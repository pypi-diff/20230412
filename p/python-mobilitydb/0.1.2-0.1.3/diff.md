# Comparing `tmp/python-mobilitydb-0.1.2.tar.gz` & `tmp/python-mobilitydb-0.1.3.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/python-mobilitydb-0.1.2.tar", last modified: Thu Apr 29 14:28:46 2021, max compression
+gzip compressed data, was "python-mobilitydb-0.1.3.tar", last modified: Wed Apr 12 12:36:20 2023, max compression
```

## Comparing `python-mobilitydb-0.1.2.tar` & `python-mobilitydb-0.1.3.tar`

### file list

```diff
@@ -1,93 +1,93 @@
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5454 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/PKG-INFO
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     3388 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/README.md
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/tests/
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/tests/asyncpg/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    11709 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_tgeompoint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4973 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_time.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5165 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_ttext.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    11709 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_tgeogpoint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     3386 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/conftest.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5243 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_tbool.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     6411 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_tfloat.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     2544 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_tbox.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5092 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_tint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4283 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/test_stbox.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)        0 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/asyncpg/__init__.py
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/tests/psycopg/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    28555 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_tgeompoint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     8459 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_time.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    19904 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_ttext.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    28320 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_tgeogpoint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     3319 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/conftest.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    19416 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_tbool.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    21781 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_tfloat.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     2440 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_tbox.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    19685 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_tint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4182 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/test_stbox.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)      286 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/psycopg/__init__.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)        0 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/tests/__init__.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)       79 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/setup.cfg
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/python_mobilitydb.egg-info/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)       17 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/python_mobilitydb.egg-info/top_level.txt
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     2480 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/python_mobilitydb.egg-info/SOURCES.txt
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5454 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/python_mobilitydb.egg-info/PKG-INFO
--rw-rw-r--   0 maxime    (1001) maxime    (1001)       83 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/python_mobilitydb.egg-info/requires.txt
--rw-rw-r--   0 maxime    (1001) maxime    (1001)        1 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/python_mobilitydb.egg-info/dependency_links.txt
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     1652 2021-04-29 14:27:25.000000 python-mobilitydb-0.1.2/setup.py
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/mobilitydb/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4068 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     3106 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/asyncpg.py
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5723 2021-04-28 14:37:17.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/tinstantset.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     6432 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/temporal.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     9024 2021-04-28 14:38:05.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/tsequence.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     6874 2021-04-28 14:36:56.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/tinstant.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     2841 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/temporal_parser.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4212 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/temporalinstants.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    11254 2021-04-28 14:39:27.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/tsequenceset.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)      318 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/temporal/__init__.py
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/mobilitydb/time/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7087 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/time/timestampset.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     8491 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/time/periodset.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    10387 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/time/period.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)      150 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/time/__init__.py
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/mobilitydb/boxes/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    12799 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/boxes/stbox.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7004 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/boxes/tbox.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)       77 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/boxes/__init__.py
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/mobilitydb/examples/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5819 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/time_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4379 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/box_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     6926 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/ttext.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7245 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tint_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     1775 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/db_connect.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7088 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tbool_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     5607 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/time_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7273 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tgeogpoint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    11535 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tfloat.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7280 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/ttext_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7064 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/ttext_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7317 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tfloat_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7461 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tgeompoint_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7244 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tgeogpoint_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4040 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/box.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7113 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tfloat_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7302 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7232 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tint_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7244 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tgeompoint_psycopg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7346 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tgeompoint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7312 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/time.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7461 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tgeogpoint_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7057 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tbool.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     4377 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/box_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7283 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/tbool_asyncpg.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)        0 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/examples/__init__.py
-drwxrwxr-x   0 maxime    (1001) maxime    (1001)        0 2021-04-29 14:28:46.000000 python-mobilitydb-0.1.2/mobilitydb/main/
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7993 2021-04-28 14:48:03.000000 python-mobilitydb-0.1.2/mobilitydb/main/ttext.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    10947 2021-04-28 14:42:54.000000 python-mobilitydb-0.1.2/mobilitydb/main/tfloat.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)    34519 2021-04-28 14:56:07.000000 python-mobilitydb-0.1.2/mobilitydb/main/tpoint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     7023 2021-04-28 14:43:44.000000 python-mobilitydb-0.1.2/mobilitydb/main/tint.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     8357 2021-04-28 14:45:46.000000 python-mobilitydb-0.1.2/mobilitydb/main/tbool.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)     1093 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/main/__init__.py
--rw-rw-r--   0 maxime    (1001) maxime    (1001)      837 2021-04-28 14:28:39.000000 python-mobilitydb-0.1.2/mobilitydb/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.110831 python-mobilitydb-0.1.3/
+-rw-rw-rw-   0        0        0     4960 2023-04-12 12:36:20.110831 python-mobilitydb-0.1.3/PKG-INFO
+-rw-rw-rw-   0        0        0     3785 2023-04-12 12:30:20.000000 python-mobilitydb-0.1.3/README.md
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.061832 python-mobilitydb-0.1.3/mobilitydb/
+-rw-rw-rw-   0        0        0     1130 2023-04-12 12:28:36.000000 python-mobilitydb-0.1.3/mobilitydb/__init__.py
+-rw-rw-rw-   0        0        0     3161 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/asyncpg.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.063831 python-mobilitydb-0.1.3/mobilitydb/boxes/
+-rw-rw-rw-   0        0        0       81 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/boxes/__init__.py
+-rw-rw-rw-   0        0        0    13105 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/boxes/stbox.py
+-rw-rw-rw-   0        0        0     7197 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/boxes/tbox.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.079831 python-mobilitydb-0.1.3/mobilitydb/examples/
+-rw-rw-rw-   0        0        0        0 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/__init__.py
+-rw-rw-rw-   0        0        0     4154 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/box.py
+-rw-rw-rw-   0        0        0     4497 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/box_asyncpg.py
+-rw-rw-rw-   0        0        0     4510 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/box_psycopg.py
+-rw-rw-rw-   0        0        0     1816 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/db_connect.py
+-rw-rw-rw-   0        0        0     7329 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tbool.py
+-rw-rw-rw-   0        0        0     7475 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tbool_asyncpg.py
+-rw-rw-rw-   0        0        0     7300 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tbool_psycopg.py
+-rw-rw-rw-   0        0        0    11900 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tfloat.py
+-rw-rw-rw-   0        0        0     7511 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tfloat_asyncpg.py
+-rw-rw-rw-   0        0        0     7324 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tfloat_psycopg.py
+-rw-rw-rw-   0        0        0     7537 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tgeogpoint.py
+-rw-rw-rw-   0        0        0     7655 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tgeogpoint_asyncpg.py
+-rw-rw-rw-   0        0        0     7455 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tgeogpoint_psycopg.py
+-rw-rw-rw-   0        0        0     7612 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tgeompoint.py
+-rw-rw-rw-   0        0        0     7655 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tgeompoint_asyncpg.py
+-rw-rw-rw-   0        0        0     7455 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tgeompoint_psycopg.py
+-rw-rw-rw-   0        0        0     7522 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/time.py
+-rw-rw-rw-   0        0        0     5975 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/time_asyncpg.py
+-rw-rw-rw-   0        0        0     5775 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/time_psycopg.py
+-rw-rw-rw-   0        0        0     7590 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tint.py
+-rw-rw-rw-   0        0        0     7439 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tint_asyncpg.py
+-rw-rw-rw-   0        0        0     7443 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/tint_psycopg.py
+-rw-rw-rw-   0        0        0     7196 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/ttext.py
+-rw-rw-rw-   0        0        0     7473 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/ttext_asyncpg.py
+-rw-rw-rw-   0        0        0     7275 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/examples/ttext_psycopg.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.083831 python-mobilitydb-0.1.3/mobilitydb/main/
+-rw-rw-rw-   0        0        0     1108 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/main/__init__.py
+-rw-rw-rw-   0        0        0     8566 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/main/tbool.py
+-rw-rw-rw-   0        0        0    11216 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/main/tfloat.py
+-rw-rw-rw-   0        0        0     7209 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/main/tint.py
+-rw-rw-rw-   0        0        0    35242 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/main/tpoint.py
+-rw-rw-rw-   0        0        0     8196 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/main/ttext.py
+-rw-rw-rw-   0        0        0     4161 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/psycopg.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.089831 python-mobilitydb-0.1.3/mobilitydb/temporal/
+-rw-rw-rw-   0        0        0      326 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/__init__.py
+-rw-rw-rw-   0        0        0     6720 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/temporal.py
+-rw-rw-rw-   0        0        0     2920 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/temporal_parser.py
+-rw-rw-rw-   0        0        0     4370 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/temporalinstants.py
+-rw-rw-rw-   0        0        0     7135 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/tinstant.py
+-rw-rw-rw-   0        0        0     5875 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/tinstantset.py
+-rw-rw-rw-   0        0        0     9264 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/tsequence.py
+-rw-rw-rw-   0        0        0    11599 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/temporal/tsequenceset.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.091831 python-mobilitydb-0.1.3/mobilitydb/time/
+-rw-rw-rw-   0        0        0      155 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/time/__init__.py
+-rw-rw-rw-   0        0        0    10668 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/time/period.py
+-rw-rw-rw-   0        0        0     8743 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/time/periodset.py
+-rw-rw-rw-   0        0        0     7282 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/mobilitydb/time/timestampset.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.095831 python-mobilitydb-0.1.3/python_mobilitydb.egg-info/
+-rw-rw-rw-   0        0        0     4960 2023-04-12 12:36:20.000000 python-mobilitydb-0.1.3/python_mobilitydb.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     2480 2023-04-12 12:36:20.000000 python-mobilitydb-0.1.3/python_mobilitydb.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-04-12 12:36:20.000000 python-mobilitydb-0.1.3/python_mobilitydb.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       83 2023-04-12 12:36:20.000000 python-mobilitydb-0.1.3/python_mobilitydb.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       17 2023-04-12 12:36:20.000000 python-mobilitydb-0.1.3/python_mobilitydb.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       86 2023-04-12 12:36:20.112831 python-mobilitydb-0.1.3/setup.cfg
+-rw-rw-rw-   0        0        0     1701 2023-04-12 12:33:41.000000 python-mobilitydb-0.1.3/setup.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.095831 python-mobilitydb-0.1.3/tests/
+-rw-rw-rw-   0        0        0        0 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.102831 python-mobilitydb-0.1.3/tests/asyncpg/
+-rw-rw-rw-   0        0        0        0 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/__init__.py
+-rw-rw-rw-   0        0        0     3470 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/conftest.py
+-rw-rw-rw-   0        0        0     4364 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_stbox.py
+-rw-rw-rw-   0        0        0     5344 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_tbool.py
+-rw-rw-rw-   0        0        0     2600 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_tbox.py
+-rw-rw-rw-   0        0        0     6525 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_tfloat.py
+-rw-rw-rw-   0        0        0    11892 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_tgeogpoint.py
+-rw-rw-rw-   0        0        0    11892 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_tgeompoint.py
+-rw-rw-rw-   0        0        0     5068 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_time.py
+-rw-rw-rw-   0        0        0     5193 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_tint.py
+-rw-rw-rw-   0        0        0     5266 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/asyncpg/test_ttext.py
+drwxrwxrwx   0        0        0        0 2023-04-12 12:36:20.110831 python-mobilitydb-0.1.3/tests/psycopg/
+-rw-rw-rw-   0        0        0      289 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/__init__.py
+-rw-rw-rw-   0        0        0     3399 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/conftest.py
+-rw-rw-rw-   0        0        0     4262 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_stbox.py
+-rw-rw-rw-   0        0        0    19708 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_tbool.py
+-rw-rw-rw-   0        0        0     2494 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_tbox.py
+-rw-rw-rw-   0        0        0    22095 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_tfloat.py
+-rw-rw-rw-   0        0        0    28718 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_tgeogpoint.py
+-rw-rw-rw-   0        0        0    28957 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_tgeompoint.py
+-rw-rw-rw-   0        0        0     8607 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_time.py
+-rw-rw-rw-   0        0        0    19994 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_tint.py
+-rw-rw-rw-   0        0        0    20207 2023-04-12 12:18:50.000000 python-mobilitydb-0.1.3/tests/psycopg/test_ttext.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `python-mobilitydb-0.1.2/README.md` & `python-mobilitydb-0.1.3/README.md`

 * *Files 21% similar despite different names*

```diff
@@ -1,115 +1,118 @@
-# MobilityDB-python
-MobilityDB-python is a database adapter to access [MobilityDB](https://github.com/MobilityDB/MobilityDB) from Python. It supports both the [psycopg2](https://github.com/psycopg/psycopg2) and the [asyncpg](https://github.com/MagicStack/asyncpg) adapters for PostgreSQL and uses the [postgis](https://github.com/tilery/python-postgis) adapter for PostGIS.
-
-
-Install
-------------
-```sh
-pip install python-mobilitydb
-```
-
-Requirements
-------------
- - Python >= 3.0
- - MobilityDB
-
-Basic Usage
-------------
-
-Using the psycopg2 adapter for PostgreSQL
-
-```python
-import psycopg2
-from mobilitydb.psycopg import register
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg2.connect(host='localhost', database='test', user='user', password='pw')
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    # Open a cursor to perform database operations
-    cursor = connection.cursor()
-
-    # Query the database and obtain data as Python objects
-    select_query = "SELECT * FROM tbl_tfloatseq ORDER BY k LIMIT 10"
-    cursor.execute(select_query)
-    rows = cursor.fetchall()
-
-    # Print the obtained rows and call a method on the instances
-    for row in rows:
-        print("key =", row[0])
-        print("tfloatseq =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp(), "\n")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-    # Close the connection
-    if connection:
-        connection.close()
-```
-
-Using the asyncg adapter for PostgreSQL
-
-```python
-import asyncio
-import asyncpg
-from mobilitydb.asyncpg import register
-
-
-async def run():
-    # Connect to an existing database
-    connection = await asyncpg.connect(host='localhost', database='test', user='user', password='pw')
-
-    try:
-        # Register MobilityDB data types
-        await register(connection)
-
-        # Query the database and obtain data as Python objects
-        select_query = "SELECT * FROM tbl_tgeompointseq ORDER BY k LIMIT 10"
-        rows = await connection.fetch(select_query)
-
-        # Print the obtained rows and call a method on the instances
-        for row in rows:
-            print("key =", row[0])
-            print("tgeompointseq =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp(), "\n")
-    finally:
-        # Close the connection
-        await connection.close()
-
-# Launch the process
-loop = asyncio.get_event_loop()
-loop.run_until_complete(run())
-```
-
-Manual
-------
-
-HTML: https://docs.mobilitydb.com/MobilityDB-python/master/
-
-PDF: https://docs.mobilitydb.com/MobilityDB-python/master/python-mobilitydb.pdf
-
-EPUB: https://docs.mobilitydb.com/MobilityDB-python/master/python-mobilitydb.epub
-
-Contributing
-------------
-
-[Issues](https://github.com/MobilityDB/MobilityDB-python/issues) and [Pull Requests](https://github.com/MobilityDB/MobilityDB-python/pulls) are welcome.
-
-Related Project
----------------
-
-[MobilityDB SQLAlchemy](https://github.com/adonmo/mobilitydb-sqlalchemy) is another package that provides extensions to [SQLAlchemy](https://www.sqlalchemy.org/) for interacting with [MobilityDB](https://github.com/MobilityDB/MobilityDB). 
+# MobilityDB-python
+MobilityDB-python is a database adapter to access [MobilityDB](https://github.com/MobilityDB/MobilityDB) from Python. It supports both the [psycopg2](https://github.com/psycopg/psycopg2) and the [asyncpg](https://github.com/MagicStack/asyncpg) adapters for PostgreSQL and uses the [postgis](https://github.com/tilery/python-postgis) adapter for PostGIS.
+
+## Deprecation Notice :warning:
+This package is no longer maintained. Instead, we recommend using the [PyMEOS package](https://pypi.org/project/pymeos/), 
+which provides a Python interface to the MEOS C library, which is the underlying library of MobilityDB.
+
+Install
+------------
+```sh
+pip install python-mobilitydb
+```
+
+Requirements
+------------
+ - Python >= 3.0
+ - MobilityDB
+
+Basic Usage
+------------
+
+Using the psycopg2 adapter for PostgreSQL
+
+```python
+import psycopg2
+from mobilitydb.psycopg import register
+
+connection = None
+
+try:
+    # Set the connection parameters to PostgreSQL
+    connection = psycopg2.connect(host='localhost', database='test', user='user', password='pw')
+    connection.autocommit = True
+
+    # Register MobilityDB data types
+    register(connection)
+
+    # Open a cursor to perform database operations
+    cursor = connection.cursor()
+
+    # Query the database and obtain data as Python objects
+    select_query = "SELECT * FROM tbl_tfloatseq ORDER BY k LIMIT 10"
+    cursor.execute(select_query)
+    rows = cursor.fetchall()
+
+    # Print the obtained rows and call a method on the instances
+    for row in rows:
+        print("key =", row[0])
+        print("tfloatseq =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp.isoformat(), "\n")
+
+except (Exception, psycopg2.Error) as error:
+    print("Error while connecting to PostgreSQL", error)
+
+finally:
+    # Close the connection
+    if connection:
+        connection.close()
+```
+
+Using the asyncg adapter for PostgreSQL
+
+```python
+import asyncio
+import asyncpg
+from mobilitydb.asyncpg import register
+
+
+async def run():
+    # Connect to an existing database
+    connection = await asyncpg.connect(host='localhost', database='test', user='user', password='pw')
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        # Query the database and obtain data as Python objects
+        select_query = "SELECT * FROM tbl_tgeompointseq ORDER BY k LIMIT 10"
+        rows = await connection.fetch(select_query)
+
+        # Print the obtained rows and call a method on the instances
+        for row in rows:
+            print("key =", row[0])
+            print("tgeompointseq =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp.isoformat(), "\n")
+    finally:
+        # Close the connection
+        await connection.close()
+
+# Launch the process
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+```
+
+Manual
+------
+
+HTML: https://docs.mobilitydb.com/MobilityDB-python/master/
+
+PDF: https://docs.mobilitydb.com/MobilityDB-python/master/python-mobilitydb.pdf
+
+EPUB: https://docs.mobilitydb.com/MobilityDB-python/master/python-mobilitydb.epub
+
+Contributing
+------------
+
+[Issues](https://github.com/MobilityDB/MobilityDB-python/issues) and [Pull Requests](https://github.com/MobilityDB/MobilityDB-python/pulls) are welcome.
+
+Related Project
+---------------
+
+[MobilityDB SQLAlchemy](https://github.com/adonmo/mobilitydb-sqlalchemy) is another package that provides extensions to [SQLAlchemy](https://www.sqlalchemy.org/) for interacting with [MobilityDB](https://github.com/MobilityDB/MobilityDB).
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_tgeompoint.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_tgeompoint.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,183 +1,183 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from postgis import Point
-from mobilitydb.main import TGeomPointInst, TGeomPointInstSet, TGeomPointSeq, TGeomPointSeqSet
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_tgeompointinst', [
-    'POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-    ('POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
-    ['POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
-    ('SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
-    ['SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
-    (Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')),
-    [Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')],
-    (Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')),
-    [Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')],
-])
-async def test_tgeompointinst_constructors(connection, expected_tgeompointinst):
-    params = TGeomPointInst(expected_tgeompointinst)
-    await connection.execute('INSERT INTO tbl_tgeompointinst (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointinst WHERE temp=$1', params, column=0)
-    assert result == TGeomPointInst(expected_tgeompointinst)
-
-@pytest.mark.parametrize('expected_tgeompointinstset', [
-    '{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
-    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
-    ('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'),
-    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    ('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'),
-    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    (TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')),
-    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    (TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')),
-    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-])
-async def test_tgeompointinstset_constructor(connection, expected_tgeompointinstset):
-    if isinstance(expected_tgeompointinstset, tuple):
-        params = TGeomPointInstSet(*expected_tgeompointinstset)
-    else:
-        params = TGeomPointInstSet(expected_tgeompointinstset)
-    await connection.execute('INSERT INTO tbl_tgeompointinstset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointinstset WHERE temp=$1', params)
-    if isinstance(expected_tgeompointinstset, tuple):
-        assert result == TGeomPointInstSet(*expected_tgeompointinstset)
-    else:
-        assert result == TGeomPointInstSet(expected_tgeompointinstset)
-
-@pytest.mark.parametrize('expected_tgeompointseq', [
-    '[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise'),
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Linear', 4326),
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise', 4326),
-    ([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-    ([TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-])
-async def test_tgeompointseq_constructor(connection, expected_tgeompointseq):
-    if isinstance(expected_tgeompointseq, tuple):
-        params = TGeomPointSeq(*expected_tgeompointseq)
-    else:
-        params = TGeomPointSeq(expected_tgeompointseq)
-    await connection.execute('INSERT INTO tbl_tgeompointseq (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointseq WHERE temp=$1', params)
-    if isinstance(expected_tgeompointseq, tuple):
-        assert result == TGeomPointSeq(*expected_tgeompointseq)
-    else:
-        assert result == TGeomPointSeq(expected_tgeompointseq)
-
-@pytest.mark.parametrize('expected_tgeompointseqset', [
-    '{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'SRID=4326;Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    ['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-    ['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
-    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
-    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise'),
-    (['SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise', 4326),
-    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise', 4326),
-    [TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
-    ([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear'),
-    ([TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeomPointSeq(
-            'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
-     'Stepwise'),
-])
-async def test_tgeompointseqset_constructor(connection, expected_tgeompointseqset):
-    if isinstance(expected_tgeompointseqset, tuple):
-        params = TGeomPointSeqSet(*expected_tgeompointseqset)
-    else:
-        params = TGeomPointSeqSet(expected_tgeompointseqset)
-    await connection.execute('INSERT INTO tbl_tgeompointseqset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointseqset WHERE temp=$1', params)
-    if isinstance(expected_tgeompointseqset, tuple):
-        assert result == TGeomPointSeqSet(*expected_tgeompointseqset)
-    else:
-        assert result == TGeomPointSeqSet(expected_tgeompointseqset)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from postgis import Point
+from mobilitydb.main import TGeomPointInst, TGeomPointInstSet, TGeomPointSeq, TGeomPointSeqSet
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_tgeompointinst', [
+    'POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+    ('POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
+    ['POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
+    ('SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
+    ['SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
+    (Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')),
+    [Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')],
+    (Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')),
+    [Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')],
+])
+async def test_tgeompointinst_constructors(connection, expected_tgeompointinst):
+    params = TGeomPointInst(expected_tgeompointinst)
+    await connection.execute('INSERT INTO tbl_tgeompointinst (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointinst WHERE temp=$1', params, column=0)
+    assert result == TGeomPointInst(expected_tgeompointinst)
+
+@pytest.mark.parametrize('expected_tgeompointinstset', [
+    '{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
+    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
+    ('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'),
+    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    ('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'),
+    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    (TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')),
+    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    (TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')),
+    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+])
+async def test_tgeompointinstset_constructor(connection, expected_tgeompointinstset):
+    if isinstance(expected_tgeompointinstset, tuple):
+        params = TGeomPointInstSet(*expected_tgeompointinstset)
+    else:
+        params = TGeomPointInstSet(expected_tgeompointinstset)
+    await connection.execute('INSERT INTO tbl_tgeompointinstset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointinstset WHERE temp=$1', params)
+    if isinstance(expected_tgeompointinstset, tuple):
+        assert result == TGeomPointInstSet(*expected_tgeompointinstset)
+    else:
+        assert result == TGeomPointInstSet(expected_tgeompointinstset)
+
+@pytest.mark.parametrize('expected_tgeompointseq', [
+    '[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise'),
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Linear', 4326),
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise', 4326),
+    ([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+    ([TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+])
+async def test_tgeompointseq_constructor(connection, expected_tgeompointseq):
+    if isinstance(expected_tgeompointseq, tuple):
+        params = TGeomPointSeq(*expected_tgeompointseq)
+    else:
+        params = TGeomPointSeq(expected_tgeompointseq)
+    await connection.execute('INSERT INTO tbl_tgeompointseq (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointseq WHERE temp=$1', params)
+    if isinstance(expected_tgeompointseq, tuple):
+        assert result == TGeomPointSeq(*expected_tgeompointseq)
+    else:
+        assert result == TGeomPointSeq(expected_tgeompointseq)
+
+@pytest.mark.parametrize('expected_tgeompointseqset', [
+    '{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'SRID=4326;Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    ['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+    ['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
+    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
+    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise'),
+    (['SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise', 4326),
+    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise', 4326),
+    [TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
+    ([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear'),
+    ([TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeomPointSeq(
+            'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
+     'Stepwise'),
+])
+async def test_tgeompointseqset_constructor(connection, expected_tgeompointseqset):
+    if isinstance(expected_tgeompointseqset, tuple):
+        params = TGeomPointSeqSet(*expected_tgeompointseqset)
+    else:
+        params = TGeomPointSeqSet(expected_tgeompointseqset)
+    await connection.execute('INSERT INTO tbl_tgeompointseqset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tgeompointseqset WHERE temp=$1', params)
+    if isinstance(expected_tgeompointseqset, tuple):
+        assert result == TGeomPointSeqSet(*expected_tgeompointseqset)
+    else:
+        assert result == TGeomPointSeqSet(expected_tgeompointseqset)
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_time.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_time.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb import TimestampSet, Period, PeriodSet
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_timestampset', [
-    '{2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01, 2019-09-11 00:00:00+01}',
-    ['2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'],
-    [parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')],
-    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')),
-])
-async def test_timestampset_constructor(connection, expected_timestampset):
-    if isinstance(expected_timestampset, tuple):
-        params = TimestampSet(*expected_timestampset)
-    else:
-        params = TimestampSet(expected_timestampset)
-    await connection.execute("INSERT INTO tbl_timestampset (timetype) VALUES ($1)", params)
-    result = await connection.fetchval("SELECT timetype FROM tbl_timestampset WHERE timetype=$1", params)
-    if isinstance(expected_timestampset, tuple):
-        assert result == TimestampSet(*expected_timestampset)
-    else:
-        assert result == TimestampSet(expected_timestampset)
-
-@pytest.mark.parametrize('expected_period', [
-    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
-    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
-    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
-    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
-    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01'),
-    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', False, True),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01')),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), False, True),
-])
-async def test_period_constructor(connection, expected_period):
-    if isinstance(expected_period, tuple):
-        params = Period(*expected_period)
-    else:
-        params = Period(expected_period)
-    await connection.execute("INSERT INTO tbl_period (timetype) VALUES ($1)", params)
-    result = await connection.fetchval("SELECT timetype FROM tbl_period WHERE timetype=$1", params)
-    if isinstance(expected_period, tuple):
-        assert result == Period(*expected_period)
-    else:
-        assert result == Period(expected_period)
-
-@pytest.mark.parametrize('expected_periodset', [
-    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]}',
-    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01], [2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]}',
-    ['[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'],
-    [Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
-     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')],
-    ('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'),
-    (Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
-     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')),
-])
-async def test_periodset_constructor(connection, expected_periodset):
-    if isinstance(expected_periodset, tuple):
-        params = PeriodSet(*expected_periodset)
-    else:
-        params = PeriodSet(expected_periodset)
-    await connection.execute("INSERT INTO tbl_periodset (timetype) VALUES ($1)", params)
-    result = await connection.fetchval("SELECT timetype FROM tbl_periodset WHERE timetype=$1", params)
-    if isinstance(expected_periodset, tuple):
-        assert result == PeriodSet(*expected_periodset)
-    else:
-        assert result == PeriodSet(expected_periodset)
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb import TimestampSet, Period, PeriodSet
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_timestampset', [
+    '{2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01, 2019-09-11 00:00:00+01}',
+    ['2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'],
+    [parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')],
+    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')),
+])
+async def test_timestampset_constructor(connection, expected_timestampset):
+    if isinstance(expected_timestampset, tuple):
+        params = TimestampSet(*expected_timestampset)
+    else:
+        params = TimestampSet(expected_timestampset)
+    await connection.execute("INSERT INTO tbl_timestampset (timetype) VALUES ($1)", params)
+    result = await connection.fetchval("SELECT timetype FROM tbl_timestampset WHERE timetype=$1", params)
+    if isinstance(expected_timestampset, tuple):
+        assert result == TimestampSet(*expected_timestampset)
+    else:
+        assert result == TimestampSet(expected_timestampset)
+
+@pytest.mark.parametrize('expected_period', [
+    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
+    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
+    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
+    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
+    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01'),
+    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', False, True),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01')),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), False, True),
+])
+async def test_period_constructor(connection, expected_period):
+    if isinstance(expected_period, tuple):
+        params = Period(*expected_period)
+    else:
+        params = Period(expected_period)
+    await connection.execute("INSERT INTO tbl_period (timetype) VALUES ($1)", params)
+    result = await connection.fetchval("SELECT timetype FROM tbl_period WHERE timetype=$1", params)
+    if isinstance(expected_period, tuple):
+        assert result == Period(*expected_period)
+    else:
+        assert result == Period(expected_period)
+
+@pytest.mark.parametrize('expected_periodset', [
+    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]}',
+    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01], [2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]}',
+    ['[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'],
+    [Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
+     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')],
+    ('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'),
+    (Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
+     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')),
+])
+async def test_periodset_constructor(connection, expected_periodset):
+    if isinstance(expected_periodset, tuple):
+        params = PeriodSet(*expected_periodset)
+    else:
+        params = PeriodSet(expected_periodset)
+    await connection.execute("INSERT INTO tbl_periodset (timetype) VALUES ($1)", params)
+    result = await connection.fetchval("SELECT timetype FROM tbl_periodset WHERE timetype=$1", params)
+    if isinstance(expected_periodset, tuple):
+        assert result == PeriodSet(*expected_periodset)
+    else:
+        assert result == PeriodSet(expected_periodset)
+
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_ttext.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_ttext.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,101 +1,101 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb.main import TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_ttextinst', [
-    'AA@2019-09-01 00:00:00+01',
-    ('AA', '2019-09-08 00:00:00+01'),
-    ['AA', '2019-09-08 00:00:00+01'],
-    ('AA', parse('2019-09-08 00:00:00+01')),
-    ['AA', parse('2019-09-08 00:00:00+01')],
-])
-async def test_ttextinst_constructors(connection, expected_ttextinst):
-    params = TTextInst(expected_ttextinst)
-    await connection.execute('INSERT INTO tbl_ttextinst (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_ttextinst WHERE temp=$1', params, column=0)
-    assert result == TTextInst(expected_ttextinst)
-
-@pytest.mark.parametrize('expected_ttextinstset', [
-    '{AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01}',
-    ('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'),
-    (TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-     TTextInst('AA@2019-09-03 00:00:00+01')),
-    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'],
-    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-     TTextInst('AA@2019-09-03 00:00:00+01')],
-])
-async def test_ttextinstset_constructor(connection, expected_ttextinstset):
-    if isinstance(expected_ttextinstset, tuple):
-        params = TTextInstSet(*expected_ttextinstset)
-    else:
-        params = TTextInstSet(expected_ttextinstset)
-    await connection.execute('INSERT INTO tbl_ttextinstset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_ttextinstset WHERE temp=$1', params)
-    if isinstance(expected_ttextinstset, tuple):
-        assert result == TTextInstSet(*expected_ttextinstset)
-    else:
-        assert result == TTextInstSet(expected_ttextinstset)
-
-@pytest.mark.parametrize('expected_ttextseq', [
-    '[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]',
-    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'BB@2019-09-03 00:00:00+01'],
-    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-     TTextInst('BB@2019-09-03 00:00:00+01')],
-])
-async def test_ttextseq_constructor(connection, expected_ttextseq):
-    if isinstance(expected_ttextseq, tuple):
-        params = TTextSeq(*expected_ttextseq)
-    else:
-        params = TTextSeq(expected_ttextseq)
-    await connection.execute('INSERT INTO tbl_ttextseq (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_ttextseq WHERE temp=$1', params)
-    if isinstance(expected_ttextseq, tuple):
-        assert result == TTextSeq(*expected_ttextseq)
-    else:
-        assert result == TTextSeq(expected_ttextseq)
-
-@pytest.mark.parametrize('expected_ttextseqset', [
-    '{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}',
-    ['[AA@2019-09-01 00:00:00+01]', '[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]'],
-    [TTextSeq('[AA@2019-09-01 00:00:00+01]'),
-     TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')],
-])
-async def test_ttextseqset_constructor(connection, expected_ttextseqset):
-    if isinstance(expected_ttextseqset, tuple):
-        params = TTextSeqSet(*expected_ttextseqset)
-    else:
-        params = TTextSeqSet(expected_ttextseqset)
-    await connection.execute('INSERT INTO tbl_ttextseqset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_ttextseqset WHERE temp=$1', params)
-    if isinstance(expected_ttextseqset, tuple):
-        assert result == TTextSeqSet(*expected_ttextseqset)
-    else:
-        assert result == TTextSeqSet(expected_ttextseqset)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb.main import TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_ttextinst', [
+    'AA@2019-09-01 00:00:00+01',
+    ('AA', '2019-09-08 00:00:00+01'),
+    ['AA', '2019-09-08 00:00:00+01'],
+    ('AA', parse('2019-09-08 00:00:00+01')),
+    ['AA', parse('2019-09-08 00:00:00+01')],
+])
+async def test_ttextinst_constructors(connection, expected_ttextinst):
+    params = TTextInst(expected_ttextinst)
+    await connection.execute('INSERT INTO tbl_ttextinst (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_ttextinst WHERE temp=$1', params, column=0)
+    assert result == TTextInst(expected_ttextinst)
+
+@pytest.mark.parametrize('expected_ttextinstset', [
+    '{AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01}',
+    ('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'),
+    (TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+     TTextInst('AA@2019-09-03 00:00:00+01')),
+    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'],
+    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+     TTextInst('AA@2019-09-03 00:00:00+01')],
+])
+async def test_ttextinstset_constructor(connection, expected_ttextinstset):
+    if isinstance(expected_ttextinstset, tuple):
+        params = TTextInstSet(*expected_ttextinstset)
+    else:
+        params = TTextInstSet(expected_ttextinstset)
+    await connection.execute('INSERT INTO tbl_ttextinstset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_ttextinstset WHERE temp=$1', params)
+    if isinstance(expected_ttextinstset, tuple):
+        assert result == TTextInstSet(*expected_ttextinstset)
+    else:
+        assert result == TTextInstSet(expected_ttextinstset)
+
+@pytest.mark.parametrize('expected_ttextseq', [
+    '[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]',
+    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'BB@2019-09-03 00:00:00+01'],
+    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+     TTextInst('BB@2019-09-03 00:00:00+01')],
+])
+async def test_ttextseq_constructor(connection, expected_ttextseq):
+    if isinstance(expected_ttextseq, tuple):
+        params = TTextSeq(*expected_ttextseq)
+    else:
+        params = TTextSeq(expected_ttextseq)
+    await connection.execute('INSERT INTO tbl_ttextseq (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_ttextseq WHERE temp=$1', params)
+    if isinstance(expected_ttextseq, tuple):
+        assert result == TTextSeq(*expected_ttextseq)
+    else:
+        assert result == TTextSeq(expected_ttextseq)
+
+@pytest.mark.parametrize('expected_ttextseqset', [
+    '{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}',
+    ['[AA@2019-09-01 00:00:00+01]', '[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]'],
+    [TTextSeq('[AA@2019-09-01 00:00:00+01]'),
+     TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')],
+])
+async def test_ttextseqset_constructor(connection, expected_ttextseqset):
+    if isinstance(expected_ttextseqset, tuple):
+        params = TTextSeqSet(*expected_ttextseqset)
+    else:
+        params = TTextSeqSet(expected_ttextseqset)
+    await connection.execute('INSERT INTO tbl_ttextseqset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_ttextseqset WHERE temp=$1', params)
+    if isinstance(expected_ttextseqset, tuple):
+        assert result == TTextSeqSet(*expected_ttextseqset)
+    else:
+        assert result == TTextSeqSet(expected_ttextseqset)
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/conftest.py` & `python-mobilitydb-0.1.3/tests/asyncpg/conftest.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,84 +1,84 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncpg
-import pytest
-import os
-from mobilitydb import *
-from mobilitydb.asyncpg import register
-
-
-time_types = [TimestampSet, Period, PeriodSet]
-box_types = [TBox, STBox]
-subtype_suffixes = ['Inst', 'InstSet', 'Seq', 'SeqSet']
-subtype_names = ['INSTANT', 'INSTANTSET', 'SEQUENCE', 'SEQUENCESET']
-temporal_types = [TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint]
-
-
-@pytest.fixture
-async def connection():
-    conn = await asyncpg.connect(database=os.getenv('PGDATABASE', 'test'))
-    await register(conn)
-    for time in time_types:
-        await conn.execute(
-            'CREATE TABLE IF NOT EXISTS tbl_' + time.__name__.lower() +
-            '(timetype ' + time.__name__.lower() + ' NOT NULL);')
-    for box in box_types:
-        await conn.execute(
-            'CREATE TABLE IF NOT EXISTS tbl_' + box.__name__.lower() +
-            '(box ' + box.__name__.lower() + ' NOT NULL);')
-    for ttype in temporal_types:
-        for suffix, name in zip(subtype_suffixes, subtype_names):
-            await conn.execute(
-                'CREATE TABLE IF NOT EXISTS tbl_' + ttype.__name__.lower() + suffix +
-                '(temp ' + ttype.__name__.lower() + '(' + name + ') NOT NULL);')
-    yield conn
-    await conn.close()
-
-"""
-def pytest_unconfigure():
-    for time in time_types:
-        cur.execute(
-            'DROP TABLE tbl_' + time.__name__.lower() + ';')
-    for box in box_types:
-        cur.execute(
-            'DROP TABLE tbl_' + box.__name__.lower() + ';')
-    for ttype, suffix in zip(temporal_types, subtype_suffixes):
-        cur.execute('DROP TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
-
-
-@pytest.fixture
-def cursor():
-    # Make sure tables are clean.
-    for time in time_types:
-        cur.execute('TRUNCATE TABLE tbl_' + time.__name__.lower() + ';')
-    for box in box_types:
-        cur.execute('TRUNCATE TABLE tbl_' + box.__name__.lower() + ';')
-    for ttype in temporal_types:
-        for suffix in subtype_suffixes:
-            cur.execute('TRUNCATE TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
-    return cur
-"""
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncpg
+import pytest
+import os
+from mobilitydb import *
+from mobilitydb.asyncpg import register
+
+
+time_types = [TimestampSet, Period, PeriodSet]
+box_types = [TBox, STBox]
+subtype_suffixes = ['Inst', 'InstSet', 'Seq', 'SeqSet']
+subtype_names = ['INSTANT', 'INSTANTSET', 'SEQUENCE', 'SEQUENCESET']
+temporal_types = [TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint]
+
+
+@pytest.fixture
+async def connection():
+    conn = await asyncpg.connect(database=os.getenv('PGDATABASE', 'test'))
+    await register(conn)
+    for time in time_types:
+        await conn.execute(
+            'CREATE TABLE IF NOT EXISTS tbl_' + time.__name__.lower() +
+            '(timetype ' + time.__name__.lower() + ' NOT NULL);')
+    for box in box_types:
+        await conn.execute(
+            'CREATE TABLE IF NOT EXISTS tbl_' + box.__name__.lower() +
+            '(box ' + box.__name__.lower() + ' NOT NULL);')
+    for ttype in temporal_types:
+        for suffix, name in zip(subtype_suffixes, subtype_names):
+            await conn.execute(
+                'CREATE TABLE IF NOT EXISTS tbl_' + ttype.__name__.lower() + suffix +
+                '(temp ' + ttype.__name__.lower() + '(' + name + ') NOT NULL);')
+    yield conn
+    await conn.close()
+
+"""
+def pytest_unconfigure():
+    for time in time_types:
+        cur.execute(
+            'DROP TABLE tbl_' + time.__name__.lower() + ';')
+    for box in box_types:
+        cur.execute(
+            'DROP TABLE tbl_' + box.__name__.lower() + ';')
+    for ttype, suffix in zip(temporal_types, subtype_suffixes):
+        cur.execute('DROP TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
+
+
+@pytest.fixture
+def cursor():
+    # Make sure tables are clean.
+    for time in time_types:
+        cur.execute('TRUNCATE TABLE tbl_' + time.__name__.lower() + ';')
+    for box in box_types:
+        cur.execute('TRUNCATE TABLE tbl_' + box.__name__.lower() + ';')
+    for ttype in temporal_types:
+        for suffix in subtype_suffixes:
+            cur.execute('TRUNCATE TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
+    return cur
+"""
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_tbool.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_tbool.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,101 +1,101 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb.main import TBoolInst, TBoolInstSet, TBoolSeq, TBoolSeqSet
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_tboolinst', [
-    'true@2019-09-01 00:00:00+01',
-    ('true', '2019-09-08 00:00:00+01'),
-    ['true', '2019-09-08 00:00:00+01'],
-    (True, '2019-09-08 00:00:00+01'),
-    [True, parse('2019-09-08 00:00:00+01')],
-])
-async def test_tboolinst_constructors(connection, expected_tboolinst):
-    params = TBoolInst(expected_tboolinst)
-    await connection.execute('INSERT INTO tbl_tboolinst (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tboolinst WHERE temp=$1', params, column=0)
-    assert result == TBoolInst(expected_tboolinst)
-
-@pytest.mark.parametrize('expected_tboolinstset', [
-    '{true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01}',
-    ('true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'),
-    (TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-     TBoolInst('true@2019-09-03 00:00:00+01')),
-    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'],
-    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-     TBoolInst('true@2019-09-03 00:00:00+01')],
-])
-async def test_tboolinstset_constructor(connection, expected_tboolinstset):
-    if isinstance(expected_tboolinstset, tuple):
-        params = TBoolInstSet(*expected_tboolinstset)
-    else:
-        params = TBoolInstSet(expected_tboolinstset)
-    await connection.execute('INSERT INTO tbl_tboolinstset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tboolinstset WHERE temp=$1', params)
-    if isinstance(expected_tboolinstset, tuple):
-        assert result == TBoolInstSet(*expected_tboolinstset)
-    else:
-        assert result == TBoolInstSet(expected_tboolinstset)
-
-@pytest.mark.parametrize('expected_tboolseq', [
-    '[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]',
-    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'false@2019-09-03 00:00:00+01'],
-    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-     TBoolInst('false@2019-09-03 00:00:00+01')],
-])
-async def test_tboolseq_constructor(connection, expected_tboolseq):
-    if isinstance(expected_tboolseq, tuple):
-        params = TBoolSeq(*expected_tboolseq)
-    else:
-        params = TBoolSeq(expected_tboolseq)
-    await connection.execute('INSERT INTO tbl_tboolseq (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tboolseq WHERE temp=$1', params)
-    if isinstance(expected_tboolseq, tuple):
-        assert result == TBoolSeq(*expected_tboolseq)
-    else:
-        assert result == TBoolSeq(expected_tboolseq)
-
-@pytest.mark.parametrize('expected_tboolseqset', [
-    '{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
-    ['[true@2019-09-01 00:00:00+01]', '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]'],
-    [TBoolSeq('[true@2019-09-01 00:00:00+01]'),
-     TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')],
-])
-async def test_tboolseqset_constructor(connection, expected_tboolseqset):
-    if isinstance(expected_tboolseqset, tuple):
-        params = TBoolSeqSet(*expected_tboolseqset)
-    else:
-        params = TBoolSeqSet(expected_tboolseqset)
-    await connection.execute('INSERT INTO tbl_tboolseqset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tboolseqset WHERE temp=$1', params)
-    if isinstance(expected_tboolseqset, tuple):
-        assert result == TBoolSeqSet(*expected_tboolseqset)
-    else:
-        assert result == TBoolSeqSet(expected_tboolseqset)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb.main import TBoolInst, TBoolInstSet, TBoolSeq, TBoolSeqSet
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_tboolinst', [
+    'true@2019-09-01 00:00:00+01',
+    ('true', '2019-09-08 00:00:00+01'),
+    ['true', '2019-09-08 00:00:00+01'],
+    (True, '2019-09-08 00:00:00+01'),
+    [True, parse('2019-09-08 00:00:00+01')],
+])
+async def test_tboolinst_constructors(connection, expected_tboolinst):
+    params = TBoolInst(expected_tboolinst)
+    await connection.execute('INSERT INTO tbl_tboolinst (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tboolinst WHERE temp=$1', params, column=0)
+    assert result == TBoolInst(expected_tboolinst)
+
+@pytest.mark.parametrize('expected_tboolinstset', [
+    '{true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01}',
+    ('true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'),
+    (TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+     TBoolInst('true@2019-09-03 00:00:00+01')),
+    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'],
+    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+     TBoolInst('true@2019-09-03 00:00:00+01')],
+])
+async def test_tboolinstset_constructor(connection, expected_tboolinstset):
+    if isinstance(expected_tboolinstset, tuple):
+        params = TBoolInstSet(*expected_tboolinstset)
+    else:
+        params = TBoolInstSet(expected_tboolinstset)
+    await connection.execute('INSERT INTO tbl_tboolinstset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tboolinstset WHERE temp=$1', params)
+    if isinstance(expected_tboolinstset, tuple):
+        assert result == TBoolInstSet(*expected_tboolinstset)
+    else:
+        assert result == TBoolInstSet(expected_tboolinstset)
+
+@pytest.mark.parametrize('expected_tboolseq', [
+    '[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]',
+    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'false@2019-09-03 00:00:00+01'],
+    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+     TBoolInst('false@2019-09-03 00:00:00+01')],
+])
+async def test_tboolseq_constructor(connection, expected_tboolseq):
+    if isinstance(expected_tboolseq, tuple):
+        params = TBoolSeq(*expected_tboolseq)
+    else:
+        params = TBoolSeq(expected_tboolseq)
+    await connection.execute('INSERT INTO tbl_tboolseq (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tboolseq WHERE temp=$1', params)
+    if isinstance(expected_tboolseq, tuple):
+        assert result == TBoolSeq(*expected_tboolseq)
+    else:
+        assert result == TBoolSeq(expected_tboolseq)
+
+@pytest.mark.parametrize('expected_tboolseqset', [
+    '{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
+    ['[true@2019-09-01 00:00:00+01]', '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]'],
+    [TBoolSeq('[true@2019-09-01 00:00:00+01]'),
+     TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')],
+])
+async def test_tboolseqset_constructor(connection, expected_tboolseqset):
+    if isinstance(expected_tboolseqset, tuple):
+        params = TBoolSeqSet(*expected_tboolseqset)
+    else:
+        params = TBoolSeqSet(expected_tboolseqset)
+    await connection.execute('INSERT INTO tbl_tboolseqset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tboolseqset WHERE temp=$1', params)
+    if isinstance(expected_tboolseqset, tuple):
+        assert result == TBoolSeqSet(*expected_tboolseqset)
+    else:
+        assert result == TBoolSeqSet(expected_tboolseqset)
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_tfloat.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_tfloat.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,114 +1,114 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb.main import TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_tfloatinst', [
-    '10.0@2019-09-01 00:00:00+01',
-    ('10.0', '2019-09-08 00:00:00+01'),
-    ['10.0', '2019-09-08 00:00:00+01'],
-    (10.0, parse('2019-09-08 00:00:00+01')),
-    [10.0, parse('2019-09-08 00:00:00+01')],
-])
-async def test_tfloatinst_constructors(connection, expected_tfloatinst):
-    params = TFloatInst(expected_tfloatinst)
-    await connection.execute('INSERT INTO tbl_tfloatinst (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tfloatinst WHERE temp=$1', params, column=0)
-    assert result == TFloatInst(expected_tfloatinst)
-
-@pytest.mark.parametrize('expected_tfloatinstset', [
-    '{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01}',
-    ('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'),
-    (TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-     TFloatInst('10.0@2019-09-03 00:00:00+01')),
-    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
-    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-     TFloatInst('10.0@2019-09-03 00:00:00+01')],
-])
-async def test_tfloatinstseq_constructor(connection, expected_tfloatinstset):
-    if isinstance(expected_tfloatinstset, tuple):
-        params = TFloatInstSet(*expected_tfloatinstset)
-    else:
-        params = TFloatInstSet(expected_tfloatinstset)
-    await connection.execute('INSERT INTO tbl_tfloatinstset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tfloatinstset WHERE temp=$1', params)
-    if isinstance(expected_tfloatinstset, tuple):
-        assert result == TFloatInstSet(*expected_tfloatinstset)
-    else:
-        assert result == TFloatInstSet(expected_tfloatinstset)
-
-@pytest.mark.parametrize('expected_tfloatseq', [
-    '[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
-    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
-    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-     TFloatInst('10.0@2019-09-03 00:00:00+01')],
-    (['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True,
-     'Stepwise'),
-    ([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-      TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-])
-async def test_tfloatseq_constructor(connection, expected_tfloatseq):
-    if isinstance(expected_tfloatseq, tuple):
-        params = TFloatSeq(*expected_tfloatseq)
-    else:
-        params = TFloatSeq(expected_tfloatseq)
-    await connection.execute('INSERT INTO tbl_tfloatseq (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tfloatseq WHERE temp=$1', params)
-    if isinstance(expected_tfloatseq, tuple):
-        assert result == TFloatSeq(*expected_tfloatseq)
-    else:
-        assert result == TFloatSeq(expected_tfloatseq)
-
-@pytest.mark.parametrize('expected_tfloatseqset', [
-    '{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
-    ['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'],
-    (['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]',
-      'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise'),
-    [TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
-     TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')],
-    ([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
-      TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear'),
-    ([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'),
-      TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise'),
-])
-async def test_tfloatseqset_constructor(connection, expected_tfloatseqset):
-    if isinstance(expected_tfloatseqset, tuple):
-        params = TFloatSeqSet(*expected_tfloatseqset)
-    else:
-        params = TFloatSeqSet(expected_tfloatseqset)
-    await connection.execute('INSERT INTO tbl_tfloatseqset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tfloatseqset WHERE temp=$1', params)
-    if isinstance(expected_tfloatseqset, tuple):
-        assert result == TFloatSeqSet(*expected_tfloatseqset)
-    else:
-        assert result == TFloatSeqSet(expected_tfloatseqset)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb.main import TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_tfloatinst', [
+    '10.0@2019-09-01 00:00:00+01',
+    ('10.0', '2019-09-08 00:00:00+01'),
+    ['10.0', '2019-09-08 00:00:00+01'],
+    (10.0, parse('2019-09-08 00:00:00+01')),
+    [10.0, parse('2019-09-08 00:00:00+01')],
+])
+async def test_tfloatinst_constructors(connection, expected_tfloatinst):
+    params = TFloatInst(expected_tfloatinst)
+    await connection.execute('INSERT INTO tbl_tfloatinst (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tfloatinst WHERE temp=$1', params, column=0)
+    assert result == TFloatInst(expected_tfloatinst)
+
+@pytest.mark.parametrize('expected_tfloatinstset', [
+    '{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01}',
+    ('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'),
+    (TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+     TFloatInst('10.0@2019-09-03 00:00:00+01')),
+    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
+    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+     TFloatInst('10.0@2019-09-03 00:00:00+01')],
+])
+async def test_tfloatinstseq_constructor(connection, expected_tfloatinstset):
+    if isinstance(expected_tfloatinstset, tuple):
+        params = TFloatInstSet(*expected_tfloatinstset)
+    else:
+        params = TFloatInstSet(expected_tfloatinstset)
+    await connection.execute('INSERT INTO tbl_tfloatinstset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tfloatinstset WHERE temp=$1', params)
+    if isinstance(expected_tfloatinstset, tuple):
+        assert result == TFloatInstSet(*expected_tfloatinstset)
+    else:
+        assert result == TFloatInstSet(expected_tfloatinstset)
+
+@pytest.mark.parametrize('expected_tfloatseq', [
+    '[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
+    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
+    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+     TFloatInst('10.0@2019-09-03 00:00:00+01')],
+    (['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True,
+     'Stepwise'),
+    ([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+      TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+])
+async def test_tfloatseq_constructor(connection, expected_tfloatseq):
+    if isinstance(expected_tfloatseq, tuple):
+        params = TFloatSeq(*expected_tfloatseq)
+    else:
+        params = TFloatSeq(expected_tfloatseq)
+    await connection.execute('INSERT INTO tbl_tfloatseq (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tfloatseq WHERE temp=$1', params)
+    if isinstance(expected_tfloatseq, tuple):
+        assert result == TFloatSeq(*expected_tfloatseq)
+    else:
+        assert result == TFloatSeq(expected_tfloatseq)
+
+@pytest.mark.parametrize('expected_tfloatseqset', [
+    '{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
+    ['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'],
+    (['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]',
+      'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise'),
+    [TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
+     TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')],
+    ([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
+      TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear'),
+    ([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'),
+      TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise'),
+])
+async def test_tfloatseqset_constructor(connection, expected_tfloatseqset):
+    if isinstance(expected_tfloatseqset, tuple):
+        params = TFloatSeqSet(*expected_tfloatseqset)
+    else:
+        params = TFloatSeqSet(expected_tfloatseqset)
+    await connection.execute('INSERT INTO tbl_tfloatseqset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tfloatseqset WHERE temp=$1', params)
+    if isinstance(expected_tfloatseqset, tuple):
+        assert result == TFloatSeqSet(*expected_tfloatseqset)
+    else:
+        assert result == TFloatSeqSet(expected_tfloatseqset)
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_tbox.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_tbox.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb import TBox
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_tbox', [
-    'TBOX((10.0, 2019-09-08 00:00:00+02), (30.0, 2019-09-10 00:00:00+02))',
-    'TBOX((, 2019-09-08 00:00:00+02), (, 2019-09-10 00:00:00+02))',
-    'TBOX((10.0, ), (30.0, ))',
-    ('10.0', '20.0'),
-    (10.0, 20.0),
-    ('2019-09-08 00:00:00+01', '2019-09-08 00:00:00+01'),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-08 00:00:00+01')),
-    ('10.0', '2019-09-08 00:00:00+01', '20.0', '2019-09-08 00:00:00+01'),
-    (10.0, parse('2019-09-08 00:00:00+01'), 20.0, parse('2019-09-08 00:00:00+01')),
-])
-async def test_tbox_constructor(connection, expected_tbox):
-    if isinstance(expected_tbox, tuple):
-        params = TBox(*expected_tbox)
-    else:
-        params = TBox(expected_tbox)
-    print('params =',params.__class__)
-    await connection.execute("INSERT INTO tbl_tbox (box) VALUES ($1)", params)
-    print('after =',params)
-    result = await connection.fetchval("SELECT box FROM tbl_tbox WHERE box=$1", params)
-    if isinstance(expected_tbox, tuple):
-        assert result == TBox(*expected_tbox)
-    else:
-        assert result == TBox(expected_tbox)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb import TBox
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_tbox', [
+    'TBOX((10.0, 2019-09-08 00:00:00+02), (30.0, 2019-09-10 00:00:00+02))',
+    'TBOX((, 2019-09-08 00:00:00+02), (, 2019-09-10 00:00:00+02))',
+    'TBOX((10.0, ), (30.0, ))',
+    ('10.0', '20.0'),
+    (10.0, 20.0),
+    ('2019-09-08 00:00:00+01', '2019-09-08 00:00:00+01'),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-08 00:00:00+01')),
+    ('10.0', '2019-09-08 00:00:00+01', '20.0', '2019-09-08 00:00:00+01'),
+    (10.0, parse('2019-09-08 00:00:00+01'), 20.0, parse('2019-09-08 00:00:00+01')),
+])
+async def test_tbox_constructor(connection, expected_tbox):
+    if isinstance(expected_tbox, tuple):
+        params = TBox(*expected_tbox)
+    else:
+        params = TBox(expected_tbox)
+    print('params =',params.__class__)
+    await connection.execute("INSERT INTO tbl_tbox (box) VALUES ($1)", params)
+    print('after =',params)
+    result = await connection.fetchval("SELECT box FROM tbl_tbox WHERE box=$1", params)
+    if isinstance(expected_tbox, tuple):
+        assert result == TBox(*expected_tbox)
+    else:
+        assert result == TBox(expected_tbox)
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_tint.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_tint.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,101 +1,101 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb.main import TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_tintinst', [
-    '10@2019-09-01 00:00:00+01',
-    ('10', '2019-09-08 00:00:00+01'),
-    ['10', '2019-09-08 00:00:00+01'],
-    (10, parse('2019-09-08 00:00:00+01')),
-    [10, parse('2019-09-08 00:00:00+01')],
-])
-async def test_tintinst_constructors(connection, expected_tintinst):
-    params = TIntInst(expected_tintinst)
-    await connection.execute('INSERT INTO tbl_tintinst (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tintinst WHERE temp=$1', params, column=0)
-    assert result == TIntInst(expected_tintinst)
-
-@pytest.mark.parametrize('expected_tintinstset', [
-    '{10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01}',
-    ('10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'),
-    (TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-     TIntInst('10@2019-09-03 00:00:00+01')),
-    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'],
-    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-     TIntInst('10@2019-09-03 00:00:00+01')],
-])
-async def test_tintinstset_constructor(connection, expected_tintinstset):
-    if isinstance(expected_tintinstset, tuple):
-        params = TIntInstSet(*expected_tintinstset)
-    else:
-        params = TIntInstSet(expected_tintinstset)
-    await connection.execute('INSERT INTO tbl_tintinstset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tintinstset WHERE temp=$1', params)
-    if isinstance(expected_tintinstset, tuple):
-        assert result == TIntInstSet(*expected_tintinstset)
-    else:
-        assert result == TIntInstSet(expected_tintinstset)
-
-@pytest.mark.parametrize('expected_tintseq', [
-    '[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]',
-    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '20@2019-09-03 00:00:00+01'],
-    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-     TIntInst('20@2019-09-03 00:00:00+01')],
-])
-async def test_tintseq_constructor(connection, expected_tintseq):
-    if isinstance(expected_tintseq, tuple):
-        params = TIntSeq(*expected_tintseq)
-    else:
-        params = TIntSeq(expected_tintseq)
-    await connection.execute('INSERT INTO tbl_tintseq (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tintseq WHERE temp=$1', params)
-    if isinstance(expected_tintseq, tuple):
-        assert result == TIntSeq(*expected_tintseq)
-    else:
-        assert result == TIntSeq(expected_tintseq)
-
-@pytest.mark.parametrize('expected_tintseqset', [
-    '{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}',
-    ['[10@2019-09-01 00:00:00+01]', '[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]'],
-    [TIntSeq('[10@2019-09-01 00:00:00+01]'),
-     TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')],
-])
-async def test_tintseqset_constructor(connection, expected_tintseqset):
-    if isinstance(expected_tintseqset, tuple):
-        params = TIntSeqSet(*expected_tintseqset)
-    else:
-        params = TIntSeqSet(expected_tintseqset)
-    await connection.execute('INSERT INTO tbl_tintseqset (temp) VALUES ($1)', params)
-    result = await connection.fetchval('SELECT temp FROM tbl_tintseqset WHERE temp=$1', params)
-    if isinstance(expected_tintseqset, tuple):
-        assert result == TIntSeqSet(*expected_tintseqset)
-    else:
-        assert result == TIntSeqSet(expected_tintseqset)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb.main import TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_tintinst', [
+    '10@2019-09-01 00:00:00+01',
+    ('10', '2019-09-08 00:00:00+01'),
+    ['10', '2019-09-08 00:00:00+01'],
+    (10, parse('2019-09-08 00:00:00+01')),
+    [10, parse('2019-09-08 00:00:00+01')],
+])
+async def test_tintinst_constructors(connection, expected_tintinst):
+    params = TIntInst(expected_tintinst)
+    await connection.execute('INSERT INTO tbl_tintinst (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tintinst WHERE temp=$1', params, column=0)
+    assert result == TIntInst(expected_tintinst)
+
+@pytest.mark.parametrize('expected_tintinstset', [
+    '{10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01}',
+    ('10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'),
+    (TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+     TIntInst('10@2019-09-03 00:00:00+01')),
+    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'],
+    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+     TIntInst('10@2019-09-03 00:00:00+01')],
+])
+async def test_tintinstset_constructor(connection, expected_tintinstset):
+    if isinstance(expected_tintinstset, tuple):
+        params = TIntInstSet(*expected_tintinstset)
+    else:
+        params = TIntInstSet(expected_tintinstset)
+    await connection.execute('INSERT INTO tbl_tintinstset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tintinstset WHERE temp=$1', params)
+    if isinstance(expected_tintinstset, tuple):
+        assert result == TIntInstSet(*expected_tintinstset)
+    else:
+        assert result == TIntInstSet(expected_tintinstset)
+
+@pytest.mark.parametrize('expected_tintseq', [
+    '[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]',
+    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '20@2019-09-03 00:00:00+01'],
+    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+     TIntInst('20@2019-09-03 00:00:00+01')],
+])
+async def test_tintseq_constructor(connection, expected_tintseq):
+    if isinstance(expected_tintseq, tuple):
+        params = TIntSeq(*expected_tintseq)
+    else:
+        params = TIntSeq(expected_tintseq)
+    await connection.execute('INSERT INTO tbl_tintseq (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tintseq WHERE temp=$1', params)
+    if isinstance(expected_tintseq, tuple):
+        assert result == TIntSeq(*expected_tintseq)
+    else:
+        assert result == TIntSeq(expected_tintseq)
+
+@pytest.mark.parametrize('expected_tintseqset', [
+    '{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}',
+    ['[10@2019-09-01 00:00:00+01]', '[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]'],
+    [TIntSeq('[10@2019-09-01 00:00:00+01]'),
+     TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')],
+])
+async def test_tintseqset_constructor(connection, expected_tintseqset):
+    if isinstance(expected_tintseqset, tuple):
+        params = TIntSeqSet(*expected_tintseqset)
+    else:
+        params = TIntSeqSet(expected_tintseqset)
+    await connection.execute('INSERT INTO tbl_tintseqset (temp) VALUES ($1)', params)
+    result = await connection.fetchval('SELECT temp FROM tbl_tintseqset WHERE temp=$1', params)
+    if isinstance(expected_tintseqset, tuple):
+        assert result == TIntSeqSet(*expected_tintseqset)
+    else:
+        assert result == TIntSeqSet(expected_tintseqset)
```

### Comparing `python-mobilitydb-0.1.2/tests/asyncpg/test_stbox.py` & `python-mobilitydb-0.1.3/tests/asyncpg/test_stbox.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,81 +1,81 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-import asyncio
-from dateutil.parser import parse
-from mobilitydb import STBox
-
-pytestmark = pytest.mark.asyncio
-
-@pytest.mark.parametrize('expected_stbox', [
-    # Only coordinate (X and Y) dimension
-    'STBOX ((1.0, 2.0), (1.0, 2.0))',
-    (('1.0', '2.0', '3.0', '4.0')),
-    (1.0, 2.0, 3.0, 4.0),
-    # Only coordinate (X, Y and Z) dimension
-    'STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
-    (('1.0', '2.0', '3.0', '4.0', '5.0', '6.0')),
-    ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0)),
-    # Both coordinate (X, Y) and time dimensions
-    'STBOX T((1.0, 2.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 2001-01-03 00:00:00+01))',
-    {'bounds':(1.0, 2.0, '2001-01-01 00:00:00+01', 3.0, 4.0, '2001-01-02 00:00:00+01'), 'dimt':True},
-    {'bounds':(1.0, 2.0, parse('2001-01-01 00:00:00+01'), 3.0, 4.0, parse('2001-01-02 00:00:00+01')), 'dimt':True},
-    # Both coordinate (X, Y, and Z) and time dimensions
-    'STBOX ZT((1.0, 2.0, 3.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
-    ((1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01')),
-    ((1.0, 2.0, 3.0, parse('2001-01-01 00:00:00+01'), 4.0, 5.0, 6.0, parse('2001-01-02 00:00:00+01'))),
-    # Only time dimension
-    'STBOX T(, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
-    (('2001-01-03 00:00:00+01', '2001-01-03 00:00:00+01')),
-    ((parse('2001-01-03 00:00:00+01'), parse('2001-01-03 00:00:00+01'))),
-    # Only geodetic coordinate (X, Y and Z) dimension
-    'GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
-    {'bounds':(1.0, 2.0, 3.0, 4.0, 5.0, 6.0), 'geodetic':True},
-    #  Both geodetic coordinate (X, Y, and Z) and time dimensions
-    'GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
-    {'bounds':(1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic':True},
-    # Only time dimension for geodetic box
-    'GEODSTBOX T((, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
-    {'bounds':('2001-01-01 00:00:00+01', '2001-01-02 00:00:00+01'), 'geodetic':True},
-    # With SRID
-    'SRID=5676;STBOX T((1.0, 2.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 2001-01-04 00:00:00+01))',
-    'SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
-    {'bounds': (1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic': True, 'srid': 4326},
-])
-async def test_stbox_constructor(connection, expected_stbox):
-    if isinstance(expected_stbox, dict):
-        params = STBox(**expected_stbox)
-    else:
-        params = STBox(expected_stbox)
-    print(params.__class__)
-    print(params.xmax)
-    await connection.execute("INSERT INTO tbl_stbox (box) VALUES ($1)", params)
-    result = await connection.fetchval("SELECT box FROM tbl_stbox WHERE box=$1", params, column=0)
-    if isinstance(expected_stbox, dict):
-        assert result == STBox(**expected_stbox)
-    else:
-        assert result == STBox(expected_stbox)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+import asyncio
+from dateutil.parser import parse
+from mobilitydb import STBox
+
+pytestmark = pytest.mark.asyncio
+
+@pytest.mark.parametrize('expected_stbox', [
+    # Only coordinate (X and Y) dimension
+    'STBOX ((1.0, 2.0), (1.0, 2.0))',
+    (('1.0', '2.0', '3.0', '4.0')),
+    (1.0, 2.0, 3.0, 4.0),
+    # Only coordinate (X, Y and Z) dimension
+    'STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
+    (('1.0', '2.0', '3.0', '4.0', '5.0', '6.0')),
+    ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0)),
+    # Both coordinate (X, Y) and time dimensions
+    'STBOX T((1.0, 2.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 2001-01-03 00:00:00+01))',
+    {'bounds':(1.0, 2.0, '2001-01-01 00:00:00+01', 3.0, 4.0, '2001-01-02 00:00:00+01'), 'dimt':True},
+    {'bounds':(1.0, 2.0, parse('2001-01-01 00:00:00+01'), 3.0, 4.0, parse('2001-01-02 00:00:00+01')), 'dimt':True},
+    # Both coordinate (X, Y, and Z) and time dimensions
+    'STBOX ZT((1.0, 2.0, 3.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
+    ((1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01')),
+    ((1.0, 2.0, 3.0, parse('2001-01-01 00:00:00+01'), 4.0, 5.0, 6.0, parse('2001-01-02 00:00:00+01'))),
+    # Only time dimension
+    'STBOX T(, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
+    (('2001-01-03 00:00:00+01', '2001-01-03 00:00:00+01')),
+    ((parse('2001-01-03 00:00:00+01'), parse('2001-01-03 00:00:00+01'))),
+    # Only geodetic coordinate (X, Y and Z) dimension
+    'GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
+    {'bounds':(1.0, 2.0, 3.0, 4.0, 5.0, 6.0), 'geodetic':True},
+    #  Both geodetic coordinate (X, Y, and Z) and time dimensions
+    'GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
+    {'bounds':(1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic':True},
+    # Only time dimension for geodetic box
+    'GEODSTBOX T((, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
+    {'bounds':('2001-01-01 00:00:00+01', '2001-01-02 00:00:00+01'), 'geodetic':True},
+    # With SRID
+    'SRID=5676;STBOX T((1.0, 2.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 2001-01-04 00:00:00+01))',
+    'SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
+    {'bounds': (1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic': True, 'srid': 4326},
+])
+async def test_stbox_constructor(connection, expected_stbox):
+    if isinstance(expected_stbox, dict):
+        params = STBox(**expected_stbox)
+    else:
+        params = STBox(expected_stbox)
+    print(params.__class__)
+    print(params.xmax)
+    await connection.execute("INSERT INTO tbl_stbox (box) VALUES ($1)", params)
+    result = await connection.fetchval("SELECT box FROM tbl_stbox WHERE box=$1", params, column=0)
+    if isinstance(expected_stbox, dict):
+        assert result == STBox(**expected_stbox)
+    else:
+        assert result == STBox(expected_stbox)
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_tgeompoint.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_tgeompoint.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,402 +1,402 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from datetime import timedelta
-from dateutil.parser import parse
-from postgis import Point, MultiPoint, LineString, MultiLineString, GeometryCollection
-from mobilitydb.main import TGeomPointInst, TGeomPointInstSet, TGeomPointSeq, TGeomPointSeqSet
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-
-
-@pytest.mark.parametrize('expected_tgeompointinst', [
-    'POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-    ('POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
-    ['POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
-    ('SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
-    ['SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
-    (Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')),
-    [Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')],
-    (Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')),
-    [Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')],
-])
-def test_tgeompointinst_constructors(cursor, expected_tgeompointinst):
-    if isinstance(expected_tgeompointinst, tuple):
-        params = [TGeomPointInst(*expected_tgeompointinst)]
-    else:
-        params = [TGeomPointInst(expected_tgeompointinst)]
-    cursor.execute('INSERT INTO tbl_tgeompointinst (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeompointinst WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeompointinst, tuple):
-        assert result == TGeomPointInst(*expected_tgeompointinst)
-    else:
-        assert result == TGeomPointInst(expected_tgeompointinst)
-
-
-@pytest.mark.parametrize('expected_tgeompointinst', [
-    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-])
-def test_tgeompointinst_accessors(cursor, expected_tgeompointinst):
-    assert TGeomPointInst(expected_tgeompointinst).srid == 4326
-    assert TGeomPointInst(expected_tgeompointinst).tempSubtype() == 'Instant'
-    assert TGeomPointInst(expected_tgeompointinst).getValue == Point(10.0, 10.0)
-    assert TGeomPointInst(expected_tgeompointinst).getValues == Point(10.0, 10.0)
-    assert TGeomPointInst(expected_tgeompointinst).startValue == Point(10.0, 10.0)
-    assert TGeomPointInst(expected_tgeompointinst).endValue == Point(10.0, 10.0)
-    assert TGeomPointInst(expected_tgeompointinst).getTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeomPointInst(expected_tgeompointinst).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
-    assert TGeomPointInst(expected_tgeompointinst).duration == timedelta(0)
-    assert TGeomPointInst(expected_tgeompointinst).timespan == timedelta(0)
-    assert TGeomPointInst(expected_tgeompointinst).period == Period(
-        '[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
-    assert TGeomPointInst(expected_tgeompointinst).numInstants == 1
-    assert TGeomPointInst(expected_tgeompointinst).startInstant == TGeomPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeomPointInst(expected_tgeompointinst).endInstant == TGeomPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeomPointInst(expected_tgeompointinst).instantN(1) == TGeomPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeomPointInst(expected_tgeompointinst).instants == [
-        TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')]
-    assert TGeomPointInst(expected_tgeompointinst).numTimestamps == 1
-    assert TGeomPointInst(expected_tgeompointinst).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeomPointInst(expected_tgeompointinst).endTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeomPointInst(expected_tgeompointinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
-    assert TGeomPointInst(expected_tgeompointinst).timestamps == [parse('2019-09-01 00:00:00+01')]
-    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
-    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
-    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriod(
-        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
-    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriod(
-        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
-    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
-    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tgeompointinstset', [
-    '{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
-    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
-    ('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'),
-    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    ('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'),
-    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    (TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')),
-    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    (TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')),
-    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-])
-def test_tgeompointinstset_constructor(cursor, expected_tgeompointinstset):
-    if isinstance(expected_tgeompointinstset, tuple):
-        params = [TGeomPointInstSet(*expected_tgeompointinstset)]
-    else:
-        params = [TGeomPointInstSet(expected_tgeompointinstset)]
-    cursor.execute('INSERT INTO tbl_tgeompointinstset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeompointinstset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeompointinstset, tuple):
-        assert result == TGeomPointInstSet(*expected_tgeompointinstset)
-    else:
-        assert result == TGeomPointInstSet(expected_tgeompointinstset)
-
-
-@pytest.mark.parametrize('expected_tgeompointinstset', [
-    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(30.0 30.0)@2019-09-03 00:00:00+01}',
-])
-def test_tgeompointi_accessors(cursor, expected_tgeompointinstset):
-    assert TGeomPointInstSet(expected_tgeompointinstset).srid == 4326
-    assert TGeomPointInstSet(expected_tgeompointinstset).tempSubtype() == 'InstantSet'
-    assert TGeomPointInstSet(expected_tgeompointinstset).getValues == \
-           MultiPoint([Point(10.0, 10.0),Point(20.0, 20.0),Point(30.0, 30.0)])
-    assert TGeomPointInstSet(expected_tgeompointinstset).startValue == Point(10.0, 10.0)
-    assert TGeomPointInstSet(expected_tgeompointinstset).endValue == Point(30.0, 30.0)
-    assert TGeomPointInstSet(expected_tgeompointinstset).getTime == \
-           PeriodSet(
-               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
-               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TGeomPointInstSet(expected_tgeompointinstset).duration == timedelta(0)
-    assert TGeomPointInstSet(expected_tgeompointinstset).timespan == timedelta(2)
-    assert TGeomPointInstSet(expected_tgeompointinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TGeomPointInstSet(expected_tgeompointinstset).numInstants == 3
-    assert TGeomPointInstSet(expected_tgeompointinstset).startInstant == TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeomPointInstSet(expected_tgeompointinstset).endInstant == TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
-    assert TGeomPointInstSet(expected_tgeompointinstset).instantN(2) == TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
-    assert TGeomPointInstSet(expected_tgeompointinstset).instants == [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-                                                            TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-                                                            TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
-    assert TGeomPointInstSet(expected_tgeompointinstset).numTimestamps == 3
-    assert TGeomPointInstSet(expected_tgeompointinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeomPointInstSet(expected_tgeompointinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TGeomPointInstSet(expected_tgeompointinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TGeomPointInstSet(expected_tgeompointinstset).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                              parse('2019-09-02 00:00:00+01'),
-                                                              parse('2019-09-03 00:00:00+01')]
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriod(
-        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
-    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tgeompointseq', [
-    '[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise'),
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Linear', 4326),
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise', 4326),
-    ([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-    ([TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-])
-def test_tgeompointseq_constructor(cursor, expected_tgeompointseq):
-    if isinstance(expected_tgeompointseq, tuple):
-        params = [TGeomPointSeq(*expected_tgeompointseq)]
-    else:
-        params = [TGeomPointSeq(expected_tgeompointseq)]
-    cursor.execute('INSERT INTO tbl_tgeompointseq (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeompointseq WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeompointseq, tuple):
-        assert result == TGeomPointSeq(*expected_tgeompointseq)
-    else:
-        assert result == TGeomPointSeq(expected_tgeompointseq)
-
-@pytest.mark.parametrize('expected_tgeompointseq', [
-    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-    'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-])
-def test_tgeompointseq_accessors(cursor, expected_tgeompointseq):
-    assert TGeomPointSeq(expected_tgeompointseq).srid == 4326
-    assert TGeomPointSeq(expected_tgeompointseq).tempSubtype() == 'Sequence'
-    assert TGeomPointSeq(expected_tgeompointseq).getValues == LineString([Point(10.0, 10.0),Point(20.0, 20.0),Point(10.0, 10.0)])
-    assert TGeomPointSeq(expected_tgeompointseq).startValue == Point(10.0, 10.0)
-    assert TGeomPointSeq(expected_tgeompointseq).endValue == Point(10.0, 10.0)
-    assert TGeomPointSeq(expected_tgeompointseq).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TGeomPointSeq(expected_tgeompointseq).duration == timedelta(2)
-    assert TGeomPointSeq(expected_tgeompointseq).timespan == timedelta(2)
-    assert TGeomPointSeq(expected_tgeompointseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TGeomPointSeq(expected_tgeompointseq).numInstants == 3
-    assert TGeomPointSeq(expected_tgeompointseq).startInstant == TGeomPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeomPointSeq(expected_tgeompointseq).endInstant == TGeomPointInst(
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01')
-    assert TGeomPointSeq(expected_tgeompointseq).instantN(2) == TGeomPointInst(
-        'Point(20.0 20.0)@2019-09-02 00:00:00+01')
-    assert TGeomPointSeq(expected_tgeompointseq).instants == \
-           [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-            TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-            TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')]
-    assert TGeomPointSeq(expected_tgeompointseq).numTimestamps == 3
-    assert TGeomPointSeq(expected_tgeompointseq).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeomPointSeq(expected_tgeompointseq).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TGeomPointSeq(expected_tgeompointseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TGeomPointSeq(expected_tgeompointseq).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                                  parse('2019-09-02 00:00:00+01'),
-                                                                  parse('2019-09-03 00:00:00+01')]
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tgeompointseqset', [
-    '{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'SRID=4326;Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    ['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-    ['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
-    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
-    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise'),
-    (['SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise', 4326),
-    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise', 4326),
-    [TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
-    ([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear'),
-    ([TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeomPointSeq(
-            'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
-     'Stepwise'),
-])
-def test_tgeompointseqset_constructor(cursor, expected_tgeompointseqset):
-    if isinstance(expected_tgeompointseqset, tuple):
-        params = [TGeomPointSeqSet(*expected_tgeompointseqset)]
-    else:
-        params = [TGeomPointSeqSet(expected_tgeompointseqset)]
-    cursor.execute('INSERT INTO tbl_tgeompointseqset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeompointseqset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeompointseqset, tuple):
-        assert result == TGeomPointSeqSet(*expected_tgeompointseqset)
-    else:
-        assert result == TGeomPointSeqSet(expected_tgeompointseqset)
-
-@pytest.mark.parametrize('expected_tgeompointseqset', [
-    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01],  '
-    '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]}',
-])
-def test_tgeompointseqset_accessors(cursor, expected_tgeompointseqset):
-    assert TGeomPointSeqSet(expected_tgeompointseqset).srid == 4326
-    assert TGeomPointSeqSet(expected_tgeompointseqset).tempSubtype() == 'SequenceSet'
-    assert TGeomPointSeqSet(expected_tgeompointseqset).getValues == \
-        GeometryCollection([Point(10.0, 10.0), LineString([Point(20.0, 20.0), Point(30.0, 30.0)])])
-    assert TGeomPointSeqSet(expected_tgeompointseqset).startValue == Point(10.0, 10.0)
-    assert TGeomPointSeqSet(expected_tgeompointseqset).endValue == Point(30.0, 30.0)
-    # assert TGeomPointSeqSet(expected_tgeompointseqset).valueRange == geompointrange(Point(10.0, 10.0), Point(30.0, 30.0), upper_inc=True)
-    assert TGeomPointSeqSet(expected_tgeompointseqset).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).duration == timedelta(1)
-    assert TGeomPointSeqSet(expected_tgeompointseqset).timespan == timedelta(2)
-    assert TGeomPointSeqSet(expected_tgeompointseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).numInstants == 3
-    assert TGeomPointSeqSet(expected_tgeompointseqset).startInstant == TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).endInstant == TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).instantN(2) == TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).instants == [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-                                                        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-                                                        TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
-    assert TGeomPointSeqSet(expected_tgeompointseqset).numTimestamps == 3
-    assert TGeomPointSeqSet(expected_tgeompointseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                          parse('2019-09-02 00:00:00+01'),
-                                                          parse('2019-09-03 00:00:00+01')]
-    assert TGeomPointSeqSet(expected_tgeompointseqset).numSequences == 2
-    assert TGeomPointSeqSet(expected_tgeompointseqset).startSequence == TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).endSequence == TGeomPointSeq(
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).sequenceN(2) == TGeomPointSeq(
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
-    assert TGeomPointSeqSet(expected_tgeompointseqset).sequences == [TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')]
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from datetime import timedelta
+from dateutil.parser import parse
+from postgis import Point, MultiPoint, LineString, MultiLineString, GeometryCollection
+from mobilitydb.main import TGeomPointInst, TGeomPointInstSet, TGeomPointSeq, TGeomPointSeqSet
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+
+
+@pytest.mark.parametrize('expected_tgeompointinst', [
+    'POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+    ('POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
+    ['POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
+    ('SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
+    ['SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'],
+    (Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')),
+    [Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')],
+    (Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')),
+    [Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')],
+])
+def test_tgeompointinst_constructors(cursor, expected_tgeompointinst):
+    if isinstance(expected_tgeompointinst, tuple):
+        params = [TGeomPointInst(*expected_tgeompointinst)]
+    else:
+        params = [TGeomPointInst(expected_tgeompointinst)]
+    cursor.execute('INSERT INTO tbl_tgeompointinst (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeompointinst WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeompointinst, tuple):
+        assert result == TGeomPointInst(*expected_tgeompointinst)
+    else:
+        assert result == TGeomPointInst(expected_tgeompointinst)
+
+
+@pytest.mark.parametrize('expected_tgeompointinst', [
+    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+])
+def test_tgeompointinst_accessors(cursor, expected_tgeompointinst):
+    assert TGeomPointInst(expected_tgeompointinst).srid == 4326
+    assert TGeomPointInst(expected_tgeompointinst).tempSubtype() == 'Instant'
+    assert TGeomPointInst(expected_tgeompointinst).getValue == Point(10.0, 10.0)
+    assert TGeomPointInst(expected_tgeompointinst).getValues == Point(10.0, 10.0)
+    assert TGeomPointInst(expected_tgeompointinst).startValue == Point(10.0, 10.0)
+    assert TGeomPointInst(expected_tgeompointinst).endValue == Point(10.0, 10.0)
+    assert TGeomPointInst(expected_tgeompointinst).getTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeomPointInst(expected_tgeompointinst).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
+    assert TGeomPointInst(expected_tgeompointinst).duration == timedelta(0)
+    assert TGeomPointInst(expected_tgeompointinst).timespan == timedelta(0)
+    assert TGeomPointInst(expected_tgeompointinst).period == Period(
+        '[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
+    assert TGeomPointInst(expected_tgeompointinst).numInstants == 1
+    assert TGeomPointInst(expected_tgeompointinst).startInstant == TGeomPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeomPointInst(expected_tgeompointinst).endInstant == TGeomPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeomPointInst(expected_tgeompointinst).instantN(1) == TGeomPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeomPointInst(expected_tgeompointinst).instants == [
+        TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')]
+    assert TGeomPointInst(expected_tgeompointinst).numTimestamps == 1
+    assert TGeomPointInst(expected_tgeompointinst).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeomPointInst(expected_tgeompointinst).endTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeomPointInst(expected_tgeompointinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
+    assert TGeomPointInst(expected_tgeompointinst).timestamps == [parse('2019-09-01 00:00:00+01')]
+    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
+    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeomPointInst(expected_tgeompointinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
+    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriod(
+        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
+    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriod(
+        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
+    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
+    assert TGeomPointInst(expected_tgeompointinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tgeompointinstset', [
+    '{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
+    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
+    ('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'),
+    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    ('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'),
+    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    (TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')),
+    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    (TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')),
+    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+])
+def test_tgeompointinstset_constructor(cursor, expected_tgeompointinstset):
+    if isinstance(expected_tgeompointinstset, tuple):
+        params = [TGeomPointInstSet(*expected_tgeompointinstset)]
+    else:
+        params = [TGeomPointInstSet(expected_tgeompointinstset)]
+    cursor.execute('INSERT INTO tbl_tgeompointinstset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeompointinstset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeompointinstset, tuple):
+        assert result == TGeomPointInstSet(*expected_tgeompointinstset)
+    else:
+        assert result == TGeomPointInstSet(expected_tgeompointinstset)
+
+
+@pytest.mark.parametrize('expected_tgeompointinstset', [
+    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(30.0 30.0)@2019-09-03 00:00:00+01}',
+])
+def test_tgeompointi_accessors(cursor, expected_tgeompointinstset):
+    assert TGeomPointInstSet(expected_tgeompointinstset).srid == 4326
+    assert TGeomPointInstSet(expected_tgeompointinstset).tempSubtype() == 'InstantSet'
+    assert TGeomPointInstSet(expected_tgeompointinstset).getValues == \
+           MultiPoint([Point(10.0, 10.0),Point(20.0, 20.0),Point(30.0, 30.0)])
+    assert TGeomPointInstSet(expected_tgeompointinstset).startValue == Point(10.0, 10.0)
+    assert TGeomPointInstSet(expected_tgeompointinstset).endValue == Point(30.0, 30.0)
+    assert TGeomPointInstSet(expected_tgeompointinstset).getTime == \
+           PeriodSet(
+               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
+               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TGeomPointInstSet(expected_tgeompointinstset).duration == timedelta(0)
+    assert TGeomPointInstSet(expected_tgeompointinstset).timespan == timedelta(2)
+    assert TGeomPointInstSet(expected_tgeompointinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TGeomPointInstSet(expected_tgeompointinstset).numInstants == 3
+    assert TGeomPointInstSet(expected_tgeompointinstset).startInstant == TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeomPointInstSet(expected_tgeompointinstset).endInstant == TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
+    assert TGeomPointInstSet(expected_tgeompointinstset).instantN(2) == TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
+    assert TGeomPointInstSet(expected_tgeompointinstset).instants == [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+                                                            TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+                                                            TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
+    assert TGeomPointInstSet(expected_tgeompointinstset).numTimestamps == 3
+    assert TGeomPointInstSet(expected_tgeompointinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeomPointInstSet(expected_tgeompointinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TGeomPointInstSet(expected_tgeompointinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TGeomPointInstSet(expected_tgeompointinstset).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                              parse('2019-09-02 00:00:00+01'),
+                                                              parse('2019-09-03 00:00:00+01')]
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriod(
+        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
+    assert TGeomPointInstSet(expected_tgeompointinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tgeompointseq', [
+    '[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    [TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise'),
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Linear', 4326),
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise', 4326),
+    ([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+    ([TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeomPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+])
+def test_tgeompointseq_constructor(cursor, expected_tgeompointseq):
+    if isinstance(expected_tgeompointseq, tuple):
+        params = [TGeomPointSeq(*expected_tgeompointseq)]
+    else:
+        params = [TGeomPointSeq(expected_tgeompointseq)]
+    cursor.execute('INSERT INTO tbl_tgeompointseq (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeompointseq WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeompointseq, tuple):
+        assert result == TGeomPointSeq(*expected_tgeompointseq)
+    else:
+        assert result == TGeomPointSeq(expected_tgeompointseq)
+
+@pytest.mark.parametrize('expected_tgeompointseq', [
+    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+    'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+])
+def test_tgeompointseq_accessors(cursor, expected_tgeompointseq):
+    assert TGeomPointSeq(expected_tgeompointseq).srid == 4326
+    assert TGeomPointSeq(expected_tgeompointseq).tempSubtype() == 'Sequence'
+    assert TGeomPointSeq(expected_tgeompointseq).getValues == LineString([Point(10.0, 10.0),Point(20.0, 20.0),Point(10.0, 10.0)])
+    assert TGeomPointSeq(expected_tgeompointseq).startValue == Point(10.0, 10.0)
+    assert TGeomPointSeq(expected_tgeompointseq).endValue == Point(10.0, 10.0)
+    assert TGeomPointSeq(expected_tgeompointseq).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TGeomPointSeq(expected_tgeompointseq).duration == timedelta(2)
+    assert TGeomPointSeq(expected_tgeompointseq).timespan == timedelta(2)
+    assert TGeomPointSeq(expected_tgeompointseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TGeomPointSeq(expected_tgeompointseq).numInstants == 3
+    assert TGeomPointSeq(expected_tgeompointseq).startInstant == TGeomPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeomPointSeq(expected_tgeompointseq).endInstant == TGeomPointInst(
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01')
+    assert TGeomPointSeq(expected_tgeompointseq).instantN(2) == TGeomPointInst(
+        'Point(20.0 20.0)@2019-09-02 00:00:00+01')
+    assert TGeomPointSeq(expected_tgeompointseq).instants == \
+           [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+            TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+            TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')]
+    assert TGeomPointSeq(expected_tgeompointseq).numTimestamps == 3
+    assert TGeomPointSeq(expected_tgeompointseq).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeomPointSeq(expected_tgeompointseq).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TGeomPointSeq(expected_tgeompointseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TGeomPointSeq(expected_tgeompointseq).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                                  parse('2019-09-02 00:00:00+01'),
+                                                                  parse('2019-09-03 00:00:00+01')]
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeomPointSeq(expected_tgeompointseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tgeompointseqset', [
+    '{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'SRID=4326;Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    ['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+    ['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
+    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
+    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise'),
+    (['SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise', 4326),
+    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise', 4326),
+    [TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
+    ([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear'),
+    ([TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeomPointSeq(
+            'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
+     'Stepwise'),
+])
+def test_tgeompointseqset_constructor(cursor, expected_tgeompointseqset):
+    if isinstance(expected_tgeompointseqset, tuple):
+        params = [TGeomPointSeqSet(*expected_tgeompointseqset)]
+    else:
+        params = [TGeomPointSeqSet(expected_tgeompointseqset)]
+    cursor.execute('INSERT INTO tbl_tgeompointseqset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeompointseqset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeompointseqset, tuple):
+        assert result == TGeomPointSeqSet(*expected_tgeompointseqset)
+    else:
+        assert result == TGeomPointSeqSet(expected_tgeompointseqset)
+
+@pytest.mark.parametrize('expected_tgeompointseqset', [
+    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01],  '
+    '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]}',
+])
+def test_tgeompointseqset_accessors(cursor, expected_tgeompointseqset):
+    assert TGeomPointSeqSet(expected_tgeompointseqset).srid == 4326
+    assert TGeomPointSeqSet(expected_tgeompointseqset).tempSubtype() == 'SequenceSet'
+    assert TGeomPointSeqSet(expected_tgeompointseqset).getValues == \
+        GeometryCollection([Point(10.0, 10.0), LineString([Point(20.0, 20.0), Point(30.0, 30.0)])])
+    assert TGeomPointSeqSet(expected_tgeompointseqset).startValue == Point(10.0, 10.0)
+    assert TGeomPointSeqSet(expected_tgeompointseqset).endValue == Point(30.0, 30.0)
+    # assert TGeomPointSeqSet(expected_tgeompointseqset).valueRange == geompointrange(Point(10.0, 10.0), Point(30.0, 30.0), upper_inc=True)
+    assert TGeomPointSeqSet(expected_tgeompointseqset).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).duration == timedelta(1)
+    assert TGeomPointSeqSet(expected_tgeompointseqset).timespan == timedelta(2)
+    assert TGeomPointSeqSet(expected_tgeompointseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).numInstants == 3
+    assert TGeomPointSeqSet(expected_tgeompointseqset).startInstant == TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).endInstant == TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).instantN(2) == TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).instants == [TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+                                                        TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+                                                        TGeomPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
+    assert TGeomPointSeqSet(expected_tgeompointseqset).numTimestamps == 3
+    assert TGeomPointSeqSet(expected_tgeompointseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                          parse('2019-09-02 00:00:00+01'),
+                                                          parse('2019-09-03 00:00:00+01')]
+    assert TGeomPointSeqSet(expected_tgeompointseqset).numSequences == 2
+    assert TGeomPointSeqSet(expected_tgeompointseqset).startSequence == TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).endSequence == TGeomPointSeq(
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).sequenceN(2) == TGeomPointSeq(
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
+    assert TGeomPointSeqSet(expected_tgeompointseqset).sequences == [TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')]
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeomPointSeqSet(expected_tgeompointseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_time.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_time.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,148 +1,148 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from datetime import timedelta
-from dateutil.parser import parse
-from mobilitydb import TimestampSet, Period, PeriodSet
-
-
-@pytest.mark.parametrize('expected_timestampset', [
-    '{2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01, 2019-09-11 00:00:00+01}',
-    ['2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'],
-    [parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')],
-    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')),
-])
-def test_timestampset_constructor(cursor, expected_timestampset):
-    if isinstance(expected_timestampset, tuple):
-        params = TimestampSet(*expected_timestampset)
-    else:
-        params = TimestampSet(expected_timestampset)
-    cursor.execute("INSERT INTO tbl_timestampset (timetype) VALUES (%s)" % params)
-    cursor.execute("SELECT timetype FROM tbl_timestampset WHERE timetype=%s" % params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_timestampset, tuple):
-        assert result == TimestampSet(*expected_timestampset)
-    else:
-        assert result == TimestampSet(expected_timestampset)
-
-@pytest.mark.parametrize('expected_timestampset', [
-    '{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}',
-])
-def test_timestampset_accessors(cursor, expected_timestampset):
-    assert TimestampSet(expected_timestampset).timespan == timedelta(2)
-    assert TimestampSet(expected_timestampset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TimestampSet(expected_timestampset).numTimestamps == 3
-    assert TimestampSet(expected_timestampset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TimestampSet(expected_timestampset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TimestampSet(expected_timestampset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TimestampSet(expected_timestampset).timestamps == \
-           [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'), parse('2019-09-03 00:00:00+01')]
-    assert TimestampSet(expected_timestampset).shift(timedelta(days=1)) == \
-           TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01, 2019-09-04 00:00:00+01}')
-
-@pytest.mark.parametrize('expected_period', [
-    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
-    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
-    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
-    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
-    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01'),
-    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', False, True),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01')),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), False, True),
-])
-def test_period_constructor(cursor, expected_period):
-    if isinstance(expected_period, tuple):
-        params = Period(*expected_period)
-    else:
-        params = Period(expected_period)
-    cursor.execute("INSERT INTO tbl_period (timetype) VALUES (%s)" % params)
-    cursor.execute("SELECT timetype FROM tbl_period WHERE timetype=%s" % params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_period, tuple):
-        assert result == Period(*expected_period)
-    else:
-        assert result == Period(expected_period)
-
-@pytest.mark.parametrize('expected_period', [
-    '[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]',
-])
-def test_period_accessors(cursor, expected_period):
-    assert Period(expected_period).lower == parse('2019-09-01 00:00:00+01')
-    assert Period(expected_period).upper == parse('2019-09-03 00:00:00+01')
-    assert Period(expected_period).lower_inc == True
-    assert Period(expected_period).upper_inc == True
-    assert Period(expected_period).duration == timedelta(2)
-    assert Period(expected_period).shift(timedelta(days=1)) == Period('[2019-09-02 00:00:00+01, 2019-09-04 00:00:00+01]')
-
-@pytest.mark.parametrize('expected_periodset', [
-    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]}',
-    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01], [2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]}',
-    ['[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'],
-    [Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
-     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')],
-    ('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'),
-    (Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
-     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')),
-])
-def test_periodset_constructor(cursor, expected_periodset):
-    if isinstance(expected_periodset, tuple):
-        params = PeriodSet(*expected_periodset)
-    else:
-        params = PeriodSet(expected_periodset)
-    cursor.execute("INSERT INTO tbl_periodset (timetype) VALUES (%s)" % params)
-    cursor.execute("SELECT timetype FROM tbl_periodset WHERE timetype=%s" % params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_periodset, tuple):
-        assert result == PeriodSet(*expected_periodset)
-    else:
-        assert result == PeriodSet(expected_periodset)
-
-@pytest.mark.parametrize('expected_periodset', [
-    '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],  [2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}',
-])
-def test_periodset_accessors(cursor, expected_periodset):
-    assert PeriodSet(expected_periodset).duration == timedelta(1)
-    assert PeriodSet(expected_periodset).timespan == timedelta(2)
-    assert PeriodSet(expected_periodset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert PeriodSet(expected_periodset).numTimestamps == 3
-    assert PeriodSet(expected_periodset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert PeriodSet(expected_periodset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert PeriodSet(expected_periodset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert PeriodSet(expected_periodset).timestamps == \
-           [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'), parse('2019-09-03 00:00:00+01')]
-    assert PeriodSet(expected_periodset).numPeriods == 2
-    assert PeriodSet(expected_periodset).startPeriod == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
-    assert PeriodSet(expected_periodset).endPeriod == Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert PeriodSet(expected_periodset).periodN(2) == Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert PeriodSet(expected_periodset).periods == [Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]'),
-                                                       Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')]
-    assert PeriodSet(expected_periodset).shift(timedelta(days=1)) == \
-           PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01],  '
-                     '[2019-09-03 00:00:00+01, 2019-09-04 00:00:00+01]}')
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from datetime import timedelta
+from dateutil.parser import parse
+from mobilitydb import TimestampSet, Period, PeriodSet
+
+
+@pytest.mark.parametrize('expected_timestampset', [
+    '{2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01, 2019-09-11 00:00:00+01}',
+    ['2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'],
+    [parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')],
+    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')),
+])
+def test_timestampset_constructor(cursor, expected_timestampset):
+    if isinstance(expected_timestampset, tuple):
+        params = TimestampSet(*expected_timestampset)
+    else:
+        params = TimestampSet(expected_timestampset)
+    cursor.execute("INSERT INTO tbl_timestampset (timetype) VALUES (%s)" % params)
+    cursor.execute("SELECT timetype FROM tbl_timestampset WHERE timetype=%s" % params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_timestampset, tuple):
+        assert result == TimestampSet(*expected_timestampset)
+    else:
+        assert result == TimestampSet(expected_timestampset)
+
+@pytest.mark.parametrize('expected_timestampset', [
+    '{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}',
+])
+def test_timestampset_accessors(cursor, expected_timestampset):
+    assert TimestampSet(expected_timestampset).timespan == timedelta(2)
+    assert TimestampSet(expected_timestampset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TimestampSet(expected_timestampset).numTimestamps == 3
+    assert TimestampSet(expected_timestampset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TimestampSet(expected_timestampset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TimestampSet(expected_timestampset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TimestampSet(expected_timestampset).timestamps == \
+           [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'), parse('2019-09-03 00:00:00+01')]
+    assert TimestampSet(expected_timestampset).shift(timedelta(days=1)) == \
+           TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01, 2019-09-04 00:00:00+01}')
+
+@pytest.mark.parametrize('expected_period', [
+    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
+    '[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
+    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]',
+    '(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)',
+    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01'),
+    ('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', False, True),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01')),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), False, True),
+])
+def test_period_constructor(cursor, expected_period):
+    if isinstance(expected_period, tuple):
+        params = Period(*expected_period)
+    else:
+        params = Period(expected_period)
+    cursor.execute("INSERT INTO tbl_period (timetype) VALUES (%s)" % params)
+    cursor.execute("SELECT timetype FROM tbl_period WHERE timetype=%s" % params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_period, tuple):
+        assert result == Period(*expected_period)
+    else:
+        assert result == Period(expected_period)
+
+@pytest.mark.parametrize('expected_period', [
+    '[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]',
+])
+def test_period_accessors(cursor, expected_period):
+    assert Period(expected_period).lower == parse('2019-09-01 00:00:00+01')
+    assert Period(expected_period).upper == parse('2019-09-03 00:00:00+01')
+    assert Period(expected_period).lower_inc == True
+    assert Period(expected_period).upper_inc == True
+    assert Period(expected_period).duration == timedelta(2)
+    assert Period(expected_period).shift(timedelta(days=1)) == Period('[2019-09-02 00:00:00+01, 2019-09-04 00:00:00+01]')
+
+@pytest.mark.parametrize('expected_periodset', [
+    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]}',
+    '{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01], [2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]}',
+    ['[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'],
+    [Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
+     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')],
+    ('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'),
+    (Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'),
+     Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')),
+])
+def test_periodset_constructor(cursor, expected_periodset):
+    if isinstance(expected_periodset, tuple):
+        params = PeriodSet(*expected_periodset)
+    else:
+        params = PeriodSet(expected_periodset)
+    cursor.execute("INSERT INTO tbl_periodset (timetype) VALUES (%s)" % params)
+    cursor.execute("SELECT timetype FROM tbl_periodset WHERE timetype=%s" % params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_periodset, tuple):
+        assert result == PeriodSet(*expected_periodset)
+    else:
+        assert result == PeriodSet(expected_periodset)
+
+@pytest.mark.parametrize('expected_periodset', [
+    '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],  [2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}',
+])
+def test_periodset_accessors(cursor, expected_periodset):
+    assert PeriodSet(expected_periodset).duration == timedelta(1)
+    assert PeriodSet(expected_periodset).timespan == timedelta(2)
+    assert PeriodSet(expected_periodset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert PeriodSet(expected_periodset).numTimestamps == 3
+    assert PeriodSet(expected_periodset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert PeriodSet(expected_periodset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert PeriodSet(expected_periodset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert PeriodSet(expected_periodset).timestamps == \
+           [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'), parse('2019-09-03 00:00:00+01')]
+    assert PeriodSet(expected_periodset).numPeriods == 2
+    assert PeriodSet(expected_periodset).startPeriod == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
+    assert PeriodSet(expected_periodset).endPeriod == Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert PeriodSet(expected_periodset).periodN(2) == Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert PeriodSet(expected_periodset).periods == [Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]'),
+                                                       Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')]
+    assert PeriodSet(expected_periodset).shift(timedelta(days=1)) == \
+           PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01],  '
+                     '[2019-09-03 00:00:00+01, 2019-09-04 00:00:00+01]}')
+
+
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_ttext.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_ttext.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,303 +1,303 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from datetime import timedelta
-from dateutil.parser import parse
-from mobilitydb.main import TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-
-
-@pytest.mark.parametrize('expected_ttextinst', [
-    'AA@2019-09-01 00:00:00+01',
-    ('AA', '2019-09-08 00:00:00+01'),
-    ['AA', '2019-09-08 00:00:00+01'],
-    ('AA', parse('2019-09-08 00:00:00+01')),
-    ['AA', parse('2019-09-08 00:00:00+01')],
-])
-def test_ttextinst_constructors(cursor, expected_ttextinst):
-    params = [TTextInst(expected_ttextinst)]
-    cursor.execute('INSERT INTO tbl_ttextinst (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_ttextinst WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    assert result == TTextInst(expected_ttextinst)
-
-
-@pytest.mark.parametrize('expected_ttextinst', [
-    'AA@2019-09-01 00:00:00+01',
-])
-def test_ttextinst_accessors(cursor, expected_ttextinst):
-    assert TTextInst(expected_ttextinst).tempSubtype() == 'Instant'
-    assert TTextInst(expected_ttextinst).getValue == 'AA'
-    assert TTextInst(expected_ttextinst).getValues == ['AA']
-    assert TTextInst(expected_ttextinst).startValue == 'AA'
-    assert TTextInst(expected_ttextinst).endValue == 'AA'
-    assert TTextInst(expected_ttextinst).minValue == 'AA'
-    assert TTextInst(expected_ttextinst).maxValue == 'AA'
-    assert TTextInst(expected_ttextinst).getTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TTextInst(expected_ttextinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
-    assert TTextInst(expected_ttextinst).duration == timedelta(0)
-    assert TTextInst(expected_ttextinst).timespan == timedelta(0)
-    assert TTextInst(expected_ttextinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
-    assert TTextInst(expected_ttextinst).numInstants == 1
-    assert TTextInst(expected_ttextinst).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
-    assert TTextInst(expected_ttextinst).endInstant == TTextInst('AA@2019-09-01 00:00:00+01')
-    assert TTextInst(expected_ttextinst).instantN(1) == TTextInst('AA@2019-09-01 00:00:00+01')
-    assert TTextInst(expected_ttextinst).instants == [TTextInst('AA@2019-09-01 00:00:00+01')]
-    assert TTextInst(expected_ttextinst).numTimestamps == 1
-    assert TTextInst(expected_ttextinst).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TTextInst(expected_ttextinst).endTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TTextInst(expected_ttextinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
-    assert TTextInst(expected_ttextinst).timestamps == [parse('2019-09-01 00:00:00+01')]
-    assert TTextInst(expected_ttextinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TTextInst(expected_ttextinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
-    assert TTextInst(expected_ttextinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TTextInst(expected_ttextinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
-    assert TTextInst(expected_ttextinst).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TTextInst(expected_ttextinst).intersectsPeriod(
-        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
-    assert TTextInst(expected_ttextinst).intersectsPeriod(
-        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
-    assert TTextInst(expected_ttextinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TTextInst(expected_ttextinst).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
-    assert TTextInst(expected_ttextinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
-
-@pytest.mark.parametrize('expected_ttextinstset', [
-    '{AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01}',
-    ('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'),
-    (TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-     TTextInst('AA@2019-09-03 00:00:00+01')),
-    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'],
-    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-     TTextInst('AA@2019-09-03 00:00:00+01')],
-])
-def test_ttextinstset_constructor(cursor, expected_ttextinstset):
-    if isinstance(expected_ttextinstset, tuple):
-        params = [TTextInstSet(*expected_ttextinstset)]
-    else:
-        params = [TTextInstSet(expected_ttextinstset)]
-    cursor.execute('INSERT INTO tbl_ttextinstset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_ttextinstset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_ttextinstset, tuple):
-        assert result == TTextInstSet(*expected_ttextinstset)
-    else:
-        assert result == TTextInstSet(expected_ttextinstset)
-
-
-@pytest.mark.parametrize('expected_ttextinstset', [
-    '{AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01}',
-])
-def test_ttextinstset_accessors(cursor, expected_ttextinstset):
-    assert TTextInstSet(expected_ttextinstset).tempSubtype() == 'InstantSet'
-    assert TTextInstSet(expected_ttextinstset).getValues == ['AA', 'BB', 'CC']
-    assert TTextInstSet(expected_ttextinstset).startValue == 'AA'
-    assert TTextInstSet(expected_ttextinstset).endValue == 'CC'
-    assert TTextInstSet(expected_ttextinstset).minValue == 'AA'
-    assert TTextInstSet(expected_ttextinstset).maxValue == 'CC'
-    assert TTextInstSet(expected_ttextinstset).getTime == \
-           PeriodSet(
-               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
-               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TTextInstSet(expected_ttextinstset).duration == timedelta(0)
-    assert TTextInstSet(expected_ttextinstset).timespan == timedelta(2)
-    assert TTextInstSet(expected_ttextinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TTextInstSet(expected_ttextinstset).numInstants == 3
-    assert TTextInstSet(expected_ttextinstset).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
-    assert TTextInstSet(expected_ttextinstset).endInstant == TTextInst('CC@2019-09-03 00:00:00+01')
-    assert TTextInstSet(expected_ttextinstset).instantN(2) == TTextInst('BB@2019-09-02 00:00:00+01')
-    assert TTextInstSet(expected_ttextinstset).instants == [TTextInst('AA@2019-09-01 00:00:00+01'),
-                                                TTextInst('BB@2019-09-02 00:00:00+01'),
-                                                TTextInst('CC@2019-09-03 00:00:00+01')]
-    assert TTextInstSet(expected_ttextinstset).numTimestamps == 3
-    assert TTextInstSet(expected_ttextinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TTextInstSet(expected_ttextinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TTextInstSet(expected_ttextinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TTextInstSet(expected_ttextinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                                  parse('2019-09-03 00:00:00+01')]
-    assert TTextInstSet(expected_ttextinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TTextInstSet(expected_ttextinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TTextInstSet(expected_ttextinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TTextInstSet(expected_ttextinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TTextInstSet(expected_ttextinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TTextInstSet(expected_ttextinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
-    assert TTextInstSet(expected_ttextinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TTextInstSet(expected_ttextinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TTextInstSet(expected_ttextinstset).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
-    assert TTextInstSet(expected_ttextinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_ttextseqseteq', [
-    '[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, BB@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, BB@2019-09-03 00:00:00+01]',
-    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'BB@2019-09-03 00:00:00+01'],
-    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-     TTextInst('BB@2019-09-03 00:00:00+01')],
-    (['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'], True, True),
-    ([TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-      TTextInst('AA@2019-09-03 00:00:00+01')], True, True),
-])
-def test_ttextseq_constructor(cursor, expected_ttextseqseteq):
-    if isinstance(expected_ttextseqseteq, tuple):
-        params = [TTextSeq(*expected_ttextseqseteq)]
-    else:
-        params = [TTextSeq(expected_ttextseqseteq)]
-    cursor.execute('INSERT INTO tbl_ttextseq (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_ttextseq WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_ttextseqseteq, tuple):
-        assert result == TTextSeq(*expected_ttextseqseteq)
-    else:
-        assert result == TTextSeq(expected_ttextseqseteq)
-
-
-@pytest.mark.parametrize('expected_ttextseqseteq', [
-    '[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]',
-])
-def test_ttextseq_accessors(cursor, expected_ttextseqseteq):
-    assert TTextSeq(expected_ttextseqseteq).tempSubtype() == 'Sequence'
-    assert TTextSeq(expected_ttextseqseteq).getValues == ['AA', 'BB', 'CC']
-    assert TTextSeq(expected_ttextseqseteq).startValue == 'AA'
-    assert TTextSeq(expected_ttextseqseteq).endValue == 'CC'
-    assert TTextSeq(expected_ttextseqseteq).minValue == 'AA'
-    assert TTextSeq(expected_ttextseqseteq).maxValue == 'CC'
-    assert TTextSeq(expected_ttextseqseteq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TTextSeq(expected_ttextseqseteq).duration == timedelta(2)
-    assert TTextSeq(expected_ttextseqseteq).timespan == timedelta(2)
-    assert TTextSeq(expected_ttextseqseteq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TTextSeq(expected_ttextseqseteq).numInstants == 3
-    assert TTextSeq(expected_ttextseqseteq).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
-    assert TTextSeq(expected_ttextseqseteq).endInstant == TTextInst('CC@2019-09-03 00:00:00+01')
-    assert TTextSeq(expected_ttextseqseteq).instantN(2) == TTextInst('BB@2019-09-02 00:00:00+01')
-    assert TTextSeq(expected_ttextseqseteq).instants == \
-           [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
-            TTextInst('CC@2019-09-03 00:00:00+01')]
-    assert TTextSeq(expected_ttextseqseteq).numTimestamps == 3
-    assert TTextSeq(expected_ttextseqseteq).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TTextSeq(expected_ttextseqseteq).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TTextSeq(expected_ttextseqseteq).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TTextSeq(expected_ttextseqseteq).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                      parse('2019-09-02 00:00:00+01'),
-                                                      parse('2019-09-03 00:00:00+01')]
-    assert TTextSeq(expected_ttextseqseteq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TTextSeq(expected_ttextseqseteq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TTextSeq(expected_ttextseqseteq).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TTextSeq(expected_ttextseqseteq).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TTextSeq(expected_ttextseqseteq).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TTextSeq(expected_ttextseqseteq).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TTextSeq(expected_ttextseqseteq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TTextSeq(expected_ttextseqseteq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_ttextseqset', [
-    '{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}',
-    ['[AA@2019-09-01 00:00:00+01]', '[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]'],
-    [TTextSeq('[AA@2019-09-01 00:00:00+01]'),
-     TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')],
-])
-def test_ttextseqset_constructor(cursor, expected_ttextseqset):
-    if isinstance(expected_ttextseqset, tuple):
-        params = [TTextSeqSet(*expected_ttextseqset)]
-    else:
-        params = [TTextSeqSet(expected_ttextseqset)]
-    cursor.execute('INSERT INTO tbl_ttextseqset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_ttextseqset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_ttextseqset, tuple):
-        assert result == TTextSeqSet(*expected_ttextseqset)
-    else:
-        assert result == TTextSeqSet(expected_ttextseqset)
-
-
-@pytest.mark.parametrize('expected_ttextseqset', [
-    '{[AA@2019-09-01 00:00:00+01],  [BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]}',
-])
-def test_ttextseqset_accessors(cursor, expected_ttextseqset):
-    assert TTextSeqSet(expected_ttextseqset).tempSubtype() == 'SequenceSet'
-    assert TTextSeqSet(expected_ttextseqset).getValues == ['AA', 'BB', 'CC']
-    assert TTextSeqSet(expected_ttextseqset).startValue == 'AA'
-    assert TTextSeqSet(expected_ttextseqset).endValue == 'CC'
-    assert TTextSeqSet(expected_ttextseqset).minValue == 'AA'
-    assert TTextSeqSet(expected_ttextseqset).maxValue == 'CC'
-    assert TTextSeqSet(expected_ttextseqset).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TTextSeqSet(expected_ttextseqset).duration == timedelta(1)
-    assert TTextSeqSet(expected_ttextseqset).timespan == timedelta(2)
-    assert TTextSeqSet(expected_ttextseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TTextSeqSet(expected_ttextseqset).numInstants == 3
-    assert TTextSeqSet(expected_ttextseqset).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
-    assert TTextSeqSet(expected_ttextseqset).endInstant == TTextInst('CC@2019-09-03 00:00:00+01')
-    assert TTextSeqSet(expected_ttextseqset).instantN(2) == TTextInst('BB@2019-09-02 00:00:00+01')
-    assert TTextSeqSet(expected_ttextseqset).instants == [TTextInst('AA@2019-09-01 00:00:00+01'),
-                                                TTextInst('BB@2019-09-02 00:00:00+01'),
-                                                TTextInst('CC@2019-09-03 00:00:00+01')]
-    assert TTextSeqSet(expected_ttextseqset).numTimestamps == 3
-    assert TTextSeqSet(expected_ttextseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TTextSeqSet(expected_ttextseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TTextSeqSet(expected_ttextseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TTextSeqSet(expected_ttextseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                                  parse('2019-09-03 00:00:00+01')]
-    assert TTextSeqSet(expected_ttextseqset).numSequences == 2
-    assert TTextSeqSet(expected_ttextseqset).startSequence == TTextSeq('[AA@2019-09-01 00:00:00+01]')
-    assert TTextSeqSet(expected_ttextseqset).endSequence == TTextSeq(
-        '[BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]')
-    assert TTextSeqSet(expected_ttextseqset).sequenceN(2) == TTextSeq(
-        '[BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]')
-    assert TTextSeqSet(expected_ttextseqset).sequences == [TTextSeq('[AA@2019-09-01 00:00:00+01]'),
-                                                 TTextSeq(
-                                                     '[BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]')]
-    assert TTextSeqSet(expected_ttextseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TTextSeqSet(expected_ttextseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TTextSeqSet(expected_ttextseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TTextSeqSet(expected_ttextseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TTextSeqSet(expected_ttextseqset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TTextSeqSet(expected_ttextseqset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TTextSeqSet(expected_ttextseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TTextSeqSet(expected_ttextseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from datetime import timedelta
+from dateutil.parser import parse
+from mobilitydb.main import TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+
+
+@pytest.mark.parametrize('expected_ttextinst', [
+    'AA@2019-09-01 00:00:00+01',
+    ('AA', '2019-09-08 00:00:00+01'),
+    ['AA', '2019-09-08 00:00:00+01'],
+    ('AA', parse('2019-09-08 00:00:00+01')),
+    ['AA', parse('2019-09-08 00:00:00+01')],
+])
+def test_ttextinst_constructors(cursor, expected_ttextinst):
+    params = [TTextInst(expected_ttextinst)]
+    cursor.execute('INSERT INTO tbl_ttextinst (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_ttextinst WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    assert result == TTextInst(expected_ttextinst)
+
+
+@pytest.mark.parametrize('expected_ttextinst', [
+    'AA@2019-09-01 00:00:00+01',
+])
+def test_ttextinst_accessors(cursor, expected_ttextinst):
+    assert TTextInst(expected_ttextinst).tempSubtype() == 'Instant'
+    assert TTextInst(expected_ttextinst).getValue == 'AA'
+    assert TTextInst(expected_ttextinst).getValues == ['AA']
+    assert TTextInst(expected_ttextinst).startValue == 'AA'
+    assert TTextInst(expected_ttextinst).endValue == 'AA'
+    assert TTextInst(expected_ttextinst).minValue == 'AA'
+    assert TTextInst(expected_ttextinst).maxValue == 'AA'
+    assert TTextInst(expected_ttextinst).getTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TTextInst(expected_ttextinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
+    assert TTextInst(expected_ttextinst).duration == timedelta(0)
+    assert TTextInst(expected_ttextinst).timespan == timedelta(0)
+    assert TTextInst(expected_ttextinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
+    assert TTextInst(expected_ttextinst).numInstants == 1
+    assert TTextInst(expected_ttextinst).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
+    assert TTextInst(expected_ttextinst).endInstant == TTextInst('AA@2019-09-01 00:00:00+01')
+    assert TTextInst(expected_ttextinst).instantN(1) == TTextInst('AA@2019-09-01 00:00:00+01')
+    assert TTextInst(expected_ttextinst).instants == [TTextInst('AA@2019-09-01 00:00:00+01')]
+    assert TTextInst(expected_ttextinst).numTimestamps == 1
+    assert TTextInst(expected_ttextinst).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TTextInst(expected_ttextinst).endTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TTextInst(expected_ttextinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
+    assert TTextInst(expected_ttextinst).timestamps == [parse('2019-09-01 00:00:00+01')]
+    assert TTextInst(expected_ttextinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TTextInst(expected_ttextinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
+    assert TTextInst(expected_ttextinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TTextInst(expected_ttextinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
+    assert TTextInst(expected_ttextinst).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TTextInst(expected_ttextinst).intersectsPeriod(
+        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
+    assert TTextInst(expected_ttextinst).intersectsPeriod(
+        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
+    assert TTextInst(expected_ttextinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TTextInst(expected_ttextinst).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
+    assert TTextInst(expected_ttextinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
+
+@pytest.mark.parametrize('expected_ttextinstset', [
+    '{AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01}',
+    ('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'),
+    (TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+     TTextInst('AA@2019-09-03 00:00:00+01')),
+    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'],
+    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+     TTextInst('AA@2019-09-03 00:00:00+01')],
+])
+def test_ttextinstset_constructor(cursor, expected_ttextinstset):
+    if isinstance(expected_ttextinstset, tuple):
+        params = [TTextInstSet(*expected_ttextinstset)]
+    else:
+        params = [TTextInstSet(expected_ttextinstset)]
+    cursor.execute('INSERT INTO tbl_ttextinstset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_ttextinstset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_ttextinstset, tuple):
+        assert result == TTextInstSet(*expected_ttextinstset)
+    else:
+        assert result == TTextInstSet(expected_ttextinstset)
+
+
+@pytest.mark.parametrize('expected_ttextinstset', [
+    '{AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01}',
+])
+def test_ttextinstset_accessors(cursor, expected_ttextinstset):
+    assert TTextInstSet(expected_ttextinstset).tempSubtype() == 'InstantSet'
+    assert TTextInstSet(expected_ttextinstset).getValues == ['AA', 'BB', 'CC']
+    assert TTextInstSet(expected_ttextinstset).startValue == 'AA'
+    assert TTextInstSet(expected_ttextinstset).endValue == 'CC'
+    assert TTextInstSet(expected_ttextinstset).minValue == 'AA'
+    assert TTextInstSet(expected_ttextinstset).maxValue == 'CC'
+    assert TTextInstSet(expected_ttextinstset).getTime == \
+           PeriodSet(
+               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
+               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TTextInstSet(expected_ttextinstset).duration == timedelta(0)
+    assert TTextInstSet(expected_ttextinstset).timespan == timedelta(2)
+    assert TTextInstSet(expected_ttextinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TTextInstSet(expected_ttextinstset).numInstants == 3
+    assert TTextInstSet(expected_ttextinstset).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
+    assert TTextInstSet(expected_ttextinstset).endInstant == TTextInst('CC@2019-09-03 00:00:00+01')
+    assert TTextInstSet(expected_ttextinstset).instantN(2) == TTextInst('BB@2019-09-02 00:00:00+01')
+    assert TTextInstSet(expected_ttextinstset).instants == [TTextInst('AA@2019-09-01 00:00:00+01'),
+                                                TTextInst('BB@2019-09-02 00:00:00+01'),
+                                                TTextInst('CC@2019-09-03 00:00:00+01')]
+    assert TTextInstSet(expected_ttextinstset).numTimestamps == 3
+    assert TTextInstSet(expected_ttextinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TTextInstSet(expected_ttextinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TTextInstSet(expected_ttextinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TTextInstSet(expected_ttextinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                                  parse('2019-09-03 00:00:00+01')]
+    assert TTextInstSet(expected_ttextinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TTextInstSet(expected_ttextinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TTextInstSet(expected_ttextinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TTextInstSet(expected_ttextinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TTextInstSet(expected_ttextinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TTextInstSet(expected_ttextinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
+    assert TTextInstSet(expected_ttextinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TTextInstSet(expected_ttextinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TTextInstSet(expected_ttextinstset).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
+    assert TTextInstSet(expected_ttextinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_ttextseqseteq', [
+    '[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, BB@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, BB@2019-09-03 00:00:00+01]',
+    ['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'BB@2019-09-03 00:00:00+01'],
+    [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+     TTextInst('BB@2019-09-03 00:00:00+01')],
+    (['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'], True, True),
+    ([TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+      TTextInst('AA@2019-09-03 00:00:00+01')], True, True),
+])
+def test_ttextseq_constructor(cursor, expected_ttextseqseteq):
+    if isinstance(expected_ttextseqseteq, tuple):
+        params = [TTextSeq(*expected_ttextseqseteq)]
+    else:
+        params = [TTextSeq(expected_ttextseqseteq)]
+    cursor.execute('INSERT INTO tbl_ttextseq (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_ttextseq WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_ttextseqseteq, tuple):
+        assert result == TTextSeq(*expected_ttextseqseteq)
+    else:
+        assert result == TTextSeq(expected_ttextseqseteq)
+
+
+@pytest.mark.parametrize('expected_ttextseqseteq', [
+    '[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]',
+])
+def test_ttextseq_accessors(cursor, expected_ttextseqseteq):
+    assert TTextSeq(expected_ttextseqseteq).tempSubtype() == 'Sequence'
+    assert TTextSeq(expected_ttextseqseteq).getValues == ['AA', 'BB', 'CC']
+    assert TTextSeq(expected_ttextseqseteq).startValue == 'AA'
+    assert TTextSeq(expected_ttextseqseteq).endValue == 'CC'
+    assert TTextSeq(expected_ttextseqseteq).minValue == 'AA'
+    assert TTextSeq(expected_ttextseqseteq).maxValue == 'CC'
+    assert TTextSeq(expected_ttextseqseteq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TTextSeq(expected_ttextseqseteq).duration == timedelta(2)
+    assert TTextSeq(expected_ttextseqseteq).timespan == timedelta(2)
+    assert TTextSeq(expected_ttextseqseteq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TTextSeq(expected_ttextseqseteq).numInstants == 3
+    assert TTextSeq(expected_ttextseqseteq).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
+    assert TTextSeq(expected_ttextseqseteq).endInstant == TTextInst('CC@2019-09-03 00:00:00+01')
+    assert TTextSeq(expected_ttextseqseteq).instantN(2) == TTextInst('BB@2019-09-02 00:00:00+01')
+    assert TTextSeq(expected_ttextseqseteq).instants == \
+           [TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'),
+            TTextInst('CC@2019-09-03 00:00:00+01')]
+    assert TTextSeq(expected_ttextseqseteq).numTimestamps == 3
+    assert TTextSeq(expected_ttextseqseteq).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TTextSeq(expected_ttextseqseteq).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TTextSeq(expected_ttextseqseteq).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TTextSeq(expected_ttextseqseteq).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                      parse('2019-09-02 00:00:00+01'),
+                                                      parse('2019-09-03 00:00:00+01')]
+    assert TTextSeq(expected_ttextseqseteq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TTextSeq(expected_ttextseqseteq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TTextSeq(expected_ttextseqseteq).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TTextSeq(expected_ttextseqseteq).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TTextSeq(expected_ttextseqseteq).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TTextSeq(expected_ttextseqseteq).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TTextSeq(expected_ttextseqseteq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TTextSeq(expected_ttextseqseteq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_ttextseqset', [
+    '{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}',
+    ['[AA@2019-09-01 00:00:00+01]', '[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]'],
+    [TTextSeq('[AA@2019-09-01 00:00:00+01]'),
+     TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')],
+])
+def test_ttextseqset_constructor(cursor, expected_ttextseqset):
+    if isinstance(expected_ttextseqset, tuple):
+        params = [TTextSeqSet(*expected_ttextseqset)]
+    else:
+        params = [TTextSeqSet(expected_ttextseqset)]
+    cursor.execute('INSERT INTO tbl_ttextseqset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_ttextseqset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_ttextseqset, tuple):
+        assert result == TTextSeqSet(*expected_ttextseqset)
+    else:
+        assert result == TTextSeqSet(expected_ttextseqset)
+
+
+@pytest.mark.parametrize('expected_ttextseqset', [
+    '{[AA@2019-09-01 00:00:00+01],  [BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]}',
+])
+def test_ttextseqset_accessors(cursor, expected_ttextseqset):
+    assert TTextSeqSet(expected_ttextseqset).tempSubtype() == 'SequenceSet'
+    assert TTextSeqSet(expected_ttextseqset).getValues == ['AA', 'BB', 'CC']
+    assert TTextSeqSet(expected_ttextseqset).startValue == 'AA'
+    assert TTextSeqSet(expected_ttextseqset).endValue == 'CC'
+    assert TTextSeqSet(expected_ttextseqset).minValue == 'AA'
+    assert TTextSeqSet(expected_ttextseqset).maxValue == 'CC'
+    assert TTextSeqSet(expected_ttextseqset).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TTextSeqSet(expected_ttextseqset).duration == timedelta(1)
+    assert TTextSeqSet(expected_ttextseqset).timespan == timedelta(2)
+    assert TTextSeqSet(expected_ttextseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TTextSeqSet(expected_ttextseqset).numInstants == 3
+    assert TTextSeqSet(expected_ttextseqset).startInstant == TTextInst('AA@2019-09-01 00:00:00+01')
+    assert TTextSeqSet(expected_ttextseqset).endInstant == TTextInst('CC@2019-09-03 00:00:00+01')
+    assert TTextSeqSet(expected_ttextseqset).instantN(2) == TTextInst('BB@2019-09-02 00:00:00+01')
+    assert TTextSeqSet(expected_ttextseqset).instants == [TTextInst('AA@2019-09-01 00:00:00+01'),
+                                                TTextInst('BB@2019-09-02 00:00:00+01'),
+                                                TTextInst('CC@2019-09-03 00:00:00+01')]
+    assert TTextSeqSet(expected_ttextseqset).numTimestamps == 3
+    assert TTextSeqSet(expected_ttextseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TTextSeqSet(expected_ttextseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TTextSeqSet(expected_ttextseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TTextSeqSet(expected_ttextseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                                  parse('2019-09-03 00:00:00+01')]
+    assert TTextSeqSet(expected_ttextseqset).numSequences == 2
+    assert TTextSeqSet(expected_ttextseqset).startSequence == TTextSeq('[AA@2019-09-01 00:00:00+01]')
+    assert TTextSeqSet(expected_ttextseqset).endSequence == TTextSeq(
+        '[BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]')
+    assert TTextSeqSet(expected_ttextseqset).sequenceN(2) == TTextSeq(
+        '[BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]')
+    assert TTextSeqSet(expected_ttextseqset).sequences == [TTextSeq('[AA@2019-09-01 00:00:00+01]'),
+                                                 TTextSeq(
+                                                     '[BB@2019-09-02 00:00:00+01, CC@2019-09-03 00:00:00+01]')]
+    assert TTextSeqSet(expected_ttextseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TTextSeqSet(expected_ttextseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TTextSeqSet(expected_ttextseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TTextSeqSet(expected_ttextseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TTextSeqSet(expected_ttextseqset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TTextSeqSet(expected_ttextseqset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TTextSeqSet(expected_ttextseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TTextSeqSet(expected_ttextseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_tgeogpoint.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_tgeogpoint.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,398 +1,398 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from datetime import timedelta
-from dateutil.parser import parse
-from postgis import Point, MultiPoint, LineString, MultiLineString, GeometryCollection
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TGeogPointInst, TGeogPointInstSet, TGeogPointSeq, TGeogPointSeqSet
-
-
-@pytest.mark.parametrize('expected_tgeogpointinst', [
-    'POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-    ('POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
-    ('SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
-    (Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')),
-    (Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')),
-])
-def test_tgeogpointinst_constructors(cursor, expected_tgeogpointinst):
-    if isinstance(expected_tgeogpointinst, tuple):
-        params = [TGeogPointInst(*expected_tgeogpointinst)]
-    else:
-        params = [TGeogPointInst(expected_tgeogpointinst)]
-    cursor.execute('INSERT INTO tbl_tgeogpointinst (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeogpointinst WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeogpointinst, tuple):
-        assert result == TGeogPointInst(*expected_tgeogpointinst)
-    else:
-        assert result == TGeogPointInst(expected_tgeogpointinst)
-
-
-@pytest.mark.parametrize('expected_tgeogpointinst', [
-    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
-])
-def test_tgeogpointinst_accessors(cursor, expected_tgeogpointinst):
-    assert TGeogPointInst(expected_tgeogpointinst).srid == 4326
-    assert TGeogPointInst(expected_tgeogpointinst).tempSubtype() == 'Instant'
-    assert TGeogPointInst(expected_tgeogpointinst).getValue == Point(10.0, 10.0)
-    assert TGeogPointInst(expected_tgeogpointinst).getValues == Point(10.0, 10.0)
-    assert TGeogPointInst(expected_tgeogpointinst).startValue == Point(10.0, 10.0)
-    assert TGeogPointInst(expected_tgeogpointinst).endValue == Point(10.0, 10.0)
-    assert TGeogPointInst(expected_tgeogpointinst).getTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeogPointInst(expected_tgeogpointinst).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
-    assert TGeogPointInst(expected_tgeogpointinst).duration == timedelta(0)
-    assert TGeogPointInst(expected_tgeogpointinst).timespan == timedelta(0)
-    assert TGeogPointInst(expected_tgeogpointinst).period == Period(
-        '[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
-    assert TGeogPointInst(expected_tgeogpointinst).numInstants == 1
-    assert TGeogPointInst(expected_tgeogpointinst).startInstant == TGeogPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeogPointInst(expected_tgeogpointinst).endInstant == TGeogPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeogPointInst(expected_tgeogpointinst).instantN(1) == TGeogPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeogPointInst(expected_tgeogpointinst).instants == [
-        TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')]
-    assert TGeogPointInst(expected_tgeogpointinst).numTimestamps == 1
-    assert TGeogPointInst(expected_tgeogpointinst).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeogPointInst(expected_tgeogpointinst).endTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeogPointInst(expected_tgeogpointinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
-    assert TGeogPointInst(expected_tgeogpointinst).timestamps == [parse('2019-09-01 00:00:00+01')]
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriod(
-        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriod(
-        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
-    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tgeogpointinstset', [
-    '{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
-    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
-    ('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'),
-    ('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'),
-    (TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')),
-    (TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')),
-    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    [TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-])
-def test_tgeogpointinstset_constructor(cursor, expected_tgeogpointinstset):
-    if isinstance(expected_tgeogpointinstset, tuple):
-        params = [TGeogPointInstSet(*expected_tgeogpointinstset)]
-    else:
-        params = [TGeogPointInstSet(expected_tgeogpointinstset)]
-    cursor.execute('INSERT INTO tbl_tgeogpointinstset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeogpointinstset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeogpointinstset, tuple):
-        assert result == TGeogPointInstSet(*expected_tgeogpointinstset)
-    else:
-        assert result == TGeogPointInstSet(expected_tgeogpointinstset)
-
-
-@pytest.mark.parametrize('expected_tgeogpointinstset', [
-    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(30.0 30.0)@2019-09-03 00:00:00+01}',
-])
-def test_tgeogpointinstset_accessors(cursor, expected_tgeogpointinstset):
-    assert TGeogPointInstSet(expected_tgeogpointinstset).srid == 4326
-    assert TGeogPointInstSet(expected_tgeogpointinstset).tempSubtype() == 'InstantSet'
-    assert TGeogPointInstSet(expected_tgeogpointinstset).getValues == \
-           MultiPoint([Point(10.0, 10.0),Point(20.0, 20.0),Point(30.0, 30.0)])
-    assert TGeogPointInstSet(expected_tgeogpointinstset).startValue == Point(10.0, 10.0)
-    assert TGeogPointInstSet(expected_tgeogpointinstset).endValue == Point(30.0, 30.0)
-    assert TGeogPointInstSet(expected_tgeogpointinstset).getTime == \
-           PeriodSet(
-               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
-               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).duration == timedelta(0)
-    assert TGeogPointInstSet(expected_tgeogpointinstset).timespan == timedelta(2)
-    assert TGeogPointInstSet(expected_tgeogpointinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).numInstants == 3
-    assert TGeogPointInstSet(expected_tgeogpointinstset).startInstant == TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).endInstant == TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).instantN(2) == TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).instants == [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-                                                            TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-                                                            TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
-    assert TGeogPointInstSet(expected_tgeogpointinstset).numTimestamps == 3
-    assert TGeogPointInstSet(expected_tgeogpointinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TGeogPointInstSet(expected_tgeogpointinstset).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                              parse('2019-09-02 00:00:00+01'),
-                                                              parse('2019-09-03 00:00:00+01')]
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriod(
-        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
-    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tgeogpointseq', [
-    '[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    'SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
-    [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    [TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise'),
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Linear', 4326),
-    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise', 4326),
-    ([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-    ([TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-])
-def test_tgeogpointseq_constructor(cursor, expected_tgeogpointseq):
-    if isinstance(expected_tgeogpointseq, tuple):
-        params = [TGeogPointSeq(*expected_tgeogpointseq)]
-    else:
-        params = [TGeogPointSeq(expected_tgeogpointseq)]
-    cursor.execute('INSERT INTO tbl_tgeogpointseq (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeogpointseq WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeogpointseq, tuple):
-        assert result == TGeogPointSeq(*expected_tgeogpointseq)
-    else:
-        assert result == TGeogPointSeq(expected_tgeogpointseq)
-
-@pytest.mark.parametrize('expected_tgeogpointseq', [
-    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
-    'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
-])
-def test_tgeogpointseq_accessors(cursor, expected_tgeogpointseq):
-    assert TGeogPointSeq(expected_tgeogpointseq).srid == 4326
-    assert TGeogPointSeq(expected_tgeogpointseq).tempSubtype() == 'Sequence'
-    assert TGeogPointSeq(expected_tgeogpointseq).getValues == LineString([Point(10.0, 10.0),Point(20.0, 20.0),Point(10.0, 10.0)])
-    assert TGeogPointSeq(expected_tgeogpointseq).startValue == Point(10.0, 10.0)
-    assert TGeogPointSeq(expected_tgeogpointseq).endValue == Point(10.0, 10.0)
-    assert TGeogPointSeq(expected_tgeogpointseq).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TGeogPointSeq(expected_tgeogpointseq).duration == timedelta(2)
-    assert TGeogPointSeq(expected_tgeogpointseq).timespan == timedelta(2)
-    assert TGeogPointSeq(expected_tgeogpointseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TGeogPointSeq(expected_tgeogpointseq).numInstants == 3
-    assert TGeogPointSeq(expected_tgeogpointseq).startInstant == TGeogPointInst(
-        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeogPointSeq(expected_tgeogpointseq).endInstant == TGeogPointInst(
-        'Point(10.0 10.0)@2019-09-03 00:00:00+01')
-    assert TGeogPointSeq(expected_tgeogpointseq).instantN(2) == TGeogPointInst(
-        'Point(20.0 20.0)@2019-09-02 00:00:00+01')
-    assert TGeogPointSeq(expected_tgeogpointseq).instants == \
-           [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-            TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-            TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')]
-    assert TGeogPointSeq(expected_tgeogpointseq).numTimestamps == 3
-    assert TGeogPointSeq(expected_tgeogpointseq).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeogPointSeq(expected_tgeogpointseq).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TGeogPointSeq(expected_tgeogpointseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TGeogPointSeq(expected_tgeogpointseq).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                                  parse('2019-09-02 00:00:00+01'),
-                                                                  parse('2019-09-03 00:00:00+01')]
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tgeogpointseqset', [
-    '{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    'SRID=4326;Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
-    ['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-    ['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
-    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
-    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise'),
-    (['SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'SRID=4326;Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise', 4326),
-    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
-        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
-        'Stepwise', 4326),
-    [TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
-    ([TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear'),
-    ([TGeogPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeogPointSeq(
-            'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
-     'Stepwise'),
-])
-def test_tgeogpointseqset_constructor(cursor, expected_tgeogpointseqset):
-    if isinstance(expected_tgeogpointseqset, tuple):
-        params = [TGeogPointSeqSet(*expected_tgeogpointseqset)]
-    else:
-        params = [TGeogPointSeqSet(expected_tgeogpointseqset)]
-    cursor.execute('INSERT INTO tbl_tgeogpointseqset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tgeogpointseqset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tgeogpointseqset, tuple):
-        assert result == TGeogPointSeqSet(*expected_tgeogpointseqset)
-    else:
-        assert result == TGeogPointSeqSet(expected_tgeogpointseqset)
-
-@pytest.mark.parametrize('expected_tgeogpointseqset', [
-    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01],  '
-    '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]}',
-])
-def test_tgeogpointseqset_accessors(cursor, expected_tgeogpointseqset):
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).srid == 4326
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).tempSubtype() == 'SequenceSet'
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).getValues == \
-        GeometryCollection([Point(10.0, 10.0), LineString([Point(20.0, 20.0), Point(30.0, 30.0)])])
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).startValue == Point(10.0, 10.0)
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).endValue == Point(30.0, 30.0)
-    # assert TGeogPointSeqSet(expected_tgeogpointseqset).valueRange == geompointrange(Point(10.0, 10.0), Point(30.0, 30.0), upper_inc=True)
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).duration == timedelta(1)
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).timespan == timedelta(2)
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).numInstants == 3
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).startInstant == TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).endInstant == TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).instantN(2) == TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).instants == [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
-                                                        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
-                                                        TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).numTimestamps == 3
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                          parse('2019-09-02 00:00:00+01'),
-                                                          parse('2019-09-03 00:00:00+01')]
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).numSequences == 2
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).startSequence == TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).endSequence == TGeogPointSeq(
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).sequenceN(2) == TGeogPointSeq(
-        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).sequences == [TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
-        TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')]
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from datetime import timedelta
+from dateutil.parser import parse
+from postgis import Point, MultiPoint, LineString, MultiLineString, GeometryCollection
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TGeogPointInst, TGeogPointInstSet, TGeogPointSeq, TGeogPointSeqSet
+
+
+@pytest.mark.parametrize('expected_tgeogpointinst', [
+    'POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+    ('POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
+    ('SRID=4326;POINT(10.0 10.0)', '2019-09-08 00:00:00+01'),
+    (Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')),
+    (Point(10.0, 10.0, srid=4326), parse('2019-09-08 00:00:00+01')),
+])
+def test_tgeogpointinst_constructors(cursor, expected_tgeogpointinst):
+    if isinstance(expected_tgeogpointinst, tuple):
+        params = [TGeogPointInst(*expected_tgeogpointinst)]
+    else:
+        params = [TGeogPointInst(expected_tgeogpointinst)]
+    cursor.execute('INSERT INTO tbl_tgeogpointinst (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeogpointinst WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeogpointinst, tuple):
+        assert result == TGeogPointInst(*expected_tgeogpointinst)
+    else:
+        assert result == TGeogPointInst(expected_tgeogpointinst)
+
+
+@pytest.mark.parametrize('expected_tgeogpointinst', [
+    'SRID=4326;POINT(10.0 10.0)@2019-09-01 00:00:00+01',
+])
+def test_tgeogpointinst_accessors(cursor, expected_tgeogpointinst):
+    assert TGeogPointInst(expected_tgeogpointinst).srid == 4326
+    assert TGeogPointInst(expected_tgeogpointinst).tempSubtype() == 'Instant'
+    assert TGeogPointInst(expected_tgeogpointinst).getValue == Point(10.0, 10.0)
+    assert TGeogPointInst(expected_tgeogpointinst).getValues == Point(10.0, 10.0)
+    assert TGeogPointInst(expected_tgeogpointinst).startValue == Point(10.0, 10.0)
+    assert TGeogPointInst(expected_tgeogpointinst).endValue == Point(10.0, 10.0)
+    assert TGeogPointInst(expected_tgeogpointinst).getTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeogPointInst(expected_tgeogpointinst).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
+    assert TGeogPointInst(expected_tgeogpointinst).duration == timedelta(0)
+    assert TGeogPointInst(expected_tgeogpointinst).timespan == timedelta(0)
+    assert TGeogPointInst(expected_tgeogpointinst).period == Period(
+        '[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
+    assert TGeogPointInst(expected_tgeogpointinst).numInstants == 1
+    assert TGeogPointInst(expected_tgeogpointinst).startInstant == TGeogPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeogPointInst(expected_tgeogpointinst).endInstant == TGeogPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeogPointInst(expected_tgeogpointinst).instantN(1) == TGeogPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeogPointInst(expected_tgeogpointinst).instants == [
+        TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')]
+    assert TGeogPointInst(expected_tgeogpointinst).numTimestamps == 1
+    assert TGeogPointInst(expected_tgeogpointinst).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeogPointInst(expected_tgeogpointinst).endTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeogPointInst(expected_tgeogpointinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
+    assert TGeogPointInst(expected_tgeogpointinst).timestamps == [parse('2019-09-01 00:00:00+01')]
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriod(
+        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriod(
+        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
+    assert TGeogPointInst(expected_tgeogpointinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tgeogpointinstset', [
+    '{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
+    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01}',
+    ('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'),
+    ('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'),
+    (TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')),
+    (TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')),
+    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    [TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+])
+def test_tgeogpointinstset_constructor(cursor, expected_tgeogpointinstset):
+    if isinstance(expected_tgeogpointinstset, tuple):
+        params = [TGeogPointInstSet(*expected_tgeogpointinstset)]
+    else:
+        params = [TGeogPointInstSet(expected_tgeogpointinstset)]
+    cursor.execute('INSERT INTO tbl_tgeogpointinstset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeogpointinstset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeogpointinstset, tuple):
+        assert result == TGeogPointInstSet(*expected_tgeogpointinstset)
+    else:
+        assert result == TGeogPointInstSet(expected_tgeogpointinstset)
+
+
+@pytest.mark.parametrize('expected_tgeogpointinstset', [
+    'SRID=4326;{Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(30.0 30.0)@2019-09-03 00:00:00+01}',
+])
+def test_tgeogpointinstset_accessors(cursor, expected_tgeogpointinstset):
+    assert TGeogPointInstSet(expected_tgeogpointinstset).srid == 4326
+    assert TGeogPointInstSet(expected_tgeogpointinstset).tempSubtype() == 'InstantSet'
+    assert TGeogPointInstSet(expected_tgeogpointinstset).getValues == \
+           MultiPoint([Point(10.0, 10.0),Point(20.0, 20.0),Point(30.0, 30.0)])
+    assert TGeogPointInstSet(expected_tgeogpointinstset).startValue == Point(10.0, 10.0)
+    assert TGeogPointInstSet(expected_tgeogpointinstset).endValue == Point(30.0, 30.0)
+    assert TGeogPointInstSet(expected_tgeogpointinstset).getTime == \
+           PeriodSet(
+               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
+               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).duration == timedelta(0)
+    assert TGeogPointInstSet(expected_tgeogpointinstset).timespan == timedelta(2)
+    assert TGeogPointInstSet(expected_tgeogpointinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).numInstants == 3
+    assert TGeogPointInstSet(expected_tgeogpointinstset).startInstant == TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).endInstant == TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).instantN(2) == TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).instants == [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+                                                            TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+                                                            TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
+    assert TGeogPointInstSet(expected_tgeogpointinstset).numTimestamps == 3
+    assert TGeogPointInstSet(expected_tgeogpointinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TGeogPointInstSet(expected_tgeogpointinstset).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                              parse('2019-09-02 00:00:00+01'),
+                                                              parse('2019-09-03 00:00:00+01')]
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriod(
+        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
+    assert TGeogPointInstSet(expected_tgeogpointinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tgeogpointseq', [
+    '[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    'SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+    ['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    ['SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01', 'SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01'],
+    [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    [TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')],
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise'),
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Linear', 4326),
+    (['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01',
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise', 4326),
+    ([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+    ([TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+        TGeogPointInst('SRID=4326;Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+])
+def test_tgeogpointseq_constructor(cursor, expected_tgeogpointseq):
+    if isinstance(expected_tgeogpointseq, tuple):
+        params = [TGeogPointSeq(*expected_tgeogpointseq)]
+    else:
+        params = [TGeogPointSeq(expected_tgeogpointseq)]
+    cursor.execute('INSERT INTO tbl_tgeogpointseq (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeogpointseq WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeogpointseq, tuple):
+        assert result == TGeogPointSeq(*expected_tgeogpointseq)
+    else:
+        assert result == TGeogPointSeq(expected_tgeogpointseq)
+
+@pytest.mark.parametrize('expected_tgeogpointseq', [
+    'SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, '
+    'Point(10.0 10.0)@2019-09-03 00:00:00+01]',
+])
+def test_tgeogpointseq_accessors(cursor, expected_tgeogpointseq):
+    assert TGeogPointSeq(expected_tgeogpointseq).srid == 4326
+    assert TGeogPointSeq(expected_tgeogpointseq).tempSubtype() == 'Sequence'
+    assert TGeogPointSeq(expected_tgeogpointseq).getValues == LineString([Point(10.0, 10.0),Point(20.0, 20.0),Point(10.0, 10.0)])
+    assert TGeogPointSeq(expected_tgeogpointseq).startValue == Point(10.0, 10.0)
+    assert TGeogPointSeq(expected_tgeogpointseq).endValue == Point(10.0, 10.0)
+    assert TGeogPointSeq(expected_tgeogpointseq).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TGeogPointSeq(expected_tgeogpointseq).duration == timedelta(2)
+    assert TGeogPointSeq(expected_tgeogpointseq).timespan == timedelta(2)
+    assert TGeogPointSeq(expected_tgeogpointseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TGeogPointSeq(expected_tgeogpointseq).numInstants == 3
+    assert TGeogPointSeq(expected_tgeogpointseq).startInstant == TGeogPointInst(
+        'Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeogPointSeq(expected_tgeogpointseq).endInstant == TGeogPointInst(
+        'Point(10.0 10.0)@2019-09-03 00:00:00+01')
+    assert TGeogPointSeq(expected_tgeogpointseq).instantN(2) == TGeogPointInst(
+        'Point(20.0 20.0)@2019-09-02 00:00:00+01')
+    assert TGeogPointSeq(expected_tgeogpointseq).instants == \
+           [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+            TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+            TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')]
+    assert TGeogPointSeq(expected_tgeogpointseq).numTimestamps == 3
+    assert TGeogPointSeq(expected_tgeogpointseq).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeogPointSeq(expected_tgeogpointseq).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TGeogPointSeq(expected_tgeogpointseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TGeogPointSeq(expected_tgeogpointseq).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                                  parse('2019-09-02 00:00:00+01'),
+                                                                  parse('2019-09-03 00:00:00+01')]
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeogPointSeq(expected_tgeogpointseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tgeogpointseqset', [
+    '{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    'SRID=4326;Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], '
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}',
+    ['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+    ['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
+    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['SRID=4326;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear', 4326),
+    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise'),
+    (['SRID=4326;Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'SRID=4326;Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise', 4326),
+    (['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]',
+        'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'],
+        'Stepwise', 4326),
+    [TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
+    ([TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear'),
+    ([TGeogPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeogPointSeq(
+            'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')],
+     'Stepwise'),
+])
+def test_tgeogpointseqset_constructor(cursor, expected_tgeogpointseqset):
+    if isinstance(expected_tgeogpointseqset, tuple):
+        params = [TGeogPointSeqSet(*expected_tgeogpointseqset)]
+    else:
+        params = [TGeogPointSeqSet(expected_tgeogpointseqset)]
+    cursor.execute('INSERT INTO tbl_tgeogpointseqset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tgeogpointseqset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tgeogpointseqset, tuple):
+        assert result == TGeogPointSeqSet(*expected_tgeogpointseqset)
+    else:
+        assert result == TGeogPointSeqSet(expected_tgeogpointseqset)
+
+@pytest.mark.parametrize('expected_tgeogpointseqset', [
+    'SRID=4326;{[Point(10.0 10.0)@2019-09-01 00:00:00+01],  '
+    '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]}',
+])
+def test_tgeogpointseqset_accessors(cursor, expected_tgeogpointseqset):
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).srid == 4326
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).tempSubtype() == 'SequenceSet'
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).getValues == \
+        GeometryCollection([Point(10.0, 10.0), LineString([Point(20.0, 20.0), Point(30.0, 30.0)])])
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).startValue == Point(10.0, 10.0)
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).endValue == Point(30.0, 30.0)
+    # assert TGeogPointSeqSet(expected_tgeogpointseqset).valueRange == geompointrange(Point(10.0, 10.0), Point(30.0, 30.0), upper_inc=True)
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).duration == timedelta(1)
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).timespan == timedelta(2)
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).numInstants == 3
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).startInstant == TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).endInstant == TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).instantN(2) == TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).instants == [TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'),
+                                                        TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'),
+                                                        TGeogPointInst('Point(30.0 30.0)@2019-09-03 00:00:00+01')]
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).numTimestamps == 3
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                          parse('2019-09-02 00:00:00+01'),
+                                                          parse('2019-09-03 00:00:00+01')]
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).numSequences == 2
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).startSequence == TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).endSequence == TGeogPointSeq(
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).sequenceN(2) == TGeogPointSeq(
+        '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).sequences == [TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),
+        TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(30.0 30.0)@2019-09-03 00:00:00+01]')]
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TGeogPointSeqSet(expected_tgeogpointseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/conftest.py` & `python-mobilitydb-0.1.3/tests/psycopg/conftest.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,80 +1,80 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-import psycopg2
-import os
-from mobilitydb import *
-from mobilitydb.psycopg import register
-
-db = psycopg2.connect(dbname=os.getenv('PGDATABASE', 'test'))
-db.autocommit = True
-
-register(db)
-cur = db.cursor()
-
-time_types = [TimestampSet, Period, PeriodSet]
-box_types = [TBox, STBox]
-subtype_suffixes = ['Inst', 'InstSet', 'Seq', 'SeqSet']
-subtype_names = ['INSTANT', 'INSTANTSET', 'SEQUENCE', 'SEQUENCESET']
-temporal_types = [TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint]
-
-def pytest_configure():
-    for time in time_types:
-        cur.execute(
-            'CREATE TABLE IF NOT EXISTS tbl_' + time.__name__.lower() +
-            '(timetype ' +  time.__name__.lower() + ' NOT NULL);')
-    for box in box_types:
-        cur.execute(
-            'CREATE TABLE IF NOT EXISTS tbl_' + box.__name__.lower() +
-            '(box ' +  box.__name__.lower() + ' NOT NULL);')
-    for ttype in temporal_types:
-        for suffix, name in zip(subtype_suffixes, subtype_names):
-            cur.execute(
-                'CREATE TABLE IF NOT EXISTS tbl_' + ttype.__name__.lower() + suffix +
-                '(temp ' + ttype.__name__.lower() + '(' + name + ') NOT NULL);')
-
-def pytest_unconfigure():
-    for time in time_types:
-        cur.execute(
-            'DROP TABLE tbl_' + time.__name__.lower() + ';')
-    for box in box_types:
-        cur.execute(
-            'DROP TABLE tbl_' + box.__name__.lower() + ';')
-    for ttype, suffix in zip(temporal_types, subtype_suffixes):
-        cur.execute('DROP TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
-
-@pytest.fixture
-def cursor():
-    # Make sure tables are clean.
-    for time in time_types:
-        cur.execute('TRUNCATE TABLE tbl_' + time.__name__.lower() + ';')
-    for box in box_types:
-        cur.execute('TRUNCATE TABLE tbl_' + box.__name__.lower() + ';')
-    for ttype in temporal_types:
-        for suffix in subtype_suffixes:
-            cur.execute('TRUNCATE TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
-    return cur
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+import psycopg2
+import os
+from mobilitydb import *
+from mobilitydb.psycopg import register
+
+db = psycopg2.connect(dbname=os.getenv('PGDATABASE', 'test'))
+db.autocommit = True
+
+register(db)
+cur = db.cursor()
+
+time_types = [TimestampSet, Period, PeriodSet]
+box_types = [TBox, STBox]
+subtype_suffixes = ['Inst', 'InstSet', 'Seq', 'SeqSet']
+subtype_names = ['INSTANT', 'INSTANTSET', 'SEQUENCE', 'SEQUENCESET']
+temporal_types = [TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint]
+
+def pytest_configure():
+    for time in time_types:
+        cur.execute(
+            'CREATE TABLE IF NOT EXISTS tbl_' + time.__name__.lower() +
+            '(timetype ' +  time.__name__.lower() + ' NOT NULL);')
+    for box in box_types:
+        cur.execute(
+            'CREATE TABLE IF NOT EXISTS tbl_' + box.__name__.lower() +
+            '(box ' +  box.__name__.lower() + ' NOT NULL);')
+    for ttype in temporal_types:
+        for suffix, name in zip(subtype_suffixes, subtype_names):
+            cur.execute(
+                'CREATE TABLE IF NOT EXISTS tbl_' + ttype.__name__.lower() + suffix +
+                '(temp ' + ttype.__name__.lower() + '(' + name + ') NOT NULL);')
+
+def pytest_unconfigure():
+    for time in time_types:
+        cur.execute(
+            'DROP TABLE tbl_' + time.__name__.lower() + ';')
+    for box in box_types:
+        cur.execute(
+            'DROP TABLE tbl_' + box.__name__.lower() + ';')
+    for ttype, suffix in zip(temporal_types, subtype_suffixes):
+        cur.execute('DROP TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
+
+@pytest.fixture
+def cursor():
+    # Make sure tables are clean.
+    for time in time_types:
+        cur.execute('TRUNCATE TABLE tbl_' + time.__name__.lower() + ';')
+    for box in box_types:
+        cur.execute('TRUNCATE TABLE tbl_' + box.__name__.lower() + ';')
+    for ttype in temporal_types:
+        for suffix in subtype_suffixes:
+            cur.execute('TRUNCATE TABLE tbl_' + ttype.__name__.lower() + suffix + ';')
+    return cur
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_tbool.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_tbool.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,292 +1,292 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from datetime import timedelta
-from dateutil.parser import parse
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TBoolInst, TBoolInstSet, TBoolSeq, TBoolSeqSet
-
-
-@pytest.mark.parametrize('expected_tboolinst', [
-    'true@2019-09-01 00:00:00+01',
-    ('true', '2019-09-08 00:00:00+01'),
-    ['true', '2019-09-08 00:00:00+01'],
-    (True, '2019-09-08 00:00:00+01'),
-    [True, parse('2019-09-08 00:00:00+01')],
-])
-def test_tboolinst_constructors(cursor, expected_tboolinst):
-    params = [TBoolInst(expected_tboolinst)]
-    cursor.execute('INSERT INTO tbl_tboolinst (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tboolinst WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    assert result == TBoolInst(expected_tboolinst)
-
-@pytest.mark.parametrize('expected_tboolinst', [
-    'true@2019-09-01 00:00:00+01',
-])
-def test_tboolinst_accessors(cursor, expected_tboolinst):
-    assert TBoolInst(expected_tboolinst).tempSubtype() == 'Instant'
-    assert TBoolInst(expected_tboolinst).getValue == True
-    assert TBoolInst(expected_tboolinst).getValues == [True]
-    assert TBoolInst(expected_tboolinst).startValue == True
-    assert TBoolInst(expected_tboolinst).endValue == True
-    assert TBoolInst(expected_tboolinst).getTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TBoolInst(expected_tboolinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
-    assert TBoolInst(expected_tboolinst).duration == timedelta(0)
-    assert TBoolInst(expected_tboolinst).timespan == timedelta(0)
-    assert TBoolInst(expected_tboolinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
-    assert TBoolInst(expected_tboolinst).numInstants == 1
-    assert TBoolInst(expected_tboolinst).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
-    assert TBoolInst(expected_tboolinst).endInstant == TBoolInst('true@2019-09-01 00:00:00+01')
-    assert TBoolInst(expected_tboolinst).instantN(1) == TBoolInst('true@2019-09-01 00:00:00+01')
-    assert TBoolInst(expected_tboolinst).instants == [TBoolInst('true@2019-09-01 00:00:00+01')]
-    assert TBoolInst(expected_tboolinst).numTimestamps == 1
-    assert TBoolInst(expected_tboolinst).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TBoolInst(expected_tboolinst).endTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TBoolInst(expected_tboolinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
-    assert TBoolInst(expected_tboolinst).timestamps == [parse('2019-09-01 00:00:00+01')]
-    assert TBoolInst(expected_tboolinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TBoolInst(expected_tboolinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
-    assert TBoolInst(expected_tboolinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TBoolInst(expected_tboolinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
-    assert TBoolInst(expected_tboolinst).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TBoolInst(expected_tboolinst).intersectsPeriod(
-        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
-    assert TBoolInst(expected_tboolinst).intersectsPeriod(
-        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
-    assert TBoolInst(expected_tboolinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TBoolInst(expected_tboolinst).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
-    assert TBoolInst(expected_tboolinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
-
-@pytest.mark.parametrize('expected_tboolinstset', [
-    '{true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01}',
-    ('true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'),
-    (TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-     TBoolInst('true@2019-09-03 00:00:00+01')),
-    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'],
-    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-     TBoolInst('true@2019-09-03 00:00:00+01')],
-])
-def test_tboolinstset_constructor(cursor, expected_tboolinstset):
-    if isinstance(expected_tboolinstset, tuple):
-        params = [TBoolInstSet(*expected_tboolinstset)]
-    else:
-        params = [TBoolInstSet(expected_tboolinstset)]
-    cursor.execute('INSERT INTO tbl_tboolinstset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tboolinstset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tboolinstset, tuple):
-        assert result == TBoolInstSet(*expected_tboolinstset)
-    else:
-        assert result == TBoolInstSet(expected_tboolinstset)
-
-@pytest.mark.parametrize('expected_tboolinstset', [
-    '{true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01}',
-])
-def test_tboolinstset_accessors(cursor, expected_tboolinstset):
-    assert TBoolInstSet(expected_tboolinstset).tempSubtype() == 'InstantSet'
-    assert TBoolInstSet(expected_tboolinstset).getValues == [True, False]
-    assert TBoolInstSet(expected_tboolinstset).startValue == True
-    assert TBoolInstSet(expected_tboolinstset).endValue == True
-    assert TBoolInstSet(expected_tboolinstset).getTime == \
-           PeriodSet(
-               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
-               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TBoolInstSet(expected_tboolinstset).duration == timedelta(0)
-    assert TBoolInstSet(expected_tboolinstset).timespan == timedelta(2)
-    assert TBoolInstSet(expected_tboolinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TBoolInstSet(expected_tboolinstset).numInstants == 3
-    assert TBoolInstSet(expected_tboolinstset).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
-    assert TBoolInstSet(expected_tboolinstset).endInstant == TBoolInst('true@2019-09-03 00:00:00+01')
-    assert TBoolInstSet(expected_tboolinstset).instantN(2) == TBoolInst('false@2019-09-02 00:00:00+01')
-    assert TBoolInstSet(expected_tboolinstset).instants == [TBoolInst('true@2019-09-01 00:00:00+01'),
-                                                TBoolInst('false@2019-09-02 00:00:00+01'),
-                                                TBoolInst('true@2019-09-03 00:00:00+01')]
-    assert TBoolInstSet(expected_tboolinstset).numTimestamps == 3
-    assert TBoolInstSet(expected_tboolinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TBoolInstSet(expected_tboolinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TBoolInstSet(expected_tboolinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TBoolInstSet(expected_tboolinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                                  parse('2019-09-03 00:00:00+01')]
-    assert TBoolInstSet(expected_tboolinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TBoolInstSet(expected_tboolinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TBoolInstSet(expected_tboolinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TBoolInstSet(expected_tboolinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TBoolInstSet(expected_tboolinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TBoolInstSet(expected_tboolinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
-    assert TBoolInstSet(expected_tboolinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TBoolInstSet(expected_tboolinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TBoolInstSet(expected_tboolinstset).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
-    assert TBoolInstSet(expected_tboolinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-@pytest.mark.parametrize('expected_tboolseq', [
-    '[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, false@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, false@2019-09-03 00:00:00+01]',
-    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'false@2019-09-03 00:00:00+01'],
-    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-     TBoolInst('false@2019-09-03 00:00:00+01')],
-    (['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'], True, True),
-    ([TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-      TBoolInst('true@2019-09-03 00:00:00+01')], True, True),
-])
-def test_tboolseq_constructor(cursor, expected_tboolseq):
-    if isinstance(expected_tboolseq, tuple):
-        params = [TBoolSeq(*expected_tboolseq)]
-    else:
-        params = [TBoolSeq(expected_tboolseq)]
-    cursor.execute('INSERT INTO tbl_tboolseq (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tboolseq WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tboolseq, tuple):
-        assert result == TBoolSeq(*expected_tboolseq)
-    else:
-        assert result == TBoolSeq(expected_tboolseq)
-
-
-@pytest.mark.parametrize('expected_tboolseq', [
-    '[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]',
-])
-def test_tboolseq_accessors(cursor, expected_tboolseq):
-    assert TBoolSeq(expected_tboolseq).tempSubtype() == 'Sequence'
-    assert TBoolSeq(expected_tboolseq).getValues == [True, False]
-    assert TBoolSeq(expected_tboolseq).startValue == True
-    assert TBoolSeq(expected_tboolseq).endValue == True
-    assert TBoolSeq(expected_tboolseq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TBoolSeq(expected_tboolseq).duration == timedelta(2)
-    assert TBoolSeq(expected_tboolseq).timespan == timedelta(2)
-    assert TBoolSeq(expected_tboolseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TBoolSeq(expected_tboolseq).numInstants == 3
-    assert TBoolSeq(expected_tboolseq).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
-    assert TBoolSeq(expected_tboolseq).endInstant == TBoolInst('true@2019-09-03 00:00:00+01')
-    assert TBoolSeq(expected_tboolseq).instantN(2) == TBoolInst('false@2019-09-02 00:00:00+01')
-    assert TBoolSeq(expected_tboolseq).instants == \
-           [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
-            TBoolInst('true@2019-09-03 00:00:00+01')]
-    assert TBoolSeq(expected_tboolseq).numTimestamps == 3
-    assert TBoolSeq(expected_tboolseq).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TBoolSeq(expected_tboolseq).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TBoolSeq(expected_tboolseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TBoolSeq(expected_tboolseq).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                      parse('2019-09-02 00:00:00+01'),
-                                                      parse('2019-09-03 00:00:00+01')]
-    assert TBoolSeq(expected_tboolseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TBoolSeq(expected_tboolseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TBoolSeq(expected_tboolseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TBoolSeq(expected_tboolseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TBoolSeq(expected_tboolseq).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TBoolSeq(expected_tboolseq).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TBoolSeq(expected_tboolseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TBoolSeq(expected_tboolseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tboolseqset', [
-    '{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
-    ['[true@2019-09-01 00:00:00+01]', '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]'],
-    [TBoolSeq('[true@2019-09-01 00:00:00+01]'),
-     TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')],
-])
-def test_tboolseqset_constructor(cursor, expected_tboolseqset):
-    if isinstance(expected_tboolseqset, tuple):
-        params = [TBoolSeqSet(*expected_tboolseqset)]
-    else:
-        params = [TBoolSeqSet(expected_tboolseqset)]
-    cursor.execute('INSERT INTO tbl_tboolseqset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tboolseqset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tboolseqset, tuple):
-        assert result == TBoolSeqSet(*expected_tboolseqset)
-    else:
-        assert result == TBoolSeqSet(expected_tboolseqset)
-
-
-@pytest.mark.parametrize('expected_tboolseqset', [
-    '{[true@2019-09-01 00:00:00+01],  [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
-])
-def test_tboolseqset_accessors(cursor, expected_tboolseqset):
-    assert TBoolSeqSet(expected_tboolseqset).tempSubtype() == 'SequenceSet'
-    assert TBoolSeqSet(expected_tboolseqset).getValues == [True, False]
-    assert TBoolSeqSet(expected_tboolseqset).startValue == True
-    assert TBoolSeqSet(expected_tboolseqset).endValue == True
-    assert TBoolSeqSet(expected_tboolseqset).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TBoolSeqSet(expected_tboolseqset).duration == timedelta(1)
-    assert TBoolSeqSet(expected_tboolseqset).timespan == timedelta(2)
-    assert TBoolSeqSet(expected_tboolseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TBoolSeqSet(expected_tboolseqset).numInstants == 3
-    assert TBoolSeqSet(expected_tboolseqset).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
-    assert TBoolSeqSet(expected_tboolseqset).endInstant == TBoolInst('true@2019-09-03 00:00:00+01')
-    assert TBoolSeqSet(expected_tboolseqset).instantN(2) == TBoolInst('false@2019-09-02 00:00:00+01')
-    assert TBoolSeqSet(expected_tboolseqset).instants == [TBoolInst('true@2019-09-01 00:00:00+01'),
-                                                TBoolInst('false@2019-09-02 00:00:00+01'),
-                                                TBoolInst('true@2019-09-03 00:00:00+01')]
-    assert TBoolSeqSet(expected_tboolseqset).numTimestamps == 3
-    assert TBoolSeqSet(expected_tboolseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TBoolSeqSet(expected_tboolseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TBoolSeqSet(expected_tboolseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TBoolSeqSet(expected_tboolseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                                  parse('2019-09-03 00:00:00+01')]
-    assert TBoolSeqSet(expected_tboolseqset).numSequences == 2
-    assert TBoolSeqSet(expected_tboolseqset).startSequence == TBoolSeq('[true@2019-09-01 00:00:00+01]')
-    assert TBoolSeqSet(expected_tboolseqset).endSequence == TBoolSeq(
-        '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')
-    assert TBoolSeqSet(expected_tboolseqset).sequenceN(2) == TBoolSeq(
-        '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')
-    assert TBoolSeqSet(expected_tboolseqset).sequences == [TBoolSeq('[true@2019-09-01 00:00:00+01]'),
-                                                 TBoolSeq(
-                                                     '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')]
-    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from datetime import timedelta
+from dateutil.parser import parse
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TBoolInst, TBoolInstSet, TBoolSeq, TBoolSeqSet
+
+
+@pytest.mark.parametrize('expected_tboolinst', [
+    'true@2019-09-01 00:00:00+01',
+    ('true', '2019-09-08 00:00:00+01'),
+    ['true', '2019-09-08 00:00:00+01'],
+    (True, '2019-09-08 00:00:00+01'),
+    [True, parse('2019-09-08 00:00:00+01')],
+])
+def test_tboolinst_constructors(cursor, expected_tboolinst):
+    params = [TBoolInst(expected_tboolinst)]
+    cursor.execute('INSERT INTO tbl_tboolinst (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tboolinst WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    assert result == TBoolInst(expected_tboolinst)
+
+@pytest.mark.parametrize('expected_tboolinst', [
+    'true@2019-09-01 00:00:00+01',
+])
+def test_tboolinst_accessors(cursor, expected_tboolinst):
+    assert TBoolInst(expected_tboolinst).tempSubtype() == 'Instant'
+    assert TBoolInst(expected_tboolinst).getValue == True
+    assert TBoolInst(expected_tboolinst).getValues == [True]
+    assert TBoolInst(expected_tboolinst).startValue == True
+    assert TBoolInst(expected_tboolinst).endValue == True
+    assert TBoolInst(expected_tboolinst).getTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TBoolInst(expected_tboolinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
+    assert TBoolInst(expected_tboolinst).duration == timedelta(0)
+    assert TBoolInst(expected_tboolinst).timespan == timedelta(0)
+    assert TBoolInst(expected_tboolinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
+    assert TBoolInst(expected_tboolinst).numInstants == 1
+    assert TBoolInst(expected_tboolinst).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
+    assert TBoolInst(expected_tboolinst).endInstant == TBoolInst('true@2019-09-01 00:00:00+01')
+    assert TBoolInst(expected_tboolinst).instantN(1) == TBoolInst('true@2019-09-01 00:00:00+01')
+    assert TBoolInst(expected_tboolinst).instants == [TBoolInst('true@2019-09-01 00:00:00+01')]
+    assert TBoolInst(expected_tboolinst).numTimestamps == 1
+    assert TBoolInst(expected_tboolinst).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TBoolInst(expected_tboolinst).endTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TBoolInst(expected_tboolinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
+    assert TBoolInst(expected_tboolinst).timestamps == [parse('2019-09-01 00:00:00+01')]
+    assert TBoolInst(expected_tboolinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TBoolInst(expected_tboolinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
+    assert TBoolInst(expected_tboolinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TBoolInst(expected_tboolinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
+    assert TBoolInst(expected_tboolinst).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TBoolInst(expected_tboolinst).intersectsPeriod(
+        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
+    assert TBoolInst(expected_tboolinst).intersectsPeriod(
+        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
+    assert TBoolInst(expected_tboolinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TBoolInst(expected_tboolinst).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
+    assert TBoolInst(expected_tboolinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
+
+@pytest.mark.parametrize('expected_tboolinstset', [
+    '{true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01}',
+    ('true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'),
+    (TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+     TBoolInst('true@2019-09-03 00:00:00+01')),
+    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'],
+    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+     TBoolInst('true@2019-09-03 00:00:00+01')],
+])
+def test_tboolinstset_constructor(cursor, expected_tboolinstset):
+    if isinstance(expected_tboolinstset, tuple):
+        params = [TBoolInstSet(*expected_tboolinstset)]
+    else:
+        params = [TBoolInstSet(expected_tboolinstset)]
+    cursor.execute('INSERT INTO tbl_tboolinstset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tboolinstset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tboolinstset, tuple):
+        assert result == TBoolInstSet(*expected_tboolinstset)
+    else:
+        assert result == TBoolInstSet(expected_tboolinstset)
+
+@pytest.mark.parametrize('expected_tboolinstset', [
+    '{true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01}',
+])
+def test_tboolinstset_accessors(cursor, expected_tboolinstset):
+    assert TBoolInstSet(expected_tboolinstset).tempSubtype() == 'InstantSet'
+    assert TBoolInstSet(expected_tboolinstset).getValues == [True, False]
+    assert TBoolInstSet(expected_tboolinstset).startValue == True
+    assert TBoolInstSet(expected_tboolinstset).endValue == True
+    assert TBoolInstSet(expected_tboolinstset).getTime == \
+           PeriodSet(
+               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
+               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TBoolInstSet(expected_tboolinstset).duration == timedelta(0)
+    assert TBoolInstSet(expected_tboolinstset).timespan == timedelta(2)
+    assert TBoolInstSet(expected_tboolinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TBoolInstSet(expected_tboolinstset).numInstants == 3
+    assert TBoolInstSet(expected_tboolinstset).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
+    assert TBoolInstSet(expected_tboolinstset).endInstant == TBoolInst('true@2019-09-03 00:00:00+01')
+    assert TBoolInstSet(expected_tboolinstset).instantN(2) == TBoolInst('false@2019-09-02 00:00:00+01')
+    assert TBoolInstSet(expected_tboolinstset).instants == [TBoolInst('true@2019-09-01 00:00:00+01'),
+                                                TBoolInst('false@2019-09-02 00:00:00+01'),
+                                                TBoolInst('true@2019-09-03 00:00:00+01')]
+    assert TBoolInstSet(expected_tboolinstset).numTimestamps == 3
+    assert TBoolInstSet(expected_tboolinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TBoolInstSet(expected_tboolinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TBoolInstSet(expected_tboolinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TBoolInstSet(expected_tboolinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                                  parse('2019-09-03 00:00:00+01')]
+    assert TBoolInstSet(expected_tboolinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TBoolInstSet(expected_tboolinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TBoolInstSet(expected_tboolinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TBoolInstSet(expected_tboolinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TBoolInstSet(expected_tboolinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TBoolInstSet(expected_tboolinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
+    assert TBoolInstSet(expected_tboolinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TBoolInstSet(expected_tboolinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TBoolInstSet(expected_tboolinstset).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
+    assert TBoolInstSet(expected_tboolinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+@pytest.mark.parametrize('expected_tboolseq', [
+    '[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, false@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, false@2019-09-03 00:00:00+01]',
+    ['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'false@2019-09-03 00:00:00+01'],
+    [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+     TBoolInst('false@2019-09-03 00:00:00+01')],
+    (['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'], True, True),
+    ([TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+      TBoolInst('true@2019-09-03 00:00:00+01')], True, True),
+])
+def test_tboolseq_constructor(cursor, expected_tboolseq):
+    if isinstance(expected_tboolseq, tuple):
+        params = [TBoolSeq(*expected_tboolseq)]
+    else:
+        params = [TBoolSeq(expected_tboolseq)]
+    cursor.execute('INSERT INTO tbl_tboolseq (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tboolseq WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tboolseq, tuple):
+        assert result == TBoolSeq(*expected_tboolseq)
+    else:
+        assert result == TBoolSeq(expected_tboolseq)
+
+
+@pytest.mark.parametrize('expected_tboolseq', [
+    '[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]',
+])
+def test_tboolseq_accessors(cursor, expected_tboolseq):
+    assert TBoolSeq(expected_tboolseq).tempSubtype() == 'Sequence'
+    assert TBoolSeq(expected_tboolseq).getValues == [True, False]
+    assert TBoolSeq(expected_tboolseq).startValue == True
+    assert TBoolSeq(expected_tboolseq).endValue == True
+    assert TBoolSeq(expected_tboolseq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TBoolSeq(expected_tboolseq).duration == timedelta(2)
+    assert TBoolSeq(expected_tboolseq).timespan == timedelta(2)
+    assert TBoolSeq(expected_tboolseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TBoolSeq(expected_tboolseq).numInstants == 3
+    assert TBoolSeq(expected_tboolseq).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
+    assert TBoolSeq(expected_tboolseq).endInstant == TBoolInst('true@2019-09-03 00:00:00+01')
+    assert TBoolSeq(expected_tboolseq).instantN(2) == TBoolInst('false@2019-09-02 00:00:00+01')
+    assert TBoolSeq(expected_tboolseq).instants == \
+           [TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'),
+            TBoolInst('true@2019-09-03 00:00:00+01')]
+    assert TBoolSeq(expected_tboolseq).numTimestamps == 3
+    assert TBoolSeq(expected_tboolseq).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TBoolSeq(expected_tboolseq).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TBoolSeq(expected_tboolseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TBoolSeq(expected_tboolseq).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                      parse('2019-09-02 00:00:00+01'),
+                                                      parse('2019-09-03 00:00:00+01')]
+    assert TBoolSeq(expected_tboolseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TBoolSeq(expected_tboolseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TBoolSeq(expected_tboolseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TBoolSeq(expected_tboolseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TBoolSeq(expected_tboolseq).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TBoolSeq(expected_tboolseq).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TBoolSeq(expected_tboolseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TBoolSeq(expected_tboolseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tboolseqset', [
+    '{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
+    ['[true@2019-09-01 00:00:00+01]', '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]'],
+    [TBoolSeq('[true@2019-09-01 00:00:00+01]'),
+     TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')],
+])
+def test_tboolseqset_constructor(cursor, expected_tboolseqset):
+    if isinstance(expected_tboolseqset, tuple):
+        params = [TBoolSeqSet(*expected_tboolseqset)]
+    else:
+        params = [TBoolSeqSet(expected_tboolseqset)]
+    cursor.execute('INSERT INTO tbl_tboolseqset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tboolseqset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tboolseqset, tuple):
+        assert result == TBoolSeqSet(*expected_tboolseqset)
+    else:
+        assert result == TBoolSeqSet(expected_tboolseqset)
+
+
+@pytest.mark.parametrize('expected_tboolseqset', [
+    '{[true@2019-09-01 00:00:00+01],  [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}',
+])
+def test_tboolseqset_accessors(cursor, expected_tboolseqset):
+    assert TBoolSeqSet(expected_tboolseqset).tempSubtype() == 'SequenceSet'
+    assert TBoolSeqSet(expected_tboolseqset).getValues == [True, False]
+    assert TBoolSeqSet(expected_tboolseqset).startValue == True
+    assert TBoolSeqSet(expected_tboolseqset).endValue == True
+    assert TBoolSeqSet(expected_tboolseqset).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TBoolSeqSet(expected_tboolseqset).duration == timedelta(1)
+    assert TBoolSeqSet(expected_tboolseqset).timespan == timedelta(2)
+    assert TBoolSeqSet(expected_tboolseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TBoolSeqSet(expected_tboolseqset).numInstants == 3
+    assert TBoolSeqSet(expected_tboolseqset).startInstant == TBoolInst('true@2019-09-01 00:00:00+01')
+    assert TBoolSeqSet(expected_tboolseqset).endInstant == TBoolInst('true@2019-09-03 00:00:00+01')
+    assert TBoolSeqSet(expected_tboolseqset).instantN(2) == TBoolInst('false@2019-09-02 00:00:00+01')
+    assert TBoolSeqSet(expected_tboolseqset).instants == [TBoolInst('true@2019-09-01 00:00:00+01'),
+                                                TBoolInst('false@2019-09-02 00:00:00+01'),
+                                                TBoolInst('true@2019-09-03 00:00:00+01')]
+    assert TBoolSeqSet(expected_tboolseqset).numTimestamps == 3
+    assert TBoolSeqSet(expected_tboolseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TBoolSeqSet(expected_tboolseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TBoolSeqSet(expected_tboolseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TBoolSeqSet(expected_tboolseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                                  parse('2019-09-03 00:00:00+01')]
+    assert TBoolSeqSet(expected_tboolseqset).numSequences == 2
+    assert TBoolSeqSet(expected_tboolseqset).startSequence == TBoolSeq('[true@2019-09-01 00:00:00+01]')
+    assert TBoolSeqSet(expected_tboolseqset).endSequence == TBoolSeq(
+        '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')
+    assert TBoolSeqSet(expected_tboolseqset).sequenceN(2) == TBoolSeq(
+        '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')
+    assert TBoolSeqSet(expected_tboolseqset).sequences == [TBoolSeq('[true@2019-09-01 00:00:00+01]'),
+                                                 TBoolSeq(
+                                                     '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')]
+    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TBoolSeqSet(expected_tboolseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TBoolSeqSet(expected_tboolseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_tfloat.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_tfloat.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,314 +1,314 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from datetime import timedelta
-from dateutil.parser import parse
-from spans.types import floatrange
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
-
-
-@pytest.mark.parametrize('expected_tfloatinst', [
-    '10.0@2019-09-01 00:00:00+01',
-    ('10.0', '2019-09-08 00:00:00+01'),
-    ['10.0', '2019-09-08 00:00:00+01'],
-    (10.0, parse('2019-09-08 00:00:00+01')),
-    [10.0, parse('2019-09-08 00:00:00+01')],
-])
-def test_tfloatinst_constructors(cursor, expected_tfloatinst):
-    params = [TFloatInst(expected_tfloatinst)]
-    cursor.execute('INSERT INTO tbl_tfloatinst (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tfloatinst WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    assert result == TFloatInst(expected_tfloatinst)
-
-@pytest.mark.parametrize('expected_tfloatinst', [
-    '10.0@2019-09-01 00:00:00+01',
-])
-def test_tfloatinst_accessors(cursor, expected_tfloatinst):
-    assert TFloatInst(expected_tfloatinst).tempSubtype() == 'Instant'
-    assert TFloatInst(expected_tfloatinst).getValue == 10.0
-    assert TFloatInst(expected_tfloatinst).getValues == [floatrange(10.0, 10.0, upper_inc=True)]
-    assert TFloatInst(expected_tfloatinst).startValue == 10.0
-    assert TFloatInst(expected_tfloatinst).endValue == 10.0
-    assert TFloatInst(expected_tfloatinst).minValue == 10.0
-    assert TFloatInst(expected_tfloatinst).maxValue == 10.0
-    assert TFloatInst(expected_tfloatinst).valueRange == floatrange(10.0, 10.0, upper_inc=True)
-    assert TFloatInst(expected_tfloatinst).getTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TFloatInst(expected_tfloatinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
-    assert TFloatInst(expected_tfloatinst).duration == timedelta(0)
-    assert TFloatInst(expected_tfloatinst).timespan == timedelta(0)
-    assert TFloatInst(expected_tfloatinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
-    assert TFloatInst(expected_tfloatinst).numInstants == 1
-    assert TFloatInst(expected_tfloatinst).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
-    assert TFloatInst(expected_tfloatinst).endInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
-    assert TFloatInst(expected_tfloatinst).instantN(1) == TFloatInst('10.0@2019-09-01 00:00:00+01')
-    assert TFloatInst(expected_tfloatinst).instants == [TFloatInst('10.0@2019-09-01 00:00:00+01')]
-    assert TFloatInst(expected_tfloatinst).numTimestamps == 1
-    assert TFloatInst(expected_tfloatinst).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TFloatInst(expected_tfloatinst).endTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TFloatInst(expected_tfloatinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
-    assert TFloatInst(expected_tfloatinst).timestamps == [parse('2019-09-01 00:00:00+01')]
-    assert TFloatInst(expected_tfloatinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TFloatInst(expected_tfloatinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
-    assert TFloatInst(expected_tfloatinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TFloatInst(expected_tfloatinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
-    assert TFloatInst(expected_tfloatinst).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TFloatInst(expected_tfloatinst).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
-    assert TFloatInst(expected_tfloatinst).intersectsPeriod(Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
-    assert TFloatInst(expected_tfloatinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TFloatInst(expected_tfloatinst).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
-    assert TFloatInst(expected_tfloatinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tfloatinstset', [
-    '{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01}',
-    ('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'),
-    (TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-     TFloatInst('10.0@2019-09-03 00:00:00+01')),
-    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
-    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-     TFloatInst('10.0@2019-09-03 00:00:00+01')],
-])
-def test_tfloatinstset_constructor(cursor, expected_tfloatinstset):
-    if isinstance(expected_tfloatinstset, tuple):
-        params = [TFloatInstSet(*expected_tfloatinstset)]
-    else:
-        params = [TFloatInstSet(expected_tfloatinstset)]
-    cursor.execute('INSERT INTO tbl_tfloatinstset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tfloatinstset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tfloatinstset, tuple):
-        assert result == TFloatInstSet(*expected_tfloatinstset)
-    else:
-        assert result == TFloatInstSet(expected_tfloatinstset)
-
-
-@pytest.mark.parametrize('expected_tfloatinstset', [
-    '{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01}',
-])
-def test_tfloatinstset_accessors(cursor, expected_tfloatinstset):
-    assert TFloatInstSet(expected_tfloatinstset).tempSubtype() == 'InstantSet'
-    assert TFloatInstSet(expected_tfloatinstset).getValues == [floatrange(10.0, 10.0, upper_inc=True),
-                                             floatrange(20.0, 20.0, upper_inc=True),
-                                             floatrange(30.0, 30.0, upper_inc=True)]
-    assert TFloatInstSet(expected_tfloatinstset).startValue == 10.0
-    assert TFloatInstSet(expected_tfloatinstset).endValue == 30.0
-    assert TFloatInstSet(expected_tfloatinstset).minValue == 10.0
-    assert TFloatInstSet(expected_tfloatinstset).maxValue == 30.0
-    assert TFloatInstSet(expected_tfloatinstset).valueRange == floatrange(10.0, 30.0, upper_inc=True)
-    assert TFloatInstSet(expected_tfloatinstset).getTime == \
-           PeriodSet(
-               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
-               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TFloatInstSet(expected_tfloatinstset).duration == timedelta(0)
-    assert TFloatInstSet(expected_tfloatinstset).timespan == timedelta(2)
-    assert TFloatInstSet(expected_tfloatinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TFloatInstSet(expected_tfloatinstset).numInstants == 3
-    assert TFloatInstSet(expected_tfloatinstset).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
-    assert TFloatInstSet(expected_tfloatinstset).endInstant == TFloatInst('30.0@2019-09-03 00:00:00+01')
-    assert TFloatInstSet(expected_tfloatinstset).instantN(2) == TFloatInst('20.0@2019-09-02 00:00:00+01')
-    assert TFloatInstSet(expected_tfloatinstset).instants == [TFloatInst('10.0@2019-09-01 00:00:00+01'),
-                                            TFloatInst('20.0@2019-09-02 00:00:00+01'),
-                                            TFloatInst('30.0@2019-09-03 00:00:00+01')]
-    assert TFloatInstSet(expected_tfloatinstset).numTimestamps == 3
-    assert TFloatInstSet(expected_tfloatinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TFloatInstSet(expected_tfloatinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TFloatInstSet(expected_tfloatinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TFloatInstSet(expected_tfloatinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                              parse('2019-09-03 00:00:00+01')]
-    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
-    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
-    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tfloatseqseteq', [
-    '[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
-    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
-    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-     TFloatInst('10.0@2019-09-03 00:00:00+01')],
-    (['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True,
-     'Stepwise'),
-    ([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-      TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
-])
-def test_tfloatseq_constructor(cursor, expected_tfloatseqseteq):
-    if isinstance(expected_tfloatseqseteq, tuple):
-        params = [TFloatSeq(*expected_tfloatseqseteq)]
-    else:
-        params = [TFloatSeq(expected_tfloatseqseteq)]
-    cursor.execute('INSERT INTO tbl_tfloatseq (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tfloatseq WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tfloatseqseteq, tuple):
-        assert result == TFloatSeq(*expected_tfloatseqseteq)
-    else:
-        assert result == TFloatSeq(expected_tfloatseqseteq)
-
-
-@pytest.mark.parametrize('expected_tfloatseqseteq', [
-    '[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]',
-])
-def test_tfloatseq_accessors(cursor, expected_tfloatseqseteq):
-    assert TFloatSeq(expected_tfloatseqseteq).tempSubtype() == 'Sequence'
-    # assert TFloatSeq(expected_tfloatseqseteq).getValues == [floatrange(10.0, 30.0, upper_inc=True)]
-    assert TFloatSeq(expected_tfloatseqseteq).startValue == 10.0
-    assert TFloatSeq(expected_tfloatseqseteq).endValue == 30.0
-    assert TFloatSeq(expected_tfloatseqseteq).minValue == 10.0
-    assert TFloatSeq(expected_tfloatseqseteq).maxValue == 30.0
-    assert TFloatSeq(expected_tfloatseqseteq).valueRange == floatrange(10.0, 30.0, upper_inc=True)
-    assert TFloatSeq(expected_tfloatseqseteq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TFloatSeq(expected_tfloatseqseteq).duration == timedelta(2)
-    assert TFloatSeq(expected_tfloatseqseteq).timespan == timedelta(2)
-    assert TFloatSeq(expected_tfloatseqseteq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TFloatSeq(expected_tfloatseqseteq).numInstants == 3
-    assert TFloatSeq(expected_tfloatseqseteq).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
-    assert TFloatSeq(expected_tfloatseqseteq).endInstant == TFloatInst('30.0@2019-09-03 00:00:00+01')
-    assert TFloatSeq(expected_tfloatseqseteq).instantN(2) == TFloatInst('20.0@2019-09-02 00:00:00+01')
-    assert TFloatSeq(expected_tfloatseqseteq).instants == \
-           [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
-            TFloatInst('30.0@2019-09-03 00:00:00+01')]
-    assert TFloatSeq(expected_tfloatseqseteq).numTimestamps == 3
-    assert TFloatSeq(expected_tfloatseqseteq).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TFloatSeq(expected_tfloatseqseteq).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TFloatSeq(expected_tfloatseqseteq).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TFloatSeq(expected_tfloatseqseteq).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                          parse('2019-09-02 00:00:00+01'),
-                                                          parse('2019-09-03 00:00:00+01')]
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tfloatseqset', [
-    '{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
-    ['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'],
-    (['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear'),
-    (['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise'),
-    [TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
-     TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')],
-    ([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
-      TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear'),
-    ([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'),
-      TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise'),
-])
-def test_tfloatseqset_constructor(cursor, expected_tfloatseqset):
-    if isinstance(expected_tfloatseqset, tuple):
-        params = [TFloatSeqSet(*expected_tfloatseqset)]
-    else:
-        params = [TFloatSeqSet(expected_tfloatseqset)]
-    cursor.execute('INSERT INTO tbl_tfloatseqset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tfloatseqset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tfloatseqset, tuple):
-        assert result == TFloatSeqSet(*expected_tfloatseqset)
-    else:
-        assert result == TFloatSeqSet(expected_tfloatseqset)
-
-
-@pytest.mark.parametrize('expected_tfloatseqset', [
-    '{[10.0@2019-09-01 00:00:00+01],  [20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]}',
-])
-def test_tfloatseqset_accessors(cursor, expected_tfloatseqset):
-    assert TFloatSeqSet(expected_tfloatseqset).tempSubtype() == 'SequenceSet'
-    #assert TFloatSeqSet(expected_tfloatseqset).getValues == [floatrange(10.0, 10.0, upper_inc=True),floatrange(20.0, 30.0, 30.0, upper_inc=True)]
-    assert TFloatSeqSet(expected_tfloatseqset).startValue == 10.0
-    assert TFloatSeqSet(expected_tfloatseqset).endValue == 30.0
-    assert TFloatSeqSet(expected_tfloatseqset).minValue == 10.0
-    assert TFloatSeqSet(expected_tfloatseqset).maxValue == 30.0
-    assert TFloatSeqSet(expected_tfloatseqset).valueRange == floatrange(10.0, 30.0, upper_inc=True)
-    assert TFloatSeqSet(expected_tfloatseqset).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TFloatSeqSet(expected_tfloatseqset).duration == timedelta(1)
-    assert TFloatSeqSet(expected_tfloatseqset).timespan == timedelta(2)
-    assert TFloatSeqSet(expected_tfloatseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TFloatSeqSet(expected_tfloatseqset).numInstants == 3
-    assert TFloatSeqSet(expected_tfloatseqset).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
-    assert TFloatSeqSet(expected_tfloatseqset).endInstant == TFloatInst('30.0@2019-09-03 00:00:00+01')
-    assert TFloatSeqSet(expected_tfloatseqset).instantN(2) == TFloatInst('20.0@2019-09-02 00:00:00+01')
-    assert TFloatSeqSet(expected_tfloatseqset).instants == [TFloatInst('10.0@2019-09-01 00:00:00+01'),
-                                                    TFloatInst('20.0@2019-09-02 00:00:00+01'),
-                                                    TFloatInst('30.0@2019-09-03 00:00:00+01')]
-    assert TFloatSeqSet(expected_tfloatseqset).numTimestamps == 3
-    assert TFloatSeqSet(expected_tfloatseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TFloatSeqSet(expected_tfloatseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TFloatSeqSet(expected_tfloatseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TFloatSeqSet(expected_tfloatseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                                      parse('2019-09-03 00:00:00+01')]
-    assert TFloatSeqSet(expected_tfloatseqset).numSequences == 2
-    assert TFloatSeqSet(expected_tfloatseqset).startSequence == TFloatSeq('[10.0@2019-09-01 00:00:00+01]')
-    assert TFloatSeqSet(expected_tfloatseqset).endSequence == TFloatSeq(
-        '[20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]')
-    assert TFloatSeqSet(expected_tfloatseqset).sequenceN(2) == TFloatSeq(
-        '[20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]')
-    assert TFloatSeqSet(expected_tfloatseqset).sequences == [TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
-                                                     TFloatSeq(
-                                                         '[20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]')]
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from datetime import timedelta
+from dateutil.parser import parse
+from spans.types import floatrange
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
+
+
+@pytest.mark.parametrize('expected_tfloatinst', [
+    '10.0@2019-09-01 00:00:00+01',
+    ('10.0', '2019-09-08 00:00:00+01'),
+    ['10.0', '2019-09-08 00:00:00+01'],
+    (10.0, parse('2019-09-08 00:00:00+01')),
+    [10.0, parse('2019-09-08 00:00:00+01')],
+])
+def test_tfloatinst_constructors(cursor, expected_tfloatinst):
+    params = [TFloatInst(expected_tfloatinst)]
+    cursor.execute('INSERT INTO tbl_tfloatinst (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tfloatinst WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    assert result == TFloatInst(expected_tfloatinst)
+
+@pytest.mark.parametrize('expected_tfloatinst', [
+    '10.0@2019-09-01 00:00:00+01',
+])
+def test_tfloatinst_accessors(cursor, expected_tfloatinst):
+    assert TFloatInst(expected_tfloatinst).tempSubtype() == 'Instant'
+    assert TFloatInst(expected_tfloatinst).getValue == 10.0
+    assert TFloatInst(expected_tfloatinst).getValues == [floatrange(10.0, 10.0, upper_inc=True)]
+    assert TFloatInst(expected_tfloatinst).startValue == 10.0
+    assert TFloatInst(expected_tfloatinst).endValue == 10.0
+    assert TFloatInst(expected_tfloatinst).minValue == 10.0
+    assert TFloatInst(expected_tfloatinst).maxValue == 10.0
+    assert TFloatInst(expected_tfloatinst).valueRange == floatrange(10.0, 10.0, upper_inc=True)
+    assert TFloatInst(expected_tfloatinst).getTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TFloatInst(expected_tfloatinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
+    assert TFloatInst(expected_tfloatinst).duration == timedelta(0)
+    assert TFloatInst(expected_tfloatinst).timespan == timedelta(0)
+    assert TFloatInst(expected_tfloatinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
+    assert TFloatInst(expected_tfloatinst).numInstants == 1
+    assert TFloatInst(expected_tfloatinst).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
+    assert TFloatInst(expected_tfloatinst).endInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
+    assert TFloatInst(expected_tfloatinst).instantN(1) == TFloatInst('10.0@2019-09-01 00:00:00+01')
+    assert TFloatInst(expected_tfloatinst).instants == [TFloatInst('10.0@2019-09-01 00:00:00+01')]
+    assert TFloatInst(expected_tfloatinst).numTimestamps == 1
+    assert TFloatInst(expected_tfloatinst).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TFloatInst(expected_tfloatinst).endTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TFloatInst(expected_tfloatinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
+    assert TFloatInst(expected_tfloatinst).timestamps == [parse('2019-09-01 00:00:00+01')]
+    assert TFloatInst(expected_tfloatinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TFloatInst(expected_tfloatinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
+    assert TFloatInst(expected_tfloatinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TFloatInst(expected_tfloatinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
+    assert TFloatInst(expected_tfloatinst).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TFloatInst(expected_tfloatinst).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
+    assert TFloatInst(expected_tfloatinst).intersectsPeriod(Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
+    assert TFloatInst(expected_tfloatinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TFloatInst(expected_tfloatinst).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
+    assert TFloatInst(expected_tfloatinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tfloatinstset', [
+    '{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01}',
+    ('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'),
+    (TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+     TFloatInst('10.0@2019-09-03 00:00:00+01')),
+    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
+    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+     TFloatInst('10.0@2019-09-03 00:00:00+01')],
+])
+def test_tfloatinstset_constructor(cursor, expected_tfloatinstset):
+    if isinstance(expected_tfloatinstset, tuple):
+        params = [TFloatInstSet(*expected_tfloatinstset)]
+    else:
+        params = [TFloatInstSet(expected_tfloatinstset)]
+    cursor.execute('INSERT INTO tbl_tfloatinstset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tfloatinstset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tfloatinstset, tuple):
+        assert result == TFloatInstSet(*expected_tfloatinstset)
+    else:
+        assert result == TFloatInstSet(expected_tfloatinstset)
+
+
+@pytest.mark.parametrize('expected_tfloatinstset', [
+    '{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01}',
+])
+def test_tfloatinstset_accessors(cursor, expected_tfloatinstset):
+    assert TFloatInstSet(expected_tfloatinstset).tempSubtype() == 'InstantSet'
+    assert TFloatInstSet(expected_tfloatinstset).getValues == [floatrange(10.0, 10.0, upper_inc=True),
+                                             floatrange(20.0, 20.0, upper_inc=True),
+                                             floatrange(30.0, 30.0, upper_inc=True)]
+    assert TFloatInstSet(expected_tfloatinstset).startValue == 10.0
+    assert TFloatInstSet(expected_tfloatinstset).endValue == 30.0
+    assert TFloatInstSet(expected_tfloatinstset).minValue == 10.0
+    assert TFloatInstSet(expected_tfloatinstset).maxValue == 30.0
+    assert TFloatInstSet(expected_tfloatinstset).valueRange == floatrange(10.0, 30.0, upper_inc=True)
+    assert TFloatInstSet(expected_tfloatinstset).getTime == \
+           PeriodSet(
+               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
+               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TFloatInstSet(expected_tfloatinstset).duration == timedelta(0)
+    assert TFloatInstSet(expected_tfloatinstset).timespan == timedelta(2)
+    assert TFloatInstSet(expected_tfloatinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TFloatInstSet(expected_tfloatinstset).numInstants == 3
+    assert TFloatInstSet(expected_tfloatinstset).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
+    assert TFloatInstSet(expected_tfloatinstset).endInstant == TFloatInst('30.0@2019-09-03 00:00:00+01')
+    assert TFloatInstSet(expected_tfloatinstset).instantN(2) == TFloatInst('20.0@2019-09-02 00:00:00+01')
+    assert TFloatInstSet(expected_tfloatinstset).instants == [TFloatInst('10.0@2019-09-01 00:00:00+01'),
+                                            TFloatInst('20.0@2019-09-02 00:00:00+01'),
+                                            TFloatInst('30.0@2019-09-03 00:00:00+01')]
+    assert TFloatInstSet(expected_tfloatinstset).numTimestamps == 3
+    assert TFloatInstSet(expected_tfloatinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TFloatInstSet(expected_tfloatinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TFloatInstSet(expected_tfloatinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TFloatInstSet(expected_tfloatinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                              parse('2019-09-03 00:00:00+01')]
+    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TFloatInstSet(expected_tfloatinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
+    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
+    assert TFloatInstSet(expected_tfloatinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tfloatseqseteq', [
+    '[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]',
+    ['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'],
+    [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+     TFloatInst('10.0@2019-09-03 00:00:00+01')],
+    (['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True,
+     'Stepwise'),
+    ([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+      TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise'),
+])
+def test_tfloatseq_constructor(cursor, expected_tfloatseqseteq):
+    if isinstance(expected_tfloatseqseteq, tuple):
+        params = [TFloatSeq(*expected_tfloatseqseteq)]
+    else:
+        params = [TFloatSeq(expected_tfloatseqseteq)]
+    cursor.execute('INSERT INTO tbl_tfloatseq (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tfloatseq WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tfloatseqseteq, tuple):
+        assert result == TFloatSeq(*expected_tfloatseqseteq)
+    else:
+        assert result == TFloatSeq(expected_tfloatseqseteq)
+
+
+@pytest.mark.parametrize('expected_tfloatseqseteq', [
+    '[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]',
+])
+def test_tfloatseq_accessors(cursor, expected_tfloatseqseteq):
+    assert TFloatSeq(expected_tfloatseqseteq).tempSubtype() == 'Sequence'
+    # assert TFloatSeq(expected_tfloatseqseteq).getValues == [floatrange(10.0, 30.0, upper_inc=True)]
+    assert TFloatSeq(expected_tfloatseqseteq).startValue == 10.0
+    assert TFloatSeq(expected_tfloatseqseteq).endValue == 30.0
+    assert TFloatSeq(expected_tfloatseqseteq).minValue == 10.0
+    assert TFloatSeq(expected_tfloatseqseteq).maxValue == 30.0
+    assert TFloatSeq(expected_tfloatseqseteq).valueRange == floatrange(10.0, 30.0, upper_inc=True)
+    assert TFloatSeq(expected_tfloatseqseteq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TFloatSeq(expected_tfloatseqseteq).duration == timedelta(2)
+    assert TFloatSeq(expected_tfloatseqseteq).timespan == timedelta(2)
+    assert TFloatSeq(expected_tfloatseqseteq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TFloatSeq(expected_tfloatseqseteq).numInstants == 3
+    assert TFloatSeq(expected_tfloatseqseteq).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
+    assert TFloatSeq(expected_tfloatseqseteq).endInstant == TFloatInst('30.0@2019-09-03 00:00:00+01')
+    assert TFloatSeq(expected_tfloatseqseteq).instantN(2) == TFloatInst('20.0@2019-09-02 00:00:00+01')
+    assert TFloatSeq(expected_tfloatseqseteq).instants == \
+           [TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'),
+            TFloatInst('30.0@2019-09-03 00:00:00+01')]
+    assert TFloatSeq(expected_tfloatseqseteq).numTimestamps == 3
+    assert TFloatSeq(expected_tfloatseqseteq).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TFloatSeq(expected_tfloatseqseteq).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TFloatSeq(expected_tfloatseqseteq).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TFloatSeq(expected_tfloatseqseteq).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                          parse('2019-09-02 00:00:00+01'),
+                                                          parse('2019-09-03 00:00:00+01')]
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TFloatSeq(expected_tfloatseqseteq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tfloatseqset', [
+    '{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}',
+    ['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'],
+    (['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear'),
+    (['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise'),
+    [TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
+     TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')],
+    ([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
+      TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear'),
+    ([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'),
+      TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise'),
+])
+def test_tfloatseqset_constructor(cursor, expected_tfloatseqset):
+    if isinstance(expected_tfloatseqset, tuple):
+        params = [TFloatSeqSet(*expected_tfloatseqset)]
+    else:
+        params = [TFloatSeqSet(expected_tfloatseqset)]
+    cursor.execute('INSERT INTO tbl_tfloatseqset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tfloatseqset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tfloatseqset, tuple):
+        assert result == TFloatSeqSet(*expected_tfloatseqset)
+    else:
+        assert result == TFloatSeqSet(expected_tfloatseqset)
+
+
+@pytest.mark.parametrize('expected_tfloatseqset', [
+    '{[10.0@2019-09-01 00:00:00+01],  [20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]}',
+])
+def test_tfloatseqset_accessors(cursor, expected_tfloatseqset):
+    assert TFloatSeqSet(expected_tfloatseqset).tempSubtype() == 'SequenceSet'
+    #assert TFloatSeqSet(expected_tfloatseqset).getValues == [floatrange(10.0, 10.0, upper_inc=True),floatrange(20.0, 30.0, 30.0, upper_inc=True)]
+    assert TFloatSeqSet(expected_tfloatseqset).startValue == 10.0
+    assert TFloatSeqSet(expected_tfloatseqset).endValue == 30.0
+    assert TFloatSeqSet(expected_tfloatseqset).minValue == 10.0
+    assert TFloatSeqSet(expected_tfloatseqset).maxValue == 30.0
+    assert TFloatSeqSet(expected_tfloatseqset).valueRange == floatrange(10.0, 30.0, upper_inc=True)
+    assert TFloatSeqSet(expected_tfloatseqset).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TFloatSeqSet(expected_tfloatseqset).duration == timedelta(1)
+    assert TFloatSeqSet(expected_tfloatseqset).timespan == timedelta(2)
+    assert TFloatSeqSet(expected_tfloatseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TFloatSeqSet(expected_tfloatseqset).numInstants == 3
+    assert TFloatSeqSet(expected_tfloatseqset).startInstant == TFloatInst('10.0@2019-09-01 00:00:00+01')
+    assert TFloatSeqSet(expected_tfloatseqset).endInstant == TFloatInst('30.0@2019-09-03 00:00:00+01')
+    assert TFloatSeqSet(expected_tfloatseqset).instantN(2) == TFloatInst('20.0@2019-09-02 00:00:00+01')
+    assert TFloatSeqSet(expected_tfloatseqset).instants == [TFloatInst('10.0@2019-09-01 00:00:00+01'),
+                                                    TFloatInst('20.0@2019-09-02 00:00:00+01'),
+                                                    TFloatInst('30.0@2019-09-03 00:00:00+01')]
+    assert TFloatSeqSet(expected_tfloatseqset).numTimestamps == 3
+    assert TFloatSeqSet(expected_tfloatseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TFloatSeqSet(expected_tfloatseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TFloatSeqSet(expected_tfloatseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TFloatSeqSet(expected_tfloatseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                                      parse('2019-09-03 00:00:00+01')]
+    assert TFloatSeqSet(expected_tfloatseqset).numSequences == 2
+    assert TFloatSeqSet(expected_tfloatseqset).startSequence == TFloatSeq('[10.0@2019-09-01 00:00:00+01]')
+    assert TFloatSeqSet(expected_tfloatseqset).endSequence == TFloatSeq(
+        '[20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]')
+    assert TFloatSeqSet(expected_tfloatseqset).sequenceN(2) == TFloatSeq(
+        '[20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]')
+    assert TFloatSeqSet(expected_tfloatseqset).sequences == [TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),
+                                                     TFloatSeq(
+                                                         '[20.0@2019-09-02 00:00:00+01, 30.0@2019-09-03 00:00:00+01]')]
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TFloatSeqSet(expected_tfloatseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_tbox.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_tbox.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb import TBox
-
-
-@pytest.mark.parametrize('expected_tbox', [
-    'TBOX((10.0, 2019-09-08 00:00:00+02), (30.0, 2019-09-10 00:00:00+02))',
-    'TBOX((, 2019-09-08 00:00:00+02), (, 2019-09-10 00:00:00+02))',
-    'TBOX((10.0, ), (30.0, ))',
-    ('10.0', '20.0'),
-    (10.0, 20.0),
-    ('2019-09-08 00:00:00+01', '2019-09-08 00:00:00+01'),
-    (parse('2019-09-08 00:00:00+01'), parse('2019-09-08 00:00:00+01')),
-    ('10.0', '2019-09-08 00:00:00+01', '20.0', '2019-09-08 00:00:00+01'),
-    (10.0, parse('2019-09-08 00:00:00+01'), 20.0, parse('2019-09-08 00:00:00+01')),
-])
-def test_tbox_constructor(cursor, expected_tbox):
-    if isinstance(expected_tbox, tuple):
-        params = TBox(*expected_tbox)
-    else:
-        params = TBox(expected_tbox)
-    cursor.execute("INSERT INTO tbl_tbox (box) VALUES (%s)" % params)
-    cursor.execute("SELECT box FROM tbl_tbox WHERE box=%s" % params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tbox, tuple):
-        assert result == TBox(*expected_tbox)
-    else:
-        assert result == TBox(expected_tbox)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb import TBox
+
+
+@pytest.mark.parametrize('expected_tbox', [
+    'TBOX((10.0, 2019-09-08 00:00:00+02), (30.0, 2019-09-10 00:00:00+02))',
+    'TBOX((, 2019-09-08 00:00:00+02), (, 2019-09-10 00:00:00+02))',
+    'TBOX((10.0, ), (30.0, ))',
+    ('10.0', '20.0'),
+    (10.0, 20.0),
+    ('2019-09-08 00:00:00+01', '2019-09-08 00:00:00+01'),
+    (parse('2019-09-08 00:00:00+01'), parse('2019-09-08 00:00:00+01')),
+    ('10.0', '2019-09-08 00:00:00+01', '20.0', '2019-09-08 00:00:00+01'),
+    (10.0, parse('2019-09-08 00:00:00+01'), 20.0, parse('2019-09-08 00:00:00+01')),
+])
+def test_tbox_constructor(cursor, expected_tbox):
+    if isinstance(expected_tbox, tuple):
+        params = TBox(*expected_tbox)
+    else:
+        params = TBox(expected_tbox)
+    cursor.execute("INSERT INTO tbl_tbox (box) VALUES (%s)" % params)
+    cursor.execute("SELECT box FROM tbl_tbox WHERE box=%s" % params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tbox, tuple):
+        assert result == TBox(*expected_tbox)
+    else:
+        assert result == TBox(expected_tbox)
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_tint.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_tint.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,309 +1,309 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from datetime import timedelta
-from dateutil.parser import parse
-from spans.types import intrange
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
-
-
-@pytest.mark.parametrize('expected_tintinst', [
-    '10@2019-09-01 00:00:00+01',
-    ('10', '2019-09-08 00:00:00+01'),
-    ['10', '2019-09-08 00:00:00+01'],
-    (10, parse('2019-09-08 00:00:00+01')),
-    [10, parse('2019-09-08 00:00:00+01')],
-])
-def test_tintinst_constructors(cursor, expected_tintinst):
-    params = [TIntInst(expected_tintinst)]
-    cursor.execute('INSERT INTO tbl_tintinst (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tintinst WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    assert result == TIntInst(expected_tintinst)
-
-
-@pytest.mark.parametrize('expected_tintinst', [
-    '10@2019-09-01 00:00:00+01',
-])
-def test_tintinst_accessors(cursor, expected_tintinst):
-    assert TIntInst(expected_tintinst).tempSubtype() == 'Instant'
-    assert TIntInst(expected_tintinst).getValue == 10
-    assert TIntInst(expected_tintinst).getValues == [10]
-    assert TIntInst(expected_tintinst).startValue == 10
-    assert TIntInst(expected_tintinst).endValue == 10
-    assert TIntInst(expected_tintinst).minValue == 10
-    assert TIntInst(expected_tintinst).maxValue == 10
-    assert TIntInst(expected_tintinst).valueRange == intrange(10, 10, upper_inc=True)
-    assert TIntInst(expected_tintinst).getTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TIntInst(expected_tintinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
-    assert TIntInst(expected_tintinst).duration == timedelta(0)
-    assert TIntInst(expected_tintinst).timespan == timedelta(0)
-    assert TIntInst(expected_tintinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
-    assert TIntInst(expected_tintinst).numInstants == 1
-    assert TIntInst(expected_tintinst).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
-    assert TIntInst(expected_tintinst).endInstant == TIntInst('10@2019-09-01 00:00:00+01')
-    assert TIntInst(expected_tintinst).instantN(1) == TIntInst('10@2019-09-01 00:00:00+01')
-    assert TIntInst(expected_tintinst).instants == [TIntInst('10@2019-09-01 00:00:00+01')]
-    assert TIntInst(expected_tintinst).numTimestamps == 1
-    assert TIntInst(expected_tintinst).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TIntInst(expected_tintinst).endTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TIntInst(expected_tintinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
-    assert TIntInst(expected_tintinst).timestamps == [parse('2019-09-01 00:00:00+01')]
-    assert TIntInst(expected_tintinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TIntInst(expected_tintinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
-    assert TIntInst(expected_tintinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TIntInst(expected_tintinst).intersectsTimestampSet(
-        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
-    assert TIntInst(expected_tintinst).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TIntInst(expected_tintinst).intersectsPeriod(
-        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
-    assert TIntInst(expected_tintinst).intersectsPeriod(
-        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
-    assert TIntInst(expected_tintinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TIntInst(expected_tintinst).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
-    assert TIntInst(expected_tintinst).intersectsPeriodSet(
-        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tintinstset', [
-    '{10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01}',
-    ('10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'),
-    (TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-     TIntInst('10@2019-09-03 00:00:00+01')),
-    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'],
-    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-     TIntInst('10@2019-09-03 00:00:00+01')],
-])
-def test_tintinstset_constructor(cursor, expected_tintinstset):
-    if isinstance(expected_tintinstset, tuple):
-        params = [TIntInstSet(*expected_tintinstset)]
-    else:
-        params = [TIntInstSet(expected_tintinstset)]
-    cursor.execute('INSERT INTO tbl_tintinstset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tintinstset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tintinstset, tuple):
-        assert result == TIntInstSet(*expected_tintinstset)
-    else:
-        assert result == TIntInstSet(expected_tintinstset)
-
-
-@pytest.mark.parametrize('expected_tintinstset', [
-    '{10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01}',
-])
-def test_tintinstset_accessors(cursor, expected_tintinstset):
-    assert TIntInstSet(expected_tintinstset).tempSubtype() == 'InstantSet'
-    assert TIntInstSet(expected_tintinstset).getValues == [10, 20, 30]
-    assert TIntInstSet(expected_tintinstset).startValue == 10
-    assert TIntInstSet(expected_tintinstset).endValue == 30
-    assert TIntInstSet(expected_tintinstset).minValue == 10
-    assert TIntInstSet(expected_tintinstset).maxValue == 30
-    assert TIntInstSet(expected_tintinstset).valueRange == intrange(10, 30, upper_inc=True)
-    assert TIntInstSet(expected_tintinstset).getTime == \
-           PeriodSet(
-               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
-               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TIntInstSet(expected_tintinstset).duration == timedelta(0)
-    assert TIntInstSet(expected_tintinstset).timespan == timedelta(2)
-    assert TIntInstSet(expected_tintinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TIntInstSet(expected_tintinstset).numInstants == 3
-    assert TIntInstSet(expected_tintinstset).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
-    assert TIntInstSet(expected_tintinstset).endInstant == TIntInst('30@2019-09-03 00:00:00+01')
-    assert TIntInstSet(expected_tintinstset).instantN(2) == TIntInst('20@2019-09-02 00:00:00+01')
-    assert TIntInstSet(expected_tintinstset).instants == [TIntInst('10@2019-09-01 00:00:00+01'),
-                                                TIntInst('20@2019-09-02 00:00:00+01'),
-                                                TIntInst('30@2019-09-03 00:00:00+01')]
-    assert TIntInstSet(expected_tintinstset).numTimestamps == 3
-    assert TIntInstSet(expected_tintinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TIntInstSet(expected_tintinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TIntInstSet(expected_tintinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TIntInstSet(expected_tintinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                                  parse('2019-09-03 00:00:00+01')]
-    assert TIntInstSet(expected_tintinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TIntInstSet(expected_tintinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TIntInstSet(expected_tintinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TIntInstSet(expected_tintinstset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TIntInstSet(expected_tintinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TIntInstSet(expected_tintinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
-    assert TIntInstSet(expected_tintinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TIntInstSet(expected_tintinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TIntInstSet(expected_tintinstset).intersectsPeriodSet(
-        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
-    assert TIntInstSet(expected_tintinstset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tintseq', [
-    '[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 20@2019-09-03 00:00:00+01]',
-    'Interp=Stepwise;[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 20@2019-09-03 00:00:00+01]',
-    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '20@2019-09-03 00:00:00+01'],
-    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-     TIntInst('20@2019-09-03 00:00:00+01')],
-    (['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'], True, True),
-    ([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-      TIntInst('10@2019-09-03 00:00:00+01')], True, True),
-])
-def test_tintseq_constructor(cursor, expected_tintseq):
-    if isinstance(expected_tintseq, tuple):
-        params = [TIntSeq(*expected_tintseq)]
-    else:
-        params = [TIntSeq(expected_tintseq)]
-    cursor.execute('INSERT INTO tbl_tintseq (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tintseq WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tintseq, tuple):
-        assert result == TIntSeq(*expected_tintseq)
-    else:
-        assert result == TIntSeq(expected_tintseq)
-
-
-@pytest.mark.parametrize('expected_tintseq', [
-    '[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]',
-])
-def test_tintseq_accessors(cursor, expected_tintseq):
-    assert TIntSeq(expected_tintseq).tempSubtype() == 'Sequence'
-    assert TIntSeq(expected_tintseq).getValues == [10, 20, 30]
-    assert TIntSeq(expected_tintseq).startValue == 10
-    assert TIntSeq(expected_tintseq).endValue == 30
-    assert TIntSeq(expected_tintseq).minValue == 10
-    assert TIntSeq(expected_tintseq).maxValue == 30
-    assert TIntSeq(expected_tintseq).valueRange == intrange(10, 30, upper_inc=True)
-    assert TIntSeq(expected_tintseq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TIntSeq(expected_tintseq).duration == timedelta(2)
-    assert TIntSeq(expected_tintseq).timespan == timedelta(2)
-    assert TIntSeq(expected_tintseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TIntSeq(expected_tintseq).numInstants == 3
-    assert TIntSeq(expected_tintseq).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
-    assert TIntSeq(expected_tintseq).endInstant == TIntInst('30@2019-09-03 00:00:00+01')
-    assert TIntSeq(expected_tintseq).instantN(2) == TIntInst('20@2019-09-02 00:00:00+01')
-    assert TIntSeq(expected_tintseq).instants == \
-           [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
-            TIntInst('30@2019-09-03 00:00:00+01')]
-    assert TIntSeq(expected_tintseq).numTimestamps == 3
-    assert TIntSeq(expected_tintseq).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TIntSeq(expected_tintseq).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TIntSeq(expected_tintseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TIntSeq(expected_tintseq).timestamps == [parse('2019-09-01 00:00:00+01'),
-                                                      parse('2019-09-02 00:00:00+01'),
-                                                      parse('2019-09-03 00:00:00+01')]
-    assert TIntSeq(expected_tintseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TIntSeq(expected_tintseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TIntSeq(expected_tintseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TIntSeq(expected_tintseq).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TIntSeq(expected_tintseq).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TIntSeq(expected_tintseq).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TIntSeq(expected_tintseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TIntSeq(expected_tintseq).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
-
-
-@pytest.mark.parametrize('expected_tintseqset', [
-    '{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}',
-    'Interp=Stepwise;{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}',
-    ['[10@2019-09-01 00:00:00+01]', '[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]'],
-    [TIntSeq('[10@2019-09-01 00:00:00+01]'),
-     TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')],
-])
-def test_tintseqset_constructor(cursor, expected_tintseqset):
-    if isinstance(expected_tintseqset, tuple):
-        params = [TIntSeqSet(*expected_tintseqset)]
-    else:
-        params = [TIntSeqSet(expected_tintseqset)]
-    cursor.execute('INSERT INTO tbl_tintseqset (temp) VALUES (%s)', params)
-    cursor.execute('SELECT temp FROM tbl_tintseqset WHERE temp=%s', params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_tintseqset, tuple):
-        assert result == TIntSeqSet(*expected_tintseqset)
-    else:
-        assert result == TIntSeqSet(expected_tintseqset)
-
-
-@pytest.mark.parametrize('expected_tintseqset', [
-    '{[10@2019-09-01 00:00:00+01],  [20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]}',
-])
-def test_tintseqset_accessors(cursor, expected_tintseqset):
-    assert TIntSeqSet(expected_tintseqset).tempSubtype() == 'SequenceSet'
-    assert TIntSeqSet(expected_tintseqset).getValues == [10, 20, 30]
-    assert TIntSeqSet(expected_tintseqset).startValue == 10
-    assert TIntSeqSet(expected_tintseqset).endValue == 30
-    assert TIntSeqSet(expected_tintseqset).minValue == 10
-    assert TIntSeqSet(expected_tintseqset).maxValue == 30
-    assert TIntSeqSet(expected_tintseqset).valueRange == intrange(10, 30, upper_inc=True)
-    assert TIntSeqSet(expected_tintseqset).getTime == PeriodSet(
-        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
-    assert TIntSeqSet(expected_tintseqset).duration == timedelta(1)
-    assert TIntSeqSet(expected_tintseqset).timespan == timedelta(2)
-    assert TIntSeqSet(expected_tintseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
-    assert TIntSeqSet(expected_tintseqset).numInstants == 3
-    assert TIntSeqSet(expected_tintseqset).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
-    assert TIntSeqSet(expected_tintseqset).endInstant == TIntInst('30@2019-09-03 00:00:00+01')
-    assert TIntSeqSet(expected_tintseqset).instantN(2) == TIntInst('20@2019-09-02 00:00:00+01')
-    assert TIntSeqSet(expected_tintseqset).instants == [TIntInst('10@2019-09-01 00:00:00+01'),
-                                                TIntInst('20@2019-09-02 00:00:00+01'),
-                                                TIntInst('30@2019-09-03 00:00:00+01')]
-    assert TIntSeqSet(expected_tintseqset).numTimestamps == 3
-    assert TIntSeqSet(expected_tintseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
-    assert TIntSeqSet(expected_tintseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
-    assert TIntSeqSet(expected_tintseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
-    assert TIntSeqSet(expected_tintseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
-                                                  parse('2019-09-03 00:00:00+01')]
-    assert TIntSeqSet(expected_tintseqset).numSequences == 2
-    assert TIntSeqSet(expected_tintseqset).startSequence == TIntSeq('[10@2019-09-01 00:00:00+01]')
-    assert TIntSeqSet(expected_tintseqset).endSequence == TIntSeq(
-        '[20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]')
-    assert TIntSeqSet(expected_tintseqset).sequenceN(2) == TIntSeq(
-        '[20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]')
-    assert TIntSeqSet(expected_tintseqset).sequences == [TIntSeq('[10@2019-09-01 00:00:00+01]'),
-                                                 TIntSeq(
-                                                     '[20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]')]
-    assert TIntSeqSet(expected_tintseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
-    assert TIntSeqSet(expected_tintseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
-    assert TIntSeqSet(expected_tintseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
-    assert TIntSeqSet(expected_tintseqset).intersectsTimestampSet(
-        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
-    assert TIntSeqSet(expected_tintseqset).intersectsPeriod(
-        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
-    assert TIntSeqSet(expected_tintseqset).intersectsPeriod(
-        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
-    assert TIntSeqSet(expected_tintseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
-    assert TIntSeqSet(expected_tintseqset).intersectsPeriodSet(
-        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from datetime import timedelta
+from dateutil.parser import parse
+from spans.types import intrange
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
+
+
+@pytest.mark.parametrize('expected_tintinst', [
+    '10@2019-09-01 00:00:00+01',
+    ('10', '2019-09-08 00:00:00+01'),
+    ['10', '2019-09-08 00:00:00+01'],
+    (10, parse('2019-09-08 00:00:00+01')),
+    [10, parse('2019-09-08 00:00:00+01')],
+])
+def test_tintinst_constructors(cursor, expected_tintinst):
+    params = [TIntInst(expected_tintinst)]
+    cursor.execute('INSERT INTO tbl_tintinst (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tintinst WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    assert result == TIntInst(expected_tintinst)
+
+
+@pytest.mark.parametrize('expected_tintinst', [
+    '10@2019-09-01 00:00:00+01',
+])
+def test_tintinst_accessors(cursor, expected_tintinst):
+    assert TIntInst(expected_tintinst).tempSubtype() == 'Instant'
+    assert TIntInst(expected_tintinst).getValue == 10
+    assert TIntInst(expected_tintinst).getValues == [10]
+    assert TIntInst(expected_tintinst).startValue == 10
+    assert TIntInst(expected_tintinst).endValue == 10
+    assert TIntInst(expected_tintinst).minValue == 10
+    assert TIntInst(expected_tintinst).maxValue == 10
+    assert TIntInst(expected_tintinst).valueRange == intrange(10, 10, upper_inc=True)
+    assert TIntInst(expected_tintinst).getTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TIntInst(expected_tintinst).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]}')
+    assert TIntInst(expected_tintinst).duration == timedelta(0)
+    assert TIntInst(expected_tintinst).timespan == timedelta(0)
+    assert TIntInst(expected_tintinst).period == Period('[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01]')
+    assert TIntInst(expected_tintinst).numInstants == 1
+    assert TIntInst(expected_tintinst).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
+    assert TIntInst(expected_tintinst).endInstant == TIntInst('10@2019-09-01 00:00:00+01')
+    assert TIntInst(expected_tintinst).instantN(1) == TIntInst('10@2019-09-01 00:00:00+01')
+    assert TIntInst(expected_tintinst).instants == [TIntInst('10@2019-09-01 00:00:00+01')]
+    assert TIntInst(expected_tintinst).numTimestamps == 1
+    assert TIntInst(expected_tintinst).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TIntInst(expected_tintinst).endTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TIntInst(expected_tintinst).timestampN(1) == parse('2019-09-01 00:00:00+01')
+    assert TIntInst(expected_tintinst).timestamps == [parse('2019-09-01 00:00:00+01')]
+    assert TIntInst(expected_tintinst).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TIntInst(expected_tintinst).intersectsTimestamp(parse('2019-09-02 00:00:00+01')) == False
+    assert TIntInst(expected_tintinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TIntInst(expected_tintinst).intersectsTimestampSet(
+        TimestampSet('{2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01}')) == False
+    assert TIntInst(expected_tintinst).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TIntInst(expected_tintinst).intersectsPeriod(
+        Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == False
+    assert TIntInst(expected_tintinst).intersectsPeriod(
+        Period('[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]')) == False
+    assert TIntInst(expected_tintinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TIntInst(expected_tintinst).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == False
+    assert TIntInst(expected_tintinst).intersectsPeriodSet(
+        PeriodSet('{[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tintinstset', [
+    '{10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01}',
+    ('10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'),
+    (TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+     TIntInst('10@2019-09-03 00:00:00+01')),
+    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'],
+    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+     TIntInst('10@2019-09-03 00:00:00+01')],
+])
+def test_tintinstset_constructor(cursor, expected_tintinstset):
+    if isinstance(expected_tintinstset, tuple):
+        params = [TIntInstSet(*expected_tintinstset)]
+    else:
+        params = [TIntInstSet(expected_tintinstset)]
+    cursor.execute('INSERT INTO tbl_tintinstset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tintinstset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tintinstset, tuple):
+        assert result == TIntInstSet(*expected_tintinstset)
+    else:
+        assert result == TIntInstSet(expected_tintinstset)
+
+
+@pytest.mark.parametrize('expected_tintinstset', [
+    '{10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01}',
+])
+def test_tintinstset_accessors(cursor, expected_tintinstset):
+    assert TIntInstSet(expected_tintinstset).tempSubtype() == 'InstantSet'
+    assert TIntInstSet(expected_tintinstset).getValues == [10, 20, 30]
+    assert TIntInstSet(expected_tintinstset).startValue == 10
+    assert TIntInstSet(expected_tintinstset).endValue == 30
+    assert TIntInstSet(expected_tintinstset).minValue == 10
+    assert TIntInstSet(expected_tintinstset).maxValue == 30
+    assert TIntInstSet(expected_tintinstset).valueRange == intrange(10, 30, upper_inc=True)
+    assert TIntInstSet(expected_tintinstset).getTime == \
+           PeriodSet(
+               '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01], [2019-09-02 00:00:00+01, 2019-09-02 00:00:00+01], '
+               '[2019-09-03 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TIntInstSet(expected_tintinstset).duration == timedelta(0)
+    assert TIntInstSet(expected_tintinstset).timespan == timedelta(2)
+    assert TIntInstSet(expected_tintinstset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TIntInstSet(expected_tintinstset).numInstants == 3
+    assert TIntInstSet(expected_tintinstset).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
+    assert TIntInstSet(expected_tintinstset).endInstant == TIntInst('30@2019-09-03 00:00:00+01')
+    assert TIntInstSet(expected_tintinstset).instantN(2) == TIntInst('20@2019-09-02 00:00:00+01')
+    assert TIntInstSet(expected_tintinstset).instants == [TIntInst('10@2019-09-01 00:00:00+01'),
+                                                TIntInst('20@2019-09-02 00:00:00+01'),
+                                                TIntInst('30@2019-09-03 00:00:00+01')]
+    assert TIntInstSet(expected_tintinstset).numTimestamps == 3
+    assert TIntInstSet(expected_tintinstset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TIntInstSet(expected_tintinstset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TIntInstSet(expected_tintinstset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TIntInstSet(expected_tintinstset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                                  parse('2019-09-03 00:00:00+01')]
+    assert TIntInstSet(expected_tintinstset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TIntInstSet(expected_tintinstset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TIntInstSet(expected_tintinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TIntInstSet(expected_tintinstset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TIntInstSet(expected_tintinstset).intersectsPeriod(Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TIntInstSet(expected_tintinstset).intersectsPeriod(Period('(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)')) == False
+    assert TIntInstSet(expected_tintinstset).intersectsPeriod(Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TIntInstSet(expected_tintinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TIntInstSet(expected_tintinstset).intersectsPeriodSet(
+        PeriodSet('{(2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01)}')) == False
+    assert TIntInstSet(expected_tintinstset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tintseq', [
+    '[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 20@2019-09-03 00:00:00+01]',
+    'Interp=Stepwise;[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 20@2019-09-03 00:00:00+01]',
+    ['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '20@2019-09-03 00:00:00+01'],
+    [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+     TIntInst('20@2019-09-03 00:00:00+01')],
+    (['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'], True, True),
+    ([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+      TIntInst('10@2019-09-03 00:00:00+01')], True, True),
+])
+def test_tintseq_constructor(cursor, expected_tintseq):
+    if isinstance(expected_tintseq, tuple):
+        params = [TIntSeq(*expected_tintseq)]
+    else:
+        params = [TIntSeq(expected_tintseq)]
+    cursor.execute('INSERT INTO tbl_tintseq (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tintseq WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tintseq, tuple):
+        assert result == TIntSeq(*expected_tintseq)
+    else:
+        assert result == TIntSeq(expected_tintseq)
+
+
+@pytest.mark.parametrize('expected_tintseq', [
+    '[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]',
+])
+def test_tintseq_accessors(cursor, expected_tintseq):
+    assert TIntSeq(expected_tintseq).tempSubtype() == 'Sequence'
+    assert TIntSeq(expected_tintseq).getValues == [10, 20, 30]
+    assert TIntSeq(expected_tintseq).startValue == 10
+    assert TIntSeq(expected_tintseq).endValue == 30
+    assert TIntSeq(expected_tintseq).minValue == 10
+    assert TIntSeq(expected_tintseq).maxValue == 30
+    assert TIntSeq(expected_tintseq).valueRange == intrange(10, 30, upper_inc=True)
+    assert TIntSeq(expected_tintseq).getTime == PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TIntSeq(expected_tintseq).duration == timedelta(2)
+    assert TIntSeq(expected_tintseq).timespan == timedelta(2)
+    assert TIntSeq(expected_tintseq).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TIntSeq(expected_tintseq).numInstants == 3
+    assert TIntSeq(expected_tintseq).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
+    assert TIntSeq(expected_tintseq).endInstant == TIntInst('30@2019-09-03 00:00:00+01')
+    assert TIntSeq(expected_tintseq).instantN(2) == TIntInst('20@2019-09-02 00:00:00+01')
+    assert TIntSeq(expected_tintseq).instants == \
+           [TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'),
+            TIntInst('30@2019-09-03 00:00:00+01')]
+    assert TIntSeq(expected_tintseq).numTimestamps == 3
+    assert TIntSeq(expected_tintseq).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TIntSeq(expected_tintseq).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TIntSeq(expected_tintseq).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TIntSeq(expected_tintseq).timestamps == [parse('2019-09-01 00:00:00+01'),
+                                                      parse('2019-09-02 00:00:00+01'),
+                                                      parse('2019-09-03 00:00:00+01')]
+    assert TIntSeq(expected_tintseq).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TIntSeq(expected_tintseq).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TIntSeq(expected_tintseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TIntSeq(expected_tintseq).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TIntSeq(expected_tintseq).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TIntSeq(expected_tintseq).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TIntSeq(expected_tintseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TIntSeq(expected_tintseq).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
+
+
+@pytest.mark.parametrize('expected_tintseqset', [
+    '{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}',
+    'Interp=Stepwise;{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}',
+    ['[10@2019-09-01 00:00:00+01]', '[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]'],
+    [TIntSeq('[10@2019-09-01 00:00:00+01]'),
+     TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')],
+])
+def test_tintseqset_constructor(cursor, expected_tintseqset):
+    if isinstance(expected_tintseqset, tuple):
+        params = [TIntSeqSet(*expected_tintseqset)]
+    else:
+        params = [TIntSeqSet(expected_tintseqset)]
+    cursor.execute('INSERT INTO tbl_tintseqset (temp) VALUES (%s)', params)
+    cursor.execute('SELECT temp FROM tbl_tintseqset WHERE temp=%s', params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_tintseqset, tuple):
+        assert result == TIntSeqSet(*expected_tintseqset)
+    else:
+        assert result == TIntSeqSet(expected_tintseqset)
+
+
+@pytest.mark.parametrize('expected_tintseqset', [
+    '{[10@2019-09-01 00:00:00+01],  [20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]}',
+])
+def test_tintseqset_accessors(cursor, expected_tintseqset):
+    assert TIntSeqSet(expected_tintseqset).tempSubtype() == 'SequenceSet'
+    assert TIntSeqSet(expected_tintseqset).getValues == [10, 20, 30]
+    assert TIntSeqSet(expected_tintseqset).startValue == 10
+    assert TIntSeqSet(expected_tintseqset).endValue == 30
+    assert TIntSeqSet(expected_tintseqset).minValue == 10
+    assert TIntSeqSet(expected_tintseqset).maxValue == 30
+    assert TIntSeqSet(expected_tintseqset).valueRange == intrange(10, 30, upper_inc=True)
+    assert TIntSeqSet(expected_tintseqset).getTime == PeriodSet(
+        '{[2019-09-01 00:00:00+01, 2019-09-01 00:00:00+01],[2019-09-02 00:00:00+01, 2019-09-03 00:00:00+01]}')
+    assert TIntSeqSet(expected_tintseqset).duration == timedelta(1)
+    assert TIntSeqSet(expected_tintseqset).timespan == timedelta(2)
+    assert TIntSeqSet(expected_tintseqset).period == Period('[2019-09-01 00:00:00+01, 2019-09-03 00:00:00+01]')
+    assert TIntSeqSet(expected_tintseqset).numInstants == 3
+    assert TIntSeqSet(expected_tintseqset).startInstant == TIntInst('10@2019-09-01 00:00:00+01')
+    assert TIntSeqSet(expected_tintseqset).endInstant == TIntInst('30@2019-09-03 00:00:00+01')
+    assert TIntSeqSet(expected_tintseqset).instantN(2) == TIntInst('20@2019-09-02 00:00:00+01')
+    assert TIntSeqSet(expected_tintseqset).instants == [TIntInst('10@2019-09-01 00:00:00+01'),
+                                                TIntInst('20@2019-09-02 00:00:00+01'),
+                                                TIntInst('30@2019-09-03 00:00:00+01')]
+    assert TIntSeqSet(expected_tintseqset).numTimestamps == 3
+    assert TIntSeqSet(expected_tintseqset).startTimestamp == parse('2019-09-01 00:00:00+01')
+    assert TIntSeqSet(expected_tintseqset).endTimestamp == parse('2019-09-03 00:00:00+01')
+    assert TIntSeqSet(expected_tintseqset).timestampN(2) == parse('2019-09-02 00:00:00+01')
+    assert TIntSeqSet(expected_tintseqset).timestamps == [parse('2019-09-01 00:00:00+01'), parse('2019-09-02 00:00:00+01'),
+                                                  parse('2019-09-03 00:00:00+01')]
+    assert TIntSeqSet(expected_tintseqset).numSequences == 2
+    assert TIntSeqSet(expected_tintseqset).startSequence == TIntSeq('[10@2019-09-01 00:00:00+01]')
+    assert TIntSeqSet(expected_tintseqset).endSequence == TIntSeq(
+        '[20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]')
+    assert TIntSeqSet(expected_tintseqset).sequenceN(2) == TIntSeq(
+        '[20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]')
+    assert TIntSeqSet(expected_tintseqset).sequences == [TIntSeq('[10@2019-09-01 00:00:00+01]'),
+                                                 TIntSeq(
+                                                     '[20@2019-09-02 00:00:00+01, 30@2019-09-03 00:00:00+01]')]
+    assert TIntSeqSet(expected_tintseqset).intersectsTimestamp(parse('2019-09-01 00:00:00+01')) == True
+    assert TIntSeqSet(expected_tintseqset).intersectsTimestamp(parse('2019-09-04 00:00:00+01')) == False
+    assert TIntSeqSet(expected_tintseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01}')) == True
+    assert TIntSeqSet(expected_tintseqset).intersectsTimestampSet(
+        TimestampSet('{2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01}')) == False
+    assert TIntSeqSet(expected_tintseqset).intersectsPeriod(
+        Period('[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]')) == True
+    assert TIntSeqSet(expected_tintseqset).intersectsPeriod(
+        Period('[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]')) == False
+    assert TIntSeqSet(expected_tintseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-01 00:00:00+01, 2019-09-02 00:00:00+01]}')) == True
+    assert TIntSeqSet(expected_tintseqset).intersectsPeriodSet(
+        PeriodSet('{[2019-09-04 00:00:00+01, 2019-09-05 00:00:00+01]}')) == False
```

### Comparing `python-mobilitydb-0.1.2/tests/psycopg/test_stbox.py` & `python-mobilitydb-0.1.3/tests/psycopg/test_stbox.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,80 +1,80 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import pytest
-from dateutil.parser import parse
-from mobilitydb import STBox
-
-
-@pytest.mark.parametrize('expected_stbox', [
-    # Only coordinate (X and Y) dimension
-    'STBOX ((1.0, 2.0), (1.0, 2.0))',
-    (('1.0', '2.0', '3.0', '4.0')),
-    (1.0, 2.0, 3.0, 4.0),
-    # Only coordinate (X, Y and Z) dimension
-    'STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
-    (('1.0', '2.0', '3.0', '4.0', '5.0', '6.0')),
-    ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0)),
-    # Both coordinate (X, Y) and time dimensions
-    'STBOX T((1.0, 2.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 2001-01-03 00:00:00+01))',
-    {'bounds': (1.0, 2.0, '2001-01-01 00:00:00+01', 3.0, 4.0, '2001-01-02 00:00:00+01'), 'dimt': True},
-    {'bounds': (1.0, 2.0, parse('2001-01-01 00:00:00+01'), 3.0, 4.0, parse('2001-01-02 00:00:00+01')), 'dimt': True},
-    # Both coordinate (X, Y, and Z) and time dimensions
-    'STBOX ZT((1.0, 2.0, 3.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
-    ((1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01')),
-    ((1.0, 2.0, 3.0, parse('2001-01-01 00:00:00+01'), 4.0, 5.0, 6.0, parse('2001-01-02 00:00:00+01'))),
-    # Only time dimension
-    'STBOX T(, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
-    (('2001-01-03 00:00:00+01', '2001-01-03 00:00:00+01')),
-    ((parse('2001-01-03 00:00:00+01'), parse('2001-01-03 00:00:00+01'))),
-    # Only geodetic coordinate (X, Y and Z) dimension
-    'GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
-    {'bounds': (1.0, 2.0, 3.0, 4.0, 5.0, 6.0), 'geodetic': True},
-    #  Both geodetic coordinate (X, Y, and Z) and time dimensions
-    'GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
-    {'bounds': (1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic': True},
-    # Only time dimension for geodetic box
-    'GEODSTBOX T((, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
-    {'bounds': ('2001-01-01 00:00:00+01', '2001-01-02 00:00:00+01'), 'geodetic': True},
-    # With SRID
-    'SRID=5676;STBOX T((1.0, 2.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 2001-01-04 00:00:00+01))',
-    'SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
-    {'bounds': (1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic': True, 'srid': 4326},
-])
-def test_stbox_constructor(cursor, expected_stbox):
-    if isinstance(expected_stbox, dict):
-        params = STBox(**expected_stbox)
-    else:
-        params = STBox(expected_stbox)
-    cursor.execute("INSERT INTO tbl_stbox (box) VALUES (%s)" % params)
-    cursor.execute("SELECT box FROM tbl_stbox WHERE box=%s" % params)
-    result = cursor.fetchone()[0]
-    if isinstance(expected_stbox, dict):
-        assert result == STBox(**expected_stbox)
-    else:
-        assert result == STBox(expected_stbox)
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import pytest
+from dateutil.parser import parse
+from mobilitydb import STBox
+
+
+@pytest.mark.parametrize('expected_stbox', [
+    # Only coordinate (X and Y) dimension
+    'STBOX ((1.0, 2.0), (1.0, 2.0))',
+    (('1.0', '2.0', '3.0', '4.0')),
+    (1.0, 2.0, 3.0, 4.0),
+    # Only coordinate (X, Y and Z) dimension
+    'STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
+    (('1.0', '2.0', '3.0', '4.0', '5.0', '6.0')),
+    ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0)),
+    # Both coordinate (X, Y) and time dimensions
+    'STBOX T((1.0, 2.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 2001-01-03 00:00:00+01))',
+    {'bounds': (1.0, 2.0, '2001-01-01 00:00:00+01', 3.0, 4.0, '2001-01-02 00:00:00+01'), 'dimt': True},
+    {'bounds': (1.0, 2.0, parse('2001-01-01 00:00:00+01'), 3.0, 4.0, parse('2001-01-02 00:00:00+01')), 'dimt': True},
+    # Both coordinate (X, Y, and Z) and time dimensions
+    'STBOX ZT((1.0, 2.0, 3.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
+    ((1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01')),
+    ((1.0, 2.0, 3.0, parse('2001-01-01 00:00:00+01'), 4.0, 5.0, 6.0, parse('2001-01-02 00:00:00+01'))),
+    # Only time dimension
+    'STBOX T(, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
+    (('2001-01-03 00:00:00+01', '2001-01-03 00:00:00+01')),
+    ((parse('2001-01-03 00:00:00+01'), parse('2001-01-03 00:00:00+01'))),
+    # Only geodetic coordinate (X, Y and Z) dimension
+    'GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
+    {'bounds': (1.0, 2.0, 3.0, 4.0, 5.0, 6.0), 'geodetic': True},
+    #  Both geodetic coordinate (X, Y, and Z) and time dimensions
+    'GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))',
+    {'bounds': (1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic': True},
+    # Only time dimension for geodetic box
+    'GEODSTBOX T((, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))',
+    {'bounds': ('2001-01-01 00:00:00+01', '2001-01-02 00:00:00+01'), 'geodetic': True},
+    # With SRID
+    'SRID=5676;STBOX T((1.0, 2.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 2001-01-04 00:00:00+01))',
+    'SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))',
+    {'bounds': (1.0, 2.0, 3.0, '2001-01-01 00:00:00+01', 4.0, 5.0, 6.0, '2001-01-02 00:00:00+01'), 'geodetic': True, 'srid': 4326},
+])
+def test_stbox_constructor(cursor, expected_stbox):
+    if isinstance(expected_stbox, dict):
+        params = STBox(**expected_stbox)
+    else:
+        params = STBox(expected_stbox)
+    cursor.execute("INSERT INTO tbl_stbox (box) VALUES (%s)" % params)
+    cursor.execute("SELECT box FROM tbl_stbox WHERE box=%s" % params)
+    result = cursor.fetchone()[0]
+    if isinstance(expected_stbox, dict):
+        assert result == STBox(**expected_stbox)
+    else:
+        assert result == STBox(expected_stbox)
+
+
```

### Comparing `python-mobilitydb-0.1.2/python_mobilitydb.egg-info/SOURCES.txt` & `python-mobilitydb-0.1.3/python_mobilitydb.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `python-mobilitydb-0.1.2/setup.py` & `python-mobilitydb-0.1.3/setup.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-from setuptools import find_packages
-from distutils.core import setup
-
-with open("README.md", "r") as fh:
-    long_description = fh.read()
-
-setup(
-    name='python-mobilitydb',
-    packages=find_packages(),
-    version='0.1.2',
-    license='MIT',
-    description='A database adapter to access MobilityDB from Python',
-    author='MobilityDB Project',
-    platforms=["linux"],
-    long_description=long_description,
-    long_description_content_type='text/markdown',
-    url='https://github.com/MobilityDB/MobilityDB-python',
-    download_url='',
-    install_requires=[
-        'asyncpg',
-        'psycopg2-binary',
-        'Spans',
-        'postgis',
-        'pytest',
-        'python-dateutil',
-        'parsec',
-        'pytest-asyncio'
-    ],
-    keywords=['MobilityDB', 'Python'],
-    classifiers=[
-        'Development Status :: 3 - Alpha',
-        'Intended Audience :: Developers',
-        'Topic :: Database :: Front-Ends',
-        'Topic :: Software Development :: Libraries :: Python Modules',
-        "Topic :: Scientific/Engineering :: GIS",
-        'License :: OSI Approved :: MIT License',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.4',
-        'Programming Language :: Python :: 3.5',
-        'Programming Language :: Python :: 3.6',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-    ],
-    project_urls={
-        'Source': 'https://github.com/MobilityDB/MobilityDB-python',
-        'Documentation': 'https://docs.mobilitydb.com/MobilityDB-python/master/python-mobilitydb.pdf',
-    },
-)
+from setuptools import find_packages
+from distutils.core import setup
+
+with open("README.md", "r") as fh:
+    long_description = fh.read()
+
+setup(
+    name='python-mobilitydb',
+    packages=find_packages(),
+    version='0.1.3',
+    license='MIT',
+    description='A database adapter to access MobilityDB from Python',
+    author='MobilityDB Project',
+    platforms=["linux"],
+    long_description=long_description,
+    long_description_content_type='text/markdown',
+    url='https://github.com/MobilityDB/MobilityDB-python',
+    download_url='',
+    install_requires=[
+        'asyncpg',
+        'psycopg2-binary',
+        'Spans',
+        'postgis',
+        'pytest',
+        'python-dateutil',
+        'parsec',
+        'pytest-asyncio'
+    ],
+    keywords=['MobilityDB', 'Python'],
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Intended Audience :: Developers',
+        'Topic :: Database :: Front-Ends',
+        'Topic :: Software Development :: Libraries :: Python Modules',
+        "Topic :: Scientific/Engineering :: GIS",
+        'License :: OSI Approved :: MIT License',
+        'Programming Language :: Python :: 3',
+        'Programming Language :: Python :: 3.4',
+        'Programming Language :: Python :: 3.5',
+        'Programming Language :: Python :: 3.6',
+        'Programming Language :: Python :: 3.7',
+        'Programming Language :: Python :: 3.8',
+        'Programming Language :: Python :: 3.9',
+    ],
+    project_urls={
+        'Source': 'https://github.com/MobilityDB/MobilityDB-python',
+        'Documentation': 'https://docs.mobilitydb.com/MobilityDB-python/master/python-mobilitydb.pdf',
+    },
+)
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/psycopg.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,93 +1,93 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from psycopg2 import extensions
-from mobilitydb.boxes import TBox, STBox
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint
-
-
-# Suggestion is to have our own connection method to register our types without asking the user to do this step
-"""
-class MobilityDB:
-    @classmethod
-    def connect(cls, host_, database_, user_, password_):
-        conn = psycopg2.connect(host=host_, database=database_, user=user_, password=password_)
-        register(conn)
-        return conn
-"""
-
-def register(connection):
-    if isinstance(connection, extensions.cursor):
-        # Retrocompat.
-        cursor = connection
-    else:
-        cursor = connection.cursor()
-
-    # Add MobilityDB types to PostgreSQL adapter and specify the reader function for each type.
-    cursor.execute("SELECT NULL::TimestampSet")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TimestampSet", TimestampSet.read_from_cursor))
-
-    cursor.execute("SELECT NULL::Period")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "Period", Period.read_from_cursor))
-
-    cursor.execute("SELECT NULL::PeriodSet")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "PeriodSet", PeriodSet.read_from_cursor))
-
-    cursor.execute("SELECT NULL::TBOX")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TBOX", TBox.read_from_cursor))
-
-    cursor.execute("SELECT NULL::TBool")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TBool", TBool.read_from_cursor))
-
-    cursor.execute("SELECT NULL::TInt")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TInt", TInt.read_from_cursor))
-
-    cursor.execute("SELECT NULL::TFloat")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TFloat", TFloat.read_from_cursor))
-
-    cursor.execute("SELECT NULL::TText")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TText", TText.read_from_cursor))
-
-    cursor.execute("SELECT NULL::STBOX")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "STBOX", STBox.read_from_cursor))
-
-    cursor.execute("SELECT NULL::TGeomPoint")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TGeomPoint", TGeomPoint.read_from_cursor))
-
-    cursor.execute("SELECT NULL::TGeogPoint")
-    oid = cursor.description[0][1]
-    extensions.register_type(extensions.new_type((oid,), "TGeogPoint", TGeogPoint.read_from_cursor))
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from psycopg2 import extensions
+from mobilitydb.boxes import TBox, STBox
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint
+
+
+# Suggestion is to have our own connection method to register our types without asking the user to do this step
+"""
+class MobilityDB:
+    @classmethod
+    def connect(cls, host_, database_, user_, password_):
+        conn = psycopg2.connect(host=host_, database=database_, user=user_, password=password_)
+        register(conn)
+        return conn
+"""
+
+def register(connection):
+    if isinstance(connection, extensions.cursor):
+        # Retrocompat.
+        cursor = connection
+    else:
+        cursor = connection.cursor()
+
+    # Add MobilityDB types to PostgreSQL adapter and specify the reader function for each type.
+    cursor.execute("SELECT NULL::TimestampSet")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TimestampSet", TimestampSet.read_from_cursor))
+
+    cursor.execute("SELECT NULL::Period")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "Period", Period.read_from_cursor))
+
+    cursor.execute("SELECT NULL::PeriodSet")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "PeriodSet", PeriodSet.read_from_cursor))
+
+    cursor.execute("SELECT NULL::TBOX")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TBOX", TBox.read_from_cursor))
+
+    cursor.execute("SELECT NULL::TBool")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TBool", TBool.read_from_cursor))
+
+    cursor.execute("SELECT NULL::TInt")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TInt", TInt.read_from_cursor))
+
+    cursor.execute("SELECT NULL::TFloat")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TFloat", TFloat.read_from_cursor))
+
+    cursor.execute("SELECT NULL::TText")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TText", TText.read_from_cursor))
+
+    cursor.execute("SELECT NULL::STBOX")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "STBOX", STBox.read_from_cursor))
+
+    cursor.execute("SELECT NULL::TGeomPoint")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TGeomPoint", TGeomPoint.read_from_cursor))
+
+    cursor.execute("SELECT NULL::TGeogPoint")
+    oid = cursor.description[0][1]
+    extensions.register_type(extensions.new_type((oid,), "TGeogPoint", TGeogPoint.read_from_cursor))
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/asyncpg.py` & `python-mobilitydb-0.1.3/mobilitydb/asyncpg.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,55 +1,55 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncio
-import asyncpg
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.boxes import TBox, STBox
-from mobilitydb.main import TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint
-
-# Suggestion is to have our own connection method to register our types without asking the user to do this step
-"""
-class MobilityDB:
-    @classmethod
-    async def connect(cls, host_, database_, user_, password_):
-        conn = await asyncpg.connect(host=host_, database=database_, user=user_, password=password_)
-        register(conn)
-        return conn
-"""
-
-async def register(conn):
-    # Add MobilityDB types to PostgreSQL adapter and specify the encoder and decoder functions for each type.
-    await conn.set_type_codec("timestampset", encoder=TimestampSet.write, decoder=TimestampSet.read_from_cursor)
-    await conn.set_type_codec("period", encoder=Period.write, decoder=Period.read_from_cursor)
-    await conn.set_type_codec("periodset", encoder=PeriodSet.write, decoder=PeriodSet.read_from_cursor)
-    await conn.set_type_codec("tbox", encoder=TBox.write, decoder=TBox.read_from_cursor)
-    await conn.set_type_codec("tbool", encoder=TBool.write, decoder=TBool.read_from_cursor)
-    await conn.set_type_codec("tint", encoder=TInt.write, decoder=TInt.read_from_cursor)
-    await conn.set_type_codec("tfloat", encoder=TFloat.write, decoder=TFloat.read_from_cursor)
-    await conn.set_type_codec("ttext", encoder=TText.write, decoder=TText.read_from_cursor)
-    await conn.set_type_codec("stbox", encoder=STBox.write, decoder=STBox.read_from_cursor)
-    await conn.set_type_codec("tgeompoint", encoder=TGeomPoint.write, decoder=TGeomPoint.read_from_cursor)
-    await conn.set_type_codec("tgeogpoint", encoder=TGeogPoint.write, decoder=TGeogPoint.read_from_cursor)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+import asyncpg
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.boxes import TBox, STBox
+from mobilitydb.main import TBool, TInt, TFloat, TText, TGeomPoint, TGeogPoint
+
+# Suggestion is to have our own connection method to register our types without asking the user to do this step
+"""
+class MobilityDB:
+    @classmethod
+    async def connect(cls, host_, database_, user_, password_):
+        conn = await asyncpg.connect(host=host_, database=database_, user=user_, password=password_)
+        register(conn)
+        return conn
+"""
+
+async def register(conn):
+    # Add MobilityDB types to PostgreSQL adapter and specify the encoder and decoder functions for each type.
+    await conn.set_type_codec("timestampset", encoder=TimestampSet.write, decoder=TimestampSet.read_from_cursor)
+    await conn.set_type_codec("period", encoder=Period.write, decoder=Period.read_from_cursor)
+    await conn.set_type_codec("periodset", encoder=PeriodSet.write, decoder=PeriodSet.read_from_cursor)
+    await conn.set_type_codec("tbox", encoder=TBox.write, decoder=TBox.read_from_cursor)
+    await conn.set_type_codec("tbool", encoder=TBool.write, decoder=TBool.read_from_cursor)
+    await conn.set_type_codec("tint", encoder=TInt.write, decoder=TInt.read_from_cursor)
+    await conn.set_type_codec("tfloat", encoder=TFloat.write, decoder=TFloat.read_from_cursor)
+    await conn.set_type_codec("ttext", encoder=TText.write, decoder=TText.read_from_cursor)
+    await conn.set_type_codec("stbox", encoder=STBox.write, decoder=STBox.read_from_cursor)
+    await conn.set_type_codec("tgeompoint", encoder=TGeomPoint.write, decoder=TGeomPoint.read_from_cursor)
+    await conn.set_type_codec("tgeogpoint", encoder=TGeogPoint.write, decoder=TGeogPoint.read_from_cursor)
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/temporal/tinstantset.py` & `python-mobilitydb-0.1.3/mobilitydb/temporal/tinstantset.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,153 +1,153 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import timedelta
-from mobilitydb.time import Period, PeriodSet
-from mobilitydb.temporal import TemporalInstants
-from mobilitydb.temporal.temporal_parser import parse_temporalinstset
-
-
-class TInstantSet(TemporalInstants):
-    """
-    Abstract class for representing temporal values of instant set subtype.
-    """
-
-    def __init__(self, *argv):
-        self._instantList = []
-        # Constructor with a single argument of type string
-        if len(argv) == 1 and isinstance(argv[0], str):
-            elements = parse_temporalinstset(argv[0], 0)
-            for inst in elements[2]:
-                self._instantList.append(self.ComponentClass(inst[0], inst[1]))
-        # Constructor with a single argument of type list
-        elif len(argv) == 1 and isinstance(argv[0], list):
-            # List of strings representing instant values
-            if all(isinstance(arg, str) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._instantList.append(self.ComponentClass(arg))
-            # List of instant values
-            elif all(isinstance(arg, self.ComponentClass) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._instantList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse temporal instant set value")
-        # Constructor with multiple arguments
-        else:
-            # Arguments are of type string
-            if all(isinstance(arg, str) for arg in argv):
-                for arg in argv:
-                    self._instantList.append(self.ComponentClass(arg))
-            # Arguments are of type instant
-            elif all(isinstance(arg, self.ComponentClass) for arg in argv):
-                for arg in argv:
-                    self._instantList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse temporal instant set value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        if any(x._time > y._time for x, y in zip(self._instantList, self._instantList[1:])):
-            raise Exception("ERROR: The timestamps of a temporal instant must be increasing")
-
-    @classmethod
-    def tempSubtype(cls):
-        """
-        Subtype of the temporal value, that is, ``'InstantSet'``.
-        """
-        return "InstantSet"
-
-    def valueAtTimestamp(self, timestamp):
-        """
-        Value at timestamp.
-        """
-    def valueAtTimestamp(self, timestamp):
-        """
-        Value at timestamp.
-        """
-        for inst in self._instantList:
-            if inst._time > timestamp:
-                return None
-            if inst._time == timestamp:
-                return inst._value
-        return None
-
-    @property
-    def getTime(self):
-        """
-        Period set on which the temporal value is defined.
-        """
-        return PeriodSet([inst.period for inst in self._instantList])
-
-    @property
-    def duration(self):
-        """
-        Interval on which the temporal value is defined. It is zero for
-        temporal values of instant set subtype.
-        """
-        return timedelta(0)
-
-    @property
-    def timespan(self):
-        """
-        Interval on which the temporal value is defined ignoring the potential
-        time gaps.
-        """
-        return self.endTimestamp - self.startTimestamp
-
-    @property
-    def period(self):
-        """
-        Period on which the temporal value is defined ignoring the potential
-        time gaps.
-        """
-        return Period(self.startTimestamp, self.endTimestamp, True, True)
-
-    def intersectsTimestamp(self, timestamp):
-        """
-        Does the temporal value intersect the timestamp?
-        """
-        return any(inst._time == timestamp for inst in self._instantList)
-
-    def intersectsPeriod(self, period):
-        """
-        Does the temporal value intersect the period?
-        """
-        return any(period.contains_timestamp(inst._time) for inst in self._instantList)
-
-    # Comparisons are missing
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            if self._instantList == other._instantList:
-                return True
-        return False
-
-    def __str__(self):
-        return (f"'{{{TemporalInstants.__str__(self)}}}'")
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import timedelta
+from mobilitydb.time import Period, PeriodSet
+from mobilitydb.temporal import TemporalInstants
+from mobilitydb.temporal.temporal_parser import parse_temporalinstset
+
+
+class TInstantSet(TemporalInstants):
+    """
+    Abstract class for representing temporal values of instant set subtype.
+    """
+
+    def __init__(self, *argv):
+        self._instantList = []
+        # Constructor with a single argument of type string
+        if len(argv) == 1 and isinstance(argv[0], str):
+            elements = parse_temporalinstset(argv[0], 0)
+            for inst in elements[2]:
+                self._instantList.append(self.ComponentClass(inst[0], inst[1]))
+        # Constructor with a single argument of type list
+        elif len(argv) == 1 and isinstance(argv[0], list):
+            # List of strings representing instant values
+            if all(isinstance(arg, str) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._instantList.append(self.ComponentClass(arg))
+            # List of instant values
+            elif all(isinstance(arg, self.ComponentClass) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._instantList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse temporal instant set value")
+        # Constructor with multiple arguments
+        else:
+            # Arguments are of type string
+            if all(isinstance(arg, str) for arg in argv):
+                for arg in argv:
+                    self._instantList.append(self.ComponentClass(arg))
+            # Arguments are of type instant
+            elif all(isinstance(arg, self.ComponentClass) for arg in argv):
+                for arg in argv:
+                    self._instantList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse temporal instant set value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        if any(x._time > y._time for x, y in zip(self._instantList, self._instantList[1:])):
+            raise Exception("ERROR: The timestamps of a temporal instant must be increasing")
+
+    @classmethod
+    def tempSubtype(cls):
+        """
+        Subtype of the temporal value, that is, ``'InstantSet'``.
+        """
+        return "InstantSet"
+
+    def valueAtTimestamp(self, timestamp):
+        """
+        Value at timestamp.
+        """
+    def valueAtTimestamp(self, timestamp):
+        """
+        Value at timestamp.
+        """
+        for inst in self._instantList:
+            if inst._time > timestamp:
+                return None
+            if inst._time == timestamp:
+                return inst._value
+        return None
+
+    @property
+    def getTime(self):
+        """
+        Period set on which the temporal value is defined.
+        """
+        return PeriodSet([inst.period for inst in self._instantList])
+
+    @property
+    def duration(self):
+        """
+        Interval on which the temporal value is defined. It is zero for
+        temporal values of instant set subtype.
+        """
+        return timedelta(0)
+
+    @property
+    def timespan(self):
+        """
+        Interval on which the temporal value is defined ignoring the potential
+        time gaps.
+        """
+        return self.endTimestamp - self.startTimestamp
+
+    @property
+    def period(self):
+        """
+        Period on which the temporal value is defined ignoring the potential
+        time gaps.
+        """
+        return Period(self.startTimestamp, self.endTimestamp, True, True)
+
+    def intersectsTimestamp(self, timestamp):
+        """
+        Does the temporal value intersect the timestamp?
+        """
+        return any(inst._time == timestamp for inst in self._instantList)
+
+    def intersectsPeriod(self, period):
+        """
+        Does the temporal value intersect the period?
+        """
+        return any(period.contains_timestamp(inst._time) for inst in self._instantList)
+
+    # Comparisons are missing
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            if self._instantList == other._instantList:
+                return True
+        return False
+
+    def __str__(self):
+        return (f"'{{{TemporalInstants.__str__(self)}}}'")
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
                 f'({self._instantList!r})')
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/temporal/tsequence.py` & `python-mobilitydb-0.1.3/mobilitydb/temporal/tsequence.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,240 +1,240 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from mobilitydb.time import Period, PeriodSet
-from mobilitydb.temporal import TemporalInstants
-from mobilitydb.temporal.temporal_parser import parse_temporalseq
-
-
-class TSequence(TemporalInstants):
-    """
-    Abstract class for representing temporal values of sequence subtype.
-    """
-    __slots__ = ['_lower_inc', '_upper_inc', '_interp']
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None):
-        assert (isinstance(lower_inc, (bool, type(None)))), "ERROR: Invalid lower bound flag"
-        assert (isinstance(upper_inc, (bool, type(None)))), "ERROR: Invalid upper bound flag"
-        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
-        if isinstance(interp, str):
-            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
-        self._instantList = []
-        # Constructor with a first argument of type string and optional arguments for the bounds and interpolation
-        if isinstance(instantList, str):
-            elements = parse_temporalseq(instantList, 0)
-            for inst in elements[2][0]:
-                self._instantList.append(self.ComponentClass(inst[0], inst[1]))
-            self._lower_inc = elements[2][1]
-            self._upper_inc = elements[2][2]
-            # Set interpolation with the argument or the flag from the string if given
-            if interp is not None:
-                self._interp = interp
-            else:
-                if self.BaseClassDiscrete:
-                    self._interp = 'Stepwise'
-                else:
-                    self._interp = elements[2][3] if elements[2][3] is not None else 'Linear'
-        # Constructor with a first argument of type list and optional arguments for the bounds and interpolation
-        elif isinstance(instantList, list):
-            # List of strings representing instant values
-            if all(isinstance(arg, str) for arg in instantList):
-                for arg in instantList:
-                    self._instantList.append(self.ComponentClass(arg))
-            # List of instant values
-            elif all(isinstance(arg, self.ComponentClass) for arg in instantList):
-                for arg in instantList:
-                    self._instantList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse temporal sequence value")
-            self._lower_inc = lower_inc if lower_inc is not None else True
-            self._upper_inc = upper_inc if upper_inc is not None else False
-            # Set the interpolation
-            if interp is not None:
-                self._interp = interp
-            else:
-                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
-        else:
-            raise Exception("ERROR: Could not parse temporal sequence value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        if len(self._instantList) == 1 and (not self._lower_inc or not self._lower_inc):
-            raise Exception("ERROR: The lower and upper bounds must be inclusive for an instant temporal sequence")
-        if any(x._time >= y._time for x, y in zip(self._instantList, self._instantList[1:])):
-            raise Exception("ERROR: The timestamps of a temporal sequence must be increasing")
-        if (self._interp == 'Stepwise' and len(self._instantList) > 1 and not self._upper_inc and
-                    self._instantList[-1]._value != self._instantList[-2]._value):
-            raise Exception(
-                "ERROR: The last two values of a temporal sequence with exclusive upper bound and stepwise interpolation must be equal")
-        return True
-
-    @classmethod
-    def tempSubtype(cls):
-        """
-        Subtype of the temporal value, that is, ``'Sequence'``.
-        """
-        return "Sequence"
-
-    @property
-    def lower_inc(self):
-        """
-        Is the lower bound inclusive?
-        """
-        return self._lower_inc
-
-    @property
-    def upper_inc(self):
-        """
-        Is the upper bound inclusive?
-        """
-        return self._upper_inc
-
-    def valueAtTimestamp(self, timestamp):
-        """
-        Value at timestamp.
-        """
-        for i in range(len(self._instantList)):
-            inst1 = self._instantList[i]
-            if inst1._time > timestamp:
-                return None
-
-            if i < len(self._instantList) - 1:
-                inst2 = self._instantList[i+1]
-            else:
-                inst2 = None
-            if inst1._time == timestamp:
-                if inst2 is not None or self._upper_inc:
-                    return inst1._value
-                else:
-                    return None
-            # We know that inst1._time < timestamp
-            # if inst1 is the last instant
-            if inst2 is None:
-                return None
-            else:
-                if timestamp < inst2._time:
-                    if self._interp == 'Stepwise':
-                        return inst1._value
-                    else:
-                        return self._interpolate(inst1, inst2, timestamp)
-        return None
-
-    @property
-    def getTime(self):
-        """
-        Period set on which the temporal value is defined.
-        """
-        return PeriodSet([self.period])
-
-    @property
-    def duration(self):
-        """
-        Interval on which the temporal value is defined.
-        """
-        return self.period.upper - self.period.lower
-
-    @property
-    def timespan(self):
-        """
-        Interval on which the temporal value is defined.
-        """
-        return self.period.upper - self.period.lower
-
-    @property
-    def period(self):
-        """
-        Period on which the temporal value is defined.
-        """
-        return Period(self.startTimestamp, self.endTimestamp, self.lower_inc, self.upper_inc)
-
-    @property
-    def numSequences(self):
-        """
-        Number of sequences.
-        """
-        return 1
-
-    @property
-    def startSequence(self):
-        """
-        Start sequence.
-        """
-        return self
-
-    @property
-    def endSequence(self):
-        """
-        End sequence.
-        """
-        return self
-
-    def sequenceN(self, n):
-        """
-        N-th sequence.
-        """
-        # 1-based
-        if n == 1:
-            return self
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def sequences(self):
-        """
-        List of sequences.
-        """
-        return [self]
-
-    def intersectsTimestamp(self, timestamp):
-        """
-        Does the temporal value intersect the timestamp?
-        """
-        return self.period.contains_timestamp(timestamp)
-
-    def intersectsPeriod(self, period):
-        """
-        Does the temporal value intersect the period?
-        """
-        return self.period.overlap(period)
-
-    # Comparisons are missing
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            if self._instantList == other._instantList and self._lower_inc == other._lower_inc and \
-                            self._upper_inc == other._upper_inc and self._interp == other._interp:
-                return True
-        return False
-
-    def __str__(self):
-        interp_str = 'Interp=Stepwise;' if self._interp == 'Stepwise' and self.__class__.BaseClassDiscrete == False else ''
-        lower_str = '[' if self._lower_inc else '('
-        upper_str = ']' if self._upper_inc else ')'
-        return (f"'{interp_str}{lower_str}{TemporalInstants.__str__(self)}{upper_str}'")
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
-                f'({self._instantList!r}, {self._lower_inc!r}, {self._upper_inc!r}, {self._interp!r})')
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from mobilitydb.time import Period, PeriodSet
+from mobilitydb.temporal import TemporalInstants
+from mobilitydb.temporal.temporal_parser import parse_temporalseq
+
+
+class TSequence(TemporalInstants):
+    """
+    Abstract class for representing temporal values of sequence subtype.
+    """
+    __slots__ = ['_lower_inc', '_upper_inc', '_interp']
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None):
+        assert (isinstance(lower_inc, (bool, type(None)))), "ERROR: Invalid lower bound flag"
+        assert (isinstance(upper_inc, (bool, type(None)))), "ERROR: Invalid upper bound flag"
+        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
+        if isinstance(interp, str):
+            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
+        self._instantList = []
+        # Constructor with a first argument of type string and optional arguments for the bounds and interpolation
+        if isinstance(instantList, str):
+            elements = parse_temporalseq(instantList, 0)
+            for inst in elements[2][0]:
+                self._instantList.append(self.ComponentClass(inst[0], inst[1]))
+            self._lower_inc = elements[2][1]
+            self._upper_inc = elements[2][2]
+            # Set interpolation with the argument or the flag from the string if given
+            if interp is not None:
+                self._interp = interp
+            else:
+                if self.BaseClassDiscrete:
+                    self._interp = 'Stepwise'
+                else:
+                    self._interp = elements[2][3] if elements[2][3] is not None else 'Linear'
+        # Constructor with a first argument of type list and optional arguments for the bounds and interpolation
+        elif isinstance(instantList, list):
+            # List of strings representing instant values
+            if all(isinstance(arg, str) for arg in instantList):
+                for arg in instantList:
+                    self._instantList.append(self.ComponentClass(arg))
+            # List of instant values
+            elif all(isinstance(arg, self.ComponentClass) for arg in instantList):
+                for arg in instantList:
+                    self._instantList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse temporal sequence value")
+            self._lower_inc = lower_inc if lower_inc is not None else True
+            self._upper_inc = upper_inc if upper_inc is not None else False
+            # Set the interpolation
+            if interp is not None:
+                self._interp = interp
+            else:
+                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
+        else:
+            raise Exception("ERROR: Could not parse temporal sequence value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        if len(self._instantList) == 1 and (not self._lower_inc or not self._lower_inc):
+            raise Exception("ERROR: The lower and upper bounds must be inclusive for an instant temporal sequence")
+        if any(x._time >= y._time for x, y in zip(self._instantList, self._instantList[1:])):
+            raise Exception("ERROR: The timestamps of a temporal sequence must be increasing")
+        if (self._interp == 'Stepwise' and len(self._instantList) > 1 and not self._upper_inc and
+                    self._instantList[-1]._value != self._instantList[-2]._value):
+            raise Exception(
+                "ERROR: The last two values of a temporal sequence with exclusive upper bound and stepwise interpolation must be equal")
+        return True
+
+    @classmethod
+    def tempSubtype(cls):
+        """
+        Subtype of the temporal value, that is, ``'Sequence'``.
+        """
+        return "Sequence"
+
+    @property
+    def lower_inc(self):
+        """
+        Is the lower bound inclusive?
+        """
+        return self._lower_inc
+
+    @property
+    def upper_inc(self):
+        """
+        Is the upper bound inclusive?
+        """
+        return self._upper_inc
+
+    def valueAtTimestamp(self, timestamp):
+        """
+        Value at timestamp.
+        """
+        for i in range(len(self._instantList)):
+            inst1 = self._instantList[i]
+            if inst1._time > timestamp:
+                return None
+
+            if i < len(self._instantList) - 1:
+                inst2 = self._instantList[i+1]
+            else:
+                inst2 = None
+            if inst1._time == timestamp:
+                if inst2 is not None or self._upper_inc:
+                    return inst1._value
+                else:
+                    return None
+            # We know that inst1._time < timestamp
+            # if inst1 is the last instant
+            if inst2 is None:
+                return None
+            else:
+                if timestamp < inst2._time:
+                    if self._interp == 'Stepwise':
+                        return inst1._value
+                    else:
+                        return self._interpolate(inst1, inst2, timestamp)
+        return None
+
+    @property
+    def getTime(self):
+        """
+        Period set on which the temporal value is defined.
+        """
+        return PeriodSet([self.period])
+
+    @property
+    def duration(self):
+        """
+        Interval on which the temporal value is defined.
+        """
+        return self.period.upper - self.period.lower
+
+    @property
+    def timespan(self):
+        """
+        Interval on which the temporal value is defined.
+        """
+        return self.period.upper - self.period.lower
+
+    @property
+    def period(self):
+        """
+        Period on which the temporal value is defined.
+        """
+        return Period(self.startTimestamp, self.endTimestamp, self.lower_inc, self.upper_inc)
+
+    @property
+    def numSequences(self):
+        """
+        Number of sequences.
+        """
+        return 1
+
+    @property
+    def startSequence(self):
+        """
+        Start sequence.
+        """
+        return self
+
+    @property
+    def endSequence(self):
+        """
+        End sequence.
+        """
+        return self
+
+    def sequenceN(self, n):
+        """
+        N-th sequence.
+        """
+        # 1-based
+        if n == 1:
+            return self
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def sequences(self):
+        """
+        List of sequences.
+        """
+        return [self]
+
+    def intersectsTimestamp(self, timestamp):
+        """
+        Does the temporal value intersect the timestamp?
+        """
+        return self.period.contains_timestamp(timestamp)
+
+    def intersectsPeriod(self, period):
+        """
+        Does the temporal value intersect the period?
+        """
+        return self.period.overlap(period)
+
+    # Comparisons are missing
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            if self._instantList == other._instantList and self._lower_inc == other._lower_inc and \
+                            self._upper_inc == other._upper_inc and self._interp == other._interp:
+                return True
+        return False
+
+    def __str__(self):
+        interp_str = 'Interp=Stepwise;' if self._interp == 'Stepwise' and self.__class__.BaseClassDiscrete == False else ''
+        lower_str = '[' if self._lower_inc else '('
+        upper_str = ']' if self._upper_inc else ')'
+        return (f"'{interp_str}{lower_str}{TemporalInstants.__str__(self)}{upper_str}'")
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
+                f'({self._instantList!r}, {self._lower_inc!r}, {self._upper_inc!r}, {self._interp!r})')
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/temporal/tinstant.py` & `python-mobilitydb-0.1.3/mobilitydb/temporal/tinstant.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,261 +1,261 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from parsec import *
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from mobilitydb.time import Period, PeriodSet
-from mobilitydb.temporal import Temporal
-from mobilitydb.temporal.temporal_parser import parse_temporalinst
-
-
-class TInstant(Temporal):
-    """
-    Abstract class for representing temporal values of instant subtype.
-    """
-    __slots__ = ['_value', '_time']
-
-    def __init__(self, value, time=None):
-        if(time is None):
-            # Constructor with a single argument of type string
-            if isinstance(value, str):
-                couple = parse_temporalinst(value, 0)
-                value = couple[2][0]
-                time = couple[2][1]
-            # Constructor with a single argument of type tuple or list
-            elif isinstance(value, (tuple, list)):
-                value, time = value
-            else:
-                raise Exception("ERROR: Could not parse temporal instant value")
-        # Now both value and time are not None
-        assert(isinstance(value, (str, self.BaseClass))), "ERROR: Invalid value argument"
-        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
-        self._value = self.BaseClass(value) if isinstance(value, str) else value
-        self._time = parse(time) if isinstance(time, str) else time
-
-    @classmethod
-    def tempSubtype(cls):
-        """
-        Subtype of the temporal value, that is, ``'Instant'``.
-        """
-        return "Instant"
-
-    @property
-    def getValue(self):
-        """
-        Value component.
-        """
-        return self._value
-
-    @property
-    def getValues(self):
-        """
-        List of distinct values.
-        """
-        return [self._value]
-
-    @property
-    def startValue(self):
-        """
-        Start value.
-        """
-        return self._value
-
-    @property
-    def endValue(self):
-        """
-        End value.
-        """
-        return self._value
-
-    @property
-    def minValue(self):
-        """
-        Minimum value.
-        """
-        return self._value
-
-    @property
-    def maxValue(self):
-        """
-        Maximum value.
-        """
-        return self._value
-
-    def valueAtTimestamp(self, timestamp):
-        """
-        Value at timestamp.
-        """
-        if timestamp == self._time:
-            return self._value
-        else:
-            return None
-
-    @property
-    def getTimestamp(self):
-        """
-        Timestamp.
-        """
-        return self._time
-
-    @property
-    def getTime(self):
-        """
-        Period set on which the temporal value is defined.
-        """
-        return PeriodSet([Period(self._time, self._time, True, True)])
-
-    @property
-    def duration(self):
-        """
-        Interval on which the temporal value is defined. It is zero for
-        temporal values of instant subtype.
-        """
-        return timedelta(0)
-
-    @property
-    def timespan(self):
-        """
-        Interval on which the temporal value is defined ignoring the potential
-        time gaps. It is zero for temporal values of instant subtype.
-        """
-        return timedelta(0)
-
-    @property
-    def period(self):
-        """
-        Period on which the temporal value is defined ignoring the potential
-        time gaps.
-        """
-        return Period(self._time, self._time, True, True)
-
-    @property
-    def numInstants(self):
-        """
-        Number of instants.
-        """
-        return 1
-
-    @property
-    def startInstant(self):
-        """
-        Start instant.
-        """
-        return self
-
-    @property
-    def endInstant(self):
-        """
-        End instant.
-        """
-        return self
-
-    def instantN(self, n):
-        """
-        N-th instant.
-        """
-        if n == 1:
-            return self
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def instants(self):
-        """
-        List of instants.
-        """
-        return [self]
-
-    @property
-    def numTimestamps(self):
-        """
-        Number of timestamps.
-        """
-        return 1
-
-    @property
-    def startTimestamp(self):
-        """
-        Start timestamp.
-        """
-        return self._time
-
-    @property
-    def endTimestamp(self):
-        """
-        End timestamp.
-        """
-        return self._time
-
-    def timestampN(self, n):
-        """
-        N-th timestamp
-        """
-        if n == 1:
-            return self._time
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def timestamps(self):
-        """
-        List of timestamps.
-        """
-        return [self._time]
-
-    def shift(self, timedelta):
-        """
-        Shift the temporal value by a time interval.
-        """
-        self._time += timedelta
-        return self
-
-    def intersectsTimestamp(self, timestamp):
-        """
-        Does the temporal value intersect the timestamp?
-        """
-        return self._time == timestamp
-
-    def intersectsPeriod(self, period):
-        """
-        Does the temporal value intersect the period?
-        """
-        return period.contains_timestamp(self._time)
-
-    # Comparisons are missing
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            if self._value == other._value and self._time == other._time:
-                return True
-        return False
-
-    def __str__(self):
-        return (f"'{self._value!s}@{self._time!s}'")
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
-                f'({self._value!r}, {self._time!r})')
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from parsec import *
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from mobilitydb.time import Period, PeriodSet
+from mobilitydb.temporal import Temporal
+from mobilitydb.temporal.temporal_parser import parse_temporalinst
+
+
+class TInstant(Temporal):
+    """
+    Abstract class for representing temporal values of instant subtype.
+    """
+    __slots__ = ['_value', '_time']
+
+    def __init__(self, value, time=None):
+        if(time is None):
+            # Constructor with a single argument of type string
+            if isinstance(value, str):
+                couple = parse_temporalinst(value, 0)
+                value = couple[2][0]
+                time = couple[2][1]
+            # Constructor with a single argument of type tuple or list
+            elif isinstance(value, (tuple, list)):
+                value, time = value
+            else:
+                raise Exception("ERROR: Could not parse temporal instant value")
+        # Now both value and time are not None
+        assert(isinstance(value, (str, self.BaseClass))), "ERROR: Invalid value argument"
+        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
+        self._value = self.BaseClass(value) if isinstance(value, str) else value
+        self._time = parse(time) if isinstance(time, str) else time
+
+    @classmethod
+    def tempSubtype(cls):
+        """
+        Subtype of the temporal value, that is, ``'Instant'``.
+        """
+        return "Instant"
+
+    @property
+    def getValue(self):
+        """
+        Value component.
+        """
+        return self._value
+
+    @property
+    def getValues(self):
+        """
+        List of distinct values.
+        """
+        return [self._value]
+
+    @property
+    def startValue(self):
+        """
+        Start value.
+        """
+        return self._value
+
+    @property
+    def endValue(self):
+        """
+        End value.
+        """
+        return self._value
+
+    @property
+    def minValue(self):
+        """
+        Minimum value.
+        """
+        return self._value
+
+    @property
+    def maxValue(self):
+        """
+        Maximum value.
+        """
+        return self._value
+
+    def valueAtTimestamp(self, timestamp):
+        """
+        Value at timestamp.
+        """
+        if timestamp == self._time:
+            return self._value
+        else:
+            return None
+
+    @property
+    def getTimestamp(self):
+        """
+        Timestamp.
+        """
+        return self._time
+
+    @property
+    def getTime(self):
+        """
+        Period set on which the temporal value is defined.
+        """
+        return PeriodSet([Period(self._time, self._time, True, True)])
+
+    @property
+    def duration(self):
+        """
+        Interval on which the temporal value is defined. It is zero for
+        temporal values of instant subtype.
+        """
+        return timedelta(0)
+
+    @property
+    def timespan(self):
+        """
+        Interval on which the temporal value is defined ignoring the potential
+        time gaps. It is zero for temporal values of instant subtype.
+        """
+        return timedelta(0)
+
+    @property
+    def period(self):
+        """
+        Period on which the temporal value is defined ignoring the potential
+        time gaps.
+        """
+        return Period(self._time, self._time, True, True)
+
+    @property
+    def numInstants(self):
+        """
+        Number of instants.
+        """
+        return 1
+
+    @property
+    def startInstant(self):
+        """
+        Start instant.
+        """
+        return self
+
+    @property
+    def endInstant(self):
+        """
+        End instant.
+        """
+        return self
+
+    def instantN(self, n):
+        """
+        N-th instant.
+        """
+        if n == 1:
+            return self
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def instants(self):
+        """
+        List of instants.
+        """
+        return [self]
+
+    @property
+    def numTimestamps(self):
+        """
+        Number of timestamps.
+        """
+        return 1
+
+    @property
+    def startTimestamp(self):
+        """
+        Start timestamp.
+        """
+        return self._time
+
+    @property
+    def endTimestamp(self):
+        """
+        End timestamp.
+        """
+        return self._time
+
+    def timestampN(self, n):
+        """
+        N-th timestamp
+        """
+        if n == 1:
+            return self._time
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def timestamps(self):
+        """
+        List of timestamps.
+        """
+        return [self._time]
+
+    def shift(self, timedelta):
+        """
+        Shift the temporal value by a time interval.
+        """
+        self._time += timedelta
+        return self
+
+    def intersectsTimestamp(self, timestamp):
+        """
+        Does the temporal value intersect the timestamp?
+        """
+        return self._time == timestamp
+
+    def intersectsPeriod(self, period):
+        """
+        Does the temporal value intersect the period?
+        """
+        return period.contains_timestamp(self._time)
+
+    # Comparisons are missing
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            if self._value == other._value and self._time == other._time:
+                return True
+        return False
+
+    def __str__(self):
+        return (f"'{self._value!s}@{self._time!s}'")
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
+                f'({self._value!r}, {self._time!r})')
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/temporal/temporal_parser.py` & `python-mobilitydb-0.1.3/mobilitydb/temporal/temporal_parser.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,79 +1,79 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from parsec import *
-
-
-spaces = regex(r'\s*', re.MULTILINE)
-lexeme = lambda p: p << spaces
-lbrace = lexeme(string('{'))
-rbrace = lexeme(string('}'))
-lbrack = lexeme(string('['))
-rbrack = lexeme(string(']'))
-lparen = lexeme(string('('))
-rparen = lexeme(string(')'))
-at = lexeme(string('@'))
-
-@generate
-def parse_temporalinst():
-    value = yield spaces >> regex(r'[^@]+') << spaces
-    yield string('@')
-    time = yield spaces >> regex(r'[^,}\]\)]+')
-    return [value, time]
-
-@generate
-def parse_temporalinstset():
-    yield spaces >> lbrace << spaces
-    instants = yield sepEndBy1(parse_temporalinst, string(','))
-    yield spaces >> rbrace << spaces
-    return instants
-
-@generate
-def parse_temporalseq():
-    ip = yield spaces >> (string('Interp=Stepwise;') | string('')) << spaces
-    if ip == '':
-        interp = None
-    else:
-        interp = 'Stepwise'
-    lb = yield spaces >> (lbrack | lparen) << spaces
-    lower = True if lb == '[' else False
-    instants = yield sepEndBy1(parse_temporalinst, string(','))
-    ub = yield spaces >> (rbrack | rparen) << spaces
-    upper = True if ub == ']' else False
-    return (instants, lower, upper, interp)
-
-@generate
-def parse_temporalseqset():
-    ip = yield spaces >> string('Interp=Stepwise;') | string('') << spaces
-    if ip == '':
-        interp = None
-    else:
-        interp = 'Stepwise'
-    yield spaces >> lbrace << spaces
-    sequences = yield sepEndBy1(parse_temporalseq, string(','))
-    yield spaces >> rbrace << spaces
-    return (sequences, interp)
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from parsec import *
+
+
+spaces = regex(r'\s*', re.MULTILINE)
+lexeme = lambda p: p << spaces
+lbrace = lexeme(string('{'))
+rbrace = lexeme(string('}'))
+lbrack = lexeme(string('['))
+rbrack = lexeme(string(']'))
+lparen = lexeme(string('('))
+rparen = lexeme(string(')'))
+at = lexeme(string('@'))
+
+@generate
+def parse_temporalinst():
+    value = yield spaces >> regex(r'[^@]+') << spaces
+    yield string('@')
+    time = yield spaces >> regex(r'[^,}\]\)]+')
+    return [value, time]
+
+@generate
+def parse_temporalinstset():
+    yield spaces >> lbrace << spaces
+    instants = yield sepEndBy1(parse_temporalinst, string(','))
+    yield spaces >> rbrace << spaces
+    return instants
+
+@generate
+def parse_temporalseq():
+    ip = yield spaces >> (string('Interp=Stepwise;') | string('')) << spaces
+    if ip == '':
+        interp = None
+    else:
+        interp = 'Stepwise'
+    lb = yield spaces >> (lbrack | lparen) << spaces
+    lower = True if lb == '[' else False
+    instants = yield sepEndBy1(parse_temporalinst, string(','))
+    ub = yield spaces >> (rbrack | rparen) << spaces
+    upper = True if ub == ']' else False
+    return (instants, lower, upper, interp)
+
+@generate
+def parse_temporalseqset():
+    ip = yield spaces >> string('Interp=Stepwise;') | string('') << spaces
+    if ip == '':
+        interp = None
+    else:
+        interp = 'Stepwise'
+    yield spaces >> lbrace << spaces
+    sequences = yield sepEndBy1(parse_temporalseq, string(','))
+    yield spaces >> rbrace << spaces
+    return (sequences, interp)
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/temporal/temporalinstants.py` & `python-mobilitydb-0.1.3/mobilitydb/temporal/temporalinstants.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,158 +1,158 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from .temporal import Temporal
-
-
-class TemporalInstants(Temporal):
-    """
-    Abstract class for representing temporal values of instant set or
-    sequence subtype.
-    """
-    __slots__ = ['_instantList']
-
-    @property
-    def getValues(self):
-        """
-        List of distinct values taken by the temporal value.
-        """
-        return list(dict.fromkeys([inst._value for inst in self._instantList]))
-
-    @property
-    def startValue(self):
-        """
-        Start value.
-        """
-        return self._instantList[0]._value
-
-    @property
-    def endValue(self):
-        """
-        End value.
-        """
-        return self._instantList[-1]._value
-
-    @property
-    def minValue(self):
-        """
-        Minimum value.
-        """
-        return min(inst._value for inst in self._instantList)
-
-    @property
-    def maxValue(self):
-        """
-        Maximum value.
-        """
-        return max(inst._value for inst in self._instantList)
-
-    @property
-    def numInstants(self):
-        """
-        Number of instants.
-        """
-        return len(self._instantList)
-
-    @property
-    def startInstant(self):
-        """
-        Start instant.
-        """
-        return self._instantList[0]
-
-    @property
-    def endInstant(self):
-        """
-        End instant.
-        """
-        return self._instantList[-1]
-
-    def instantN(self, n):
-        """
-        N-th instant.
-        """
-        # 1-based
-        if 1 <= n <= len(self._instantList):
-            return self._instantList[n - 1]
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def instants(self):
-        """
-        List of instants.
-        """
-        return self._instantList
-
-    @property
-    def numTimestamps(self):
-        """
-        Number of timestamps.
-        """
-        return len(self._instantList)
-
-    @property
-    def startTimestamp(self):
-        """
-        Start timestamp.
-        """
-        return self._instantList[0]._time
-
-    @property
-    def endTimestamp(self):
-        """
-        End timestamp.
-        """
-        return self._instantList[-1]._time
-
-    def timestampN(self, n):
-        """
-        N-th timestamp.
-        """
-        # 1-based
-        if 1 <= n <= len(self._instantList):
-            return self._instantList[n - 1]._time
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def timestamps(self):
-        """
-        List of timestamps.
-        """
-        return [instant._time for instant in self._instantList]
-
-    def shift(self, timedelta):
-        """
-        Shift the temporal value by a time interval.
-        """
-        for inst in self._instantList:
-            inst._time += timedelta
-        return self
-
-    def __str__(self):
-        return "{}".format(', '.join('{}'.format(instant.__str__().replace("'", ""))
-            for instant in self._instantList))
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from .temporal import Temporal
+
+
+class TemporalInstants(Temporal):
+    """
+    Abstract class for representing temporal values of instant set or
+    sequence subtype.
+    """
+    __slots__ = ['_instantList']
+
+    @property
+    def getValues(self):
+        """
+        List of distinct values taken by the temporal value.
+        """
+        return list(dict.fromkeys([inst._value for inst in self._instantList]))
+
+    @property
+    def startValue(self):
+        """
+        Start value.
+        """
+        return self._instantList[0]._value
+
+    @property
+    def endValue(self):
+        """
+        End value.
+        """
+        return self._instantList[-1]._value
+
+    @property
+    def minValue(self):
+        """
+        Minimum value.
+        """
+        return min(inst._value for inst in self._instantList)
+
+    @property
+    def maxValue(self):
+        """
+        Maximum value.
+        """
+        return max(inst._value for inst in self._instantList)
+
+    @property
+    def numInstants(self):
+        """
+        Number of instants.
+        """
+        return len(self._instantList)
+
+    @property
+    def startInstant(self):
+        """
+        Start instant.
+        """
+        return self._instantList[0]
+
+    @property
+    def endInstant(self):
+        """
+        End instant.
+        """
+        return self._instantList[-1]
+
+    def instantN(self, n):
+        """
+        N-th instant.
+        """
+        # 1-based
+        if 1 <= n <= len(self._instantList):
+            return self._instantList[n - 1]
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def instants(self):
+        """
+        List of instants.
+        """
+        return self._instantList
+
+    @property
+    def numTimestamps(self):
+        """
+        Number of timestamps.
+        """
+        return len(self._instantList)
+
+    @property
+    def startTimestamp(self):
+        """
+        Start timestamp.
+        """
+        return self._instantList[0]._time
+
+    @property
+    def endTimestamp(self):
+        """
+        End timestamp.
+        """
+        return self._instantList[-1]._time
+
+    def timestampN(self, n):
+        """
+        N-th timestamp.
+        """
+        # 1-based
+        if 1 <= n <= len(self._instantList):
+            return self._instantList[n - 1]._time
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def timestamps(self):
+        """
+        List of timestamps.
+        """
+        return [instant._time for instant in self._instantList]
+
+    def shift(self, timedelta):
+        """
+        Shift the temporal value by a time interval.
+        """
+        for inst in self._instantList:
+            inst._time += timedelta
+        return self
+
+    def __str__(self):
+        return "{}".format(', '.join('{}'.format(instant.__str__().replace("'", ""))
+            for instant in self._instantList))
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/temporal/tsequenceset.py` & `python-mobilitydb-0.1.3/mobilitydb/temporal/tsequenceset.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,345 +1,345 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from mobilitydb.time import Period, PeriodSet
-from mobilitydb.temporal.temporal import Temporal
-from mobilitydb.temporal.temporal_parser import parse_temporalseqset
-
-
-class TSequenceSet(Temporal):
-    """
-    Abstract class for representing temporal values of sequence set subtype.
-    """
-    __slots__ = ['_sequenceList', '_interp']
-
-    def __init__(self, sequenceList, interp=None):
-        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
-        if isinstance(interp, str) and interp is None:
-            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
-        self._sequenceList = []
-        # Constructor with a single argument of type string
-        if isinstance(sequenceList, str):
-            elements = parse_temporalseqset(sequenceList, 0)
-            seqList = []
-            for seq in elements[2][0]:
-                instList = []
-                for inst in seq[0]:
-                    instList.append(self.ComponentClass.ComponentClass(inst[0], inst[1]))
-                if self.BaseClassDiscrete:
-                    seqList.append(self.ComponentClass(instList, seq[1], seq[2]))
-                else:
-                    seqList.append(self.ComponentClass(instList, seq[1], seq[2], elements[2][1]))
-            self._sequenceList = seqList
-            # Set interpolation with the argument or the flag from the string if given
-            if interp is not None:
-                self._interp = interp
-            else:
-                if self.BaseClassDiscrete:
-                    self._interp = 'Stepwise'
-                else:
-                    self._interp = elements[2][1] if elements[2][1] is not None else 'Linear'
-        # Constructor with a single argument of type list
-        elif isinstance(sequenceList, list):
-            # List of strings representing periods
-            if all(isinstance(sequence, str) for sequence in sequenceList):
-                for sequence in sequenceList:
-                    self._sequenceList.append(self.ComponentClass(sequence))
-            # List of periods
-            elif all(isinstance(sequence, self.ComponentClass) for sequence in sequenceList):
-                for sequence in sequenceList:
-                    self._sequenceList.append(sequence)
-            else:
-                raise Exception("ERROR: Could not parse temporal sequence set value")
-            # Set the interpolation
-            if interp is not None:
-                self._interp = interp
-            else:
-                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
-        else:
-            raise Exception("ERROR: Could not parse temporal sequence set value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        if any(x.endTimestamp >= y.startTimestamp or \
-                       (x.endTimestamp == y.startTimestamp and x.upper_inc and x.lower_inc) \
-               for x, y in zip(self._sequenceList, self._sequenceList[1:])):
-            raise Exception("ERROR: The sequences of a sequence set cannot overlap")
-        if any(x.interpolation != y.interpolation \
-               for x, y in zip(self._sequenceList, self._sequenceList[1:])):
-            raise Exception("ERROR: All sequences of a sequence set must have the same interpolation")
-        return True
-
-    @classmethod
-    def tempSubtype(cls):
-        """
-        Subtype of the temporal value, that is, ``'SequenceSet'``.
-        """
-        return "SequenceSet"
-
-    @property
-    def getValues(self):
-        """
-        List of distinct values taken by the temporal value.
-        """
-        values = [seq.getValues for seq in self._sequenceList]
-        return list(dict.fromkeys([item for sublist in values for item in sublist]))
-
-    @property
-    def startValue(self):
-        """
-        Start value.
-        """
-        return self._sequenceList[0].startInstant._value
-
-    @property
-    def endValue(self):
-        """
-        End value.
-        """
-        return self._sequenceList[-1].endInstant._value
-
-    @property
-    def minValue(self):
-        """
-        Minimum value.
-        """
-        return min(seq.minValue for seq in self._sequenceList)
-
-    @property
-    def maxValue(self):
-        """
-        Maximum value.
-        """
-        return max(seq.maxValue for seq in self._sequenceList)
-
-    def valueAtTimestamp(self, timestamp):
-        """
-        Value at timestamp.
-        """
-        for seq in self._sequenceList:
-            per = seq.period
-            if per.lower > timestamp:
-                return None
-            if per.contains_timestamp(timestamp):
-                return seq.valueAtTimestamp(timestamp)
-        return None
-
-    @property
-    def getTime(self):
-        """
-        Period set on which the temporal value is defined.
-        """
-        return PeriodSet([seq.period for seq in self._sequenceList])
-
-    @property
-    def duration(self):
-        """
-        Interval on which the period set is defined.
-        """
-        result = self._sequenceList[0].period.duration
-        for sequence in self._sequenceList[1:]:
-            result = result + sequence.period.duration
-        return result
-
-    @property
-    def timespan(self):
-        """
-        Interval on which the period set is defined ignoring the potential
-        time gaps.
-        """
-        return self.endTimestamp - self.startTimestamp
-
-    @property
-    def period(self):
-        """
-        Period on which the temporal value is defined ignoring the potential
-        time gaps.
-        """
-        return Period(self.startTimestamp, self.endTimestamp,
-                      self._sequenceList[0]._lower_inc, self._sequenceList[-1]._upper_inc)
-
-    @property
-    def numInstants(self):
-        """
-        Number of distinct instants.
-        """
-        return len(self.instants)
-
-    @property
-    def startInstant(self):
-        """
-        Start instant.
-        """
-        return self._sequenceList[0].startInstant
-
-    @property
-    def endInstant(self):
-        """
-        End instant.
-        """
-        return self._sequenceList[-1].endInstant
-
-    def instantN(self, n):
-        """
-        N-th distinct instant.
-        """
-        # 1-based
-        if 1 <= n <= len(self.instants):
-            return (self.instants)[n - 1]
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def instants(self):
-        """
-        List of instants.
-        """
-        instantList = []
-        for sequence in self._sequenceList:
-            for instant in sequence._instantList:
-                instantList.append(instant)
-        return instantList
-
-    @property
-    def numTimestamps(self):
-        """
-        Number of distinct timestamps.
-        """
-        return len(self.timestamps)
-
-    @property
-    def startTimestamp(self):
-        """
-        Start timestamp.
-        """
-        return self._sequenceList[0].startInstant.getTimestamp
-
-    @property
-    def endTimestamp(self):
-        """
-        End timestamp.
-        """
-        return self._sequenceList[-1].endInstant.getTimestamp
-
-    def timestampN(self, n):
-        """
-        N-th distinct timestamp.
-        """
-        # 1-based
-        if 1 <= n <= len(self.timestamps):
-            return (self.timestamps)[n - 1]
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def timestamps(self):
-        """
-        List of timestamps.
-        """
-        timestampList = []
-        for sequence in self._sequenceList:
-            for instant in sequence._instantList:
-                timestampList.append(instant.getTimestamp)
-        # Remove duplicates
-        timestampList = list(dict.fromkeys(timestampList))
-        return timestampList
-
-    @property
-    def numSequences(self):
-        """
-        Number of sequences.
-        """
-        return len(self._sequenceList)
-
-    @property
-    def startSequence(self):
-        """
-        Start sequence.
-        """
-        return self._sequenceList[0]
-
-    @property
-    def endSequence(self):
-        """
-        End sequence.
-        """
-        return self._sequenceList[-1]
-
-    def sequenceN(self, n):
-        """
-        N-th sequence.
-        """
-        # 1-based
-        if 1 <= n <= len(self._sequenceList):
-            return self._sequenceList[n - 1]
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def sequences(self):
-        """
-        List of sequences.
-        """
-        return self._sequenceList
-
-    def shift(self, timedelta):
-        """
-        Shift the temporal value by a time interval.
-        """
-        for seq in self._sequenceList:
-            seq = seq.shift(timedelta)
-        return self
-
-    def intersectsTimestamp(self, timestamp):
-        """
-        Does the temporal value intersect the timestamp?
-        """
-        return any(seq.intersectsTimestamp(timestamp) for seq in self._sequenceList)
-
-    def intersectsPeriod(self, period):
-        """
-        Does the temporal value intersect the period?
-        """
-        return any(seq.intersectsPeriod(period) for seq in self._sequenceList)
-
-    # Comparisons are missing
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            if self._sequenceList == other._sequenceList and self._interp == other._interp:
-                return True
-        return False
-
-    def __str__(self):
-        interp_str = 'Interp=Stepwise;' if self._interp == 'Stepwise' and self.__class__.BaseClassDiscrete == False else ''
-        seqList_str = "{{{}}}".format(
-            ', '.join('{}'.format(sequence.__str__().replace("'", "").replace("Interp=Stepwise;", ""))
-                      for sequence in self._sequenceList))
-        return f"'{interp_str}{seqList_str}'"
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
-                f'({self._sequenceList!r}, {self._interp!r})')
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from mobilitydb.time import Period, PeriodSet
+from mobilitydb.temporal.temporal import Temporal
+from mobilitydb.temporal.temporal_parser import parse_temporalseqset
+
+
+class TSequenceSet(Temporal):
+    """
+    Abstract class for representing temporal values of sequence set subtype.
+    """
+    __slots__ = ['_sequenceList', '_interp']
+
+    def __init__(self, sequenceList, interp=None):
+        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
+        if isinstance(interp, str) and interp is None:
+            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
+        self._sequenceList = []
+        # Constructor with a single argument of type string
+        if isinstance(sequenceList, str):
+            elements = parse_temporalseqset(sequenceList, 0)
+            seqList = []
+            for seq in elements[2][0]:
+                instList = []
+                for inst in seq[0]:
+                    instList.append(self.ComponentClass.ComponentClass(inst[0], inst[1]))
+                if self.BaseClassDiscrete:
+                    seqList.append(self.ComponentClass(instList, seq[1], seq[2]))
+                else:
+                    seqList.append(self.ComponentClass(instList, seq[1], seq[2], elements[2][1]))
+            self._sequenceList = seqList
+            # Set interpolation with the argument or the flag from the string if given
+            if interp is not None:
+                self._interp = interp
+            else:
+                if self.BaseClassDiscrete:
+                    self._interp = 'Stepwise'
+                else:
+                    self._interp = elements[2][1] if elements[2][1] is not None else 'Linear'
+        # Constructor with a single argument of type list
+        elif isinstance(sequenceList, list):
+            # List of strings representing periods
+            if all(isinstance(sequence, str) for sequence in sequenceList):
+                for sequence in sequenceList:
+                    self._sequenceList.append(self.ComponentClass(sequence))
+            # List of periods
+            elif all(isinstance(sequence, self.ComponentClass) for sequence in sequenceList):
+                for sequence in sequenceList:
+                    self._sequenceList.append(sequence)
+            else:
+                raise Exception("ERROR: Could not parse temporal sequence set value")
+            # Set the interpolation
+            if interp is not None:
+                self._interp = interp
+            else:
+                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
+        else:
+            raise Exception("ERROR: Could not parse temporal sequence set value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        if any(x.endTimestamp >= y.startTimestamp or \
+                       (x.endTimestamp == y.startTimestamp and x.upper_inc and x.lower_inc) \
+               for x, y in zip(self._sequenceList, self._sequenceList[1:])):
+            raise Exception("ERROR: The sequences of a sequence set cannot overlap")
+        if any(x.interpolation != y.interpolation \
+               for x, y in zip(self._sequenceList, self._sequenceList[1:])):
+            raise Exception("ERROR: All sequences of a sequence set must have the same interpolation")
+        return True
+
+    @classmethod
+    def tempSubtype(cls):
+        """
+        Subtype of the temporal value, that is, ``'SequenceSet'``.
+        """
+        return "SequenceSet"
+
+    @property
+    def getValues(self):
+        """
+        List of distinct values taken by the temporal value.
+        """
+        values = [seq.getValues for seq in self._sequenceList]
+        return list(dict.fromkeys([item for sublist in values for item in sublist]))
+
+    @property
+    def startValue(self):
+        """
+        Start value.
+        """
+        return self._sequenceList[0].startInstant._value
+
+    @property
+    def endValue(self):
+        """
+        End value.
+        """
+        return self._sequenceList[-1].endInstant._value
+
+    @property
+    def minValue(self):
+        """
+        Minimum value.
+        """
+        return min(seq.minValue for seq in self._sequenceList)
+
+    @property
+    def maxValue(self):
+        """
+        Maximum value.
+        """
+        return max(seq.maxValue for seq in self._sequenceList)
+
+    def valueAtTimestamp(self, timestamp):
+        """
+        Value at timestamp.
+        """
+        for seq in self._sequenceList:
+            per = seq.period
+            if per.lower > timestamp:
+                return None
+            if per.contains_timestamp(timestamp):
+                return seq.valueAtTimestamp(timestamp)
+        return None
+
+    @property
+    def getTime(self):
+        """
+        Period set on which the temporal value is defined.
+        """
+        return PeriodSet([seq.period for seq in self._sequenceList])
+
+    @property
+    def duration(self):
+        """
+        Interval on which the period set is defined.
+        """
+        result = self._sequenceList[0].period.duration
+        for sequence in self._sequenceList[1:]:
+            result = result + sequence.period.duration
+        return result
+
+    @property
+    def timespan(self):
+        """
+        Interval on which the period set is defined ignoring the potential
+        time gaps.
+        """
+        return self.endTimestamp - self.startTimestamp
+
+    @property
+    def period(self):
+        """
+        Period on which the temporal value is defined ignoring the potential
+        time gaps.
+        """
+        return Period(self.startTimestamp, self.endTimestamp,
+                      self._sequenceList[0]._lower_inc, self._sequenceList[-1]._upper_inc)
+
+    @property
+    def numInstants(self):
+        """
+        Number of distinct instants.
+        """
+        return len(self.instants)
+
+    @property
+    def startInstant(self):
+        """
+        Start instant.
+        """
+        return self._sequenceList[0].startInstant
+
+    @property
+    def endInstant(self):
+        """
+        End instant.
+        """
+        return self._sequenceList[-1].endInstant
+
+    def instantN(self, n):
+        """
+        N-th distinct instant.
+        """
+        # 1-based
+        if 1 <= n <= len(self.instants):
+            return (self.instants)[n - 1]
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def instants(self):
+        """
+        List of instants.
+        """
+        instantList = []
+        for sequence in self._sequenceList:
+            for instant in sequence._instantList:
+                instantList.append(instant)
+        return instantList
+
+    @property
+    def numTimestamps(self):
+        """
+        Number of distinct timestamps.
+        """
+        return len(self.timestamps)
+
+    @property
+    def startTimestamp(self):
+        """
+        Start timestamp.
+        """
+        return self._sequenceList[0].startInstant.getTimestamp
+
+    @property
+    def endTimestamp(self):
+        """
+        End timestamp.
+        """
+        return self._sequenceList[-1].endInstant.getTimestamp
+
+    def timestampN(self, n):
+        """
+        N-th distinct timestamp.
+        """
+        # 1-based
+        if 1 <= n <= len(self.timestamps):
+            return (self.timestamps)[n - 1]
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def timestamps(self):
+        """
+        List of timestamps.
+        """
+        timestampList = []
+        for sequence in self._sequenceList:
+            for instant in sequence._instantList:
+                timestampList.append(instant.getTimestamp)
+        # Remove duplicates
+        timestampList = list(dict.fromkeys(timestampList))
+        return timestampList
+
+    @property
+    def numSequences(self):
+        """
+        Number of sequences.
+        """
+        return len(self._sequenceList)
+
+    @property
+    def startSequence(self):
+        """
+        Start sequence.
+        """
+        return self._sequenceList[0]
+
+    @property
+    def endSequence(self):
+        """
+        End sequence.
+        """
+        return self._sequenceList[-1]
+
+    def sequenceN(self, n):
+        """
+        N-th sequence.
+        """
+        # 1-based
+        if 1 <= n <= len(self._sequenceList):
+            return self._sequenceList[n - 1]
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def sequences(self):
+        """
+        List of sequences.
+        """
+        return self._sequenceList
+
+    def shift(self, timedelta):
+        """
+        Shift the temporal value by a time interval.
+        """
+        for seq in self._sequenceList:
+            seq = seq.shift(timedelta)
+        return self
+
+    def intersectsTimestamp(self, timestamp):
+        """
+        Does the temporal value intersect the timestamp?
+        """
+        return any(seq.intersectsTimestamp(timestamp) for seq in self._sequenceList)
+
+    def intersectsPeriod(self, period):
+        """
+        Does the temporal value intersect the period?
+        """
+        return any(seq.intersectsPeriod(period) for seq in self._sequenceList)
+
+    # Comparisons are missing
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            if self._sequenceList == other._sequenceList and self._interp == other._interp:
+                return True
+        return False
+
+    def __str__(self):
+        interp_str = 'Interp=Stepwise;' if self._interp == 'Stepwise' and self.__class__.BaseClassDiscrete == False else ''
+        seqList_str = "{{{}}}".format(
+            ', '.join('{}'.format(sequence.__str__().replace("'", "").replace("Interp=Stepwise;", ""))
+                      for sequence in self._sequenceList))
+        return f"'{interp_str}{seqList_str}'"
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
+                f'({self._sequenceList!r}, {self._interp!r})')
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/time/timestampset.py` & `python-mobilitydb-0.1.3/mobilitydb/time/timestampset.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,196 +1,196 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from .period import Period
-import warnings
-
-try:
-    # Do not make psycopg2 a requirement.
-    from psycopg2.extensions import ISQLQuote
-except ImportError:
-    warnings.warn('psycopg2 not installed', ImportWarning)
-
-
-class TimestampSet:
-    """
-    Class for representing lists of distinct timestamp values.
-
-    ``TimestampSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TimestampSet('{2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01, 2019-09-11 00:00:00+01}')
-
-    Another possibility is to give a tuple or list of composing timestamps,
-    which can be instances of ``str`` or ``datetime``. The composing timestamps
-    must be given in increasing order.
-
-        >>> TimestampSet(['2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'])
-        >>> TimestampSet([parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')])
-        >>> TimestampSet('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01')
-        >>> TimestampSet(parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01'))
-
-    """
-
-    __slots__ = ['_datetimeList']
-
-    def __init__(self, *argv):
-        # Constructor with a single argument of type string
-        self._datetimeList = []
-        if len(argv) == 1 and isinstance(argv[0], str):
-            ts = argv[0].strip()
-            if ts[0] == '{' and ts[-1] == '}':
-                ts = ts[1:-1]
-                times = ts.split(",")
-                for time in times:
-                    self._datetimeList.append(parse(time.strip()))
-            else:
-                raise Exception("ERROR: Could not parse timestamp set value")
-        # Constructor with a single argument of type list
-        elif len(argv) == 1 and isinstance(argv[0], list):
-            # List of strings representing datetime values
-            if all(isinstance(arg, str) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._datetimeList.append(parse(arg))
-            # List of datetimes
-            elif all(isinstance(arg, datetime) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._datetimeList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse timestamp set value")
-        # Constructor with multiple arguments
-        else:
-            # Arguments are of type string
-            if all(isinstance(arg, str) for arg in argv):
-                for arg in argv:
-                    self._datetimeList.append(parse(arg))
-            # Arguments are of type datetime
-            elif all(isinstance(arg, datetime) for arg in argv):
-                for arg in argv:
-                    self._datetimeList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse timestamp set value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        if any(x >= y for x, y in zip(self._datetimeList, self._datetimeList[1:])):
-            raise Exception("ERROR: The timestamps of a timestamp set must be increasing")
-
-    @property
-    def timespan(self):
-        """
-        Interval on which the timestamp set is defined ignoring the potential time gaps
-        """
-        return self._datetimeList[-1] - self._datetimeList[0]
-
-    @property
-    def period(self):
-        """
-        Period on which the timestamp set is defined ignoring the potential time gaps
-        """
-        return Period(self._datetimeList[0], self._datetimeList[-1], True, True)
-
-    @property
-    def numTimestamps(self):
-        """
-        Number of timestamps
-        """
-        return len(self._datetimeList)
-
-    @property
-    def startTimestamp(self):
-        """
-        Start timestamp
-        """
-        return self._datetimeList[0]
-
-    @property
-    def endTimestamp(self):
-        """
-        End timestamp
-        """
-        return self._datetimeList[-1]
-
-    def timestampN(self, n):
-        """
-        N-th timestamp
-        """
-        # 1-based
-        if 0 < n <= len(self._datetimeList):
-            return self._datetimeList[n - 1]
-        else:
-            raise Exception("ERROR: there is no value at this index")
-
-    @property
-    def timestamps(self):
-        """
-        Distinct timestamps
-        """
-        return self._datetimeList
-
-    def shift(self, timedelta):
-        """
-        Shift the timestamp set by a time interval
-        """
-        return TimestampSet([datetime + timedelta for datetime in self._datetimeList])
-
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            if (len(other._datetimeList) == len(self._datetimeList) and
-                other._datetimeList == self._datetimeList):
-                return True
-        return False
-
-    # Psycopg2 interface.
-    def __conform__(self, protocol):
-        if protocol is ISQLQuote:
-            return self
-
-    def getquoted(self):
-        return "{}".format(self.__str__())
-    # End Psycopg2 interface.
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        return TimestampSet(value)
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, TimestampSet):
-            raise ValueError('Value must be an instance of TimestampSet class')
-        return value.__str__().strip("'")
-
-    def __str__(self):
-        return "'{{{}}}'".format(', '.join('{}'.format(datetime.__str__())
-            for datetime in self._datetimeList))
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from .period import Period
+import warnings
+
+try:
+    # Do not make psycopg2 a requirement.
+    from psycopg2.extensions import ISQLQuote
+except ImportError:
+    warnings.warn('psycopg2 not installed', ImportWarning)
+
+
+class TimestampSet:
+    """
+    Class for representing lists of distinct timestamp values.
+
+    ``TimestampSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TimestampSet('{2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01, 2019-09-11 00:00:00+01}')
+
+    Another possibility is to give a tuple or list of composing timestamps,
+    which can be instances of ``str`` or ``datetime``. The composing timestamps
+    must be given in increasing order.
+
+        >>> TimestampSet(['2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01'])
+        >>> TimestampSet([parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01')])
+        >>> TimestampSet('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', '2019-09-11 00:00:00+01')
+        >>> TimestampSet(parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), parse('2019-09-11 00:00:00+01'))
+
+    """
+
+    __slots__ = ['_datetimeList']
+
+    def __init__(self, *argv):
+        # Constructor with a single argument of type string
+        self._datetimeList = []
+        if len(argv) == 1 and isinstance(argv[0], str):
+            ts = argv[0].strip()
+            if ts[0] == '{' and ts[-1] == '}':
+                ts = ts[1:-1]
+                times = ts.split(",")
+                for time in times:
+                    self._datetimeList.append(parse(time.strip()))
+            else:
+                raise Exception("ERROR: Could not parse timestamp set value")
+        # Constructor with a single argument of type list
+        elif len(argv) == 1 and isinstance(argv[0], list):
+            # List of strings representing datetime values
+            if all(isinstance(arg, str) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._datetimeList.append(parse(arg))
+            # List of datetimes
+            elif all(isinstance(arg, datetime) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._datetimeList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse timestamp set value")
+        # Constructor with multiple arguments
+        else:
+            # Arguments are of type string
+            if all(isinstance(arg, str) for arg in argv):
+                for arg in argv:
+                    self._datetimeList.append(parse(arg))
+            # Arguments are of type datetime
+            elif all(isinstance(arg, datetime) for arg in argv):
+                for arg in argv:
+                    self._datetimeList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse timestamp set value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        if any(x >= y for x, y in zip(self._datetimeList, self._datetimeList[1:])):
+            raise Exception("ERROR: The timestamps of a timestamp set must be increasing")
+
+    @property
+    def timespan(self):
+        """
+        Interval on which the timestamp set is defined ignoring the potential time gaps
+        """
+        return self._datetimeList[-1] - self._datetimeList[0]
+
+    @property
+    def period(self):
+        """
+        Period on which the timestamp set is defined ignoring the potential time gaps
+        """
+        return Period(self._datetimeList[0], self._datetimeList[-1], True, True)
+
+    @property
+    def numTimestamps(self):
+        """
+        Number of timestamps
+        """
+        return len(self._datetimeList)
+
+    @property
+    def startTimestamp(self):
+        """
+        Start timestamp
+        """
+        return self._datetimeList[0]
+
+    @property
+    def endTimestamp(self):
+        """
+        End timestamp
+        """
+        return self._datetimeList[-1]
+
+    def timestampN(self, n):
+        """
+        N-th timestamp
+        """
+        # 1-based
+        if 0 < n <= len(self._datetimeList):
+            return self._datetimeList[n - 1]
+        else:
+            raise Exception("ERROR: there is no value at this index")
+
+    @property
+    def timestamps(self):
+        """
+        Distinct timestamps
+        """
+        return self._datetimeList
+
+    def shift(self, timedelta):
+        """
+        Shift the timestamp set by a time interval
+        """
+        return TimestampSet([datetime + timedelta for datetime in self._datetimeList])
+
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            if (len(other._datetimeList) == len(self._datetimeList) and
+                other._datetimeList == self._datetimeList):
+                return True
+        return False
+
+    # Psycopg2 interface.
+    def __conform__(self, protocol):
+        if protocol is ISQLQuote:
+            return self
+
+    def getquoted(self):
+        return "{}".format(self.__str__())
+    # End Psycopg2 interface.
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        return TimestampSet(value)
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, TimestampSet):
+            raise ValueError('Value must be an instance of TimestampSet class')
+        return value.__str__().strip("'")
+
+    def __str__(self):
+        return "'{{{}}}'".format(', '.join('{}'.format(datetime.__str__())
+            for datetime in self._datetimeList))
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
                 f'({self._datetimeList!r})')
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/time/periodset.py` & `python-mobilitydb-0.1.3/mobilitydb/time/periodset.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,253 +1,253 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import re
-from .period import Period
-import warnings
-
-try:
-    # Do not make psycopg2 a requirement.
-    from psycopg2.extensions import ISQLQuote
-except ImportError:
-    warnings.warn('psycopg2 not installed', ImportWarning)
-
-
-class PeriodSet:
-    """
-    Class for representing lists of disjoint periods.
-
-    ``PeriodSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> PeriodSet('{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01], [2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]}')
-
-    Another possibility is to give a list or tuple specifying the composing
-    periods, which can be instances  of ``str`` or ``Period``. The composing
-    periods must be given in increasing order.
-
-        >>> PeriodSet(['[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'])
-        >>> PeriodSet([Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'), Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')])
-        >>> PeriodSet('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')
-        >>> PeriodSet(Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'), Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'))
-
-    """
-
-    __slots__ = ['_periodList']
-
-    def __init__(self, *argv):
-        self._periodList = []
-        # Constructor with a single argument of type string
-        if len(argv) == 1 and isinstance(argv[0], str):
-            ps = argv[0].strip()
-            if ps[0] == '{' and ps[-1] == '}':
-                p = re.compile(r'[\[|\(].*?[^\]\)][\]|\)]')
-                periods = p.findall(ps)
-                for period in periods:
-                    self._periodList.append(Period(period))
-            else:
-                raise Exception("ERROR: Could not parse period set value")
-        # Constructor with a single argument of type list
-        elif len(argv) == 1 and isinstance(argv[0], list):
-            # List of strings representing periods
-            if all(isinstance(arg, str) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._periodList.append(Period(arg))
-            # List of periods
-            elif all(isinstance(arg, Period) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._periodList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse period set value")
-        # Constructor with multiple arguments
-        else:
-            # Arguments are of type string
-            if all(isinstance(arg, str) for arg in argv):
-                for arg in argv:
-                    self._periodList.append(Period(arg))
-            # Arguments are of type period
-            elif all(isinstance(arg, Period) for arg in argv):
-                for arg in argv:
-                    self._periodList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse period set value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        if any(x.upper > y.lower or \
-            (x.upper == y.lower and x.upper_inc and x.lower_inc) \
-                   for x, y in zip(self._periodList, self._periodList[1:])):
-            raise Exception("ERROR: The periods of a period set cannot overlap")
-        return True
-
-    @property
-    def duration(self):
-        """
-        Time interval on which the period set is defined
-        """
-        result = self._periodList[0].duration
-        for period in self._periodList[1:]:
-            result = result + period.duration
-        return result
-
-    @property
-    def timespan(self):
-        """
-        Time interval on which the period set is defined
-        """
-        return self.endTimestamp - self.startTimestamp
-
-
-    @property
-    def period(self):
-        """
-        Period on which the period set is defined ignoring the potential time gaps
-        """
-        return Period((self._periodList[0]).lower, (self._periodList[-1]).upper,
-                      self._periodList[0].lower_inc, self._periodList[-1].upper_inc)
-
-    @property
-    def numTimestamps(self):
-        """
-        Number of distinct timestamps
-        """
-        return len(self.timestamps)
-
-    @property
-    def startTimestamp(self):
-        """
-        Start timestamp
-        """
-        return self._periodList[0].lower
-
-    @property
-    def endTimestamp(self):
-        """
-        End timestamp
-        """
-        return self._periodList[-1].upper
-
-    def timestampN(self, n):
-        """
-        N-th distinct timestamp
-        """
-        # 1-based
-        if 1 <= n <= len(self.timestamps):
-            return (self.timestamps)[n - 1]
-        else:
-            raise Exception("ERROR: there is no value at this index")
-
-    @property
-    def timestamps(self):
-        """
-        Distinct timestamps
-        """
-        timestampList = []
-        for period in self._periodList:
-            timestampList.append(period.lower)
-            timestampList.append(period.upper)
-        # Remove duplicates
-        return list(dict.fromkeys(timestampList))
-
-    @property
-    def numPeriods(self):
-        """
-        Number of periods
-        """
-        return len(self._periodList)
-
-    @property
-    def startPeriod(self):
-        """
-        Start period
-        """
-        return self._periodList[0]
-
-    @property
-    def endPeriod(self):
-        """
-        End period
-        """
-        return self._periodList[self.numPeriods - 1]
-
-    def periodN(self, n):
-        """
-        N-th period
-        """
-        # 1-based
-        if 1 <= n <= len(self._periodList):
-            return self._periodList[n - 1]
-        else:
-            raise Exception("ERROR: Out of range")
-
-    @property
-    def periods(self):
-        """
-        Periods
-        """
-        return self._periodList
-
-    def shift(self, timedelta):
-        """
-        Shift the period set by a time interval
-        """
-        return PeriodSet([period.shift(timedelta) for period in self._periodList])
-
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            if (len(other._periodList) == len(self._periodList) and
-                other._periodList == self._periodList):
-                return True
-        return False
-
-    # Psycopg2 interface.
-    def __conform__(self, protocol):
-        if protocol is ISQLQuote:
-            return self
-
-    def getquoted(self):
-        return "{}".format(self.__str__())
-    # End Psycopg2 interface.
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        return PeriodSet(value)
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, PeriodSet):
-            raise ValueError('Value must be an instance of PeriodSet class')
-        return value.__str__().strip("'")
-
-    def __str__(self):
-        return "'{{{}}}'".format(', '.join('{}'.format(period.__str__().replace("'", ""))
-            for period in self._periodList))
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import re
+from .period import Period
+import warnings
+
+try:
+    # Do not make psycopg2 a requirement.
+    from psycopg2.extensions import ISQLQuote
+except ImportError:
+    warnings.warn('psycopg2 not installed', ImportWarning)
+
+
+class PeriodSet:
+    """
+    Class for representing lists of disjoint periods.
+
+    ``PeriodSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> PeriodSet('{[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01], [2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]}')
+
+    Another possibility is to give a list or tuple specifying the composing
+    periods, which can be instances  of ``str`` or ``Period``. The composing
+    periods must be given in increasing order.
+
+        >>> PeriodSet(['[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'])
+        >>> PeriodSet([Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'), Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')])
+        >>> PeriodSet('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]', '[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]')
+        >>> PeriodSet(Period('[2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01]'), Period('[2019-09-11 00:00:00+01, 2019-09-12 00:00:00+01]'))
+
+    """
+
+    __slots__ = ['_periodList']
+
+    def __init__(self, *argv):
+        self._periodList = []
+        # Constructor with a single argument of type string
+        if len(argv) == 1 and isinstance(argv[0], str):
+            ps = argv[0].strip()
+            if ps[0] == '{' and ps[-1] == '}':
+                p = re.compile(r'[\[|\(].*?[^\]\)][\]|\)]')
+                periods = p.findall(ps)
+                for period in periods:
+                    self._periodList.append(Period(period))
+            else:
+                raise Exception("ERROR: Could not parse period set value")
+        # Constructor with a single argument of type list
+        elif len(argv) == 1 and isinstance(argv[0], list):
+            # List of strings representing periods
+            if all(isinstance(arg, str) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._periodList.append(Period(arg))
+            # List of periods
+            elif all(isinstance(arg, Period) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._periodList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse period set value")
+        # Constructor with multiple arguments
+        else:
+            # Arguments are of type string
+            if all(isinstance(arg, str) for arg in argv):
+                for arg in argv:
+                    self._periodList.append(Period(arg))
+            # Arguments are of type period
+            elif all(isinstance(arg, Period) for arg in argv):
+                for arg in argv:
+                    self._periodList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse period set value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        if any(x.upper > y.lower or \
+            (x.upper == y.lower and x.upper_inc and x.lower_inc) \
+                   for x, y in zip(self._periodList, self._periodList[1:])):
+            raise Exception("ERROR: The periods of a period set cannot overlap")
+        return True
+
+    @property
+    def duration(self):
+        """
+        Time interval on which the period set is defined
+        """
+        result = self._periodList[0].duration
+        for period in self._periodList[1:]:
+            result = result + period.duration
+        return result
+
+    @property
+    def timespan(self):
+        """
+        Time interval on which the period set is defined
+        """
+        return self.endTimestamp - self.startTimestamp
+
+
+    @property
+    def period(self):
+        """
+        Period on which the period set is defined ignoring the potential time gaps
+        """
+        return Period((self._periodList[0]).lower, (self._periodList[-1]).upper,
+                      self._periodList[0].lower_inc, self._periodList[-1].upper_inc)
+
+    @property
+    def numTimestamps(self):
+        """
+        Number of distinct timestamps
+        """
+        return len(self.timestamps)
+
+    @property
+    def startTimestamp(self):
+        """
+        Start timestamp
+        """
+        return self._periodList[0].lower
+
+    @property
+    def endTimestamp(self):
+        """
+        End timestamp
+        """
+        return self._periodList[-1].upper
+
+    def timestampN(self, n):
+        """
+        N-th distinct timestamp
+        """
+        # 1-based
+        if 1 <= n <= len(self.timestamps):
+            return (self.timestamps)[n - 1]
+        else:
+            raise Exception("ERROR: there is no value at this index")
+
+    @property
+    def timestamps(self):
+        """
+        Distinct timestamps
+        """
+        timestampList = []
+        for period in self._periodList:
+            timestampList.append(period.lower)
+            timestampList.append(period.upper)
+        # Remove duplicates
+        return list(dict.fromkeys(timestampList))
+
+    @property
+    def numPeriods(self):
+        """
+        Number of periods
+        """
+        return len(self._periodList)
+
+    @property
+    def startPeriod(self):
+        """
+        Start period
+        """
+        return self._periodList[0]
+
+    @property
+    def endPeriod(self):
+        """
+        End period
+        """
+        return self._periodList[self.numPeriods - 1]
+
+    def periodN(self, n):
+        """
+        N-th period
+        """
+        # 1-based
+        if 1 <= n <= len(self._periodList):
+            return self._periodList[n - 1]
+        else:
+            raise Exception("ERROR: Out of range")
+
+    @property
+    def periods(self):
+        """
+        Periods
+        """
+        return self._periodList
+
+    def shift(self, timedelta):
+        """
+        Shift the period set by a time interval
+        """
+        return PeriodSet([period.shift(timedelta) for period in self._periodList])
+
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            if (len(other._periodList) == len(self._periodList) and
+                other._periodList == self._periodList):
+                return True
+        return False
+
+    # Psycopg2 interface.
+    def __conform__(self, protocol):
+        if protocol is ISQLQuote:
+            return self
+
+    def getquoted(self):
+        return "{}".format(self.__str__())
+    # End Psycopg2 interface.
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        return PeriodSet(value)
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, PeriodSet):
+            raise ValueError('Value must be an instance of PeriodSet class')
+        return value.__str__().strip("'")
+
+    def __str__(self):
+        return "'{{{}}}'".format(', '.join('{}'.format(period.__str__().replace("'", ""))
+            for period in self._periodList))
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
                 f'({self._periodList!r})')
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/time/period.py` & `python-mobilitydb-0.1.3/mobilitydb/time/period.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,281 +1,281 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import datetime
-from dateutil.parser import parse
-import warnings
-
-try:
-    # Do not make psycopg2 a requirement.
-    from psycopg2.extensions import ISQLQuote
-except ImportError:
-    warnings.warn('psycopg2 not installed', ImportWarning)
-
-
-class Period:
-    """
-    Class for representing sets of contiguous timestamps between a lower and
-    an upper bound. The bounds may be inclusive or not.
-
-    ``Period`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> Period('(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)')
-
-    Another possibility is to give a tuple of arguments as follows:
-
-    * ``lower`` and ``upper`` are instances of ``str`` or ``datetime``
-      specifying the bounds,
-    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
-      whether the bounds are inclusive or not. By default, ``lower_inc``
-      is ``True`` and ``upper_inc`` is ``False``.
-
-    Some examples are given next.
-
-        >>> Period('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01')
-        >>> Period('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', False, True)
-        >>> Period(parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'))
-        >>> Period(parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), False, True)
-
-    """
-
-    __slots__ = ['_lower', '_upper', '_lower_inc', '_upper_inc']
-
-    def __init__(self, lower, upper=None, lower_inc=None, upper_inc=None):
-        assert(isinstance(lower_inc, (bool, type(None)))), "ERROR: Invalid lower bound flag"
-        assert(isinstance(upper_inc, (bool, type(None)))), "ERROR: Invalid upper bound flag"
-        # Constructor with a single argument of type string
-        if upper is None and isinstance(lower, str):
-            lower = lower.strip()
-            assert(lower[0] == '[' or lower[0] == '('), "Lower bound flag must be either '[' or '('"
-            assert(lower[-1] == ']' or lower[-1] == ')'), "Upper bound flag must be either ']' or ')'"
-            self._lower_inc = True if lower[0] == '[' else False
-            self._upper_inc = True if lower[-1] == ']' else False
-            bounds = lower[1:-1].split(',')
-            self._lower = parse(bounds[0])
-            self._upper = parse(bounds[1])
-        # Constructor with two arguments of type string and optional arguments for the bounds
-        elif isinstance(lower, str) and isinstance(upper, str):
-            self._lower = parse(lower)
-            self._upper = parse(upper)
-            self._lower_inc = lower_inc if lower_inc is not None else True
-            self._upper_inc = upper_inc if upper_inc is not None else False
-        # Constructor with two arguments of type datetime and optional arguments for the bounds
-        elif isinstance(lower, datetime.datetime) and isinstance(upper, datetime.datetime):
-            self._lower = lower
-            self._upper = upper
-            self._lower_inc = lower_inc if lower_inc is not None else True
-            self._upper_inc = upper_inc if upper_inc is not None else False
-        else:
-            raise Exception("ERROR: Could not parse period value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        if self._lower > self._upper:
-            raise Exception("ERROR: The lower bound must be less than or equal to the upper bound")
-        if (self._lower == self._upper and
-            (self._lower_inc == False or self._upper_inc == False)):
-            raise Exception("ERROR: The lower and upper bounds must be inclusive for an instant period")
-        return True
-
-    @property
-    def lower(self):
-        """
-        Lower bound
-        """
-        return self._lower
-
-    @property
-    def upper(self):
-        """
-        Upper bound
-        """
-        return self._upper
-
-    @property
-    def lower_inc(self):
-        """
-        Is the lower bound inclusive?
-        """
-        return self._lower_inc
-
-    @property
-    def upper_inc(self):
-        """
-        Is the upper bound inclusive?
-        """
-        return self._upper_inc
-
-    @property
-    def duration(self):
-        """
-        Time interval on which the period is defined
-        """
-        return self._upper - self._lower
-
-    def shift(self, timedelta):
-        """
-        Shift the period by a time interval
-        """
-        return Period(self._lower + timedelta, self._upper + timedelta,
-                      self._lower_inc, self._upper_inc)
-
-    @staticmethod
-    def _cmp_boundSeqSet(t1, t2, lower1, lower2, inclusive1, inclusive2):
-        # Compare the values
-        if t1 < t2:
-            return -1
-        elif t1 > t2:
-            return 1
-        """
-        If the comparison is not equal and the bounds are both inclusive or 
-        both exclusive, we're done. If they compare equal, we still have to 
-        consider whether the boundaries are inclusive or exclusive. 
-        """
-        if not inclusive1 and not inclusive2:
-            # both are exclusive
-            if lower1 == lower2:
-                return 0
-            else:
-                if lower1:
-                    return 1
-                else:
-                    return -1
-        elif not inclusive1:
-            if lower1:
-                return 1
-            else:
-                return -1
-        elif not inclusive2:
-            if lower2:
-                return -1
-            else:
-                return 1
-        else:
-            return 0
-
-    def overlap(self, other):
-        """
-        Do the periods share a timestamp?
-        """
-        if ((self._cmp_boundSeqSet(self._lower, other._lower, True, True, self._lower_inc, other._lower_inc) >= 0 and
-                     self._cmp_boundSeqSet(self._lower, other._upper, True, False, self._lower_inc, other._upper_inc) <= 0) or
-            (self._cmp_boundSeqSet(other._lower, self._lower, True, True, other._lower_inc, self._lower_inc) >= 0 and
-                     self._cmp_boundSeqSet(other._lower, self._upper, True, False, other._lower_inc, self._upper_inc) <= 0)):
-            return True
-        return False
-
-    def contains_timestamp(self, datetime):
-        """
-        Does the period contain the timestamp?
-        """
-        if ((self._lower < datetime < self._upper) or
-            (self._lower_inc and self._lower == datetime) or
-            (self._upper_inc and self._upper == datetime)):
-            return True
-        return False
-
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            if (self._lower == other._lower and self._upper == other._upper and
-                self._lower_inc == other._lower_inc and self._upper_inc == other._upper_inc):
-                return True
-        return False
-
-    def _cmp(self, other):
-        if isinstance(other, self.__class__):
-            if self._lower < other._lower:
-                return -1
-            elif self._lower > other._lower:
-                return 1
-            elif self._upper < other._upper:
-                return -1
-            elif self._upper > other._upper:
-                return 1
-            elif self._lower_inc and not other._lower_inc:
-                return -1
-            elif not self._lower_inc and other._lower_inc:
-                return 1
-            elif self._upper_inc and not other._upper_inc:
-                return -1
-            elif not self._upper_inc and other._upper_inc:
-                return 1
-        return 0
-
-    def __lt__(self, other):
-        if isinstance(other, self.__class__):
-            if self._cmp(other) == -1:
-                return True
-        return False
-
-    def __le__(self, other):
-        if isinstance(other, self.__class__):
-            if self._cmp(other) == -1 or self._cmp(other) == 0:
-                return True
-        return False
-
-    def __gt__(self, other):
-        if isinstance(other, self.__class__):
-            if self._cmp(other) == 1:
-                return True
-        return False
-
-    def __ge__(self, other):
-        if isinstance(other, self.__class__):
-            if self._cmp(other) == 1 or self._cmp(other) == 0:
-                return True
-        return False
-
-    # Psycopg2 interface.
-    def __conform__(self, protocol):
-        if protocol is ISQLQuote:
-            return self
-
-    def getquoted(self):
-        return "{}".format(self.__str__())
-    # End Psycopg2 interface.
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        return Period(value)
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, Period):
-            raise ValueError('Value must be an instance of Period class')
-        return value.__str__().strip("'")
-
-    def __str__(self):
-        lower_str = '[' if self._lower_inc else '('
-        upper_str = ']' if self._upper_inc else ')'
-        return f"'{lower_str}{self._lower}, {self._upper}{upper_str}'"
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
-                f'({self._lower!r}, {self._upper!r}, {self._lower_inc!r}, {self._upper_inc!r})')
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import datetime
+from dateutil.parser import parse
+import warnings
+
+try:
+    # Do not make psycopg2 a requirement.
+    from psycopg2.extensions import ISQLQuote
+except ImportError:
+    warnings.warn('psycopg2 not installed', ImportWarning)
+
+
+class Period:
+    """
+    Class for representing sets of contiguous timestamps between a lower and
+    an upper bound. The bounds may be inclusive or not.
+
+    ``Period`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> Period('(2019-09-08 00:00:00+01, 2019-09-10 00:00:00+01)')
+
+    Another possibility is to give a tuple of arguments as follows:
+
+    * ``lower`` and ``upper`` are instances of ``str`` or ``datetime``
+      specifying the bounds,
+    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
+      whether the bounds are inclusive or not. By default, ``lower_inc``
+      is ``True`` and ``upper_inc`` is ``False``.
+
+    Some examples are given next.
+
+        >>> Period('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01')
+        >>> Period('2019-09-08 00:00:00+01', '2019-09-10 00:00:00+01', False, True)
+        >>> Period(parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'))
+        >>> Period(parse('2019-09-08 00:00:00+01'), parse('2019-09-10 00:00:00+01'), False, True)
+
+    """
+
+    __slots__ = ['_lower', '_upper', '_lower_inc', '_upper_inc']
+
+    def __init__(self, lower, upper=None, lower_inc=None, upper_inc=None):
+        assert(isinstance(lower_inc, (bool, type(None)))), "ERROR: Invalid lower bound flag"
+        assert(isinstance(upper_inc, (bool, type(None)))), "ERROR: Invalid upper bound flag"
+        # Constructor with a single argument of type string
+        if upper is None and isinstance(lower, str):
+            lower = lower.strip()
+            assert(lower[0] == '[' or lower[0] == '('), "Lower bound flag must be either '[' or '('"
+            assert(lower[-1] == ']' or lower[-1] == ')'), "Upper bound flag must be either ']' or ')'"
+            self._lower_inc = True if lower[0] == '[' else False
+            self._upper_inc = True if lower[-1] == ']' else False
+            bounds = lower[1:-1].split(',')
+            self._lower = parse(bounds[0])
+            self._upper = parse(bounds[1])
+        # Constructor with two arguments of type string and optional arguments for the bounds
+        elif isinstance(lower, str) and isinstance(upper, str):
+            self._lower = parse(lower)
+            self._upper = parse(upper)
+            self._lower_inc = lower_inc if lower_inc is not None else True
+            self._upper_inc = upper_inc if upper_inc is not None else False
+        # Constructor with two arguments of type datetime and optional arguments for the bounds
+        elif isinstance(lower, datetime.datetime) and isinstance(upper, datetime.datetime):
+            self._lower = lower
+            self._upper = upper
+            self._lower_inc = lower_inc if lower_inc is not None else True
+            self._upper_inc = upper_inc if upper_inc is not None else False
+        else:
+            raise Exception("ERROR: Could not parse period value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        if self._lower > self._upper:
+            raise Exception("ERROR: The lower bound must be less than or equal to the upper bound")
+        if (self._lower == self._upper and
+            (self._lower_inc == False or self._upper_inc == False)):
+            raise Exception("ERROR: The lower and upper bounds must be inclusive for an instant period")
+        return True
+
+    @property
+    def lower(self):
+        """
+        Lower bound
+        """
+        return self._lower
+
+    @property
+    def upper(self):
+        """
+        Upper bound
+        """
+        return self._upper
+
+    @property
+    def lower_inc(self):
+        """
+        Is the lower bound inclusive?
+        """
+        return self._lower_inc
+
+    @property
+    def upper_inc(self):
+        """
+        Is the upper bound inclusive?
+        """
+        return self._upper_inc
+
+    @property
+    def duration(self):
+        """
+        Time interval on which the period is defined
+        """
+        return self._upper - self._lower
+
+    def shift(self, timedelta):
+        """
+        Shift the period by a time interval
+        """
+        return Period(self._lower + timedelta, self._upper + timedelta,
+                      self._lower_inc, self._upper_inc)
+
+    @staticmethod
+    def _cmp_boundSeqSet(t1, t2, lower1, lower2, inclusive1, inclusive2):
+        # Compare the values
+        if t1 < t2:
+            return -1
+        elif t1 > t2:
+            return 1
+        """
+        If the comparison is not equal and the bounds are both inclusive or 
+        both exclusive, we're done. If they compare equal, we still have to 
+        consider whether the boundaries are inclusive or exclusive. 
+        """
+        if not inclusive1 and not inclusive2:
+            # both are exclusive
+            if lower1 == lower2:
+                return 0
+            else:
+                if lower1:
+                    return 1
+                else:
+                    return -1
+        elif not inclusive1:
+            if lower1:
+                return 1
+            else:
+                return -1
+        elif not inclusive2:
+            if lower2:
+                return -1
+            else:
+                return 1
+        else:
+            return 0
+
+    def overlap(self, other):
+        """
+        Do the periods share a timestamp?
+        """
+        if ((self._cmp_boundSeqSet(self._lower, other._lower, True, True, self._lower_inc, other._lower_inc) >= 0 and
+                     self._cmp_boundSeqSet(self._lower, other._upper, True, False, self._lower_inc, other._upper_inc) <= 0) or
+            (self._cmp_boundSeqSet(other._lower, self._lower, True, True, other._lower_inc, self._lower_inc) >= 0 and
+                     self._cmp_boundSeqSet(other._lower, self._upper, True, False, other._lower_inc, self._upper_inc) <= 0)):
+            return True
+        return False
+
+    def contains_timestamp(self, datetime):
+        """
+        Does the period contain the timestamp?
+        """
+        if ((self._lower < datetime < self._upper) or
+            (self._lower_inc and self._lower == datetime) or
+            (self._upper_inc and self._upper == datetime)):
+            return True
+        return False
+
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            if (self._lower == other._lower and self._upper == other._upper and
+                self._lower_inc == other._lower_inc and self._upper_inc == other._upper_inc):
+                return True
+        return False
+
+    def _cmp(self, other):
+        if isinstance(other, self.__class__):
+            if self._lower < other._lower:
+                return -1
+            elif self._lower > other._lower:
+                return 1
+            elif self._upper < other._upper:
+                return -1
+            elif self._upper > other._upper:
+                return 1
+            elif self._lower_inc and not other._lower_inc:
+                return -1
+            elif not self._lower_inc and other._lower_inc:
+                return 1
+            elif self._upper_inc and not other._upper_inc:
+                return -1
+            elif not self._upper_inc and other._upper_inc:
+                return 1
+        return 0
+
+    def __lt__(self, other):
+        if isinstance(other, self.__class__):
+            if self._cmp(other) == -1:
+                return True
+        return False
+
+    def __le__(self, other):
+        if isinstance(other, self.__class__):
+            if self._cmp(other) == -1 or self._cmp(other) == 0:
+                return True
+        return False
+
+    def __gt__(self, other):
+        if isinstance(other, self.__class__):
+            if self._cmp(other) == 1:
+                return True
+        return False
+
+    def __ge__(self, other):
+        if isinstance(other, self.__class__):
+            if self._cmp(other) == 1 or self._cmp(other) == 0:
+                return True
+        return False
+
+    # Psycopg2 interface.
+    def __conform__(self, protocol):
+        if protocol is ISQLQuote:
+            return self
+
+    def getquoted(self):
+        return "{}".format(self.__str__())
+    # End Psycopg2 interface.
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        return Period(value)
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, Period):
+            raise ValueError('Value must be an instance of Period class')
+        return value.__str__().strip("'")
+
+    def __str__(self):
+        lower_str = '[' if self._lower_inc else '('
+        upper_str = ']' if self._upper_inc else ')'
+        return f"'{lower_str}{self._lower}, {self._upper}{upper_str}'"
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
+                f'({self._lower!r}, {self._upper!r}, {self._lower_inc!r}, {self._upper_inc!r})')
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/boxes/stbox.py` & `python-mobilitydb-0.1.3/mobilitydb/boxes/stbox.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,306 +1,306 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime
-from dateutil.parser import parse
-import warnings
-
-try:
-    # Do not make psycopg2 a requirement.
-    from psycopg2.extensions import ISQLQuote
-except ImportError:
-    warnings.warn('psycopg2 not installed', ImportWarning)
-
-
-class STBox:
-    """
-    Class for representing bounding boxes composed of coordinate and/or time
-    dimensions, where the coordinates may be in 2D (``X`` and ``Y``) or in 3D
-    (``X``, ``Y``, and ``Z``). For each dimension, minimum and maximum values
-    are stored. The coordinates may be either Cartesian (planar) or geodetic
-    (spherical). Additionally, the SRID of coordinates can be specified.
-
-
-    ``STBox`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> "STBOX ((1.0, 2.0), (1.0, 2.0))",
-        >>> "STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))",
-        >>> "STBOX T((1.0, 2.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 2001-01-03 00:00:00+01))",
-        >>> "STBOX ZT((1.0, 2.0, 3.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))",
-        >>> "STBOX T(, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))",
-        >>> "GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))",
-        >>> "GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))",
-        >>> "GEODSTBOX T((, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))",
-        >>> "SRID=5676;STBOX T((1.0, 2.0, 2001-01-04), (1.0, 2.0, 2001-01-04))",
-        >>> "SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))",
-
-    Another possibility is to give the bounds in the following order:
-    ``xmin``, ``ymin``, ``zmin``, ``tmin``, ``xmax``, ``ymax``, ``zmax``,
-    ``tmax``, where the bounds can be instances of ``str``, ``float``
-    and ``datetime``. All arguments are optional but they must be given
-    in pairs for each dimension and at least one pair must be given.
-    When three pairs are given, by default, the third pair will be
-    interpreted as representing the ``Z`` dimension unless the ``dimt``
-    parameter is given. Finally, the ``geodetic`` parameter determines
-    whether the coordinates in the bounds are planar or spherical.
-
-        >>> STBox((1.0, 2.0, 1.0, 2.0))
-        >>> STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0))
-        >>> STBox((1.0, 2.0, '2001-01-03', 1.0, 2.0, '2001-01-03'), dimt=True)
-        >>> STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-04'))
-        >>> STBox(('2001-01-03', '2001-01-03'))
-        >>> STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0), geodetic=True)
-        >>> STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03'), geodetic=True)
-        >>> STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03'), geodetic=True, srid=4326)
-        >>> STBox(('2001-01-03', '2001-01-03'), geodetic=True)
-
-    """
-    __slots__ = ['_xmin', '_ymin', '_zmin', '_tmin', '_xmax', '_ymax', '_zmax', '_tmax', '_geodetic', '_srid']
-
-    def __init__(self, bounds, dimt=None, geodetic=None, srid=None):
-        # Initialize arguments to None and set geodetic if given
-        self._xmin = self._ymin = self._zmin = self._tmin = None
-        self._xmax = self._ymax = self._zmax = self._tmax = None
-        assert(geodetic is None or isinstance(geodetic, bool)), "ERROR: Geodetic parameter must be Boolean"
-        self._geodetic = geodetic if geodetic is not None else False
-        assert(srid is None or isinstance(srid, int)), "ERROR: SRID parameter must be Integer"
-        self._srid = srid if srid is not None else False
-        # Unpack the bounds
-        if isinstance(bounds, str):
-            self.parse_from_string(bounds)
-            return
-        if isinstance(bounds, (tuple, list)):
-            xmin = ymin = zmin = tmin = None
-            xmax = ymax = zmax = tmax = None
-            if len(bounds) == 2:
-                tmin, tmax = bounds
-            elif len(bounds) == 4:
-                xmin, ymin, xmax, ymax = bounds
-            elif len(bounds) == 6:
-                if dimt:
-                    xmin, ymin, tmin, xmax, ymax, tmax = bounds
-                else:
-                    xmin, ymin, zmin, xmax, ymax, zmax = bounds
-            elif len(bounds) == 8:
-                xmin, ymin, zmin, tmin, xmax, ymax, zmax, tmax = bounds
-            else:
-                raise Exception("ERROR: Cannot parse STBox")
-        # Initialize the new instance
-        self._xmin = float(xmin) if xmin is not None else None
-        self._xmax = float(xmax) if xmax is not None else None
-        self._ymin = float(ymin) if ymin is not None else None
-        self._ymax = float(ymax) if ymax is not None else None
-        self._zmin = float(zmin) if zmin is not None else None
-        self._zmax = float(zmax) if zmax is not None else None
-        if tmin is not None and tmax is not None:
-            if isinstance(tmin, str) and isinstance(tmax, str):
-                self._tmin = parse(tmin)
-                self._tmax = parse(tmax)
-            elif isinstance(tmin, datetime) and isinstance(tmax, datetime):
-                self._tmin = tmin
-                self._tmax = tmax
-            else:
-                raise Exception("ERROR: Cannot parse STBox")
-
-    def parse_from_string(self, value):
-        if value is None or not isinstance(value, str):
-            raise Exception("ERROR: Cannot parse STBox")
-        value = value.strip()
-        values = None
-
-        # SRID, if specified would be at start of the value. Example:
-        #   SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))
-        if value.startswith("SRID"):
-            srid, _stbox = value.split(";")
-            srid = int(srid.split('=')[1])
-            self._srid = srid
-            value = _stbox
-
-        if 'GEODSTBOX' in value:
-            self._geodetic = True
-            value = value.replace("GEODSTBOX", '')
-            hasz = True
-            hast = True if 'T' in value else False
-        elif 'STBOX' in value:
-            value = value.replace("STBOX", '')
-            hasz = True if 'Z' in value else False
-            hast = True if 'T' in value else False
-        else:
-            raise Exception("ERROR: Input must be STBOX")
-
-        values = value.replace('Z', '').replace('T', ''). replace('(', '').replace(')', '').split(',')
-        # Remove empty or only space strings
-        values = [value for value in values if value != '' and not value.isspace()]
-
-        if len(values) == 2:
-            self._tmin = parse(values[0])
-            self._tmax = parse(values[1])
-        else:
-            if len(values) >= 4:
-                self._xmin = float(values[0])
-                self._xmax = float(values[int(len(values) / 2)])
-                self._ymin = float(values[1])
-                self._ymax = float(values[1 + int(len(values) / 2)])
-            if hasz:
-                self._zmin = float(values[2])
-                self._zmax = float(values[2 + int(len(values) / 2)])
-            if hast:
-                self._tmin = parse(values[int(len(values) / 2) - 1])
-                self._tmax = parse(values[(int(len(values) / 2) - 1) + int(len(values) / 2)])
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        return STBox(value)
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, STBox):
-            raise ValueError('Value must be an instance of STBox class')
-        return value.__str__().strip("'")
-
-    # Psycopg2 interface.
-    def __conform__(self, protocol):
-        if protocol is ISQLQuote:
-            return self
-
-    def getquoted(self):
-        return "{}".format(self.__str__())
-    # End Psycopg2 interface.
-
-    @property
-    def xmin(self):
-        """
-        Minimum X
-        """
-        return self._xmin
-
-    @property
-    def ymin(self):
-        """
-        Minimum Y
-        """
-        return self._ymin
-
-    @property
-    def zmin(self):
-        """
-        Minimum Z
-        """
-        return self._ymin
-
-    @property
-    def tmin(self):
-        """
-        Minimum T
-        """
-        return self._tmin
-
-    @property
-    def xmax(self):
-        """
-        Maximum X
-        """
-        return self._xmax
-
-    @property
-    def ymax(self):
-        """
-        Maximum Y
-        """
-        return self._ymax
-
-    @property
-    def zmax(self):
-        """
-        Maximum Z
-        """
-        return self._zmax
-
-    @property
-    def tmax(self):
-        """
-        Maximum T
-        """
-        return self._tmax
-
-    @property
-    def geodetic(self):
-        """
-        Is the box is geodetic?
-        """
-        return self._geodetic
-
-    @property
-    def srid(self):
-        """
-        SRID of the geographic coordinates
-        """
-        return self._srid
-
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            return self._xmin == other._xmin and self._ymin == other._ymin and self._zmin == other._zmin and \
-                   self._tmin == other._tmin and self._xmax == other._xmax and self._ymax == other._ymax and \
-                   self._zmax == other._zmax and self._tmax == other._tmax and self._geodetic == other._geodetic
-        return False
-
-    def __str__(self):
-        srid_prefix = ('SRID=%s;' % self._srid) if self._srid else ''
-        if self._geodetic:
-            if self._tmin is not None:
-                if self._xmin is not None:
-                    return "'%sGEODSTBOX T((%s, %s, %s, %s), (%s, %s, %s, %s))'" % \
-                        (srid_prefix, self._xmin, self._ymin, self._zmin, self._tmin, self._xmax, self._ymax, self._zmax, self._tmax)
-                else:
-                    return "'%sGEODSTBOX T((, %s), (, %s))'" % (srid_prefix, self._tmin, self._tmax)
-            else:
-                return "'%sGEODSTBOX((%s, %s, %s), (%s, %s, %s))'" % \
-                    (srid_prefix, self._xmin, self._ymin, self._zmin, self._xmax, self._ymax, self._zmax)
-        else:
-            if self._xmin is not None and self._zmin is not None and self._tmin is not None:
-                return "'%sSTBOX ZT((%s, %s, %s, %s), (%s, %s, %s, %s))'" % \
-                    (srid_prefix, self._xmin, self._ymin, self._zmin, self._tmin, self._xmax, self._ymax, self._zmax, self._tmax)
-            elif self._xmin is not None and self._zmin is not None and self._tmin is None:
-                return "'%sSTBOX Z((%s, %s, %s), (%s, %s, %s))'" % \
-                    (srid_prefix, self._xmin, self._ymin, self._zmin, self._xmax, self._ymax, self._zmax)
-            elif self._xmin is not None and self._zmin is None and self._tmin is not None:
-                return "'%sSTBOX T((%s, %s, %s), (%s, %s, %s))'" % \
-                    (srid_prefix, self._xmin, self._ymin, self._tmin, self._xmax, self._ymax, self._tmax)
-            elif self._xmin is not None and self._zmin is None and self._tmin is None:
-                return "'%sSTBOX ((%s, %s), (%s, %s))'" % \
-                       (srid_prefix, self._xmin, self._ymin, self._xmax, self._ymax)
-            elif self._xmin is None and self._zmin is None and self._tmin is not None:
-                return "'%sSTBOX T((, %s), (, %s))'" % (srid_prefix, self._tmin, self._tmax)
-            else:
-                raise Exception("ERROR: Wrong values")
-
-    def __repr__(self):
-        return (f'{self.__class__.__name__ }'
-                f'({self._xmin!r}, {self._ymin!r}, {self._zmin!r}, {self._tmin!r}, '
-                f'{self._xmax!r}, {self._ymax!r}, {self._zmax!r}, {self._tmax!r}, {self._geodetic!r}, {self._srid!r})')
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime
+from dateutil.parser import parse
+import warnings
+
+try:
+    # Do not make psycopg2 a requirement.
+    from psycopg2.extensions import ISQLQuote
+except ImportError:
+    warnings.warn('psycopg2 not installed', ImportWarning)
+
+
+class STBox:
+    """
+    Class for representing bounding boxes composed of coordinate and/or time
+    dimensions, where the coordinates may be in 2D (``X`` and ``Y``) or in 3D
+    (``X``, ``Y``, and ``Z``). For each dimension, minimum and maximum values
+    are stored. The coordinates may be either Cartesian (planar) or geodetic
+    (spherical). Additionally, the SRID of coordinates can be specified.
+
+
+    ``STBox`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> "STBOX ((1.0, 2.0), (1.0, 2.0))",
+        >>> "STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))",
+        >>> "STBOX T((1.0, 2.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 2001-01-03 00:00:00+01))",
+        >>> "STBOX ZT((1.0, 2.0, 3.0, 2001-01-04 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))",
+        >>> "STBOX T(, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))",
+        >>> "GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))",
+        >>> "GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-03 00:00:00+01), (1.0, 2.0, 3.0, 2001-01-04 00:00:00+01))",
+        >>> "GEODSTBOX T((, 2001-01-03 00:00:00+01), (, 2001-01-03 00:00:00+01))",
+        >>> "SRID=5676;STBOX T((1.0, 2.0, 2001-01-04), (1.0, 2.0, 2001-01-04))",
+        >>> "SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))",
+
+    Another possibility is to give the bounds in the following order:
+    ``xmin``, ``ymin``, ``zmin``, ``tmin``, ``xmax``, ``ymax``, ``zmax``,
+    ``tmax``, where the bounds can be instances of ``str``, ``float``
+    and ``datetime``. All arguments are optional but they must be given
+    in pairs for each dimension and at least one pair must be given.
+    When three pairs are given, by default, the third pair will be
+    interpreted as representing the ``Z`` dimension unless the ``dimt``
+    parameter is given. Finally, the ``geodetic`` parameter determines
+    whether the coordinates in the bounds are planar or spherical.
+
+        >>> STBox((1.0, 2.0, 1.0, 2.0))
+        >>> STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0))
+        >>> STBox((1.0, 2.0, '2001-01-03', 1.0, 2.0, '2001-01-03'), dimt=True)
+        >>> STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-04'))
+        >>> STBox(('2001-01-03', '2001-01-03'))
+        >>> STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0), geodetic=True)
+        >>> STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03'), geodetic=True)
+        >>> STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03'), geodetic=True, srid=4326)
+        >>> STBox(('2001-01-03', '2001-01-03'), geodetic=True)
+
+    """
+    __slots__ = ['_xmin', '_ymin', '_zmin', '_tmin', '_xmax', '_ymax', '_zmax', '_tmax', '_geodetic', '_srid']
+
+    def __init__(self, bounds, dimt=None, geodetic=None, srid=None):
+        # Initialize arguments to None and set geodetic if given
+        self._xmin = self._ymin = self._zmin = self._tmin = None
+        self._xmax = self._ymax = self._zmax = self._tmax = None
+        assert(geodetic is None or isinstance(geodetic, bool)), "ERROR: Geodetic parameter must be Boolean"
+        self._geodetic = geodetic if geodetic is not None else False
+        assert(srid is None or isinstance(srid, int)), "ERROR: SRID parameter must be Integer"
+        self._srid = srid if srid is not None else False
+        # Unpack the bounds
+        if isinstance(bounds, str):
+            self.parse_from_string(bounds)
+            return
+        if isinstance(bounds, (tuple, list)):
+            xmin = ymin = zmin = tmin = None
+            xmax = ymax = zmax = tmax = None
+            if len(bounds) == 2:
+                tmin, tmax = bounds
+            elif len(bounds) == 4:
+                xmin, ymin, xmax, ymax = bounds
+            elif len(bounds) == 6:
+                if dimt:
+                    xmin, ymin, tmin, xmax, ymax, tmax = bounds
+                else:
+                    xmin, ymin, zmin, xmax, ymax, zmax = bounds
+            elif len(bounds) == 8:
+                xmin, ymin, zmin, tmin, xmax, ymax, zmax, tmax = bounds
+            else:
+                raise Exception("ERROR: Cannot parse STBox")
+        # Initialize the new instance
+        self._xmin = float(xmin) if xmin is not None else None
+        self._xmax = float(xmax) if xmax is not None else None
+        self._ymin = float(ymin) if ymin is not None else None
+        self._ymax = float(ymax) if ymax is not None else None
+        self._zmin = float(zmin) if zmin is not None else None
+        self._zmax = float(zmax) if zmax is not None else None
+        if tmin is not None and tmax is not None:
+            if isinstance(tmin, str) and isinstance(tmax, str):
+                self._tmin = parse(tmin)
+                self._tmax = parse(tmax)
+            elif isinstance(tmin, datetime) and isinstance(tmax, datetime):
+                self._tmin = tmin
+                self._tmax = tmax
+            else:
+                raise Exception("ERROR: Cannot parse STBox")
+
+    def parse_from_string(self, value):
+        if value is None or not isinstance(value, str):
+            raise Exception("ERROR: Cannot parse STBox")
+        value = value.strip()
+        values = None
+
+        # SRID, if specified would be at start of the value. Example:
+        #   SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))
+        if value.startswith("SRID"):
+            srid, _stbox = value.split(";")
+            srid = int(srid.split('=')[1])
+            self._srid = srid
+            value = _stbox
+
+        if 'GEODSTBOX' in value:
+            self._geodetic = True
+            value = value.replace("GEODSTBOX", '')
+            hasz = True
+            hast = True if 'T' in value else False
+        elif 'STBOX' in value:
+            value = value.replace("STBOX", '')
+            hasz = True if 'Z' in value else False
+            hast = True if 'T' in value else False
+        else:
+            raise Exception("ERROR: Input must be STBOX")
+
+        values = value.replace('Z', '').replace('T', ''). replace('(', '').replace(')', '').split(',')
+        # Remove empty or only space strings
+        values = [value for value in values if value != '' and not value.isspace()]
+
+        if len(values) == 2:
+            self._tmin = parse(values[0])
+            self._tmax = parse(values[1])
+        else:
+            if len(values) >= 4:
+                self._xmin = float(values[0])
+                self._xmax = float(values[int(len(values) / 2)])
+                self._ymin = float(values[1])
+                self._ymax = float(values[1 + int(len(values) / 2)])
+            if hasz:
+                self._zmin = float(values[2])
+                self._zmax = float(values[2 + int(len(values) / 2)])
+            if hast:
+                self._tmin = parse(values[int(len(values) / 2) - 1])
+                self._tmax = parse(values[(int(len(values) / 2) - 1) + int(len(values) / 2)])
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        return STBox(value)
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, STBox):
+            raise ValueError('Value must be an instance of STBox class')
+        return value.__str__().strip("'")
+
+    # Psycopg2 interface.
+    def __conform__(self, protocol):
+        if protocol is ISQLQuote:
+            return self
+
+    def getquoted(self):
+        return "{}".format(self.__str__())
+    # End Psycopg2 interface.
+
+    @property
+    def xmin(self):
+        """
+        Minimum X
+        """
+        return self._xmin
+
+    @property
+    def ymin(self):
+        """
+        Minimum Y
+        """
+        return self._ymin
+
+    @property
+    def zmin(self):
+        """
+        Minimum Z
+        """
+        return self._ymin
+
+    @property
+    def tmin(self):
+        """
+        Minimum T
+        """
+        return self._tmin
+
+    @property
+    def xmax(self):
+        """
+        Maximum X
+        """
+        return self._xmax
+
+    @property
+    def ymax(self):
+        """
+        Maximum Y
+        """
+        return self._ymax
+
+    @property
+    def zmax(self):
+        """
+        Maximum Z
+        """
+        return self._zmax
+
+    @property
+    def tmax(self):
+        """
+        Maximum T
+        """
+        return self._tmax
+
+    @property
+    def geodetic(self):
+        """
+        Is the box is geodetic?
+        """
+        return self._geodetic
+
+    @property
+    def srid(self):
+        """
+        SRID of the geographic coordinates
+        """
+        return self._srid
+
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            return self._xmin == other._xmin and self._ymin == other._ymin and self._zmin == other._zmin and \
+                   self._tmin == other._tmin and self._xmax == other._xmax and self._ymax == other._ymax and \
+                   self._zmax == other._zmax and self._tmax == other._tmax and self._geodetic == other._geodetic
+        return False
+
+    def __str__(self):
+        srid_prefix = ('SRID=%s;' % self._srid) if self._srid else ''
+        if self._geodetic:
+            if self._tmin is not None:
+                if self._xmin is not None:
+                    return "'%sGEODSTBOX T((%s, %s, %s, %s), (%s, %s, %s, %s))'" % \
+                        (srid_prefix, self._xmin, self._ymin, self._zmin, self._tmin, self._xmax, self._ymax, self._zmax, self._tmax)
+                else:
+                    return "'%sGEODSTBOX T((, %s), (, %s))'" % (srid_prefix, self._tmin, self._tmax)
+            else:
+                return "'%sGEODSTBOX((%s, %s, %s), (%s, %s, %s))'" % \
+                    (srid_prefix, self._xmin, self._ymin, self._zmin, self._xmax, self._ymax, self._zmax)
+        else:
+            if self._xmin is not None and self._zmin is not None and self._tmin is not None:
+                return "'%sSTBOX ZT((%s, %s, %s, %s), (%s, %s, %s, %s))'" % \
+                    (srid_prefix, self._xmin, self._ymin, self._zmin, self._tmin, self._xmax, self._ymax, self._zmax, self._tmax)
+            elif self._xmin is not None and self._zmin is not None and self._tmin is None:
+                return "'%sSTBOX Z((%s, %s, %s), (%s, %s, %s))'" % \
+                    (srid_prefix, self._xmin, self._ymin, self._zmin, self._xmax, self._ymax, self._zmax)
+            elif self._xmin is not None and self._zmin is None and self._tmin is not None:
+                return "'%sSTBOX T((%s, %s, %s), (%s, %s, %s))'" % \
+                    (srid_prefix, self._xmin, self._ymin, self._tmin, self._xmax, self._ymax, self._tmax)
+            elif self._xmin is not None and self._zmin is None and self._tmin is None:
+                return "'%sSTBOX ((%s, %s), (%s, %s))'" % \
+                       (srid_prefix, self._xmin, self._ymin, self._xmax, self._ymax)
+            elif self._xmin is None and self._zmin is None and self._tmin is not None:
+                return "'%sSTBOX T((, %s), (, %s))'" % (srid_prefix, self._tmin, self._tmax)
+            else:
+                raise Exception("ERROR: Wrong values")
+
+    def __repr__(self):
+        return (f'{self.__class__.__name__ }'
+                f'({self._xmin!r}, {self._ymin!r}, {self._zmin!r}, {self._tmin!r}, '
+                f'{self._xmax!r}, {self._ymax!r}, {self._zmax!r}, {self._tmax!r}, {self._geodetic!r}, {self._srid!r})')
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/time_asyncpg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/time_asyncpg.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,156 +1,156 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncio
-from mobilitydb.asyncpg import register
-from mobilitydb.examples.db_connect import asyncpg_connect
-
-async def run():
-
-    # Set the connection parameters to PostgreSQL
-    connection = await asyncpg_connect()
-
-    try:
-        # Register MobilityDB data types
-        await register(connection)
-
-        ######################
-        # TimestampSet
-        ######################
-
-        select_query = "SELECT * FROM tbl_timestampset ORDER BY k LIMIT 10"
-
-        await connection.execute(select_query)
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_timestampset table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("timestampset =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("duration =", row[1].duration, "\n")
-
-        drop_table_query = "DROP TABLE IF EXISTS tbl_timestampset_temp;"
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL")
-
-        create_table_query = '''CREATE TABLE tbl_timestampset_temp
-        (
-          k integer PRIMARY KEY,
-          ts timestampset
-        ); '''
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL")
-
-        insert_query = "INSERT INTO tbl_timestampset_temp (k, ts) VALUES ($1, $2)"
-        await connection.executemany(insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_timestampset_temp table")
-
-        ######################
-        # Period
-        ######################
-
-        select_query = "SELECT * FROM tbl_period ORDER BY k LIMIT 10"
-
-        await connection.execute(select_query)
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_period table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("period =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("duration =", row[1].duration, "\n")
-
-        drop_table_query = "DROP TABLE IF EXISTS tbl_period_temp;"
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL")
-
-        create_table_query = '''CREATE TABLE tbl_period_temp
-        (
-          k integer PRIMARY KEY,
-          p period
-        ); '''
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL")
-
-        insert_query = "INSERT INTO tbl_period_temp (k, p) VALUES ($1, $2)"
-        await connection.executemany(insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_period_temp table")
-
-        ######################
-        # PeriodSet
-        ######################
-
-        select_query = "SELECT * FROM tbl_periodset ORDER BY k LIMIT 10"
-
-        await connection.execute(select_query)
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_periodset table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("periodset =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("duration =", row[1].duration, "\n")
-
-        drop_table_query = "DROP TABLE IF EXISTS tbl_periodset_temp;"
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL")
-
-        create_table_query = '''CREATE TABLE tbl_periodset_temp
-        (
-          k integer PRIMARY KEY,
-          ps periodset
-        ); '''
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL")
-
-        insert_query = "INSERT INTO tbl_periodset_temp (k, ps) VALUES ($1, $2)"
-        await connection.executemany(insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_periodset_temp table")
-
-        print("\n****************************************************************")
-
-    finally:
-        await connection.close()
-
-loop = asyncio.get_event_loop()
-loop.run_until_complete(run())
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TimestampSet
+        ######################
+
+        select_query = "SELECT * FROM tbl_timestampset ORDER BY k LIMIT 10"
+
+        await connection.execute(select_query)
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_timestampset table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("timestampset =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("duration =", row[1].duration, "\n")
+
+        drop_table_query = "DROP TABLE IF EXISTS tbl_timestampset_temp;"
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL")
+
+        create_table_query = '''CREATE TABLE tbl_timestampset_temp
+        (
+          k integer PRIMARY KEY,
+          ts timestampset
+        ); '''
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL")
+
+        insert_query = "INSERT INTO tbl_timestampset_temp (k, ts) VALUES ($1, $2)"
+        await connection.executemany(insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_timestampset_temp table")
+
+        ######################
+        # Period
+        ######################
+
+        select_query = "SELECT * FROM tbl_period ORDER BY k LIMIT 10"
+
+        await connection.execute(select_query)
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_period table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("period =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("duration =", row[1].duration, "\n")
+
+        drop_table_query = "DROP TABLE IF EXISTS tbl_period_temp;"
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL")
+
+        create_table_query = '''CREATE TABLE tbl_period_temp
+        (
+          k integer PRIMARY KEY,
+          p period
+        ); '''
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL")
+
+        insert_query = "INSERT INTO tbl_period_temp (k, p) VALUES ($1, $2)"
+        await connection.executemany(insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_period_temp table")
+
+        ######################
+        # PeriodSet
+        ######################
+
+        select_query = "SELECT * FROM tbl_periodset ORDER BY k LIMIT 10"
+
+        await connection.execute(select_query)
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_periodset table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("periodset =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("duration =", row[1].duration, "\n")
+
+        drop_table_query = "DROP TABLE IF EXISTS tbl_periodset_temp;"
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL")
+
+        create_table_query = '''CREATE TABLE tbl_periodset_temp
+        (
+          k integer PRIMARY KEY,
+          ps periodset
+        ); '''
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL")
+
+        insert_query = "INSERT INTO tbl_periodset_temp (k, ps) VALUES ($1, $2)"
+        await connection.executemany(insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_periodset_temp table")
+
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/box_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/box_asyncpg.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,131 +1,120 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TBOX
-    ######################
-
-    select_query = "select * from tbl_tbox order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tbox table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tbox =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("tmin =", row[1].tmin, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tbox_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tbox_temp
-        (
-          k integer PRIMARY KEY,
-          box tbox
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tbox_temp (k, box) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tbox_temp table")
-
-    ######################
-    # STBOX
-    ######################
-
-    select_query = "select * from tbl_stbox order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_stbox table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("stbox =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("tmin =", row[1].tmin, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_stbox_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_stbox_temp
-        (
-          k integer PRIMARY KEY,
-          box stbox
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_stbox_temp (k, box) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_stbox_temp table")
-
-    print("\n****************************************************************")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connection:
-        connection.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TBox
+        ######################
+
+        select_query = "SELECT * FROM tbl_tbox ORDER BY k LIMIT 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tbox table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tbox =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("tmin =", row[1].tmin, "\n")
+
+        drop_table_query = "DROP TABLE IF EXISTS tbl_tbox_temp;"
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+
+        create_table_query = '''CREATE TABLE tbl_tbox_temp
+            (
+              k integer PRIMARY KEY,
+              box tbox
+            ); '''
+
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+
+        postgres_insert_query = "INSERT INTO tbl_tbox_temp (k, box) VALUES ($1, $2)"
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tbox_temp table")
+
+        ######################
+        # STBox
+        ######################
+
+        select_query = "SELECT * FROM tbl_stbox ORDER BY k LIMIT 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_stbox table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("stbox =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("tmin =", row[1].tmin, "\n")
+
+        drop_table_query = "DROP TABLE IF EXISTS tbl_stbox_temp;"
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+
+        create_table_query = '''CREATE TABLE tbl_stbox_temp
+            (
+              k integer PRIMARY KEY,
+              box stbox
+            ); '''
+
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+
+        postgres_insert_query = "INSERT INTO tbl_stbox_temp (k, box) VALUES ($1, $2)"
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_stbox_temp table")
+
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/ttext.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/ttext.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,270 +1,270 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
-
-print("\nConstructors for TTextInst")
-inst = TTextInst('A@2019-09-08')
-print(inst)
-inst = TTextInst('A', '2019-09-08')
-print(inst)
-t = parse('2019-09-08')
-inst = TTextInst('A', t)
-print(inst)
-
-print("\nConstructors for TTextInstSet")
-ti = TTextInstSet('{A@2019-09-08, B@2019-09-09, B@2019-09-10}')
-print(tinstset)
-ti = TTextInstSet('A@2019-09-08', 'B@2019-09-09', 'B@2019-09-10')
-print(tinstset)
-ti = TTextInstSet(['A@2019-09-08', 'B@2019-09-09', 'B@2019-09-10'])
-print(tinstset)
-t1 = TTextInst('A@2019-09-08')
-t2 = TTextInst('B@2019-09-09')
-t3 = TTextInst('B@2019-09-10')
-ti = TTextInstSet(t1, t2, t3)
-print(tinstset)
-ti = TTextInstSet([t1, t2, t3])
-print(tinstset)
-
-print("\nConstructors for TTextSeq")
-seq = TTextSeq('[A@2019-09-08, B@2019-09-09, B@2019-09-10]')
-print(seq)
-seq = TTextSeq(['A@2019-09-08', 'B@2019-09-09', 'B@2019-09-10'])
-print(seq)
-seq = TTextSeq([t1, t2, t3])
-print(seq)
-seq = TTextSeq([t1, t2, t3], False, True)
-print(seq)
-
-print("\nConstructors for TTextSeqSet")
-ts = TTextSeqSet('{[A@2019-09-08, B@2019-09-09, B@2019-09-10],[B@2019-09-11, C@2019-09-12]}')
-print(ts)
-ts = TTextSeqSet(['[A@2019-09-08, B@2019-09-09, B@2019-09-10]', '[B@2019-09-11, C@2019-09-12]'])
-print(ts)
-seq1 = TTextSeq('[A@2019-09-08, B@2019-09-09, B@2019-09-10]')
-seq2 = TTextSeq('[B@2019-09-11, C@2019-09-12]')
-ts = TTextSeqSet([seq1, seq2])
-print(ts)
-
-print("\n__class__ ")
-print(inst.__class__.__name__)
-print(ti.__class__.__name__)
-print(seq.__class__.__name__)
-print(ts.__class__.__name__)
-
-print("\n__bases__ ")
-print(inst.__class__.__bases__)
-print(ti.__class__.__bases__)
-print(seq.__class__.__bases__)
-print(ts.__class__.__bases__)
-
-print("\ntempSubtype")
-print(inst.tempSubtype())
-print(ti.tempSubtype())
-print(seq.tempSubtype())
-print(ts.tempSubtype())
-
-print("\ninterpolation")
-print(seq.interpolation)
-print(ts.interpolation)
-
-print("\ngetValue")
-print(inst.getValue)
-
-print("\ngetValues")
-print(inst.getValues)
-print(ti.getValues)
-print(seq.getValues)
-print(ts.getValues)
-
-print("\nstartValue")
-print(inst.startValue)
-print(ti.startValue)
-print(seq.startValue)
-print(ts.startValue)
-
-print("\nendValue")
-print(inst.endValue)
-print(ti.endValue)
-print(seq.endValue)
-print(ts.endValue)
-
-print("\nminValue")
-print(inst.minValue)
-print(ti.minValue)
-print(seq.minValue)
-print(ts.minValue)
-
-print("\nmaxValue")
-print(inst.maxValue)
-print(ti.maxValue)
-print(seq.maxValue)
-print(ts.maxValue)
-
-print("\ngetTimestamp")
-print(inst.getTimestamp)
-
-print("\ngetTime")
-print(inst.getTime)
-print(ti.getTime)
-print(seq.getTime)
-print(ts.getTime)
-
-print("\nduration")
-print(inst.duration)
-print(ti.duration)
-print(seq.duration)
-print(ts.duration)
-
-print("\ntimespan")
-print(inst.timespan)
-print(ti.timespan)
-print(seq.timespan)
-print(ts.timespan)
-
-print("\nperiod")
-print(inst.period)
-print(ti.period)
-print(seq.period)
-print(ts.period)
-
-print("\nnumInstants")
-print(inst.numInstants)
-print(ti.numInstants)
-print(seq.numInstants)
-print(ts.numInstants)
-
-print("\nstartInstant")
-print(inst.startInstant)
-print(ti.startInstant)
-print(seq.startInstant)
-print(ts.startInstant)
-
-print("\nendInstant")
-print(inst.endInstant)
-print(ti.endInstant)
-print(seq.endInstant)
-print(ts.endInstant)
-
-print("\ninstantN")
-print(inst.instantN(1))
-print(ti.instantN(1))
-print(seq.instantN(1))
-print(ts.instantN(1))
-
-print("\ninstants")
-print(inst.instants)
-print(ti.instants)
-print(seq.instants)
-print(ts.instants)
-
-print("\nnumTimestamps")
-print(inst.numTimestamps)
-print(ti.numTimestamps)
-print(seq.numTimestamps)
-print(ts.numTimestamps)
-
-print("\nstartTimestamp")
-print(inst.startTimestamp)
-print(ti.startTimestamp)
-print(seq.startTimestamp)
-print(ts.startTimestamp)
-
-print("\nendTimestamp")
-print(inst.endTimestamp)
-print(ti.endTimestamp)
-print(seq.endTimestamp)
-print(ts.endTimestamp)
-
-print("\ntimestampN")
-print(inst.timestampN(1))
-print(ti.timestampN(1))
-print(seq.timestampN(1))
-print(ts.timestampN(1))
-
-print("\ntimestamps")
-print(inst.timestamps)
-print(ti.timestamps)
-print(seq.timestamps)
-print(ts.timestamps)
-
-print("\nnumSequences")
-print(seq.numSequences)
-print(ts.numSequences)
-
-print("\nstartSequence")
-print(seq.startSequence)
-print(ts.startSequence)
-
-print("\nendSequence")
-print(seq.endSequence)
-print(ts.endSequence)
-
-print("\nsequenceN")
-print(seq.sequenceN(1))
-print(ts.sequenceN(1))
-
-print("\nsequences")
-print(seq.sequences)
-print(ts.sequences)
-
-print("\nshift")
-print(inst.shift(timedelta(days=1)))
-print(ti.shift(timedelta(days=1)))
-print(seq.shift(timedelta(days=1)))
-print(ts.shift(timedelta(days=1)))
-
-print("\nintersectsTimestamp")
-t = datetime.strptime('2019-09-09', '%Y-%m-%d')
-print(inst.intersectsTimestamp(t))
-print(ti.intersectsTimestamp(t))
-print(seq.intersectsTimestamp(t))
-print(ts.intersectsTimestamp(t))
-
-print("\nintersectsTimestampSet")
-tss = TimestampSet('{2019-09-09, 2019-09-10}')
-print(inst.intersectsTimestampSet(tss))
-print(ti.intersectsTimestampSet(tss))
-print(seq.intersectsTimestampSet(tss))
-print(ts.intersectsTimestampSet(tss))
-
-print("\nintersectsPeriod")
-p = Period('2019-09-09', '2019-09-10', True, True)
-print(inst.intersectsPeriod(p))
-print(ti.intersectsPeriod(p))
-print(seq.intersectsPeriod(p))
-print(ts.intersectsPeriod(p))
-
-print("\nintersectsPeriodSet")
-ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
-print(inst.intersectsPeriodSet(ps))
-print(ti.intersectsPeriodSet(ps))
-print(seq.intersectsPeriodSet(ps))
-print(ts.intersectsPeriodSet(ps))
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
+
+print("\nConstructors for TTextInst")
+inst = TTextInst('A@2019-09-08')
+print(inst)
+inst = TTextInst('A', '2019-09-08')
+print(inst)
+t = parse('2019-09-08')
+inst = TTextInst('A', t)
+print(inst)
+
+print("\nConstructors for TTextInstSet")
+ti = TTextInstSet('{A@2019-09-08, B@2019-09-09, B@2019-09-10}')
+print(tinstset)
+ti = TTextInstSet('A@2019-09-08', 'B@2019-09-09', 'B@2019-09-10')
+print(tinstset)
+ti = TTextInstSet(['A@2019-09-08', 'B@2019-09-09', 'B@2019-09-10'])
+print(tinstset)
+t1 = TTextInst('A@2019-09-08')
+t2 = TTextInst('B@2019-09-09')
+t3 = TTextInst('B@2019-09-10')
+ti = TTextInstSet(t1, t2, t3)
+print(tinstset)
+ti = TTextInstSet([t1, t2, t3])
+print(tinstset)
+
+print("\nConstructors for TTextSeq")
+seq = TTextSeq('[A@2019-09-08, B@2019-09-09, B@2019-09-10]')
+print(seq)
+seq = TTextSeq(['A@2019-09-08', 'B@2019-09-09', 'B@2019-09-10'])
+print(seq)
+seq = TTextSeq([t1, t2, t3])
+print(seq)
+seq = TTextSeq([t1, t2, t3], False, True)
+print(seq)
+
+print("\nConstructors for TTextSeqSet")
+ts = TTextSeqSet('{[A@2019-09-08, B@2019-09-09, B@2019-09-10],[B@2019-09-11, C@2019-09-12]}')
+print(ts)
+ts = TTextSeqSet(['[A@2019-09-08, B@2019-09-09, B@2019-09-10]', '[B@2019-09-11, C@2019-09-12]'])
+print(ts)
+seq1 = TTextSeq('[A@2019-09-08, B@2019-09-09, B@2019-09-10]')
+seq2 = TTextSeq('[B@2019-09-11, C@2019-09-12]')
+ts = TTextSeqSet([seq1, seq2])
+print(ts)
+
+print("\n__class__ ")
+print(inst.__class__.__name__)
+print(ti.__class__.__name__)
+print(seq.__class__.__name__)
+print(ts.__class__.__name__)
+
+print("\n__bases__ ")
+print(inst.__class__.__bases__)
+print(ti.__class__.__bases__)
+print(seq.__class__.__bases__)
+print(ts.__class__.__bases__)
+
+print("\ntempSubtype")
+print(inst.tempSubtype())
+print(ti.tempSubtype())
+print(seq.tempSubtype())
+print(ts.tempSubtype())
+
+print("\ninterpolation")
+print(seq.interpolation)
+print(ts.interpolation)
+
+print("\ngetValue")
+print(inst.getValue)
+
+print("\ngetValues")
+print(inst.getValues)
+print(ti.getValues)
+print(seq.getValues)
+print(ts.getValues)
+
+print("\nstartValue")
+print(inst.startValue)
+print(ti.startValue)
+print(seq.startValue)
+print(ts.startValue)
+
+print("\nendValue")
+print(inst.endValue)
+print(ti.endValue)
+print(seq.endValue)
+print(ts.endValue)
+
+print("\nminValue")
+print(inst.minValue)
+print(ti.minValue)
+print(seq.minValue)
+print(ts.minValue)
+
+print("\nmaxValue")
+print(inst.maxValue)
+print(ti.maxValue)
+print(seq.maxValue)
+print(ts.maxValue)
+
+print("\ngetTimestamp")
+print(inst.getTimestamp)
+
+print("\ngetTime")
+print(inst.getTime)
+print(ti.getTime)
+print(seq.getTime)
+print(ts.getTime)
+
+print("\nduration")
+print(inst.duration)
+print(ti.duration)
+print(seq.duration)
+print(ts.duration)
+
+print("\ntimespan")
+print(inst.timespan)
+print(ti.timespan)
+print(seq.timespan)
+print(ts.timespan)
+
+print("\nperiod")
+print(inst.period)
+print(ti.period)
+print(seq.period)
+print(ts.period)
+
+print("\nnumInstants")
+print(inst.numInstants)
+print(ti.numInstants)
+print(seq.numInstants)
+print(ts.numInstants)
+
+print("\nstartInstant")
+print(inst.startInstant)
+print(ti.startInstant)
+print(seq.startInstant)
+print(ts.startInstant)
+
+print("\nendInstant")
+print(inst.endInstant)
+print(ti.endInstant)
+print(seq.endInstant)
+print(ts.endInstant)
+
+print("\ninstantN")
+print(inst.instantN(1))
+print(ti.instantN(1))
+print(seq.instantN(1))
+print(ts.instantN(1))
+
+print("\ninstants")
+print(inst.instants)
+print(ti.instants)
+print(seq.instants)
+print(ts.instants)
+
+print("\nnumTimestamps")
+print(inst.numTimestamps)
+print(ti.numTimestamps)
+print(seq.numTimestamps)
+print(ts.numTimestamps)
+
+print("\nstartTimestamp")
+print(inst.startTimestamp)
+print(ti.startTimestamp)
+print(seq.startTimestamp)
+print(ts.startTimestamp)
+
+print("\nendTimestamp")
+print(inst.endTimestamp)
+print(ti.endTimestamp)
+print(seq.endTimestamp)
+print(ts.endTimestamp)
+
+print("\ntimestampN")
+print(inst.timestampN(1))
+print(ti.timestampN(1))
+print(seq.timestampN(1))
+print(ts.timestampN(1))
+
+print("\ntimestamps")
+print(inst.timestamps)
+print(ti.timestamps)
+print(seq.timestamps)
+print(ts.timestamps)
+
+print("\nnumSequences")
+print(seq.numSequences)
+print(ts.numSequences)
+
+print("\nstartSequence")
+print(seq.startSequence)
+print(ts.startSequence)
+
+print("\nendSequence")
+print(seq.endSequence)
+print(ts.endSequence)
+
+print("\nsequenceN")
+print(seq.sequenceN(1))
+print(ts.sequenceN(1))
+
+print("\nsequences")
+print(seq.sequences)
+print(ts.sequences)
+
+print("\nshift")
+print(inst.shift(timedelta(days=1)))
+print(ti.shift(timedelta(days=1)))
+print(seq.shift(timedelta(days=1)))
+print(ts.shift(timedelta(days=1)))
+
+print("\nintersectsTimestamp")
+t = datetime.strptime('2019-09-09', '%Y-%m-%d')
+print(inst.intersectsTimestamp(t))
+print(ti.intersectsTimestamp(t))
+print(seq.intersectsTimestamp(t))
+print(ts.intersectsTimestamp(t))
+
+print("\nintersectsTimestampSet")
+tss = TimestampSet('{2019-09-09, 2019-09-10}')
+print(inst.intersectsTimestampSet(tss))
+print(ti.intersectsTimestampSet(tss))
+print(seq.intersectsTimestampSet(tss))
+print(ts.intersectsTimestampSet(tss))
+
+print("\nintersectsPeriod")
+p = Period('2019-09-09', '2019-09-10', True, True)
+print(inst.intersectsPeriod(p))
+print(ti.intersectsPeriod(p))
+print(seq.intersectsPeriod(p))
+print(ts.intersectsPeriod(p))
+
+print("\nintersectsPeriodSet")
+ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
+print(inst.intersectsPeriodSet(ps))
+print(ti.intersectsPeriodSet(ps))
+print(seq.intersectsPeriodSet(ps))
+print(ts.intersectsPeriodSet(ps))
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tint_asyncpg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tfloat_asyncpg.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,194 +1,194 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncio
-import asyncpg
-from mobilitydb.asyncpg import register
-from mobilitydb.examples.db_connect import asyncpg_connect
-
-
-async def run():
-
-    # Set the connection parameters to PostgreSQL
-    connection = await asyncpg_connect()
-
-    try:
-        # Register MobilityDB data types
-        await register(connection)
-
-        ######################
-        # TIntInst
-        ######################
-
-        select_query = "select * from tbl_tintinst order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tintinst table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tintinst =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinst_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tintinst_temp
-            (
-              k integer PRIMARY KEY,
-              temp tint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tintinst_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tintinst table")
-
-        ######################
-        # TIntI
-        ######################
-
-        select_query = "select * from tbl_tinti order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tinti table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tinti =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinstset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tintinstset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tintinstset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tintinstset_temp table")
-
-        ######################
-        # TIntSeq
-        ######################
-    
-        select_query = "select * from tbl_tintseq order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tintseq table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tintseq =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseq_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tintseq_temp
-            (
-              k integer PRIMARY KEY,
-              temp tint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tintseq_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tintseq_temp table")
-
-        ######################
-        # TIntS
-        ######################
-    
-        select_query = "select * from tbl_tints order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tints table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tints =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseqset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tintseqset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tintseqset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tintseqset_temp table")
-    
-        print("\n****************************************************************")
-
-    finally:
-        await connection.close()
-
-loop = asyncio.get_event_loop()
-loop.run_until_complete(run())
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+import asyncpg
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TFloatInst
+        ######################
+
+        select_query = "select * from tbl_tfloatinst order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tfloatinst table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tfloatinst =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinst_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tfloatinst_temp
+            (
+              k integer PRIMARY KEY,
+              temp tfloat
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tfloatinst_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tfloatinst table")
+
+        ######################
+        # TFloatI
+        ######################
+
+        select_query = "select * from tbl_tfloati order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tfloati table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tfloati =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinstset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tfloatinstset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tfloat
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tfloatinstset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tfloatinstset_temp table")
+
+        ######################
+        # TFloatSeq
+        ######################
+    
+        select_query = "select * from tbl_tfloatseq order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tfloatseq table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tfloatseq =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseq_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tfloatseq_temp
+            (
+              k integer PRIMARY KEY,
+              temp tfloat
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tfloatseq_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tfloatseq_temp table")
+
+        ######################
+        # TFloatS
+        ######################
+    
+        select_query = "select * from tbl_tfloats order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tfloats table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tfloats =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseqset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tfloatseqset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tfloat
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tfloatseqset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tfloatseqset_temp table")
+    
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/db_connect.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/db_connect.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncpg
-import psycopg2
-import os
-    
-_pghost = os.getenv('PGHOST', 'localhost')
-_pgdb = os.getenv('PGDATABASE', 'regtests')
-_pguser = os.getenv('PGUSER', 'mobilitydb')
-_pgpassword = os.getenv('PGPASSWORD', '')
-
-def asyncpg_connect():
-    return asyncpg.connect(host=_pghost, database=_pgdb, user=_pguser, password=_pgpassword)
-
-def psycopg_connect():
-    return psycopg2.connect(host=_pghost, database=_pgdb, user=_pguser, password=_pgpassword)
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncpg
+import psycopg2
+import os
+    
+_pghost = os.getenv('PGHOST', 'localhost')
+_pgdb = os.getenv('PGDATABASE', 'regtests')
+_pguser = os.getenv('PGUSER', 'mobilitydb')
+_pgpassword = os.getenv('PGPASSWORD', '')
+
+def asyncpg_connect():
+    return asyncpg.connect(host=_pghost, database=_pgdb, user=_pguser, password=_pgpassword)
+
+def psycopg_connect():
+    return psycopg2.connect(host=_pghost, database=_pgdb, user=_pguser, password=_pgpassword)
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tbool_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tbool_psycopg.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,212 +1,212 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TBoolInst
-    ######################
-
-    select_query = "select * from tbl_tboolinst order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tboolinst table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tboolinst =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolinst_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tboolinst_temp
-        (
-          k integer PRIMARY KEY,
-          temp tbool
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tboolinst_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tboolinst_temp table")
-
-    ######################
-    # TBoolInstSet
-    ######################
-
-    select_query = "select * from tbl_tboolinstset order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tbooli table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tboolinstset =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolinstset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tboolinstset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tbool
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tboolinstset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tboolinstset_temp table")
-
-    ######################
-    # TBoolSeq
-    ######################
-
-    select_query = "select * from tbl_tboolseq order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tboolseq table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tboolseq =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolseq_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tboolseq_temp
-        (
-          k integer PRIMARY KEY,
-          temp tbool
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tboolseq_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tboolseq_temp table")
-
-    ######################
-    # TBoolS
-    ######################
-
-    select_query = "select * from tbl_tboolseqset order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tbools table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tbools =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolseqset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tboolseqset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tbool
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tboolseqset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tboolseqset_temp table")
-
-    print("\n****************************************************************")
-
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connection:
-        connection.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import psycopg2
+from mobilitydb.psycopg import register
+from mobilitydb.examples.db_connect import psycopg_connect
+
+connection = None
+
+try:
+    # Set the connection parameters to PostgreSQL
+    connection = psycopg_connect()
+    connection.autocommit = True
+
+    # Register MobilityDB data types
+    register(connection)
+
+    cursor = connection.cursor()
+
+    ######################
+    # TBoolInst
+    ######################
+
+    select_query = "select * from tbl_tboolinst order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tboolinst table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tboolinst =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolinst_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tboolinst_temp
+        (
+          k integer PRIMARY KEY,
+          temp tbool
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tboolinst_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tboolinst_temp table")
+
+    ######################
+    # TBoolInstSet
+    ######################
+
+    select_query = "select * from tbl_tboolinstset order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tbooli table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tboolinstset =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolinstset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tboolinstset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tbool
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tboolinstset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tboolinstset_temp table")
+
+    ######################
+    # TBoolSeq
+    ######################
+
+    select_query = "select * from tbl_tboolseq order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tboolseq table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tboolseq =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolseq_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tboolseq_temp
+        (
+          k integer PRIMARY KEY,
+          temp tbool
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tboolseq_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tboolseq_temp table")
+
+    ######################
+    # TBoolS
+    ######################
+
+    select_query = "select * from tbl_tboolseqset order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tbools table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tbools =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolseqset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tboolseqset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tbool
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tboolseqset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tboolseqset_temp table")
+
+    print("\n****************************************************************")
+
+
+except (Exception, psycopg2.Error) as error:
+    print("Error while connecting to PostgreSQL", error)
+
+finally:
+
+    if connection:
+        connection.close()
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/time_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tint_asyncpg.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,168 +1,194 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TimestampSet
-    ######################
-
-    select_query = "SELECT * FROM tbl_timestampset ORDER BY k LIMIT 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_timestampset table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("timestampset =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("duration =", row[1].duration, "\n")
-
-    drop_table_query = "DROP TABLE IF EXISTS tbl_timestampset_temp;"
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL")
-
-    create_table_query = '''CREATE TABLE tbl_timestampset_temp
-    (
-      k integer PRIMARY KEY,
-      ts timestampset
-    ); '''
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL")
-
-    insert_query = "INSERT INTO tbl_timestampset_temp (k, ts) VALUES (%s, %s)"
-    result = cursor.executemany(insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_timestampset_temp table")
-
-    ######################
-    # Period
-    ######################
-
-    select_query = "SELECT * FROM tbl_period ORDER BY k LIMIT 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_period table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("period =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("duration =", row[1].duration, "\n")
-
-    drop_table_query = "DROP TABLE IF EXISTS tbl_period_temp;"
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL")
-
-    create_table_query = '''CREATE TABLE tbl_period_temp
-    (
-      k integer PRIMARY KEY,
-      p period
-    ); '''
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL")
-
-    insert_query = "INSERT INTO tbl_period_temp (k, p) VALUES (%s, %s)"
-    result = cursor.executemany(insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_period_temp table")
-
-    ######################
-    # PeriodSet
-    ######################
-
-    select_query = "SELECT * FROM tbl_periodset ORDER BY k LIMIT 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_periodset table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("periodset =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("duration =", row[1].duration, "\n")
-
-    drop_table_query = "DROP TABLE IF EXISTS tbl_periodset_temp;"
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL")
-
-    create_table_query = '''CREATE TABLE tbl_periodset_temp
-    (
-      k integer PRIMARY KEY,
-      ps periodset
-    ); '''
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL")
-
-    insert_query = "INSERT INTO tbl_periodset_temp (k, ps) VALUES (%s, %s)"
-    result = cursor.executemany(insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_periodset_temp table")
-
-    print("\n****************************************************************")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connection:
-        connection.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+import asyncpg
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TIntInst
+        ######################
+
+        select_query = "select * from tbl_tintinst order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tintinst table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tintinst =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinst_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tintinst_temp
+            (
+              k integer PRIMARY KEY,
+              temp tint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tintinst_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tintinst table")
+
+        ######################
+        # TIntI
+        ######################
+
+        select_query = "select * from tbl_tinti order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tinti table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tinti =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinstset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tintinstset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tintinstset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tintinstset_temp table")
+
+        ######################
+        # TIntSeq
+        ######################
+    
+        select_query = "select * from tbl_tintseq order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tintseq table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tintseq =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseq_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tintseq_temp
+            (
+              k integer PRIMARY KEY,
+              temp tint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tintseq_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tintseq_temp table")
+
+        ######################
+        # TIntS
+        ######################
+    
+        select_query = "select * from tbl_tints order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tints table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tints =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseqset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tintseqset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tintseqset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tintseqset_temp table")
+    
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tgeogpoint.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tgeompoint.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,265 +1,266 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from postgis import Point, MultiPoint, LineString, MultiLineString, GeometryCollection
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main.tpoint import TGeogPointInst, TGeogPointInstSet, TGeogPointSeq, TGeogPointSeqSet
-
-
-print("\nConstructors for TGeogPointInst")
-inst = TGeogPointInst('Point(10 10)@2019-09-08')
-print(inst)
-inst = TGeogPointInst('Point(10 10)', '2019-09-08')
-print(inst)
-p = Point(10,10)
-t = parse('2019-09-08')
-inst = TGeogPointInst(p, t)
-print(inst)
-
-print("\nConstructors for TGeogPointInstSet")
-ti = TGeogPointInstSet('{Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10}')
-print(tinstset)
-ti = TGeogPointInstSet('Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10')
-print(tinstset)
-ti = TGeogPointInstSet(['Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10'])
-print(tinstset)
-t1 = TGeogPointInst('Point(10 10)@2019-09-08')
-t2 = TGeogPointInst('Point(20 20)@2019-09-09')
-t3 = TGeogPointInst('Point(20 20)@2019-09-10')
-ti = TGeogPointInstSet(t1, t2, t3)
-print(tinstset)
-ti = TGeogPointInstSet([t1, t2, t3])
-print(tinstset)
-
-print("\nConstructors for TGeogPointSeq")
-seq = TGeogPointSeq('[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10]')
-print(seq)
-seq = TGeogPointSeq(['Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10'])
-print(seq)
-seq = TGeogPointSeq([t1, t2, t3])
-print(seq)
-seq = TGeogPointSeq([t1, t2, t3], False, True)
-print(seq)
-
-print("\nConstructors for TGeogPointSeqSet")
-ts = TGeogPointSeqSet('{[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10],[Point(15 15)@2019-09-11, Point(30 30)@2019-09-12]}')
-print(ts)
-seq1 = TGeogPointSeq('[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10]')
-seq2 = TGeogPointSeq('[Point(15 15)@2019-09-11, Point(30 30)@2019-09-12]')
-ts = TGeogPointSeqSet([seq1, seq2])
-print(ts)
-
-print("\n__class__ ")
-print(inst.__class__.__name__)
-print(ti.__class__.__name__)
-print(seq.__class__.__name__)
-print(ts.__class__.__name__)
-
-print("\n__bases__ ")
-print(inst.__class__.__bases__)
-print(ti.__class__.__bases__)
-print(seq.__class__.__bases__)
-print(ts.__class__.__bases__)
-
-print("\ntempSubtype")
-print(inst.tempSubtype())
-print(ti.tempSubtype())
-print(seq.tempSubtype())
-print(ts.tempSubtype())
-
-print("\ninterpolation")
-print(seq.interpolation)
-print(ts.interpolation)
-
-print("\ngetValue")
-print(inst.getValue)
-
-print("\ngetValues")
-print(inst.getValues)
-print(ti.getValues)
-print(seq.getValues)
-print(ts.getValues)
-
-print("\nstartValue")
-print(inst.startValue)
-print(ti.startValue)
-print(seq.startValue)
-print(ts.startValue)
-
-print("\nendValue")
-print(inst.endValue)
-print(ti.endValue)
-print(seq.endValue)
-print(ts.endValue)
-
-print("\ngetTimestamp")
-print(inst.getTimestamp)
-
-print("\ngetTime")
-print(inst.getTime)
-print(ti.getTime)
-print(seq.getTime)
-print(ts.getTime)
-
-print("\nduration")
-print(inst.duration)
-print(ti.duration)
-print(seq.duration)
-print(ts.duration)
-
-print("\ntimespan")
-print(inst.timespan)
-print(ti.timespan)
-print(seq.timespan)
-print(ts.timespan)
-
-print("\nperiod")
-print(inst.period)
-print(ti.period)
-print(seq.period)
-print(ts.period)
-
-print("\nnumInstants")
-print(inst.numInstants)
-print(ti.numInstants)
-print(seq.numInstants)
-print(ts.numInstants)
-
-print("\nstartInstant")
-print(inst.startInstant)
-print(ti.startInstant)
-print(seq.startInstant)
-print(ts.startInstant)
-
-print("\nendInstant")
-print(inst.endInstant)
-print(ti.endInstant)
-print(seq.endInstant)
-print(ts.endInstant)
-
-print("\ninstantN")
-print(inst.instantN(1))
-print(ti.instantN(1))
-print(seq.instantN(1))
-print(ts.instantN(1))
-
-print("\ninstants")
-print(inst.instants)
-print(ti.instants)
-print(seq.instants)
-print(ts.instants)
-
-print("\nnumTimestamps")
-print(inst.numTimestamps)
-print(ti.numTimestamps)
-print(seq.numTimestamps)
-print(ts.numTimestamps)
-
-print("\nstartTimestamp")
-print(inst.startTimestamp)
-print(ti.startTimestamp)
-print(seq.startTimestamp)
-print(ts.startTimestamp)
-
-print("\nendTimestamp")
-print(inst.endTimestamp)
-print(ti.endTimestamp)
-print(seq.endTimestamp)
-print(ts.endTimestamp)
-
-print("\ntimestampN")
-print(inst.timestampN(1))
-print(ti.timestampN(1))
-print(seq.timestampN(1))
-print(ts.timestampN(1))
-
-print("\ntimestamps")
-print(inst.timestamps)
-print(ti.timestamps)
-print(seq.timestamps)
-print(ts.timestamps)
-
-print("\nnumSequences")
-print(seq.numSequences)
-print(ts.numSequences)
-
-print("\nstartSequence")
-print(seq.startSequence)
-print(ts.startSequence)
-
-print("\nendSequence")
-print(seq.endSequence)
-print(ts.endSequence)
-
-print("\nsequenceN")
-print(seq.sequenceN(1))
-print(ts.sequenceN(1))
-
-print("\nsequences")
-print(seq.sequences)
-print(ts.sequences)
-
-print("\nshift")
-print(inst.shift(timedelta(days=1)))
-print(ti.shift(timedelta(days=1)))
-print(seq.shift(timedelta(days=1)))
-print(ts.shift(timedelta(days=1)))
-
-print("\nintersectsTimestamp")
-t = datetime.strptime('2019-09-09', '%Y-%m-%d')
-print(inst.intersectsTimestamp(t))
-print(ti.intersectsTimestamp(t))
-print(seq.intersectsTimestamp(t))
-print(ts.intersectsTimestamp(t))
-
-print("\nintersectsTimestampSet")
-tss = TimestampSet('{2019-09-09, 2019-09-10}')
-print(inst.intersectsTimestampSet(tss))
-print(ti.intersectsTimestampSet(tss))
-print(seq.intersectsTimestampSet(tss))
-print(ts.intersectsTimestampSet(tss))
-
-print("\nintersectsPeriod")
-p = Period('2019-09-09', '2019-09-10', True, True)
-print(inst.intersectsPeriod(p))
-print(ti.intersectsPeriod(p))
-print(seq.intersectsPeriod(p))
-print(ts.intersectsPeriod(p))
-
-print("\nintersectsPeriodSet")
-ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
-print(inst.intersectsPeriodSet(ps))
-print(ti.intersectsPeriodSet(ps))
-print(seq.intersectsPeriodSet(ps))
-print(ts.intersectsPeriodSet(ps))
-
-print("\nsrid")
-print(inst.srid)
-print(ti.srid)
-print(seq.srid)
-print(ts.srid)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from postgis import Point, MultiPoint, LineString, MultiLineString, GeometryCollection
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main.tpoint import TGeomPointInst, TGeomPointInstSet, TGeomPointSeq, TGeomPointSeqSet
+
+
+print("\nConstructors for TGeomPointInst")
+inst = TGeomPointInst('Point(10 10)@2019-09-08')
+print(inst)
+inst = TGeomPointInst('Point(10 10)', '2019-09-08')
+print(inst)
+p = Point(10,10)
+t = parse('2019-09-08')
+inst = TGeomPointInst(p, t)
+print(inst)
+
+print("\nConstructors for TGeomPointInstSet")
+ti = TGeomPointInstSet('{Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10}')
+print(tinstset)
+ti = TGeomPointInstSet(['Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10'])
+print(tinstset)
+t1 = TGeomPointInst('Point(10 10)@2019-09-08')
+t2 = TGeomPointInst('Point(20 20)@2019-09-09')
+t3 = TGeomPointInst('Point(20 20)@2019-09-10')
+ti = TGeomPointInstSet([t1, t2, t3])
+print(tinstset)
+ti = TGeomPointInstSet([t1, t2, t3], srid=4326)
+print(tinstset)
+
+print("\nConstructors for TGeomPointSeq")
+seq = TGeomPointSeq('[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10]')
+print(seq)
+seq = TGeomPointSeq(['Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10'])
+print(seq)
+seq = TGeomPointSeq([t1, t2, t3])
+print(seq)
+seq = TGeomPointSeq([t1, t2, t3], False, True, srid=4326)
+print(seq)
+
+print("\nConstructors for TGeomPointSeqSet")
+ts = TGeomPointSeqSet('{[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10],[Point(15 15)@2019-09-11, Point(30 30)@2019-09-12]}')
+print(ts)
+ts = TGeomPointSeqSet(['[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10]', '[Point(15 15)@2019-09-11, Point(30 30)@2019-09-12]'])
+print(ts)
+seq1 = TGeomPointSeq('[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10]')
+seq2 = TGeomPointSeq('[Point(15 15)@2019-09-11, Point(30 30)@2019-09-12]')
+ts = TGeomPointSeqSet([seq1, seq2])
+print(ts)
+
+print("\n__class__ ")
+print(inst.__class__.__name__)
+print(ti.__class__.__name__)
+print(seq.__class__.__name__)
+print(ts.__class__.__name__)
+
+print("\n__bases__ ")
+print(inst.__class__.__bases__)
+print(ti.__class__.__bases__)
+print(seq.__class__.__bases__)
+print(ts.__class__.__bases__)
+
+print("\ntempSubtype")
+print(inst.tempSubtype())
+print(ti.tempSubtype())
+print(seq.tempSubtype())
+print(ts.tempSubtype())
+
+print("\ninterpolation")
+print(seq.interpolation)
+print(ts.interpolation)
+
+print("\ngetValue")
+print(inst.getValue)
+
+print("\ngetValues")
+print(inst.getValues)
+print(ti.getValues)
+print(seq.getValues)
+print(ts.getValues)
+
+print("\nstartValue")
+print(inst.startValue)
+print(ti.startValue)
+print(seq.startValue)
+print(ts.startValue)
+
+print("\nendValue")
+print(inst.endValue)
+print(ti.endValue)
+print(seq.endValue)
+print(ts.endValue)
+
+print("\ngetTimestamp")
+print(inst.getTimestamp)
+
+print("\ngetTime")
+print(inst.getTime)
+print(ti.getTime)
+print(seq.getTime)
+print(ts.getTime)
+
+print("\nduration")
+print(inst.duration)
+print(ti.duration)
+print(seq.duration)
+print(ts.duration)
+
+print("\ntimespan")
+print(inst.timespan)
+print(ti.timespan)
+print(seq.timespan)
+print(ts.timespan)
+
+print("\nperiod")
+print(inst.period)
+print(ti.period)
+print(seq.period)
+print(ts.period)
+
+print("\nnumInstants")
+print(inst.numInstants)
+print(ti.numInstants)
+print(seq.numInstants)
+print(ts.numInstants)
+
+print("\nstartInstant")
+print(inst.startInstant)
+print(ti.startInstant)
+print(seq.startInstant)
+print(ts.startInstant)
+
+print("\nendInstant")
+print(inst.endInstant)
+print(ti.endInstant)
+print(seq.endInstant)
+print(ts.endInstant)
+
+print("\ninstantN")
+print(inst.instantN(1))
+print(ti.instantN(1))
+print(seq.instantN(1))
+print(ts.instantN(1))
+
+print("\ninstants")
+print(inst.instants)
+print(ti.instants)
+print(seq.instants)
+print(ts.instants)
+
+print("\nnumTimestamps")
+print(inst.numTimestamps)
+print(ti.numTimestamps)
+print(seq.numTimestamps)
+print(ts.numTimestamps)
+
+print("\nstartTimestamp")
+print(inst.startTimestamp)
+print(ti.startTimestamp)
+print(seq.startTimestamp)
+print(ts.startTimestamp)
+
+print("\nendTimestamp")
+print(inst.endTimestamp)
+print(ti.endTimestamp)
+print(seq.endTimestamp)
+print(ts.endTimestamp)
+
+print("\ntimestampN")
+print(inst.timestampN(1))
+print(ti.timestampN(1))
+print(seq.timestampN(1))
+print(ts.timestampN(1))
+
+print("\ntimestamps")
+print(inst.timestamps)
+print(ti.timestamps)
+print(seq.timestamps)
+print(ts.timestamps)
+
+print("\nnumSequences")
+print(seq.numSequences)
+print(ts.numSequences)
+
+print("\nstartSequence")
+print(seq.startSequence)
+print(ts.startSequence)
+
+print("\nendSequence")
+print(seq.endSequence)
+print(ts.endSequence)
+
+print("\nsequenceN")
+print(seq.sequenceN(1))
+print(ts.sequenceN(1))
+
+print("\nsequences")
+print(seq.sequences)
+print(ts.sequences)
+
+print("\nshift")
+print(inst.shift(timedelta(days=1)))
+print(ti.shift(timedelta(days=1)))
+print(seq.shift(timedelta(days=1)))
+print(ts.shift(timedelta(days=1)))
+
+print("\nintersectsTimestamp")
+t = datetime.strptime('2019-09-09', '%Y-%m-%d')
+print(inst.intersectsTimestamp(t))
+print(ti.intersectsTimestamp(t))
+print(seq.intersectsTimestamp(t))
+print(ts.intersectsTimestamp(t))
+
+print("\nintersectsTimestampSet")
+tss = TimestampSet('{2019-09-09, 2019-09-10}')
+print(inst.intersectsTimestampSet(tss))
+print(ti.intersectsTimestampSet(tss))
+print(seq.intersectsTimestampSet(tss))
+print(ts.intersectsTimestampSet(tss))
+
+print("\nintersectsPeriod")
+p = Period('2019-09-09', '2019-09-10', True, True)
+print(inst.intersectsPeriod(p))
+print(ti.intersectsPeriod(p))
+print(seq.intersectsPeriod(p))
+print(ts.intersectsPeriod(p))
+
+print("\nintersectsPeriodSet")
+ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
+print(inst.intersectsPeriodSet(ps))
+print(ti.intersectsPeriodSet(ps))
+print(seq.intersectsPeriodSet(ps))
+print(ts.intersectsPeriodSet(ps))
+
+print("\nsrid")
+print(inst.srid)
+print(ti.srid)
+print(seq.srid)
+print(ts.srid)
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tfloat.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tfloat.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,365 +1,365 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TFloat, TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
-
-
-print("\nConstructors for TFloatInst")
-inst = TFloatInst('10@2019-09-08')
-print(inst)
-inst = TFloatInst('10', '2019-09-08')
-print(inst)
-t = parse('2019-09-08')
-inst = TFloatInst(10.0, t)
-print(inst)
-
-print("\nConstructors for TFloatInstSet")
-ti = TFloatInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
-print(tinstset)
-ti = TFloatInstSet('10@2019-09-08', '20@2019-09-09', '20@2019-09-10')
-print(tinstset)
-ti = TFloatInstSet(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
-print(tinstset)
-t1 = TFloatInst('10@2019-09-08')
-t2 = TFloatInst('20@2019-09-09')
-t3 = TFloatInst('20@2019-09-10')
-ti = TFloatInstSet(t1, t2, t3)
-print(tinstset)
-ti = TFloatInstSet([t1, t2, t3])
-print(tinstset)
-
-print("\nConstructors for TFloatSeq")
-seq = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-print(seq)
-seq = TFloatSeq(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
-print(seq)
-seq = TFloatSeq([t1, t2, t3])
-print(seq)
-seq = TFloatSeq([t1, t2, t3], False, True)
-print(seq)
-
-print("\nConstructors for TFloatSeqSet")
-ts = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[15@2019-09-11, 30@2019-09-12]}')
-print(ts)
-ts = TFloatSeqSet(['[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]', '[15@2019-09-11, 30@2019-09-12]'])
-print(ts)
-seq1 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-seq2 = TFloatSeq('[15@2019-09-11, 30@2019-09-12]')
-ts = TFloatSeqSet([seq1, seq2])
-print(ts)
-
-print("\n__class__ ")
-print(inst.__class__.__name__)
-print(ti.__class__.__name__)
-print(seq.__class__.__name__)
-print(ts.__class__.__name__)
-
-print("\n__bases__ ")
-print(inst.__class__.__bases__)
-print(ti.__class__.__bases__)
-print(seq.__class__.__bases__)
-print(ts.__class__.__bases__)
-
-print("\nRepresentation")
-print(repr(inst))
-print(repr(tinstset))
-print(repr(seq))
-print(repr(ts))
-
-print("\ntempSubtype")
-print(inst.tempSubtype())
-print(ti.tempSubtype())
-print(seq.tempSubtype())
-print(ts.tempSubtype())
-
-print("\ninterpolation")
-print(seq.interpolation)
-print(ts.interpolation)
-
-print("\ngetValue")
-print(inst.getValue)
-
-print("\ngetValues")
-print(inst.getValues)
-print(ti.getValues)
-print(seq.getValues)
-print(ts.getValues)
-
-print("\nstartValue")
-print(inst.startValue)
-print(ti.startValue)
-print(seq.startValue)
-print(ts.startValue)
-
-print("\nendValue")
-print(inst.endValue)
-print(ti.endValue)
-print(seq.endValue)
-print(ts.endValue)
-
-print("\nminValue")
-print(inst.minValue)
-print(ti.minValue)
-print(seq.minValue)
-print(ts.minValue)
-
-print("\nmaxValue")
-print(inst.maxValue)
-print(ti.maxValue)
-print(seq.maxValue)
-print(ts.maxValue)
-
-print("\nvalueRange")
-print(inst.valueRange)
-print(ti.valueRange)
-print(seq.valueRange)
-print(ts.valueRange)
-
-print("\ngetTimestamp")
-print(inst.getTimestamp)
-
-print("\ngetTime")
-print(inst.getTime)
-print(ti.getTime)
-print(seq.getTime)
-print(ts.getTime)
-
-print("\nduration")
-print(inst.duration)
-print(ti.duration)
-print(seq.duration)
-print(ts.duration)
-
-print("\ntimespan")
-print(inst.timespan)
-print(ti.timespan)
-print(seq.timespan)
-print(ts.timespan)
-
-print("\nperiod")
-print(inst.period)
-print(ti.period)
-print(seq.period)
-print(ts.period)
-
-print("\nnumInstants")
-print(inst.numInstants)
-print(ti.numInstants)
-print(seq.numInstants)
-print(ts.numInstants)
-
-print("\nstartInstant")
-print(inst.startInstant)
-print(ti.startInstant)
-print(seq.startInstant)
-print(ts.startInstant)
-
-print("\nendInstant")
-print(inst.endInstant)
-print(ti.endInstant)
-print(seq.endInstant)
-print(ts.endInstant)
-
-print("\ninstantN")
-print(inst.instantN(1))
-print(ti.instantN(1))
-print(seq.instantN(1))
-print(ts.instantN(1))
-
-print("\ninstants")
-print(inst.instants)
-print(ti.instants)
-print(seq.instants)
-print(ts.instants)
-
-print("\nnumTimestamps")
-print(inst.numTimestamps)
-print(ti.numTimestamps)
-print(seq.numTimestamps)
-print(ts.numTimestamps)
-
-print("\nstartTimestamp")
-print(inst.startTimestamp)
-print(ti.startTimestamp)
-print(seq.startTimestamp)
-print(ts.startTimestamp)
-
-print("\nendTimestamp")
-print(inst.endTimestamp)
-print(ti.endTimestamp)
-print(seq.endTimestamp)
-print(ts.endTimestamp)
-
-print("\ntimestampN")
-print(inst.timestampN(1))
-print(ti.timestampN(1))
-print(seq.timestampN(1))
-print(ts.timestampN(1))
-
-print("\ntimestamps")
-print(inst.timestamps)
-print(ti.timestamps)
-print(seq.timestamps)
-print(ts.timestamps)
-
-print("\nnumSequences")
-print(seq.numSequences)
-print(ts.numSequences)
-
-print("\nstartSequence")
-print(seq.startSequence)
-print(ts.startSequence)
-
-print("\nendSequence")
-print(seq.endSequence)
-print(ts.endSequence)
-
-print("\nsequenceN")
-print(seq.sequenceN(1))
-print(ts.sequenceN(1))
-
-print("\nsequences")
-print(seq.sequences)
-print(ts.sequences)
-
-print("\nshift")
-print(inst.shift(timedelta(days=1)))
-print(ti.shift(timedelta(days=1)))
-print(seq.shift(timedelta(days=1)))
-print(ts.shift(timedelta(days=1)))
-
-print("\nintersectsTimestamp")
-t = datetime.strptime('2019-09-09', '%Y-%m-%d')
-print(inst.intersectsTimestamp(t))
-print(ti.intersectsTimestamp(t))
-print(seq.intersectsTimestamp(t))
-print(ts.intersectsTimestamp(t))
-
-print("\nintersectsTimestampSet")
-tss = TimestampSet('{2019-09-09, 2019-09-10}')
-print(inst.intersectsTimestampSet(tss))
-print(ti.intersectsTimestampSet(tss))
-print(seq.intersectsTimestampSet(tss))
-print(ts.intersectsTimestampSet(tss))
-
-print("\nintersectsPeriod")
-p = Period('2019-09-09', '2019-09-10', True, True)
-print(inst.intersectsPeriod(p))
-print(ti.intersectsPeriod(p))
-print(seq.intersectsPeriod(p))
-print(ts.intersectsPeriod(p))
-
-print("\nintersectsPeriodSet")
-ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
-print(inst.intersectsPeriodSet(ps))
-print(ti.intersectsPeriodSet(ps))
-print(seq.intersectsPeriodSet(ps))
-print(ts.intersectsPeriodSet(ps))
-
-print("\nequality for TInstant")
-inst1 = TFloatInst('1@2019-09-09')
-inst2 = TFloatInst('1.0@2019-09-09 00:00:00')
-inst3 = TFloatInst('1.1@2019-09-09')
-inst4 = TFloatInst('1@2019-09-10')
-print(inst1 == inst2)
-print(inst1 == inst3)
-print(inst1 == inst4)
-
-print("\nequality for TInstantSet")
-ti1 = TFloatInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
-ti2 = TFloatInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
-ti3 = TFloatInstSet('{10@2019-09-08, 20@2019-09-10}')
-print(ti1 == ti2)
-print(ti1 == ti3)
-
-print("\nequality for TSequence")
-seq1 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-seq2 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-seq3 = TFloatSeq('[10.1@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-seq4 = TFloatSeq('(10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-seq5 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10)')
-seq6 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]', interp='Stepwise')
-print(seq1 == seq2)
-print(seq1 == seq3)
-print(seq1 == seq4)
-print(seq1 == seq5)
-print(seq1 == seq6)
-
-print("\nequality for TSequenceSet")
-ts1 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11, 20@2019-09-12]}')
-ts2 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11, 20@2019-09-12]}')
-ts3 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11]}')
-ts4 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11, 20@2019-09-12]}', interp='Stepwise')
-print(ts1 == ts2)
-print(ts1 == ts3)
-print(ts1 == ts4)
-
-print("*** Manual ***")
-p = TFloatInstSet('{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01}')
-print(p)
-p = TFloatInstSet('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01')
-print(p)
-p = TFloatInstSet(TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01'))
-print(p)
-p = TFloatInstSet(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
-print(p)
-p = TFloatInstSet([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
-print(p)
-
-print("*** Manual ***")
-p = TFloatSeq('[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
-print(p)
-p = TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
-print(p)
-p = TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
-print(p)
-p = TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
-print(p)
-p = TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
-print(p)
-p = TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
-print(p)
-
-print("*** Manual ***")
-p = TFloatSeqSet('{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
-print(p)
-p = TFloatSeqSet('Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
-print(p)
-p = TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'])
-print(p)
-p = TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear')
-print(p)
-p = TFloatSeqSet(['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise')
-print(p)
-p = TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')])
-print(p)
-p = TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),  TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear')
-print(p)
-p = TFloatSeqSet([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise')
-print(p)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TFloat, TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
+
+
+print("\nConstructors for TFloatInst")
+inst = TFloatInst('10@2019-09-08')
+print(inst)
+inst = TFloatInst('10', '2019-09-08')
+print(inst)
+t = parse('2019-09-08')
+inst = TFloatInst(10.0, t)
+print(inst)
+
+print("\nConstructors for TFloatInstSet")
+ti = TFloatInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
+print(tinstset)
+ti = TFloatInstSet('10@2019-09-08', '20@2019-09-09', '20@2019-09-10')
+print(tinstset)
+ti = TFloatInstSet(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
+print(tinstset)
+t1 = TFloatInst('10@2019-09-08')
+t2 = TFloatInst('20@2019-09-09')
+t3 = TFloatInst('20@2019-09-10')
+ti = TFloatInstSet(t1, t2, t3)
+print(tinstset)
+ti = TFloatInstSet([t1, t2, t3])
+print(tinstset)
+
+print("\nConstructors for TFloatSeq")
+seq = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+print(seq)
+seq = TFloatSeq(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
+print(seq)
+seq = TFloatSeq([t1, t2, t3])
+print(seq)
+seq = TFloatSeq([t1, t2, t3], False, True)
+print(seq)
+
+print("\nConstructors for TFloatSeqSet")
+ts = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[15@2019-09-11, 30@2019-09-12]}')
+print(ts)
+ts = TFloatSeqSet(['[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]', '[15@2019-09-11, 30@2019-09-12]'])
+print(ts)
+seq1 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+seq2 = TFloatSeq('[15@2019-09-11, 30@2019-09-12]')
+ts = TFloatSeqSet([seq1, seq2])
+print(ts)
+
+print("\n__class__ ")
+print(inst.__class__.__name__)
+print(ti.__class__.__name__)
+print(seq.__class__.__name__)
+print(ts.__class__.__name__)
+
+print("\n__bases__ ")
+print(inst.__class__.__bases__)
+print(ti.__class__.__bases__)
+print(seq.__class__.__bases__)
+print(ts.__class__.__bases__)
+
+print("\nRepresentation")
+print(repr(inst))
+print(repr(tinstset))
+print(repr(seq))
+print(repr(ts))
+
+print("\ntempSubtype")
+print(inst.tempSubtype())
+print(ti.tempSubtype())
+print(seq.tempSubtype())
+print(ts.tempSubtype())
+
+print("\ninterpolation")
+print(seq.interpolation)
+print(ts.interpolation)
+
+print("\ngetValue")
+print(inst.getValue)
+
+print("\ngetValues")
+print(inst.getValues)
+print(ti.getValues)
+print(seq.getValues)
+print(ts.getValues)
+
+print("\nstartValue")
+print(inst.startValue)
+print(ti.startValue)
+print(seq.startValue)
+print(ts.startValue)
+
+print("\nendValue")
+print(inst.endValue)
+print(ti.endValue)
+print(seq.endValue)
+print(ts.endValue)
+
+print("\nminValue")
+print(inst.minValue)
+print(ti.minValue)
+print(seq.minValue)
+print(ts.minValue)
+
+print("\nmaxValue")
+print(inst.maxValue)
+print(ti.maxValue)
+print(seq.maxValue)
+print(ts.maxValue)
+
+print("\nvalueRange")
+print(inst.valueRange)
+print(ti.valueRange)
+print(seq.valueRange)
+print(ts.valueRange)
+
+print("\ngetTimestamp")
+print(inst.getTimestamp)
+
+print("\ngetTime")
+print(inst.getTime)
+print(ti.getTime)
+print(seq.getTime)
+print(ts.getTime)
+
+print("\nduration")
+print(inst.duration)
+print(ti.duration)
+print(seq.duration)
+print(ts.duration)
+
+print("\ntimespan")
+print(inst.timespan)
+print(ti.timespan)
+print(seq.timespan)
+print(ts.timespan)
+
+print("\nperiod")
+print(inst.period)
+print(ti.period)
+print(seq.period)
+print(ts.period)
+
+print("\nnumInstants")
+print(inst.numInstants)
+print(ti.numInstants)
+print(seq.numInstants)
+print(ts.numInstants)
+
+print("\nstartInstant")
+print(inst.startInstant)
+print(ti.startInstant)
+print(seq.startInstant)
+print(ts.startInstant)
+
+print("\nendInstant")
+print(inst.endInstant)
+print(ti.endInstant)
+print(seq.endInstant)
+print(ts.endInstant)
+
+print("\ninstantN")
+print(inst.instantN(1))
+print(ti.instantN(1))
+print(seq.instantN(1))
+print(ts.instantN(1))
+
+print("\ninstants")
+print(inst.instants)
+print(ti.instants)
+print(seq.instants)
+print(ts.instants)
+
+print("\nnumTimestamps")
+print(inst.numTimestamps)
+print(ti.numTimestamps)
+print(seq.numTimestamps)
+print(ts.numTimestamps)
+
+print("\nstartTimestamp")
+print(inst.startTimestamp)
+print(ti.startTimestamp)
+print(seq.startTimestamp)
+print(ts.startTimestamp)
+
+print("\nendTimestamp")
+print(inst.endTimestamp)
+print(ti.endTimestamp)
+print(seq.endTimestamp)
+print(ts.endTimestamp)
+
+print("\ntimestampN")
+print(inst.timestampN(1))
+print(ti.timestampN(1))
+print(seq.timestampN(1))
+print(ts.timestampN(1))
+
+print("\ntimestamps")
+print(inst.timestamps)
+print(ti.timestamps)
+print(seq.timestamps)
+print(ts.timestamps)
+
+print("\nnumSequences")
+print(seq.numSequences)
+print(ts.numSequences)
+
+print("\nstartSequence")
+print(seq.startSequence)
+print(ts.startSequence)
+
+print("\nendSequence")
+print(seq.endSequence)
+print(ts.endSequence)
+
+print("\nsequenceN")
+print(seq.sequenceN(1))
+print(ts.sequenceN(1))
+
+print("\nsequences")
+print(seq.sequences)
+print(ts.sequences)
+
+print("\nshift")
+print(inst.shift(timedelta(days=1)))
+print(ti.shift(timedelta(days=1)))
+print(seq.shift(timedelta(days=1)))
+print(ts.shift(timedelta(days=1)))
+
+print("\nintersectsTimestamp")
+t = datetime.strptime('2019-09-09', '%Y-%m-%d')
+print(inst.intersectsTimestamp(t))
+print(ti.intersectsTimestamp(t))
+print(seq.intersectsTimestamp(t))
+print(ts.intersectsTimestamp(t))
+
+print("\nintersectsTimestampSet")
+tss = TimestampSet('{2019-09-09, 2019-09-10}')
+print(inst.intersectsTimestampSet(tss))
+print(ti.intersectsTimestampSet(tss))
+print(seq.intersectsTimestampSet(tss))
+print(ts.intersectsTimestampSet(tss))
+
+print("\nintersectsPeriod")
+p = Period('2019-09-09', '2019-09-10', True, True)
+print(inst.intersectsPeriod(p))
+print(ti.intersectsPeriod(p))
+print(seq.intersectsPeriod(p))
+print(ts.intersectsPeriod(p))
+
+print("\nintersectsPeriodSet")
+ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
+print(inst.intersectsPeriodSet(ps))
+print(ti.intersectsPeriodSet(ps))
+print(seq.intersectsPeriodSet(ps))
+print(ts.intersectsPeriodSet(ps))
+
+print("\nequality for TInstant")
+inst1 = TFloatInst('1@2019-09-09')
+inst2 = TFloatInst('1.0@2019-09-09 00:00:00')
+inst3 = TFloatInst('1.1@2019-09-09')
+inst4 = TFloatInst('1@2019-09-10')
+print(inst1 == inst2)
+print(inst1 == inst3)
+print(inst1 == inst4)
+
+print("\nequality for TInstantSet")
+ti1 = TFloatInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
+ti2 = TFloatInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
+ti3 = TFloatInstSet('{10@2019-09-08, 20@2019-09-10}')
+print(ti1 == ti2)
+print(ti1 == ti3)
+
+print("\nequality for TSequence")
+seq1 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+seq2 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+seq3 = TFloatSeq('[10.1@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+seq4 = TFloatSeq('(10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+seq5 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10)')
+seq6 = TFloatSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]', interp='Stepwise')
+print(seq1 == seq2)
+print(seq1 == seq3)
+print(seq1 == seq4)
+print(seq1 == seq5)
+print(seq1 == seq6)
+
+print("\nequality for TSequenceSet")
+ts1 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11, 20@2019-09-12]}')
+ts2 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11, 20@2019-09-12]}')
+ts3 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11]}')
+ts4 = TFloatSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[10@2019-09-11, 20@2019-09-12]}', interp='Stepwise')
+print(ts1 == ts2)
+print(ts1 == ts3)
+print(ts1 == ts4)
+
+print("*** Manual ***")
+p = TFloatInstSet('{10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01}')
+print(p)
+p = TFloatInstSet('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01')
+print(p)
+p = TFloatInstSet(TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01'))
+print(p)
+p = TFloatInstSet(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
+print(p)
+p = TFloatInstSet([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
+print(p)
+
+print("*** Manual ***")
+p = TFloatSeq('[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
+print(p)
+p = TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
+print(p)
+p = TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
+print(p)
+p = TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
+print(p)
+p = TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
+print(p)
+p = TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
+print(p)
+
+print("*** Manual ***")
+p = TFloatSeqSet('{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
+print(p)
+p = TFloatSeqSet('Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
+print(p)
+p = TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'])
+print(p)
+p = TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear')
+print(p)
+p = TFloatSeqSet(['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise')
+print(p)
+p = TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')])
+print(p)
+p = TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),  TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear')
+print(p)
+p = TFloatSeqSet([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise')
+print(p)
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/ttext_asyncpg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/ttext_asyncpg.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,193 +1,193 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncio
-import asyncpg
-from mobilitydb.asyncpg import register
-from mobilitydb.examples.db_connect import asyncpg_connect
-
-async def run():
-
-    # Set the connection parameters to PostgreSQL
-    connection = await asyncpg_connect()
-
-    try:
-        # Register MobilityDB data types
-        await register(connection)
-
-        ######################
-        # TTextInst
-        ######################
-
-        select_query = "select * from tbl_ttextinst order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_ttextinst table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("ttextinst =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinst_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_ttextinst_temp
-            (
-              k integer PRIMARY KEY,
-              temp ttext
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_ttextinst_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_ttextinst table")
-
-        ######################
-        # TTextI
-        ######################
-
-        select_query = "select * from tbl_ttexti order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_ttexti table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("ttexti =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinstset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_ttextinstset_temp
-            (
-              k integer PRIMARY KEY,
-              temp ttext
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_ttextinstset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_ttextinstset_temp table")
-
-        ######################
-        # TTextSeq
-        ######################
-    
-        select_query = "select * from tbl_ttextseq order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_ttextseq table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("ttextseq =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseq_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_ttextseq_temp
-            (
-              k integer PRIMARY KEY,
-              temp ttext
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_ttextseq_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_ttextseq_temp table")
-
-        ######################
-        # TTextS
-        ######################
-    
-        select_query = "select * from tbl_ttexts order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_ttexts table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("ttexts =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseqset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_ttextseqset_temp
-            (
-              k integer PRIMARY KEY,
-              temp ttext
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_ttextseqset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_ttextseqset_temp table")
-    
-        print("\n****************************************************************")
-
-    finally:
-        await connection.close()
-
-loop = asyncio.get_event_loop()
-loop.run_until_complete(run())
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+import asyncpg
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TTextInst
+        ######################
+
+        select_query = "select * from tbl_ttextinst order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_ttextinst table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("ttextinst =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinst_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_ttextinst_temp
+            (
+              k integer PRIMARY KEY,
+              temp ttext
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_ttextinst_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_ttextinst table")
+
+        ######################
+        # TTextI
+        ######################
+
+        select_query = "select * from tbl_ttexti order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_ttexti table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("ttexti =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinstset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_ttextinstset_temp
+            (
+              k integer PRIMARY KEY,
+              temp ttext
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_ttextinstset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_ttextinstset_temp table")
+
+        ######################
+        # TTextSeq
+        ######################
+    
+        select_query = "select * from tbl_ttextseq order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_ttextseq table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("ttextseq =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseq_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_ttextseq_temp
+            (
+              k integer PRIMARY KEY,
+              temp ttext
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_ttextseq_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_ttextseq_temp table")
+
+        ######################
+        # TTextS
+        ######################
+    
+        select_query = "select * from tbl_ttexts order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_ttexts table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("ttexts =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseqset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_ttextseqset_temp
+            (
+              k integer PRIMARY KEY,
+              temp ttext
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_ttextseqset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_ttextseqset_temp table")
+    
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/ttext_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tint_psycopg.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TTextInst
-    ######################
-
-    select_query = "select * from tbl_ttextinst order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_ttextinst table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("ttextinst =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinst_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_ttextinst_temp
-        (
-          k integer PRIMARY KEY,
-          temp ttext
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_ttextinst_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_ttextinst_temp table")
-
-    ######################
-    # TTextI
-    ######################
-
-    select_query = "select * from tbl_ttexti order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_ttexti table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("ttexti =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinstset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_ttextinstset_temp
-        (
-          k integer PRIMARY KEY,
-          temp ttext
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_ttextinstset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_ttextinstset_temp table")
-
-    ######################
-    # TTextSeq
-    ######################
-
-    select_query = "select * from tbl_ttextseq order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_ttextseq table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("ttextseq =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseq_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_ttextseq_temp
-        (
-          k integer PRIMARY KEY,
-          temp ttext
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_ttextseq_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_ttextseq_temp table")
-
-    ######################
-    # TTextS
-    ######################
-
-    select_query = "select * from tbl_ttexts order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_ttexts table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("ttexts =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseqset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_ttextseqset_temp
-        (
-          k integer PRIMARY KEY,
-          temp ttext
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_ttextseqset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_ttextseqset_temp table")
-
-    print("\n****************************************************************")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connection:
-        connection.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import psycopg2
+from mobilitydb.psycopg import register
+from mobilitydb.examples.db_connect import psycopg_connect
+
+connection = None
+
+try:
+    # Set the connection parameters to PostgreSQL
+    connection = psycopg_connect()
+    connection.autocommit = True
+
+    # Register MobilityDB data types
+    register(connection)
+
+    cursor = connection.cursor()
+
+    ######################
+    # TIntInst
+    ######################
+
+    select_query = "select * from tbl_tintinst order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tintinst table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tintinst =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinst_temp;'''
+        cursor.execute(drop_table_query)
+        connection.commit()
+        print("Table deleted successfully in PostgreSQL ")
+
+        create_table_query = '''CREATE TABLE tbl_tintinst_temp
+            (
+              k integer PRIMARY KEY,
+              temp tint
+            ); '''
+
+        cursor.execute(create_table_query)
+        connection.commit()
+        print("Table created successfully in PostgreSQL ")
+
+        postgres_insert_query = ''' INSERT INTO tbl_tintinst_temp (k, temp) VALUES (%s, %s) '''
+        result = cursor.executemany(postgres_insert_query, rows)
+        connection.commit()
+        count = cursor.rowcount
+        print(count, "record(s) inserted successfully into tbl_tintinst_temp table")
+
+    ######################
+    # TIntI
+    ######################
+
+    select_query = "select * from tbl_tinti order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tinti table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tinti =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinstset_temp;'''
+        cursor.execute(drop_table_query)
+        connection.commit()
+        print("Table deleted successfully in PostgreSQL ")
+
+        create_table_query = '''CREATE TABLE tbl_tintinstset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tint
+            ); '''
+
+        cursor.execute(create_table_query)
+        connection.commit()
+        print("Table created successfully in PostgreSQL ")
+
+        postgres_insert_query = ''' INSERT INTO tbl_tintinstset_temp (k, temp) VALUES (%s, %s) '''
+        result = cursor.executemany(postgres_insert_query, rows)
+        connection.commit()
+        count = cursor.rowcount
+        print(count, "record(s) inserted successfully into tbl_tintinstset_temp table")
+
+    ######################
+    # TIntSeq
+    ######################
+
+    select_query = "select * from tbl_tintseq order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tintseq table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tintseq =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseq_temp;'''
+        cursor.execute(drop_table_query)
+        connection.commit()
+        print("Table deleted successfully in PostgreSQL ")
+
+        create_table_query = '''CREATE TABLE tbl_tintseq_temp
+            (
+              k integer PRIMARY KEY,
+              temp tint
+            ); '''
+
+        cursor.execute(create_table_query)
+        connection.commit()
+        print("Table created successfully in PostgreSQL ")
+
+        postgres_insert_query = ''' INSERT INTO tbl_tintseq_temp (k, temp) VALUES (%s, %s) '''
+        result = cursor.executemany(postgres_insert_query, rows)
+        connection.commit()
+        count = cursor.rowcount
+        print(count, "record(s) inserted successfully into tbl_tintseq_temp table")
+
+    ######################
+    # TIntS
+    ######################
+
+    select_query = "select * from tbl_tints order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tints table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tints =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseqset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tintseqset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tintseqset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tintseqset_temp table")
+
+    print("\n****************************************************************")
+
+except (Exception, psycopg2.Error) as error:
+    print("Error while connecting to PostgreSQL", error)
+
+finally:
+
+    if connection:
+        connection.close()
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tfloat_asyncpg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tbool_asyncpg.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,194 +1,192 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncio
-import asyncpg
-from mobilitydb.asyncpg import register
-from mobilitydb.examples.db_connect import asyncpg_connect
-
-
-async def run():
-
-    # Set the connection parameters to PostgreSQL
-    connection = await asyncpg_connect()
-
-    try:
-        # Register MobilityDB data types
-        await register(connection)
-
-        ######################
-        # TFloatInst
-        ######################
-
-        select_query = "select * from tbl_tfloatinst order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tfloatinst table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tfloatinst =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinst_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tfloatinst_temp
-            (
-              k integer PRIMARY KEY,
-              temp tfloat
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tfloatinst_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tfloatinst table")
-
-        ######################
-        # TFloatI
-        ######################
-
-        select_query = "select * from tbl_tfloati order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tfloati table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tfloati =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinstset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tfloatinstset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tfloat
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tfloatinstset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tfloatinstset_temp table")
-
-        ######################
-        # TFloatSeq
-        ######################
-    
-        select_query = "select * from tbl_tfloatseq order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tfloatseq table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tfloatseq =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseq_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tfloatseq_temp
-            (
-              k integer PRIMARY KEY,
-              temp tfloat
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tfloatseq_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tfloatseq_temp table")
-
-        ######################
-        # TFloatS
-        ######################
-    
-        select_query = "select * from tbl_tfloats order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tfloats table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tfloats =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseqset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tfloatseqset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tfloat
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tfloatseqset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tfloatseqset_temp table")
-    
-        print("\n****************************************************************")
-
-    finally:
-        await connection.close()
-
-loop = asyncio.get_event_loop()
-loop.run_until_complete(run())
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TBoolInst
+        ######################
+
+        select_query = "select * from tbl_tboolinst order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tboolinst table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tboolinst =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolinst_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tboolinst_temp
+            (
+              k integer PRIMARY KEY,
+              temp tbool
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tboolinst_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tboolinst table")
+
+        ######################
+        # TBoolInstSet
+        ######################
+
+        select_query = "select * from tbl_tboolinstset order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tbooli table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tboolinstset =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolinstset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tboolinstset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tbool
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tboolinstset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tboolinstset_temp table")
+
+        ######################
+        # TBoolSeq
+        ######################
+    
+        select_query = "select * from tbl_tboolseq order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tboolseq table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tboolseq =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolseq_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tboolseq_temp
+            (
+              k integer PRIMARY KEY,
+              temp tbool
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tboolseq_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tboolseq_temp table")
+
+        ######################
+        # TBoolS
+        ######################
+    
+        select_query = "select * from tbl_tbools order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tbools table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tbools =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tboolseqset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tboolseqset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tbool
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tboolseqset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tboolseqset_temp table")
+    
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tgeompoint_asyncpg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tgeompoint_asyncpg.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,194 +1,194 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncio
-import asyncpg
-from mobilitydb.asyncpg import register
-from mobilitydb.examples.db_connect import asyncpg_connect
-
-
-async def run():
-
-    # Set the connection parameters to PostgreSQL
-    connection = await asyncpg_connect()
-
-    try:
-        # Register MobilityDB data types
-        await register(connection)
-
-        ######################
-        # TGeomPointInst
-        ######################
-
-        select_query = "select * from tbl_tgeompointinst order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeompointinst table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tgeompointinst =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinst_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeompointinst_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeompoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeompointinst_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeompointinst table")
-
-        ######################
-        # TGeomPointI
-        ######################
-
-        select_query = "select * from tbl_tgeompointi order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeompointi table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tgeompointi =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinstset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeompointinstset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeompoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeompointinstset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeompointinstset_temp table")
-
-        ######################
-        # TGeomPointSeq
-        ######################
-    
-        select_query = "select * from tbl_tgeompointseq order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeompointseq table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tgeompointseq =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseq_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeompointseq_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeompoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeompointseq_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeompointseq_temp table")
-
-        ######################
-        # TGeomPointS
-        ######################
-    
-        select_query = "select * from tbl_tgeompoints order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeompoints table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tgeompoints =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseqset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeompointseqset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeompoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeompointseqset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeompointseqset_temp table")
-    
-        print("\n****************************************************************")
-
-    finally:
-        await connection.close()
-
-loop = asyncio.get_event_loop()
-loop.run_until_complete(run())
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+import asyncpg
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TGeomPointInst
+        ######################
+
+        select_query = "select * from tbl_tgeompointinst order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeompointinst table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tgeompointinst =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinst_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeompointinst_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeompoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeompointinst_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeompointinst table")
+
+        ######################
+        # TGeomPointI
+        ######################
+
+        select_query = "select * from tbl_tgeompointi order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeompointi table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tgeompointi =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinstset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeompointinstset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeompoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeompointinstset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeompointinstset_temp table")
+
+        ######################
+        # TGeomPointSeq
+        ######################
+    
+        select_query = "select * from tbl_tgeompointseq order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeompointseq table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tgeompointseq =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseq_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeompointseq_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeompoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeompointseq_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeompointseq_temp table")
+
+        ######################
+        # TGeomPointS
+        ######################
+    
+        select_query = "select * from tbl_tgeompoints order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeompoints table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tgeompoints =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseqset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeompointseqset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeompoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeompointseqset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeompointseqset_temp table")
+    
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tgeogpoint_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tgeogpoint_psycopg.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TGeogPointInst
-    ######################
-
-    select_query = "select * from tbl_tgeogpointinst order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeogpointinst table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeogpointinst =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinst_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeogpointinst_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeogpoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinst_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeogpointinst_temp table")
-
-    ######################
-    # TGeogPointI
-    ######################
-
-    select_query = "select * from tbl_tgeogpointi order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeogpointi table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeogpointi =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinstset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeogpointinstset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeogpoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinstset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeogpointinstset_temp table")
-
-    ######################
-    # TGeogPointSeq
-    ######################
-
-    select_query = "select * from tbl_tgeogpointseq order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeogpointseq table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeogpointseq =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseq_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeogpointseq_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeogpoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseq_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeogpointseq_temp table")
-
-    ######################
-    # TGeogPointS
-    ######################
-
-    select_query = "select * from tbl_tgeogpoints order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeogpoints table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeogpoints =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseqset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeogpointseqset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeogpoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseqset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeogpointseqset_temp table")
-
-    print("\n****************************************************************")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connection:
-        connection.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import psycopg2
+from mobilitydb.psycopg import register
+from mobilitydb.examples.db_connect import psycopg_connect
+
+connection = None
+
+try:
+    # Set the connection parameters to PostgreSQL
+    connection = psycopg_connect()
+    connection.autocommit = True
+
+    # Register MobilityDB data types
+    register(connection)
+
+    cursor = connection.cursor()
+
+    ######################
+    # TGeogPointInst
+    ######################
+
+    select_query = "select * from tbl_tgeogpointinst order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeogpointinst table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeogpointinst =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinst_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeogpointinst_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeogpoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinst_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeogpointinst_temp table")
+
+    ######################
+    # TGeogPointI
+    ######################
+
+    select_query = "select * from tbl_tgeogpointi order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeogpointi table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeogpointi =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinstset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeogpointinstset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeogpoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinstset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeogpointinstset_temp table")
+
+    ######################
+    # TGeogPointSeq
+    ######################
+
+    select_query = "select * from tbl_tgeogpointseq order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeogpointseq table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeogpointseq =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseq_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeogpointseq_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeogpoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseq_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeogpointseq_temp table")
+
+    ######################
+    # TGeogPointS
+    ######################
+
+    select_query = "select * from tbl_tgeogpoints order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeogpoints table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeogpoints =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseqset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeogpointseqset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeogpoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseqset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeogpointseqset_temp table")
+
+    print("\n****************************************************************")
+
+except (Exception, psycopg2.Error) as error:
+    print("Error while connecting to PostgreSQL", error)
+
+finally:
+
+    if connection:
+        connection.close()
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/box.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/box.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,114 +1,114 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from mobilitydb import TBox, STBox
-
-print("############################")
-print('# Create new TBOX instances')
-print("############################")
-
-print('\n# Input string')
-
-# Both value and time dimensions
-var = TBox('TBOX((1.0, 2000-01-01), (2.0, 2000-01-02))')
-print(var)
-# Only value dimension
-var = TBox('TBOX((1.0,), (2.0,))')
-print(var)
-# Only time dimension
-var = TBox('TBOX((, 2000-01-01), (, 2000-01-02))')
-print(var)
-
-print('\n# Constructors')
-
-# Both value and time dimensions
-var = TBox(1.0, '2001-01-01', 2.0, '2001-01-02')
-print(var)
-# Only value dimension
-var = TBox(1.0, 2.0)
-print(var)
-# Only time dimension
-var = TBox('2001-01-01', '2001-01-02')
-print(var)
-
-print("\n############################")
-print('# Create new STBOX instances')
-print("############################")
-
-print('\n# Input string')
-
-# Only coordinate (X and Y) dimension
-var = STBox('STBOX((1.0, 2.0), (1.0, 2.0))')
-print(var)
-# Only coordinate (X, Y and Z) dimension
-var = STBox('STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))')
-print(var)
-# Both coordinate (X, Y) and time dimensions
-var = STBox('STBOX T((1.0, 2.0, 2001-01-03), (1.0, 2.0, 2001-01-03))')
-print(var)
-# Both coordinate (X, Y, and Z) and time dimensions
-var = STBox('STBOX ZT((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))')
-print(var)
-# Only time dimension
-var = STBox('STBOX T(( , , 2001-01-03), ( , , 2001-01-03))')
-print(var)
-# Only geodetic coordinate (X, Y and Z) dimension
-var = STBox('GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))')
-print(var)
-#  Both geodetic coordinate (X, Y, and Z) and time dimensions
-var = STBox('GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))')
-print(var)
-# Only time dimension for geodetic box
-var = STBox('GEODSTBOX T(( , , 2001-01-03), ( , , 2001-01-03))')
-print(var)
-
-print('\n# Constructors')
-
-# Only coordinate (X and Y) dimension
-var = STBox((1.0, 2.0, 1.0, 2.0))
-print(var)
-# Only coordinate (X, Y and Z) dimension
-var = STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0))
-print(var)
-# Both coordinate (X, Y) and time dimensions
-var = STBox((1.0, 2.0, '2001-01-03', 1.0, 2.0, '2001-01-03'), dimt=True)
-print(var)
-# Both coordinate (X, Y, and Z) and time dimensions
-var = STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-04'))
-print(var)
-# Only time dimension
-var = STBox(('2001-01-03', '2001-01-03'))
-print(var)
-# Only geodetic coordinate (X, Y and Z) dimension
-var = STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0), geodetic=True)
-print(var)
-#  Both geodetic coordinate (X, Y, and Z) and time dimensions
-var = STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03'), geodetic=True)
-print(var)
-# Only time dimension for geodetic box
-var = STBox(('2001-01-03', '2001-01-03'), geodetic=True)
-print(var)
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from mobilitydb import TBox, STBox
+
+print("############################")
+print('# Create new TBOX instances')
+print("############################")
+
+print('\n# Input string')
+
+# Both value and time dimensions
+var = TBox('TBOX((1.0, 2000-01-01), (2.0, 2000-01-02))')
+print(var)
+# Only value dimension
+var = TBox('TBOX((1.0,), (2.0,))')
+print(var)
+# Only time dimension
+var = TBox('TBOX((, 2000-01-01), (, 2000-01-02))')
+print(var)
+
+print('\n# Constructors')
+
+# Both value and time dimensions
+var = TBox(1.0, '2001-01-01', 2.0, '2001-01-02')
+print(var)
+# Only value dimension
+var = TBox(1.0, 2.0)
+print(var)
+# Only time dimension
+var = TBox('2001-01-01', '2001-01-02')
+print(var)
+
+print("\n############################")
+print('# Create new STBOX instances')
+print("############################")
+
+print('\n# Input string')
+
+# Only coordinate (X and Y) dimension
+var = STBox('STBOX((1.0, 2.0), (1.0, 2.0))')
+print(var)
+# Only coordinate (X, Y and Z) dimension
+var = STBox('STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))')
+print(var)
+# Both coordinate (X, Y) and time dimensions
+var = STBox('STBOX T((1.0, 2.0, 2001-01-03), (1.0, 2.0, 2001-01-03))')
+print(var)
+# Both coordinate (X, Y, and Z) and time dimensions
+var = STBox('STBOX ZT((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))')
+print(var)
+# Only time dimension
+var = STBox('STBOX T(( , , 2001-01-03), ( , , 2001-01-03))')
+print(var)
+# Only geodetic coordinate (X, Y and Z) dimension
+var = STBox('GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))')
+print(var)
+#  Both geodetic coordinate (X, Y, and Z) and time dimensions
+var = STBox('GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))')
+print(var)
+# Only time dimension for geodetic box
+var = STBox('GEODSTBOX T(( , , 2001-01-03), ( , , 2001-01-03))')
+print(var)
+
+print('\n# Constructors')
+
+# Only coordinate (X and Y) dimension
+var = STBox((1.0, 2.0, 1.0, 2.0))
+print(var)
+# Only coordinate (X, Y and Z) dimension
+var = STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0))
+print(var)
+# Both coordinate (X, Y) and time dimensions
+var = STBox((1.0, 2.0, '2001-01-03', 1.0, 2.0, '2001-01-03'), dimt=True)
+print(var)
+# Both coordinate (X, Y, and Z) and time dimensions
+var = STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-04'))
+print(var)
+# Only time dimension
+var = STBox(('2001-01-03', '2001-01-03'))
+print(var)
+# Only geodetic coordinate (X, Y and Z) dimension
+var = STBox((1.0, 2.0, 3.0, 1.0, 2.0, 3.0), geodetic=True)
+print(var)
+#  Both geodetic coordinate (X, Y, and Z) and time dimensions
+var = STBox((1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03'), geodetic=True)
+print(var)
+# Only time dimension for geodetic box
+var = STBox(('2001-01-03', '2001-01-03'), geodetic=True)
+print(var)
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tfloat_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tfloat_psycopg.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connectionObject = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TFloatInst
-    ######################
-
-    select_query = "select * from tbl_tfloatinst order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tfloatinst table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tfloatinst =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinst_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tfloatinst_temp
-        (
-          k integer PRIMARY KEY,
-          temp tfloat
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tfloatinst_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tfloatinst table")
-
-    ######################
-    # TFloatI
-    ######################
-
-    select_query = "select * from tbl_tfloati order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tfloati table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tfloati =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinstset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tfloatinstset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tfloat
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tfloatinstset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tfloatinstset_temp table")
-
-    ######################
-    # TFloatSeq
-    ######################
-
-    select_query = "select * from tbl_tfloatseq order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tfloatseq table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tfloatseq =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseq_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tfloatseq_temp
-        (
-          k integer PRIMARY KEY,
-          temp tfloat
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tfloatseq_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tfloatseq_temp table")
-
-    ######################
-    # TFloatS
-    ######################
-
-    select_query = "select * from tbl_tfloats order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tfloats table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tfloats =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseqset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tfloatseqset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tfloat
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tfloatseqset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tfloatseqset_temp table")
-
-    print("\n****************************************************************")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connectionObject:
-        connectionObject.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import psycopg2
+from mobilitydb.psycopg import register
+from mobilitydb.examples.db_connect import psycopg_connect
+
+connectionObject = None
+
+try:
+    # Set the connection parameters to PostgreSQL
+    connection = psycopg_connect()
+    connection.autocommit = True
+
+    # Register MobilityDB data types
+    register(connection)
+
+    cursor = connection.cursor()
+
+    ######################
+    # TFloatInst
+    ######################
+
+    select_query = "select * from tbl_tfloatinst order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tfloatinst table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tfloatinst =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinst_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tfloatinst_temp
+        (
+          k integer PRIMARY KEY,
+          temp tfloat
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tfloatinst_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tfloatinst table")
+
+    ######################
+    # TFloatI
+    ######################
+
+    select_query = "select * from tbl_tfloati order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tfloati table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tfloati =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatinstset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tfloatinstset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tfloat
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tfloatinstset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tfloatinstset_temp table")
+
+    ######################
+    # TFloatSeq
+    ######################
+
+    select_query = "select * from tbl_tfloatseq order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tfloatseq table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tfloatseq =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseq_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tfloatseq_temp
+        (
+          k integer PRIMARY KEY,
+          temp tfloat
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tfloatseq_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tfloatseq_temp table")
+
+    ######################
+    # TFloatS
+    ######################
+
+    select_query = "select * from tbl_tfloats order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tfloats table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tfloats =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tfloatseqset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tfloatseqset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tfloat
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tfloatseqset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tfloatseqset_temp table")
+
+    print("\n****************************************************************")
+
+except (Exception, psycopg2.Error) as error:
+    print("Error while connecting to PostgreSQL", error)
+
+finally:
+
+    if connectionObject:
+        connectionObject.close()
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tint.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tgeogpoint.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,288 +1,265 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from spans.types import intrange
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
-
-
-print("\nConstructors for TFloatInst")
-inst = TIntInst('10@2019-09-08')
-print(inst)
-inst = TIntInst('10', '2019-09-08')
-print(inst)
-t = parse('2019-09-08')
-inst = TIntInst(10, t)
-print(inst)
-
-print("\nConstructors for TIntInstSet")
-ti = TIntInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
-print(tinstset)
-ti = TIntInstSet('10@2019-09-08', '20@2019-09-09', '20@2019-09-10')
-print(tinstset)
-ti = TIntInstSet(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
-print(tinstset)
-t1 = TIntInst('10@2019-09-08')
-t2 = TIntInst('20@2019-09-09')
-t3 = TIntInst('20@2019-09-10')
-ti = TIntInstSet(t1, t2, t3)
-print(tinstset)
-ti = TIntInstSet([t1, t2, t3])
-print(tinstset)
-
-print("\nConstructors for TIntSeq")
-seq = TIntSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-print(seq)
-seq = TIntSeq(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
-print(seq)
-seq = TIntSeq([t1, t2, t3])
-print(seq)
-seq = TIntSeq([t1, t2, t3], False, True)
-print(seq)
-
-print("\nConstructors for TIntSeqSet")
-ts = TIntSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[15@2019-09-11, 30@2019-09-12]}')
-print(ts)
-ts = TIntSeqSet(['[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]', '[15@2019-09-11, 30@2019-09-12]'])
-print(ts)
-seq1 = TIntSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
-seq2 = TIntSeq('[15@2019-09-11, 30@2019-09-12]')
-ts = TIntSeqSet([seq1, seq2])
-print(ts)
-
-print("\n__class__ ")
-print(inst.__class__.__name__)
-print(ti.__class__.__name__)
-print(seq.__class__.__name__)
-print(ts.__class__.__name__)
-
-print("\n__bases__ ")
-print(inst.__class__.__bases__)
-print(ti.__class__.__bases__)
-print(seq.__class__.__bases__)
-print(ts.__class__.__bases__)
-
-print("\ntempSubtype")
-print(inst.tempSubtype())
-print(ti.tempSubtype())
-print(seq.tempSubtype())
-print(ts.tempSubtype())
-
-print("\ninterpolation")
-print(seq.interpolation)
-print(ts.interpolation)
-
-print("\ngetValue")
-print(inst.getValue)
-
-print("\ngetValues")
-print(inst.getValues)
-print(ti.getValues)
-print(seq.getValues)
-print(ts.getValues)
-
-print("\nstartValue")
-print(inst.startValue)
-print(ti.startValue)
-print(seq.startValue)
-print(ts.startValue)
-
-print("\nendValue")
-print(inst.endValue)
-print(ti.endValue)
-print(seq.endValue)
-print(ts.endValue)
-
-print("\nminValue")
-print(inst.minValue)
-print(ti.minValue)
-print(seq.minValue)
-print(ts.minValue)
-
-print("\nmaxValue")
-print(inst.maxValue)
-print(ti.maxValue)
-print(seq.maxValue)
-print(ts.maxValue)
-
-print("\nvalueRange")
-print(inst.valueRange)
-print(ti.valueRange)
-print(seq.valueRange)
-print(ts.valueRange)
-
-print("\ngetTimestamp")
-print(inst.getTimestamp)
-
-print("\ngetTime")
-print(inst.getTime)
-print(ti.getTime)
-print(seq.getTime)
-print(ts.getTime)
-
-print("\nduration")
-print(inst.duration)
-print(ti.duration)
-print(seq.duration)
-print(ts.duration)
-
-print("\ntimespan")
-print(inst.timespan)
-print(ti.timespan)
-print(seq.timespan)
-print(ts.timespan)
-
-print("\nperiod")
-print(inst.period)
-print(ti.period)
-print(seq.period)
-print(ts.period)
-
-print("\nnumInstants")
-print(inst.numInstants)
-print(ti.numInstants)
-print(seq.numInstants)
-print(ts.numInstants)
-
-print("\nstartInstant")
-print(inst.startInstant)
-print(ti.startInstant)
-print(seq.startInstant)
-print(ts.startInstant)
-
-print("\nendInstant")
-print(inst.endInstant)
-print(ti.endInstant)
-print(seq.endInstant)
-print(ts.endInstant)
-
-print("\ninstantN")
-print(inst.instantN(1))
-print(ti.instantN(1))
-print(seq.instantN(1))
-print(ts.instantN(1))
-
-print("\ninstants")
-print(inst.instants)
-print(ti.instants)
-print(seq.instants)
-print(ts.instants)
-
-print("\nnumTimestamps")
-print(inst.numTimestamps)
-print(ti.numTimestamps)
-print(seq.numTimestamps)
-print(ts.numTimestamps)
-
-print("\nstartTimestamp")
-print(inst.startTimestamp)
-print(ti.startTimestamp)
-print(seq.startTimestamp)
-print(ts.startTimestamp)
-
-print("\nendTimestamp")
-print(inst.endTimestamp)
-print(ti.endTimestamp)
-print(seq.endTimestamp)
-print(ts.endTimestamp)
-
-print("\ntimestampN")
-print(inst.timestampN(1))
-print(ti.timestampN(1))
-print(seq.timestampN(1))
-print(ts.timestampN(1))
-
-print("\ntimestamps")
-print(inst.timestamps)
-print(ti.timestamps)
-print(seq.timestamps)
-print(ts.timestamps)
-
-print("\nnumSequences")
-print(seq.numSequences)
-print(ts.numSequences)
-
-print("\nstartSequence")
-print(seq.startSequence)
-print(ts.startSequence)
-
-print("\nendSequence")
-print(seq.endSequence)
-print(ts.endSequence)
-
-print("\nsequenceN")
-print(seq.sequenceN(1))
-print(ts.sequenceN(1))
-
-print("\nsequences")
-print(seq.sequences)
-print(ts.sequences)
-
-print("\nshift")
-print(inst.shift(timedelta(days=1)))
-print(ti.shift(timedelta(days=1)))
-print(seq.shift(timedelta(days=1)))
-print(ts.shift(timedelta(days=1)))
-
-print("\nintersectsTimestamp")
-t = datetime.strptime('2019-09-09', '%Y-%m-%d')
-print(inst.intersectsTimestamp(t))
-print(ti.intersectsTimestamp(t))
-print(seq.intersectsTimestamp(t))
-print(ts.intersectsTimestamp(t))
-
-print("\nintersectsTimestampSet")
-tss = TimestampSet('{2019-09-09, 2019-09-10}')
-print(inst.intersectsTimestampSet(tss))
-print(ti.intersectsTimestampSet(tss))
-print(seq.intersectsTimestampSet(tss))
-print(ts.intersectsTimestampSet(tss))
-
-print("\nintersectsPeriod")
-p = Period('2019-09-09', '2019-09-10', True, True)
-print(inst.intersectsPeriod(p))
-print(ti.intersectsPeriod(p))
-print(seq.intersectsPeriod(p))
-print(ts.intersectsPeriod(p))
-
-print("\nintersectsPeriodSet")
-ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
-print(inst.intersectsPeriodSet(ps))
-print(ti.intersectsPeriodSet(ps))
-print(seq.intersectsPeriodSet(ps))
-print(ts.intersectsPeriodSet(ps))
-
-"""
-f = TInt('1@2000-01-01')
-print(f)
-f = TInt('{1@2000-01-01, 1@2000-01-02}')
-print(f)
-"""
-
-ts = TIntSeq('Interp=Stepwise;[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 20@2019-09-03 00:00:00+01]')
-print(repr(ts))
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from postgis import Point, MultiPoint, LineString, MultiLineString, GeometryCollection
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main.tpoint import TGeogPointInst, TGeogPointInstSet, TGeogPointSeq, TGeogPointSeqSet
+
+
+print("\nConstructors for TGeogPointInst")
+inst = TGeogPointInst('Point(10 10)@2019-09-08')
+print(inst)
+inst = TGeogPointInst('Point(10 10)', '2019-09-08')
+print(inst)
+p = Point(10,10)
+t = parse('2019-09-08')
+inst = TGeogPointInst(p, t)
+print(inst)
+
+print("\nConstructors for TGeogPointInstSet")
+ti = TGeogPointInstSet('{Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10}')
+print(tinstset)
+ti = TGeogPointInstSet('Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10')
+print(tinstset)
+ti = TGeogPointInstSet(['Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10'])
+print(tinstset)
+t1 = TGeogPointInst('Point(10 10)@2019-09-08')
+t2 = TGeogPointInst('Point(20 20)@2019-09-09')
+t3 = TGeogPointInst('Point(20 20)@2019-09-10')
+ti = TGeogPointInstSet(t1, t2, t3)
+print(tinstset)
+ti = TGeogPointInstSet([t1, t2, t3])
+print(tinstset)
+
+print("\nConstructors for TGeogPointSeq")
+seq = TGeogPointSeq('[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10]')
+print(seq)
+seq = TGeogPointSeq(['Point(10 10)@2019-09-08', 'Point(20 20)@2019-09-09', 'Point(20 20)@2019-09-10'])
+print(seq)
+seq = TGeogPointSeq([t1, t2, t3])
+print(seq)
+seq = TGeogPointSeq([t1, t2, t3], False, True)
+print(seq)
+
+print("\nConstructors for TGeogPointSeqSet")
+ts = TGeogPointSeqSet('{[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10],[Point(15 15)@2019-09-11, Point(30 30)@2019-09-12]}')
+print(ts)
+seq1 = TGeogPointSeq('[Point(10 10)@2019-09-08, Point(20 20)@2019-09-09, Point(20 20)@2019-09-10]')
+seq2 = TGeogPointSeq('[Point(15 15)@2019-09-11, Point(30 30)@2019-09-12]')
+ts = TGeogPointSeqSet([seq1, seq2])
+print(ts)
+
+print("\n__class__ ")
+print(inst.__class__.__name__)
+print(ti.__class__.__name__)
+print(seq.__class__.__name__)
+print(ts.__class__.__name__)
+
+print("\n__bases__ ")
+print(inst.__class__.__bases__)
+print(ti.__class__.__bases__)
+print(seq.__class__.__bases__)
+print(ts.__class__.__bases__)
+
+print("\ntempSubtype")
+print(inst.tempSubtype())
+print(ti.tempSubtype())
+print(seq.tempSubtype())
+print(ts.tempSubtype())
+
+print("\ninterpolation")
+print(seq.interpolation)
+print(ts.interpolation)
+
+print("\ngetValue")
+print(inst.getValue)
+
+print("\ngetValues")
+print(inst.getValues)
+print(ti.getValues)
+print(seq.getValues)
+print(ts.getValues)
+
+print("\nstartValue")
+print(inst.startValue)
+print(ti.startValue)
+print(seq.startValue)
+print(ts.startValue)
+
+print("\nendValue")
+print(inst.endValue)
+print(ti.endValue)
+print(seq.endValue)
+print(ts.endValue)
+
+print("\ngetTimestamp")
+print(inst.getTimestamp)
+
+print("\ngetTime")
+print(inst.getTime)
+print(ti.getTime)
+print(seq.getTime)
+print(ts.getTime)
+
+print("\nduration")
+print(inst.duration)
+print(ti.duration)
+print(seq.duration)
+print(ts.duration)
+
+print("\ntimespan")
+print(inst.timespan)
+print(ti.timespan)
+print(seq.timespan)
+print(ts.timespan)
+
+print("\nperiod")
+print(inst.period)
+print(ti.period)
+print(seq.period)
+print(ts.period)
+
+print("\nnumInstants")
+print(inst.numInstants)
+print(ti.numInstants)
+print(seq.numInstants)
+print(ts.numInstants)
+
+print("\nstartInstant")
+print(inst.startInstant)
+print(ti.startInstant)
+print(seq.startInstant)
+print(ts.startInstant)
+
+print("\nendInstant")
+print(inst.endInstant)
+print(ti.endInstant)
+print(seq.endInstant)
+print(ts.endInstant)
+
+print("\ninstantN")
+print(inst.instantN(1))
+print(ti.instantN(1))
+print(seq.instantN(1))
+print(ts.instantN(1))
+
+print("\ninstants")
+print(inst.instants)
+print(ti.instants)
+print(seq.instants)
+print(ts.instants)
+
+print("\nnumTimestamps")
+print(inst.numTimestamps)
+print(ti.numTimestamps)
+print(seq.numTimestamps)
+print(ts.numTimestamps)
+
+print("\nstartTimestamp")
+print(inst.startTimestamp)
+print(ti.startTimestamp)
+print(seq.startTimestamp)
+print(ts.startTimestamp)
+
+print("\nendTimestamp")
+print(inst.endTimestamp)
+print(ti.endTimestamp)
+print(seq.endTimestamp)
+print(ts.endTimestamp)
+
+print("\ntimestampN")
+print(inst.timestampN(1))
+print(ti.timestampN(1))
+print(seq.timestampN(1))
+print(ts.timestampN(1))
+
+print("\ntimestamps")
+print(inst.timestamps)
+print(ti.timestamps)
+print(seq.timestamps)
+print(ts.timestamps)
+
+print("\nnumSequences")
+print(seq.numSequences)
+print(ts.numSequences)
+
+print("\nstartSequence")
+print(seq.startSequence)
+print(ts.startSequence)
+
+print("\nendSequence")
+print(seq.endSequence)
+print(ts.endSequence)
+
+print("\nsequenceN")
+print(seq.sequenceN(1))
+print(ts.sequenceN(1))
+
+print("\nsequences")
+print(seq.sequences)
+print(ts.sequences)
+
+print("\nshift")
+print(inst.shift(timedelta(days=1)))
+print(ti.shift(timedelta(days=1)))
+print(seq.shift(timedelta(days=1)))
+print(ts.shift(timedelta(days=1)))
+
+print("\nintersectsTimestamp")
+t = datetime.strptime('2019-09-09', '%Y-%m-%d')
+print(inst.intersectsTimestamp(t))
+print(ti.intersectsTimestamp(t))
+print(seq.intersectsTimestamp(t))
+print(ts.intersectsTimestamp(t))
+
+print("\nintersectsTimestampSet")
+tss = TimestampSet('{2019-09-09, 2019-09-10}')
+print(inst.intersectsTimestampSet(tss))
+print(ti.intersectsTimestampSet(tss))
+print(seq.intersectsTimestampSet(tss))
+print(ts.intersectsTimestampSet(tss))
+
+print("\nintersectsPeriod")
+p = Period('2019-09-09', '2019-09-10', True, True)
+print(inst.intersectsPeriod(p))
+print(ti.intersectsPeriod(p))
+print(seq.intersectsPeriod(p))
+print(ts.intersectsPeriod(p))
+
+print("\nintersectsPeriodSet")
+ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
+print(inst.intersectsPeriodSet(ps))
+print(ti.intersectsPeriodSet(ps))
+print(seq.intersectsPeriodSet(ps))
+print(ts.intersectsPeriodSet(ps))
+
+print("\nsrid")
+print(inst.srid)
+print(ti.srid)
+print(seq.srid)
+print(ts.srid)
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tint_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/ttext_psycopg.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TIntInst
-    ######################
-
-    select_query = "select * from tbl_tintinst order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tintinst table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tintinst =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinst_temp;'''
-        cursor.execute(drop_table_query)
-        connection.commit()
-        print("Table deleted successfully in PostgreSQL ")
-
-        create_table_query = '''CREATE TABLE tbl_tintinst_temp
-            (
-              k integer PRIMARY KEY,
-              temp tint
-            ); '''
-
-        cursor.execute(create_table_query)
-        connection.commit()
-        print("Table created successfully in PostgreSQL ")
-
-        postgres_insert_query = ''' INSERT INTO tbl_tintinst_temp (k, temp) VALUES (%s, %s) '''
-        result = cursor.executemany(postgres_insert_query, rows)
-        connection.commit()
-        count = cursor.rowcount
-        print(count, "record(s) inserted successfully into tbl_tintinst_temp table")
-
-    ######################
-    # TIntI
-    ######################
-
-    select_query = "select * from tbl_tinti order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tinti table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tinti =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintinstset_temp;'''
-        cursor.execute(drop_table_query)
-        connection.commit()
-        print("Table deleted successfully in PostgreSQL ")
-
-        create_table_query = '''CREATE TABLE tbl_tintinstset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tint
-            ); '''
-
-        cursor.execute(create_table_query)
-        connection.commit()
-        print("Table created successfully in PostgreSQL ")
-
-        postgres_insert_query = ''' INSERT INTO tbl_tintinstset_temp (k, temp) VALUES (%s, %s) '''
-        result = cursor.executemany(postgres_insert_query, rows)
-        connection.commit()
-        count = cursor.rowcount
-        print(count, "record(s) inserted successfully into tbl_tintinstset_temp table")
-
-    ######################
-    # TIntSeq
-    ######################
-
-    select_query = "select * from tbl_tintseq order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tintseq table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tintseq =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseq_temp;'''
-        cursor.execute(drop_table_query)
-        connection.commit()
-        print("Table deleted successfully in PostgreSQL ")
-
-        create_table_query = '''CREATE TABLE tbl_tintseq_temp
-            (
-              k integer PRIMARY KEY,
-              temp tint
-            ); '''
-
-        cursor.execute(create_table_query)
-        connection.commit()
-        print("Table created successfully in PostgreSQL ")
-
-        postgres_insert_query = ''' INSERT INTO tbl_tintseq_temp (k, temp) VALUES (%s, %s) '''
-        result = cursor.executemany(postgres_insert_query, rows)
-        connection.commit()
-        count = cursor.rowcount
-        print(count, "record(s) inserted successfully into tbl_tintseq_temp table")
-
-    ######################
-    # TIntS
-    ######################
-
-    select_query = "select * from tbl_tints order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tints table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tints =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tintseqset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tintseqset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tintseqset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tintseqset_temp table")
-
-    print("\n****************************************************************")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connection:
-        connection.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import psycopg2
+from mobilitydb.psycopg import register
+from mobilitydb.examples.db_connect import psycopg_connect
+
+connection = None
+
+try:
+    # Set the connection parameters to PostgreSQL
+    connection = psycopg_connect()
+    connection.autocommit = True
+
+    # Register MobilityDB data types
+    register(connection)
+
+    cursor = connection.cursor()
+
+    ######################
+    # TTextInst
+    ######################
+
+    select_query = "select * from tbl_ttextinst order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_ttextinst table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("ttextinst =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinst_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_ttextinst_temp
+        (
+          k integer PRIMARY KEY,
+          temp ttext
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_ttextinst_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_ttextinst_temp table")
+
+    ######################
+    # TTextI
+    ######################
+
+    select_query = "select * from tbl_ttexti order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_ttexti table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("ttexti =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextinstset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_ttextinstset_temp
+        (
+          k integer PRIMARY KEY,
+          temp ttext
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_ttextinstset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_ttextinstset_temp table")
+
+    ######################
+    # TTextSeq
+    ######################
+
+    select_query = "select * from tbl_ttextseq order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_ttextseq table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("ttextseq =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseq_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_ttextseq_temp
+        (
+          k integer PRIMARY KEY,
+          temp ttext
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_ttextseq_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_ttextseq_temp table")
+
+    ######################
+    # TTextS
+    ######################
+
+    select_query = "select * from tbl_ttexts order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_ttexts table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("ttexts =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_ttextseqset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_ttextseqset_temp
+        (
+          k integer PRIMARY KEY,
+          temp ttext
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_ttextseqset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_ttextseqset_temp table")
+
+    print("\n****************************************************************")
+
+except (Exception, psycopg2.Error) as error:
+    print("Error while connecting to PostgreSQL", error)
+
+finally:
+
+    if connection:
+        connection.close()
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tgeompoint_psycopg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tgeompoint_psycopg.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import psycopg2
-from mobilitydb.psycopg import register
-from mobilitydb.examples.db_connect import psycopg_connect
-
-connection = None
-
-try:
-    # Set the connection parameters to PostgreSQL
-    connection = psycopg_connect()
-    connection.autocommit = True
-
-    # Register MobilityDB data types
-    register(connection)
-
-    cursor = connection.cursor()
-
-    ######################
-    # TGeomPointInst
-    ######################
-
-    select_query = "select * from tbl_tgeompointinst order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeompointinst table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeompointinst =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinst_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeompointinst_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeompoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeompointinst_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeompointinst_temp table")
-
-    ######################
-    # TGeomPointI
-    ######################
-
-    select_query = "select * from tbl_tgeompointi order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeompointi table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeompointi =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinstset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeompointinstset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeompoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeompointinstset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeompointinstset_temp table")
-
-    ######################
-    # TGeomPointSeq
-    ######################
-
-    select_query = "select * from tbl_tgeompointseq order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeompointseq table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeompointseq =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseq_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeompointseq_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeompoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeompointseq_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeompointseq_temp table")
-
-    ######################
-    # TGeomPointS
-    ######################
-
-    select_query = "select * from tbl_tgeompoints order by k limit 10"
-
-    cursor.execute(select_query)
-    print("\n****************************************************************")
-    print("Selecting rows from tbl_tgeompoints table\n")
-    rows = cursor.fetchall()
-
-    for row in rows:
-        print("key =", row[0])
-        print("tgeompoints =", row[1])
-        if not row[1]:
-            print("")
-        else:
-            print("startTimestamp =", row[1].startTimestamp, "\n")
-
-    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseqset_temp;'''
-    cursor.execute(drop_table_query)
-    connection.commit()
-    print("Table deleted successfully in PostgreSQL ")
-
-    create_table_query = '''CREATE TABLE tbl_tgeompointseqset_temp
-        (
-          k integer PRIMARY KEY,
-          temp tgeompoint
-        ); '''
-
-    cursor.execute(create_table_query)
-    connection.commit()
-    print("Table created successfully in PostgreSQL ")
-
-    postgres_insert_query = ''' INSERT INTO tbl_tgeompointseqset_temp (k, temp) VALUES (%s, %s) '''
-    result = cursor.executemany(postgres_insert_query, rows)
-    connection.commit()
-    count = cursor.rowcount
-    print(count, "record(s) inserted successfully into tbl_tgeompointseqset_temp table")
-
-    print("\n****************************************************************")
-
-except (Exception, psycopg2.Error) as error:
-    print("Error while connecting to PostgreSQL", error)
-
-finally:
-
-    if connection:
-        connection.close()
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import psycopg2
+from mobilitydb.psycopg import register
+from mobilitydb.examples.db_connect import psycopg_connect
+
+connection = None
+
+try:
+    # Set the connection parameters to PostgreSQL
+    connection = psycopg_connect()
+    connection.autocommit = True
+
+    # Register MobilityDB data types
+    register(connection)
+
+    cursor = connection.cursor()
+
+    ######################
+    # TGeomPointInst
+    ######################
+
+    select_query = "select * from tbl_tgeompointinst order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeompointinst table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeompointinst =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinst_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeompointinst_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeompoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeompointinst_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeompointinst_temp table")
+
+    ######################
+    # TGeomPointI
+    ######################
+
+    select_query = "select * from tbl_tgeompointi order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeompointi table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeompointi =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointinstset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeompointinstset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeompoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeompointinstset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeompointinstset_temp table")
+
+    ######################
+    # TGeomPointSeq
+    ######################
+
+    select_query = "select * from tbl_tgeompointseq order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeompointseq table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeompointseq =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseq_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeompointseq_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeompoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeompointseq_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeompointseq_temp table")
+
+    ######################
+    # TGeomPointS
+    ######################
+
+    select_query = "select * from tbl_tgeompoints order by k limit 10"
+
+    cursor.execute(select_query)
+    print("\n****************************************************************")
+    print("Selecting rows from tbl_tgeompoints table\n")
+    rows = cursor.fetchall()
+
+    for row in rows:
+        print("key =", row[0])
+        print("tgeompoints =", row[1])
+        if not row[1]:
+            print("")
+        else:
+            print("startTimestamp =", row[1].startTimestamp, "\n")
+
+    drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeompointseqset_temp;'''
+    cursor.execute(drop_table_query)
+    connection.commit()
+    print("Table deleted successfully in PostgreSQL ")
+
+    create_table_query = '''CREATE TABLE tbl_tgeompointseqset_temp
+        (
+          k integer PRIMARY KEY,
+          temp tgeompoint
+        ); '''
+
+    cursor.execute(create_table_query)
+    connection.commit()
+    print("Table created successfully in PostgreSQL ")
+
+    postgres_insert_query = ''' INSERT INTO tbl_tgeompointseqset_temp (k, temp) VALUES (%s, %s) '''
+    result = cursor.executemany(postgres_insert_query, rows)
+    connection.commit()
+    count = cursor.rowcount
+    print(count, "record(s) inserted successfully into tbl_tgeompointseqset_temp table")
+
+    print("\n****************************************************************")
+
+except (Exception, psycopg2.Error) as error:
+    print("Error while connecting to PostgreSQL", error)
+
+finally:
+
+    if connection:
+        connection.close()
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/time.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/time.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,210 +1,210 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-
-print("\n# Period")
-
-# Constructors
-var = Period('[2019-09-08, 2019-09-10]')
-print("Constructor string:", var)
-var = Period('[2019-09-08, 2019-09-10)')
-print("Constructor string:", var)
-var = Period('(2019-09-08, 2019-09-10]')
-print("Constructor string:", var)
-var = Period('(2019-09-08, 2019-09-10)')
-print("Constructor string:", var)
-var = Period('2019-09-08', '2019-09-10')
-print("Constructor 2 args:", var)
-var = Period('2019-09-08', '2019-09-10', False, True)
-print("Constructor 4 args:", var)
-
-# Accessor functions
-var1 = var.lower
-print("lower:", var1)
-var1 = var.upper
-print("upper:", var1)
-var1 = var.lower_inc
-print("lower_inc:", var1)
-var1 = var.upper_inc
-print("upper_inc:", var1)
-var1 = var.duration
-print("duration:", var1)
-var1 = var.shift(timedelta(days=1))
-print("shift:", var1)
-
-# Comparisons
-var1 = Period('2019-09-08', '2019-09-10', True, True)
-var2 = Period('2019-09-08', '2019-09-10', False, True)
-print("Eq:", var1 == var2)
-print("Lt:", var1 < var2)
-print("Le:", var1 <= var2)
-print("Gt:", var1 > var2)
-print("Ge:", var1 >= var2)
-
-print("\n# TimestampSet")
-
-# Constructor with a single argument of type string
-var = TimestampSet('{2019-09-08, 2019-09-10, 2019-09-11, 2019-09-12}')
-print("Constructor string:   ", var)
-# Constructor with multiple arguments of type string
-var = TimestampSet('2019-09-08', '2019-09-10', '2019-09-11', '2019-09-12')
-print("Constructor strings:  ", var)
-# Constructor with multiple arguments of type datetime
-t1 = datetime.strptime('2019-09-08', '%Y-%m-%d')
-t2 = datetime.strptime('2019-09-10', '%Y-%m-%d')
-t3 = datetime.strptime('2019-09-11', '%Y-%m-%d')
-t4 = datetime.strptime('2019-09-12', '%Y-%m-%d')
-var = TimestampSet(t1, t2, t3, t4)
-print("Constructor datetimes:", var)
-# Constructor with a single argument of type list of strings
-var = TimestampSet(['2019-09-08', '2019-09-10', '2019-09-11', '2019-09-12'])
-print("Constructor list of strings:  ", var)
-# Constructor with a single argument of type list of periods
-var = TimestampSet([t1, t2, t3, t4])
-print("Constructor list of datetimes:", var)
-
-# Error
-# t4 = datetime.strptime('2019-09-11', '%Y-%m-%d')
-# var = TimestampSet(t1, t2, t3, t4)
-
-# Accessor functions
-var1 = var.timespan
-print("timespan:", var1)
-var1 = var.period
-print("period:", var1)
-var1 = var.numTimestamps
-print("numTimestamps:", var1)
-var1 = var.startTimestamp
-print("startTimestamp:", var1)
-var1 = var.endTimestamp
-print("endTimestamp:", var1)
-var1 = var.timestampN(1)
-print("timestampN(1):", var1)
-var1 = var.timestampN(4)
-print("timestampN(4):", var1)
-var1 = var.timestamps
-print("timestamps:", var1)
-var1 = var.shift(timedelta(days=1))
-print("shift:", var1)
-
-print("\n# PeriodSet")
-
-# Constructor with a single argument of type string
-var = PeriodSet('{[2019-09-08, 2019-09-10], [2019-09-11, 2019-09-12), \
-    [2019-09-13,2019-09-13], (2019-09-14, 2019-09-15]}')
-print("Constructor string: ", var)
-# Constructor with multiple arguments of type string
-var = PeriodSet('[2019-09-08, 2019-09-10]', '[2019-09-11, 2019-09-12)', \
-                '[2019-09-13,2019-09-13]', '(2019-09-14, 2019-09-15)')
-print("Constructor strings:", var)
-# Constructor with multiple arguments of type period
-p1 = Period('[2019-09-08, 2019-09-10]')
-p2 = Period('[2019-09-11, 2019-09-12)')
-p3 = Period('[2019-09-13,2019-09-13]')
-p4 = Period('(2019-09-14, 2019-09-15)')
-var = PeriodSet(p1, p2, p3, p4)
-print("Constructor periods:", var)
-# Constructor with a single argument of type list of strings
-var = PeriodSet(['[2019-09-08, 2019-09-10]', '[2019-09-11, 2019-09-12)', \
-                 '[2019-09-13,2019-09-13]', '(2019-09-14, 2019-09-15)'])
-print("Constructor list of strings:", var)
-# Constructor with a single argument of type list of periods
-var = PeriodSet([p1, p2, p3, p4])
-print("Constructor list of periods:", var)
-
-# Error
-# t4 = datetime.strptime('2019-09-11', '%Y-%m-%d')
-# var = PeriodSet(p1, p2, p3, p4)
-
-# Accessor functions
-var1 = var.duration
-print("duration:", var1)
-var1 = var.timespan
-print("timespan:", var1)
-var1 = var.period
-print("period:", var1)
-var1 = var.numTimestamps
-print("numTimestamps:", var1)
-var1 = var.startTimestamp
-print("startTimestamp:", var1)
-var1 = var.endTimestamp
-print("endTimestamp:", var1)
-var1 = var.timestampN(1)
-print("timestampN(1):", var1)
-var1 = var.timestamps
-print("timestamps:", var1)
-
-var1 = var.numPeriods
-print("numPeriods:", var1)
-var1 = var.startPeriod
-print("startPeriod:", var1)
-var1 = var.endPeriod
-print("endPeriod:", var1)
-var1 = var.periodN(1)
-print("periodN(1):", var1)
-var1 = var.periods
-print("periods:", var1)
-var1 = var.shift(timedelta(days=1))
-print("shift:", var1)
-
-p1 = Period('[2019-09-08, 2019-09-10]')
-p2 = Period('[2019-09-11, 2019-09-12)')
-print ("overlap:", p1.overlap(p2))
-p2 = Period('[2019-09-09, 2019-09-12)')
-print ("overlap:", p1.overlap(p2))
-
-p1 = Period('[2019-09-08, 2019-09-10]')
-p2 = Period('[2019-09-08, 2019-09-10]')
-p3 = Period('[2019-09-11, 2019-09-12)')
-print ("Period equality:", p1 == p2)
-print ("Period equality:", p1 == p3)
-
-ts1 = TimestampSet('{2019-09-08, 2019-09-10}')
-ts2 = TimestampSet('{2019-09-08, 2019-09-10}')
-ts3 = TimestampSet('{2019-09-08, 2019-09-10, 2019-09-11}')
-print ("TimestampSet equality:", ts1 == ts2)
-print ("TimestampSet equality:", ts1 == ts3)
-
-ps1 = PeriodSet('{[2019-09-08, 2019-09-10],[2019-09-11, 2019-09-12)}')
-ps2 = PeriodSet('{[2019-09-08, 2019-09-10],[2019-09-11, 2019-09-12)}')
-ps3 = PeriodSet('{[2019-09-08, 2019-09-10],[2019-09-11, 2019-09-12]}')
-ps4 = PeriodSet('{[2019-09-11, 2019-09-12)}')
-print ("PeriodSet equality:", ps1 == ps2)
-print ("PeriodSet equality:", ps1 == ps3)
-print ("PeriodSet equality:", ps1 == ps4)
-
-print ("Time types equality:", p1 == ts1)
-print ("Time types equality:", p1 == ps1)
-print ("Time types equality:", ts1 == ps1)
-
-print("representantion:", repr(p1))
-print("representantion:", repr(ts1))
-print("representantion:", repr(ps1))
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+
+print("\n# Period")
+
+# Constructors
+var = Period('[2019-09-08, 2019-09-10]')
+print("Constructor string:", var)
+var = Period('[2019-09-08, 2019-09-10)')
+print("Constructor string:", var)
+var = Period('(2019-09-08, 2019-09-10]')
+print("Constructor string:", var)
+var = Period('(2019-09-08, 2019-09-10)')
+print("Constructor string:", var)
+var = Period('2019-09-08', '2019-09-10')
+print("Constructor 2 args:", var)
+var = Period('2019-09-08', '2019-09-10', False, True)
+print("Constructor 4 args:", var)
+
+# Accessor functions
+var1 = var.lower
+print("lower:", var1)
+var1 = var.upper
+print("upper:", var1)
+var1 = var.lower_inc
+print("lower_inc:", var1)
+var1 = var.upper_inc
+print("upper_inc:", var1)
+var1 = var.duration
+print("duration:", var1)
+var1 = var.shift(timedelta(days=1))
+print("shift:", var1)
+
+# Comparisons
+var1 = Period('2019-09-08', '2019-09-10', True, True)
+var2 = Period('2019-09-08', '2019-09-10', False, True)
+print("Eq:", var1 == var2)
+print("Lt:", var1 < var2)
+print("Le:", var1 <= var2)
+print("Gt:", var1 > var2)
+print("Ge:", var1 >= var2)
+
+print("\n# TimestampSet")
+
+# Constructor with a single argument of type string
+var = TimestampSet('{2019-09-08, 2019-09-10, 2019-09-11, 2019-09-12}')
+print("Constructor string:   ", var)
+# Constructor with multiple arguments of type string
+var = TimestampSet('2019-09-08', '2019-09-10', '2019-09-11', '2019-09-12')
+print("Constructor strings:  ", var)
+# Constructor with multiple arguments of type datetime
+t1 = datetime.strptime('2019-09-08', '%Y-%m-%d')
+t2 = datetime.strptime('2019-09-10', '%Y-%m-%d')
+t3 = datetime.strptime('2019-09-11', '%Y-%m-%d')
+t4 = datetime.strptime('2019-09-12', '%Y-%m-%d')
+var = TimestampSet(t1, t2, t3, t4)
+print("Constructor datetimes:", var)
+# Constructor with a single argument of type list of strings
+var = TimestampSet(['2019-09-08', '2019-09-10', '2019-09-11', '2019-09-12'])
+print("Constructor list of strings:  ", var)
+# Constructor with a single argument of type list of periods
+var = TimestampSet([t1, t2, t3, t4])
+print("Constructor list of datetimes:", var)
+
+# Error
+# t4 = datetime.strptime('2019-09-11', '%Y-%m-%d')
+# var = TimestampSet(t1, t2, t3, t4)
+
+# Accessor functions
+var1 = var.timespan
+print("timespan:", var1)
+var1 = var.period
+print("period:", var1)
+var1 = var.numTimestamps
+print("numTimestamps:", var1)
+var1 = var.startTimestamp
+print("startTimestamp:", var1)
+var1 = var.endTimestamp
+print("endTimestamp:", var1)
+var1 = var.timestampN(1)
+print("timestampN(1):", var1)
+var1 = var.timestampN(4)
+print("timestampN(4):", var1)
+var1 = var.timestamps
+print("timestamps:", var1)
+var1 = var.shift(timedelta(days=1))
+print("shift:", var1)
+
+print("\n# PeriodSet")
+
+# Constructor with a single argument of type string
+var = PeriodSet('{[2019-09-08, 2019-09-10], [2019-09-11, 2019-09-12), \
+    [2019-09-13,2019-09-13], (2019-09-14, 2019-09-15]}')
+print("Constructor string: ", var)
+# Constructor with multiple arguments of type string
+var = PeriodSet('[2019-09-08, 2019-09-10]', '[2019-09-11, 2019-09-12)', \
+                '[2019-09-13,2019-09-13]', '(2019-09-14, 2019-09-15)')
+print("Constructor strings:", var)
+# Constructor with multiple arguments of type period
+p1 = Period('[2019-09-08, 2019-09-10]')
+p2 = Period('[2019-09-11, 2019-09-12)')
+p3 = Period('[2019-09-13,2019-09-13]')
+p4 = Period('(2019-09-14, 2019-09-15)')
+var = PeriodSet(p1, p2, p3, p4)
+print("Constructor periods:", var)
+# Constructor with a single argument of type list of strings
+var = PeriodSet(['[2019-09-08, 2019-09-10]', '[2019-09-11, 2019-09-12)', \
+                 '[2019-09-13,2019-09-13]', '(2019-09-14, 2019-09-15)'])
+print("Constructor list of strings:", var)
+# Constructor with a single argument of type list of periods
+var = PeriodSet([p1, p2, p3, p4])
+print("Constructor list of periods:", var)
+
+# Error
+# t4 = datetime.strptime('2019-09-11', '%Y-%m-%d')
+# var = PeriodSet(p1, p2, p3, p4)
+
+# Accessor functions
+var1 = var.duration
+print("duration:", var1)
+var1 = var.timespan
+print("timespan:", var1)
+var1 = var.period
+print("period:", var1)
+var1 = var.numTimestamps
+print("numTimestamps:", var1)
+var1 = var.startTimestamp
+print("startTimestamp:", var1)
+var1 = var.endTimestamp
+print("endTimestamp:", var1)
+var1 = var.timestampN(1)
+print("timestampN(1):", var1)
+var1 = var.timestamps
+print("timestamps:", var1)
+
+var1 = var.numPeriods
+print("numPeriods:", var1)
+var1 = var.startPeriod
+print("startPeriod:", var1)
+var1 = var.endPeriod
+print("endPeriod:", var1)
+var1 = var.periodN(1)
+print("periodN(1):", var1)
+var1 = var.periods
+print("periods:", var1)
+var1 = var.shift(timedelta(days=1))
+print("shift:", var1)
+
+p1 = Period('[2019-09-08, 2019-09-10]')
+p2 = Period('[2019-09-11, 2019-09-12)')
+print ("overlap:", p1.overlap(p2))
+p2 = Period('[2019-09-09, 2019-09-12)')
+print ("overlap:", p1.overlap(p2))
+
+p1 = Period('[2019-09-08, 2019-09-10]')
+p2 = Period('[2019-09-08, 2019-09-10]')
+p3 = Period('[2019-09-11, 2019-09-12)')
+print ("Period equality:", p1 == p2)
+print ("Period equality:", p1 == p3)
+
+ts1 = TimestampSet('{2019-09-08, 2019-09-10}')
+ts2 = TimestampSet('{2019-09-08, 2019-09-10}')
+ts3 = TimestampSet('{2019-09-08, 2019-09-10, 2019-09-11}')
+print ("TimestampSet equality:", ts1 == ts2)
+print ("TimestampSet equality:", ts1 == ts3)
+
+ps1 = PeriodSet('{[2019-09-08, 2019-09-10],[2019-09-11, 2019-09-12)}')
+ps2 = PeriodSet('{[2019-09-08, 2019-09-10],[2019-09-11, 2019-09-12)}')
+ps3 = PeriodSet('{[2019-09-08, 2019-09-10],[2019-09-11, 2019-09-12]}')
+ps4 = PeriodSet('{[2019-09-11, 2019-09-12)}')
+print ("PeriodSet equality:", ps1 == ps2)
+print ("PeriodSet equality:", ps1 == ps3)
+print ("PeriodSet equality:", ps1 == ps4)
+
+print ("Time types equality:", p1 == ts1)
+print ("Time types equality:", p1 == ps1)
+print ("Time types equality:", ts1 == ps1)
+
+print("representantion:", repr(p1))
+print("representantion:", repr(ts1))
+print("representantion:", repr(ps1))
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tgeogpoint_asyncpg.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tgeogpoint_asyncpg.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,194 +1,194 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import asyncio
-import asyncpg
-from mobilitydb.asyncpg import register
-from mobilitydb.examples.db_connect import asyncpg_connect
-
-
-async def run():
-
-    # Set the connection parameters to PostgreSQL
-    connection = await asyncpg_connect()
-
-    try:
-        # Register MobilityDB data types
-        await register(connection)
-
-        ######################
-        # TGeogPointInst
-        ######################
-
-        select_query = "select * from tbl_tgeogpointinst order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeogpointinst table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tgeogpointinst =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinst_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeogpointinst_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeogpoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinst_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointinst table")
-
-        ######################
-        # TGeogPointI
-        ######################
-
-        select_query = "select * from tbl_tgeogpointi order by k limit 10"
-
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeogpointi table\n")
-        rows = await connection.fetch(select_query)
-
-        for row in rows:
-            print("key =", row[0])
-            print("tgeogpointi =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinstset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeogpointinstset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeogpoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinstset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointinstset_temp table")
-
-        ######################
-        # TGeogPointSeq
-        ######################
-    
-        select_query = "select * from tbl_tgeogpointseq order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeogpointseq table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tgeogpointseq =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseq_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeogpointseq_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeogpoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseq_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        #count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointseq_temp table")
-
-        ######################
-        # TGeogPointS
-        ######################
-    
-        select_query = "select * from tbl_tgeogpoints order by k limit 10"
-    
-        print("\n****************************************************************")
-        print("Selecting rows from tbl_tgeogpoints table\n")
-        rows = await connection.fetch(select_query)
-    
-        for row in rows:
-            print("key =", row[0])
-            print("tgeogpoints =", row[1])
-            if not row[1]:
-                print("")
-            else:
-                print("startTimestamp =", row[1].startTimestamp, "\n")
-    
-        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseqset_temp;'''
-        await connection.execute(drop_table_query)
-        print("Table deleted successfully in PostgreSQL ")
-    
-        create_table_query = '''CREATE TABLE tbl_tgeogpointseqset_temp
-            (
-              k integer PRIMARY KEY,
-              temp tgeogpoint
-            ); '''
-    
-        await connection.execute(create_table_query)
-        print("Table created successfully in PostgreSQL ")
-    
-        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseqset_temp (k, temp) VALUES ($1, $2) '''
-        await connection.executemany(postgres_insert_query, rows)
-        # count = cursor.rowcount
-        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointseqset_temp table")
-    
-        print("\n****************************************************************")
-
-    finally:
-        await connection.close()
-
-loop = asyncio.get_event_loop()
-loop.run_until_complete(run())
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import asyncio
+import asyncpg
+from mobilitydb.asyncpg import register
+from mobilitydb.examples.db_connect import asyncpg_connect
+
+
+async def run():
+
+    # Set the connection parameters to PostgreSQL
+    connection = await asyncpg_connect()
+
+    try:
+        # Register MobilityDB data types
+        await register(connection)
+
+        ######################
+        # TGeogPointInst
+        ######################
+
+        select_query = "select * from tbl_tgeogpointinst order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeogpointinst table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tgeogpointinst =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinst_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeogpointinst_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeogpoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinst_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointinst table")
+
+        ######################
+        # TGeogPointI
+        ######################
+
+        select_query = "select * from tbl_tgeogpointi order by k limit 10"
+
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeogpointi table\n")
+        rows = await connection.fetch(select_query)
+
+        for row in rows:
+            print("key =", row[0])
+            print("tgeogpointi =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointinstset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeogpointinstset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeogpoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointinstset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointinstset_temp table")
+
+        ######################
+        # TGeogPointSeq
+        ######################
+    
+        select_query = "select * from tbl_tgeogpointseq order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeogpointseq table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tgeogpointseq =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseq_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeogpointseq_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeogpoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseq_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        #count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointseq_temp table")
+
+        ######################
+        # TGeogPointS
+        ######################
+    
+        select_query = "select * from tbl_tgeogpoints order by k limit 10"
+    
+        print("\n****************************************************************")
+        print("Selecting rows from tbl_tgeogpoints table\n")
+        rows = await connection.fetch(select_query)
+    
+        for row in rows:
+            print("key =", row[0])
+            print("tgeogpoints =", row[1])
+            if not row[1]:
+                print("")
+            else:
+                print("startTimestamp =", row[1].startTimestamp, "\n")
+    
+        drop_table_query = '''DROP TABLE IF EXISTS tbl_tgeogpointseqset_temp;'''
+        await connection.execute(drop_table_query)
+        print("Table deleted successfully in PostgreSQL ")
+    
+        create_table_query = '''CREATE TABLE tbl_tgeogpointseqset_temp
+            (
+              k integer PRIMARY KEY,
+              temp tgeogpoint
+            ); '''
+    
+        await connection.execute(create_table_query)
+        print("Table created successfully in PostgreSQL ")
+    
+        postgres_insert_query = ''' INSERT INTO tbl_tgeogpointseqset_temp (k, temp) VALUES ($1, $2) '''
+        await connection.executemany(postgres_insert_query, rows)
+        # count = cursor.rowcount
+        print(len(rows), "record(s) inserted successfully into tbl_tgeogpointseqset_temp table")
+    
+        print("\n****************************************************************")
+
+    finally:
+        await connection.close()
+
+loop = asyncio.get_event_loop()
+loop.run_until_complete(run())
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/examples/tbool.py` & `python-mobilitydb-0.1.3/mobilitydb/examples/tint.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,272 +1,288 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime, timedelta
-from dateutil.parser import parse
-from mobilitydb.time import TimestampSet, Period, PeriodSet
-from mobilitydb.main import TBoolInst, TBoolInstSet, TBoolSeq, TBoolSeqSet
-
-
-print("\nConstructors for TBoolInst")
-inst = TBoolInst('True@2019-09-08')
-print(inst)
-inst = TBoolInst('True', '2019-09-08')
-print(inst)
-t = parse('2019-09-08')
-inst = TBoolInst('True', t)
-print(inst)
-
-print("\nConstructors for TBoolInstSet")
-ti = TBoolInstSet('{True@2019-09-08, False@2019-09-09, False@2019-09-10}')
-print(tinstset)
-ti = TBoolInstSet('True@2019-09-08', 'False@2019-09-09', 'False@2019-09-10')
-print(tinstset)
-ti = TBoolInstSet(['True@2019-09-08', 'False@2019-09-09', 'False@2019-09-10'])
-print(tinstset)
-t1 = TBoolInst('True@2019-09-08')
-t2 = TBoolInst('False@2019-09-09')
-t3 = TBoolInst('False@2019-09-10')
-ti = TBoolInstSet(t1, t2, t3)
-print(tinstset)
-ti = TBoolInstSet([t1, t2, t3])
-print(tinstset)
-
-print("\nConstructors for TBoolSeq")
-seq = TBoolSeq('[True@2019-09-08, False@2019-09-09, False@2019-09-10]')
-print(seq)
-seq = TBoolSeq(['True@2019-09-08', 'False@2019-09-09', 'False@2019-09-10'])
-print(seq)
-seq = TBoolSeq([t1, t2, t3])
-print(seq)
-seq = TBoolSeq([t1, t2, t3], False, True)
-print(seq)
-
-print("\nConstructors for TBoolSeqSet")
-ts = TBoolSeqSet('{[True@2019-09-08, False@2019-09-09, False@2019-09-10],[False@2019-09-11, True@2019-09-12]}')
-print(ts)
-ts = TBoolSeqSet(['[True@2019-09-08, False@2019-09-09, False@2019-09-10]', '[False@2019-09-11, True@2019-09-12]'])
-print(ts)
-seq1 = TBoolSeq('[True@2019-09-08, False@2019-09-09, False@2019-09-10]')
-seq2 = TBoolSeq('[False@2019-09-11, True@2019-09-12]')
-ts = TBoolSeqSet([seq1, seq2])
-print(ts)
-
-
-print("\n__class__ ")
-print(inst.__class__.__name__)
-print(ti.__class__.__name__)
-print(seq.__class__.__name__)
-print(ts.__class__.__name__)
-
-print("\n__bases__ ")
-print(inst.__class__.__bases__)
-print(ti.__class__.__bases__)
-print(seq.__class__.__bases__)
-print(ts.__class__.__bases__)
-
-print("\ntempSubtype")
-print(inst.tempSubtype())
-print(ti.tempSubtype())
-print(seq.tempSubtype())
-print(ts.tempSubtype())
-
-print("\ninterpolation")
-print(seq.interpolation)
-print(ts.interpolation)
-
-print("\ngetValue")
-print(inst.getValue)
-
-print("\ngetValues")
-print(inst.getValues)
-print(ti.getValues)
-print(seq.getValues)
-print(ts.getValues)
-
-print("\nstartValue")
-print(inst.startValue)
-print(ti.startValue)
-print(seq.startValue)
-print(ts.startValue)
-
-print("\nendValue")
-print(inst.endValue)
-print(ti.endValue)
-print(seq.endValue)
-print(ts.endValue)
-
-print("\nminValue")
-print(inst.minValue)
-print(ti.minValue)
-print(seq.minValue)
-print(ts.minValue)
-
-print("\nmaxValue")
-print(inst.maxValue)
-print(ti.maxValue)
-print(seq.maxValue)
-print(ts.maxValue)
-
-print("\ngetTimestamp")
-print(inst.getTimestamp)
-
-print("\ngetTime")
-print(inst.getTime)
-print(ti.getTime)
-print(seq.getTime)
-print(ts.getTime)
-
-print("\nduration")
-print(inst.duration)
-print(ti.duration)
-print(seq.duration)
-print(ts.duration)
-
-print("\ntimespan")
-print(inst.timespan)
-print(ti.timespan)
-print(seq.timespan)
-print(ts.timespan)
-
-print("\nperiod")
-print(inst.period)
-print(ti.period)
-print(seq.period)
-print(ts.period)
-
-print("\nnumInstants")
-print(inst.numInstants)
-print(ti.numInstants)
-print(seq.numInstants)
-print(ts.numInstants)
-
-print("\nstartInstant")
-print(inst.startInstant)
-print(ti.startInstant)
-print(seq.startInstant)
-print(ts.startInstant)
-
-print("\nendInstant")
-print(inst.endInstant)
-print(ti.endInstant)
-print(seq.endInstant)
-print(ts.endInstant)
-
-print("\ninstantN")
-print(inst.instantN(1))
-print(ti.instantN(1))
-print(seq.instantN(1))
-print(ts.instantN(1))
-
-print("\ninstants")
-print(inst.instants)
-print(ti.instants)
-print(seq.instants)
-print(ts.instants)
-
-print("\nnumTimestamps")
-print(inst.numTimestamps)
-print(ti.numTimestamps)
-print(seq.numTimestamps)
-print(ts.numTimestamps)
-
-print("\nstartTimestamp")
-print(inst.startTimestamp)
-print(ti.startTimestamp)
-print(seq.startTimestamp)
-print(ts.startTimestamp)
-
-print("\nendTimestamp")
-print(inst.endTimestamp)
-print(ti.endTimestamp)
-print(seq.endTimestamp)
-print(ts.endTimestamp)
-
-print("\ntimestampN")
-print(inst.timestampN(1))
-print(ti.timestampN(1))
-print(seq.timestampN(1))
-print(ts.timestampN(1))
-
-print("\ntimestamps")
-print(inst.timestamps)
-print(ti.timestamps)
-print(seq.timestamps)
-print(ts.timestamps)
-
-print("\nnumSequences")
-print(seq.numSequences)
-print(ts.numSequences)
-
-print("\nstartSequence")
-print(seq.startSequence)
-print(ts.startSequence)
-
-print("\nendSequence")
-print(seq.endSequence)
-print(ts.endSequence)
-
-print("\nsequenceN")
-print(seq.sequenceN(1))
-print(ts.sequenceN(1))
-
-print("\nsequences")
-print(seq.sequences)
-print(ts.sequences)
-
-print("\nshift")
-print(inst.shift(timedelta(days=1)))
-print(ti.shift(timedelta(days=1)))
-print(seq.shift(timedelta(days=1)))
-print(ts.shift(timedelta(days=1)))
-
-print("\nintersectsTimestamp")
-t = datetime.strptime('2019-09-09', '%Y-%m-%d')
-print(inst.intersectsTimestamp(t))
-print(ti.intersectsTimestamp(t))
-print(seq.intersectsTimestamp(t))
-print(ts.intersectsTimestamp(t))
-
-print("\nintersectsTimestampSet")
-tss = TimestampSet('{2019-09-09, 2019-09-10}')
-print(inst.intersectsTimestampSet(tss))
-print(ti.intersectsTimestampSet(tss))
-print(seq.intersectsTimestampSet(tss))
-print(ts.intersectsTimestampSet(tss))
-
-print("\nintersectsPeriod")
-p = Period('2019-09-09', '2019-09-10', True, True)
-print(inst.intersectsPeriod(p))
-print(ti.intersectsPeriod(p))
-print(seq.intersectsPeriod(p))
-print(ts.intersectsPeriod(p))
-
-print("\nintersectsPeriodSet")
-ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
-print(inst.intersectsPeriodSet(ps))
-print(ti.intersectsPeriodSet(ps))
-print(seq.intersectsPeriodSet(ps))
-print(ts.intersectsPeriodSet(ps))
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime, timedelta
+from dateutil.parser import parse
+from spans.types import intrange
+from mobilitydb.time import TimestampSet, Period, PeriodSet
+from mobilitydb.main import TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
+
+
+print("\nConstructors for TFloatInst")
+inst = TIntInst('10@2019-09-08')
+print(inst)
+inst = TIntInst('10', '2019-09-08')
+print(inst)
+t = parse('2019-09-08')
+inst = TIntInst(10, t)
+print(inst)
+
+print("\nConstructors for TIntInstSet")
+ti = TIntInstSet('{10@2019-09-08, 20@2019-09-09, 20@2019-09-10}')
+print(tinstset)
+ti = TIntInstSet('10@2019-09-08', '20@2019-09-09', '20@2019-09-10')
+print(tinstset)
+ti = TIntInstSet(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
+print(tinstset)
+t1 = TIntInst('10@2019-09-08')
+t2 = TIntInst('20@2019-09-09')
+t3 = TIntInst('20@2019-09-10')
+ti = TIntInstSet(t1, t2, t3)
+print(tinstset)
+ti = TIntInstSet([t1, t2, t3])
+print(tinstset)
+
+print("\nConstructors for TIntSeq")
+seq = TIntSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+print(seq)
+seq = TIntSeq(['10@2019-09-08', '20@2019-09-09', '20@2019-09-10'])
+print(seq)
+seq = TIntSeq([t1, t2, t3])
+print(seq)
+seq = TIntSeq([t1, t2, t3], False, True)
+print(seq)
+
+print("\nConstructors for TIntSeqSet")
+ts = TIntSeqSet('{[10@2019-09-08, 20@2019-09-09, 20@2019-09-10],[15@2019-09-11, 30@2019-09-12]}')
+print(ts)
+ts = TIntSeqSet(['[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]', '[15@2019-09-11, 30@2019-09-12]'])
+print(ts)
+seq1 = TIntSeq('[10@2019-09-08, 20@2019-09-09, 20@2019-09-10]')
+seq2 = TIntSeq('[15@2019-09-11, 30@2019-09-12]')
+ts = TIntSeqSet([seq1, seq2])
+print(ts)
+
+print("\n__class__ ")
+print(inst.__class__.__name__)
+print(ti.__class__.__name__)
+print(seq.__class__.__name__)
+print(ts.__class__.__name__)
+
+print("\n__bases__ ")
+print(inst.__class__.__bases__)
+print(ti.__class__.__bases__)
+print(seq.__class__.__bases__)
+print(ts.__class__.__bases__)
+
+print("\ntempSubtype")
+print(inst.tempSubtype())
+print(ti.tempSubtype())
+print(seq.tempSubtype())
+print(ts.tempSubtype())
+
+print("\ninterpolation")
+print(seq.interpolation)
+print(ts.interpolation)
+
+print("\ngetValue")
+print(inst.getValue)
+
+print("\ngetValues")
+print(inst.getValues)
+print(ti.getValues)
+print(seq.getValues)
+print(ts.getValues)
+
+print("\nstartValue")
+print(inst.startValue)
+print(ti.startValue)
+print(seq.startValue)
+print(ts.startValue)
+
+print("\nendValue")
+print(inst.endValue)
+print(ti.endValue)
+print(seq.endValue)
+print(ts.endValue)
+
+print("\nminValue")
+print(inst.minValue)
+print(ti.minValue)
+print(seq.minValue)
+print(ts.minValue)
+
+print("\nmaxValue")
+print(inst.maxValue)
+print(ti.maxValue)
+print(seq.maxValue)
+print(ts.maxValue)
+
+print("\nvalueRange")
+print(inst.valueRange)
+print(ti.valueRange)
+print(seq.valueRange)
+print(ts.valueRange)
+
+print("\ngetTimestamp")
+print(inst.getTimestamp)
+
+print("\ngetTime")
+print(inst.getTime)
+print(ti.getTime)
+print(seq.getTime)
+print(ts.getTime)
+
+print("\nduration")
+print(inst.duration)
+print(ti.duration)
+print(seq.duration)
+print(ts.duration)
+
+print("\ntimespan")
+print(inst.timespan)
+print(ti.timespan)
+print(seq.timespan)
+print(ts.timespan)
+
+print("\nperiod")
+print(inst.period)
+print(ti.period)
+print(seq.period)
+print(ts.period)
+
+print("\nnumInstants")
+print(inst.numInstants)
+print(ti.numInstants)
+print(seq.numInstants)
+print(ts.numInstants)
+
+print("\nstartInstant")
+print(inst.startInstant)
+print(ti.startInstant)
+print(seq.startInstant)
+print(ts.startInstant)
+
+print("\nendInstant")
+print(inst.endInstant)
+print(ti.endInstant)
+print(seq.endInstant)
+print(ts.endInstant)
+
+print("\ninstantN")
+print(inst.instantN(1))
+print(ti.instantN(1))
+print(seq.instantN(1))
+print(ts.instantN(1))
+
+print("\ninstants")
+print(inst.instants)
+print(ti.instants)
+print(seq.instants)
+print(ts.instants)
+
+print("\nnumTimestamps")
+print(inst.numTimestamps)
+print(ti.numTimestamps)
+print(seq.numTimestamps)
+print(ts.numTimestamps)
+
+print("\nstartTimestamp")
+print(inst.startTimestamp)
+print(ti.startTimestamp)
+print(seq.startTimestamp)
+print(ts.startTimestamp)
+
+print("\nendTimestamp")
+print(inst.endTimestamp)
+print(ti.endTimestamp)
+print(seq.endTimestamp)
+print(ts.endTimestamp)
+
+print("\ntimestampN")
+print(inst.timestampN(1))
+print(ti.timestampN(1))
+print(seq.timestampN(1))
+print(ts.timestampN(1))
+
+print("\ntimestamps")
+print(inst.timestamps)
+print(ti.timestamps)
+print(seq.timestamps)
+print(ts.timestamps)
+
+print("\nnumSequences")
+print(seq.numSequences)
+print(ts.numSequences)
+
+print("\nstartSequence")
+print(seq.startSequence)
+print(ts.startSequence)
+
+print("\nendSequence")
+print(seq.endSequence)
+print(ts.endSequence)
+
+print("\nsequenceN")
+print(seq.sequenceN(1))
+print(ts.sequenceN(1))
+
+print("\nsequences")
+print(seq.sequences)
+print(ts.sequences)
+
+print("\nshift")
+print(inst.shift(timedelta(days=1)))
+print(ti.shift(timedelta(days=1)))
+print(seq.shift(timedelta(days=1)))
+print(ts.shift(timedelta(days=1)))
+
+print("\nintersectsTimestamp")
+t = datetime.strptime('2019-09-09', '%Y-%m-%d')
+print(inst.intersectsTimestamp(t))
+print(ti.intersectsTimestamp(t))
+print(seq.intersectsTimestamp(t))
+print(ts.intersectsTimestamp(t))
+
+print("\nintersectsTimestampSet")
+tss = TimestampSet('{2019-09-09, 2019-09-10}')
+print(inst.intersectsTimestampSet(tss))
+print(ti.intersectsTimestampSet(tss))
+print(seq.intersectsTimestampSet(tss))
+print(ts.intersectsTimestampSet(tss))
+
+print("\nintersectsPeriod")
+p = Period('2019-09-09', '2019-09-10', True, True)
+print(inst.intersectsPeriod(p))
+print(ti.intersectsPeriod(p))
+print(seq.intersectsPeriod(p))
+print(ts.intersectsPeriod(p))
+
+print("\nintersectsPeriodSet")
+ps = PeriodSet('{[2019-09-09,2019-09-10], [2019-09-11,2019-09-12]}')
+print(inst.intersectsPeriodSet(ps))
+print(ti.intersectsPeriodSet(ps))
+print(seq.intersectsPeriodSet(ps))
+print(ts.intersectsPeriodSet(ps))
+
+"""
+f = TInt('1@2000-01-01')
+print(f)
+f = TInt('{1@2000-01-01, 1@2000-01-02}')
+print(f)
+"""
+
+ts = TIntSeq('Interp=Stepwise;[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 20@2019-09-03 00:00:00+01]')
+print(repr(ts))
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/main/ttext.py` & `python-mobilitydb-0.1.3/mobilitydb/main/ttext.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,203 +1,203 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime
-from dateutil.parser import parse
-from mobilitydb.temporal.temporal_parser import parse_temporalinst
-from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
-
-
-class TText(Temporal):
-    """
-    Abstract class for representing temporal strings of any subtype.
-    """
-
-    BaseClass = str
-    BaseClassDiscrete = True
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        if value[0] != '{' and value[0] != '[' and value[0] != '(':
-            return TTextInst(value)
-        elif value[0] == '[' or value[0] == '(':
-            return TTextSeq(value)
-        elif value[0] == '{':
-            if value[1] == '[' or value[1] == '(':
-                return TTextSeqSet(value)
-            else:
-                return TTextInstSet(value)
-        raise Exception("ERROR: Could not parse temporal text value")
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, TText):
-            raise ValueError('Value must be an instance of a subclass of TText')
-        return value.__str__().strip("'")
-
-
-class TTextInst(TInstant, TText):
-    """
-    Class for representing temporal strings of instant subtype.
-
-    ``TTextInst`` objects can be created 
-    with a single argument of type string as in MobilityDB.
-
-        >>> TTextInst('AA@2019-09-01')
-
-    Another possibility is to give the ``value`` and the ``time`` arguments,
-    which can be instances of ``str`` or ``datetime``.
-
-        >>> TTextInst('AA', '2019-09-08 00:00:00+01')
-        >>> TTextInst(['AA', '2019-09-08 00:00:00+01'])
-        >>> TTextInst('AA', parse('2019-09-08 00:00:00+01'))
-        >>> TTextInst(['AA', parse('2019-09-08 00:00:00+01')])
-
-    """
-
-    """It is not possible to call super().__init__(value, time) since it is necessary
-    to strip the eventual double quotes enclosing the value
-    """
-
-    def __init__(self, value, time=None):
-        if(time is None):
-            # Constructor with a single argument of type string
-            if (isinstance(value, str)):
-                couple = parse_temporalinst(value, 0)
-                value = couple[2][0]
-                time = couple[2][1]
-            # Constructor with a single argument of type tuple or list
-            elif (isinstance(value, (tuple, list))):
-                value, time = value
-            else:
-                raise Exception("ERROR: Could not parse temporal instant value")
-        # Now both value and time are not None
-        assert(isinstance(value, str)), "ERROR: Invalid value argument"
-        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
-        # Remove double quotes if present
-        if value[0] == '"' and value[-1] == '"':
-            value = value[1:-1]
-        self._value = value
-        self._time = parse(time) if isinstance(time, str) else time
-
-
-class TTextInstSet(TInstantSet, TText):
-    """
-    Class for representing temporal strings of instant set subtype.
-
-    ``TTextInstSet`` objects can be created 
-    with a single argument of type string as in MobilityDB.
-
-        >>> TTextInstSet('AA@2019-09-01')
-
-    Another possibility is to give a tuple or list of composing instants,
-    which can be instances of ``str`` or ``TTextInst``.
-
-        >>> TTextInstSet('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01')
-        >>> TTextInstSet(TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01'))
-        >>> TTextInstSet(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'])
-        >>> TTextInstSet([TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01')])
-
-    """
-
-    ComponentClass = TTextInst
-
-    def __init__(self,  *argv):
-        super().__init__(*argv)
-
-
-class TTextSeq(TSequence, TText):
-    """
-    Class for representing temporal strings of sequence subtype.
-
-    ``TTextSeq`` objects can be created 
-    with a single argument of type string as in MobilityDB.
-
-        >>> TTextSeq('[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``instantList`` is the list of composing instants, which can be instances of
-      ``str`` or ``TTextInst``,
-    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
-      whether the bounds are inclusive or not. By default ``lower_inc``
-      is ``True`` and ``upper_inc`` is ``False``.
-
-    Some examples are given next.
-
-        >>> TTextSeq(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'])
-        >>> TTextSeq(TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01')])
-        >>> TTextSeq(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'], True, True)
-        >>> TTextSeq([TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01')], True, True)
-
-    """
-
-    ComponentClass = TTextInst
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None):
-        super().__init__(instantList, lower_inc, upper_inc)
-
-    @classmethod
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, that is, ``'Stepwise'``.
-        """
-        return 'Stepwise'
-
-
-class TTextSeqSet(TSequenceSet, TText):
-    """
-    Class for representing temporal strings of sequence subtype.
-
-    ``TTextSeqSet`` objects can be created with a single argument of typestring as in MobilityDB.
-
-        >>> TTextSeqSet('{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}')
-
-    Another possibility is to give the list of composing sequences, which can be
-    instances of ``str`` or ``TTextSeq``.
-
-        >>> TTextSeqSet(['[AA@2019-09-01 00:00:00+01]', '[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]'])
-        >>> TTextSeqSet([TTextSeq('[AA@2019-09-01 00:00:00+01]'), TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')])
-        >>> TTextSeqSet([TTextSeq('[AA@2019-09-01 00:00:00+01]'), TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')])
-
-    """
-
-    ComponentClass = TTextSeq
-
-    def __init__(self, sequenceList):
-        super().__init__(sequenceList)
-
-    @classmethod
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, that is, ``'Stepwise'``.
-        """
-        return 'Stepwise'
-
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime
+from dateutil.parser import parse
+from mobilitydb.temporal.temporal_parser import parse_temporalinst
+from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
+
+
+class TText(Temporal):
+    """
+    Abstract class for representing temporal strings of any subtype.
+    """
+
+    BaseClass = str
+    BaseClassDiscrete = True
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        if value[0] != '{' and value[0] != '[' and value[0] != '(':
+            return TTextInst(value)
+        elif value[0] == '[' or value[0] == '(':
+            return TTextSeq(value)
+        elif value[0] == '{':
+            if value[1] == '[' or value[1] == '(':
+                return TTextSeqSet(value)
+            else:
+                return TTextInstSet(value)
+        raise Exception("ERROR: Could not parse temporal text value")
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, TText):
+            raise ValueError('Value must be an instance of a subclass of TText')
+        return value.__str__().strip("'")
+
+
+class TTextInst(TInstant, TText):
+    """
+    Class for representing temporal strings of instant subtype.
+
+    ``TTextInst`` objects can be created 
+    with a single argument of type string as in MobilityDB.
+
+        >>> TTextInst('AA@2019-09-01')
+
+    Another possibility is to give the ``value`` and the ``time`` arguments,
+    which can be instances of ``str`` or ``datetime``.
+
+        >>> TTextInst('AA', '2019-09-08 00:00:00+01')
+        >>> TTextInst(['AA', '2019-09-08 00:00:00+01'])
+        >>> TTextInst('AA', parse('2019-09-08 00:00:00+01'))
+        >>> TTextInst(['AA', parse('2019-09-08 00:00:00+01')])
+
+    """
+
+    """It is not possible to call super().__init__(value, time) since it is necessary
+    to strip the eventual double quotes enclosing the value
+    """
+
+    def __init__(self, value, time=None):
+        if(time is None):
+            # Constructor with a single argument of type string
+            if (isinstance(value, str)):
+                couple = parse_temporalinst(value, 0)
+                value = couple[2][0]
+                time = couple[2][1]
+            # Constructor with a single argument of type tuple or list
+            elif (isinstance(value, (tuple, list))):
+                value, time = value
+            else:
+                raise Exception("ERROR: Could not parse temporal instant value")
+        # Now both value and time are not None
+        assert(isinstance(value, str)), "ERROR: Invalid value argument"
+        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
+        # Remove double quotes if present
+        if value[0] == '"' and value[-1] == '"':
+            value = value[1:-1]
+        self._value = value
+        self._time = parse(time) if isinstance(time, str) else time
+
+
+class TTextInstSet(TInstantSet, TText):
+    """
+    Class for representing temporal strings of instant set subtype.
+
+    ``TTextInstSet`` objects can be created 
+    with a single argument of type string as in MobilityDB.
+
+        >>> TTextInstSet('AA@2019-09-01')
+
+    Another possibility is to give a tuple or list of composing instants,
+    which can be instances of ``str`` or ``TTextInst``.
+
+        >>> TTextInstSet('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01')
+        >>> TTextInstSet(TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01'))
+        >>> TTextInstSet(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'])
+        >>> TTextInstSet([TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01')])
+
+    """
+
+    ComponentClass = TTextInst
+
+    def __init__(self,  *argv):
+        super().__init__(*argv)
+
+
+class TTextSeq(TSequence, TText):
+    """
+    Class for representing temporal strings of sequence subtype.
+
+    ``TTextSeq`` objects can be created 
+    with a single argument of type string as in MobilityDB.
+
+        >>> TTextSeq('[AA@2019-09-01 00:00:00+01, BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``instantList`` is the list of composing instants, which can be instances of
+      ``str`` or ``TTextInst``,
+    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
+      whether the bounds are inclusive or not. By default ``lower_inc``
+      is ``True`` and ``upper_inc`` is ``False``.
+
+    Some examples are given next.
+
+        >>> TTextSeq(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'])
+        >>> TTextSeq(TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01')])
+        >>> TTextSeq(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'], True, True)
+        >>> TTextSeq([TTextInst('AA@2019-09-01 00:00:00+01'), TTextInst('BB@2019-09-02 00:00:00+01'), TTextInst('AA@2019-09-03 00:00:00+01')], True, True)
+
+    """
+
+    ComponentClass = TTextInst
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None):
+        super().__init__(instantList, lower_inc, upper_inc)
+
+    @classmethod
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, that is, ``'Stepwise'``.
+        """
+        return 'Stepwise'
+
+
+class TTextSeqSet(TSequenceSet, TText):
+    """
+    Class for representing temporal strings of sequence subtype.
+
+    ``TTextSeqSet`` objects can be created with a single argument of typestring as in MobilityDB.
+
+        >>> TTextSeqSet('{[AA@2019-09-01 00:00:00+01], [BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]}')
+
+    Another possibility is to give the list of composing sequences, which can be
+    instances of ``str`` or ``TTextSeq``.
+
+        >>> TTextSeqSet(['[AA@2019-09-01 00:00:00+01]', '[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]'])
+        >>> TTextSeqSet([TTextSeq('[AA@2019-09-01 00:00:00+01]'), TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')])
+        >>> TTextSeqSet([TTextSeq('[AA@2019-09-01 00:00:00+01]'), TTextSeq('[BB@2019-09-02 00:00:00+01, AA@2019-09-03 00:00:00+01]')])
+
+    """
+
+    ComponentClass = TTextSeq
+
+    def __init__(self, sequenceList):
+        super().__init__(sequenceList)
+
+    @classmethod
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, that is, ``'Stepwise'``.
+        """
+        return 'Stepwise'
+
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/main/tfloat.py` & `python-mobilitydb-0.1.3/mobilitydb/main/tfloat.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,269 +1,269 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from datetime import datetime
-from spans.types import floatrange
-from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
-
-
-class TFloat(Temporal):
-    """
-    Abstract class for representing temporal floats of any subtype.
-    """
-
-    BaseClass = float
-    BaseClassDiscrete = False
-
-    @property
-    def valueRange(self):
-        """
-        Range of values taken by the temporal value as defined by its minimum and maximum value
-        """
-        return floatrange(self.minValue, self.maxValue, True, True)
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        if value.startswith('Interp=Stepwise;'):
-            value1 = value.replace('Interp=Stepwise;', '')
-            if value1[0] == '{':
-                return TFloatSeqSet(value)
-            else:
-                return TFloatSeq(value)
-        elif value[0] != '{' and value[0] != '[' and value[0] != '(':
-            return TFloatInst(value)
-        elif value[0] == '[' or value[0] == '(':
-            return TFloatSeq(value)
-        elif value[0] == '{':
-            if value[1] == '[' or value[1] == '(':
-                return TFloatSeqSet(value)
-            else:
-                return TFloatInstSet(value)
-        raise Exception("ERROR: Could not parse temporal float value")
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, TFloat):
-            raise ValueError('Value must be an instance of a subclass of TFloat')
-        return value.__str__().strip("'")
-
-
-class TFloatInst(TInstant, TFloat):
-    """
-    Class for representing temporal floats of instant subtype.
-
-    ``TFloatInst`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TFloatInst('10.0@2019-09-01')
-
-    Another possibility is to give the ``value`` and the ``time`` arguments,
-    which can be instances of ``str``, ``float`` or ``datetime``.
-
-        >>> TFloatInst('10.0', '2019-09-08 00:00:00+01')
-        >>> TFloatInst(['10.0', '2019-09-08 00:00:00+01'])
-        >>> TFloatInst(10.0, parse('2019-09-08 00:00:00+01'))
-        >>> TFloatInst([10.0, parse('2019-09-08 00:00:00+01')])
-
-    """
-
-    def __init__(self, value, time=None):
-        super().__init__(value, time)
-
-    @property
-    def getValues(self):
-        """
-        List of ranges representing the values taken by the temporal value
-        """
-        return [floatrange(self._value, self._value, True, True)]
-
-
-class TFloatInstSet(TInstantSet, TFloat):
-    """
-    Class for representing temporal floats of instant set subtype.
-
-    ``TFloatInstSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TFloatInstSet('10.0@2019-09-01')
-
-    Another possibility is to give a tuple or list of composing instants,
-    which can be instances of ``str`` or ``TFloatInst``.
-
-        >>> TFloatInstSet('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01')
-        >>> TFloatInstSet(TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01'))
-        >>> TFloatInstSet(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
-        >>> TFloatInstSet([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
-
-    """
-
-    ComponentClass = TFloatInst
-
-    def __init__(self,  *argv):
-        super().__init__(*argv)
-
-    @property
-    def getValues(self):
-        """
-        List of ranges representing the values taken by the temporal value.
-        """
-        values = super().getValues
-        return [floatrange(value, value, True, True) for value in values]
-
-
-class TFloatSeq(TSequence, TFloat):
-    """
-    Class for representing temporal floats of sequence subtype.
-
-    ``TFloatSeq`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TFloatSeq('[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
-        >>> TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``instantList`` is the list of composing instants, which can be instances of
-      ``str`` or ``TFloatInst``,
-    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
-      whether the bounds are inclusive or not. By default ``lower_inc``
-      is ``True`` and ``upper_inc`` is ``False``.
-    * ``interp`` which is either ``'Linear'`` or ``'Stepwise'``, the former being
-      the default.
-
-    Some examples are shown next.
-
-        >>> TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
-        >>> TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
-        >>> TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
-        >>> TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
-
-    """
-
-    ComponentClass = TFloatInst
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None):
-        super().__init__(instantList, lower_inc, upper_inc, interp)
-
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
-        """
-        return self._interp
-
-    def _interpolate(self, inst1, inst2, timestamp):
-        """
-        Interpolate the temporal value at a timestamp between inst1 and inst2.
-        """
-        # preconditions
-        if not (isinstance(inst1, TFloatInst) and
-            isinstance(inst2, TFloatInst) and isinstance(timestamp, datetime) and
-            inst1._time < timestamp and timestamp < inst2._time):
-            Exception("Erroneous arguments for function TFloatSeq._interpolate")
-
-        duration1 = timestamp - inst1._time
-        duration2 = inst2._time - inst1._time
-        ratio = duration1.total_seconds() / duration2.total_seconds();
-        return inst1._value + (inst2._value - inst1._value) * ratio;
-
-    @property
-    def getValues(self):
-        """
-        List of ranges representing the values taken by the temporal value.
-        """
-        min = self.minValue
-        max = self.maxValue
-        lower = self.startValue
-        upper = self.endValue
-        min_inc = min < lower or (min == lower and self.lower_inc)
-        max_inc = max > upper or (max == upper and self.upper_inc)
-        if not min_inc:
-            min_inc = min in self._instantList[1:-1]
-        if not max_inc:
-            max_inc = max in self._instantList[1:-1]
-        return [floatrange(min, max, min_inc, max_inc)]
-
-
-class TFloatSeqSet(TSequenceSet, TFloat):
-    """
-    Class for representing temporal floats of sequence subtype.
-
-    ``TFloatSeqSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TFloatSeqSet('{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
-        >>> TFloatSeqSet('Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``sequenceList`` is a list of composing sequences, which can be
-      instances of ``str`` or ``TFloatSeq``,
-    * ``interp`` can be ``'Linear'`` or ``'Stepwise'``, the former being
-      the default.
-
-    Some examples are shown next.
-
-        >>> TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'])
-        >>> TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear')
-        >>> TFloatSeqSet(['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise')
-        >>> TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')])
-        >>> TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),  TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear')
-        >>> TFloatSeqSet([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise')
-
-    """
-
-    ComponentClass = TFloatSeq
-
-    def __init__(self, sequenceList, interp=None):
-        super().__init__(sequenceList, interp)
-
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
-        """
-        return self._interp
-
-    @property
-    def getValues(self):
-        """
-        List of ranges representing the values taken by the temporal value
-        """
-        ranges = sorted([seq.valueRange for seq in self._sequenceList])
-        # Normalize list of ranges
-        result = []
-        range = ranges[0]
-        for range1 in ranges[1:]:
-            if range.adjacent(range1) or range.overlap(range1):
-                range = range.union(range1)
-            else:
-                result.append(range)
-                range = range1
-        result.append(range)
-        return result
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from datetime import datetime
+from spans.types import floatrange
+from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
+
+
+class TFloat(Temporal):
+    """
+    Abstract class for representing temporal floats of any subtype.
+    """
+
+    BaseClass = float
+    BaseClassDiscrete = False
+
+    @property
+    def valueRange(self):
+        """
+        Range of values taken by the temporal value as defined by its minimum and maximum value
+        """
+        return floatrange(self.minValue, self.maxValue, True, True)
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        if value.startswith('Interp=Stepwise;'):
+            value1 = value.replace('Interp=Stepwise;', '')
+            if value1[0] == '{':
+                return TFloatSeqSet(value)
+            else:
+                return TFloatSeq(value)
+        elif value[0] != '{' and value[0] != '[' and value[0] != '(':
+            return TFloatInst(value)
+        elif value[0] == '[' or value[0] == '(':
+            return TFloatSeq(value)
+        elif value[0] == '{':
+            if value[1] == '[' or value[1] == '(':
+                return TFloatSeqSet(value)
+            else:
+                return TFloatInstSet(value)
+        raise Exception("ERROR: Could not parse temporal float value")
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, TFloat):
+            raise ValueError('Value must be an instance of a subclass of TFloat')
+        return value.__str__().strip("'")
+
+
+class TFloatInst(TInstant, TFloat):
+    """
+    Class for representing temporal floats of instant subtype.
+
+    ``TFloatInst`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TFloatInst('10.0@2019-09-01')
+
+    Another possibility is to give the ``value`` and the ``time`` arguments,
+    which can be instances of ``str``, ``float`` or ``datetime``.
+
+        >>> TFloatInst('10.0', '2019-09-08 00:00:00+01')
+        >>> TFloatInst(['10.0', '2019-09-08 00:00:00+01'])
+        >>> TFloatInst(10.0, parse('2019-09-08 00:00:00+01'))
+        >>> TFloatInst([10.0, parse('2019-09-08 00:00:00+01')])
+
+    """
+
+    def __init__(self, value, time=None):
+        super().__init__(value, time)
+
+    @property
+    def getValues(self):
+        """
+        List of ranges representing the values taken by the temporal value
+        """
+        return [floatrange(self._value, self._value, True, True)]
+
+
+class TFloatInstSet(TInstantSet, TFloat):
+    """
+    Class for representing temporal floats of instant set subtype.
+
+    ``TFloatInstSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TFloatInstSet('10.0@2019-09-01')
+
+    Another possibility is to give a tuple or list of composing instants,
+    which can be instances of ``str`` or ``TFloatInst``.
+
+        >>> TFloatInstSet('10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01')
+        >>> TFloatInstSet(TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01'))
+        >>> TFloatInstSet(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
+        >>> TFloatInstSet([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
+
+    """
+
+    ComponentClass = TFloatInst
+
+    def __init__(self,  *argv):
+        super().__init__(*argv)
+
+    @property
+    def getValues(self):
+        """
+        List of ranges representing the values taken by the temporal value.
+        """
+        values = super().getValues
+        return [floatrange(value, value, True, True) for value in values]
+
+
+class TFloatSeq(TSequence, TFloat):
+    """
+    Class for representing temporal floats of sequence subtype.
+
+    ``TFloatSeq`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TFloatSeq('[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
+        >>> TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01, 20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``instantList`` is the list of composing instants, which can be instances of
+      ``str`` or ``TFloatInst``,
+    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
+      whether the bounds are inclusive or not. By default ``lower_inc``
+      is ``True`` and ``upper_inc`` is ``False``.
+    * ``interp`` which is either ``'Linear'`` or ``'Stepwise'``, the former being
+      the default.
+
+    Some examples are shown next.
+
+        >>> TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'])
+        >>> TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')])
+        >>> TFloatSeq(['10.0@2019-09-01 00:00:00+01', '20.0@2019-09-02 00:00:00+01', '10.0@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
+        >>> TFloatSeq([TFloatInst('10.0@2019-09-01 00:00:00+01'), TFloatInst('20.0@2019-09-02 00:00:00+01'), TFloatInst('10.0@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
+
+    """
+
+    ComponentClass = TFloatInst
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None):
+        super().__init__(instantList, lower_inc, upper_inc, interp)
+
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
+        """
+        return self._interp
+
+    def _interpolate(self, inst1, inst2, timestamp):
+        """
+        Interpolate the temporal value at a timestamp between inst1 and inst2.
+        """
+        # preconditions
+        if not (isinstance(inst1, TFloatInst) and
+            isinstance(inst2, TFloatInst) and isinstance(timestamp, datetime) and
+            inst1._time < timestamp and timestamp < inst2._time):
+            Exception("Erroneous arguments for function TFloatSeq._interpolate")
+
+        duration1 = timestamp - inst1._time
+        duration2 = inst2._time - inst1._time
+        ratio = duration1.total_seconds() / duration2.total_seconds();
+        return inst1._value + (inst2._value - inst1._value) * ratio;
+
+    @property
+    def getValues(self):
+        """
+        List of ranges representing the values taken by the temporal value.
+        """
+        min = self.minValue
+        max = self.maxValue
+        lower = self.startValue
+        upper = self.endValue
+        min_inc = min < lower or (min == lower and self.lower_inc)
+        max_inc = max > upper or (max == upper and self.upper_inc)
+        if not min_inc:
+            min_inc = min in self._instantList[1:-1]
+        if not max_inc:
+            max_inc = max in self._instantList[1:-1]
+        return [floatrange(min, max, min_inc, max_inc)]
+
+
+class TFloatSeqSet(TSequenceSet, TFloat):
+    """
+    Class for representing temporal floats of sequence subtype.
+
+    ``TFloatSeqSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TFloatSeqSet('{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
+        >>> TFloatSeqSet('Interp=Stepwise;{[10.0@2019-09-01 00:00:00+01], [20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]}')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``sequenceList`` is a list of composing sequences, which can be
+      instances of ``str`` or ``TFloatSeq``,
+    * ``interp`` can be ``'Linear'`` or ``'Stepwise'``, the former being
+      the default.
+
+    Some examples are shown next.
+
+        >>> TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'])
+        >>> TFloatSeqSet(['[10.0@2019-09-01 00:00:00+01]', '[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Linear')
+        >>> TFloatSeqSet(['Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]'], 'Stepwise')
+        >>> TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')])
+        >>> TFloatSeqSet([TFloatSeq('[10.0@2019-09-01 00:00:00+01]'),  TFloatSeq('[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Linear')
+        >>> TFloatSeqSet([TFloatSeq('Interp=Stepwise;[10.0@2019-09-01 00:00:00+01]'), TFloatSeq('Interp=Stepwise;[20.0@2019-09-02 00:00:00+01, 10.0@2019-09-03 00:00:00+01]')], 'Stepwise')
+
+    """
+
+    ComponentClass = TFloatSeq
+
+    def __init__(self, sequenceList, interp=None):
+        super().__init__(sequenceList, interp)
+
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
+        """
+        return self._interp
+
+    @property
+    def getValues(self):
+        """
+        List of ranges representing the values taken by the temporal value
+        """
+        ranges = sorted([seq.valueRange for seq in self._sequenceList])
+        # Normalize list of ranges
+        result = []
+        range = ranges[0]
+        for range1 in ranges[1:]:
+            if range.adjacent(range1) or range.overlap(range1):
+                range = range.union(range1)
+            else:
+                result.append(range)
+                range = range1
+        result.append(range)
+        return result
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/main/tpoint.py` & `python-mobilitydb-0.1.3/mobilitydb/main/tpoint.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,723 +1,723 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-import re
-from datetime import datetime
-from dateutil.parser import parse
-from postgis import Geometry, Point, MultiPoint, LineString, GeometryCollection, MultiLineString
-from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
-from mobilitydb.temporal.temporal_parser import parse_temporalinst, parse_temporalinstset, parse_temporalseq, parse_temporalseqset
-
-
-# Add method to Point to make the class hashable
-def __hash__(self):
-    return hash(self.values())
-
-setattr(Point, '__hash__', __hash__)
-
-
-class TPointInst(TInstant):
-    """
-    Abstract class for representing temporal points of instant subtype.
-    """
-
-    def __init__(self, value, time=None, srid=None):
-        if time is None:
-            # Constructor with a single argument of type string
-            if isinstance(value, str):
-                # If srid is given
-                if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', value):
-                    #Get the srid and remove the "srid=xxx;" prefix
-                    srid_str = int(re.search(r'(\d+)', value).group())
-                    if srid is not None and srid_str != srid:
-                        raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
-                    srid = srid_str
-                    value = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', value)
-                else:
-                    if srid is None:
-                        srid = 0
-                #Parse without the eventual "srid=xxx;" prefix
-                couple = parse_temporalinst(value, 0)
-                value = couple[2][0]
-                time = couple[2][1]
-            # Constructor with a single argument of type tuple or list
-            elif isinstance(value, (tuple, list)):
-                value, time, *extra = value
-                if extra:
-                    srid, *extra = extra
-                else:
-                    srid = 0
-            else:
-                raise Exception("ERROR: Could not parse temporal instant value")
-        if srid is None:
-            srid = 0
-        # Now value, time, and srid are not None
-        assert(isinstance(value, (str, Point))), "ERROR: Invalid value argument"
-        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
-        assert(isinstance(srid, (str, int))), "ERROR: Invalid SRID"
-        if isinstance(value, str):
-            if '(' in value and ')' in value:
-                idx1 = value.find('(')
-                idx2 = value.find(')')
-                coords = (value[idx1 + 1:idx2]).split(' ')
-                self._value = Point(coords, srid=srid)
-            else:
-                self._value = Geometry.from_ewkb(value)
-        else:
-            self._value = value
-        self._time = parse(time) if isinstance(time, str) else time
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        if self._value.m is not None:
-            raise Exception("ERROR: The points composing a temporal point cannot have M dimension")
-
-    @property
-    def getValues(self):
-        """
-        Geometry representing the values taken by the temporal value.
-        """
-        return self._value
-
-
-class TPointInstSet(TInstantSet):
-    """
-    Abstract class for representing temporal points of instant set subtype.
-    """
-
-    def __init__(self,  *argv, srid=None):
-        self._instantList = []
-        # Constructor with a single argument of type string
-        if len(argv) == 1 and isinstance(argv[0], str):
-            # If srid is given
-            if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', argv[0]):
-                # Get the srid and remove the "srid=xxx;" prefix
-                srid_str = int(re.search(r'(\d+)', argv[0]).group())
-                if srid is not None and srid_str != srid:
-                    raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
-                srid = srid_str
-                instantList = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', argv[0])
-            else:
-                instantList = argv[0]
-            # Parse without the eventual "srid=xxx;" prefix
-            elements = parse_temporalinstset(instantList, 0)
-            for inst in elements[2]:
-                self._instantList.append(self.ComponentClass(inst[0], inst[1], srid=srid))
-        # Constructor with a single argument of type list
-        elif len(argv) == 1 and isinstance(argv[0], list):
-            # List of strings representing instant values
-            if all(isinstance(arg, str) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._instantList.append(self.ComponentClass(arg, srid=srid))
-            # List of instant values
-            elif all(isinstance(arg, self.ComponentClass) for arg in argv[0]):
-                for arg in argv[0]:
-                    self._instantList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse temporal instant set value")
-        # Constructor with multiple arguments
-        else:
-            # Arguments are of type string
-            if all(isinstance(arg, str) for arg in argv):
-                for arg in argv:
-                    self._instantList.append(self.ComponentClass(arg, srid=srid))
-            # Arguments are of type instant
-            elif all(isinstance(arg, self.ComponentClass) for arg in argv):
-                for arg in argv:
-                    self._instantList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse temporal instant set value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        super()._valid()
-        if any((x._value.z is None and y._value.z is not None) or (x._value.z is not None and y._value.z is None) \
-                for x, y in zip(self._instantList, self._instantList[1:])):
-            raise Exception("ERROR: The points composing a temporal point must be of the same dimensionality")
-        if any(x._value.m is not None for x in self._instantList):
-            raise Exception("ERROR: The points composing a temporal point cannot have M dimension")
-        if any(x.srid != y.srid for x, y in zip(self._instantList, self._instantList[1:])):
-            raise Exception("ERROR: The points composing a temporal point must have the same SRID")
-
-    @property
-    def getValues(self):
-        """
-        Geometry representing the values taken by the temporal value.
-        """
-        values = super().getValues
-        return MultiPoint(values)
-
-
-class TPointSeq(TSequence):
-    """
-    Abstract class for representing temporal points of sequence subtype.
-    """
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None, srid=None):
-        assert (isinstance(lower_inc, (bool, type(None)))), "ERROR: Invalid lower bound flag"
-        assert (isinstance(upper_inc, (bool, type(None)))), "ERROR: Invalid upper bound flag"
-        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
-        if isinstance(interp, str):
-            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
-        self._instantList = []
-        # Constructor with a first argument of type string and optional arguments for the bounds and interpolation
-        if isinstance(instantList, str):
-            # If srid is given
-            if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', instantList):
-                # Get the srid and remove the "srid=xxx;" prefix
-                srid_str = int(re.search(r'(\d+)', instantList).group())
-                if srid is not None and srid_str != srid:
-                    raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
-                srid = srid_str
-                instantList = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', instantList)
-            # Parse without the eventual "srid=xxx;" prefix
-            elements = parse_temporalseq(instantList, 0)
-            for inst in elements[2][0]:
-                self._instantList.append(self.ComponentClass(inst[0], inst[1], srid=srid))
-            self._lower_inc = elements[2][1]
-            self._upper_inc = elements[2][2]
-            # Set interpolation with the argument or the flag from the string if given
-            if interp is not None:
-                self._interp = interp
-            else:
-                if self.BaseClassDiscrete:
-                    self._interp = 'Stepwise'
-                else:
-                    self._interp = elements[2][3] if elements[2][3] is not None else 'Linear'
-        # Constructor with a first argument of type list and optional arguments for the bounds and interpolation
-        elif isinstance(instantList, list):
-            # List of strings representing instant values
-            if all(isinstance(arg, str) for arg in instantList):
-                for arg in instantList:
-                    self._instantList.append(self.ComponentClass(arg, srid=srid))
-            # List of instant values
-            elif all(isinstance(arg, self.ComponentClass) for arg in instantList):
-                for arg in instantList:
-                    self._instantList.append(arg)
-            else:
-                raise Exception("ERROR: Could not parse temporal sequence value")
-            self._lower_inc = lower_inc if lower_inc is not None else True
-            self._upper_inc = upper_inc if upper_inc is not None else False
-            # Set the interpolation
-            if interp is not None:
-                self._interp = interp
-            else:
-                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
-        else:
-            raise Exception("ERROR: Could not parse temporal sequence value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        super()._valid()
-        if any((x._value.z is None and y._value.z is not None) or (x._value.z is not None and y._value.z is None) \
-                for x, y in zip(self._instantList, self._instantList[1:])):
-            raise Exception("ERROR: The points composing a temporal point must be of the same dimensionality")
-        if any(x._value.m is not None for x in self._instantList):
-            raise Exception("ERROR: The points composing a temporal point cannot have M dimension")
-        if any(x.srid != y.srid for x, y in zip(self._instantList, self._instantList[1:])):
-            raise Exception("ERROR: The points composing a temporal point must have the same SRID")
-
-
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
-        """
-        return self._interp
-
-    @property
-    def getValues(self):
-        """
-        Geometry representing the values taken by the temporal value.
-        """
-        values = [inst._value for inst in self._instantList]
-        result = values[0] if len(values) == 1 else LineString(values)
-        return result
-
-
-class TPointSeqSet(TSequenceSet):
-    """
-    Abstract class for representing temporal points of sequence set subtype.
-    """
-
-    def __init__(self, sequenceList, interp=None, srid=None):
-        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
-        if isinstance(interp, str) and interp is None:
-            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
-        self._sequenceList = []
-        # Constructor with a single argument of type string
-        if isinstance(sequenceList, str):
-            # If srid is given
-            if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', sequenceList):
-                # Get the srid and remove the "srid=xxx;" prefix
-                srid_str = int(re.search(r'(\d+)', sequenceList).group())
-                if srid is not None and srid_str != srid:
-                    raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
-                srid = srid_str
-                sequenceList = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', sequenceList)
-            # Parse without the eventual "srid=xxx;" prefix
-            elements = parse_temporalseqset(sequenceList, 0)
-            seqList = []
-            for seq in elements[2][0]:
-                instList = []
-                for inst in seq[0]:
-                    instList.append(self.ComponentClass.ComponentClass(inst[0], inst[1], srid=srid))
-                if self.BaseClassDiscrete:
-                    seqList.append(self.ComponentClass(instList, seq[1], seq[2]))
-                else:
-                    seqList.append(self.ComponentClass(instList, seq[1], seq[2], elements[2][1], srid=srid))
-            self._sequenceList = seqList
-            # Set interpolation with the argument or the flag from the string if given
-            if interp is not None:
-                self._interp = interp
-            else:
-                if self.BaseClassDiscrete:
-                    self._interp = 'Stepwise'
-                else:
-                    self._interp = elements[2][1] if elements[2][1] is not None else 'Linear'
-        # Constructor with a single argument of type list
-        elif isinstance(sequenceList, list):
-            # List of strings representing periods
-            if all(isinstance(sequence, str) for sequence in sequenceList):
-                for sequence in sequenceList:
-                    self._sequenceList.append(self.ComponentClass(sequence))
-            # List of periods
-            elif all(isinstance(sequence, self.ComponentClass) for sequence in sequenceList):
-                for sequence in sequenceList:
-                    self._sequenceList.append(sequence)
-            else:
-                raise Exception("ERROR: Could not parse temporal sequence set value")
-            # Set the interpolation
-            if interp is not None:
-                self._interp = interp
-            else:
-                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
-        else:
-            raise Exception("ERROR: Could not parse temporal sequence set value")
-        # Verify validity of the resulting instance
-        self._valid()
-
-    def _valid(self):
-        super()._valid()
-        if any((x.hasz is None and y.hasz is not None) or (x.hasz is not None and y.hasz is None) \
-                for x, y in zip(self._sequenceList, self._sequenceList[1:])):
-            raise Exception("ERROR: The points composing a temporal point must be of the same dimensionality")
-        if any(x.srid != y.srid for x, y in zip(self._sequenceList, self._sequenceList[1:])):
-            raise Exception("ERROR: The points composing a temporal point must have the same SRID")
-
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
-        """
-        return self._interp
-
-    @property
-    def getValues(self):
-        """
-        Geometry representing the values taken by the temporal value.
-        """
-        values = [seq.getValues for seq in self._sequenceList]
-        points = [geo for geo in values if isinstance(geo, Point)]
-        lines = [geo for geo in values if isinstance(geo, LineString)]
-        if len(points) != 0 and len(points) != 0:
-            return GeometryCollection(points + lines)
-        if len(points) != 0 and len(points) == 0:
-            return MultiPoint(points)
-        if len(points) == 0 and len(points) != 0:
-            return MultiLineString(lines)
-
-
-class TGeomPoint(Temporal):
-    """
-    Abstract class for representing temporal geometric or geographic points of any subtype.
-    """
-
-    BaseClass = Point
-    BaseClassDiscrete = False
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        if value.startswith('Interp=Stepwise;'):
-            value1 = value.replace('Interp=Stepwise;', '')
-            if value1[0] == '{':
-                return TGeomPointSeqSet(value)
-            else:
-                return TGeomPointSeq(value)
-        elif value[0] != '{' and value[0] != '[' and value[0] != '(':
-            return TGeomPointInst(value)
-        elif value[0] == '[' or value[0] == '(':
-            return TGeomPointSeq(value)
-        elif value[0] == '{':
-            if value[1] == '[' or value[1] == '(':
-                return TGeomPointSeqSet(value)
-            else:
-                return TGeomPointInstSet(value)
-        raise Exception("ERROR: Could not parse temporal point value")
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, TGeomPoint):
-            raise ValueError('Value must an instance of a subclass of TGeomPoint')
-        return value.__str__().strip("'")
-
-    @property
-    def hasz(self):
-        """
-        Does the temporal point has Z dimension?
-        """
-        return self.startValue.z is not None
-
-    @property
-    def srid(self):
-        """
-        Returns the SRID.
-        """
-        result = self.startValue.srid if hasattr(self.startValue, "srid") else None
-        return result
-
-
-class TGeogPoint(Temporal):
-    """
-    Abstract class for representing temporal geographic points of any subtype.
-    """
-
-    BaseClass = Point
-    BaseClassDiscrete = False
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        if value.startswith('Interp=Stepwise;'):
-            value1 = value.replace('Interp=Stepwise;', '')
-            if value1[0] == '{':
-                return TGeogPointSeqSet(value)
-            else:
-                return TGeogPointSeq(value)
-        elif value[0] != '{' and value[0] != '[' and value[0] != '(':
-            return TGeogPointInst(value)
-        elif value[0] == '[' or value[0] == '(':
-            return TGeogPointSeq(value)
-        elif value[0] == '{':
-            if value[1] == '[' or value[1] == '(':
-                return TGeogPointSeqSet(value)
-            else:
-                return TGeogPointInstSet(value)
-        raise Exception("ERROR: Could not parse temporal point value")
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, TGeogPoint):
-            raise ValueError('Value must an instance of a subclass of TGeogPoint')
-        return value.__str__().strip("'")
-
-    @property
-    def hasz(self):
-        """
-        Does the temporal point has Z dimension?
-        """
-        return self.startValue.z is not None
-
-    @property
-    def srid(self):
-        """
-        Returns the SRID.
-        """
-        result = self.startValue.srid if hasattr(self.startValue, "srid") else None
-        return result
-
-
-class TGeomPointInst(TPointInst, TGeomPoint):
-    """
-    Class for representing temporal geometric points of instant subtype.
-
-    ``TGeomPointInst`` objects can be created with a single argument of type
-    string as in MobilityDB.
-
-        >>> TGeomPointInst('Point(10.0 10.0)@2019-09-01')
-        >>> TGeomPointInst('SRID=4326,Point(10.0 10.0)@2019-09-01')
-
-    Another possibility is to give the ``value`` and the ``time`` arguments,
-    which can be instances of ``str``, ``Point`` or ``datetime``.
-    Additionally, the SRID can be specified, it will be 0 by default if not
-    given.
-
-        >>> TGeomPointInst('Point(10.0 10.0)', '2019-09-08 00:00:00+01', 4326)
-        >>> TGeomPointInst(['Point(10.0 10.0)', '2019-09-08 00:00:00+01', 4326])
-        >>> TGeomPointInst(Point(10.0, 10.0), parse('2019-09-08 00:00:00+01'), 4326)
-        >>> TGeomPointInst([Point(10.0, 10.0), parse('2019-09-08 00:00:00+01'), 4326])
-
-    """
-
-    def __init__(self, value, time=None, srid=None):
-        super().__init__(value, time, srid)
-
-
-class TGeogPointInst(TPointInst, TGeogPoint):
-    """
-    Class for representing temporal geographic points of instant subtype.
-
-    ``TGeogPointInst`` objects can be created with a single argument of type
-    string as in MobilityDB.
-
-        >>> TGeogPointInst('Point(10.0 10.0)@2019-09-01')
-
-    Another possibility is to give the ``value`` and the ``time`` arguments,
-    which can be instances of ``str``, ``Point`` or ``datetime``.
-    Additionally, the SRID can be specified, it will be 0 by default if not
-    given.
-
-        >>> TGeogPointInst('Point(10.0 10.0)', '2019-09-08 00:00:00+01')
-        >>> TGeogPointInst(['Point(10.0 10.0)', '2019-09-08 00:00:00+01'])
-        >>> TGeogPointInst(Point(10.0, 10.0), parse('2019-09-08 00:00:00+01'))
-        >>> TGeogPointInst([Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')])
-
-    """
-
-    def __init__(self, value, time=None, srid=None):
-        super().__init__(value, time, srid)
-
-
-class TGeomPointInstSet(TPointInstSet, TGeomPoint):
-    """
-    Class for representing temporal geometric points of instant set subtype.
-
-    ``TGeomPointInstSet`` objects can be created with a single argument of type
-    string as in MobilityDB.
-
-        >>> TGeomPointInstSet('Point(10.0 10.0)@2019-09-01')
-
-    Another possibility is to give a tuple or list of arguments specifying
-    the composing instants, which can be instances of ``str`` or
-    ``TGeomPointInst``.
-
-        >>> TGeomPointInstSet('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01')
-        >>> TGeomPointInstSet(TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01'))
-        >>> TGeomPointInstSet(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
-        >>> TGeomPointInstSet([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
-
-    """
-
-    ComponentClass = TGeomPointInst
-
-    def __init__(self,  *argv, **kwargs):
-        super().__init__(*argv, **kwargs)
-
-
-class TGeogPointInstSet(TPointInstSet, TGeogPoint):
-    """
-    Class for representing temporal geometric points of instant set subtype.
-
-    ``TGeogPointInstSet`` objects can be created with a single argument of type
-    string as in MobilityDB.
-
-        >>> TGeogPointInstSet('Point(10.0 10.0)@2019-09-01')
-
-    Another possibility is to give a tuple or list of arguments specifying
-    the composing instants, which can be instances of ``str`` or
-    ``TGeogPointInst``.
-
-        >>> TGeogPointInstSet('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01')
-        >>> TGeogPointInstSet(TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01'))
-        >>> TGeogPointInstSet(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
-        >>> TGeogPointInstSet([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
-
-    """
-
-    ComponentClass = TGeogPointInst
-
-    def __init__(self,  *argv, **kwargs):
-        super().__init__(*argv, **kwargs)
-
-
-class TGeomPointSeq(TPointSeq, TGeomPoint):
-    """
-    Class for representing temporal geometric points of sequence subtype.
-
-    ``TGeomPointSeq`` objects can be created with a single argument of type
-    string as in MobilityDB.
-
-        >>> TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
-        >>> TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``instantList`` is the list of composing instants, which can be instances
-      of ``str`` or ``TGeogPointInst``,
-    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
-      whether the bounds are inclusive or not,  where by default '`lower_inc``
-      is ``True`` and ``upper_inc`` is ``False``,
-    * ``interp`` which is either ``'Linear'`` or ``'Stepwise'``, the former
-      being the default, and
-    * ``srid`` is an integer specifiying the SRID
-
-    Some examples are shown next.
-
-        >>> TGeomPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
-        >>> TGeomPointSeq([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
-        >>> TGeomPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
-        >>> TGeomPointSeq([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
-
-    """
-
-    ComponentClass = TGeomPointInst
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None, srid=None):
-        super().__init__(instantList, lower_inc, upper_inc, interp, srid)
-
-    def _interpolate(self, inst1, inst2, timestamp):
-        """
-        Interpolate the temporal value at a timestamp between inst1 and inst2.
-        """
-        # preconditions
-        if not (isinstance(inst1, TGeomPointInst) and isinstance(inst2, TGeomPointInst) and
-            isinstance(timestamp, datetime) and inst1._time < timestamp and timestamp < inst2._time):
-            Exception("Erroneous arguments for function TGeomPointSeq._interpolate")
-
-        duration1 = timestamp - inst1._time
-        duration2 = inst2._time - inst1._time
-        ratio = duration1.total_seconds() / duration2.total_seconds();
-        x = inst1._value.x + (inst2._value.x - inst1._value.x) * ratio;
-        y = inst1._value.y + (inst2._value.y - inst1._value.y) * ratio;
-        if inst1._value.z is not None and inst2._value.z is not None:
-            z = inst1._value.z + (inst2._value.z - inst1._value.z) * ratio;
-            return Point(x,y,z);
-        else:
-            return Point(x,y);
-
-
-class TGeogPointSeq(TPointSeq, TGeogPoint):
-    """
-    Class for representing temporal geographic points of sequence subtype.
-
-    ``TGeogPointSeq`` objects can be created with a single argument of type
-    string as in MobilityDB.
-
-        >>> TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
-        >>> TGeogPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``instantList`` is the list of composing instants, which can be instances
-      of ``str`` or ``TGeogPointInst``,
-    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
-      whether the bounds are includive or not,  where by default '`lower_inc``
-      is ``True`` and ``upper_inc`` is ``False``, and
-    * ``interp`` which is either ``'Linear'`` or ``'Stepwise'``, the former
-      being the default.
-    * ``srid`` is an integer specifiying the SRID
-
-    Some examples are shown next.
-
-        >>> TGeogPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
-        >>> TGeogPointSeq([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
-        >>> TGeogPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
-        >>> TGeogPointSeq([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
-
-    """
-
-    ComponentClass = TGeogPointInst
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None, srid=None):
-        super().__init__(instantList, lower_inc, upper_inc, interp, srid)
-
-
-class TGeomPointSeqSet(TPointSeqSet, TGeomPoint):
-    """
-    Class for representing temporal geometric points of sequence subtype.
-
-    ``TGeomPointSeqSet`` objects can be created with a single argument of type
-    string as in MobilityDB.
-
-        >>> TGeomPointSeqSet('{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
-        >>> TGeomPointSeqSet('Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``sequenceList`` is the list of composing sequences, which can be instances
-      of ``str`` or ``TGeomPointSeq``,
-    * ``interp`` can be ``'Linear'`` or ``'Stepwise'``, the former being
-      the default, and
-    * ``srid`` is an integer specifiying the SRID, if will be 0 by default if
-      not given.
-
-    Some examples are shown next.
-
-        >>> TGeomPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'])
-        >>> TGeomPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear')
-        >>> TGeomPointSeqSet(['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Stepwise')
-        >>> TGeomPointSeqSet([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')])
-        >>> TGeomPointSeqSet([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),  TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear')
-        >>> TGeomPointSeqSet([TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeomPointSeq('Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Stepwise')
-
-    """
-
-    ComponentClass = TGeomPointSeq
-
-    def __init__(self, sequenceList, interp=None, srid=None):
-        super().__init__(sequenceList, interp, srid)
-
-
-class TGeogPointSeqSet(TPointSeqSet, TGeogPoint):
-    """
-    Class for representing temporal geographic points of sequence subtype.
-
-    ``TGeogPointSeqSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TGeogPointSeqSet('{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
-        >>> TGeogPointSeqSet('Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``sequenceList`` is the list of composing sequences, which can be instances
-      of ``str`` or ``TGeogPointSeq``,
-    * ``interp`` can be ``'Linear'`` or ``'Stepwise'``, the former being
-      the default, and
-    * ``srid`` is an integer specifiying the SRID, if will be 0 by default if
-      not given.
-
-    Some examples are shown next.
-
-        >>> TGeogPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'])
-        >>> TGeogPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear')
-        >>> TGeogPointSeqSet(['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Stepwise')
-        >>> TGeogPointSeqSet([TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')])
-        >>> TGeogPointSeqSet([TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),  TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear')
-        >>> TGeogPointSeqSet([TGeogPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeogPointSeq('Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Stepwise')
-
-    """
-
-    ComponentClass = TGeogPointSeq
-
-    def __init__(self, sequenceList, interp=None, srid=None):
-        super().__init__(sequenceList, interp, srid)
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+import re
+from datetime import datetime
+from dateutil.parser import parse
+from postgis import Geometry, Point, MultiPoint, LineString, GeometryCollection, MultiLineString
+from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
+from mobilitydb.temporal.temporal_parser import parse_temporalinst, parse_temporalinstset, parse_temporalseq, parse_temporalseqset
+
+
+# Add method to Point to make the class hashable
+def __hash__(self):
+    return hash(self.values())
+
+setattr(Point, '__hash__', __hash__)
+
+
+class TPointInst(TInstant):
+    """
+    Abstract class for representing temporal points of instant subtype.
+    """
+
+    def __init__(self, value, time=None, srid=None):
+        if time is None:
+            # Constructor with a single argument of type string
+            if isinstance(value, str):
+                # If srid is given
+                if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', value):
+                    #Get the srid and remove the "srid=xxx;" prefix
+                    srid_str = int(re.search(r'(\d+)', value).group())
+                    if srid is not None and srid_str != srid:
+                        raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
+                    srid = srid_str
+                    value = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', value)
+                else:
+                    if srid is None:
+                        srid = 0
+                #Parse without the eventual "srid=xxx;" prefix
+                couple = parse_temporalinst(value, 0)
+                value = couple[2][0]
+                time = couple[2][1]
+            # Constructor with a single argument of type tuple or list
+            elif isinstance(value, (tuple, list)):
+                value, time, *extra = value
+                if extra:
+                    srid, *extra = extra
+                else:
+                    srid = 0
+            else:
+                raise Exception("ERROR: Could not parse temporal instant value")
+        if srid is None:
+            srid = 0
+        # Now value, time, and srid are not None
+        assert(isinstance(value, (str, Point))), "ERROR: Invalid value argument"
+        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
+        assert(isinstance(srid, (str, int))), "ERROR: Invalid SRID"
+        if isinstance(value, str):
+            if '(' in value and ')' in value:
+                idx1 = value.find('(')
+                idx2 = value.find(')')
+                coords = (value[idx1 + 1:idx2]).split(' ')
+                self._value = Point(coords, srid=srid)
+            else:
+                self._value = Geometry.from_ewkb(value)
+        else:
+            self._value = value
+        self._time = parse(time) if isinstance(time, str) else time
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        if self._value.m is not None:
+            raise Exception("ERROR: The points composing a temporal point cannot have M dimension")
+
+    @property
+    def getValues(self):
+        """
+        Geometry representing the values taken by the temporal value.
+        """
+        return self._value
+
+
+class TPointInstSet(TInstantSet):
+    """
+    Abstract class for representing temporal points of instant set subtype.
+    """
+
+    def __init__(self,  *argv, srid=None):
+        self._instantList = []
+        # Constructor with a single argument of type string
+        if len(argv) == 1 and isinstance(argv[0], str):
+            # If srid is given
+            if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', argv[0]):
+                # Get the srid and remove the "srid=xxx;" prefix
+                srid_str = int(re.search(r'(\d+)', argv[0]).group())
+                if srid is not None and srid_str != srid:
+                    raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
+                srid = srid_str
+                instantList = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', argv[0])
+            else:
+                instantList = argv[0]
+            # Parse without the eventual "srid=xxx;" prefix
+            elements = parse_temporalinstset(instantList, 0)
+            for inst in elements[2]:
+                self._instantList.append(self.ComponentClass(inst[0], inst[1], srid=srid))
+        # Constructor with a single argument of type list
+        elif len(argv) == 1 and isinstance(argv[0], list):
+            # List of strings representing instant values
+            if all(isinstance(arg, str) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._instantList.append(self.ComponentClass(arg, srid=srid))
+            # List of instant values
+            elif all(isinstance(arg, self.ComponentClass) for arg in argv[0]):
+                for arg in argv[0]:
+                    self._instantList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse temporal instant set value")
+        # Constructor with multiple arguments
+        else:
+            # Arguments are of type string
+            if all(isinstance(arg, str) for arg in argv):
+                for arg in argv:
+                    self._instantList.append(self.ComponentClass(arg, srid=srid))
+            # Arguments are of type instant
+            elif all(isinstance(arg, self.ComponentClass) for arg in argv):
+                for arg in argv:
+                    self._instantList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse temporal instant set value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        super()._valid()
+        if any((x._value.z is None and y._value.z is not None) or (x._value.z is not None and y._value.z is None) \
+                for x, y in zip(self._instantList, self._instantList[1:])):
+            raise Exception("ERROR: The points composing a temporal point must be of the same dimensionality")
+        if any(x._value.m is not None for x in self._instantList):
+            raise Exception("ERROR: The points composing a temporal point cannot have M dimension")
+        if any(x.srid != y.srid for x, y in zip(self._instantList, self._instantList[1:])):
+            raise Exception("ERROR: The points composing a temporal point must have the same SRID")
+
+    @property
+    def getValues(self):
+        """
+        Geometry representing the values taken by the temporal value.
+        """
+        values = super().getValues
+        return MultiPoint(values)
+
+
+class TPointSeq(TSequence):
+    """
+    Abstract class for representing temporal points of sequence subtype.
+    """
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None, srid=None):
+        assert (isinstance(lower_inc, (bool, type(None)))), "ERROR: Invalid lower bound flag"
+        assert (isinstance(upper_inc, (bool, type(None)))), "ERROR: Invalid upper bound flag"
+        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
+        if isinstance(interp, str):
+            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
+        self._instantList = []
+        # Constructor with a first argument of type string and optional arguments for the bounds and interpolation
+        if isinstance(instantList, str):
+            # If srid is given
+            if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', instantList):
+                # Get the srid and remove the "srid=xxx;" prefix
+                srid_str = int(re.search(r'(\d+)', instantList).group())
+                if srid is not None and srid_str != srid:
+                    raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
+                srid = srid_str
+                instantList = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', instantList)
+            # Parse without the eventual "srid=xxx;" prefix
+            elements = parse_temporalseq(instantList, 0)
+            for inst in elements[2][0]:
+                self._instantList.append(self.ComponentClass(inst[0], inst[1], srid=srid))
+            self._lower_inc = elements[2][1]
+            self._upper_inc = elements[2][2]
+            # Set interpolation with the argument or the flag from the string if given
+            if interp is not None:
+                self._interp = interp
+            else:
+                if self.BaseClassDiscrete:
+                    self._interp = 'Stepwise'
+                else:
+                    self._interp = elements[2][3] if elements[2][3] is not None else 'Linear'
+        # Constructor with a first argument of type list and optional arguments for the bounds and interpolation
+        elif isinstance(instantList, list):
+            # List of strings representing instant values
+            if all(isinstance(arg, str) for arg in instantList):
+                for arg in instantList:
+                    self._instantList.append(self.ComponentClass(arg, srid=srid))
+            # List of instant values
+            elif all(isinstance(arg, self.ComponentClass) for arg in instantList):
+                for arg in instantList:
+                    self._instantList.append(arg)
+            else:
+                raise Exception("ERROR: Could not parse temporal sequence value")
+            self._lower_inc = lower_inc if lower_inc is not None else True
+            self._upper_inc = upper_inc if upper_inc is not None else False
+            # Set the interpolation
+            if interp is not None:
+                self._interp = interp
+            else:
+                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
+        else:
+            raise Exception("ERROR: Could not parse temporal sequence value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        super()._valid()
+        if any((x._value.z is None and y._value.z is not None) or (x._value.z is not None and y._value.z is None) \
+                for x, y in zip(self._instantList, self._instantList[1:])):
+            raise Exception("ERROR: The points composing a temporal point must be of the same dimensionality")
+        if any(x._value.m is not None for x in self._instantList):
+            raise Exception("ERROR: The points composing a temporal point cannot have M dimension")
+        if any(x.srid != y.srid for x, y in zip(self._instantList, self._instantList[1:])):
+            raise Exception("ERROR: The points composing a temporal point must have the same SRID")
+
+
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
+        """
+        return self._interp
+
+    @property
+    def getValues(self):
+        """
+        Geometry representing the values taken by the temporal value.
+        """
+        values = [inst._value for inst in self._instantList]
+        result = values[0] if len(values) == 1 else LineString(values)
+        return result
+
+
+class TPointSeqSet(TSequenceSet):
+    """
+    Abstract class for representing temporal points of sequence set subtype.
+    """
+
+    def __init__(self, sequenceList, interp=None, srid=None):
+        assert (isinstance(interp, (str, type(None)))), "ERROR: Invalid interpolation"
+        if isinstance(interp, str) and interp is None:
+            assert (interp == 'Linear' or interp == 'Stepwise'), "ERROR: Invalid interpolation"
+        self._sequenceList = []
+        # Constructor with a single argument of type string
+        if isinstance(sequenceList, str):
+            # If srid is given
+            if re.match(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', sequenceList):
+                # Get the srid and remove the "srid=xxx;" prefix
+                srid_str = int(re.search(r'(\d+)', sequenceList).group())
+                if srid is not None and srid_str != srid:
+                    raise Exception(f"ERROR: SRID mismatch: {srid_str} vs {srid}")
+                srid = srid_str
+                sequenceList = re.sub(r'^(SRID|srid)\s*=\s*\d+\s*(;|,)\s*', '', sequenceList)
+            # Parse without the eventual "srid=xxx;" prefix
+            elements = parse_temporalseqset(sequenceList, 0)
+            seqList = []
+            for seq in elements[2][0]:
+                instList = []
+                for inst in seq[0]:
+                    instList.append(self.ComponentClass.ComponentClass(inst[0], inst[1], srid=srid))
+                if self.BaseClassDiscrete:
+                    seqList.append(self.ComponentClass(instList, seq[1], seq[2]))
+                else:
+                    seqList.append(self.ComponentClass(instList, seq[1], seq[2], elements[2][1], srid=srid))
+            self._sequenceList = seqList
+            # Set interpolation with the argument or the flag from the string if given
+            if interp is not None:
+                self._interp = interp
+            else:
+                if self.BaseClassDiscrete:
+                    self._interp = 'Stepwise'
+                else:
+                    self._interp = elements[2][1] if elements[2][1] is not None else 'Linear'
+        # Constructor with a single argument of type list
+        elif isinstance(sequenceList, list):
+            # List of strings representing periods
+            if all(isinstance(sequence, str) for sequence in sequenceList):
+                for sequence in sequenceList:
+                    self._sequenceList.append(self.ComponentClass(sequence))
+            # List of periods
+            elif all(isinstance(sequence, self.ComponentClass) for sequence in sequenceList):
+                for sequence in sequenceList:
+                    self._sequenceList.append(sequence)
+            else:
+                raise Exception("ERROR: Could not parse temporal sequence set value")
+            # Set the interpolation
+            if interp is not None:
+                self._interp = interp
+            else:
+                self._interp = 'Stepwise' if self.BaseClassDiscrete else 'Linear'
+        else:
+            raise Exception("ERROR: Could not parse temporal sequence set value")
+        # Verify validity of the resulting instance
+        self._valid()
+
+    def _valid(self):
+        super()._valid()
+        if any((x.hasz is None and y.hasz is not None) or (x.hasz is not None and y.hasz is None) \
+                for x, y in zip(self._sequenceList, self._sequenceList[1:])):
+            raise Exception("ERROR: The points composing a temporal point must be of the same dimensionality")
+        if any(x.srid != y.srid for x, y in zip(self._sequenceList, self._sequenceList[1:])):
+            raise Exception("ERROR: The points composing a temporal point must have the same SRID")
+
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, which is either ``'Linear'`` or ``'Stepwise'``.
+        """
+        return self._interp
+
+    @property
+    def getValues(self):
+        """
+        Geometry representing the values taken by the temporal value.
+        """
+        values = [seq.getValues for seq in self._sequenceList]
+        points = [geo for geo in values if isinstance(geo, Point)]
+        lines = [geo for geo in values if isinstance(geo, LineString)]
+        if len(points) != 0 and len(points) != 0:
+            return GeometryCollection(points + lines)
+        if len(points) != 0 and len(points) == 0:
+            return MultiPoint(points)
+        if len(points) == 0 and len(points) != 0:
+            return MultiLineString(lines)
+
+
+class TGeomPoint(Temporal):
+    """
+    Abstract class for representing temporal geometric or geographic points of any subtype.
+    """
+
+    BaseClass = Point
+    BaseClassDiscrete = False
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        if value.startswith('Interp=Stepwise;'):
+            value1 = value.replace('Interp=Stepwise;', '')
+            if value1[0] == '{':
+                return TGeomPointSeqSet(value)
+            else:
+                return TGeomPointSeq(value)
+        elif value[0] != '{' and value[0] != '[' and value[0] != '(':
+            return TGeomPointInst(value)
+        elif value[0] == '[' or value[0] == '(':
+            return TGeomPointSeq(value)
+        elif value[0] == '{':
+            if value[1] == '[' or value[1] == '(':
+                return TGeomPointSeqSet(value)
+            else:
+                return TGeomPointInstSet(value)
+        raise Exception("ERROR: Could not parse temporal point value")
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, TGeomPoint):
+            raise ValueError('Value must an instance of a subclass of TGeomPoint')
+        return value.__str__().strip("'")
+
+    @property
+    def hasz(self):
+        """
+        Does the temporal point has Z dimension?
+        """
+        return self.startValue.z is not None
+
+    @property
+    def srid(self):
+        """
+        Returns the SRID.
+        """
+        result = self.startValue.srid if hasattr(self.startValue, "srid") else None
+        return result
+
+
+class TGeogPoint(Temporal):
+    """
+    Abstract class for representing temporal geographic points of any subtype.
+    """
+
+    BaseClass = Point
+    BaseClassDiscrete = False
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        if value.startswith('Interp=Stepwise;'):
+            value1 = value.replace('Interp=Stepwise;', '')
+            if value1[0] == '{':
+                return TGeogPointSeqSet(value)
+            else:
+                return TGeogPointSeq(value)
+        elif value[0] != '{' and value[0] != '[' and value[0] != '(':
+            return TGeogPointInst(value)
+        elif value[0] == '[' or value[0] == '(':
+            return TGeogPointSeq(value)
+        elif value[0] == '{':
+            if value[1] == '[' or value[1] == '(':
+                return TGeogPointSeqSet(value)
+            else:
+                return TGeogPointInstSet(value)
+        raise Exception("ERROR: Could not parse temporal point value")
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, TGeogPoint):
+            raise ValueError('Value must an instance of a subclass of TGeogPoint')
+        return value.__str__().strip("'")
+
+    @property
+    def hasz(self):
+        """
+        Does the temporal point has Z dimension?
+        """
+        return self.startValue.z is not None
+
+    @property
+    def srid(self):
+        """
+        Returns the SRID.
+        """
+        result = self.startValue.srid if hasattr(self.startValue, "srid") else None
+        return result
+
+
+class TGeomPointInst(TPointInst, TGeomPoint):
+    """
+    Class for representing temporal geometric points of instant subtype.
+
+    ``TGeomPointInst`` objects can be created with a single argument of type
+    string as in MobilityDB.
+
+        >>> TGeomPointInst('Point(10.0 10.0)@2019-09-01')
+        >>> TGeomPointInst('SRID=4326,Point(10.0 10.0)@2019-09-01')
+
+    Another possibility is to give the ``value`` and the ``time`` arguments,
+    which can be instances of ``str``, ``Point`` or ``datetime``.
+    Additionally, the SRID can be specified, it will be 0 by default if not
+    given.
+
+        >>> TGeomPointInst('Point(10.0 10.0)', '2019-09-08 00:00:00+01', 4326)
+        >>> TGeomPointInst(['Point(10.0 10.0)', '2019-09-08 00:00:00+01', 4326])
+        >>> TGeomPointInst(Point(10.0, 10.0), parse('2019-09-08 00:00:00+01'), 4326)
+        >>> TGeomPointInst([Point(10.0, 10.0), parse('2019-09-08 00:00:00+01'), 4326])
+
+    """
+
+    def __init__(self, value, time=None, srid=None):
+        super().__init__(value, time, srid)
+
+
+class TGeogPointInst(TPointInst, TGeogPoint):
+    """
+    Class for representing temporal geographic points of instant subtype.
+
+    ``TGeogPointInst`` objects can be created with a single argument of type
+    string as in MobilityDB.
+
+        >>> TGeogPointInst('Point(10.0 10.0)@2019-09-01')
+
+    Another possibility is to give the ``value`` and the ``time`` arguments,
+    which can be instances of ``str``, ``Point`` or ``datetime``.
+    Additionally, the SRID can be specified, it will be 0 by default if not
+    given.
+
+        >>> TGeogPointInst('Point(10.0 10.0)', '2019-09-08 00:00:00+01')
+        >>> TGeogPointInst(['Point(10.0 10.0)', '2019-09-08 00:00:00+01'])
+        >>> TGeogPointInst(Point(10.0, 10.0), parse('2019-09-08 00:00:00+01'))
+        >>> TGeogPointInst([Point(10.0, 10.0), parse('2019-09-08 00:00:00+01')])
+
+    """
+
+    def __init__(self, value, time=None, srid=None):
+        super().__init__(value, time, srid)
+
+
+class TGeomPointInstSet(TPointInstSet, TGeomPoint):
+    """
+    Class for representing temporal geometric points of instant set subtype.
+
+    ``TGeomPointInstSet`` objects can be created with a single argument of type
+    string as in MobilityDB.
+
+        >>> TGeomPointInstSet('Point(10.0 10.0)@2019-09-01')
+
+    Another possibility is to give a tuple or list of arguments specifying
+    the composing instants, which can be instances of ``str`` or
+    ``TGeomPointInst``.
+
+        >>> TGeomPointInstSet('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01')
+        >>> TGeomPointInstSet(TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01'))
+        >>> TGeomPointInstSet(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
+        >>> TGeomPointInstSet([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
+
+    """
+
+    ComponentClass = TGeomPointInst
+
+    def __init__(self,  *argv, **kwargs):
+        super().__init__(*argv, **kwargs)
+
+
+class TGeogPointInstSet(TPointInstSet, TGeogPoint):
+    """
+    Class for representing temporal geometric points of instant set subtype.
+
+    ``TGeogPointInstSet`` objects can be created with a single argument of type
+    string as in MobilityDB.
+
+        >>> TGeogPointInstSet('Point(10.0 10.0)@2019-09-01')
+
+    Another possibility is to give a tuple or list of arguments specifying
+    the composing instants, which can be instances of ``str`` or
+    ``TGeogPointInst``.
+
+        >>> TGeogPointInstSet('Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01')
+        >>> TGeogPointInstSet(TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01'))
+        >>> TGeogPointInstSet(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
+        >>> TGeogPointInstSet([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
+
+    """
+
+    ComponentClass = TGeogPointInst
+
+    def __init__(self,  *argv, **kwargs):
+        super().__init__(*argv, **kwargs)
+
+
+class TGeomPointSeq(TPointSeq, TGeomPoint):
+    """
+    Class for representing temporal geometric points of sequence subtype.
+
+    ``TGeomPointSeq`` objects can be created with a single argument of type
+    string as in MobilityDB.
+
+        >>> TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
+        >>> TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``instantList`` is the list of composing instants, which can be instances
+      of ``str`` or ``TGeogPointInst``,
+    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
+      whether the bounds are inclusive or not,  where by default '`lower_inc``
+      is ``True`` and ``upper_inc`` is ``False``,
+    * ``interp`` which is either ``'Linear'`` or ``'Stepwise'``, the former
+      being the default, and
+    * ``srid`` is an integer specifiying the SRID
+
+    Some examples are shown next.
+
+        >>> TGeomPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
+        >>> TGeomPointSeq([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
+        >>> TGeomPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
+        >>> TGeomPointSeq([TGeomPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeomPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeomPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
+
+    """
+
+    ComponentClass = TGeomPointInst
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None, srid=None):
+        super().__init__(instantList, lower_inc, upper_inc, interp, srid)
+
+    def _interpolate(self, inst1, inst2, timestamp):
+        """
+        Interpolate the temporal value at a timestamp between inst1 and inst2.
+        """
+        # preconditions
+        if not (isinstance(inst1, TGeomPointInst) and isinstance(inst2, TGeomPointInst) and
+            isinstance(timestamp, datetime) and inst1._time < timestamp and timestamp < inst2._time):
+            Exception("Erroneous arguments for function TGeomPointSeq._interpolate")
+
+        duration1 = timestamp - inst1._time
+        duration2 = inst2._time - inst1._time
+        ratio = duration1.total_seconds() / duration2.total_seconds();
+        x = inst1._value.x + (inst2._value.x - inst1._value.x) * ratio;
+        y = inst1._value.y + (inst2._value.y - inst1._value.y) * ratio;
+        if inst1._value.z is not None and inst2._value.z is not None:
+            z = inst1._value.z + (inst2._value.z - inst1._value.z) * ratio;
+            return Point(x,y,z);
+        else:
+            return Point(x,y);
+
+
+class TGeogPointSeq(TPointSeq, TGeogPoint):
+    """
+    Class for representing temporal geographic points of sequence subtype.
+
+    ``TGeogPointSeq`` objects can be created with a single argument of type
+    string as in MobilityDB.
+
+        >>> TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
+        >>> TGeogPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01, Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``instantList`` is the list of composing instants, which can be instances
+      of ``str`` or ``TGeogPointInst``,
+    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
+      whether the bounds are includive or not,  where by default '`lower_inc``
+      is ``True`` and ``upper_inc`` is ``False``, and
+    * ``interp`` which is either ``'Linear'`` or ``'Stepwise'``, the former
+      being the default.
+    * ``srid`` is an integer specifiying the SRID
+
+    Some examples are shown next.
+
+        >>> TGeogPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'])
+        >>> TGeogPointSeq([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')])
+        >>> TGeogPointSeq(['Point(10.0 10.0)@2019-09-01 00:00:00+01', 'Point(20.0 20.0)@2019-09-02 00:00:00+01', 'Point(10.0 10.0)@2019-09-03 00:00:00+01'], True, True, 'Stepwise')
+        >>> TGeogPointSeq([TGeogPointInst('Point(10.0 10.0)@2019-09-01 00:00:00+01'), TGeogPointInst('Point(20.0 20.0)@2019-09-02 00:00:00+01'), TGeogPointInst('Point(10.0 10.0)@2019-09-03 00:00:00+01')], True, True, 'Stepwise')
+
+    """
+
+    ComponentClass = TGeogPointInst
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None, interp=None, srid=None):
+        super().__init__(instantList, lower_inc, upper_inc, interp, srid)
+
+
+class TGeomPointSeqSet(TPointSeqSet, TGeomPoint):
+    """
+    Class for representing temporal geometric points of sequence subtype.
+
+    ``TGeomPointSeqSet`` objects can be created with a single argument of type
+    string as in MobilityDB.
+
+        >>> TGeomPointSeqSet('{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
+        >>> TGeomPointSeqSet('Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``sequenceList`` is the list of composing sequences, which can be instances
+      of ``str`` or ``TGeomPointSeq``,
+    * ``interp`` can be ``'Linear'`` or ``'Stepwise'``, the former being
+      the default, and
+    * ``srid`` is an integer specifiying the SRID, if will be 0 by default if
+      not given.
+
+    Some examples are shown next.
+
+        >>> TGeomPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'])
+        >>> TGeomPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear')
+        >>> TGeomPointSeqSet(['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Stepwise')
+        >>> TGeomPointSeqSet([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')])
+        >>> TGeomPointSeqSet([TGeomPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),  TGeomPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear')
+        >>> TGeomPointSeqSet([TGeomPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeomPointSeq('Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Stepwise')
+
+    """
+
+    ComponentClass = TGeomPointSeq
+
+    def __init__(self, sequenceList, interp=None, srid=None):
+        super().__init__(sequenceList, interp, srid)
+
+
+class TGeogPointSeqSet(TPointSeqSet, TGeogPoint):
+    """
+    Class for representing temporal geographic points of sequence subtype.
+
+    ``TGeogPointSeqSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TGeogPointSeqSet('{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
+        >>> TGeogPointSeqSet('Interp=Stepwise;{[Point(10.0 10.0)@2019-09-01 00:00:00+01], [Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]}')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``sequenceList`` is the list of composing sequences, which can be instances
+      of ``str`` or ``TGeogPointSeq``,
+    * ``interp`` can be ``'Linear'`` or ``'Stepwise'``, the former being
+      the default, and
+    * ``srid`` is an integer specifiying the SRID, if will be 0 by default if
+      not given.
+
+    Some examples are shown next.
+
+        >>> TGeogPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'])
+        >>> TGeogPointSeqSet(['[Point(10.0 10.0)@2019-09-01 00:00:00+01]', '[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Linear')
+        >>> TGeogPointSeqSet(['Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]', 'Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]'], 'Stepwise')
+        >>> TGeogPointSeqSet([TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')])
+        >>> TGeogPointSeqSet([TGeogPointSeq('[Point(10.0 10.0)@2019-09-01 00:00:00+01]'),  TGeogPointSeq('[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Linear')
+        >>> TGeogPointSeqSet([TGeogPointSeq('Interp=Stepwise;[Point(10.0 10.0)@2019-09-01 00:00:00+01]'), TGeogPointSeq('Interp=Stepwise;[Point(20.0 20.0)@2019-09-02 00:00:00+01, Point(10.0 10.0)@2019-09-03 00:00:00+01]')], 'Stepwise')
+
+    """
+
+    ComponentClass = TGeogPointSeq
+
+    def __init__(self, sequenceList, interp=None, srid=None):
+        super().__init__(sequenceList, interp, srid)
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/main/tint.py` & `python-mobilitydb-0.1.3/mobilitydb/main/tint.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,186 +1,186 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from spans.types import intrange
-from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
-
-
-class TInt(Temporal):
-    """
-    Abstract class for representing temporal integers of any subtype.
-    """
-
-    BaseClass = int
-    BaseClassDiscrete = True
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        if value[0] != '{' and value[0] != '[' and value[0] != '(':
-            return TIntInst(value)
-        elif value[0] == '[' or value[0] == '(':
-            return TIntSeq(value)
-        elif value[0] == '{':
-            if value[1] == '[' or value[1] == '(':
-                return TIntSeqSet(value)
-            else:
-                return TIntInstSet(value)
-        raise Exception("ERROR: Could not parse temporal integer value")
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, TInt):
-            raise ValueError('Value must be an instance of a subclass of TInt')
-        return value.__str__().strip("'")
-
-    @property
-    def valueRange(self):
-        """
-        Range of values taken by the temporal value as defined by its minimum and maximum value
-        """
-        return intrange(self.minValue, self.maxValue, True, True)
-
-
-class TIntInst(TInstant, TInt):
-    """
-    Class for representing temporal integers of instant subtype.
-
-    ``TIntInst`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TIntInst('10@2019-09-01')
-
-    Another possibility is to give the ``value`` and the ``time`` arguments,
-    which can be instances of ``str``, ``int`` or ``datetime``.
-
-        >>> TIntInst('10', '2019-09-08 00:00:00+01')
-        >>> TIntInst(['10', '2019-09-08 00:00:00+01'])
-        >>> TIntInst(10, parse('2019-09-08 00:00:00+01'))
-        >>> TIntInst([10, parse('2019-09-08 00:00:00+01')])
-
-    """
-
-    def __init__(self, value, time=None):
-        super().__init__(value, time)
-
-
-class TIntInstSet(TInstantSet, TInt):
-    """
-    Class for representing temporal integers of instant set subtype.
-
-    ``TIntInstSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TIntInstSet('10@2019-09-01')
-
-    Another possibility is to give a tuple or list of composing instants,
-    which can be instances of ``str`` or ``TIntInst``.
-
-        >>> TIntInstSet('10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01')
-        >>> TIntInstSet(TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01'))
-        >>> TIntInstSet(['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'])
-        >>> TIntInstSet([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01')])
-
-    """
-
-    ComponentClass = TIntInst
-
-    def __init__(self,  *argv):
-        super().__init__(*argv)
-
-
-class TIntSeq(TSequence, TInt):
-    """
-    Class for representing temporal integers of sequence subtype.
-
-    ``TIntSeq`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TIntSeq('[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')
-
-    Another possibility is to give the arguments as follows:
-
-    * ``instantList`` is the list of composing instants, which can be instances of
-      ``str`` or ``TIntInst``,
-    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
-      whether the bounds are inclusive or not. By default ``lower_inc``
-      is ``True`` and ``upper_inc`` is ``False``.
-
-    Some examples are given next.
-
-        >>> TIntSeq(['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'])
-        >>> TIntSeq([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01')])
-        >>> TIntSeq(['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'], True, True)
-        >>> TIntSeq([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01')], True, True)
-
-    """
-
-    ComponentClass = TIntInst
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None):
-        super().__init__(instantList, lower_inc, upper_inc)
-
-    @classmethod
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, that is, ``'Stepwise'``.
-        """
-        return 'Stepwise'
-
-
-class TIntSeqSet(TSequenceSet, TInt):
-    """
-    Class for representing temporal integers of sequence subtype.
-
-    ``TIntSeqSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TIntSeqSet('{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}')
-
-    Another possibility is to give the list of composing sequences, which
-    can be instances of ``str`` or ``TIntSeq``.
-
-        >>> TIntSeqSet(['[10@2019-09-01 00:00:00+01]', '[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]'])
-        >>> TIntSeqSet([TIntSeq('[10@2019-09-01 00:00:00+01]'), TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')])
-        >>> TIntSeqSet([TIntSeq('[10@2019-09-01 00:00:00+01]'), TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')])
-
-    """
-
-    ComponentClass = TIntSeq
-
-    def __init__(self, sequenceList):
-        super().__init__(sequenceList)
-
-    @classmethod
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, that is, ``'Stepwise'``.
-        """
-        return 'Stepwise'
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from spans.types import intrange
+from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
+
+
+class TInt(Temporal):
+    """
+    Abstract class for representing temporal integers of any subtype.
+    """
+
+    BaseClass = int
+    BaseClassDiscrete = True
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        if value[0] != '{' and value[0] != '[' and value[0] != '(':
+            return TIntInst(value)
+        elif value[0] == '[' or value[0] == '(':
+            return TIntSeq(value)
+        elif value[0] == '{':
+            if value[1] == '[' or value[1] == '(':
+                return TIntSeqSet(value)
+            else:
+                return TIntInstSet(value)
+        raise Exception("ERROR: Could not parse temporal integer value")
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, TInt):
+            raise ValueError('Value must be an instance of a subclass of TInt')
+        return value.__str__().strip("'")
+
+    @property
+    def valueRange(self):
+        """
+        Range of values taken by the temporal value as defined by its minimum and maximum value
+        """
+        return intrange(self.minValue, self.maxValue, True, True)
+
+
+class TIntInst(TInstant, TInt):
+    """
+    Class for representing temporal integers of instant subtype.
+
+    ``TIntInst`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TIntInst('10@2019-09-01')
+
+    Another possibility is to give the ``value`` and the ``time`` arguments,
+    which can be instances of ``str``, ``int`` or ``datetime``.
+
+        >>> TIntInst('10', '2019-09-08 00:00:00+01')
+        >>> TIntInst(['10', '2019-09-08 00:00:00+01'])
+        >>> TIntInst(10, parse('2019-09-08 00:00:00+01'))
+        >>> TIntInst([10, parse('2019-09-08 00:00:00+01')])
+
+    """
+
+    def __init__(self, value, time=None):
+        super().__init__(value, time)
+
+
+class TIntInstSet(TInstantSet, TInt):
+    """
+    Class for representing temporal integers of instant set subtype.
+
+    ``TIntInstSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TIntInstSet('10@2019-09-01')
+
+    Another possibility is to give a tuple or list of composing instants,
+    which can be instances of ``str`` or ``TIntInst``.
+
+        >>> TIntInstSet('10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01')
+        >>> TIntInstSet(TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01'))
+        >>> TIntInstSet(['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'])
+        >>> TIntInstSet([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01')])
+
+    """
+
+    ComponentClass = TIntInst
+
+    def __init__(self,  *argv):
+        super().__init__(*argv)
+
+
+class TIntSeq(TSequence, TInt):
+    """
+    Class for representing temporal integers of sequence subtype.
+
+    ``TIntSeq`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TIntSeq('[10@2019-09-01 00:00:00+01, 20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')
+
+    Another possibility is to give the arguments as follows:
+
+    * ``instantList`` is the list of composing instants, which can be instances of
+      ``str`` or ``TIntInst``,
+    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
+      whether the bounds are inclusive or not. By default ``lower_inc``
+      is ``True`` and ``upper_inc`` is ``False``.
+
+    Some examples are given next.
+
+        >>> TIntSeq(['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'])
+        >>> TIntSeq([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01')])
+        >>> TIntSeq(['10@2019-09-01 00:00:00+01', '20@2019-09-02 00:00:00+01', '10@2019-09-03 00:00:00+01'], True, True)
+        >>> TIntSeq([TIntInst('10@2019-09-01 00:00:00+01'), TIntInst('20@2019-09-02 00:00:00+01'), TIntInst('10@2019-09-03 00:00:00+01')], True, True)
+
+    """
+
+    ComponentClass = TIntInst
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None):
+        super().__init__(instantList, lower_inc, upper_inc)
+
+    @classmethod
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, that is, ``'Stepwise'``.
+        """
+        return 'Stepwise'
+
+
+class TIntSeqSet(TSequenceSet, TInt):
+    """
+    Class for representing temporal integers of sequence subtype.
+
+    ``TIntSeqSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TIntSeqSet('{[10@2019-09-01 00:00:00+01], [20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]}')
+
+    Another possibility is to give the list of composing sequences, which
+    can be instances of ``str`` or ``TIntSeq``.
+
+        >>> TIntSeqSet(['[10@2019-09-01 00:00:00+01]', '[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]'])
+        >>> TIntSeqSet([TIntSeq('[10@2019-09-01 00:00:00+01]'), TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')])
+        >>> TIntSeqSet([TIntSeq('[10@2019-09-01 00:00:00+01]'), TIntSeq('[20@2019-09-02 00:00:00+01, 10@2019-09-03 00:00:00+01]')])
+
+    """
+
+    ComponentClass = TIntSeq
+
+    def __init__(self, sequenceList):
+        super().__init__(sequenceList)
+
+    @classmethod
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, that is, ``'Stepwise'``.
+        """
+        return 'Stepwise'
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/main/tbool.py` & `python-mobilitydb-0.1.3/mobilitydb/main/tbool.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,209 +1,209 @@
-###############################################################################
-#
-# This MobilityDB code is provided under The PostgreSQL License.
-#
-# Copyright (c) 2019-2021, Université libre de Bruxelles and MobilityDB
-# contributors
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose, without fee, and without a written 
-# agreement is hereby granted, provided that the above copyright notice and
-# this paragraph and the following two paragraphs appear in all copies.
-#
-# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
-# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
-# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
-# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
-# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
-# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
-# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
-#
-###############################################################################
-
-from parsec import *
-from datetime import datetime
-from dateutil.parser import parse
-from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
-from mobilitydb.temporal.temporal_parser import parse_temporalinst
-
-
-class TBool(Temporal):
-    """
-    Abstract class for representing temporal Booleans of any subtype.
-    """
-
-    BaseClass = bool
-    BaseClassDiscrete = True
-
-    @staticmethod
-    def read_from_cursor(value, cursor=None):
-        if not value:
-            return None
-        if value[0] != '{' and value[0] != '[' and value[0] != '(':
-            return TBoolInst(value)
-        elif value[0] == '[' or value[0] == '(':
-            return TBoolSeq(value)
-        elif value[0] == '{':
-            if value[1] == '[' or value[1] == '(':
-                return TBoolSeqSet(value)
-            else:
-                return TBoolInstSet(value)
-        raise Exception("ERROR: Could not parse temporal boolean value")
-
-    @staticmethod
-    def write(value):
-        if not isinstance(value, TBool):
-            raise ValueError('Value must be an instance of a subclass of TBool')
-        return value.__str__().strip("'")
-
-
-class TBoolInst(TInstant, TBool):
-    """
-    Class for representing temporal Booleans of instant subtype.
-
-    ``TBoolInst`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TBoolInst('true@2019-09-01')
-
-    Another possibility is to give the ``value`` and the ``time`` arguments,
-    which can be instances of ``str``, ``bool``, or ``datetime``.
-
-        >>> TBoolInst('True', '2019-09-08 00:00:00+01')
-        >>> TBoolInst(['True', '2019-09-08 00:00:00+01'])
-        >>> TBoolInst(True, parse('2019-09-08 00:00:00+01'))
-        >>> TBoolInst([True, parse('2019-09-08 00:00:00+01')])
-
-    """
-
-    """
-    It is not possible to call super().__init__(value, time) since bool('False') == True
-    and eval('False') == False. Furthermore eval('false') gives an error
-    """
-    def __init__(self, value, time=None):
-        if time is None:
-            # Constructor with a single argument of type string
-            if isinstance(value, str):
-                couple = parse_temporalinst(value, 0)
-                value = couple[2][0]
-                time = couple[2][1]
-            # Constructor with a single argument of type tuple or list
-            elif isinstance(value, (tuple, list)):
-                value, time = value
-            else:
-                raise Exception("ERROR: Could not parse temporal instant value")
-        # Now both value and time are not None
-        assert(isinstance(value, (str, bool))), "ERROR: Invalid value argument"
-        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
-        if isinstance(value, str):
-            if value.lower() == 'true' or value.lower() == 't':
-                self._value = True
-            elif value.lower() == 'false' or value.lower() == 'f':
-                self._value = False
-            else:
-                raise Exception("ERROR: Could not parse temporal instant value")
-        else:
-            self._value =  value
-        self._time = parse(time) if isinstance(time, str) else time
-
-
-class TBoolInstSet(TInstantSet, TBool):
-    """
-    Class for representing temporal Booleans of instant set subtype.
-
-    ``TBoolInstSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TBoolInstSet('AA@2019-09-01')
-
-    Another possibility is to give a tuple or list of arguments,
-    which can be instances of ``str`` or ``TBoolInst``.
-
-        >>> TBoolInstSet('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01')
-        >>> TBoolInstSet(TBoolInst('AA@2019-09-01 00:00:00+01'), TBoolInst('BB@2019-09-02 00:00:00+01'), TBoolInst('AA@2019-09-03 00:00:00+01'))
-        >>> TBoolInstSet(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'])
-        >>> TBoolInstSet([TBoolInst('AA@2019-09-01 00:00:00+01'), TBoolInst('BB@2019-09-02 00:00:00+01'), TBoolInst('AA@2019-09-03 00:00:00+01')])
-
-    """
-
-    ComponentClass = TBoolInst
-
-    def __init__(self,  *argv):
-        super().__init__(*argv)
-
-
-class TBoolSeq(TSequence, TBool):
-    """
-    Class for representing temporal Booleans of sequence subtype.
-
-    ``TBoolSeq`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TBoolSeq('[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')
-
-    Another possibility is to give the arguments as follows.
-
-    * ``instantList`` is the list of composing instants, which can be instances of
-      ``str`` or ``TBoolInst``,
-    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
-      whether the bounds are inclusive or not. By default ``lower_inc``
-      is ``True`` and ``upper_inc`` is ``False``.
-
-    Some examples are given next.
-
-        >>> TBoolSeq(['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'])
-        >>> TBoolSeq(TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'), TBoolInst('true@2019-09-03 00:00:00+01')])
-        >>> TBoolSeq(['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'], True, True)
-        >>> TBoolSeq([TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'), TBoolInst('true@2019-09-03 00:00:00+01')], True, True)
-
-    """
-
-    ComponentClass = TBoolInst
-
-    def __init__(self, instantList, lower_inc=None, upper_inc=None):
-        super().__init__(instantList, lower_inc, upper_inc)
-
-    @classmethod
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, that is, ``'Stepwise'``.
-        """
-        return 'Stepwise'
-
-
-class TBoolSeqSet(TSequenceSet, TBool):
-    """
-    Class for representing temporal Booleans of sequence set subtype.
-
-    ``TBoolSeqSet`` objects can be created with a single argument of type string
-    as in MobilityDB.
-
-        >>> TBoolSeqSet('{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}')
-
-    Another possibility is to give the list of composing sequences, which
-    can be instances of ``str`` or ``TBoolSeq``.
-
-        >>> TBoolSeqSet(['[true@2019-09-01 00:00:00+01]', '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]'])
-        >>> TBoolSeqSet([TBoolSeq('[true@2019-09-01 00:00:00+01]'), TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')])
-        >>> TBoolSeqSet([TBoolSeq('[true@2019-09-01 00:00:00+01]'), TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')])
-
-    """
-
-    ComponentClass = TBoolSeq
-
-    def __init__(self, sequenceList):
-        super().__init__(sequenceList)
-
-    @classmethod
-    @property
-    def interpolation(self):
-        """
-        Interpolation of the temporal value, that is, ``'Stepwise'``.
-        """
-        return 'Stepwise'
-
+###############################################################################
+#
+# This MobilityDB code is provided under The PostgreSQL License.
+#
+# Copyright (c) 2019-2022, Université libre de Bruxelles and MobilityDB
+# contributors
+#
+# Permission to use, copy, modify, and distribute this software and its
+# documentation for any purpose, without fee, and without a written 
+# agreement is hereby granted, provided that the above copyright notice and
+# this paragraph and the following two paragraphs appear in all copies.
+#
+# IN NO EVENT SHALL UNIVERSITE LIBRE DE BRUXELLES BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+# EVEN IF UNIVERSITE LIBRE DE BRUXELLES HAS BEEN ADVISED OF THE POSSIBILITY 
+# OF SUCH DAMAGE.
+#
+# UNIVERSITE LIBRE DE BRUXELLES SPECIFICALLY DISCLAIMS ANY WARRANTIES, 
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+# AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
+# AN "AS IS" BASIS, AND UNIVERSITE LIBRE DE BRUXELLES HAS NO OBLIGATIONS TO 
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
+#
+###############################################################################
+
+from parsec import *
+from datetime import datetime
+from dateutil.parser import parse
+from mobilitydb.temporal import Temporal, TInstant, TInstantSet, TSequence, TSequenceSet
+from mobilitydb.temporal.temporal_parser import parse_temporalinst
+
+
+class TBool(Temporal):
+    """
+    Abstract class for representing temporal Booleans of any subtype.
+    """
+
+    BaseClass = bool
+    BaseClassDiscrete = True
+
+    @staticmethod
+    def read_from_cursor(value, cursor=None):
+        if not value:
+            return None
+        if value[0] != '{' and value[0] != '[' and value[0] != '(':
+            return TBoolInst(value)
+        elif value[0] == '[' or value[0] == '(':
+            return TBoolSeq(value)
+        elif value[0] == '{':
+            if value[1] == '[' or value[1] == '(':
+                return TBoolSeqSet(value)
+            else:
+                return TBoolInstSet(value)
+        raise Exception("ERROR: Could not parse temporal boolean value")
+
+    @staticmethod
+    def write(value):
+        if not isinstance(value, TBool):
+            raise ValueError('Value must be an instance of a subclass of TBool')
+        return value.__str__().strip("'")
+
+
+class TBoolInst(TInstant, TBool):
+    """
+    Class for representing temporal Booleans of instant subtype.
+
+    ``TBoolInst`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TBoolInst('true@2019-09-01')
+
+    Another possibility is to give the ``value`` and the ``time`` arguments,
+    which can be instances of ``str``, ``bool``, or ``datetime``.
+
+        >>> TBoolInst('True', '2019-09-08 00:00:00+01')
+        >>> TBoolInst(['True', '2019-09-08 00:00:00+01'])
+        >>> TBoolInst(True, parse('2019-09-08 00:00:00+01'))
+        >>> TBoolInst([True, parse('2019-09-08 00:00:00+01')])
+
+    """
+
+    """
+    It is not possible to call super().__init__(value, time) since bool('False') == True
+    and eval('False') == False. Furthermore eval('false') gives an error
+    """
+    def __init__(self, value, time=None):
+        if time is None:
+            # Constructor with a single argument of type string
+            if isinstance(value, str):
+                couple = parse_temporalinst(value, 0)
+                value = couple[2][0]
+                time = couple[2][1]
+            # Constructor with a single argument of type tuple or list
+            elif isinstance(value, (tuple, list)):
+                value, time = value
+            else:
+                raise Exception("ERROR: Could not parse temporal instant value")
+        # Now both value and time are not None
+        assert(isinstance(value, (str, bool))), "ERROR: Invalid value argument"
+        assert(isinstance(time, (str, datetime))), "ERROR: Invalid time argument"
+        if isinstance(value, str):
+            if value.lower() == 'true' or value.lower() == 't':
+                self._value = True
+            elif value.lower() == 'false' or value.lower() == 'f':
+                self._value = False
+            else:
+                raise Exception("ERROR: Could not parse temporal instant value")
+        else:
+            self._value =  value
+        self._time = parse(time) if isinstance(time, str) else time
+
+
+class TBoolInstSet(TInstantSet, TBool):
+    """
+    Class for representing temporal Booleans of instant set subtype.
+
+    ``TBoolInstSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TBoolInstSet('AA@2019-09-01')
+
+    Another possibility is to give a tuple or list of arguments,
+    which can be instances of ``str`` or ``TBoolInst``.
+
+        >>> TBoolInstSet('AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01')
+        >>> TBoolInstSet(TBoolInst('AA@2019-09-01 00:00:00+01'), TBoolInst('BB@2019-09-02 00:00:00+01'), TBoolInst('AA@2019-09-03 00:00:00+01'))
+        >>> TBoolInstSet(['AA@2019-09-01 00:00:00+01', 'BB@2019-09-02 00:00:00+01', 'AA@2019-09-03 00:00:00+01'])
+        >>> TBoolInstSet([TBoolInst('AA@2019-09-01 00:00:00+01'), TBoolInst('BB@2019-09-02 00:00:00+01'), TBoolInst('AA@2019-09-03 00:00:00+01')])
+
+    """
+
+    ComponentClass = TBoolInst
+
+    def __init__(self,  *argv):
+        super().__init__(*argv)
+
+
+class TBoolSeq(TSequence, TBool):
+    """
+    Class for representing temporal Booleans of sequence subtype.
+
+    ``TBoolSeq`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TBoolSeq('[true@2019-09-01 00:00:00+01, false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')
+
+    Another possibility is to give the arguments as follows.
+
+    * ``instantList`` is the list of composing instants, which can be instances of
+      ``str`` or ``TBoolInst``,
+    * ``lower_inc`` and ``upper_inc`` are instances of ``bool`` specifying
+      whether the bounds are inclusive or not. By default ``lower_inc``
+      is ``True`` and ``upper_inc`` is ``False``.
+
+    Some examples are given next.
+
+        >>> TBoolSeq(['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'])
+        >>> TBoolSeq(TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'), TBoolInst('true@2019-09-03 00:00:00+01')])
+        >>> TBoolSeq(['true@2019-09-01 00:00:00+01', 'false@2019-09-02 00:00:00+01', 'true@2019-09-03 00:00:00+01'], True, True)
+        >>> TBoolSeq([TBoolInst('true@2019-09-01 00:00:00+01'), TBoolInst('false@2019-09-02 00:00:00+01'), TBoolInst('true@2019-09-03 00:00:00+01')], True, True)
+
+    """
+
+    ComponentClass = TBoolInst
+
+    def __init__(self, instantList, lower_inc=None, upper_inc=None):
+        super().__init__(instantList, lower_inc, upper_inc)
+
+    @classmethod
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, that is, ``'Stepwise'``.
+        """
+        return 'Stepwise'
+
+
+class TBoolSeqSet(TSequenceSet, TBool):
+    """
+    Class for representing temporal Booleans of sequence set subtype.
+
+    ``TBoolSeqSet`` objects can be created with a single argument of type string
+    as in MobilityDB.
+
+        >>> TBoolSeqSet('{[true@2019-09-01 00:00:00+01], [false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]}')
+
+    Another possibility is to give the list of composing sequences, which
+    can be instances of ``str`` or ``TBoolSeq``.
+
+        >>> TBoolSeqSet(['[true@2019-09-01 00:00:00+01]', '[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]'])
+        >>> TBoolSeqSet([TBoolSeq('[true@2019-09-01 00:00:00+01]'), TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')])
+        >>> TBoolSeqSet([TBoolSeq('[true@2019-09-01 00:00:00+01]'), TBoolSeq('[false@2019-09-02 00:00:00+01, true@2019-09-03 00:00:00+01]')])
+
+    """
+
+    ComponentClass = TBoolSeq
+
+    def __init__(self, sequenceList):
+        super().__init__(sequenceList)
+
+    @classmethod
+    @property
+    def interpolation(self):
+        """
+        Interpolation of the temporal value, that is, ``'Stepwise'``.
+        """
+        return 'Stepwise'
+
```

### Comparing `python-mobilitydb-0.1.2/mobilitydb/main/__init__.py` & `python-mobilitydb-0.1.3/mobilitydb/main/__init__.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-from .tbool import TBool, TBoolInst, TBoolInstSet, TBoolSeq, TBoolSeqSet
-from .tint import TInt, TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
-from .tfloat import TFloat, TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
-from .ttext import TText, TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
-from .tpoint import TPointInst, TPointInstSet, TPointSeq, TPointSeqSet,\
-    TGeomPoint, TGeomPointInst, TGeomPointInstSet, TGeomPointSeq, TGeomPointSeqSet,\
-    TGeogPoint, TGeogPointInst, TGeogPointInstSet, TGeogPointSeq, TGeogPointSeqSet
-
-__all__ = ['TBool', 'TBoolInst', 'TBoolInstSet', 'TBoolSeq', 'TBoolSeqSet',
-        'TInt', 'TIntInst', 'TIntInstSet', 'TIntSeq', 'TIntSeqSet',
-        'TFloat', 'TFloatInst', 'TFloatInstSet', 'TFloatSeq', 'TFloatSeqSet',
-        'TText', 'TTextInst', 'TTextInstSet', 'TTextSeq', 'TTextSeqSet',
-        'TPointInst', 'TPointInstSet', 'TPointSeq', 'TPointSeqSet',
-        'TGeomPoint', 'TGeomPointInst', 'TGeomPointInstSet', 'TGeomPointSeq', 'TGeomPointSeqSet',
-        'TGeogPoint', 'TGeogPointInst', 'TGeogPointInstSet', 'TGeogPointSeq', 'TGeogPointSeqSet']
+from .tbool import TBool, TBoolInst, TBoolInstSet, TBoolSeq, TBoolSeqSet
+from .tint import TInt, TIntInst, TIntInstSet, TIntSeq, TIntSeqSet
+from .tfloat import TFloat, TFloatInst, TFloatInstSet, TFloatSeq, TFloatSeqSet
+from .ttext import TText, TTextInst, TTextInstSet, TTextSeq, TTextSeqSet
+from .tpoint import TPointInst, TPointInstSet, TPointSeq, TPointSeqSet,\
+    TGeomPoint, TGeomPointInst, TGeomPointInstSet, TGeomPointSeq, TGeomPointSeqSet,\
+    TGeogPoint, TGeogPointInst, TGeogPointInstSet, TGeogPointSeq, TGeogPointSeqSet
+
+__all__ = ['TBool', 'TBoolInst', 'TBoolInstSet', 'TBoolSeq', 'TBoolSeqSet',
+        'TInt', 'TIntInst', 'TIntInstSet', 'TIntSeq', 'TIntSeqSet',
+        'TFloat', 'TFloatInst', 'TFloatInstSet', 'TFloatSeq', 'TFloatSeqSet',
+        'TText', 'TTextInst', 'TTextInstSet', 'TTextSeq', 'TTextSeqSet',
+        'TPointInst', 'TPointInstSet', 'TPointSeq', 'TPointSeqSet',
+        'TGeomPoint', 'TGeomPointInst', 'TGeomPointInstSet', 'TGeomPointSeq', 'TGeomPointSeqSet',
+        'TGeogPoint', 'TGeogPointInst', 'TGeogPointInstSet', 'TGeogPointSeq', 'TGeogPointSeqSet']
```

