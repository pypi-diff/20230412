# Comparing `tmp/anubis_policy_api-0.6.0-py3-none-any.whl.zip` & `tmp/anubis_policy_api-0.7.0.dev0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,42 @@
-Zip file size: 35983 bytes, number of entries: 40
--rw-r--r--  2.0 unx        0 b- defN 22-Oct-31 20:34 anubis/__init__.py
--rw-r--r--  2.0 unx       31 b- defN 22-Oct-31 20:34 anubis/config.py
--rw-r--r--  2.0 unx     1027 b- defN 22-Oct-31 20:34 anubis/database.py
--rw-r--r--  2.0 unx      942 b- defN 22-Oct-31 20:34 anubis/default.py
--rw-r--r--  2.0 unx      153 b- defN 22-Oct-31 20:34 anubis/dependencies.py
--rw-r--r--  2.0 unx     2966 b- defN 22-Oct-31 20:34 anubis/main.py
--rw-r--r--  2.0 unx     3095 b- defN 22-Oct-31 20:34 anubis/rego.py
--rw-r--r--  2.0 unx     1197 b- defN 22-Oct-31 20:34 anubis/utils.py
--rw-r--r--  2.0 unx       25 b- defN 22-Oct-31 20:34 anubis/version.py
--rw-r--r--  2.0 unx     4325 b- defN 22-Oct-31 20:34 anubis/wac.py
--rw-r--r--  2.0 unx        0 b- defN 22-Oct-31 20:34 anubis/audit/__init__.py
--rw-r--r--  2.0 unx     1006 b- defN 22-Oct-31 20:34 anubis/audit/models.py
--rw-r--r--  2.0 unx     3147 b- defN 22-Oct-31 20:34 anubis/audit/operations.py
--rw-r--r--  2.0 unx    11086 b- defN 22-Oct-31 20:34 anubis/audit/routers.py
--rw-r--r--  2.0 unx      908 b- defN 22-Oct-31 20:34 anubis/audit/schemas.py
--rw-r--r--  2.0 unx        0 b- defN 22-Oct-31 20:34 anubis/middleware/__init__.py
--rw-r--r--  2.0 unx     2239 b- defN 22-Oct-31 20:34 anubis/middleware/operations.py
--rw-r--r--  2.0 unx    11383 b- defN 22-Oct-31 20:34 anubis/middleware/routers.py
--rw-r--r--  2.0 unx      257 b- defN 22-Oct-31 20:34 anubis/middleware/schemas.py
--rw-r--r--  2.0 unx        0 b- defN 22-Oct-31 20:34 anubis/policies/__init__.py
--rw-r--r--  2.0 unx     3348 b- defN 22-Oct-31 20:34 anubis/policies/models.py
--rw-r--r--  2.0 unx    10697 b- defN 22-Oct-31 20:34 anubis/policies/operations.py
--rw-r--r--  2.0 unx    24882 b- defN 22-Oct-31 20:34 anubis/policies/routers.py
--rw-r--r--  2.0 unx     2561 b- defN 22-Oct-31 20:34 anubis/policies/schemas.py
--rw-r--r--  2.0 unx        0 b- defN 22-Oct-31 20:34 anubis/tenants/__init__.py
--rw-r--r--  2.0 unx     1715 b- defN 22-Oct-31 20:34 anubis/tenants/models.py
--rw-r--r--  2.0 unx     4995 b- defN 22-Oct-31 20:34 anubis/tenants/operations.py
--rw-r--r--  2.0 unx    14454 b- defN 22-Oct-31 20:34 anubis/tenants/routers.py
--rw-r--r--  2.0 unx     1622 b- defN 22-Oct-31 20:34 anubis/tenants/schemas.py
--rw-r--r--  2.0 unx        0 b- defN 22-Oct-31 20:34 anubis/tests/__init__.py
--rw-r--r--  2.0 unx      601 b- defN 22-Oct-31 20:34 anubis/tests/test_api.py
--rw-r--r--  2.0 unx     5608 b- defN 22-Oct-31 20:34 anubis/tests/test_audit.py
--rw-r--r--  2.0 unx     9394 b- defN 22-Oct-31 20:34 anubis/tests/test_policies.py
--rw-r--r--  2.0 unx     5553 b- defN 22-Oct-31 20:34 anubis/tests/test_rdf_parsing.py
--rw-r--r--  2.0 unx     2664 b- defN 22-Oct-31 20:34 anubis/tests/test_tenants.py
--rw-r--r--  2.0 unx      315 b- defN 22-Oct-31 20:34 anubis/tests/utils.py
--rw-r--r--  2.0 unx     2674 b- defN 22-Oct-31 20:34 anubis_policy_api-0.6.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Oct-31 20:34 anubis_policy_api-0.6.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 22-Oct-31 20:34 anubis_policy_api-0.6.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3209 b- defN 22-Oct-31 20:34 anubis_policy_api-0.6.0.dist-info/RECORD
-40 files, 138178 bytes uncompressed, 30899 bytes compressed:  77.6%
+Zip file size: 37323 bytes, number of entries: 40
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-12 08:51 anubis/__init__.py
+-rw-r--r--  2.0 unx       31 b- defN 23-Apr-12 08:51 anubis/config.py
+-rw-r--r--  2.0 unx     1027 b- defN 23-Apr-12 08:51 anubis/database.py
+-rw-r--r--  2.0 unx      942 b- defN 23-Apr-12 08:51 anubis/default.py
+-rw-r--r--  2.0 unx      153 b- defN 23-Apr-12 08:51 anubis/dependencies.py
+-rw-r--r--  2.0 unx     3269 b- defN 23-Apr-12 08:51 anubis/main.py
+-rw-r--r--  2.0 unx     3087 b- defN 23-Apr-12 08:51 anubis/rego.py
+-rw-r--r--  2.0 unx     1197 b- defN 23-Apr-12 08:51 anubis/utils.py
+-rw-r--r--  2.0 unx       29 b- defN 23-Apr-12 08:51 anubis/version.py
+-rw-r--r--  2.0 unx     4757 b- defN 23-Apr-12 08:51 anubis/wac.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-12 08:51 anubis/audit/__init__.py
+-rw-r--r--  2.0 unx     1074 b- defN 23-Apr-12 08:51 anubis/audit/models.py
+-rw-r--r--  2.0 unx     3147 b- defN 23-Apr-12 08:51 anubis/audit/operations.py
+-rw-r--r--  2.0 unx    11086 b- defN 23-Apr-12 08:51 anubis/audit/routers.py
+-rw-r--r--  2.0 unx      908 b- defN 23-Apr-12 08:51 anubis/audit/schemas.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-12 08:51 anubis/middleware/__init__.py
+-rw-r--r--  2.0 unx     2239 b- defN 23-Apr-12 08:51 anubis/middleware/operations.py
+-rw-r--r--  2.0 unx    11401 b- defN 23-Apr-12 08:51 anubis/middleware/routers.py
+-rw-r--r--  2.0 unx      257 b- defN 23-Apr-12 08:51 anubis/middleware/schemas.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-12 08:51 anubis/policies/__init__.py
+-rw-r--r--  2.0 unx     4792 b- defN 23-Apr-12 08:51 anubis/policies/models.py
+-rw-r--r--  2.0 unx    11111 b- defN 23-Apr-12 08:51 anubis/policies/operations.py
+-rw-r--r--  2.0 unx    26422 b- defN 23-Apr-12 08:51 anubis/policies/routers.py
+-rw-r--r--  2.0 unx     2561 b- defN 23-Apr-12 08:51 anubis/policies/schemas.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-12 08:51 anubis/tenants/__init__.py
+-rw-r--r--  2.0 unx     1783 b- defN 23-Apr-12 08:51 anubis/tenants/models.py
+-rw-r--r--  2.0 unx     5252 b- defN 23-Apr-12 08:51 anubis/tenants/operations.py
+-rw-r--r--  2.0 unx    15428 b- defN 23-Apr-12 08:51 anubis/tenants/routers.py
+-rw-r--r--  2.0 unx     1622 b- defN 23-Apr-12 08:51 anubis/tenants/schemas.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-12 08:51 anubis/tests/__init__.py
+-rw-r--r--  2.0 unx      601 b- defN 23-Apr-12 08:51 anubis/tests/test_api.py
+-rw-r--r--  2.0 unx     5608 b- defN 23-Apr-12 08:51 anubis/tests/test_audit.py
+-rw-r--r--  2.0 unx    10232 b- defN 23-Apr-12 08:51 anubis/tests/test_policies.py
+-rw-r--r--  2.0 unx     5710 b- defN 23-Apr-12 08:51 anubis/tests/test_rdf_parsing.py
+-rw-r--r--  2.0 unx     2664 b- defN 23-Apr-12 08:51 anubis/tests/test_tenants.py
+-rw-r--r--  2.0 unx      315 b- defN 23-Apr-12 08:51 anubis/tests/utils.py
+-rw-r--r--  2.0 unx     2679 b- defN 23-Apr-12 08:51 anubis_policy_api-0.7.0.dev0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-12 08:51 anubis_policy_api-0.7.0.dev0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-Apr-12 08:51 anubis_policy_api-0.7.0.dev0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3230 b- defN 23-Apr-12 08:51 anubis_policy_api-0.7.0.dev0.dist-info/RECORD
+40 files, 144713 bytes uncompressed, 32199 bytes compressed:  77.7%
```

## zipnote {}

```diff
@@ -102,20 +102,20 @@
 
 Filename: anubis/tests/test_tenants.py
 Comment: 
 
 Filename: anubis/tests/utils.py
 Comment: 
 
-Filename: anubis_policy_api-0.6.0.dist-info/METADATA
+Filename: anubis_policy_api-0.7.0.dev0.dist-info/METADATA
 Comment: 
 
-Filename: anubis_policy_api-0.6.0.dist-info/WHEEL
+Filename: anubis_policy_api-0.7.0.dev0.dist-info/WHEEL
 Comment: 
 
-Filename: anubis_policy_api-0.6.0.dist-info/top_level.txt
+Filename: anubis_policy_api-0.7.0.dev0.dist-info/top_level.txt
 Comment: 
 
-Filename: anubis_policy_api-0.6.0.dist-info/RECORD
+Filename: anubis_policy_api-0.7.0.dev0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## anubis/main.py

```diff
@@ -1,19 +1,22 @@
 from fastapi import Depends, FastAPI, Response
 from anubis.tenants import routers as t
 from anubis.tenants import models as t_models
+from anubis.tenants import operations as t_operations
 from anubis.policies import routers as p
 from anubis.policies import models as p_models
 from anubis.audit import routers as a
 from anubis.audit import models as a_models
 from anubis.middleware import routers as m
 from anubis.version import ANUBIS_VERSION
 from fastapi.openapi.utils import get_openapi
-from anubis.database import engine
+from fastapi_utils.tasks import repeat_every
+from anubis.database import engine, SessionLocal
 import uvicorn
+import logging
 
 from fastapi.middleware.cors import CORSMiddleware
 
 import os
 
 tags_metadata = [
     {
@@ -37,14 +40,15 @@
 
 app.add_middleware(
     CORSMiddleware,
     allow_origins=allowed_origins,
     allow_credentials=True,
     allow_methods=allowed_methods,
     allow_headers=allowed_headers,
+    expose_headers=["Counter"]
 )
 
 # TODO auth
 # https://docs.authlib.org/en/latest/client/fastapi.html
 # https://developer.okta.com/blog/2020/12/17/build-and-secure-an-api-in-python-with-fastapi
 
 app.include_router(t.router)
@@ -79,14 +83,20 @@
 @app.on_event("startup")
 def on_startup():
     p_models.init_db()
     t_models.init_db()
     a_models.init_db()
 
 
+@app.on_event("startup")
+@repeat_every(seconds=3600, logger=logging)
+def update_policies_in_opa_task():
+    p_models.update_policies_in_opa()
+
+
 @app.get("/ping", summary="Simple healthcheck endpoint")
 async def pong():
     return {"ping": "pong!"}
 
 
 def custom_openapi():
     if app.openapi_schema:
```

## anubis/rego.py

```diff
@@ -1,16 +1,16 @@
-from .policies.models import Policy
+# from .policies.models import Policy
 from .policies import operations as po
 from .tenants import operations as to
 from sqlalchemy.orm import Session
 from .default import AUTHENTICATED_AGENT_ID
 import json
 
 
-def serialize(db: Session, policies: [Policy]):
+def serialize(db: Session, policies):
     if len(policies) > 0:
         rego = {
             "user_permissions": {},
             "default_user_permissions": {},
             "group_permissions": {},
             "default_group_permissions": {},
             "role_permissions": {},
```

## anubis/version.py

```diff
@@ -1 +1 @@
-ANUBIS_VERSION = '0.6.0'
+ANUBIS_VERSION = '0.7.0-dev'
```

## anubis/wac.py

```diff
@@ -78,16 +78,24 @@
         for index, mode in enumerate(policy.mode):
             mode = URIRef(mode.iri, acl)
             g.add((policy_node, mode_property, mode))
 
         agent_class_property = acl.agentClass
         agent_property = acl.agent
         for index, agent in enumerate(policy.agent):
-            agent = URIRef(agent.iri, acl)
-            g.add((policy_node, agent_class_property, agent))
+            if agent.iri.startswith("acl:agent:"):
+                agent_email = agent.iri.split(":")[2]
+                agent_name = agent_email.split("@")[0]
+                agent = URIRef("acl:agent:" + agent_name, acl)
+                g.add((policy_node, agent_class_property, agent))
+                g.add((agent, RDF.type, FOAF.Agent))
+                g.add((agent, FOAF.mbox, Literal(agent_email)))
+            else:
+                agent = URIRef(agent.iri, acl)
+                g.add((policy_node, agent_class_property, agent))
 
         if policy.access_to == "default":
             access_to_property = acl.default
             access_to_value = fiware_servicepath
         else:
             access_to_property = acl.accessTo
             access_to_value = policy.access_to
```

## anubis/audit/models.py

```diff
@@ -24,7 +24,11 @@
     user = Column(String, index=True, nullable=True)
     remote_ip = Column(String, index=True, nullable=True)
     timestamp = Column(DateTime, index=True)
 
 
 def init_db():
     Base.metadata.create_all(bind=autocommit_engine)
+
+
+def drop_db():
+    Base.metadata.drop_all(bind=autocommit_engine)
```

## anubis/middleware/routers.py

```diff
@@ -221,15 +221,15 @@
                     service_path_id=db_service_path_id,
                     policy=owner_policy)
     access_to: str
     resource_type: str
     policies = []
     for agent in policy.agent:
         for mode in policy.mode:
-            db_policies = op.get_policies_by_service_path(
+            db_policies, counter = op.get_policies_by_service_path(
                 db=db,
                 tenant=fiware_service,
                 service_path_id=db_service_path_id,
                 mode=mode,
                 agent=agent,
                 resource=policy.access_to,
                 resource_type=policy.resource_type,
@@ -257,15 +257,15 @@
         db: Session = Depends(get_db)):
     db_policy = op.get_policy(db, policy_id=policy_id)
     if not db_policy:
         raise HTTPException(status_code=404, detail="Policy not found")
     policies = []
     for agent in policy.agent:
         for mode in policy.mode:
-            db_policies = op.get_policies_by_service_path(
+            db_policies, counter = op.get_policies_by_service_path(
                 db=db,
                 tenant=None,
                 service_path_id=[db_policy.service_path_id],
                 mode=mode,
                 agent=agent,
                 resource=policy.access_to,
                 resource_type=policy.resource_type,
```

## anubis/policies/models.py

```diff
@@ -1,16 +1,20 @@
 from sqlalchemy import Table, Boolean, Column, ForeignKey, Integer, String, UniqueConstraint, ForeignKeyConstraint
 from sqlalchemy.orm import relationship, column_property
 
 from ..database import autocommit_engine, Base, SessionLocal
 from sqlalchemy import event, select, func
-from ..tenants.models import ServicePath
+from ..tenants.models import ServicePath, Tenant
+from ..rego import serialize as r_serialize
 from uuid import uuid4
 
 import anubis.default as default
+import json
+import requests
+import os
 
 
 policy_to_mode = Table(
     'policy_to_mode', Base.metadata, Column(
         'policy_id', String, ForeignKey(
             'policies.id', onupdate="CASCADE", ondelete="CASCADE")), Column(
                 'mode_iri', String, ForeignKey(
@@ -63,14 +67,49 @@
     name = Column(String, index=True, unique=True)
 
 
 def init_db():
     Base.metadata.create_all(bind=autocommit_engine)
 
 
+def drop_db():
+    Base.metadata.drop_all(bind=autocommit_engine)
+
+
+def update_policies_in_opa():
+    if os.environ.get('OPA_ENDPOINT') and os.environ.get(
+            'HOURLY_OPA_POLICIES_REFRESH') == "True":
+        opa_url = os.environ.get('OPA_ENDPOINT')
+        db = SessionLocal()
+        tenants = db.query(Tenant).all()
+        for tenant in tenants:
+            db_service_paths = db.query(ServicePath).filter(
+                ServicePath.tenant_id == tenant.id).all()
+            policies = []
+            for db_service_path in db_service_paths:
+                path_policies = db.query(Policy).filter(
+                    Policy.service_path_id.startswith(
+                        db_service_path.id)).all()
+                policies = policies + path_policies
+            policies = r_serialize(db, policies)
+            policies = json.loads(policies)
+            # Not currently handling service paths
+            try:
+                res = requests.put(
+                    opa_url +
+                    "/v1/data/" +
+                    tenant.name +
+                    "/policies",
+                    json=policies)
+                if res.status_code != 204:
+                    print("Failed scheduled update to policies in OPA")
+            except BaseException:
+                print("Failed scheduled update to policies in OPA")
+
+
 @event.listens_for(AgentType.__table__, 'after_create')
 def insert_initial_agent_type_values(target, connection, **kw):
     db = SessionLocal()
     db.add(AgentType(name='agent', iri=default.AGENT_IRI))
     db.add(AgentType(name='group', iri=default.AGENT_GROUP_IRI))
     db.add(AgentType(name='class', iri=default.AGENT_CLASS_IRI))
     db.commit()
```

## anubis/policies/operations.py

```diff
@@ -1,14 +1,16 @@
 from sqlalchemy.orm import Session
 
 from . import models, schemas
 from functools import reduce
 import uuid
 import anubis.default as default
 
+defaultLimit = 1000
+
 
 def get_policy(db: Session, policy_id: str):
     return db.query(
         models.Policy).filter(
         models.Policy.id == policy_id).first()
 
 
@@ -18,18 +20,16 @@
         service_path_id: [str],
         mode: str = None,
         agent: str = None,
         agent_type: str = None,
         resource: str = None,
         resource_type: str = None,
         skip: int = 0,
-        limit: int = 100,
-        user_info: dict = None,
-        owner: str = None):
-    # TODO: filter policy that owner (email based) controls
+        limit: int = defaultLimit,
+        user_info: dict = None):
     if mode is not None and agent is not None:
         db_policies = db.query(
             models.Policy).join(
             models.Policy.agent).filter(
             models.Agent.iri == agent).join(
                 models.Policy.mode).filter(
                     models.Mode.iri == mode).filter(
@@ -39,15 +39,17 @@
                 models.Policy.access_to.contains(resource))
         if resource_type:
             db_policies = db_policies.filter(
                 models.Policy.resource_type.contains(resource_type))
         if user_info:
             db_policies = filter_policies_by_user_profile(
                 db_policies, tenant, user_info)
-        return db_policies.offset(skip).limit(limit).all()
+        counter = db_policies.count()
+        return db_policies.order_by(models.Policy.id.asc()).offset(
+            skip).limit(limit).all(), counter
     elif mode is None and agent is not None:
         return get_policies_by_agent(
             db=db,
             tenant=tenant,
             service_path_id=service_path_id,
             agent=agent,
             resource=resource,
@@ -83,15 +85,15 @@
         tenant: str,
         service_path_id: [str],
         mode: str,
         agent_type: str = None,
         resource: str = None,
         resource_type: str = None,
         skip: int = 0,
-        limit: int = 100,
+        limit: int = defaultLimit,
         user_info: dict = None):
     db_policies = db.query(
         models.Policy).join(
         models.Policy.mode).filter(
             models.Mode.iri == mode).filter(
                 models.Policy.service_path_id.in_(service_path_id))
     if agent_type:
@@ -108,26 +110,28 @@
             models.Policy.access_to.contains(resource))
     if resource_type:
         db_policies = db_policies.filter(
             models.Policy.resource_type.contains(resource_type))
     if user_info:
         db_policies = filter_policies_by_user_profile(
             db_policies, tenant, user_info)
-    return db_policies.offset(skip).limit(limit).all()
+    counter = db_policies.count()
+    return db_policies.order_by(models.Policy.id.asc()).offset(
+        skip).limit(limit).all(), counter
 
 
 def get_policies_by_agent(
         db: Session,
         tenant: str,
         service_path_id: [str],
         agent: str,
         resource: str = None,
         resource_type: str = None,
         skip: int = 0,
-        limit: int = 100,
+        limit: int = defaultLimit,
         user_info: dict = None):
     db_policies = db.query(
         models.Policy).join(
         models.Policy.agent).filter(
             models.Agent.iri == agent).filter(
                 models.Policy.service_path_id.in_(service_path_id))
     if resource:
@@ -135,26 +139,28 @@
             models.Policy.access_to.contains(resource))
     if resource_type:
         db_policies = db_policies.filter(
             models.Policy.resource_type.contains(resource_type))
     if user_info:
         db_policies = filter_policies_by_user_profile(
             db_policies, tenant, user_info)
-    return db_policies.offset(skip).limit(limit).all()
+    counter = db_policies.count()
+    return db_policies.order_by(models.Policy.id.asc()).offset(
+        skip).limit(limit).all(), counter
 
 
 def _get_policies_by_service_path(
         db: Session,
         tenant: str,
         service_path_id: [str],
         agent_type: str = None,
         resource: str = None,
         resource_type: str = None,
         skip: int = 0,
-        limit: int = 100,
+        limit: int = defaultLimit,
         user_info: dict = None):
     db_policies = db.query(
         models.Policy).filter(
         models.Policy.service_path_id.in_(service_path_id))
     if agent_type:
         if agent_type in default.DEFAULT_AGENTS:
             db_policies = db_policies.join(
@@ -169,23 +175,27 @@
             models.Policy.access_to.contains(resource))
     if resource_type:
         db_policies = db_policies.filter(
             models.Policy.resource_type.contains(resource_type))
     if user_info:
         db_policies = filter_policies_by_user_profile(
             db_policies, tenant, user_info)
-    return db_policies.offset(skip).limit(limit).all()
+    counter = db_policies.count()
+    return db_policies.order_by(models.Policy.id.asc()).offset(
+        skip).limit(limit).all(), counter
 
 
 def get_policy_by_access_to(db: Session, access_to: str):
     return db.query(models.Policy).filter(models.Policy.access_to == access_to)
 
 
-def get_policies(db: Session, skip: int = 0, limit: int = 100):
-    return db.query(models.Policy).offset(skip).limit(limit).all()
+def get_policies(db: Session, skip: int = 0, limit: int = defaultLimit):
+    return db.query(
+        models.Policy).order_by(
+        models.Policy.id.asc()).offset(skip).limit(limit).all()
 
 
 def filter_policies_by_user_profile(db_policies, tenant, user_info):
     user = default.AGENT_IRI + ":" + user_info["email"]
 
     groups = user_info["tenants"].get(tenant)
     if groups:
@@ -285,36 +295,36 @@
     return db.query(models.Mode).filter(models.Mode.iri == mode_iri).first()
 
 
 def get_agent_by_iri(db: Session, agent_iri: str):
     return db.query(models.Agent).filter(models.Agent.iri == agent_iri).first()
 
 
-def get_agents(db: Session, skip: int = 0, limit: int = 100):
+def get_agents(db: Session, skip: int = 0, limit: int = defaultLimit):
     return db.query(models.Agent).offset(skip).limit(limit).all()
 
 
 def get_agents_by_type(
         db: Session,
         agent_type_iri: str,
         skip: int = 0,
-        limit: int = 100):
+        limit: int = defaultLimit):
     return db.query(models.Agent).filter(models.Agent.type_iri ==
                                          agent_type_iri).offset(skip).limit(limit).all()
 
 
 def create_agent(db: Session, agent_iri: str):
     # default agent are created on db instantiation
     agent_type = agent_iri[:agent_iri.index(":", 4)]
     db_agent = models.Agent(iri=agent_iri, type_iri=agent_type)
     db.add(db_agent)
     db.commit()
     db.refresh(db_agent)
     return db_agent
 
 
-def get_modes(db: Session, skip: int = 0, limit: int = 100):
+def get_modes(db: Session, skip: int = 0, limit: int = defaultLimit):
     return db.query(models.Mode).offset(skip).limit(limit).all()
 
 
-def get_agent_types(db: Session, skip: int = 0, limit: int = 100):
+def get_agent_types(db: Session, skip: int = 0, limit: int = defaultLimit):
     return db.query(models.AgentType).offset(skip).limit(limit).all()
```

## anubis/policies/routers.py

```diff
@@ -8,14 +8,17 @@
 from ..wac import serialize as w_serialize
 from ..rego import serialize as r_serialize
 from ..utils import parse_auth_token, OptionalHTTPBearer
 import anubis.default as default
 import logging
 import requests
 import urllib
+import json
+
+defaultLimit = 1000
 
 
 auth_scheme = OptionalHTTPBearer()
 router = APIRouter(prefix="/v1/policies",
                    tags=["policies"],
                    responses={404: {"description": "Not found"}},)
 
@@ -31,30 +34,32 @@
         id=policy.id,
         access_to=policy.access_to,
         resource_type=policy.resource_type,
         mode=modes,
         agent=agents)
 
 
-# def compute_policy_id(policy: models.Policy):
-#    return policy.id
-
-
 @router.get("/access-modes",
             response_model=List[schemas.Mode],
             summary="List supported Access Modes")
-def read_modes(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
+def read_modes(
+        skip: int = 0,
+        limit: int = defaultLimit,
+        db: Session = Depends(get_db)):
     modes = operations.get_modes(db, skip=skip, limit=limit)
     return modes
 
 
 @router.get("/agent-types",
             response_model=List[schemas.AgentType],
             summary="List supported Agent Types")
-def read_modes(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
+def read_agent_types(
+        skip: int = 0,
+        limit: int = defaultLimit,
+        db: Session = Depends(get_db)):
     types = operations.get_agent_types(db, skip=skip, limit=limit)
     return types
 
 
 policies_not_json_responses = {
     200: {
         "description": "Success",
@@ -210,36 +215,35 @@
                     }"""
                 }
             }
         }
     },
 }
 
-# TODO if no token, we should return policies for foaf:Agent!
-
 
 @router.get("/me",
             response_model=List[schemas.Policy],
             responses=policies_not_json_responses,
             summary="List policies for a given Tenant and Service Path that apply to me")
 def my_policies(
+        response: Response,
         token: str = Depends(auth_scheme),
         fiware_service: Optional[str] = Header(
             None),
         fiware_servicepath: Optional[str] = Header(
             '/#'),
         mode: Optional[str] = None,
         agent: Optional[str] = None,
         accept: Optional[str] = Header(
             'application/json'),
         resource: Optional[str] = None,
         resource_type: Optional[str] = None,
         agent_type: Optional[str] = None,
         skip: int = 0,
-        limit: int = 100,
+        limit: int = defaultLimit,
         db: Session = Depends(get_db)):
     """
     Policies can be filtered by:
       - Access Mode
       - Agent
       - Agent Type
       - Resource
@@ -247,41 +251,55 @@
     Requires a JWT token: contained user id, roles and groups are used to
     filter policies that are only valid for the user.
     To return policies from a service path tree, you can used the wildchar "#".
     For example, using `/Path1/#` you will obtain policies for all subpaths,
     such as: `/Path1/SubPath1` or `/Path1/SubPath1/SubSubPath1`.
     """
     user_info = parse_auth_token(token)
+    agent_type = None
+    if user_info and user_info['is_super_admin']:
+        agent_type = None
+    elif user_info and user_info['tenants'] and fiware_service in user_info['tenants'] and "roles" in user_info['tenants'][fiware_service] and "tenant-admin" in user_info['tenants'][fiware_service]["roles"]:
+        agent_type = None
     if not user_info:
-        raise HTTPException(
-            status_code=403,
-            detail='missing access token, cannot identify user'
-        )
-    if agent_type and agent_type not in default.DEFAULT_AGENTS and agent_type not in default.DEFAULT_AGENT_TYPES:
-        raise HTTPException(
-            status_code=422,
-            detail='agent_type {} is not a valid agent type. Valid types are {} or {}'.format(
-                agent_type,
-                default.DEFAULT_AGENTS,
-                default.DEFAULT_AGENT_TYPES))
+        agent_type = "foaf:Agent"
+    else:
+        agent_type = "acl:agent:" + user_info["email"]
     db_service_path = so.get_db_service_path(
         db, fiware_service, fiware_servicepath)
     db_service_path_id = list(map(so.compute_id, db_service_path))
-    db_policies = operations.get_policies_by_service_path(
+    db_policies, counter = operations.get_policies_by_service_path(
         db,
         tenant=fiware_service,
         service_path_id=db_service_path_id,
         mode=mode,
         agent=agent,
-        agent_type=agent_type,
+        agent_type="foaf:Agent",
         resource=resource,
         resource_type=resource_type,
         skip=skip,
         limit=limit,
-        user_info=user_info)
+        user_info=None)
+    # Maybe do this for groups and roles too?
+    if user_info:
+        db_policies_user, counter_user = operations.get_policies_by_service_path(
+            db,
+            tenant=fiware_service,
+            service_path_id=db_service_path_id,
+            mode=mode,
+            agent=agent,
+            agent_type=agent_type,
+            resource=resource,
+            resource_type=resource_type,
+            skip=skip,
+            limit=limit,
+            user_info=user_info)
+        db_policies = db_policies + db_policies_user
+        counter = counter + counter_user
+    response.headers["Counter"] = str(counter)
     if accept == 'text/turtle':
         return Response(
             content=w_serialize(
                 db,
                 fiware_service,
                 fiware_servicepath,
                 db_policies),
@@ -300,28 +318,29 @@
 
 
 @router.get("/",
             response_model=List[schemas.Policy],
             responses=policies_not_json_responses,
             summary="List policies for a given Tenant and Service Path")
 def read_policies(
+        response: Response,
         token: str = Depends(auth_scheme),
         fiware_service: Optional[str] = Header(
             None),
         fiware_servicepath: Optional[str] = Header(
             '/#'),
         mode: Optional[str] = None,
         agent: Optional[str] = None,
         accept: Optional[str] = Header(
             'application/json'),
         resource: Optional[str] = None,
         resource_type: Optional[str] = None,
         agent_type: Optional[str] = None,
         skip: int = 0,
-        limit: int = 100,
+        limit: int = defaultLimit,
         db: Session = Depends(get_db)):
     """
     Policies can be filtered by:
       - Access Mode
       - Agent
       - Agent Type
       - Resource
@@ -329,44 +348,40 @@
     In case an JWT token is passed over, user id is used to filter policies
     where the owner is user id. Unless the user is super admin or tenant admin.
     To return policies from a service path tree, you can used the wildchar "#".
     For example, using `/Path1/#` you will obtain policies for all subpaths,
     such as: `/Path1/SubPath1` or `/Path1/SubPath1/SubSubPath1`.
     """
     user_info = parse_auth_token(token)
-    owner = None
     if user_info and user_info['is_super_admin']:
-        owner = None
+        user_info = None
     elif user_info and user_info['tenants'] and fiware_service in user_info['tenants'] and "roles" in user_info['tenants'][fiware_service] and "tenant-admin" in user_info['tenants'][fiware_service]["roles"]:
-        owner = None
-    elif user_info and user_info['email']:
-        owner = user_info['email']
-    # we don't filter policies in case super admin or tenant admin
+        user_info = None
     if agent_type and agent_type not in default.DEFAULT_AGENTS and agent_type not in default.DEFAULT_AGENT_TYPES:
         raise HTTPException(
             status_code=422,
             detail='agent_type {} is not a valid agent type. Valid types are {} or {}'.format(
                 agent_type,
                 default.DEFAULT_AGENTS,
                 default.DEFAULT_AGENT_TYPES))
     db_service_path = so.get_db_service_path(
         db, fiware_service, fiware_servicepath)
     db_service_path_id = list(map(so.compute_id, db_service_path))
-    db_policies = operations.get_policies_by_service_path(
+    db_policies, counter = operations.get_policies_by_service_path(
         db,
         tenant=fiware_service,
         service_path_id=db_service_path_id,
         mode=mode,
         agent=agent,
         agent_type=agent_type,
         resource=resource,
         resource_type=resource_type,
         skip=skip,
-        limit=limit,
-        owner=owner)
+        limit=limit)
+    response.headers["Counter"] = str(counter)
     if accept == 'text/turtle':
         return Response(
             content=w_serialize(
                 db,
                 fiware_service,
                 fiware_servicepath,
                 db_policies),
@@ -447,15 +462,15 @@
             detail="access_to field needs to be the same as fiware_service when using type tenant")
     db_service_path = so.get_db_service_path(
         db, fiware_service, fiware_servicepath)
     db_service_path_id = list(map(so.compute_id, db_service_path))
     policies = []
     for agent in policy.agent:
         for mode in policy.mode:
-            db_policies = operations.get_policies_by_service_path(
+            db_policies, counter = operations.get_policies_by_service_path(
                 db=db,
                 tenant=fiware_service,
                 service_path_id=db_service_path_id,
                 mode=mode,
                 agent=agent,
                 resource=policy.access_to,
                 resource_type=policy.resource_type,
@@ -501,14 +516,15 @@
                     detail=res.text)
     except HTTPException as e:
         logging.warning(
             "failed middleware synchronization for {}".format(
                 urllib.parse.quote(
                     policy.access_to)))
         logging.error(e)
+    update_opa_policies(db, fiware_service, db_service_path_id)
     return response
 
 
 @router.put("/{policy_id}",
             response_class=Response,
             status_code=status.HTTP_204_NO_CONTENT,
             summary="Update a policy for a given Tenant and Service Path")
@@ -532,15 +548,15 @@
     if not db_policy:
         raise HTTPException(status_code=404, detail="Policy not found")
     if db_service_path_id[0] != db_policy.service_path_id:
         raise HTTPException(status_code=404, detail="Policy not found")
     policies = []
     for agent in policy.agent:
         for mode in policy.mode:
-            db_policies = operations.get_policies_by_service_path(
+            db_policies, counter = operations.get_policies_by_service_path(
                 db=db,
                 tenant=fiware_service,
                 service_path_id=db_service_path_id,
                 mode=mode,
                 agent=agent,
                 resource=policy.access_to,
                 resource_type=policy.resource_type,
@@ -574,14 +590,15 @@
                     detail=res.text)
     except HTTPException as e:
         logging.warning(
             "failed middleware synchronization for {}".format(
                 urllib.parse.quote(
                     policy.access_to)))
         logging.error(e)
+    update_opa_policies(db, fiware_service, db_service_path_id)
     return response
 
 
 @router.delete("/{policy_id}",
                response_class=Response,
                status_code=status.HTTP_204_NO_CONTENT,
                summary="Delete a policy for a given Tenant and Service Path")
@@ -592,14 +609,15 @@
             None),
     fiware_servicepath: Optional[str] = Header(
             None),
         db: Session = Depends(get_db)):
     db_service_path = so.get_db_service_path(
         db, fiware_service, fiware_servicepath)
     db_policy = operations.get_policy(db, policy_id=policy_id)
+    db_service_path_id = list(map(so.compute_id, db_service_path))
     if not db_policy:
         raise HTTPException(status_code=404, detail="Policy not found")
     if db_service_path[0].id != db_policy.service_path_id:
         raise HTTPException(status_code=404, detail="Policy not found")
     operations.delete_policy(db=db, policy=db_policy)
     response.headers["Policy-ID"] = policy_id
     response.status_code = status.HTTP_204_NO_CONTENT
@@ -624,8 +642,31 @@
                     detail=res.text)
     except HTTPException as e:
         logging.warning(
             "failed middleware synchronization for {}".format(
                 urllib.parse.quote(
                     db_policy.access_to)))
         logging.error(e)
+    update_opa_policies(db, fiware_service, db_service_path_id)
     return response
+
+
+def update_opa_policies(db, fiware_service, db_service_path_id):
+    if os.environ.get('OPA_ENDPOINT'):
+        opa_url = os.environ.get('OPA_ENDPOINT')
+        db_policies, counter = operations.get_policies_by_service_path(
+            db,
+            tenant=fiware_service,
+            service_path_id=db_service_path_id)
+        policies = r_serialize(db, db_policies)
+        policies = json.loads(policies)
+        # Not currently handling service paths
+        res = requests.put(
+            opa_url +
+            "/v1/data/" +
+            fiware_service +
+            "/policies",
+            json=policies)
+        if res.status_code != 204:
+            raise HTTPException(
+                status_code=res.status_code,
+                detail="Failed to update policies in OPA")
```

## anubis/tenants/models.py

```diff
@@ -43,7 +43,11 @@
                           )
 #ServicePath.parent_id = Column(String, ForeignKey(ServicePath.id), nullable=True)
 #ServicePath.children = relationship(ServicePath, cascade = "all, delete")
 
 
 def init_db():
     Base.metadata.create_all(bind=autocommit_engine)
+
+
+def drop_db():
+    Base.metadata.drop_all(bind=autocommit_engine)
```

## anubis/tenants/operations.py

```diff
@@ -20,15 +20,17 @@
 
 
 def get_tenant_by_name(db: Session, name: str):
     return db.query(models.Tenant).filter(models.Tenant.name == name).first()
 
 
 def get_tenants(db: Session, skip: int = 0, limit: int = 100):
-    return db.query(models.Tenant).offset(skip).limit(limit).all()
+    return db.query(
+        models.Tenant).order_by(
+        models.Tenant.name.asc()).offset(skip).limit(limit).all()
 
 
 def create_tenant(
         db: Session,
         tenant: schemas.TenantCreate,
         tenant_id: str = None):
     if not tenant_id:
@@ -65,29 +67,31 @@
 
 def delete_tenant(db: Session, tenant: models.Tenant):
     db.delete(tenant)
     db.commit()
 
 
 def get_service_paths(db: Session, skip: int = 0, limit: int = 100):
-    return db.query(models.ServicePath).offset(skip).limit(limit).all()
+    return db.query(models.ServicePath).order_by(
+        models.ServicePath.path.asc()).offset(skip).limit(limit).all()
 
 
 def get_tenant_service_paths(
         db: Session,
         tenant_id: str,
         name: str = None,
         skip: int = 0,
         limit: int = 100):
     db_service_paths = db.query(models.ServicePath).filter(
         models.ServicePath.tenant_id == tenant_id)
     if name:
         db_service_paths = db_service_paths.filter(
             models.ServicePath.path.startswith(name))
-    return db_service_paths.offset(skip).limit(limit).all()
+    return db_service_paths.order_by(
+        models.ServicePath.path.asc()).offset(skip).limit(limit).all()
 
 
 def get_db_service_path(db: Session, tenant: str, service_path: str):
     if not tenant:
         raise HTTPException(status_code=422, detail="Tenant cannot be None")
     db_tenant = get_tenant_by_name(db, name=tenant)
     if not db_tenant:
@@ -101,20 +105,22 @@
 
 def get_tenant_service_path_by_path(db: Session, tenant_id: str, path: str):
     if path.endswith('/#'):
         queryPath = path.replace('#', '%')
         return db.query(
             models.ServicePath).filter(
             models.ServicePath.tenant_id == tenant_id).filter(
-                models.ServicePath.path.like(queryPath)).all()
+            models.ServicePath.path.like(queryPath)).order_by(
+                models.ServicePath.path.asc()).all()
     else:
         return db.query(
             models.ServicePath).filter(
             models.ServicePath.tenant_id == tenant_id).filter(
-                models.ServicePath.path == path).all()
+            models.ServicePath.path == path).order_by(
+                models.ServicePath.path.asc()).all()
 
 
 def get_tenant_service_path(db: Session, service_path_id: str, tenant_id: str):
     return db.query(
         models.ServicePath).filter(
         models.ServicePath.tenant_id == tenant_id).filter(
             models.ServicePath.id == service_path_id).first()
```

## anubis/tenants/routers.py

```diff
@@ -1,12 +1,14 @@
 from typing import List, Optional
 from fastapi import Depends, APIRouter, HTTPException, status, Response, Header
 from . import operations, schemas
+from ..policies import operations as policy_operations
 from ..dependencies import get_db
 from sqlalchemy.orm import Session
+from ..rego import serialize as r_serialize
 import os
 import requests
 import json
 from ..utils import OptionalHTTPBearer, parse_auth_token
 import logging
 
 
@@ -158,14 +160,37 @@
     if keycloak_enabled and not token:
         raise HTTPException(
             status_code=401,
             detail="Token is missing: cannot authenticate with Keycloak")
 
     tenant_id = operations.create_tenant(
         db=db, tenant=tenant, tenant_id=db_tenant_id).id
+
+    if os.environ.get('OPA_ENDPOINT'):
+        opa_url = os.environ.get('OPA_ENDPOINT', 'http://127.0.0.1:8181')
+        db_service_path = operations.get_db_service_path(
+            db, tenant.name, '/')
+        db_service_path_id = list(map(operations.compute_id, db_service_path))
+        db_policies, counter = policy_operations.get_policies_by_service_path(
+            db,
+            tenant=tenant.name,
+            service_path_id=db_service_path_id)
+        policies = r_serialize(db, db_policies)
+        policies = json.loads(policies)
+        res = requests.put(
+            opa_url +
+            "/v1/data/" +
+            tenant.name +
+            "/policies",
+            json=policies)
+        if res.status_code != 204:
+            raise HTTPException(
+                status_code=res.status_code,
+                detail="Failed to update policies in OPA")
+
     response.headers["Tenant-ID"] = tenant_id
     response.status_code = status.HTTP_201_CREATED
     return response
 
 
 @router.get("/{tenant_id}",
             response_model=schemas.Tenant,
```

## anubis/tests/test_policies.py

```diff
@@ -298,7 +298,37 @@
 
     response = client.delete(
         "/v1/policies/" + policy_id,
         headers={
             "fiware-service": "Tenant1",
             "fiware-servicepath": "/"})
     assert response.status_code == 204
+
+    response = client.get(
+        "/v1/policies/me",
+        headers={
+            "fiware-service": "test",
+            "fiware-servicepath": "/"})
+    assert response.status_code == 200
+    body = response.json()
+    assert len(body) == 1
+
+    response = client.post(
+        "/v1/policies/",
+        headers={
+            "fiware-service": "test",
+            "fiware-servicepath": "/"},
+        json={
+            "access_to": "resource",
+            "resource_type": "entity",
+            "mode": ["acl:Read"],
+            "agent": ["foaf:Agent"]})
+    assert response.status_code == 201
+
+    response = client.get(
+        "/v1/policies/me",
+        headers={
+            "fiware-service": "test",
+            "fiware-servicepath": "/"})
+    assert response.status_code == 200
+    body = response.json()
+    assert len(body) == 2
```

## anubis/tests/test_rdf_parsing.py

```diff
@@ -34,15 +34,15 @@
         headers={
             "accept": "text/turtle",
             "fiware-service": "Tenant1",
             "fiware-servicepath": "/"})
     assert response.status_code == 200
     g = Graph()
     g.parse(data=response.text)
-    assert len(g) == 25
+    assert len(g) == 29
 
     response = client.get(
         "/v1/policies/",
         headers={
             "fiware-service": "Tenant1",
             "fiware-servicepath": "/"})
 
@@ -61,17 +61,20 @@
     g = Graph()
     g.parse(data=response.text)
     for subj, pred, obj in g:
         if URIRef("http://www.w3.org/ns/auth/acl#accessTo") == pred:
             assert URIRef(
                 "https://tenant1.orion.url/v2/entities/test") == obj
         elif URIRef("http://www.w3.org/ns/auth/acl#agentClass") == pred:
-            assert URIRef("acl:agent:Gina@mail.com") == obj
+            assert URIRef("acl:agent:Gina") == obj
         elif URIRef("http://www.w3.org/ns/auth/acl#mode") == pred:
             assert URIRef("acl:Read") == obj
+        elif URIRef("http://xmlns.com/foaf/0.1/mbox") == pred:
+            assert subj == URIRef("acl:agent:Gina")
+            assert obj == Literal("Gina@mail.com")
 
     response = client.post(
         "/v1/policies/",
         headers={
             "fiware-service": "Tenant1",
             "fiware-servicepath": "/"},
         json={
```

## Comparing `anubis_policy_api-0.6.0.dist-info/METADATA` & `anubis_policy_api-0.7.0.dev0.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,53 +1,53 @@
 Metadata-Version: 2.1
 Name: anubis-policy-api
-Version: 0.6.0
+Version: 0.7.0.dev0
 Summary: The main module of anubis
 Home-page: https://github.com/orchestracities/anubis
 Author: Martel-Innovate
 Author-email: gabriele.cerfoglio@martel-innovate.com
 Project-URL: Bug Reports, https://github.com/orchestracities/anubis/issues
 Project-URL: Source, https://github.com/orchestracities/anubis
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Programming Language :: Python :: 3.9
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 Requires-Dist: aiosqlite (==0.17.0)
 Requires-Dist: asn1crypto (==1.5.1)
-Requires-Dist: certifi (==2021.10.8)
-Requires-Dist: databases (==0.5.5)
-Requires-Dist: fastapi (==0.73.0)
+Requires-Dist: certifi (==2022.12.7)
+Requires-Dist: databases (==0.6.0)
+Requires-Dist: fastapi (==0.78.0)
 Requires-Dist: isodate (==0.6.1)
-Requires-Dist: opa-python-client (==1.0.4)
-Requires-Dist: pg8000 (==1.26.1)
+Requires-Dist: opa-python-client (==1.3.3)
+Requires-Dist: pg8000 (==1.29.1)
 Requires-Dist: pydantic (==1.9.0)
-Requires-Dist: pyjwt (==2.3.0)
+Requires-Dist: pyjwt (==2.4.0)
 Requires-Dist: pyyaml (==6.0)
 Requires-Dist: rdflib (==6.1.1)
 Requires-Dist: rfc3987 (==1.3.8)
 Requires-Dist: sqlalchemy (==1.4.36)
 Requires-Dist: urllib3 (==1.26.9)
 Requires-Dist: user-agent (==0.1.10)
 Requires-Dist: uuid (==1.30)
-Requires-Dist: uvicorn (==0.17.6)
+Requires-Dist: uvicorn (==0.18.1)
 Requires-Dist: anyio (==3.5.0) ; python_full_version >= "3.6.2"
 Requires-Dist: pyparsing (==3.0.8) ; python_full_version >= "3.6.8"
 Requires-Dist: six (==1.16.0) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3"
-Requires-Dist: requests (==2.27.1) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3, 3.4, 3.5"
+Requires-Dist: requests (==2.28.1) ; python_version >= "2.7" and python_version not in "3.0, 3.1, 3.2, 3.3, 3.4, 3.5"
 Requires-Dist: charset-normalizer (==2.0.12) ; python_version >= "3"
 Requires-Dist: greenlet (==1.1.2) ; python_version >= "3" and platform_machine == "aarch64" or (platform_machine == "ppc64le" or (platform_machine == "x86_64" or (platform_machine == "amd64" or (platform_machine == "AMD64" or (platform_machine == "win32" or platform_machine == "WIN32")))))
 Requires-Dist: idna (==3.3) ; python_version >= "3.5"
 Requires-Dist: sniffio (==1.2.0) ; python_version >= "3.5"
 Requires-Dist: h11 (==0.13.0) ; python_version >= "3.6"
 Requires-Dist: scramp (==1.4.1) ; python_version >= "3.6"
-Requires-Dist: starlette (==0.17.1) ; python_version >= "3.6"
+Requires-Dist: starlette (==0.25.0) ; python_version >= "3.6"
 Requires-Dist: asgiref (==3.5.1) ; python_version >= "3.7"
 Requires-Dist: click (==8.1.3) ; python_version >= "3.7"
-Requires-Dist: setuptools (==62.1.0) ; python_version >= "3.7"
+Requires-Dist: setuptools (==65.5.1) ; python_version >= "3.7"
 Requires-Dist: typing-extensions (==4.2.0) ; python_version >= "3.7"
 Provides-Extra: dev
 
 
 This package contains the Anubis Policy Management API. For more information,
 visit the [Github Page](https://github.com/orchestracities/anubis).
```

## Comparing `anubis_policy_api-0.6.0.dist-info/RECORD` & `anubis_policy_api-0.7.0.dev0.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 anubis/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 anubis/config.py,sha256=la9J1AkjIMWqsLNqOU2yFCreO1BReCdwx8hBv1_CuN0,31
 anubis/database.py,sha256=pEDRrMiE4cHTChH7KNCR2L04mTceS6ByhNZ2XL4UbUU,1027
 anubis/default.py,sha256=M6hO3yyyNZC4Z34-ZQmRYakrWXvtBuMGi9xIoGW2ikE,942
 anubis/dependencies.py,sha256=EExw0vQymhVyn7hIYrerzJSnqGt8TwoBnUE9uB9cIaM,153
-anubis/main.py,sha256=Jbz1mNTOtTl1YEXzk8JmW5LoWcY-yFdrJZRXOWkaTag,2966
-anubis/rego.py,sha256=uszMW01ikrYFnk57puKX5PZL_6QA0O5d3UEZBWFGzoY,3095
+anubis/main.py,sha256=VcqPyz7_pU42vnasyfr_il_x5RVLXfyZ7R4tHv8niNg,3269
+anubis/rego.py,sha256=-wdRBdBoNffJHpONCdeWRJyQB-_opVjTbai9jlNWOMA,3087
 anubis/utils.py,sha256=_Z_io2528rfbmR2BrY0RztUoZG8IgQmTvsp5j5uMzbE,1197
-anubis/version.py,sha256=YRN53JXmi0n1_oBzIAe6EWTmQxXS3b21VPP4tbcewuU,25
-anubis/wac.py,sha256=3n1CTERHEbsMATGWOhQ7gVZFzyz6UmyzsER_1jHhtjw,4325
+anubis/version.py,sha256=AntOXyoUBxDKrwmoZGI7Mw3NZ7UAmKmHx615iFbEP-8,29
+anubis/wac.py,sha256=WXpy48pzhdY-3khpu42muCGice977q5nhfT_TssIt7U,4757
 anubis/audit/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-anubis/audit/models.py,sha256=xUfSbwsQSArWB2pXQxnVlTJh6Vc_fXDlM_ygAL6l3ko,1006
+anubis/audit/models.py,sha256=pbXcpaOTzAuPMq83LKFpBWFzsU9xVFDV4Bdb0yEtrdQ,1074
 anubis/audit/operations.py,sha256=dLxU8yvzwXik0-_rP9gUN_hmOQQ9C6rMeM53YbjzT-4,3147
 anubis/audit/routers.py,sha256=YFjzTdSMGG2CgMhHKsrCiWr5mhZA5NRaoP7-y8fdC74,11086
 anubis/audit/schemas.py,sha256=OXHzzdReILpRQhlBU2lj0GokI5dCLD7UvjLFTCFF2a4,908
 anubis/middleware/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 anubis/middleware/operations.py,sha256=qVg828Y-MEcphdD9ItW_XscOxTCTcbjwn2OYTZVDREE,2239
-anubis/middleware/routers.py,sha256=cdvQbPCMIJJTzUrRxXntBuoORL3-tRHV0QwfwH72PXs,11383
+anubis/middleware/routers.py,sha256=Tck0tEsxRUCQnw2TRFL9Qi41oJU64amPQQ2dZyT-mI0,11401
 anubis/middleware/schemas.py,sha256=RlhqIyEv2CF_PZc-VaUP0-C0sZ4mMNGSrbtZSiiED1Y,257
 anubis/policies/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-anubis/policies/models.py,sha256=6lsgygWqK1LYVmR45p03ZLos5Lm8h2VXbQJVZLANGL0,3348
-anubis/policies/operations.py,sha256=or0KdMpNNXEl1HrOBMwPc3zWwPqfI_pyBo4sk0SBn9M,10697
-anubis/policies/routers.py,sha256=Nw0NLLChYm2bop8_SDrEIbE11mbacHP4IZ2FSO-zsfA,24882
+anubis/policies/models.py,sha256=NLcPrBHIdUOH6Q_AzX2KBmfN_ebX2CqPTyUHStJ9avw,4792
+anubis/policies/operations.py,sha256=zPh1xj6PV3SS0kYUWZIgjoOqOJxbjd0jXUTFaxqF3N0,11111
+anubis/policies/routers.py,sha256=UacQKBFajF-61czszDcyeoRm3JdGa5Ag21m7HhDjC_s,26422
 anubis/policies/schemas.py,sha256=Li97hMtw12n-kDp-3MMtj_ZmFZAExlFAQOWMzQp3rNw,2561
 anubis/tenants/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-anubis/tenants/models.py,sha256=z55t5mviGlCTj57WHzQlZHvSR5EXMV65c0loGrLl3eo,1715
-anubis/tenants/operations.py,sha256=NK3vOIPtP9fbbI5qYoNkMSmzT2yRksLFD1W3QvyVJDA,4995
-anubis/tenants/routers.py,sha256=3aaAkVlURehrPK4VzjVgLok1r90c_2aB8XiL7K5Ht54,14454
+anubis/tenants/models.py,sha256=AK468gfGXQIinoZuK8U2U7qjnzrtvNW8EVnOvNbUVJY,1783
+anubis/tenants/operations.py,sha256=aQlafnaMHD1YWqq6j7DDruTThhFEB0psmx-W29NxRWw,5252
+anubis/tenants/routers.py,sha256=LgHP3KgvGadxINv1hcqaQ3t4-VsaT6i2CUEoX7W8AXI,15428
 anubis/tenants/schemas.py,sha256=3J1rTDpCOnjTsuONmc3YSoIshjoqMC93kjZGNLfzdCg,1622
 anubis/tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 anubis/tests/test_api.py,sha256=1rZOhIqPiJ9pz1tYE6o98rjc26Nsl8-PlvB3OKzyyB8,601
 anubis/tests/test_audit.py,sha256=MUjF7fNEi_7POTVOmdLBHSgCP1t56N0vOoqZuBgxSPw,5608
-anubis/tests/test_policies.py,sha256=voA6F6nDsYp02niIJ-939rUqPLO_kD0Tqr2mFRf-qdI,9394
-anubis/tests/test_rdf_parsing.py,sha256=BT36P8V0t9ttY3QY5FHCozHFYQhZxdbx3hcDli1G9Bs,5553
+anubis/tests/test_policies.py,sha256=9iSEFWr4Yk56tSqFSzIqqpV8K6NWmZ0WG9XH2hi1AhU,10232
+anubis/tests/test_rdf_parsing.py,sha256=_tQhrBX0oaBswAXOaTzMOWVtE6yA2GUqkrtipndawyE,5710
 anubis/tests/test_tenants.py,sha256=R8irI_WJp1kSpDBf7OJ0efQRrZXFKm2qMFoKq6WALgY,2664
 anubis/tests/utils.py,sha256=M46h85qrdKUeoQFJhEm4HtCQAgFByJ1ZQNJCT5gzDrE,315
-anubis_policy_api-0.6.0.dist-info/METADATA,sha256=RSJ1mm2HHjNnJx7iTSoPGTwNzQagdIIcz4fSvHeCpN0,2674
-anubis_policy_api-0.6.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-anubis_policy_api-0.6.0.dist-info/top_level.txt,sha256=jY412krLfMbYy9L4BFs-Gg794KeAh37OQ9pj3R7jH50,7
-anubis_policy_api-0.6.0.dist-info/RECORD,,
+anubis_policy_api-0.7.0.dev0.dist-info/METADATA,sha256=Lb-976Sqr4rjhOPaQkRkM2fcRPZ8cJktjF7__XvIRZg,2679
+anubis_policy_api-0.7.0.dev0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+anubis_policy_api-0.7.0.dev0.dist-info/top_level.txt,sha256=jY412krLfMbYy9L4BFs-Gg794KeAh37OQ9pj3R7jH50,7
+anubis_policy_api-0.7.0.dev0.dist-info/RECORD,,
```

