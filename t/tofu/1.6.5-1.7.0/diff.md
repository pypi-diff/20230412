# Comparing `tmp/tofu-1.6.5.tar.gz` & `tmp/tofu-1.7.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "tofu-1.6.5.tar", last modified: Thu Dec  8 09:40:03 2022, max compression
+gzip compressed data, was "tofu-1.7.0.tar", last modified: Wed Apr 12 13:21:56 2023, max compression
```

## Comparing `tofu-1.6.5.tar` & `tofu-1.7.0.tar`

### file list

```diff
@@ -1,607 +1,606 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.198371 tofu-1.6.5/
--rw-r--r--   0 runner    (1001) docker     (123)     1071 2022-12-08 09:39:30.000000 tofu-1.6.5/LICENSE.txt
--rw-r--r--   0 runner    (1001) docker     (123)      628 2022-12-08 09:39:30.000000 tofu-1.6.5/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)    12222 2022-12-08 09:40:03.198371 tofu-1.6.5/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    11453 2022-12-08 09:39:30.000000 tofu-1.6.5/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      966 2022-12-08 09:39:30.000000 tofu-1.6.5/_updateversion.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.014369 tofu-1.6.5/inputs_temp/
--rw-r--r--   0 runner    (1001) docker     (123)   119375 2022-12-08 09:39:31.000000 tofu-1.6.5/inputs_temp/XICS_allshots_C34.py
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/inputs_temp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    37619 2022-12-08 09:39:32.000000 tofu-1.6.5/inputs_temp/dlines.py
--rw-r--r--   0 runner    (1001) docker     (123)      147 2022-12-08 09:39:32.000000 tofu-1.6.5/pyproject.toml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.014369 tofu-1.6.5/scripts/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/scripts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    19395 2022-12-08 09:39:32.000000 tofu-1.6.5/scripts/_dparser.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     3731 2022-12-08 09:39:32.000000 tofu-1.6.5/scripts/tofu_bash.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     2794 2022-12-08 09:39:32.000000 tofu-1.6.5/scripts/tofucustom.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     3643 2022-12-08 09:39:32.000000 tofu-1.6.5/scripts/tofuversion.py
--rw-r--r--   0 runner    (1001) docker     (123)       38 2022-12-08 09:40:03.198371 tofu-1.6.5/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)    13006 2022-12-08 09:39:32.000000 tofu-1.6.5/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.018369 tofu-1.6.5/tofu/
--rw-r--r--   0 runner    (1001) docker     (123)     3069 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1513 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/_physics.py
--rw-r--r--   0 runner    (1001) docker     (123)    12571 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/_plot.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.022369 tofu-1.6.5/tofu/benchmarks/
--rw-r--r--   0 runner    (1001) docker     (123)      306 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5642 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/benchmarks_00_Geometry_peakmem.py
--rw-r--r--   0 runner    (1001) docker     (123)     5615 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/benchmarks_00_Geometry_time.py
--rw-r--r--   0 runner    (1001) docker     (123)     3032 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/benchmarks_01_Mesh2D_peakmem.py
--rw-r--r--   0 runner    (1001) docker     (123)     3023 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/benchmarks_01_Mesh2D_time.py
--rw-r--r--   0 runner    (1001) docker     (123)     6733 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/benchmarks_02_spectralfit_peakmem.py
--rw-r--r--   0 runner    (1001) docker     (123)     6724 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/benchmarks_02_spectralfit_time.py
--rw-r--r--   0 runner    (1001) docker     (123)     3385 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/benchmarks/benchmarks_03_solidangles.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.042369 tofu-1.6.5/tofu/data/
--rw-r--r--   0 runner    (1001) docker     (123)    48566 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_check_inputs.py
--rw-r--r--   0 runner    (1001) docker     (123)       86 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_class.py
--rw-r--r--   0 runner    (1001) docker     (123)    38199 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_class0_Base.py
--rw-r--r--   0 runner    (1001) docker     (123)    40664 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_class1_interactivity.py
--rw-r--r--   0 runner    (1001) docker     (123)    13459 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_comp.py
--rw-r--r--   0 runner    (1001) docker     (123)     4798 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_interactivity.py
--rw-r--r--   0 runner    (1001) docker     (123)    40405 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_plot_as_array.py
--rw-r--r--   0 runner    (1001) docker     (123)    10419 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_plot_misc.py
--rw-r--r--   0 runner    (1001) docker     (123)     3114 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_DataCollection_plot_text.py
--rw-r--r--   0 runner    (1001) docker     (123)      331 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      650 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class00_Config.py
--rw-r--r--   0 runner    (1001) docker     (123)    39984 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class01_Plasma2D.py
--rw-r--r--   0 runner    (1001) docker     (123)     9238 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class02_Rays.py
--rw-r--r--   0 runner    (1001) docker     (123)     2994 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class03_Aperture.py
--rw-r--r--   0 runner    (1001) docker     (123)     2222 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class04_Filter.py
--rw-r--r--   0 runner    (1001) docker     (123)     6681 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class05_Crystal.py
--rw-r--r--   0 runner    (1001) docker     (123)     2141 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class06_Grating.py
--rw-r--r--   0 runner    (1001) docker     (123)     7802 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class07_Camera.py
--rw-r--r--   0 runner    (1001) docker     (123)    16132 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class08_Diagnostic.py
--rw-r--r--   0 runner    (1001) docker     (123)     2660 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class09_GeometryMatrix.py
--rw-r--r--   0 runner    (1001) docker     (123)     3894 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class10_Inversion.py
--rw-r--r--   0 runner    (1001) docker     (123)    21320 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class10_algos.py
--rw-r--r--   0 runner    (1001) docker     (123)    38522 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class10_checks.py
--rw-r--r--   0 runner    (1001) docker     (123)    28203 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class10_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)    21333 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class10_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)    37935 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_bsplines_operators_rect.py
--rw-r--r--   0 runner    (1001) docker     (123)    35304 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_bsplines_operators_tri.py
--rw-r--r--   0 runner    (1001) docker     (123)    24396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_bsplines_polar.py
--rw-r--r--   0 runner    (1001) docker     (123)    11347 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_bsplines_rect.py
--rw-r--r--   0 runner    (1001) docker     (123)    17756 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_bsplines_tri.py
--rw-r--r--   0 runner    (1001) docker     (123)    45656 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_checks.py
--rw-r--r--   0 runner    (1001) docker     (123)    92505 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)    40212 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class1_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)    24026 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class2_check.py
--rw-r--r--   0 runner    (1001) docker     (123)    23436 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class2_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)     5693 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class2_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)     6703 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class3_check.py
--rw-r--r--   0 runner    (1001) docker     (123)     4038 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class4_check.py
--rw-r--r--   0 runner    (1001) docker     (123)     3792 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class5_check.py
--rw-r--r--   0 runner    (1001) docker     (123)    18346 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class5_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)     3468 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class5_coordinates.py
--rw-r--r--   0 runner    (1001) docker     (123)     4719 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class5_projections.py
--rw-r--r--   0 runner    (1001) docker     (123)    25289 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class5_reflections_pts2pt.py
--rw-r--r--   0 runner    (1001) docker     (123)    20799 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class5_reflections_ptsvect.py
--rw-r--r--   0 runner    (1001) docker     (123)    22498 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class7_check.py
--rw-r--r--   0 runner    (1001) docker     (123)    10993 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class7_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)    14726 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_check.py
--rw-r--r--   0 runner    (1001) docker     (123)    41652 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)    12011 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_compute_signal.py
--rw-r--r--   0 runner    (1001) docker     (123)    18330 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_equivalent_apertures.py
--rw-r--r--   0 runner    (1001) docker     (123)    27018 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_etendue_los.py
--rw-r--r--   0 runner    (1001) docker     (123)     3735 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_los_angles.py
--rw-r--r--   0 runner    (1001) docker     (123)    13062 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_los_data.py
--rw-r--r--   0 runner    (1001) docker     (123)    12110 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_move.py
--rw-r--r--   0 runner    (1001) docker     (123)    19358 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class8_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)    12079 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class9_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)    16402 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_class9_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)    26948 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_comp.py
--rw-r--r--   0 runner    (1001) docker     (123)   178524 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_core.py
--rw-r--r--   0 runner    (1001) docker     (123)    11590 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_core_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)      357 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_def.py
--rw-r--r--   0 runner    (1001) docker     (123)     1606 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_generic_check.py
--rw-r--r--   0 runner    (1001) docker     (123)     8088 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_generic_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)   145080 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)     9358 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_spectrallines_checks.py
--rw-r--r--   0 runner    (1001) docker     (123)    18950 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_spectrallines_class.py
--rw-r--r--   0 runner    (1001) docker     (123)    14734 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_spectrallines_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)    14023 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_spectrallines_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)     9643 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_utils_bsplines.py
--rw-r--r--   0 runner    (1001) docker     (123)    11288 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/data/_utils_surface3d.py
--rw-r--r--   0 runner    (1001) docker     (123)    58540 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/defaults.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.046369 tofu-1.6.5/tofu/dumpro/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dumpro/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)       56 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dumpro/_comp.py
--rw-r--r--   0 runner    (1001) docker     (123)       50 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dumpro/_comp_clusters.py
--rw-r--r--   0 runner    (1001) docker     (123)      553 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dumpro/_core.py
--rw-r--r--   0 runner    (1001) docker     (123)       21 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dumpro/_def.py
--rw-r--r--   0 runner    (1001) docker     (123)       31 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dumpro/_draft.py
--rw-r--r--   0 runner    (1001) docker     (123)       58 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dumpro/_plot.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.046369 tofu-1.6.5/tofu/dust/
--rw-r--r--   0 runner    (1001) docker     (123)      123 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dust/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1950 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dust/_comp.py
--rw-r--r--   0 runner    (1001) docker     (123)     5472 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dust/_core.py
--rw-r--r--   0 runner    (1001) docker     (123)      906 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/dust/_plot.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.050369 tofu-1.6.5/tofu/entrypoints/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/entrypoints/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      913 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/entrypoints/_def.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     3237 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/entrypoints/tofucalc.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     3096 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/entrypoints/tofuplot.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.058369 tofu-1.6.5/tofu/geom/
--rw-r--r--   0 runner    (1001) docker     (123)   259311 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_GG.pyx
--rw-r--r--   0 runner    (1001) docker     (123)      508 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4611 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_basic_geom_tools.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    13775 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_basic_geom_tools.pyx
--rw-r--r--   0 runner    (1001) docker     (123)      502 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_chained_list.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2449 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_chained_list.pyx
--rw-r--r--   0 runner    (1001) docker     (123)    24082 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_check_optics.py
--rw-r--r--   0 runner    (1001) docker     (123)    45525 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_comp.py
--rw-r--r--   0 runner    (1001) docker     (123)    40687 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_comp_optics.py
--rw-r--r--   0 runner    (1001) docker     (123)    43304 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_comp_solidangles.py
--rw-r--r--   0 runner    (1001) docker     (123)   289844 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_core.py
--rw-r--r--   0 runner    (1001) docker     (123)   148251 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_core_optics.py
--rw-r--r--   0 runner    (1001) docker     (123)    25215 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_def.py
--rw-r--r--   0 runner    (1001) docker     (123)    11128 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_def_config.py
--rw-r--r--   0 runner    (1001) docker     (123)     7563 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_distance_tools.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    62742 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_distance_tools.pyx
--rw-r--r--   0 runner    (1001) docker     (123)    28576 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_etendue.py
--rw-r--r--   0 runner    (1001) docker     (123)     2167 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_openmp_tools.pyx
--rw-r--r--   0 runner    (1001) docker     (123)    69100 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)    62482 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_plot_optics.py
--rw-r--r--   0 runner    (1001) docker     (123)    18069 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_raytracing_tools.pxd
--rw-r--r--   0 runner    (1001) docker     (123)   118812 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_raytracing_tools.pyx
--rw-r--r--   0 runner    (1001) docker     (123)    14136 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_sampling_tools.pxd
--rw-r--r--   0 runner    (1001) docker     (123)   115661 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_sampling_tools.pyx
--rw-r--r--   0 runner    (1001) docker     (123)      371 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_sorted_set.pxd
--rw-r--r--   0 runner    (1001) docker     (123)     2262 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_sorted_set.pyx
--rw-r--r--   0 runner    (1001) docker     (123)     4156 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_vignetting_tools.pxd
--rw-r--r--   0 runner    (1001) docker     (123)    26377 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/_vignetting_tools.pyx
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.134370 tofu-1.6.5/tofu/geom/inputs/
--rw-r--r--   0 runner    (1001) docker     (123)     1609 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/AUG_V0_from_V1.py
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS1L.txt
--rw-r--r--   0 runner    (1001) docker     (123)      292 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS1U.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS2L.txt
--rw-r--r--   0 runner    (1001) docker     (123)      292 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS2U.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS3L.txt
--rw-r--r--   0 runner    (1001) docker     (123)      292 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS3U.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS1lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS1upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS2lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS2upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS3lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS3upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF4.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF5.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF6.txt
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_CentralSolenoid.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil01.txt
--rw-r--r--   0 runner    (1001) docker     (123)      346 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil02.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil03.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil04.txt
--rw-r--r--   0 runner    (1001) docker     (123)      396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil05.txt
--rw-r--r--   0 runner    (1001) docker     (123)      396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil06.txt
--rw-r--r--   0 runner    (1001) docker     (123)      396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil07.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil08.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil09.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil10.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil11.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil12.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil13.txt
--rw-r--r--   0 runner    (1001) docker     (123)      396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil14.txt
--rw-r--r--   0 runner    (1001) docker     (123)      396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil16.txt
--rw-r--r--   0 runner    (1001) docker     (123)      396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil17.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil18.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil19.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil20.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil21.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil22.txt
--rw-r--r--   0 runner    (1001) docker     (123)      302 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div1lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      298 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div1upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      302 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div2lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      298 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div2upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      302 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFClower0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      302 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFClower1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCmed0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      300 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCmed1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2448 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCupper0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      298 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCupper1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF1lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF1upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF2lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF2upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF3lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF3upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF4lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF4upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VS1lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VS1upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      665 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlatelower.txt
--rw-r--r--   0 runner    (1001) docker     (123)      654 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlateupper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      293 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_A001.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B001.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B002.txt
--rw-r--r--   0 runner    (1001) docker     (123)      959 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      908 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      908 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_C001.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_C002.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_D001.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_D002.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E001.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E002.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E003.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E004.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E005.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E006.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E007.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E008.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1520 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      294 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A2.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1542 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F001.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F002.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F003.txt
--rw-r--r--   0 runner    (1001) docker     (123)      295 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F004.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F005.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F006.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F007.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F008.txt
--rw-r--r--   0 runner    (1001) docker     (123)      942 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      892 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      892 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      293 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_BlV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      289 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_BuV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      291 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_CSV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      604 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow1V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      604 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow2V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      593 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp1V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      593 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp2V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      293 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DlV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      289 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DuV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      293 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_ElV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      289 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_EuV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      293 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_FlV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      289 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_FuV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      319 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cTPi.txt
--rw-r--r--   0 runner    (1001) docker     (123)      395 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cTPib.txt
--rw-r--r--   0 runner    (1001) docker     (123)      230 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cTPic.txt
--rw-r--r--   0 runner    (1001) docker     (123)      260 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cdomL.txt
--rw-r--r--   0 runner    (1001) docker     (123)      260 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cdomR.txt
--rw-r--r--   0 runner    (1001) docker     (123)      260 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cdome.txt
--rw-r--r--   0 runner    (1001) docker     (123)      228 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2ci1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      198 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2ci2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      469 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBG2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      244 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBl1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      259 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBl2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      244 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBl3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      379 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      214 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      214 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      168 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu4.txt
--rw-r--r--   0 runner    (1001) docker     (123)      348 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D3BG1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      334 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_D3BG10.txt
--rw-r--r--   0 runner    (1001) docker     (123)      963 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_ICRHa.txt
--rw-r--r--   0 runner    (1001) docker     (123)      167 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_LIM09.txt
--rw-r--r--   0 runner    (1001) docker     (123)      137 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_PClow.txt
--rw-r--r--   0 runner    (1001) docker     (123)      136 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_PCup.txt
--rw-r--r--   0 runner    (1001) docker     (123)      675 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_SBi.txt
--rw-r--r--   0 runner    (1001) docker     (123)      303 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      228 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      273 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      393 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT4.txt
--rw-r--r--   0 runner    (1001) docker     (123)      378 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT5.txt
--rw-r--r--   0 runner    (1001) docker     (123)      483 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT2.txt
--rw-r--r--   0 runner    (1001) docker     (123)      258 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      228 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT4.txt
--rw-r--r--   0 runner    (1001) docker     (123)      288 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT5.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2819 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_inner.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3969 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_lower.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4183 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_outer.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1693 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_upper.txt
--rw-r--r--   0 runner    (1001) docker     (123)    42519 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketInnerV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    73640 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketOuterV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    35568 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_DivertorV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    26260 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterEquatV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    26204 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterUpperV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1305 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK01.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1305 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK02.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1302 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK03.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1299 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK04.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1299 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK05.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1299 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK06.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1399 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK07.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1499 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK08.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1449 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK09.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1248 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK10.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2107 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK11.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2107 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK12.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2107 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK13.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1198 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK14.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1200 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK15.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2111 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK16.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2111 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK17.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2111 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK18.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6691 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3376 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div2.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5875 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div3.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3325 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div4.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5875 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div5.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5468 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div6.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5468 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div7.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2349 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter01.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2299 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter02.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2299 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter03.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2249 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter04.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2248 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorLower.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2298 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorUpper.txt
--rw-r--r--   0 runner    (1001) docker     (123)      546 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_ICRFAntenna.txt
--rw-r--r--   0 runner    (1001) docker     (123)    21699 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter01.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4149 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter02.txt
--rw-r--r--   0 runner    (1001) docker     (123)      344 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path69778.txt
--rw-r--r--   0 runner    (1001) docker     (123)      294 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path69912.txt
--rw-r--r--   0 runner    (1001) docker     (123)      444 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path69980.txt
--rw-r--r--   0 runner    (1001) docker     (123)      794 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70015.txt
--rw-r--r--   0 runner    (1001) docker     (123)      694 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70085.txt
--rw-r--r--   0 runner    (1001) docker     (123)      394 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70153.txt
--rw-r--r--   0 runner    (1001) docker     (123)      697 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpSPARC_ICRH0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3173 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpTOMAS_AntennaV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3224 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpTOMAS_LimiterV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      756 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1674 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)    13188 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV2.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1158 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2067 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5298 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV2.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5904 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      956 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1764 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4793 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV2.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4943 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV3.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1479 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverLDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1402 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverUDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4018 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingLDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      564 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateLDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      555 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateUDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4530 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJLDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4455 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJUDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4053 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingUDivV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      299 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      452 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      911 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV2.txt
--rw-r--r--   0 runner    (1001) docker     (123)    23939 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      709 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2443 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     7696 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV2.txt
--rw-r--r--   0 runner    (1001) docker     (123)    30724 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV3.txt
--rw-r--r--   0 runner    (1001) docker     (123)      292 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      342 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      492 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV2.txt
--rw-r--r--   0 runner    (1001) docker     (123)    23520 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV3.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2159 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6553 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2159 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6553 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2161 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6555 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2161 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6555 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2161 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6555 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      645 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      795 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1819 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldHFSV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6424 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSLowV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    20508 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSSlimV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6311 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSUpV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    20508 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSWideV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1502 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_VDEV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    50500 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_PlasmaDomain_ExpWEST_Sep.txt
--rw-r--r--   0 runner    (1001) docker     (123)    15855 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpAUG_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      588 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpAUG_VESiR.txt
--rw-r--r--   0 runner    (1001) docker     (123)     8374 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpCOMPASS2_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2720 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_InnerV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)    11775 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    84216 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpDEMO2019_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      897 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_Cryostat.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6909 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_InnerV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     7717 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_OuterV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    28016 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5235 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)    12614 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpJET_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1401 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpKSTAR_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      542 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpMAST_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6905 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpNSTX_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1296 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpNSTX_VesselInner.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3278 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFInner.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3782 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFOuter.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2521 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_FirstWallV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      902 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesInner.txt
--rw-r--r--   0 runner    (1001) docker     (123)      801 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesOuter.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2973 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTCV_t.txt
--rw-r--r--   0 runner    (1001) docker     (123)    12964 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTCV_vIn.txt
--rw-r--r--   0 runner    (1001) docker     (123)    12966 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTCV_vOut.txt
--rw-r--r--   0 runner    (1001) docker     (123)    10192 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTOMAS_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    29937 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_InnerV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)    31654 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_OuterV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2670 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3227 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3071 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV2.txt
--rw-r--r--   0 runner    (1001) docker     (123)    11599 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/WEST_get_details_from_excel.py
--rwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2491 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/inputs/get_geom_TCV.py
--rw-r--r--   0 runner    (1001) docker     (123)      181 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu/geom/openmp_enabled.py
--rw-r--r--   0 runner    (1001) docker     (123)    46718 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/geom/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.134370 tofu-1.6.5/tofu/imas2tofu/
--rw-r--r--   0 runner    (1001) docker     (123)     3301 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/imas2tofu/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    26569 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/imas2tofu/_comp.py
--rw-r--r--   0 runner    (1001) docker     (123)     7109 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/imas2tofu/_comp_mesh.py
--rw-r--r--   0 runner    (1001) docker     (123)    48066 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/imas2tofu/_comp_toobjects.py
--rw-r--r--   0 runner    (1001) docker     (123)   138425 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/imas2tofu/_core.py
--rw-r--r--   0 runner    (1001) docker     (123)    42308 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/imas2tofu/_def.py
--rw-r--r--   0 runner    (1001) docker     (123)     7691 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/imas2tofu/_mat2ids2calc.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.138370 tofu-1.6.5/tofu/mag/
--rw-r--r--   0 runner    (1001) docker     (123)     1160 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    29557 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/equimap.py
--rw-r--r--   0 runner    (1001) docker     (123)    23137 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/magFieldLines.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.138370 tofu-1.6.5/tofu/mag/mag_ripple/
--rw-r--r--   0 runner    (1001) docker     (123)      475 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/mag_ripple/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (123)      520 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/mag_ripple/compile_f2py.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)     3482 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/mag_ripple/mag_ripple.f
--rw-r--r--   0 runner    (1001) docker     (123)    11158 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/regression_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    11334 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/test_equimap.py
--rw-r--r--   0 runner    (1001) docker     (123)      588 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/test_magFieldLines.py
--rw-r--r--   0 runner    (1001) docker     (123)    15899 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/mag/test_ripple.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.138370 tofu-1.6.5/tofu/nist2tofu/
--rw-r--r--   0 runner    (1001) docker     (123)      388 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/nist2tofu/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    27712 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/nist2tofu/_requests.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.138370 tofu-1.6.5/tofu/openadas2tofu/
--rw-r--r--   0 runner    (1001) docker     (123)      503 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/openadas2tofu/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    35701 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/openadas2tofu/_read_files.py
--rw-r--r--   0 runner    (1001) docker     (123)    24831 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/openadas2tofu/_requests.py
--rw-r--r--   0 runner    (1001) docker     (123)    72466 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/pathfile.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.142370 tofu-1.6.5/tofu/spectro/
--rw-r--r--   0 runner    (1001) docker     (123)      206 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    18789 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_analysis_tools.py
--rw-r--r--   0 runner    (1001) docker     (123)    52853 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_fit12d.py
--rw-r--r--   0 runner    (1001) docker     (123)    28897 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_fit12d_dextract.py
--rw-r--r--   0 runner    (1001) docker     (123)    94177 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_fit12d_dinput.py
--rw-r--r--   0 runner    (1001) docker     (123)    25979 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_fit12d_funccostjac.py
--rw-r--r--   0 runner    (1001) docker     (123)    72085 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_plot.py
--rw-r--r--   0 runner    (1001) docker     (123)    68586 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_rockingcurve.py
--rw-r--r--   0 runner    (1001) docker     (123)    15578 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/spectro/_rockingcurve_def.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.142370 tofu-1.6.5/tofu/tests/
--rw-r--r--   0 runner    (1001) docker     (123)      297 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.142370 tofu-1.6.5/tofu/tests/tests00_root/
--rw-r--r--   0 runner    (1001) docker     (123)       29 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests00_root/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4570 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests00_root/test_03_plot.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.146370 tofu-1.6.5/tofu/tests/tests01_geom/
--rw-r--r--   0 runner    (1001) docker     (123)      184 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    76941 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_01_GG.py
--rw-r--r--   0 runner    (1001) docker     (123)     5832 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_02_compute.py
--rw-r--r--   0 runner    (1001) docker     (123)   125420 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_03_core.py
--rw-r--r--   0 runner    (1001) docker     (123)    14230 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_04_core_optics.py
--rw-r--r--   0 runner    (1001) docker     (123)    16675 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_04_sampling.py
--rw-r--r--   0 runner    (1001) docker     (123)    19047 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_05_solid_angles.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.158370 tofu-1.6.5/tofu/tests/tests01_geom/test_data/
--rw-r--r--   0 runner    (1001) docker     (123)   218404 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/Inkscape.svg
--rw-r--r--   0 runner    (1001) docker     (123)      202 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilCS_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      204 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Bl_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      200 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Bu_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      510 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivLow1_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      510 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivLow2_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      500 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivUp1_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      500 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivUp2_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      204 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Dl_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      200 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Du_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      204 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_El_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      200 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Eu_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      204 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Fl_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      200 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Fu_V0.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)    12294 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Notes.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     3641 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)      663 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1581 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V1.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     8466 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)      758 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1667 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4898 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V2.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     9724 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)      808 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1616 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4645 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V2.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     4369 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)      204 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      357 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      816 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V2.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     5741 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)      612 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2346 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)     7599 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V2.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     2639 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)      200 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      250 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_V1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      400 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_V2.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     9803 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1969 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6363 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V1.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     9824 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1969 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6363 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V1.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     9822 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1969 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6363 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V1.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)    11884 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1969 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6363 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V1.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)    12106 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1969 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6363 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V1.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     2335 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)      250 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_V0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      400 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_V1.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     8060 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PlasmaDomain_Standard_Notes.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     1358 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)     5050 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_V0.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     1355 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_Notes.py
--rw-r--r--   0 runner    (1001) docker     (123)     5050 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_V0.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/test_data/det37_CTVD_incC4_New.npz
--rw-r--r--   0 runner    (1001) docker     (123)      534 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests01_geom/testing_tools.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.158370 tofu-1.6.5/tofu/tests/tests02_data/
--rw-r--r--   0 runner    (1001) docker     (123)       65 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests02_data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    21607 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests02_data/test_03_core.py
--rw-r--r--   0 runner    (1001) docker     (123)     4831 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests02_data/test_04_spectrallines.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.158370 tofu-1.6.5/tofu/tests/tests03_openadas/
--rw-r--r--   0 runner    (1001) docker     (123)       29 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests03_openadas/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4764 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests03_openadas/test_03_core.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.158370 tofu-1.6.5/tofu/tests/tests04_spectro/
--rw-r--r--   0 runner    (1001) docker     (123)       67 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    29371 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_01_fit12d.py
--rw-r--r--   0 runner    (1001) docker     (123)     3383 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_02_analysistools.py
--rw-r--r--   0 runner    (1001) docker     (123)     3303 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_03_rockingcurve.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.166370 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/
--rw-r--r--   0 runner    (1001) docker     (123)    54707 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/TFG_CrystalBragg_ExpWEST_DgXICS_ArXVII_sh00000_Vers1.5.0.npz
--rw-r--r--   0 runner    (1001) docker     (123)  1592000 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/UV_spectra_sh55506.npz
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    38498 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/_lines_database.py
--rw-r--r--   0 runner    (1001) docker     (123)  4287706 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/_mask_54041.npz
--rw-r--r--   0 runner    (1001) docker     (123)     5561 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/_spectral_constraints.py
--rw-r--r--   0 runner    (1001) docker     (123)     1396 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/det37_CTVD_incC4_New.npz
--rw-r--r--   0 runner    (1001) docker     (123)    43500 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/spectral_fit.npz
--rw-r--r--   0 runner    (1001) docker     (123) 23594389 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests04_spectro/test_data/west_54046_xics.npz
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.194371 tofu-1.6.5/tofu/tests/tests05_nist/
--rw-r--r--   0 runner    (1001) docker     (123)       29 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests05_nist/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2927 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests05_nist/test_03_core.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.194371 tofu-1.6.5/tofu/tests/tests06_mesh/
--rw-r--r--   0 runner    (1001) docker     (123)       31 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests06_mesh/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    24953 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests06_mesh/test_01_checks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.194371 tofu-1.6.5/tofu/tests/tests06_mesh/test_data/
--rw-r--r--   0 runner    (1001) docker     (123)   163954 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests06_mesh/test_data/ITER_JINTRAC_sh134000_run30_public_edgesources_quadtrimesh.npz
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests06_mesh/test_data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)  1584667 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests06_mesh/test_data/mesh_triangular_WEST_eq.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.194371 tofu-1.6.5/tofu/tests/tests07_inversions/
--rw-r--r--   0 runner    (1001) docker     (123)       34 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests07_inversions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7550 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests07_inversions/test_01_isotropic.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.194371 tofu-1.6.5/tofu/tests/tests08_diagnostics/
--rw-r--r--   0 runner    (1001) docker     (123)       36 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests08_diagnostics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    13585 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests08_diagnostics/test_01_diagnostics.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.194371 tofu-1.6.5/tofu/tests/tests09_tutorials/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4916 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/test_01_runall.py
--rw-r--r--   0 runner    (1001) docker     (123)     2199 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_basic.py
--rw-r--r--   0 runner    (1001) docker     (123)     6551 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_create_geometry.py
--rw-r--r--   0 runner    (1001) docker     (123)     3030 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_create_geometry_from_svg.py
--rw-r--r--   0 runner    (1001) docker     (123)     3175 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_custom_emissivity.py
--rw-r--r--   0 runner    (1001) docker     (123)     1503 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_gallery_fusion_machines.py
--rw-r--r--   0 runner    (1001) docker     (123)     3835 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_solid_angles.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.198371 tofu-1.6.5/tofu/tomotok2tofu/
--rw-r--r--   0 runner    (1001) docker     (123)      407 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tomotok2tofu/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5497 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/tomotok2tofu/_core.py
--rw-r--r--   0 runner    (1001) docker     (123)   157477 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu/utils.py
--rw-r--r--   0 runner    (1001) docker     (123)       79 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu/version.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.018369 tofu-1.6.5/tofu.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)    12222 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    24018 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)      211 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (123)      181 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       53 2022-12-08 09:40:02.000000 tofu-1.6.5/tofu.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2022-12-08 09:40:03.198371 tofu-1.6.5/tofu_helpers/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu_helpers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     5064 2022-12-08 09:39:32.000000 tofu-1.6.5/tofu_helpers/openmp_helpers.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.987346 tofu-1.7.0/
+-rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-04-12 13:21:25.000000 tofu-1.7.0/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      628 2023-04-12 13:21:25.000000 tofu-1.7.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)    12202 2023-04-12 13:21:56.987346 tofu-1.7.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    11453 2023-04-12 13:21:25.000000 tofu-1.7.0/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      966 2023-04-12 13:21:26.000000 tofu-1.7.0/_updateversion.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.903346 tofu-1.7.0/inputs_temp/
+-rw-r--r--   0 runner    (1001) docker     (123)   119375 2023-04-12 13:21:26.000000 tofu-1.7.0/inputs_temp/XICS_allshots_C34.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/inputs_temp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37619 2023-04-12 13:21:27.000000 tofu-1.7.0/inputs_temp/dlines.py
+-rw-r--r--   0 runner    (1001) docker     (123)       97 2023-04-12 13:21:27.000000 tofu-1.7.0/pyproject.toml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.903346 tofu-1.7.0/scripts/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/scripts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19395 2023-04-12 13:21:27.000000 tofu-1.7.0/scripts/_dparser.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3731 2023-04-12 13:21:27.000000 tofu-1.7.0/scripts/tofu_bash.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2794 2023-04-12 13:21:27.000000 tofu-1.7.0/scripts/tofucustom.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3643 2023-04-12 13:21:27.000000 tofu-1.7.0/scripts/tofuversion.py
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-12 13:21:56.987346 tofu-1.7.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)    13006 2023-04-12 13:21:27.000000 tofu-1.7.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.903346 tofu-1.7.0/tofu/
+-rw-r--r--   0 runner    (1001) docker     (123)     3486 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1513 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/_physics.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12571 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/_plot.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.907346 tofu-1.7.0/tofu/benchmarks/
+-rw-r--r--   0 runner    (1001) docker     (123)      306 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5642 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/benchmarks_00_Geometry_peakmem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5615 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/benchmarks_00_Geometry_time.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3032 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/benchmarks_01_Mesh2D_peakmem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3023 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/benchmarks_01_Mesh2D_time.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6733 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/benchmarks_02_spectralfit_peakmem.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6724 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/benchmarks_02_spectralfit_time.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3385 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/benchmarks/benchmarks_03_solidangles.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.915346 tofu-1.7.0/tofu/data/
+-rw-r--r--   0 runner    (1001) docker     (123)    48566 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_check_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)       86 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_class.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38199 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_class0_Base.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40664 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_class1_interactivity.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13459 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_comp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4798 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_interactivity.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40405 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_plot_as_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10419 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_plot_misc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3114 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_DataCollection_plot_text.py
+-rw-r--r--   0 runner    (1001) docker     (123)      360 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      679 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class00_Config.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7690 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class01_Plasma2D.py
+-rw-r--r--   0 runner    (1001) docker     (123)      945 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class01_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9253 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class02_Rays.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2994 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class03_Aperture.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2222 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class04_Filter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7199 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class05_Crystal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2376 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class06_Grating.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1483 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class06_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9363 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class07_Camera.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18674 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class08_Diagnostic.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2826 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class09_GeometryMatrix.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4410 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class10_Inversion.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26222 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class10_algos.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34041 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class10_checks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30773 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class10_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23510 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class10_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4305 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class10_refs.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24921 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class2_check.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24365 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class2_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5693 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class2_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6703 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class3_check.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4038 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class4_check.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11771 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class5_check.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18459 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class5_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3452 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class5_coordinates.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6281 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class5_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4607 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class5_projections.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25113 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class5_reflections_pts2pt.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20731 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class5_reflections_ptsvect.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25707 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class7_check.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11079 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class7_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15398 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_check.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45724 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18599 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_compute_signal.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19033 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_equivalent_apertures.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28075 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_etendue_los.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15069 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_los_angles.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18486 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_los_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12110 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_move.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26012 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class8_vos.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15395 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class9_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16079 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_class9_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26948 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_comp.py
+-rw-r--r--   0 runner    (1001) docker     (123)   178524 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11590 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_core_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)      357 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_def.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1606 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_generic_check.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11368 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_generic_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)   145086 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9358 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_spectrallines_checks.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18874 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_spectrallines_class.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14730 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_spectrallines_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14023 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_spectrallines_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6543 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_spectralunits.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12968 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_utils_bsplines.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11288 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/data/_utils_surface3d.py
+-rw-r--r--   0 runner    (1001) docker     (123)    58540 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/defaults.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.915346 tofu-1.7.0/tofu/dumpro/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dumpro/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)       56 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dumpro/_comp.py
+-rw-r--r--   0 runner    (1001) docker     (123)       50 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dumpro/_comp_clusters.py
+-rw-r--r--   0 runner    (1001) docker     (123)      553 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dumpro/_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)       21 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dumpro/_def.py
+-rw-r--r--   0 runner    (1001) docker     (123)       31 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dumpro/_draft.py
+-rw-r--r--   0 runner    (1001) docker     (123)       58 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dumpro/_plot.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.915346 tofu-1.7.0/tofu/dust/
+-rw-r--r--   0 runner    (1001) docker     (123)      123 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dust/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1950 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dust/_comp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5472 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dust/_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)      906 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/dust/_plot.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.915346 tofu-1.7.0/tofu/entrypoints/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/entrypoints/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      913 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/entrypoints/_def.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3237 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/entrypoints/tofucalc.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3096 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/entrypoints/tofuplot.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.919346 tofu-1.7.0/tofu/geom/
+-rw-r--r--   0 runner    (1001) docker     (123)   259307 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_GG.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)      508 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4611 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_basic_geom_tools.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)    13775 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_basic_geom_tools.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)      502 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_chained_list.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)     2449 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_chained_list.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)    24082 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_check_optics.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45525 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_comp.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40687 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_comp_optics.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44212 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_comp_solidangles.py
+-rw-r--r--   0 runner    (1001) docker     (123)   289934 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)   148251 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_core_optics.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25215 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_def.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11128 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_def_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7563 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_distance_tools.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)    62742 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_distance_tools.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)    28576 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_etendue.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2167 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_openmp_tools.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)    69100 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)    62482 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_plot_optics.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18069 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_raytracing_tools.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)   118812 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_raytracing_tools.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)    14136 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_sampling_tools.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)   115661 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_sampling_tools.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)      371 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_sorted_set.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)     2262 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_sorted_set.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)     4156 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_vignetting_tools.pxd
+-rw-r--r--   0 runner    (1001) docker     (123)    26377 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/_vignetting_tools.pyx
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.943346 tofu-1.7.0/tofu/geom/inputs/
+-rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/AUG_V0_from_V1.py
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS1L.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      292 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS1U.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS2L.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      292 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS2U.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS3L.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      292 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpITER_CS3U.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS1lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS1upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS2lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS2upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS3lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilCS_ExpSPARC_CS3upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF4.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF5.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpITER_PF6.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_CentralSolenoid.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil01.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      346 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil02.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil03.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil04.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil05.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil06.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil07.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil08.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil09.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil10.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil11.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil12.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil13.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil14.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil16.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil17.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil18.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil19.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil20.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil21.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpNSTX_PFCoil22.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      302 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div1lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      298 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div1upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      302 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div2lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      298 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_Div2upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      302 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFClower0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      302 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFClower1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCmed0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      300 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCmed1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2448 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCupper0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      298 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCupper1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF1lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF1upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF2lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF2upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF3lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF3upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF4lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_PF4upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VS1lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VS1upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      665 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlatelower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      654 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlateupper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      293 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_A001.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B001.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B002.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      959 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      908 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      908 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_C001.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_C002.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_D001.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_D002.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E001.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E002.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E003.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E004.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E005.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E006.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E007.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E008.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1520 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      294 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1542 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F001.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F002.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F003.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      295 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F004.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F005.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F006.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F007.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_F008.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      942 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      892 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      892 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      293 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_BlV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      289 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_BuV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_CSV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      604 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow1V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      604 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow2V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      593 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp1V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      593 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp2V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      293 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DlV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      289 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DuV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      293 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_ElV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      289 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_EuV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      293 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_FlV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      289 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_FuV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      319 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cTPi.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      395 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cTPib.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      230 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cTPic.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      260 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cdomL.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      260 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cdomR.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      260 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2cdome.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      228 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2ci1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      198 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2ci2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      469 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBG2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      244 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBl1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      259 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBl2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      244 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBl3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      379 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      214 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      214 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      168 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D2dBu4.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      348 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D3BG1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      334 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_D3BG10.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      963 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_ICRHa.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      167 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_LIM09.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      137 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_PClow.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      136 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_PCup.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      675 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_SBi.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      303 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      228 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      273 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      393 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT4.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      378 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPLT5.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      258 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      228 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT4.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      288 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_TPRT5.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2819 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_inner.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3969 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_lower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4183 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_outer.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1693 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_upper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    42519 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketInnerV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    73640 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketOuterV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    35568 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_DivertorV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    26260 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterEquatV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    26204 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterUpperV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1305 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK01.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1305 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK02.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1302 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK03.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1299 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK04.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1299 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK05.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1299 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK06.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1399 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK07.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1499 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK08.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1449 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK09.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1248 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK10.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2107 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK11.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2107 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK12.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2107 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK13.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1198 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK14.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1200 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK15.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2111 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK16.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2111 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK17.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2111 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK18.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6691 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3376 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5875 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3325 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div4.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5875 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div5.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5468 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div6.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5468 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div7.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2349 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter01.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2299 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter02.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2299 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter03.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2249 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter04.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2248 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorLower.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorUpper.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      546 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_ICRFAntenna.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    21699 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter01.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4149 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter02.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      344 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path69778.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      294 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path69912.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      444 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path69980.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      794 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70015.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      694 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70085.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      394 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70153.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      697 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpSPARC_ICRH0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3173 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpTOMAS_AntennaV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3224 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpTOMAS_LimiterV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      756 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1674 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    13188 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2067 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5298 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5904 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      956 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1764 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4793 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4943 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1479 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverLDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1402 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverUDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4018 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingLDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      564 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateLDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      555 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateUDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4530 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJLDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4455 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJUDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4053 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingUDivV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      299 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      452 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      911 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    23939 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      709 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2443 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     7696 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    30724 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      292 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      342 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    23520 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV3.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2159 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6553 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2159 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6553 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2161 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6555 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2161 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6555 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2161 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6555 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      645 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      795 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1819 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldHFSV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6424 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSLowV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    20508 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSSlimV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6311 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSUpV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    20508 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSWideV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1502 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_VDEV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    50500 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_PlasmaDomain_ExpWEST_Sep.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    15855 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpAUG_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      588 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpAUG_VESiR.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     8374 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpCOMPASS2_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2720 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_InnerV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11775 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    84216 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpDEMO2019_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      897 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_Cryostat.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6909 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_InnerV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     7717 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_OuterV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    28016 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5235 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    12614 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpJET_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1401 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpKSTAR_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      542 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpMAST_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6905 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpNSTX_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1296 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpNSTX_VesselInner.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3278 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFInner.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3782 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFOuter.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2521 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_FirstWallV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      902 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesInner.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      801 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesOuter.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2973 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTCV_t.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    12964 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTCV_vIn.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    12966 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTCV_vOut.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    10192 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTOMAS_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    29937 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_InnerV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    31654 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_OuterV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2670 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3227 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3071 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV2.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11599 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/WEST_get_details_from_excel.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2491 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/inputs/get_geom_TCV.py
+-rw-r--r--   0 runner    (1001) docker     (123)      181 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu/geom/openmp_enabled.py
+-rw-r--r--   0 runner    (1001) docker     (123)    46718 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/geom/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.943346 tofu-1.7.0/tofu/imas2tofu/
+-rw-r--r--   0 runner    (1001) docker     (123)     3301 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/imas2tofu/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26569 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/imas2tofu/_comp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7109 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/imas2tofu/_comp_mesh.py
+-rw-r--r--   0 runner    (1001) docker     (123)    48066 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/imas2tofu/_comp_toobjects.py
+-rw-r--r--   0 runner    (1001) docker     (123)   138425 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/imas2tofu/_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42308 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/imas2tofu/_def.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7691 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/imas2tofu/_mat2ids2calc.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/mag/
+-rw-r--r--   0 runner    (1001) docker     (123)     1160 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29557 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/equimap.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23137 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/magFieldLines.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/mag/mag_ripple/
+-rw-r--r--   0 runner    (1001) docker     (123)      475 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/mag_ripple/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)      520 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/mag_ripple/compile_f2py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3482 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/mag_ripple/mag_ripple.f
+-rw-r--r--   0 runner    (1001) docker     (123)    11158 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/regression_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11334 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/test_equimap.py
+-rw-r--r--   0 runner    (1001) docker     (123)      588 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/test_magFieldLines.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15899 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/mag/test_ripple.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/nist2tofu/
+-rw-r--r--   0 runner    (1001) docker     (123)      388 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/nist2tofu/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27722 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/nist2tofu/_requests.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/openadas2tofu/
+-rw-r--r--   0 runner    (1001) docker     (123)      503 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/openadas2tofu/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35701 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/openadas2tofu/_read_files.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24831 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/openadas2tofu/_requests.py
+-rw-r--r--   0 runner    (1001) docker     (123)    72466 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/pathfile.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/spectro/
+-rw-r--r--   0 runner    (1001) docker     (123)      206 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18789 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_analysis_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)    52853 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_fit12d.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28897 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_fit12d_dextract.py
+-rw-r--r--   0 runner    (1001) docker     (123)    94177 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_fit12d_dinput.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25979 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_fit12d_funccostjac.py
+-rw-r--r--   0 runner    (1001) docker     (123)    72085 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)    68682 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_rockingcurve.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15199 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/spectro/_rockingcurve_def.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)      297 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/tests/tests00_root/
+-rw-r--r--   0 runner    (1001) docker     (123)       29 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests00_root/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4570 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests00_root/test_03_plot.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.947346 tofu-1.7.0/tofu/tests/tests01_geom/
+-rw-r--r--   0 runner    (1001) docker     (123)      184 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    76941 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_01_GG.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5832 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_02_compute.py
+-rw-r--r--   0 runner    (1001) docker     (123)   125415 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_03_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14230 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_04_core_optics.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16675 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_04_sampling.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19047 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_05_solid_angles.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.955346 tofu-1.7.0/tofu/tests/tests01_geom/test_data/
+-rw-r--r--   0 runner    (1001) docker     (123)   218404 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/Inkscape.svg
+-rw-r--r--   0 runner    (1001) docker     (123)      202 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilCS_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      204 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Bl_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      200 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Bu_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      510 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivLow1_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      510 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivLow2_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      500 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivUp1_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      500 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_DivUp2_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      204 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Dl_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      200 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Du_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      204 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_El_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      200 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Eu_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      204 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Fl_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      200 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Fu_V0.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)    12294 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Notes.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3641 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      663 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1581 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V1.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     8466 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      758 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1667 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4898 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V2.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     9724 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      808 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1616 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4645 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V2.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     4369 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      204 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      357 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      816 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V2.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5741 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      612 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2346 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     7599 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V2.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2639 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      200 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      250 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_V1.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      400 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_V2.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     9803 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1969 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6363 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V1.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     9824 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1969 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6363 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V1.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     9822 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1969 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6363 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V1.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)    11884 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1969 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6363 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V1.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)    12106 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1969 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     6363 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V1.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2335 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)      250 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_V0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      400 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_V1.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     8060 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PlasmaDomain_Standard_Notes.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1358 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5050 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_V0.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1355 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_Notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5050 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_V0.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/test_data/det37_CTVD_incC4_New.npz
+-rw-r--r--   0 runner    (1001) docker     (123)      534 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests01_geom/testing_tools.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.955346 tofu-1.7.0/tofu/tests/tests02_data/
+-rw-r--r--   0 runner    (1001) docker     (123)       65 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests02_data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21607 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests02_data/test_03_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4831 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests02_data/test_04_spectrallines.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.955346 tofu-1.7.0/tofu/tests/tests03_openadas/
+-rw-r--r--   0 runner    (1001) docker     (123)       29 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests03_openadas/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4764 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests03_openadas/test_03_core.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.955346 tofu-1.7.0/tofu/tests/tests04_spectro/
+-rw-r--r--   0 runner    (1001) docker     (123)       67 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29371 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_01_fit12d.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3383 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_02_analysistools.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3303 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_03_rockingcurve.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.963346 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/
+-rw-r--r--   0 runner    (1001) docker     (123)    54707 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/TFG_CrystalBragg_ExpWEST_DgXICS_ArXVII_sh00000_Vers1.5.0.npz
+-rw-r--r--   0 runner    (1001) docker     (123)  1592000 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/UV_spectra_sh55506.npz
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38498 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/_lines_database.py
+-rw-r--r--   0 runner    (1001) docker     (123)  4287706 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/_mask_54041.npz
+-rw-r--r--   0 runner    (1001) docker     (123)     5561 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/_spectral_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1396 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/det37_CTVD_incC4_New.npz
+-rw-r--r--   0 runner    (1001) docker     (123)    43500 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/spectral_fit.npz
+-rw-r--r--   0 runner    (1001) docker     (123) 23594389 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests04_spectro/test_data/west_54046_xics.npz
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.983346 tofu-1.7.0/tofu/tests/tests05_nist/
+-rw-r--r--   0 runner    (1001) docker     (123)       29 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests05_nist/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2804 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests05_nist/test_03_core.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.983346 tofu-1.7.0/tofu/tests/tests06_mesh/
+-rw-r--r--   0 runner    (1001) docker     (123)       31 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests06_mesh/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25579 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests06_mesh/test_01_checks.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.983346 tofu-1.7.0/tofu/tests/tests06_mesh/test_data/
+-rw-r--r--   0 runner    (1001) docker     (123)   163954 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests06_mesh/test_data/ITER_JINTRAC_sh134000_run30_public_edgesources_quadtrimesh.npz
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests06_mesh/test_data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)  1584667 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests06_mesh/test_data/mesh_triangular_WEST_eq.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.987346 tofu-1.7.0/tofu/tests/tests07_inversions/
+-rw-r--r--   0 runner    (1001) docker     (123)       34 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests07_inversions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7933 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests07_inversions/test_01_isotropic.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.987346 tofu-1.7.0/tofu/tests/tests08_diagnostics/
+-rw-r--r--   0 runner    (1001) docker     (123)       36 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests08_diagnostics/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13943 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests08_diagnostics/test_01_diagnostics.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.987346 tofu-1.7.0/tofu/tests/tests09_tutorials/
+-rw-r--r--   0 runner    (1001) docker     (123)       27 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4938 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/test_01_runall.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2199 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_basic.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6540 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_create_geometry.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3030 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_create_geometry_from_svg.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3175 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_custom_emissivity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1503 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_gallery_fusion_machines.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3835 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_solid_angles.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12134 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_real0.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.987346 tofu-1.7.0/tofu/tomotok2tofu/
+-rw-r--r--   0 runner    (1001) docker     (123)      407 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tomotok2tofu/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5497 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/tomotok2tofu/_core.py
+-rw-r--r--   0 runner    (1001) docker     (123)   157477 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)       79 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu/version.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.907346 tofu-1.7.0/tofu.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)    12202 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    23950 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      210 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      181 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       53 2023-04-12 13:21:56.000000 tofu-1.7.0/tofu.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:56.987346 tofu-1.7.0/tofu_helpers/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu_helpers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5064 2023-04-12 13:21:27.000000 tofu-1.7.0/tofu_helpers/openmp_helpers.py
```

### Comparing `tofu-1.6.5/LICENSE.txt` & `tofu-1.7.0/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/MANIFEST.in` & `tofu-1.7.0/MANIFEST.in`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/PKG-INFO` & `tofu-1.7.0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 Metadata-Version: 2.1
 Name: tofu
-Version: 1.6.5
+Version: 1.7.0
 Summary: A python library for Tomography for Fusion
 Home-page: https://github.com/ToFuProject/tofu
 Author: Didier VEZINET and Laura MENDOZA
 Author-email: didier.vezinet@gmail.com
 License: MIT
 Keywords: tomography geometry 3D inversion synthetic fusion
-Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: Topic :: Scientific/Engineering :: Physics
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Natural Language :: English
@@ -164,9 +163,7 @@
 **Warning**
 This Pypi package focuses on tomography for fusion research.
 It uses the same name as a previous package dedicated to a testing framework
 coupling fixtures and tests loosely, now renamed **reahl-tofu** and developped
 by Iwan Vosloo since 2006. If you ended up here looking for a web-oriented
 library, you should probably redirect to the more recent
 [**reahl-tofu**](https://pypi.python.org/pypi/reahl-tofu) page.
-
-
```

### Comparing `tofu-1.6.5/README.md` & `tofu-1.7.0/README.md`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/_updateversion.py` & `tofu-1.7.0/_updateversion.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/inputs_temp/XICS_allshots_C34.py` & `tofu-1.7.0/inputs_temp/XICS_allshots_C34.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/inputs_temp/dlines.py` & `tofu-1.7.0/inputs_temp/dlines.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/scripts/_dparser.py` & `tofu-1.7.0/scripts/_dparser.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/scripts/tofu_bash.py` & `tofu-1.7.0/scripts/tofu_bash.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/scripts/tofucustom.py` & `tofu-1.7.0/scripts/tofucustom.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/scripts/tofuversion.py` & `tofu-1.7.0/scripts/tofuversion.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/setup.py` & `tofu-1.7.0/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -317,18 +317,18 @@
         "numpy",
         "scipy",
         # "scikit-sparse",
         # "scikit-umfpack",
         "matplotlib<=3.5.2",
         "contourpy",
         "requests",
-        "cython>=0.26",
         "svg.path",
         "Polygon3",
-        "datastock>=0.0.22",
+        "cython>=0.26",
+        "bsplines2d>=0.0.2",
     ],
     python_requires=">=3.6",
 
     # List additional groups of dependencies here (e.g. development
     # dependencies). You can install these using the following syntax,
     # for example:
     # $ pip install -e .[dev,test]
```

### Comparing `tofu-1.6.5/tofu/__init__.py` & `tofu-1.7.0/tofu/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -46,19 +46,41 @@
 ---------
 tests
     tofu's unit-tests
 __version__
     tofu version string
 """
 
+
+import os
 import sys
 import warnings
 from .version import __version__
 
 
+# -------------------------------------
+#       DEBUG
+# -------------------------------------
+
+
+_PATH_HERE = os.path.dirname(os.path.dirname(__file__))
+_PATH_BS2 = os.path.join(
+    os.path.dirname(_PATH_HERE),
+    'bsplines2d',
+)
+sys.path.insert(0, _PATH_BS2)
+import bsplines2d as bs2
+sys.path.pop(0)
+
+
+# -------------------------------------
+#       DEBUG - END
+# -------------------------------------
+
+
 import tofu.pathfile as pathfile
 import tofu.utils as utils
 
 from tofu.utils import save, load, load_from_imas, calc_from_imas
 import tofu._plot as _plot
 import tofu.geom as geom
 from tofu.geom.utils import create_config as load_config
```

### Comparing `tofu-1.6.5/tofu/_physics.py` & `tofu-1.7.0/tofu/_physics.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/_plot.py` & `tofu-1.7.0/tofu/_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/benchmarks/benchmarks_00_Geometry_peakmem.py` & `tofu-1.7.0/tofu/benchmarks/benchmarks_00_Geometry_peakmem.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/benchmarks/benchmarks_00_Geometry_time.py` & `tofu-1.7.0/tofu/benchmarks/benchmarks_00_Geometry_time.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/benchmarks/benchmarks_01_Mesh2D_peakmem.py` & `tofu-1.7.0/tofu/benchmarks/benchmarks_01_Mesh2D_peakmem.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/benchmarks/benchmarks_01_Mesh2D_time.py` & `tofu-1.7.0/tofu/benchmarks/benchmarks_01_Mesh2D_time.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/benchmarks/benchmarks_02_spectralfit_peakmem.py` & `tofu-1.7.0/tofu/benchmarks/benchmarks_02_spectralfit_peakmem.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/benchmarks/benchmarks_02_spectralfit_time.py` & `tofu-1.7.0/tofu/benchmarks/benchmarks_02_spectralfit_time.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/benchmarks/benchmarks_03_solidangles.py` & `tofu-1.7.0/tofu/benchmarks/benchmarks_03_solidangles.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_check_inputs.py` & `tofu-1.7.0/tofu/data/_DataCollection_check_inputs.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_class0_Base.py` & `tofu-1.7.0/tofu/data/_DataCollection_class0_Base.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_class1_interactivity.py` & `tofu-1.7.0/tofu/data/_DataCollection_class1_interactivity.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_comp.py` & `tofu-1.7.0/tofu/data/_DataCollection_comp.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_interactivity.py` & `tofu-1.7.0/tofu/data/_DataCollection_interactivity.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_plot_as_array.py` & `tofu-1.7.0/tofu/data/_DataCollection_plot_as_array.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_plot_misc.py` & `tofu-1.7.0/tofu/data/_DataCollection_plot_misc.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_DataCollection_plot_text.py` & `tofu-1.7.0/tofu/data/_DataCollection_plot_text.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_class00_Config.py` & `tofu-1.7.0/tofu/data/_class00_Config.py`

 * *Files 25% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 # Built-in
 import copy
 
 
 # Common
 import numpy as np
 import datastock as ds
+import bsplines2d as bs2
 
 
 # tofu
 # from tofu import __version__ as __version__
 
 
 __all__ = ['Config']
@@ -19,17 +20,17 @@
 
 # #############################################################################
 # #############################################################################
 #                           Plasma2D
 # #############################################################################
 
 
-class Config(ds.DataStock):
+class Config(bs2.BSplines2D):
 
     _show_in_summary = 'all'
-    _dshow = dict(ds.DataStock._dshow)
+    _dshow = dict(bs2.BSplines2D._dshow)
     _dshow.update({
         'structure': [
         ],
         'config': [
         ],
     })
```

### Comparing `tofu-1.6.5/tofu/data/_class01_Plasma2D.py` & `tofu-1.7.0/tofu/imas2tofu/_comp_toobjects.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,1397 +1,1391 @@
-# -*- coding: utf-8 -*-
 
+import os
+import warnings
 
-# Built-in
-import copy
+import numpy as np
 
 
-# Common
-import numpy as np
-import datastock as ds
+from . import _def
 
 
 # tofu
-# from tofu import __version__ as __version__
-from ._class00_Config import Config as Previous
-from . import _class1_checks as _checks
-from . import _class1_compute as _compute
-from . import _class1_plot as _plot
+pfe = os.path.join(os.path.expanduser('~'), '.tofu', '_imas2tofu_def.py')
+if os.path.isfile(pfe):
+    # Make sure we load the user-specific file
+    # sys.path method
+    # sys.path.insert(1, os.path.join(os.path.expanduser('~'), '.tofu'))
+    # import _scripts_def as _defscripts
+    # _ = sys.path.pop(1)
+    # importlib method
+    import importlib.util
+    spec = importlib.util.spec_from_file_location("_defimas2tofu", pfe)
+    _defimas2tofu = importlib.util.module_from_spec(spec)
+    spec.loader.exec_module(_defimas2tofu)
+else:
+    try:
+        import tofu.imas2tofu._def as _defimas2tofu
+    except Exception as err:
+        from . import _def as _defimas2tofu
 
+_ERRSHOT = False
+_ERREXP = False
 
-__all__ = ['Plasma2D']
+_DTLIM = _defimas2tofu._DTLIM
+_INDEVENT = _defimas2tofu._INDEVENT
 
 
-_WHICH_MESH = 'mesh'
-_QUANT_R = 'R'
-_QUANT_Z = 'Z'
+# #############################################################################
+#                       Generic
+# #############################################################################
+
+
+def _check_shotExp_consistency(didd, lidd, tofustr='shot', imasstr='shot',
+                               err=True, fallback=0):
+    crit = None
+    for idd in lidd:
+        v0 = didd[idd]
+        if imasstr in v0['params']:
+            if crit is None:
+                crit = v0['params'][imasstr]
+            elif crit != v0['params'][imasstr]:
+                ss = '{} : {}'.format(idd, str(v0['params'][imasstr]))
+                msg = ("All idd refer to different {}!\n".format(imasstr)
+                       + "\t- {}".format(ss))
+                if err:
+                    raise Exception(msg)
+                else:
+                    warnings.warn(msg)
+    if crit is None:
+        crit = fallback
+    return crit
+
+
+def get_lidsidd_shotExp(lidsok,
+                        errshot=None, errExp=None, upper=True,
+                        dids=None, didd=None):
+    """ Check whether all shot / Exp are consistent accross the ids """
+
+    if errshot is None:
+        errshot = _ERRSHOT
+    if errExp is None:
+        errExp = _ERREXP
+
+    lids = set(lidsok).intersection(dids.keys())
+    lidd = set([dids[ids]['idd'] for ids in lids])
+
+    # shot (non-identical => error if errshot is True, warning otherwise)
+    shot = _check_shotExp_consistency(didd, lidd,
+                                      tofustr='shot', imasstr='shot',
+                                      err=errshot, fallback=0)
+
+    # Exp (non-identical => error if errExp is True, warning otherwise)
+    Exp = _check_shotExp_consistency(didd, lidd,
+                                     tofustr='Exp', imasstr='database',
+                                     err=errExp, fallback='Dummy')
+    if upper is True:
+        Exp = Exp.upper()
+    return lids, lidd, shot, Exp
 
 
 # #############################################################################
-# #############################################################################
-#                           Plasma2D
+#                       Extra
 # #############################################################################
 
 
-class Plasma2D(Previous):
+def extra_checkformat(dextra, fordata=None,
+                      dids=None, didd=None, dshort=None):
 
-    _ddef = copy.deepcopy(ds.DataStock._ddef)
-    _ddef['params']['ddata'].update({
-        'bsplines': (str, ''),
-    })
-    _ddef['params']['dobj'] = None
-    _ddef['params']['dref'] = None
-
-    # _show_in_summary_core = ['shape', 'ref', 'group']
-    _show_in_summary = 'all'
-    _dshow = dict(Previous._dshow)
-
-    _which_mesh = _WHICH_MESH
-    _quant_R = _QUANT_R
-    _quant_Z = _QUANT_Z
-
-    def add_mesh(
-        self,
-        # rectangular mesh
-        key=None,
-        domain=None,
-        res=None,
-        R=None,
-        Z=None,
-        # triangular mesh
-        knots=None,
-        cents=None,
-        # cropping
-        crop_poly=None,
-        thresh_in=None,
-        remove_isolated=None,
-        # direct addition of bsplines
-        deg=None,
-        **kwdargs,
-    ):
-        """ Add a mesh by key and domain / resolution
-
-        Can create a rectangular or triangular mesh:
-            - rectangular: provide (domain, res) or (R, Z)
-                - domain:
-                - res:
-                - R:
-                - Z:
-            - triangular:
-                - knots: (nknots, 2) array of (R, Z) coordinates
-                - cents: (ncents, 3 or 4) array of int indices
-
-        Can optionally be cropped by a closed polygon crop_poly, that can be:
-            - a (2, N) np.narray of (R, Z) coordinates
-            - a tuple (Config, key_struct) to designate a struct poly
-
-        Args thresh_in and remove_isolated control the level of cropping:
-            - thresh_in:
-            - remove_isolated:
-
-        If deg is provided, immediately adds a bsplines
-
-        Example:
-        --------
-                >>> import tofu as tf
-                >>> conf = tf.load_config('ITER')
-                >>> mesh = tf.data.Plasma2D()
-                >>> mesh.add_mesh(config=conf, res=0.1, deg=1)
-
-        """
-
-        # get domain, poly from crop_poly
-        if crop_poly is not None:
-            domain, poly = _checks._mesh2DRect_from_croppoly(
-                crop_poly=crop_poly,
-                domain=domain,
-            )
+    lc = [dextra is False, dextra is None,
+          isinstance(dextra, str),
+          isinstance(dextra, list),
+          isinstance(dextra, dict)]
+    if not any(lc):
+        msg = ("Arg dextra must be either:\n"
+               + "\t- None:     set to default\n"
+               + "\t- False:    no extra signal\n"
+               + "\t- str:      a single extra signal (shortcut)\n"
+               + "\t- list:     a list of extra signals\n"
+               + "\t- dict:     a dict of extra signals {ids: list of short}\n"
+               + "\n  You provided: {}".format(dextra))
+        raise Exception(msg)
+
+    if dextra is False:
+        if fordata is True:
+            return None
         else:
-            poly = None
+            return None, None
 
-        # check input data and get input dicts
-        dref, ddata, dmesh = _checks._mesh2D_check(
-            coll=self,
-            # rectangular
-            domain=domain,
-            res=res,
-            R=R,
-            Z=Z,
-            # triangular
-            knots=knots,
-            cents=cents,
-            trifind=None,
-            # key
-            key=key,
-        )
+    elif dextra is None:
+        dextra = {}
+        if 'equilibrium' in dids.keys():
+            dextra.update({'equilibrium': [('ip', 'k'), ('BT0', 'm'),
+                                           ('axR', (0., 0.8, 0.)),
+                                           ('axZ', (0., 1., 0.)),
+                                           'ax', 'sep', 't']})
+        if 'core_profiles' in dids.keys():
+            dextra.update({'core_profiles': ['ip', 'vloop', 't']})
+        if 'lh_antennas' in dids.keys():
+            dextra.update({'lh_antennas': [('power0', (0.8, 0., 0.)),
+                                           ('power1', (1., 0., 0.)), 't']})
+        if 'ic_antennas' in dids.keys():
+            dextra.update({'ic_antennas': [
+                ('power0', (0., 0., 0.8)),
+                ('power1', (0., 0., 1.)),
+                ('power2', (0., 0., 0.9)), 't']})
+    if type(dextra) is str:
+        dextra = [dextra]
+    if type(dextra) is list:
+        dex = {}
+        for ee in dextra:
+            lids = [ids for ids in dids.keys()
+                    if ee in dshort[ids].keys()]
+            if len(lids) != 1:
+                msg = ("No / multiple matches:\n"
+                       + "extra {} not available from self._dshort".format(ee))
+                raise Exception(msg)
+            if lids[0] not in dex.keys():
+                dex = {lids[0]: [ee]}
+            else:
+                dex[lids[0]].append(ee)
+        dextra = dex
+    return dextra
 
-        # add kwdargs
-        key = list(dmesh.keys())[0]
-        dmesh[key].update(**kwdargs)
-
-        # define dobj['mesh']
-        dobj = {
-            self._which_mesh: dmesh,
-        }
-
-        # update data source
-        for k0, v0 in ddata.items():
-            ddata[k0]['source'] = kwdargs.get('source')
-
-        # update dicts
-        self.update(dref=dref, ddata=ddata, dobj=dobj)
-
-        # optional bspline
-        if deg is not None:
-            self.add_bsplines(key=key, deg=deg)
 
-        # optional cropping
-        c0 = (
-            self.dobj[self._which_mesh][key]['type'] == 'rect'
-            and poly is not None
-        )
-        if c0:
-            self.crop(
-                key=key,
-                crop=poly,
-                thresh_in=thresh_in,
-                remove_isolated=remove_isolated,
-            )
+def extra_get_fordataTrue(inds, vs, vc, out, dout,
+                          ids=None, dshort=None, dcomp=None):
+    for ii in inds:
+        ss = vs[ii]
+        if ss == 't':
+            continue
+        if out[ss]['isempty'] is True:
+            continue
+        if ss in dshort[ids].keys():
+            dd = dshort[ids][ss]
+        else:
+            dd = dcomp[ids][ss]
+        label = dd.get('quant', 'unknown')
+        units = out[ss]['units']
+        key = '{}.{}'.format(ids, ss)
+
+        if 'sep' == ss.split('.')[-1].lower():
+            out[ss]['data'] = np.swapaxes(out[ss]['data'], 1, 2)
+
+        datastr = 'data'
+        if any([ss.split('.')[-1].lower() == s0 for s0 in ['sep', 'ax', 'x']]):
+            datastr = 'data2D'
+
+        dout[key] = {'t': out['t']['data'],
+                     datastr: out[ss]['data'],
+                     'label': label, 'units': units, 'c': vc[ii]}
+
+
+def extra_get_fordataFalse(out, d0d, dt0,
+                           ids=None, dshort=None, dcomp=None):
+    any_ = False
+    keyt = '{}.t'.format(ids)
+    for ss in out.keys():
+        if ss == 't':
+            continue
+        if out[ss]['isempty'] is True:
+            continue
+        if ss in dshort[ids].keys():
+            dd = dshort[ids][ss]
+        else:
+            dd = dcomp[ids][ss]
+        dim = dd.get('dim', 'unknown')
+        quant = dd.get('quant', 'unknown')
+        units = out[ss]['units']
+        key = '{}.{}'.format(ids, ss)
+
+        if 'sep' == ss.split('.')[-1].lower():
+            out[ss]['data'] = np.swapaxes(out[ss]['data'], 1, 2)
+
+        d0d[key] = {'data': out[ss]['data'], 'name': ss,
+                    'source': ids, 'dim': dim, 'quant': quant,
+                    'units': units, 'depend': (keyt,)}
+        any_ = True
+    if any_ is True:
+        dt0[keyt] = {'data': out['t']['data'], 'name': 't',
+                     'source': ids, 'depend': (keyt,)}
 
-    def add_mesh_polar(
-        self,
-        # polar mesh
-        key=None,
-        radius=None,
-        angle=None,
-        # Defined on
-        radius2d=None,
-        angle2d=None,
-        # optional special points coordinates vs time
-        O_pts=None,         # computed if not provided
-        X_pts=None,         # unused
-        strike_pts=None,    # unused
-        # res for contour discontinuity of angle2d
-        res=None,
-        # parameters
-        radius_dim=None,
-        radius_quant=None,
-        radius_name=None,
-        radius_units=None,
-        angle_dim=None,
-        angle_quant=None,
-        angle_name=None,
-        # direct addition of bsplines
-        deg=None,
-        **kwdargs,
-    ):
-        """ Add a 2d polar mesh
-
-        For now only includes radial mesh
-        radius has to be backed-up by:
-            - a radius quantity from a pre-existing rect or tri mesh
-            - a function
-
-        """
-
-        # check input data and get input dicts
-        dref, ddata, dmesh = _checks._mesh2D_polar_check(
-            coll=self,
-            # polar
-            radius=radius,
-            angle=angle,
-            radius2d=radius2d,
-            angle2d=angle2d,
-            # parameters
-            radius_dim=radius_dim,
-            radius_quant=radius_quant,
-            radius_name=radius_name,
-            radius_units=radius_units,
-            angle_dim=angle_dim,
-            angle_quant=angle_quant,
-            angle_name=angle_name,
-            # key
-            key=key,
-        )
 
-        # add kwdargs
-        key = list(dmesh.keys())[0]
-        dmesh[key].update(**kwdargs)
-
-        # update data source
-        for k0, v0 in ddata.items():
-            ddata[k0]['source'] = kwdargs.get('source')
-
-        # special treatment of radius2d
-        assert O_pts is None
-        drefO, ddataO, kR, kZ = _compute.radius2d_special_points(
-            coll=self,
-            key=dmesh[key]['radius2d'],
-            keym0=key,
-            res=res,
-        )
-        dref.update(drefO)
-        ddata.update(ddataO)
-        dmesh[key]['pts_O'] = (kR, kZ)
-
-        # define dobj['mesh']
-        dobj = {
-            self._which_mesh: dmesh,
-        }
-
-        # update dicts
-        self.update(dref=dref, ddata=ddata, dobj=dobj)
-
-        # special treatment of angle2d
-        if dmesh[key]['angle2d'] is not None:
-            drefa, ddataa, kR, kZ = _compute.angle2d_zone(
-                coll=self,
-                key=dmesh[key]['angle2d'],
-                keyrad2d=dmesh[key]['radius2d'],
-                key_ptsO=dmesh[key]['pts_O'],
-                res=res,
-                keym0=key,
-            )
+# #############################################################################
+#                       Config
+# #############################################################################
 
-            # update dicts
-            self.update(dref=drefa, ddata=ddataa)
-            if 'azone' in self.get_lparam(self._which_mesh):
-                self.set_param(
-                    key=key,
-                    param='azone',
-                    value=(kR, kZ),
-                    which=self._which_mesh,
-                )
+
+def config_extract_lS(ids, occ, wall, description_2d, mod,
+                      kwargs=None, mobile=None):
+    """ Extract all relevant structures """
+
+    nlim = len(wall.limiter.unit)
+    nmob = len(wall.mobile.unit)
+    # onelimonly = False
+
+    # ----------------------------------
+    # Relevant only if vessel is filled
+    # try:
+    #    if len(wall.vessel.unit) != 1:
+    #        msg = "There is no / several vessel.unit!"
+    #        raise Exception(msg)
+    #    if len(wall.vessel.unit[0].element) != 1:
+    #        msg = "There is no / several vessel.unit[0].element!"
+    #        raise Exception(msg)
+    #    if len(wall.vessel.unit[0].element[0].outline.r) < 3:
+    #        msg = "wall.vessel polygon has less than 3 points!"
+    #        raise Exception(msg)
+    #    name = wall.vessel.unit[0].element[0].name
+    #    poly = np.array([wall.vessel.unit[0].element[0].outline.r,
+    #                     wall.vessel.unit[0].element[0].outline.z])
+    # except Exception as err:
+    #    # If vessel not in vessel, sometimes stored a a single limiter
+    #    if nlim == 1:
+    #        name = wall.limiter.unit[0].name
+    #        poly = np.array([wall.limiter.unit[0].outline.r,
+    #                         wall.limiter.unit[0].outline.z])
+    #        onelimonly = True
+    #    else:
+    #        msg = ("There does not seem to be any vessel, "
+    #               + "not in wall.vessel nor in wall.limiter!")
+    #        raise Exception(msg)
+    # cls = None
+    # if name == '':
+    #     name = 'ImasVessel'
+    # if '_' in name:
+    #     ln = name.split('_')
+    #     if len(ln) == 2:
+    #         cls, name = ln
+    #     else:
+    #         name = name.replace('_', '')
+    # if cls is None:
+    #     cls = 'Ves'
+    # assert cls in ['Ves', 'PlasmaDomain']
+    # ves = getattr(mod, cls)(Poly=poly, Name=name, **kwargs)
+
+    # Determine if mobile or not
+    # if onelimonly is False:
+    if mobile is None:
+        if nlim == 0 and nmob > 0:
+            mobile = True
+        elif nmob == 0 and nlim > 0:
+            mobile = False
+        elif nmob > nlim:
+            msgw = 'wall.description_2[{}]'.format(description_2d)
+            msg = ("\nids wall has less limiter than mobile units\n"
+                   + "\t- len({}.limiter.unit) = {}\n".format(msgw, nlim)
+                   + "\t- len({}.mobile.unit) = {}\n".format(msgw, nmob)
+                   + "  => Choosing mobile by default")
+            warnings.warn(msg)
+            mobile = True
+        elif nmob <= nlim:
+            msgw = 'wall.description_2[{}]'.format(description_2d)
+            msg = ("\nids wall has more limiter than mobile units\n"
+                   + "\t- len({}.limiter.unit) = {}\n".format(msgw, nlim)
+                   + "\t- len({}.mobile.unit) = {}\n".format(msgw, nmob)
+                   + "  => Choosing limiter by default")
+            warnings.warn(msg)
+            mobile = False
+    assert isinstance(mobile, bool)
+
+    # Get PFC
+    if mobile is True:
+        units = wall.mobile.unit
+    else:
+        units = wall.limiter.unit
+    nunits = len(units)
+
+    if nunits == 0:
+        msg = ("There is no unit stored !\n"
+               + "The required 2d description is empty:\n")
+        ms = "len(idd.{}[occ={}].description_2d".format(ids, occ)
+        msg += "{}[{}].limiter.unit) = 0".format(ms,
+                                                 description_2d)
+        raise Exception(msg)
+
+    lS = [None for _ in units]
+    for ii in range(0, nunits):
+        try:
+            if mobile is True:
+                outline = units[ii].outline[0]
             else:
-                self.add_param(
-                    'azone', value={key: (kR, kZ)}, which=self._which_mesh,
-                )
+                outline = units[ii].outline
+            poly = np.array([outline.r, outline.z])
 
-        # optional bspline
-        if deg is not None:
-            self.add_bsplines(key=key, deg=deg)
+            if units[ii].phi_extensions.size > 0:
+                pos, extent = units[ii].phi_extensions.T
+            else:
+                pos, extent = None, None
+            name = units[ii].name
+            cls, mobi = None, None
+            if name == '':
+                name = 'unit{:02.0f}'.format(ii)
+            if '_' in name:
+                name = name.strip('_')
+                ln = name.split('_')
+                if len(ln) == 2:
+                    cls, name = ln
+                elif len(ln) == 3:
+                    cls, name, mobi = ln
+                else:
+                    name = name.replace('_', '')
+            if ' ' in name:
+                name = name.strip(' ')
+                ln = name.split(' ')
+                if len(ln) > 1:
+                    for ii, nn in enumerate(ln[1:]):
+                        if nn[0].islower():
+                            ln[ii+1] = nn.capitalize()
+                    name = ''.join(ln)
+            if cls is None:
+                if ii == nunits - 1:
+                    cls = 'Ves'
+                else:
+                    cls = 'PFC'
+            # mobi = mobi == 'mobile'
+            lS[ii] = getattr(mod, cls)(Poly=poly, pos=pos,
+                                       extent=extent,
+                                       Name=name,
+                                       **kwargs)
+        except Exception as err:
+            msg = ("PFC unit[{}] named {} ".format(ii, name)
+                   + "could not be loaded!\n"
+                   + str(err))
+            raise Exception(msg)
+    return lS
 
-    # -----------------
-    # bsplines
-    # ------------------
 
-    def add_bsplines(self, key=None, deg=None, angle=None):
-        """ Add bspline basis functions on the chosen mesh """
+# #############################################################################
+#                       Plasma
+# #############################################################################
 
-        # --------------
-        # check inputs
 
-        keym, keybs, deg = _checks._mesh2D_bsplines(
-            key=key,
-            lkeys=list(self.dobj[self._which_mesh].keys()),
-            deg=deg,
-        )
+def plasma_checkformat_dsig(dsig=None,
+                            lidsplasma=None, dids=None,
+                            dshort=None, dcomp=None):
+    lidsok = set(lidsplasma).intersection(dids.keys())
+
+    lscom = ['t']
+    lsmesh = ['2dmeshNodes', '2dmeshFaces',
+              '2dmeshR', '2dmeshZ']
+
+    lc = [dsig is None,
+          type(dsig) is str,
+          type(dsig) is list,
+          type(dsig) is dict]
+    assert any(lc)
+
+    # Convert to dict
+    if lc[0]:
+        dsig = dict.fromkeys(lidsok)
+    elif lc[1] or lc[2]:
+        if lc[1]:
+            dsig = [dsig]
+        dsig = dict.fromkeys(lidsok.intersection(dsig))
 
-        # --------------
-        # get bsplines
+    for ids in dsig.keys():
+        if dsig[ids] is None:
+            dsig[ids] = sorted(set(list(dshort[ids].keys())
+                                   + list(dcomp[ids].keys())))
+
+    # Check content
+    dout = {}
+    for k0, v0 in dsig.items():
+        lkeysok = sorted(set(list(dshort[k0].keys())
+                             + list(dcomp[k0].keys())))
+        if k0 not in lidsok:
+            msg = ("Only the following ids are relevant to Plasma2D:\n"
+                   + "\t- {}\n".format(lidsok)
+                   + "  => ids {} from dsig is ignored".format(k0))
+            warnings.warn(msg)
+            continue
+        lc = [v0 is None, type(v0) is str, type(v0) is list]
+        if not any(lc):
+            msg = ("Each value in dsig must be either:\n"
+                   + "\t- None\n"
+                   + "\t- str : a valid shortcut\n"
+                   + "\t- list of str: list of valid shortcuts\n"
+                   + "You provided:\n{}".format(dsig))
+            raise Exception(msg)
+        if lc[0]:
+            dsig[k0] = lkeysok
+        if lc[1]:
+            dsig[k0] = [dsig[k0]]
+        if not all([ss in lkeysok for ss in dsig[k0]]):
+            msg = ("All requested signals must be valid shortcuts !\n"
+                   + "    - dsig[{}] = {}".format(k0, dsig[k0]))
+            raise Exception(msg)
 
-        if self.dobj[self._which_mesh][keym]['type'] == 'rect':
-            dref, ddata, dobj = _compute._mesh2DRect_bsplines(
-                coll=self, keym=keym, keybs=keybs, deg=deg,
-            )
-        elif self.dobj[self._which_mesh][keym]['type'] == 'tri':
-            dref, ddata, dobj = _compute._mesh2DTri_bsplines(
-                coll=self, keym=keym, keybs=keybs, deg=deg,
-            )
-        else:
-            dref, ddata, dobj = _compute._mesh2Dpolar_bsplines(
-                coll=self, keym=keym, keybs=keybs, deg=deg, angle=angle,
-            )
+        # Check presence of minimum
+        lc = [ss for ss in lscom if ss not in dsig[k0]]
+        if len(lc) > 0:
+            msg = ("dsig[{}] does not have {}\n".format(k0, lc)
+                   + "    - dsig[{}] = {}".format(k0, dsig[k0]))
+            raise Exception(msg)
 
-        # --------------
-        # update dict and crop if relevant
+        # Check required minimum for 2dmesh, for valid shortcuts
+        if any(['2d' in ss for ss in dsig[k0]]):
+            lsmesh0 = set(lsmesh).intersection(dshort[k0].keys())
+            dsig[k0] += list(lsmesh0.difference(dsig[k0]))
+        dout[k0] = dsig[k0]
+    return dout
+
+
+def get_plasma(
+    multi=None,
+    dtime0=None,
+    d0d=None,
+    out0=None,
+    lids=None,
+    # radial base
+    radius_base=None,
+    # parameters
+    tlim=None,
+    t0=None,
+    indt0=None,
+    indevent=None,
+    nan=None,
+    pos=None,
+    stack=None,
+    isclose=None,
+    empty=None,
+    strict=None,
+    # plotting
+    plot=None,
+    plot_sig=None,
+):
 
-        self.update(dobj=dobj, ddata=ddata, dref=dref)
-        if self.dobj[self._which_mesh][keym]['type'] == 'rect':
-            _compute.add_cropbs_from_crop(
-                coll=self,
-                keybs=keybs,
-                keym=keym,
-            )
+    import tofu.data as tfd
+    plasma = tfd.Plasma2D()
 
-    # -----------------
-    # add_data
-    # ------------------
+    # -----------
+    # loop on ids
 
-    def update(
-        self,
-        dobj=None,
-        ddata=None,
-        dref=None,
-        harmonize=None,
-    ):
-        """ Overload datastock update() method """
-
-        # if ddata => check ref for bsplines
-        if ddata is not None:
-            for k0, v0 in ddata.items():
-                (
-                    ddata[k0]['ref'], ddata[k0]['data'],
-                ) = _checks.add_data_meshbsplines_ref(
-                    ref=v0['ref'],
-                    data=v0['data'],
-                    dmesh=self._dobj.get(self._which_mesh),
-                    dbsplines=self._dobj.get('bsplines'),
-                )
+    for ids in lids:
+        idsshort = _def._dshortids.get(ids, ids)
+
+        # -----
+        # time
 
-        # update
-        super().update(
-            dobj=dobj,
-            ddata=ddata,
-            dref=dref,
-            harmonize=harmonize,
+        out_ = {'t': out0[ids].get('t', None)}
+        lc = (
+            out_['t'] is not None
+            and out_['t']['isempty'] is False
         )
 
-        # assign bsplines
-        if self._dobj.get('bsplines') is not None:
-            for k0, v0 in self._ddata.items():
-                lbs = [
-                    k1 for k1, v1 in self._dobj['bsplines'].items()
-                    if v1['ref'] == tuple([
-                        rr for rr in v0['ref']
-                        if rr in v1['ref']
-                    ])
-                ]
-                if len(lbs) == 0:
-                    pass
-                elif len(lbs) == 1:
-                    self._ddata[k0]['bsplines'] = lbs[0]
-                else:
-                    msg = f"Multiple nsplines:\n{lbs}"
-                    raise Exception(msg)
+        keynt, nt, indt = None, None, None
+        if lc is True:
+
+            # get tlim
+            dtt = multi.get_tlim(
+                out_['t']['data'],
+                tlim=tlim,
+                indevent=indevent,
+                returnas=int,
+            )
+            indt = dtt['indt']
+            keynt = f'{idsshort}.nt'
+            nt = dtt['t'].size
+
+            # add ref and data
+            plasma.add_ref(key=keynt, size=nt)
+            plasma.add_data(
+                key=f'{idsshort}.t',
+                data=dtt['t'],
+                ref=keynt,
+                quant='t',
+                name='t',
+                dim='time',
+                units='s',
+                source=ids,
+            )
+
+            # -----------------
+            # time-only
 
-        # assign diagnostic
-        if self._dobj.get('camera') is not None:
-            for k0, v0 in self._ddata.items():
-                lcam = [
-                    k1 for k1, v1 in self._dobj['camera'].items()
-                    if v1['dgeom']['ref'] == tuple([
-                        rr for rr in v0['ref']
-                        if rr in v1['dgeom']['ref']
-                    ])
-                ]
-
-                if len(lcam) == 0:
-                    pass
-                elif len(lcam) == 1:
-                    self._ddata[k0]['camera'] = lcam[0]
+            lsig = [
+                k0 for k0, v0 in out0[ids].items()
+                if isinstance(v0['data'], np.ndarray)
+                and v0['data'].shape == (dtt['nt0'],)
+                and k0 != 't'
+            ]
+            out_ = multi.get_data(
+                dsig={ids: lsig},
+                indt=indt,
+                nan=nan,
+                pos=pos,
+                stack=stack,
+                isclose=isclose,
+                empty=empty,
+                strict=strict,
+                return_all=False,
+                warn=False,
+            )[ids]
+
+            # add data
+            for k0, v0 in out_.items():
+
+                # Get dim / quant from dshort / dcomp + units
+                if k0 in multi._dshort[ids].keys():
+                    dim = multi._dshort[ids][k0].get('dim', 'unknown')
+                    quant = multi._dshort[ids][k0].get('quant', 'unknown')
                 else:
-                    msg = f"Multiple cameras:\n{lcam}"
-                    raise Exception(msg)
+                    dim = multi._dcomp[ids][k0].get('dim', 'unknown')
+                    quant = multi._dcomp[ids][k0].get('quant', 'unknown')
 
-    # -----------------
-    # crop
-    # ------------------
+                plasma.add_data(
+                    key=f'{idsshort}.{k0}',
+                    data=v0['data'],
+                    ref=(keynt,),
+                    dim=dim,
+                    quant=quant,
+                    units=v0['units'],
+                    source=ids,
+                )
 
-    def crop(self, key=None, crop=None, thresh_in=None, remove_isolated=None):
-        """ Crop a mesh / bspline
+        # -------------
+        # d2d and dmesh
 
-        Uses:
-            - a mask of bool for each mesh elements
-            - a 2d (R, Z) closed polygon
-
-        If applied on a bspline, cropping is double-checked to make sure
-        all remaining bsplines have full support domain
-        """
-        crop, key, thresh_in = _compute.crop(
-            coll=self,
-            key=key,
-            crop=crop,
-            thresh_in=thresh_in,
-            remove_isolated=remove_isolated,
-        )
+        lsig = [kk for kk in out0[ids].keys() if '2d' in kk]
+        lsigmesh = [kk for kk in lsig if 'mesh' in kk]
+        out_ = multi.get_data(
+            dsig={ids: lsig},
+            indt=indt,
+            nan=nan,
+            pos=pos,
+            stack=stack,
+            isclose=isclose,
+            empty=empty,
+            strict=strict,
+            return_all=False,
+            warn=False,
+        )[ids]
+
+        cmesh = any([ss in out_.keys() for ss in lsigmesh])
+
+        if len(out_) > 0 and cmesh is True:
+
+            npts, datashape = None, None
+            keym = None
+
+            # ----
+            # mesh
+
+            keym = f'{idsshort}.mesh'
+            lc = [
+                all([ss in lsig for ss in ['2dmeshNodes', '2dmeshFaces']]),
+                all([ss in lsig for ss in ['2dmeshR', '2dmeshZ']]),
+            ]
+            if not np.sum(lc) == 1:
+                msg = (
+                    "2d mesh shall be provided either via:\n"
+                    "\t- '2dmeshR' and '2dmeshZ'\n"
+                    "\t- '2dmeshNodes' and '2dmeshFaces'"
+                )
+                raise Exception(msg)
 
-        # add crop data
-        keycrop = f'{key}-crop'
-        ref = tuple([
-            self._ddata[k0]['ref'][0]
-            for k0 in self._dobj[self._which_mesh][key]['cents']
-        ])
-        self.add_data(
-            key=keycrop,
-            data=crop,
-            ref=ref,
-            dim='bool',
-            quant='bool',
-        )
+            # Nodes / Faces case
+            if lc[0]:
+                plasma.add_mesh(
+                    key=keym,
+                    source=ids,
+                    knots=out_['2dmeshNodes']['data'],
+                    cents=out_['2dmeshFaces']['data'],
+                )
+                n1 = plasma.dobj[plasma._which_mesh][keym]['shape-k'][0]
+                n2 = plasma.dobj[plasma._which_mesh][keym]['shape-c'][0]
 
-        # update obj
-        self._dobj[self._which_mesh][key]['crop'] = keycrop
-        self._dobj[self._which_mesh][key]['crop-thresh'] = thresh_in
-
-        # also crop bsplines
-        for k0 in self.dobj.get('bsplines', {}).keys():
-            if self.dobj['bsplines'][k0][self._which_mesh] == key:
-                _compute.add_cropbs_from_crop(coll=self, keybs=k0, keym=key)
+            # R / Z case
+            elif lc[1]:
+                plasma.add_mesh(
+                    key=keym,
+                    source=ids,
+                    R=out_['2dmeshR']['data'],
+                    Z=out_['2dmeshZ']['data'],
+                )
+                n1, n2 = plasma.dobj[plasma._which_mesh][keym]['shape']
 
-    # -----------------
-    # get data subset
-    # ------------------
+            # ------------------
+            # profiles2d on mesh
 
-    def get_profiles2d(self):
-        """ Return dict of profiles2d with associated bsplines as values """
+            meshtype = plasma.dobj[plasma._which_mesh][keym]['type']
+            for ss in set(out_.keys()).difference(lsigmesh):
+                add_profile2d(
+                    multi=multi,
+                    ids=ids,
+                    idsshort=idsshort,
+                    plasma=plasma,
+                    out_=out_,
+                    ss=ss,
+                    # for references
+                    keynt=keynt,
+                    keym=keym,
+                    # mesh
+                    meshtype=meshtype,
+                    n1=n1,
+                    n2=n2,
+                    nt=nt,
+                )
 
-        # dict of profiles2d
-        dk = {
-            k0: v0['bsplines']
-            for k0, v0 in self._ddata.items()
-            if v0['bsplines'] != ''
-        }
-        dk.update({k0: k0 for k0 in self._dobj['bsplines'].keys()})
-
-        return dk
-
-    # -------------------
-    # get data time
-    # -------------------
-
-    def get_time(
-        self,
-        key=None,
-        t=None,
-        indt=None,
-        ind_strict=None,
-        dim=None,
-    ):
-        """ Return the time vector or time macthing indices
-
-        hastime, keyt, reft, keyt, val, dind = self.get_time(key='prof0')
-
-        Return
-        ------
-        hastime:    bool
-            flag, True if key has a time dimension
-        keyt:       None /  str
-            if hastime and a time vector exists, the key to that time vector
-        t:          None / np.ndarray
-            if hastime
-        dind:       dict, with:
-            - indt:  None / np.ndarray
-                if indt or t was provided, and keyt exists
-                int indices of nearest matching times
-            - indtu: None / np.ndarray
-                if indt is returned, np.unique(indt)
-            - indtr: None / np.ndarray
-                if indt is returned, a bool (ntu, nt) array
-            - indok: None / np.ndarray
-                if indt is returned, a bool (nt,) array
-
-        """
-
-        if dim is None:
-            dim = 'time'
-
-        return self.get_ref_vector(
-            key=key,
-            values=t,
-            indices=indt,
-            ind_strict=ind_strict,
-            dim=dim,
-        )
+        elif len(out_) > 0:
+            msg = (
+                "No mesh to be used as reference!"
+            )
+            raise Exception(msg)
 
-    def get_time_common(
-        self,
-        keys=None,
-        t=None,
-        indt=None,
-        ind_strict=None,
-        dim=None,
-    ):
-        """ Return the time vector or time macthing indices
-
-        hastime, hasvect, t, dind = self.get_time_common(
-            keys=['prof0', 'prof1'],
-            t=np.linspace(0, 5, 10),
-        )
+        # ---------------
+        # d1d and dradius
 
-        Return
-        ------
-        hastime:        bool
-            flag, True if key has a time dimension
-        keyt:           None /  str
-            if hastime and a time vector exists, the key to that time vector
-        t:              None / np.ndarray
-            if hastime
-        indt:           None / np.ndarray
-            if indt or t was provided, and keyt exists
-            int indices of nearest matching times
-        indtu:          None / np.ndarray
-            if indt is returned, np.unique(indt)
-        indt_reverse:   None / np.ndarray
-            if indt is returned, a bool (ntu, nt) array
-
-        """
-
-        if dim is None:
-            dim = 'time'
-
-        return self.get_ref_vector_common(
-            keys=keys,
-            values=t,
-            indices=indt,
-            ind_strict=ind_strict,
-            dim=dim,
-        )
+        lsig = [k for k in out0[ids].keys() if '1d' in k]
+        out_ = multi.get_data(
+            dsig={ids: lsig},
+            indt=indt,
+            nan=nan,
+            pos=pos,
+            stack=stack,
+            isclose=isclose,
+            empty=empty,
+            strict=strict,
+            return_all=False,
+            warn=False,
+        )[ids]
+
+        if len(out_) > 0:
+
+            # Identify radius base
+            drad = {}
+            for k0, v0 in out_.items():
+                c0 = (
+                    isinstance(v0['data'], np.ndarray)
+                    and np.all(np.isfinite(v0['data']))
+                    and v0['data'].ndim in [1, 2]
+                )
+                if c0:
+                    if v0['data'].ndim == 1:
+                        diff = v0['data'][1] - v0['data'][0]
+                        if np.all(np.diff(v0['data'])*diff > 0):
+                            drad[k0] = v0['data']
+                    else:
+                        if np.allclose(v0['data'][0:1, :], v0['data']):
+                            diff = v0['data'][0, 1] - v0['data'][0, 0]
+                            if np.all(np.diff(v0['data'][0, :])*diff > 0):
+                                drad[k0] = v0['data'][0, :]
+                        elif np.allclose(v0['data'][:, 0:1], v0['data']):
+                            diff = v0['data'][1, 0] - v0['data'][0, 0]
+                            if np.all(np.diff(v0['data'][:, 0])*diff > 0):
+                                drad[k0] = v0['data'][:, 0]
+
+            if len(drad) == 0:
+                msg = (
+                    "No valid radial base could be identified!\n"
+                    "A valid radial base should be a 1d monotonous array"
+                )
+                raise Exception(msg)
 
-    # -----------------
-    # indices
-    # ------------------
+            elif len(drad) == 1:
+                k0ref = list(drad.keys())[0]
+            else:
+                if not np.unique([v0.size for v0 in drad.values()]).size == 1:
+                    lstr = [f"\t- {k0}: {v0.size}" for k0, v0 in drad.items()]
+                    msg = (
+                        "Several possible radial bases identified:\n"
+                        + "\n".join(lstr)
+                    )
+                    raise Exception(msg)
 
-    def select_ind(
-        self,
-        key=None,
-        ind=None,
-        elements=None,
-        returnas=None,
-        crop=None,
-    ):
-        """ Return ind for selected key (mesh or bspline) as:
-                - tuple (default)
-                - 'flat'
-
-        Can covert one into the other
-        """
-        return _compute._select_ind(
-            coll=self,
-            key=key,
-            ind=ind,
-            elements=elements,
-            returnas=returnas,
-            crop=crop,
-        )
+                if radius_base is not None and radius_base in drad.keys():
+                    k0ref = radius_base
+                else:
+                    k0ref = list(drad.keys())[0]
 
-    def select_mesh_elements(
-        self,
-        key=None,
-        ind=None,
-        elements=None,
-        returnas=None,
-        return_neighbours=None,
-        crop=None,
-    ):
-        """ Return indices or values of selected knots / cent
-
-        Can be used to convert tuple (R, Z) indices to flat (RZ,) indices
-        Can return values instead of indices
-        Can return indices / values of neighbourgs
-
-        """
-        # check key
-        key = ds._generic_check._check_var(
-            key, 'key',
-            allowed=list(self.dobj.get('mesh', {}).keys()),
-            types=str,
-        )
+            nr = drad[k0ref].size
+            kref = f'{idsshort}.nr'
 
-        # get ind
-        if self.dobj['mesh'][key]['type'] == 'rect':
-            returnas_ind = tuple
-        else:
-            returnas_ind = bool
+            # add ref and data for radial base
+            plasma.add_ref(key=kref, size=nr)
 
-        ind = self.select_ind(
-            key=key,
-            ind=ind,
-            elements=elements,
-            returnas=returnas_ind,
-            crop=crop,
-        )
+            # Get dim / quant from dshort / dcomp + units
+            if k0ref in multi._dshort[ids].keys():
+                dim = multi._dshort[ids][k0ref].get('dim', 'unknown')
+                quant = multi._dshort[ids][k0ref].get('quant', 'unknown')
+            else:
+                dim = multi._dcomp[ids][k0ref].get('dim', 'unknown')
+                quant = multi._dcomp[ids][k0ref].get('quant', 'unknown')
 
-        return _compute._select_mesh(
-            coll=self,
-            key=key,
-            ind=ind,
-            elements=elements,
-            returnas=returnas,
-            return_neighbours=return_neighbours,
-        )
+            radius2d = [
+                k0 for k0, v0 in plasma.ddata.items()
+                if '2d' in k0
+                and v0['dim'] == dim
+                and v0['quant'] == quant
+                and v0['bsplines'] is not None
+            ]
+            if len(radius2d) == 1:
+                radius2d = radius2d[0]
+            elif len(radius2d) == 0:
+                msg = (
+                    "No 2d radius for polar mesh!\n"
+                )
+                raise Exception(msg)
+            else:
+                msg = (
+                    "Several possible 2d radius identified!\n"
+                    + str(radius2d)
+                )
+                raise Exception(msg)
 
-    def select_bsplines(
-        self,
-        key=None,
-        ind=None,
-        returnas=None,
-        return_cents=None,
-        return_knots=None,
-        crop=None,
-    ):
-        """ Return indices or values of selected knots / cent
-
-        Can be used to convert tuple (R, Z) indices to flat (RZ,) indices
-        Can return values instead of indices
-        Can return indices / values of neighbourgs
-
-        """
-        return _compute._select_bsplines(
-            coll=self,
-            key=key,
-            ind=ind,
-            returnas=returnas,
-            return_cents=return_cents,
-            return_knots=return_knots,
-            crop=crop,
-        )
+            kmrad = f'{idsshort}.radial'
+            plasma.add_mesh_polar(
+                key=kmrad,
+                radius=drad[k0ref],
+                radius2d=radius2d,
+                radius_dim=dim,
+                radius_quant=quant,
+                radius_units=out_[k0ref]['units'],
+                deg=1,
+            )
 
-    # -----------------
-    # Integration operators
-    # ------------------
+            # Add other radial data
+            for ss in out_.keys():
 
-    def add_bsplines_operator(
-        self,
-        key=None,
-        operator=None,
-        geometry=None,
-        crop=None,
-        store=None,
-        returnas=None,
-        # specific to deg = 0
-        centered=None,
-        # to return gradR, gradZ, for D1N2 deg 0, for tomotok
-        returnas_element=None,
-    ):
-        """ Get a matrix operator to compute an integral
-
-        operator specifies the integrand:
-            - 'D0N1': integral of the value
-            - 'D0N2': integral of the squared value
-            - 'D1N2': integral of the squared gradient
-            - 'D2N2': integral of the squared laplacian
-
-        geometry specifies in which geometry:
-            - 'linear': linear geometry (cross-section = surface)
-            - 'toroidal': toroildal geometry (cross-section = volumic slice)
-
-        """
-
-        (
-            opmat, operator, geometry, dim, ref, crop,
-            store, returnas, key,
-        ) = _compute.get_bsplines_operator(
-            self,
-            key=key,
-            operator=operator,
-            geometry=geometry,
-            crop=crop,
-            store=store,
-            returnas=returnas,
-            # specific to deg = 0
-            centered=centered,
-            # to return gradR, gradZ, for D1N2 deg 0, for tomotok
-            returnas_element=returnas_element,
-        )
+                # safeguard
+                shape = out_[ss]['data'].shape
+                if out_[ss]['data'].ndim not in [1, 2]:
+                    msg = (
+                        f"Non-conform {ids}.{ss}.ndim\n"
+                        "\t- expected: 1 or 2\n"
+                        f"\t- {ids}.{ss}.shape = {shape}"
+                    )
+                    raise Exception(msg)
 
-        # store
-        if store is True:
-            if operator == 'D1':
-                name = f'{key}-{operator}-dR'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat[0],
-                    ref=ref,
-                    units='',
-                    name=operator,
-                    dim=dim,
-                )
-                name = f'{key}-{operator}-dZ'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat[1],
-                    ref=ref,
-                    units='',
-                    name=operator,
-                    dim=dim,
-                )
+                # nr and nt
+                if len(shape) == 1:
+                    assert shape[0] == nr, shape
+
+                elif len(shape) == 2:
+                    if nt is None:
+                        msg = (
+                            f"{ids}.t could not be retrieved\n"
+                            "=> Assuming 't' is the first dimension of "
+                            "{ids}.{ss}"
+                        )
+                        warnings.warn(msg)
+
+                        nt = shape[0]
+                        keynt = f"{ids}.nt"
+
+                        # add ref
+                        plasma.add_ref(key=keynt, size=nt)
+
+                    elif nt not in shape or nr not in shape:
+                        msg = (
+                            "Inconsistent shape with respect to 't' and nr!\n"
+                            f"\t- {ids}.{ss}.shape = {shape}"
+                            f"\t- One dim should be nt = {nt}"
+                            f"\t- One dim should be nr = {nr}"
+                        )
+                        raise Exception(msg)
+
+                    # Make sure shape is (nt, nr)
+                    axist = shape.index(nt)
+                    if axist == 1:
+                        out_[ss]['data'] = out_[ss]['data'].T
+
+                    if out_[ss]['data'].shape != (nt, nr):
+                        msg = (
+                            f"Wrong shape for {ids}.{ss}:\n"
+                            f"\t- expected: {(nt, nr)}\n"
+                            f"\t- got:  {out_[ss]['data'].shape}"
+                        )
+                        raise Exception(msg)
+
+                # Get dim / quant from dshort / dcomp + units
+                if ss in multi._dshort[ids].keys():
+                    dim = multi._dshort[ids][ss].get('dim', 'unknown')
+                    quant = multi._dshort[ids][ss].get('quant', 'unknown')
+                else:
+                    dim = multi._dcomp[ids][ss].get('dim', 'unknown')
+                    quant = multi._dcomp[ids][ss].get('quant', 'unknown')
 
-            elif operator in ['D0N1', 'D0N2']:
-                name = f'{key}-{operator}-{geometry}'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat,
-                    ref=ref,
-                    units='',
-                    name=operator,
+                # add data
+                plasma.add_data(
+                    key=f'{idsshort}.{ss}',
+                    data=out_[ss]['data'],
+                    ref=kmrad if len(shape) == 1 else (keynt, kmrad),
                     dim=dim,
+                    quant=quant,
+                    units=out_[ss]['units'],
+                    source=ids,
                 )
-            elif operator == 'D1N2':
-                name = f'{key}-{operator}-dR-{geometry}'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat[0],
-                    ref=ref,
-                    units='',
-                    name=operator,
-                    dim=dim,
-                )
-                name = f'{key}-{operator}-dZ-{geometry}'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat[1],
-                    ref=ref,
-                    units='',
-                    name=operator,
-                    dim=dim,
-                )
-            elif operator == 'D2N2':
-                name = f'{key}-{operator}-d2R-{geometry}'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat[0],
-                    ref=ref,
-                    units='',
-                    name=operator,
-                    dim=dim,
-                )
-                name = f'{key}-{operator}-d2Z-{geometry}'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat[1],
-                    ref=ref,
-                    units='',
-                    name=operator,
-                    dim=dim,
-                )
-                name = f'{key}-{operator}-dRZ-{geometry}'
-                if crop is True:
-                    name = f'{name}-cropped'
-                self.add_data(
-                    key=name,
-                    data=opmat[2],
-                    ref=ref,
-                    units='',
-                    name=operator,
-                    dim=dim,
-                )
-            else:
-                msg = "Unknown opmat type!"
-                raise Exception(msg)
 
-        # return
-        if returnas is True:
-            return opmat, operator, geometry, dim, ref, crop
+    # t0
+    if indt0 is None:
+        indt0 = 0
+    t0 = multi._get_t0(t0, ind=indt0)
+    if t0 is not False:
+        lt = [
+            k0 for k0, v0 in plasma.ddata.items()
+            if v0['dim'] == 'time'
+        ]
+        for tt in lt:
+            plasma.ddata[lt]['data'] -= t0
+
+    return plasma
+
+
+def add_profile2d(
+    multi=None,
+    ids=None,
+    idsshort=None,
+    plasma=None,
+    out_=None,
+    ss=None,
+    # for references
+    keynt=None,
+    keym=None,
+    # mesh
+    meshtype=None,
+    n1=None,
+    n2=None,
+    nt=None,
+):
+    """ Add profile2d data to existing plasma2D instance (mesh already in) """
 
     # -----------------
-    # interp tools
-    # ------------------
+    # Check data dimension
 
-    def get_sample_mesh(
-        self,
-        key=None,
-        res=None,
-        grid=None,
-        mode=None,
-        R=None,
-        Z=None,
-        DR=None,
-        DZ=None,
-        imshow=None,
-    ):
-        """ Return a sampled version of the chosen mesh """
-        return _compute.sample_mesh(
-            coll=self,
-            key=key,
-            res=res,
-            grid=grid,
-            mode=mode,
-            R=R,
-            Z=Z,
-            DR=DR,
-            DZ=DZ,
-            imshow=imshow,
+    shape = out_[ss]['data'].shape
+    if out_[ss]['data'].ndim not in [1, 2, 3]:
+        msg = (
+            f"Non-conform {ids}.{ss}.ndim\n"
+            "\t- expected: 1, 2 or 3\n"
+            f"\t- {ids}.{ss}.shape = {shape}"
         )
+        raise Exception(msg)
 
+    # -----------------
+    # check per shape
 
-    """
-    def get_sample_bspline(self, key=None, res=None, grid=None, mode=None):
-        return _compute.sample_bsplines(
-            coll=self,
-            key=key,
-            res=res,
-            grid=grid,
-            mode=mode,
-        )
-    """
+    shape = out_[ss]['data'].shape
 
-    def _check_qr12RPZ(
-        self,
-        quant=None,
-        ref1d=None,
-        ref2d=None,
-        q2dR=None,
-        q2dPhi=None,
-        q2dZ=None,
-        group1d=None,
-        group2d=None,
-    ):
-
-        if group1d is None:
-            group1d = self._group1d
-        if group2d is None:
-            group2d = self._group2d
-
-        lc0 = [quant is None, ref1d is None, ref2d is None]
-        lc1 = [q2dR is None, q2dPhi is None, q2dZ is None]
-        if np.sum([all(lc0), all(lc1)]) != 1:
-            msg = (
-                "Please provide either (xor):\n"
-                + "\t- a scalar field (isotropic emissivity):\n"
-                + "\t\tquant : scalar quantity to interpolate\n"
-                + "\t\t\tif quant is 1d, intermediate reference\n"
-                + "\t\t\tfields are necessary for 2d interpolation\n"
-                + "\t\tref1d : 1d reference field on which to interpolate\n"
-                + "\t\tref2d : 2d reference field on which to interpolate\n"
-                + "\t- a vector (R,Phi,Z) field (anisotropic emissivity):\n"
-                + "\t\tq2dR :  R component of the vector field\n"
-                + "\t\tq2dPhi: R component of the vector field\n"
-                + "\t\tq2dZ :  Z component of the vector field\n"
-                + "\t\t=> all components have the same time and mesh!\n"
-            )
+    if len(shape) == 1:
+        # time-independent triangular mesh profile
+        if meshtype != 'tri':
+            msg = "1d profile2d should refer to a triangular mesh!"
             raise Exception(msg)
 
-        # Check requested quant is available in 2d or 1d
-        if all(lc1):
-            (
-                idquant, idref1d, idref2d,
-            ) = _compute._get_possible_ref12d(
-                dd=self._ddata,
-                key=quant, ref1d=ref1d, ref2d=ref2d,
-                group1d=group1d,
-                group2d=group2d,
-            )
-            idq2dR, idq2dPhi, idq2dZ = None, None, None
-            ani = False
+        if shape[0] == n1:
+            deg = 1
+        elif shape[0] == n2:
+            deg = 0
         else:
-            idq2dR, msg = _compute._get_keyingroup_ddata(
-                dd=self._ddata,
-                key=q2dR, group=group2d, msgstr='quant', raise_=True,
-            )
-            idq2dPhi, msg = _compute._get_keyingroup_ddata(
-                dd=self._ddata,
-                key=q2dPhi, group=group2d, msgstr='quant', raise_=True,
-            )
-            idq2dZ, msg = _compute._get_keyingroup_ddata(
-                dd=self._ddata,
-                key=q2dZ, group=group2d, msgstr='quant', raise_=True,
+            msg = (
+                "Wrong size of data, no matching deg!"
             )
-            idquant, idref1d, idref2d = None, None, None
-            ani = True
-        return idquant, idref1d, idref2d, idq2dR, idq2dPhi, idq2dZ, ani
-
-    def _interp_pts2d_to_quant1d(
-        self,
-        pts=None,
-        vect=None,
-        t=None,
-        quant=None,
-        ref1d=None,
-        ref2d=None,
-        q2dR=None,
-        q2dPhi=None,
-        q2dZ=None,
-        interp_t=None,
-        interp_space=None,
-        fill_value=None,
-        Type=None,
-        group0d=None,
-        group1d=None,
-        group2d=None,
-        return_all=None,
-    ):
-        """ Return the value of the desired 1d quantity at 2d points
-
-        For the desired inputs points (pts):
-            - pts are in (X, Y, Z) coordinates
-            - space interpolation is linear on the 1d profiles
-        At the desired input times (t):
-            - using a nearest-neighbourg approach for time
-
-        """
-        # Check inputs
-        if group0d is None:
-            group0d = self._group0d
-        if group1d is None:
-            group1d = self._group1d
-        if group2d is None:
-            group2d = self._group2d
-        # msg = "Only 'nearest' available so far for interp_t!"
-        # assert interp_t == 'nearest', msg
-
-        # Check requested quant is available in 2d or 1d
-        idquant, idref1d, idref2d, idq2dR, idq2dPhi, idq2dZ, ani = \
-                self._check_qr12RPZ(
-                    quant=quant, ref1d=ref1d, ref2d=ref2d,
-                    q2dR=q2dR, q2dPhi=q2dPhi, q2dZ=q2dZ,
-                    group1d=group1d, group2d=group2d,
-                )
+            raise Exception(msg)
+        ref = keym
 
-        # Check the pts is (3,...) array of floats
-        idmesh = None
-        if pts is None:
-            # Identify mesh to get default points
-            if ani:
-                idmesh = [id_ for id_ in self._ddata[idq2dR]['ref']
-                          if self._dref[id_]['group'] == group2d][0]
-            else:
-                if idref1d is None:
-                    idmesh = [id_ for id_ in self._ddata[idquant]['ref']
-                              if self._dref[id_]['group'] == group2d][0]
-                else:
-                    idmesh = [id_ for id_ in self._ddata[idref2d]['ref']
-                              if self._dref[id_]['group'] == group2d][0]
+    elif len(shape) == 2:
+        # time-dependent triangular mesh or time-independent rectangular mesh
 
-            # Derive pts
-            pts = self._get_pts_from_mesh(key=idmesh)
+        # check shape compatibility
+        if meshtype == 'tri':
+            compat_shapes = [(nt, n1), (nt, n2)]
+        else:
+            compat_shapes = [(n1, n2)]
+        compat_shapesT = [(sh[1], sh[0]) for sh in compat_shapes]
 
-        pts = np.atleast_2d(pts)
-        if pts.shape[0] != 3:
+        if not shape in compat_shapes + compat_shapesT:
             msg = (
-                "pts must be np.ndarray of (X,Y,Z) points coordinates\n"
-                + "Can be multi-dimensional, but 1st dimension is (X,Y,Z)\n"
-                + "    - Expected shape : (3,...)\n"
-                + "    - Provided shape : {}".format(pts.shape)
+                f"Data {ss} has incompatible shape for mesh\n"
+                f"\t- Data shape: {shape}\n"
+                f"\t- nt: {nt}\n"
+                f"\t- n1, n2: {n1}, {n2}"
             )
             raise Exception(msg)
 
-        # Check t
-        lc = [t is None, type(t) is str, type(t) is np.ndarray]
-        assert any(lc)
-        if lc[1]:
-            assert t in self._ddata.keys()
-            t = self._ddata[t]['data']
+        # Make sure time is the first dimension
+        if shape not in compat_shapes:
+            out_[ss]['data'] = out_[ss]['data'].T
+            shape = out_[ss]['data'].shape
+
+        # choose degree
+        if meshtype == 'tri':
+            if shape == (nt, n1):
+                deg = 1
+            else:
+                deg = 0
+            ref = (keynt, keym)
+        else:
+            deg = 0
+            ref = keym
 
-        # Interpolation (including time broadcasting)
-        # this is the second slowest step (~0.08 s)
-        func = self._get_finterp(
-            idquant=idquant, idref1d=idref1d, idref2d=idref2d,
-            idq2dR=idq2dR, idq2dPhi=idq2dPhi, idq2dZ=idq2dZ,
-            idmesh=idmesh,
-            interp_t=interp_t, interp_space=interp_space,
-            fill_value=fill_value, ani=ani, Type=Type,
-            group0d=group0d, group2d=group2d,
-        )
+    else:
 
-        # Check vect of ani
+        # check shape
         c0 = (
-            ani is True
-            and (
-                vect is None
-                or not (
-                    isinstance(vect, np.ndarray)
-                    and vect.shape == pts.shape
-                )
-            )
+            meshtype == 'rect'
+            and sorted(shape) == sorted((nt, n1, n2))
         )
-        if c0:
-            msg = (
-                "Anisotropic field interpolation needs a field of local vect\n"
-                + "  => Please provide vect as (3, npts) np.ndarray!"
-            )
+        if not c0:
+            msg = ("Data should be time-varying rect mesh!")
             raise Exception(msg)
 
-        # This is the slowest step (~1.8 s)
-        val, t = func(pts, vect=vect, t=t)
-
-        # return
-        if return_all is None:
-            return_all = True
-        if return_all is True:
-            dout = {
-                't': t,
-                'pts': pts,
-                'ref1d': idref1d,
-                'ref2d': idref2d,
-                'q2dR': idq2dR,
-                'q2dPhi': idq2dPhi,
-                'q2dZ': idq2dZ,
-                'interp_t': interp_t,
-                'interp_space': interp_space,
-            }
-            return val, dout
+        # re-order shape if necessary
+        if shape == (nt, n1, n2):
+            pass
+        elif shape == (nt, n2, n1):
+            out_[ss]['data'] = np.swapaxes(out_[ss]['data'], 1, 2)
+        elif shape == (n1, n2, nt):
+            out_[ss]['data'] = out_[ss]['data']
+        elif shape == (n2, n1, nt):
+            out_[ss]['data'] = out_[ss]['data'].T
         else:
-            return val
+            import pdb; pdb.set_trace()     # DB
+            pass
+        ref = (keynt, keym)
+
+
+    # get parameters
+    if ss in multi._dshort[ids].keys():
+        dim = multi._dshort[ids][ss].get('dim', 'unknown')
+        quant = multi._dshort[ids][ss].get('quant', 'unknown')
+    else:
+        dim = multi._dcomp[ids][ss].get('dim', 'unknown')
+        quant = multi._dcomp[ids][ss].get('quant', 'unknown')
+    units = out_[ss]['units']
+    key = f'{ids}.{ss}'
+
+    # add / check bsplines
+    if plasma.dobj.get('bsplines') is None:
+        plasma.add_bsplines(deg=deg)
+    elif list(plasma.dobj['bsplines'].values())[0]['deg'] != deg:
+        degref = list(plasma.dobj['bsplines'].values())[0]['deg']
+        msg = "Degree not matching!\n\t{deg} vs {degref}"
+        raise Exception(msg)
+
+    # add data
+    plasma.add_data(
+        key=f'{idsshort}.{ss}',
+        data=out_[ss]['data'],
+        name=ss,
+        dim=dim,
+        quant=quant,
+        units=units,
+        source=ids,
+        ref=ref,
+    )
+
+
+# def plasma_plot_args(plot, plot_X, plot_sig,
+                     # dsig=None):
+    # # Set plot
+    # if plot is None:
+        # plot = not (plot_sig is None and plot_X is None)
+
+    # if plot is True:
+        # # set plot_sig
+        # if plot_sig is None:
+            # lsplot = [ss for ss in list(dsig.values())[0]
+                      # if ('1d' in ss and ss != 't'
+                          # and all([sub not in ss
+                                   # for sub in ['rho', 'psi', 'phi']]))]
+            # if not (len(dsig) == 1 and len(lsplot) == 1):
+                # msg = ("Direct plotting only possible if\n"
+                       # + "sig_plot is provided, or can be derived from:\n"
+                       # + "\t- unique ids: {}\n\t".format(dsig.keys())
+                       # + "- unique non-(t, radius) 1d sig: {}".format(lsplot))
+                # raise Exception(msg)
+            # plot_sig = lsplot
+        # if type(plot_sig) is str:
+            # plot_sig = [plot_sig]
+
+        # # set plot_X
+        # if plot_X is None:
+            # lsplot = [ss for ss in list(dsig.values())[0]
+                      # if ('1d' in ss and ss != 't'
+                          # and any([sub in ss
+                                   # for sub in ['rho', 'psi', 'phi']]))]
+            # if not (len(dsig) == 1 and len(lsplot) == 1):
+                # msg = ("Direct plotting only possible if\n"
+                       # + "X_plot is provided, or can be derived from:\n"
+                       # + "\t- unique ids: {}\n".format(dsig.keys())
+                       # + "\t- unique non-t, 1d radius: {}".format(lsplot))
+                # raise Exception(msg)
+            # plot_X = lsplot
+        # if type(plot_X) is str:
+            # plot_X = [plot_X]
+    # return plot, plot_X, plot_sig
 
-    def _interp_pts2d_to_quant1d(
-        self,
-        pts=None,
-        vect=None,
-        t=None,
-        quant=None,
-        ref1d=None,
-        ref2d=None,
-        q2dR=None,
-        q2dPhi=None,
-        q2dZ=None,
-        interp_t=None,
-        interp_space=None,
-        fill_value=None,
-        Type=None,
-        group0d=None,
-        group1d=None,
-        group2d=None,
-        return_all=None,
-    ):
-        """ Return the value of the desired 1d quantity at 2d points
-
-        For the desired inputs points (pts):
-            - pts are in (X, Y, Z) coordinates
-            - space interpolation is linear on the 1d profiles
-        At the desired input times (t):
-            - using a nearest-neighbourg approach for time
-
-        """
-        # Check inputs
-        if group0d is None:
-            group0d = self._group0d
-        if group1d is None:
-            group1d = self._group1d
-        if group2d is None:
-            group2d = self._group2d
-        # msg = "Only 'nearest' available so far for interp_t!"
-        # assert interp_t == 'nearest', msg
-
-        # Check requested quant is available in 2d or 1d
-        idquant, idref1d, idref2d, idq2dR, idq2dPhi, idq2dZ, ani = \
-                self._check_qr12RPZ(
-                    quant=quant, ref1d=ref1d, ref2d=ref2d,
-                    q2dR=q2dR, q2dPhi=q2dPhi, q2dZ=q2dZ,
-                    group1d=group1d, group2d=group2d,
-                )
 
-        # Check the pts is (3,...) array of floats
-        idmesh = None
-        if pts is None:
-            # Identify mesh to get default points
-            if ani:
-                idmesh = [id_ for id_ in self._ddata[idq2dR]['ref']
-                          if self._dref[id_]['group'] == group2d][0]
-            else:
-                if idref1d is None:
-                    idmesh = [id_ for id_ in self._ddata[idquant]['ref']
-                              if self._dref[id_]['group'] == group2d][0]
-                else:
-                    idmesh = [id_ for id_ in self._ddata[idref2d]['ref']
-                              if self._dref[id_]['group'] == group2d][0]
+# #############################################################################
+#                       Cam
+# #############################################################################
 
-            # Derive pts
-            pts = self._get_pts_from_mesh(key=idmesh)
 
-        pts = np.atleast_2d(pts)
-        if pts.shape[0] != 3:
-            msg = (
-                "pts must be np.ndarray of (X,Y,Z) points coordinates\n"
-                + "Can be multi-dimensional, but 1st dimension is (X,Y,Z)\n"
-                + "    - Expected shape : (3,...)\n"
-                + "    - Provided shape : {}".format(pts.shape)
-            )
+def cam_checkformat_geom(ids=None, geomcls=None, indch=None,
+                         lidsdiag=None, dids=None, didsdiag=None):
+
+    # Check ids
+    idsok = set(lidsdiag).intersection(dids.keys())
+    if ids is None and len(idsok) == 1:
+        ids = next(iter(idsok))
+
+    if ids not in dids.keys():
+        msg = ("Provided ids should be available as a self.dids.keys()!\n"
+               + "\t- provided: {}\n".format(str(ids))
+               + "\t- available: {}".format(sorted(dids.keys())))
+        raise Exception(msg)
+
+    if ids not in lidsdiag:
+        msg = ("Requested ids is not pre-tabulated !\n"
+               + "  => Be careful with args (geomcls, indch)")
+        warnings.warn(msg)
+    else:
+        if geomcls is None:
+            geomcls = didsdiag[ids]['geomcls']
+
+    # Check data and geom
+    import tofu.geom as tfg
+
+    lgeom = [kk for kk in dir(tfg) if 'Cam' in kk]
+    if geomcls not in [False] + lgeom:
+        msg = "Arg geomcls must be in {}".format([False]+lgeom)
+        raise Exception(msg)
+
+    if geomcls is False:
+        msg = "ids {} does not seem to be a ids with a camera".format(ids)
+        raise Exception(msg)
+
+    return geomcls
+
+
+def cam_compare_indch_indchr(indch, indchr, nch, indch_auto=None):
+    if indch_auto is None:
+        indch_auto = True
+    if indch is None:
+        indch = np.arange(0, nch)
+    if not np.all(np.in1d(indch, indchr)):
+        msg = ("indch has to be changed, some data may be missing\n"
+               + "\t- indch: {}\n".format(indch)
+               + "\t- indch recommended: {}".format(indchr)
+               + "\n\n  => check self.inspect_channels() for details")
+        if indch_auto is True:
+            indch = indchr
+            warnings.warn(msg)
+        else:
             raise Exception(msg)
+    return indch
 
-        # Check t
-        lc = [t is None, type(t) is str, type(t) is np.ndarray]
-        assert any(lc)
-        if lc[1]:
-            assert t in self._ddata.keys()
-            t = self._ddata[t]['data']
 
-        # Interpolation (including time broadcasting)
-        # this is the second slowest step (~0.08 s)
-        func = self._get_finterp(
-            idquant=idquant, idref1d=idref1d, idref2d=idref2d,
-            idq2dR=idq2dR, idq2dPhi=idq2dPhi, idq2dZ=idq2dZ,
-            idmesh=idmesh,
-            interp_t=interp_t, interp_space=interp_space,
-            fill_value=fill_value, ani=ani, Type=Type,
-            group0d=group0d, group2d=group2d,
-        )
+def inspect_channels_dout(ids=None, indch=None, geom=None,
+                          out=None, nch=None, dshort=None,
+                          lsig=None, lsigshape=None,
+                          compute_ind=None):
+    dout = {}
+    for k0, v0 in out.items():
+        v0 = v0['data']
+        if len(v0) != nch:
+            if len(v0) != 1:
+                import pdb          # DB
+                pdb.set_trace()     # DB
+            continue
+        if isinstance(v0[0], np.ndarray):
+            dout[k0] = {'shapes': np.array([vv.shape for vv in v0]),
+                        'isnan': np.array([np.any(np.isnan(vv))
+                                           for vv in v0])}
+            if k0 == 'los_ptsRZPhi':
+                dout[k0]['equal'] = np.array([np.allclose(vv[0, ...],
+                                                          vv[1, ...])
+                                             for vv in v0])
+        elif type(v0[0]) in [int, float, np.int, np.float, str]:
+            dout[k0] = {'value': np.asarray(v0).ravel()}
+        else:
+            typv = type(v0[0])
+            k0str = (dshort[ids][k0]['str']
+                     if k0 in dshort[ids].keys() else k0)
+            msg = ("\nUnknown data type:\n"
+                   + "\ttype({}) = {}".format(k0str, typv))
+            raise Exception(msg)
 
-        # Check vect of ani
-        c0 = (
-            ani is True
-            and (
-                vect is None
-                or not (
-                    isinstance(vect, np.ndarray)
-                    and vect.shape == pts.shape
-                )
-            )
-        )
-        if c0:
-            msg = (
-                "Anisotropic field interpolation needs a field of local vect\n"
-                + "  => Please provide vect as (3, npts) np.ndarray!"
-            )
+    lsig = sorted(set(lsig).intersection(dout.keys()))
+    lsigshape = sorted(set(lsigshape).intersection(dout.keys()))
+
+    # --------------
+    # Get indchout
+    indchout = None
+    if compute_ind:
+        if geom in ['only', True] and 'los_ptsRZPhi' in out.keys():
+            indg = ((np.prod(dout['los_ptsRZPhi']['shapes'], axis=1) == 0)
+                    | dout['los_ptsRZPhi']['isnan']
+                    | dout['los_ptsRZPhi']['equal'])
+            if geom == 'only':
+                indok = ~indg
+                indchout = indok.nonzero()[0]
+        if geom != 'only':
+            shapes0 = np.concatenate([np.prod(dout[k0]['shapes'],
+                                              axis=1, keepdims=True)
+                                      for k0 in lsigshape], axis=1)
+            indok = np.all(shapes0 != 0, axis=1)
+            if geom is True and 'los_ptsRZPhi' in out.keys():
+                indok[indg] = False
+        if not np.any(indok):
+            indchout = np.array([], dtype=int)
+        elif geom != 'only':
+            indchout = (np.arange(0, nch)[indok]
+                        if indch is None else np.r_[indch][indok])
+            lshapes = [dout[k0]['shapes'][indchout, :] for k0 in lsigshape]
+            lshapesu = [np.unique(ss, axis=0) for ss in lshapes]
+            if any([ss.shape[0] > 1 for ss in lshapesu]):
+                for ii in range(len(lshapesu)):
+                    if lshapesu[ii].shape[0] > 1:
+                        _, inv, counts = np.unique(lshapes[ii], axis=0,
+                                                   return_counts=True,
+                                                   return_inverse=True)
+                        indchout = indchout[inv == np.argmax(counts)]
+                        lshapes = [dout[k0]['shapes'][indchout, :]
+                                   for k0 in lsigshape]
+                        lshapesu = [np.unique(ss, axis=0) for ss in lshapes]
+    return dout, indchout
+
+
+def cam_to_Cam_Du(out, ids=None):
+    Etendues, Surfaces, names = None, None, None
+    if 'los_ptsRZPhi' in out.keys():
+        oo = out['los_ptsRZPhi']['data']
+        D = np.array([oo[:, 0, 0]*np.cos(oo[:, 0, 2]),
+                      oo[:, 0, 0]*np.sin(oo[:, 0, 2]), oo[:, 0, 1]])
+        u = np.array([oo[:, 1, 0]*np.cos(oo[:, 1, 2]),
+                      oo[:, 1, 0]*np.sin(oo[:, 1, 2]), oo[:, 1, 1]])
+        u = (u-D) / np.sqrt(np.sum((u-D)**2, axis=0))[None, :]
+        dgeom = (D, u)
+        indnan = np.any(np.isnan(D), axis=0) | np.any(np.isnan(u), axis=0)
+        if np.any(indnan):
+            nunav, ntot = str(indnan.sum()), str(D.shape[1])
+            msg = ("Some lines of sight unavailable in {}:\n".format(ids)
+                   + "\t- unavailable LOS: {0} / {1}\n".format(nunav, ntot)
+                   + "\t- indices: {0}".format(str(indnan.nonzero()[0])))
+            warnings.warn(msg)
+    else:
+        dgeom = None
+
+    if 'etendue' in out.keys():
+        Etendues = out['etendue']['data']
+    if 'surface' in out.keys():
+        Surfaces = out['surface']['data']
+    if 'names' in out.keys():
+        names = out['names']['data']
+    return dgeom, Etendues, Surfaces, names
+
+
+# #############################################################################
+#                       Data
+# #############################################################################
+
+
+def data_checkformat_tlim(t, tlim=None,
+                          names=None, times=None, indevent=None,
+                          returnas=bool, Exp=None):
+    # Check inputs
+    if tlim is None:
+        tlim = _DTLIM.get(Exp, False)
+    if indevent is None:
+        indevent = _INDEVENT
+    if names is not None:
+        names = np.char.strip(names)
+    if returnas is None:
+        returnas = bool
+    if returnas not in [bool, int]:
+        msg = ("Arg returnas must be in [bool, int]\n"
+               + "\t- provided: {}".format(returnas))
+        raise Exception(msg)
+    assert returnas in [bool, int]
+    lc = [tlim is None,
+          tlim is False,
+          (isinstance(tlim, list) and len(tlim) == 2
+           and all([(type(tt) in [int, float, np.int_, np.float_]
+                     or (isinstance(tt, str)
+                         and names is not None
+                         and tt in names)
+                     or tt is None) for tt in tlim]))]
+
+    if not any(lc):
+        msg = ("tlim must be either:\n"
+               + "\t- None:  set to default (False)\n"
+               + "\t- False: no time limit\n"
+               + "\t- list:  a list of 2, lower and upper limits [t0, t1]:\n"
+               + "\t\t- [None, float]: no lower, explicit upper limit\n"
+               + "\t\t- [float, float]: explicit lower and upper limit\n"
+               + "\t\t- [float, str]: explicit lower, event name for upper\n\n"
+               + "  You provided: {}".format(tlim))
+        if any([isinstance(tt, str) for tt in tlim]):
+            msg += '\n\nAvailable events:\n' + str(names)
+        warnings.warn(msg)
+        tlim = False
+    if tlim is None:
+        tlim = False
+
+    # Compute
+    nt0 = t.size
+    indt = np.ones((nt0,), dtype=bool)
+    if tlim is not False:
+        for ii in range(len(tlim)):
+            if isinstance(tlim[ii], str):
+                ind = (names == tlim[ii]).nonzero()[0][indevent]
+                tlim[ii] = times[ind]
+        if tlim[0] is not None:
+            indt[t < tlim[0]] = False
+        if tlim[1] is not None:
+            indt[t > tlim[1]] = False
+    t = t[indt]
+    if returnas is int:
+        indt = np.nonzero(indt)[0]
+    return {'tlim': tlim, 'nt': t.size, 't': t, 'indt': indt, 'nt0': nt0}
+
+
+def data_checkformat_dsig(ids=None, dsig=None, data=None, X=None,
+                          datacls=None, geomcls=None,
+                          lidsdiag=None, dids=None, didsdiag=None,
+                          dshort=None, dcomp=None):
+
+    # Check ids
+    idsok = set(lidsdiag).intersection(dids.keys())
+    if ids is None and len(idsok) == 1:
+        ids = next(iter(idsok))
+
+    if ids not in dids.keys():
+        msg = "Provided ids should be available as a self.dids.keys() !"
+        raise Exception(msg)
+
+    if ids not in lidsdiag:
+        msg = "Requested ids is not pre-tabulated !\n"
+        msg = "  => Be careful with args (dsig, datacls, geomcls)"
+        warnings.warn(msg)
+    else:
+        if datacls is None:
+            datacls = didsdiag[ids]['datacls']
+        if geomcls is None:
+            geomcls = didsdiag[ids]['geomcls']
+        if dsig is None:
+            dsig = didsdiag[ids]['sig']
+    if data is not None:
+        if not isinstance(data, str):
+            msg = ("data was expected as a str\n"
+                   + "\t- provided: {}".format(data))
+            raise Exception(msg)
+        dsig['data'] = data
+    if X is not None:
+        if not isinstance(X, str):
+            msg = ("X was expected as a str\n"
+                   + "\t- provided: {}".format(X))
             raise Exception(msg)
+        dsig['X'] = X
 
-        # This is the slowest step (~1.8 s)
-        val, t = func(pts, vect=vect, t=t)
+    # Check data and geom
+    import tofu.geom as tfg
+    import tofu.data as tfd
+
+    if datacls is None:
+        datacls = 'DataCam1D'
+    ldata = [kk for kk in dir(tfd) if 'DataCam' in kk]
+    if datacls not in ldata:
+        msg = "Arg datacls must be in {}".format(ldata)
+        raise Exception(msg)
+    lgeom = [kk for kk in dir(tfg) if 'Cam' in kk]
+    if geomcls not in [False] + lgeom:
+        msg = "Arg geom must be in {}".format([False] + lgeom)
+        raise Exception(msg)
+
+    # Check signals
+    c0 = type(dsig) is dict
+    c0 = c0 and 'data' in dsig.keys()
+    ls = ['t', 'X', 'lamb', 'data']
+    c0 = c0 and all([ss in ls for ss in dsig.keys()])
+    if not c0:
+        msg = ("Arg dsig must be a dict with keys:\n"
+               + "\t- 'data' : shortcut to the main data to be loaded\n"
+               + "\t- 't':       (optional) shortcut to time vector\n"
+               + "\t- 'X':       (optional) shortcut to abscissa vector\n"
+               + "\t- 'lamb':    (optional) shortcut to wavelengths")
+        raise Exception(msg)
+
+    dout = {}
+    lok = set(dshort[ids].keys()).union(dcomp[ids].keys())
+    for k, v in dsig.items():
+        if v in lok:
+            dout[k] = v
 
-        # return
-        if return_all is None:
-            return_all = True
-        if return_all is True:
-            dout = {
-                't': t,
-                'pts': pts,
-                'ref1d': idref1d,
-                'ref2d': idref2d,
-                'q2dR': idq2dR,
-                'q2dPhi': idq2dPhi,
-                'q2dZ': idq2dZ,
-                'interp_t': interp_t,
-                'interp_space': interp_space,
-            }
-            return val, dout
-        else:
-            return val
+    return datacls, geomcls, dout
 
-    def interpolate_profile2d(
-        # ressources
-        self,
-        # interpolation base, 1d or 2d
-        key=None,
-        # external coefs (optional)
-        coefs=None,
-        # interpolation points
-        R=None,
-        Z=None,
-        radius=None,
-        angle=None,
-        grid=None,
-        radius_vs_time=None,
-        azone=None,
-        # time: t or indt
-        t=None,
-        indt=None,
-        indt_strict=None,
-        # bsplines
-        indbs=None,
-        # parameters
-        details=None,
-        reshape=None,
-        res=None,
-        crop=None,
-        nan0=None,
-        val_out=None,
-        imshow=None,
-        return_params=None,
-        # storing
-        store=None,
-        inplace=None,
-    ):
-        """ Interpolate desired profile2d (i.e.: data on bsplines)
-
-        Interpolate:
-            - key: a data on bsplines
-            - coefs: external-provided set of coefs
-
-        coefs can only be provided if:
-            - details = False
-            - key = keybs
-            - coefs is a scalar or has shape = shapebs
-
-        At points:
-            - R:  R coordinates (np.ndarray or scalar)
-            - Z:  Z coordinates (np.ndarray, same shape as R, or scalar)
-            - grid: bool, if True mesh R x Z
-            - indt: if provided, only interpolate at desired time indices
-
-        With options:
-            - details: bool, if True returns value for each bspline
-            - indbs:   optional, select bsplines for which to interpolate
-            - reshape: bool,
-            - res:  optional, resolution to generate R and Z if they are None
-            - crop: bool, whether to use the cropped mesh
-            - nan0: value for out-of-mesh points
-            - imshow: bool, whether to return as imshow (transpose)
-            - return_params: bool, whether to return dict of input params
-
-        """
-
-        return _compute.interp2d(
-            # ressources
-            coll=self,
-            # interpolation base, 1d or 2d
-            key=key,
-            # external coefs (optional)
-            coefs=coefs,
-            # interpolation points
-            R=R,
-            Z=Z,
-            radius=radius,
-            angle=angle,
-            grid=grid,
-            radius_vs_time=radius_vs_time,
-            azone=azone,
-            # time: t or indt
-            t=t,
-            indt=indt,
-            indt_strict=indt_strict,
-            # bsplines
-            indbs=indbs,
-            # parameters
-            details=details,
-            reshape=reshape,
-            res=res,
-            crop=crop,
-            nan0=nan0,
-            val_out=val_out,
-            imshow=imshow,
-            return_params=return_params,
-            # storing
-            store=store,
-            inplace=inplace,
-        )
 
-    # TBF after polar meshes
-    def interpolate_2dto1d(
-        # resources
-        self,
-        # interpolation base
-        key1d=None,
-        key2d=None,
-        # interpolation pts
-        R=None,
-        Z=None,
-        grid=None,
-        # parameters
-        interp_t=None,
-        fill_value=None,
-        ani=False,
-    ):
-
-        return _compute.interp2dto1d(
-            coll=self,
-            key1d=key1d,
-            key2d=key2d,
-            R=R,
-            Z=Z,
-            grid=grid,
-            crop=crop,
-            nan0=nan0,
-            return_params=return_params,
-        )
+# #############################################################################
+#                       signal
+# #############################################################################
 
-    # -----------------
-    # plotting
-    # ------------------
 
-    def plot_mesh(
-        self,
-        key=None,
-        ind_knot=None,
-        ind_cent=None,
-        crop=None,
-        color=None,
-        dax=None,
-        dmargin=None,
-        fs=None,
-        dleg=None,
-        connect=None,
-    ):
-
-        return _plot.plot_mesh(
-            coll=self,
-            key=key,
-            ind_knot=ind_knot,
-            ind_cent=ind_cent,
-            crop=crop,
-            color=color,
-            dax=dax,
-            dmargin=dmargin,
-            fs=fs,
-            dleg=dleg,
-            connect=connect,
-        )
+def signal_get_synth(ids, dsig=None,
+                     quant=None, ref1d=None, ref2d=None,
+                     q2dR=None, q2dPhi=None, q2dZ=None,
+                     didsdiag=None, lidsplasma=None, dshort=None, dcomp=None):
+
+    # Check quant, ref1d, ref2d
+    dq = {'quant': quant, 'ref1d': ref1d, 'ref2d': ref2d,
+          'q2dR': q2dR, 'q2dPhi': q2dPhi, 'q2dZ': q2dZ}
+    for kk, vv in dq.items():
+        lc = [vv is None, type(vv) is str, type(vv) in [list, tuple]]
+        assert any(lc)
+        if lc[0]:
+            dq[kk] = didsdiag[ids]['synth']['dsynth'].get(kk, None)
+        if type(dq[kk]) is str:
+            dq[kk] = [dq[kk]]
+        if dq[kk] is not None:
+            for ii in range(0, len(dq[kk])):
+                v1 = tuple(dq[kk][ii].split('.'))
+                assert len(v1) == 2
+                assert v1[0] in lidsplasma
+                assert (v1[1] in dshort[v1[0]].keys()
+                        or v1[1] in dcomp[v1[0]].keys())
+                dq[kk][ii] = v1
+
+    # Check dsig
+    if dsig is None:
+        dsig = didsdiag[ids]['synth']['dsig']
+
+    for k0, v0 in dsig.items():
+        if type(v0) is not list:
+            v0 = [v0]
+        c0 = k0 in lidsplasma
+        c0 = c0 and all([type(vv) is str for vv in v0])
+        if not c0:
+            msg = "Arg dsig must be a dict (ids:[shortcut1, shortcut2...])"
+            raise Exception(msg)
+        dsig[k0] = v0
 
-    def plot_bsplines(
-        self,
-        key=None,
-        indbs=None,
-        indt=None,
-        knots=None,
-        cents=None,
-        res=None,
-        plot_mesh=None,
-        val_out=None,
-        nan0=None,
-        cmap=None,
-        dax=None,
-        dmargin=None,
-        fs=None,
-        dleg=None,
-    ):
-
-        return _plot.plot_bspline(
-            coll=self,
-            key=key,
-            indbs=indbs,
-            indt=indt,
-            knots=knots,
-            cents=cents,
-            res=res,
-            plot_mesh=plot_mesh,
-            val_out=val_out,
-            nan0=nan0,
-            cmap=cmap,
-            dax=dax,
-            dmargin=dmargin,
-            fs=fs,
-            dleg=dleg,
-        )
+    # Check dsig vs quant/ref1d/ref2d consistency
+    for kk, vv in dq.items():
+        if vv is None:
+            continue
+        for ii in range(0, len(vv)):
+            if vv[ii][0] not in dsig.keys():
+                dsig[vv[ii][0]] = []
+            if vv[ii][1] not in dsig[vv[ii][0]]:
+                dsig[vv[ii][0]].append(vv[ii][1])
+            dq[kk][ii] = '{}.{}'.format(vv[ii][0], vv[ii][1])
+
+    lq = didsdiag[ids]['synth']['dsynth'].get('fargs', None)
+    if lq is not None:
+        for qq in lq:
+            q01 = qq.split('.')
+            assert len(q01) == 2
+            if q01[0] not in dsig.keys():
+                dsig[q01[0]] = [q01[1]]
+            else:
+                dsig[q01[0]].append(q01[1])
 
-    def plot_profile2d(
-        self,
-        # inputs
-        key=None,
-        coefs=None,
-        indt=None,
-        res=None,
-        # plot options
-        vmin=None,
-        vmax=None,
-        cmap=None,
-        dax=None,
-        dmargin=None,
-        fs=None,
-        dcolorbar=None,
-        dleg=None,
-        # interactivity
-        dinc=None,
-        connect=None,
-    ):
-        return _plot.plot_profile2d(
-            coll=self,
-            # inputs
-            key=key,
-            coefs=coefs,
-            indt=indt,
-            res=res,
-            # plot options
-            vmin=vmin,
-            vmax=vmax,
-            cmap=cmap,
-            dax=dax,
-            dmargin=dmargin,
-            fs=fs,
-            dcolorbar=dcolorbar,
-            dleg=dleg,
-            # interactivity
-            dinc=dinc,
-            connect=connect,
-        )
+    if dq['quant'] is None and dq['q2dR'] is None and lq is None:
+        msg = "both quant and q2dR are not specified !"
+        raise Exception(msg)
+
+    # Remove unused keys
+    for kk in list(dq.keys()):
+        if dq[kk] is None:
+            del dq[kk]
+    return dsig, dq, lq
```

### Comparing `tofu-1.6.5/tofu/data/_class02_Rays.py` & `tofu-1.7.0/tofu/data/_class02_Rays.py`

 * *Files 4% similar despite different names*

```diff
@@ -61,14 +61,15 @@
         pts_z=None,
         # from ray-tracing (vect + length or config or diag)
         vect_x=None,
         vect_y=None,
         vect_z=None,
         length=None,
         config=None,
+        strict=None,
         reflections_nb=None,
         reflections_type=None,
         key_nseg=None,
         diag=None,
         key_cam=None,
     ):
         """ Add a set of rays
@@ -97,14 +98,15 @@
             pts_z=pts_z,
             # from ray-tracing (vect + length or config or diag)
             vect_x=vect_x,
             vect_y=vect_y,
             vect_z=vect_z,
             length=length,
             config=config,
+            strict=strict,
             reflections_nb=reflections_nb,
             reflections_type=reflections_type,
             key_nseg=key_nseg,
             diag=diag,
             key_cam=key_cam,
         )
 
@@ -263,28 +265,28 @@
         axis_radius=None,
         segment=None,
         lim_to_segments=None,
         return_pts=None,
         return_itot=None,
     ):
         """ Return the tangancy radius to an axis of each ray segment
-        
+
         parameters
         ----------
         axis_pt:    len=3 iterable
             (x, y, z) coordinates of a pt on the axis, default to [0, 0, 0]
         axis_vect:  len=3 iterable
             (x, y, z) coordinates of the axis vector, default to [0, 0, 1]
         axis_radius:    float
             The radius around the axis defining the cylinder to intersect
         lim_to_segments: bool
             flag indicating whether to limit solutions to the segments
         return_pts:
-            flag indicating whether to return the pts (x, y, z) coordinates 
-                
+            flag indicating whether to return the pts (x, y, z) coordinates
+
         Return
         -------
         k0:         np.ndarray of floats
             First solution, per segment
         k1:         np.ndarray of floats
             Second solution, per segment
         iok:        np.ndarray of bool
@@ -293,15 +295,15 @@
             The x coordinates of the points inside the cylinder
         pts_y:      np.ndarray of floats
             The y coordinates of the points inside the cylinder
         pts_z:      np.ndarray of floats
             The z coordinates of the points inside the cylinder
 
         """
-        
+
         return _compute.intersect_radius(
             coll=self,
             key=key,
             key_cam=key_cam,
             axis_pt=axis_pt,
             axis_vect=axis_vect,
             axis_radius=axis_radius,
```

### Comparing `tofu-1.6.5/tofu/data/_class03_Aperture.py` & `tofu-1.7.0/tofu/data/_class03_Aperture.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_class04_Filter.py` & `tofu-1.7.0/tofu/data/_class04_Filter.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_class05_Crystal.py` & `tofu-1.7.0/tofu/data/_class05_Crystal.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,28 +1,24 @@
 # -*- coding: utf-8 -*-
 
 
 # Built-in
 # import copy
 
 
-# Common
-import numpy as np
-import datastock as ds
-
-
 # tofu
 from ._class04_Filter import Filter as Previous
 from . import _class3_check
 from . import _class5_check as _check
 from . import _class5_compute as _compute
 from . import _class5_coordinates as _coordinates
 from . import _class5_reflections_pts2pt as _reflections_pts2pt
 from . import _class5_reflections_ptsvect as _reflections_ptsvect
 from . import _class5_projections as _projections
+from . import _class5_plot as _plot
 
 
 __all__ = ['Crystal']
 
 
 # #############################################################################
 # #############################################################################
@@ -81,14 +77,16 @@
             **dgeom,
         )
 
         key = list(dobj['crystal'].keys())[0]
 
         # material
         dobj['crystal'][key]['dmat'] = _check._dmat(
+            coll=self,
+            key=key,
             dgeom=dobj['crystal'][key]['dgeom'],
             dmat=dmat,
             alpha=alpha,
             beta=beta,
         )
 
         # dmisc
@@ -258,7 +256,33 @@
             key_aperture=key_aperture,
             aperture_dimensions=aperture_dimensions,
             pinhole_radius=pinhole_radius,
             cam_pixels_nb=cam_pixels_nb,
             # returnas
             returnas=returnas,
         )
+
+    # --------------------
+    # plotting
+    # ---------------------
+
+    def plot_crystal_rocking_curve(
+        self,
+        key=None,
+        # option
+        T=None,
+        # plotting
+        dax=None,
+        color=None,
+        plot_FW=None,
+    ):
+
+        return _plot.plot_rocking_curve(
+            coll=self,
+            key=key,
+            # option
+            T=T,
+            # plotting
+            dax=dax,
+            color=color,
+            plot_FW=plot_FW,
+        )
```

### Comparing `tofu-1.6.5/tofu/data/_class06_Grating.py` & `tofu-1.7.0/tofu/data/_class06_Grating.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 import datastock as ds
 
 
 # tofu
 from ._class05_Crystal import Crystal as Previous
 from . import _class3_check
 # from . import _class6_check as _check
-# from . import _class6_compute as _compute
+from . import _class06_compute as _compute
 
 
 __all__ = ['Grating']
 
 
 # #############################################################################
 # #############################################################################
@@ -89,7 +89,15 @@
         dobj['grating'][key]['dmisc'] = _class3_check._dmisc(
             key=key,
             color=color,
         )
 
         # update dicts
         self.update(dref=dref, ddata=ddata, dobj=dobj)
+
+    # ------------
+    # utilities
+    # ------------
+
+    def get_optics_isconvex(self, keys=None):
+        """ return list of bool flags indicating if each optics is convex """
+        return _compute._isconvex(coll=self, keys=keys)
```

### Comparing `tofu-1.6.5/tofu/data/_class07_Camera.py` & `tofu-1.7.0/tofu/data/_class01_Plasma2D.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,284 +1,311 @@
 # -*- coding: utf-8 -*-
 
 
 # Built-in
-# import copy
+import copy
 
 
 # Common
 import numpy as np
 import datastock as ds
 
 
 # tofu
-from ._class06_Grating import Grating as Previous
-from . import _class3_check
-from . import _class7_check as _check
-from . import _class7_compute as _compute
+# from tofu import __version__ as __version__
+from ._class00_Config import Config as Previous
+from . import _class01_compute as _compute
 
 
-__all__ = ['Camera']
+__all__ = ['Plasma2D']
+
+
+_WHICH_MESH = 'mesh'
+_QUANT_R = 'R'
+_QUANT_Z = 'Z'
 
 
 # #############################################################################
 # #############################################################################
-#                           Diagnostic
+#                           Plasma2D
 # #############################################################################
 
 
-class Camera(Previous):
+class Plasma2D(Previous):
 
-    # _ddef = copy.deepcopy(ds.DataStock._ddef)
-    # _ddef['params']['ddata'].update({
-    #       'bsplines': (str, ''),
-    # })
-    # _ddef['params']['dobj'] = None
-    # _ddef['params']['dref'] = None
+    _ddef = copy.deepcopy(Previous._ddef)
 
     # _show_in_summary_core = ['shape', 'ref', 'group']
-    _show_in_summary = 'all'
-
     _dshow = dict(Previous._dshow)
-    _dshow.update({
-        'camera': [
-            'dgeom.type',
-            'dgeom.parallel',
-            'dgeom.shape',
-            'dgeom.ref',
-            'dgeom.pix_area',
-            'dgeom.pix_nb',
-            'dgeom.outline',
-            'dgeom.cent',
-            'dgeom.cents',
-            'dmat.qeff_energy',
-            'dmat.qeff',
-            # 'dmisc.color',
-        ],
-    })
 
-    def _add_camera(
-        self,
-        dref=None,
-        ddata=None,
-        dobj=None,
-        dmat=None,
-        color=None,
-    ):
-        key = list(dobj['camera'].keys())[0]
+    # _quant_R = _QUANT_R
+    # _quant_Z = _QUANT_Z
 
-        # material
-        dref2, ddata2, dmat = _check._dmat(
-            key=key,
-            dmat=dmat,
-        )
+    # -------------------
+    # units conversione
+    # -------------------
 
-        if dmat is not None:
-            if dref2 is not None:
-                dref.update(dref2)
-                ddata.update(ddata2)
-            dobj['camera'][key]['dmat'] = dmat
+    def convert_units_spectral(
+        self,
+        data=None,
+        units=None,
+        units_in=None,
+    ):
 
-        # dmisc
-        dobj['camera'][key]['dmisc'] = _class3_check._dmisc(
-            key=key,
-            color=color,
+        return _compute.convert_spectral_units(
+            coll=self,
+            data=data,
+            units=units,
+            units_in=units_in,
         )
 
-        # update dicts
-        self.update(dref=dref, ddata=ddata, dobj=dobj)
+    # -------------------
+    # get data time
+    # -------------------
 
-    def add_camera_1d(
+    def get_time(
         self,
         key=None,
-        # geometry
-        dgeom=None,
-        # quantum efficiency
-        dmat=None,
-        # dmisc
-        color=None,
+        t=None,
+        indt=None,
+        ind_strict=None,
+        dim=None,
     ):
-        """ add a 1d camera
+        """ Return the time vector or time macthing indices
+
+        hastime, keyt, reft, keyt, val, dind = self.get_time(key='prof0')
 
-        A 1d camera is an unordered set of pixels of indentical outline
-        Its geometry os defined by dgeom
-        Its material properties (i.e: quantum efficiency) in dmat
-
-        The geometry in dgeom must contain:
-            - 'outline_x0': 1st coordinate of planar outline of a single pixel
-            - 'outline_x1': 1st coordinate of planar outline of a single pixel
-            - 'cents_x': x coordinate of the centers of ll pixels
-            - 'cents_y': y coordinate of the centers of ll pixels
-            - 'cents_z': z coordinate of the centers of ll pixels
-            - 'nin_x': x coordinate of inward normal unit vector of all pixels
-            - 'nin_y': y coordinate of inward normal unit vector of all pixels
-            - 'nin_z': z coordinate of inward normal unit vector of all pixels
-            - 'e0_x': x coordinate of e0 unit vector of all pixels
-            - 'e0_y': y coordinate of e0 unit vector of all pixels
-            - 'e0_z': z coordinate of e0 unit vector of all pixels
-            - 'e1_x': x coordinate of e1 unit vector of all pixels
-            - 'e1_y': y coordinate of e1 unit vector of all pixels
-            - 'e1_z': z coordinate of e1 unit vector of all pixels
-
-        The material dict, dmat can contain:
-            - 'energy': a 1d energy vector , in eV
-            - 'qeff': a 1d vector, same size as energy, with values in [0; 1]
+        Return
+        ------
+        hastime:    bool
+            flag, True if key has a time dimension
+        keyt:       None /  str
+            if hastime and a time vector exists, the key to that time vector
+        t:          None / np.ndarray
+            if hastime
+        dind:       dict, with:
+            - indt:  None / np.ndarray
+                if indt or t was provided, and keyt exists
+                int indices of nearest matching times
+            - indtu: None / np.ndarray
+                if indt is returned, np.unique(indt)
+            - indtr: None / np.ndarray
+                if indt is returned, a bool (ntu, nt) array
+            - indok: None / np.ndarray
+                if indt is returned, a bool (nt,) array
 
         """
-        # check / format input
-        dref, ddata, dobj = _check._camera_1d(
-            coll=self,
-            key=key,
-            **dgeom,
-        )
 
-        # add generic parts
-        self._add_camera(
-            dref=dref,
-            ddata=ddata,
-            dobj=dobj,
-            dmat=dmat,
-            color=color,
+        if dim is None:
+            dim = 'time'
+
+        return self.get_ref_vector(
+            key=key,
+            values=t,
+            indices=indt,
+            ind_strict=ind_strict,
+            dim=dim,
         )
 
-    def add_camera_2d(
+    def get_time_common(
         self,
-        key=None,
-        # geometry
-        dgeom=None,
-        # material
-        dmat=None,
-        # dmisc
-        color=None,
+        keys=None,
+        t=None,
+        indt=None,
+        ind_strict=None,
+        dim=None,
     ):
-        """ add a 2d camera
+        """ Return the time vector or time macthing indices
+
+        hastime, hasvect, t, dind = self.get_time_common(
+            keys=['prof0', 'prof1'],
+            t=np.linspace(0, 5, 10),
+        )
 
-        A 2d camera is an ordered 2d grid of pixels of indentical outline
-        Its geometry os defined by dgeom
-        Its material properties (i.e: quantum efficiency) in dmat
-
-        The geometry in dgeom must contain:
-            - 'outline_x0': 1st coordinate of planar outline of a single pixel
-            - 'outline_x1': 1st coordinate of planar outline of a single pixel
-            - 'cent': (x, y, z) coordinate of the center of the camera
-            - 'cents_x0': x0 coordinate of the centers of all pixels
-            - 'cents_x1': x1 coordinate of the centers of all pixels
-            - 'nin': x coordinate of inward normal unit vector of all pixels
-            - 'e0': x coordinate of e0 unit vector of all pixels
-            - 'e1': x coordinate of e1 unit vector of all pixels
-
-        The material dict, dmat can contain:
-            - 'energy': a 1d energy vector , in eV
-            - 'qeff': a 1d vector, same size as energy, with values in [0; 1]
+        Return
+        ------
+        hastime:        bool
+            flag, True if key has a time dimension
+        keyt:           None /  str
+            if hastime and a time vector exists, the key to that time vector
+        t:              None / np.ndarray
+            if hastime
+        indt:           None / np.ndarray
+            if indt or t was provided, and keyt exists
+            int indices of nearest matching times
+        indtu:          None / np.ndarray
+            if indt is returned, np.unique(indt)
+        indt_reverse:   None / np.ndarray
+            if indt is returned, a bool (ntu, nt) array
 
         """
-        # check / format input
-        dref, ddata, dobj = _check._camera_2d(
-            coll=self,
-            key=key,
-            **dgeom,
-        )
 
-        # add generic parts
-        self._add_camera(
-            dref=dref,
-            ddata=ddata,
-            dobj=dobj,
-            dmat=dmat,
-            color=color,
-        )
+        if dim is None:
+            dim = 'time'
 
-    # ---------------
-    # add pinhole cameras
-    # ---------------
+        return self.get_ref_vector_common(
+            keys=keys,
+            values=t,
+            indices=indt,
+            ind_strict=ind_strict,
+            dim=dim,
+        )
 
-    def add_camera_pinhole(
+    def plot_as_profile2d(
         self,
         key=None,
-        key_pinhole=None,
-        key_diag=None,
-        cam_type=None,
-        # position
-        x=None,
-        y=None,
-        R=None,
-        z=None,
-        phi=None,
-        # orientation
-        theta=None,
-        dphi=None,
-        tilt=None,
-        # camera
-        focal=None,
-        pix_nb=None,
-        pix_size=None,
-        pix_spacing=None,
-        # pinhole
-        pinhole_radius=None,
-        pinhole_size=None,
-        # reflections
-        reflections_nb=None,
-        reflections_type=None,
-        # diagnostic
-        compute=None,
-        config=None,
-        length=None,
+        # parameters
+        dres=None,
+        dunique_mesh_2d=None,
+        # levels
+        dlevels=None,
+        ref_com=None,
+        # options
+        plot_details=None,
+        plot_config=None,
+        # ref vectors
+        dref_vectorZ=None,
+        dref_vectorU=None,
+        # interpolation
+        val_out=None,
+        nan0=None,
+        # plot options
+        vmin=None,
+        vmax=None,
+        cmap=None,
+        dax=None,
+        dmargin=None,
+        fs=None,
+        dcolorbar=None,
+        dleg=None,
+        # interactivity
+        dinc=None,
+        connect=True,
     ):
 
-        return _compute.add_camera_pinhole(
-            coll=self,
+        # Plot profile 2d
+        dax, dgroup = super().plot_as_profile2d(
             key=key,
-            key_pinhole=key_pinhole,
-            key_diag=key_diag,
-            cam_type=cam_type,
-            # position
-            x=x,
-            y=y,
-            R=R,
-            z=z,
-            phi=phi,
-            # orientation
-            theta=theta,
-            dphi=dphi,
-            tilt=tilt,
-            # camera
-            focal=focal,
-            pix_nb=pix_nb,
-            pix_size=pix_size,
-            pix_spacing=pix_spacing,
-            # pinhole
-            pinhole_radius=pinhole_radius,
-            pinhole_size=pinhole_size,
-            # reflections
-            reflections_nb=reflections_nb,
-            reflections_type=reflections_type,
-            # diagnostic
-            compute=compute,
-            config=config,
-            length=length,
+            # parameters
+            dres=dres,
+            dunique_mesh_2d=dunique_mesh_2d,
+            # levels
+            dlevels=dlevels,
+            ref_com=ref_com,
+            # details
+            plot_details=plot_details,
+            # ref vectors
+            dref_vectorZ=dref_vectorZ,
+            dref_vectorU=dref_vectorU,
+            # interpolation
+            val_out=val_out,
+            nan0=nan0,
+            # plot options
+            vmin=vmin,
+            vmax=vmax,
+            cmap=cmap,
+            dax=dax,
+            dmargin=dmargin,
+            fs=fs,
+            dcolorbar=dcolorbar,
+            dleg=dleg,
+            connect=False,
         )
 
-    # ---------------
-    # utilities
-    # ---------------
-
-    def get_camera_unit_vectors(self, key=None):
-        """ Return unit vectors components as dict """
-        return _check.get_camera_unitvectors(
-            coll=self,
-            key=key,
-        )
+        # plot config if relevant
+        if plot_config.__class__.__name__ == 'Config':
+            if 'matrix' in dax.dax.keys():
+                ax = dax.dax['matrix']['handle']
+                ax = plot_config.plot(lax=ax, proj='cross')
+
+        # -----------
+        # connect
+
+        if connect is True:
+            dax.setup_interactivity(kinter='inter0', dgroup=dgroup, dinc=dinc)
+            dax.disconnect_old()
+            dax.connect()
+
+            dax.show_commands()
+            return dax
+        else:
+            return dax, dgroup
 
-    def get_camera_cents_xyz(self, key=None):
-        """ Return cents_x, cents_y, cents_z """
-        return _check.get_camera_cents_xyz(
-            coll=self,
-            key=key,
-        )
-
-    def get_as_dict(self, key=None):
-        """ Return the desired object as a dict (input to some routines) """
+    def plot_as_profile2d_compare(
+        self,
+        keys=None,
+        # parameters
+        dres=None,
+        # levels
+        dlevels=None,
+        ref_com=None,
+        # options
+        plot_config=None,
+        plot_details=None,
+        # ref vectors
+        dref_vectorZ=None,
+        dref_vectorU=None,
+        # interpolation
+        val_out=None,
+        nan0=None,
+        # plot options
+        vmin=None,
+        vmax=None,
+        cmap=None,
+        dax=None,
+        dmargin=None,
+        fs=None,
+        dcolorbar=None,
+        dleg=None,
+        # interactivity
+        dinc=None,
+        connect=True,
+    ):
 
-        return _class3_check._return_as_dict(
-            coll=self,
-            key=key,
+        # Plot profile 2d
+        dax, dgroup = super().plot_as_profile2d_compare(
+            keys=keys,
+            # parameters
+            dres=dres,
+            # levels
+            dlevels=dlevels,
+            ref_com=ref_com,
+            # details
+            plot_details=plot_details,
+            # ref vectors
+            dref_vectorZ=dref_vectorZ,
+            dref_vectorU=dref_vectorU,
+            # interpolation
+            val_out=val_out,
+            nan0=nan0,
+            # plot options
+            vmin=vmin,
+            vmax=vmax,
+            cmap=cmap,
+            dax=dax,
+            dmargin=dmargin,
+            fs=fs,
+            dcolorbar=dcolorbar,
+            dleg=dleg,
+            # interactivity
+            connect=False,
         )
+
+        # plot config if relevant
+        if plot_config.__class__.__name__ == 'Config':
+            for kax in ['prof0', 'prof1']:
+                if kax in dax.dax.keys():
+                    ax = dax.dax[kax]['handle']
+                    ax = plot_config.plot(lax=ax, proj='cross')
+
+        # -----------
+        # connect
+
+        if connect is True:
+            dax.setup_interactivity(kinter='inter0', dgroup=dgroup, dinc=dinc)
+            dax.disconnect_old()
+            dax.connect()
+
+            dax.show_commands()
+            return dax
+        else:
+            return dax, dgroup
```

### Comparing `tofu-1.6.5/tofu/data/_class08_Diagnostic.py` & `tofu-1.7.0/tofu/data/_class08_Diagnostic.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 from ._class07_Camera import Camera as Previous
 from . import _class8_check as _check
 from . import _class8_compute as _compute
 from . import _class8_move as _move
 from . import _class8_los_data as _los_data
 from . import _class8_equivalent_apertures as _equivalent_apertures
 from . import _class8_etendue_los as _etendue_los
+from . import _class8_vos as _vos
 from . import _class8_los_angles as _los_angles
 from . import _class8_compute_signal as _compute_signal
 from . import _class8_plot as _plot
 
 
 __all__ = ['Diagnostic']
 
@@ -37,15 +38,17 @@
     _show_in_summary = 'all'
 
     _dshow = dict(Previous._dshow)
     _dshow.update({
         'diagnostic': [
             'is2d',
             'spectro',
+            'PHA',
             'camera',
+            'signal',
         ],
     })
 
     def add_diagnostic(
         self,
         key=None,
         doptics=None,
@@ -56,14 +59,17 @@
         length=None,
         # reflections
         reflections_nb=None,
         reflections_type=None,
         key_nseg=None,
         # compute
         compute=True,
+        add_points=None,
+        # spectro-only
+        rocking_curve_fw=None,
         # others
         verb=None,
         **kwdargs,
     ):
 
         # -----------
         # adding diag
@@ -93,14 +99,17 @@
                 check=False,
                 # los
                 config=config,
                 length=length,
                 reflections_nb=reflections_nb,
                 reflections_type=reflections_type,
                 key_nseg=key_nseg,
+                add_points=add_points,
+                # spectro-only
+                rocking_curve_fw=rocking_curve_fw,
                 # bool
                 verb=verb,
                 plot=False,
                 store='analytical',
             )
 
     # -----------------
@@ -126,14 +135,15 @@
 
     def get_diagnostic_data(
         self,
         key=None,
         key_cam=None,
         data=None,
         rocking_curve=None,
+        units=None,
         **kwdargs,
         ):
         """ Return dict of data for chosen cameras
 
         data can be:
             'etendue'
             'amin'
@@ -147,14 +157,15 @@
         """
         return _compute._get_data(
             coll=self,
             key=key,
             key_cam=key_cam,
             data=data,
             rocking_curve=rocking_curve,
+            units=units,
             **kwdargs,
         )
 
     def get_diagnostic_data_concatenated(
         self,
         key=None,
         key_data=None,
@@ -181,24 +192,27 @@
         # parameters
         analytical=None,
         numerical=None,
         res=None,
         check=None,
         margin_par=None,
         margin_perp=None,
+        # spectro-only
+        rocking_curve_fw=None,
         # equivalent aperture
         add_points=None,
         convex=None,
         # for storing los
         config=None,
         length=None,
         reflections_nb=None,
         reflections_type=None,
         key_nseg=None,
         # bool
+        compute_vos_from_los=None,
         verb=None,
         plot=None,
         store=None,
     ):
         """ Compute the etendue of the diagnostic (per pixel)
 
         Etendue (m2.sr) can be computed analytically or numerically
@@ -213,14 +227,16 @@
             # etendue
             analytical=analytical,
             numerical=numerical,
             res=res,
             check=check,
             margin_par=margin_par,
             margin_perp=margin_perp,
+            # spectro-only
+            rocking_curve_fw=rocking_curve_fw,
             # equivalent aperture
             add_points=add_points,
             convex=convex,
             # bool
             verb=verb,
             plot=plot,
             store=store,
@@ -238,16 +254,73 @@
                 # los
                 config=config,
                 length=length,
                 reflections_nb=reflections_nb,
                 reflections_type=reflections_type,
                 key_nseg=key_nseg,
                 dcompute=dcompute,
+                compute_vos_from_los=compute_vos_from_los,
             )
 
+    def compute_diagnostic_vos(
+        self,
+        key=None,
+        key_mesh=None,
+        # parameters
+        res=None,
+        check=None,
+        margin_par=None,
+        margin_perp=None,
+        # raytracing
+        visibility=None,
+        # spectro-only
+        rocking_curve_fw=None,
+        # equivalent aperture
+        add_points=None,
+        convex=None,
+        # for storing los
+        config=None,
+        length=None,
+        reflections_nb=None,
+        reflections_type=None,
+        key_nseg=None,
+        # bool
+        verb=None,
+        plot=None,
+        store=None,
+        timing=None,
+    ):
+        """ Compute the etendue of the diagnostic (per pixel)
+
+        Etendue (m2.sr) can be computed analytically or numerically
+        If plot, plot the comparison between all computations
+        If store = 'analytical' or 'numerical', overwrites the diag etendue
+
+        """
+
+        dvos = _vos.compute_vos(
+            coll=self,
+            key_diag=key,
+            key_mesh=key_mesh,
+            # etendue
+            res=res,
+            check=check,
+            margin_par=margin_par,
+            margin_perp=margin_perp,
+            config=config,
+            visibility=visibility,
+            # spectro-only
+            rocking_curve_fw=rocking_curve_fw,
+            # bool
+            verb=verb,
+            plot=plot,
+            store=store,
+            timing=timing,
+        )
+
     # ---------------
     # utilities
     # ---------------
 
     def get_diagnostic_equivalent_aperture(
         self,
         key=None,
@@ -290,43 +363,45 @@
 
     def get_diagnostic_lamb(
         self,
         key=None,
         key_cam=None,
         lamb=None,
         rocking_curve=None,
+        units=None,
     ):
         """ Return the wavelength associated to
         - 'lamb'
         - 'lambmin'
         - 'lambmax'
         - 'res' = lamb / (lambmax - lambmin)
 
         """
         return _compute.get_lamb_from_angle(
             coll=self,
             key=key,
             key_cam=key_cam,
             lamb=lamb,
             rocking_curve=rocking_curve,
+            units=units,
         )
 
     # ---------------
     # utilities
     # ---------------
 
     def get_optics_cls(self, optics=None):
         """ Return list of optics and list of their classes
 
         """
         return _check._get_optics_cls(coll=self, optics=optics)
 
     # def get_diagnostic_doptics(self, key=None):
-    #     """ 
-    #     Get dict of optics and corresponding classes 
+    #     """
+    #     Get dict of optics and corresponding classes
 
     #     """
     #     return _check._get_diagnostic_doptics(coll=self, key=key)
 
     def get_optics_outline(
         self,
         key=None,
@@ -365,14 +440,24 @@
             mode=mode,
             closed=closed,
             ravel=ravel,
             total=total,
             return_outline=return_outline,
         )
 
+    def get_optics_as_input_solid_angle(
+        self,
+        keys=None,
+    ):
+        """ Return the optics outline """
+        return _compute.get_optics_as_input_solid_angle(
+            coll=self,
+            keys=keys,
+        )
+
     def set_optics_color(self, key=None, color=None):
         return _check._set_optics_color(
             coll=self,
             key=key,
             color=color,
         )
 
@@ -423,15 +508,15 @@
             theta=theta,
             dphi=dphi,
         )
 
         if compute:
             self.compute_diagnostic_etendue_los(
                 key=key,
-                #e etendue
+                # etendue
                 analytical=True,
                 numerical=False,
                 res=None,
                 check=False,
                 margin_par=margin_par,
                 margin_perp=margin_perp,
                 # equivalent aperture
@@ -480,28 +565,28 @@
             config=config,
             visibility=visibility,
             # return
             return_vect=return_vect,
             return_alpha=return_alpha,
         )
 
-
     def compute_diagnostic_signal(
         self,
         key=None,
         key_diag=None,
         key_cam=None,
         # integrand
         key_integrand=None,
         # sampling
         method=None,
         res=None,
         mode=None,
         groupby=None,
         val_init=None,
+        ref_com=None,
         # signal
         brightness=None,
         # store
         store=None,
         # return
         returnas=None,
     ):
@@ -518,23 +603,23 @@
             key_integrand=key_integrand,
             # sampling
             method=method,
             res=res,
             mode=mode,
             groupby=groupby,
             val_init=val_init,
+            ref_com=ref_com,
             # signal
             brightness=brightness,
             # store
             store=store,
             # return
             returnas=returnas,
         )
 
-
     # -----------------
     # plotting
     # -----------------
 
     def get_diagnostic_dplot(
         self,
         key=None,
@@ -592,17 +677,19 @@
         key_cam=None,
         optics=None,
         elements=None,
         proj=None,
         los_res=None,
         # data plot
         data=None,
+        units=None,
         cmap=None,
         vmin=None,
         vmax=None,
+        alpha=None,
         # config
         plot_config=None,
         # figure
         dax=None,
         dmargin=None,
         fs=None,
         wintit=None,
@@ -619,63 +706,71 @@
             key_cam=key_cam,
             optics=optics,
             elements=elements,
             proj=proj,
             los_res=los_res,
             # data plot
             data=data,
+            units=units,
             cmap=cmap,
             vmin=vmin,
             vmax=vmax,
+            alpha=alpha,
             # config
             plot_config=plot_config,
             # figure
             dax=dax,
             dmargin=dmargin,
             fs=fs,
             wintit=wintit,
             # interactivity
             color_dict=color_dict,
             nlos=nlos,
             dinc=dinc,
             connect=connect,
         )
 
-    def plot_diagnostic_interpolated_along_los(
+    def interpolate_along_los(
         self,
-        key=None,
+        key_diag=None,
         key_cam=None,
-        key_data_x=None,
-        key_data_y=None,
+        key_integrand=None,
+        key_coords=None,
         # sampling
         res=None,
         mode=None,
         segment=None,
         radius_max=None,
+        # interpolating
+        domain=None,
+        val_out=None,
         # plotting
         vmin=None,
         vmax=None,
         plot=None,
         dcolor=None,
         dax=None,
     ):
         """ Compute and plot interpolated data along the los of the diagnostic
 
         """
-        return _los_data._interpolated_along_los(
+        return _los_data._interpolate_along_los(
             coll=self,
-            key=key,
+            key_diag=key_diag,
             key_cam=key_cam,
-            key_data_x=key_data_x,
-            key_data_y=key_data_y,
+            key_integrand=key_integrand,
+            key_coords=key_coords,
             # sampling
             res=res,
             mode=mode,
             segment=segment,
             radius_max=radius_max,
+            # interpolating
+            domain=domain,
+            val_out=val_out,
             # plotting
             vmin=vmin,
             vmax=vmax,
             plot=plot,
             dcolor=dcolor,
             dax=dax,
             )
```

### Comparing `tofu-1.6.5/tofu/data/_class09_GeometryMatrix.py` & `tofu-1.7.0/tofu/data/_class09_GeometryMatrix.py`

 * *Files 14% similar despite different names*

```diff
@@ -96,31 +96,38 @@
     # ------------------
 
     def plot_geometry_matrix(
         self,
         key=None,
         indbf=None,
         indchan=None,
+        # options
         plot_mesh=None,
+        plot_config=None,
+        # parameters
         vmin=None,
         vmax=None,
         res=None,
         cmap=None,
+        # figure
         dax=None,
         dmargin=None,
         fs=None,
         dcolorbar=None,
         dleg=None,
     ):
         return _plot.plot_geometry_matrix(
             coll=self,
             key=key,
             indbf=indbf,
             indchan=indchan,
+            # options
             plot_mesh=plot_mesh,
+            plot_config=plot_config,
+            # parameters
             vmin=vmin,
             vmax=vmax,
             res=res,
             cmap=cmap,
             dax=dax,
             dmargin=dmargin,
             fs=fs,
```

### Comparing `tofu-1.6.5/tofu/data/_class10_algos.py` & `tofu-1.7.0/tofu/data/_class10_algos.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,19 @@
+# -*- coding: utf-8 -*-
 
 
+import copy
 import warnings
 
 
 import numpy as np
 import scipy.linalg as scplin
 import scipy.optimize as scpop
 import scipy.sparse as scpsp
+import datastock as ds
 
 
 dfail = {}
 try:
     import sksparse as sksp
 except Exception as err:
     sksp = False
@@ -27,20 +30,263 @@
     msg = (
         "Consider installing the following for faster inversions:\n"
         + "\n".join(lstr)
     )
     warnings.warn(msg)
 
 
+# optional
+try:
+    from .. import tomotok2tofu
+except Exception as err:
+    tomotok2tofu = False
+
+
+_DALGO0 = {
+    'algo0': {
+        'source': 'tofu',
+        'family': 'Phillips-Tikhonov',
+        'reg_operator': 'any linear',
+        'reg_param': 'augTikho',
+        'decomposition': '',
+        'positive': False,
+        'sparse': True,
+        'isotropic': True,
+        'func': 'inv_linear_augTikho_sparse',
+    },
+    'algo1': {
+        'source': 'tofu',
+        'family': 'Phillips-Tikhonov',
+        'reg_operator': 'any linear',
+        'reg_param': 'augTikho',
+        'decomposition': '',
+        'positive': False,
+        'sparse': False,
+        'isotropic': True,
+        'func': 'inv_linear_augTikho_dense',
+    },
+    'algo2': {
+        'source': 'tofu',
+        'family': 'Phillips-Tikhonov',
+        'reg_operator': 'any linear',
+        'reg_param': 'augTikho',
+        'decomposition': 'cholesky',
+        'positive': False,
+        'sparse': False,
+        'isotropic': True,
+        'func': 'inv_linear_augTikho_chol_dense',
+    },
+    'algo3': {
+        'source': 'tofu',
+        'family': 'Phillips-Tikhonov',
+        'reg_operator': 'any linear',
+        'reg_param': 'augTikho',
+        'decomposition': 'cholesky',
+        'positive': False,
+        'sparse': True,
+        'isotropic': True,
+        'func': 'inv_linear_augTikho_chol_sparse',
+    },
+    'algo4': {
+        'source': 'tofu',
+        'family': 'Phillips-Tikhonov',
+        'reg_operator': 'any linear',
+        'reg_param': 'augTikho',
+        'decomposition': '',
+        'positive': True,
+        'sparse': False,
+        'isotropic': True,
+        'func': 'inv_linear_augTikho_pos_dense',
+    },
+    'algo5': {
+        'source': 'tofu',
+        'family': 'Phillips-Tikhonov',
+        'reg_operator': 'any linear',
+        'reg_param': 'DisPrinc',
+        'decomposition': '',
+        'positive': False,
+        'sparse': True,
+        'isotropic': True,
+        'func': 'inv_linear_DisPrinc_sparse',
+    },
+    'algo6': {
+        'source': 'tofu',
+        'family': 'Non-regularized',
+        'reg_operator': None,
+        'reg_param': None,
+        'decomposition': '',
+        'positive': False,
+        'sparse': True,
+        'isotropic': True,
+        'func': 'inv_linear_leastsquares_bounds',
+    },
+    'algo7': {
+        'source': 'tofu',
+        'family': 'Non-regularized',
+        'reg_operator': None,
+        'reg_param': None,
+        'decomposition': '',
+        'positive': True,
+        'sparse': True,
+        'isotropic': True,
+        'func': 'inv_linear_leastsquares_bounds',
+    },
+}
+
+
 # #############################################################################
 # #############################################################################
-#                      Basic routines - augmented tikhonov
+#                           info
 # #############################################################################
 
 
+def get_available_inversions_algo(
+    # for filtering
+    source=None,
+    family=None,
+    reg_operator=None,
+    reg_param=None,
+    decomposition=None,
+    positive=None,
+    sparse=None,
+    isotropic=None,
+    dalgo=None,
+    # parameters
+    returnas=None,
+    verb=None,
+):
+
+    # --------------
+    # check inputs
+
+    returnas = ds._generic_check._check_var(
+        returnas,
+        'returnas',
+        default=False,
+        allowed=[False, dict, list, str]
+    )
+
+    verb = ds._generic_check._check_var(
+        verb,
+        'verb',
+        default=returnas is False,
+        types=bool,
+    )
+
+    # ------------------------------------
+    # filter according to criteria, if any
+
+    dalgo = match_algo(
+        # filtering
+        source=source,
+        family=family,
+        reg_operator=reg_operator,
+        reg_param=reg_param,
+        decomposition=decomposition,
+        positive=positive,
+        sparse=sparse,
+        isotropic=isotropic,
+    )
+
+    # complemet with name
+    for k0 in dalgo.keys():
+        dalgo[k0]['name'] = k0
+
+    # ------------
+    # print or str
+
+    if verb is True or returnas is str:
+
+        head = ['key'] + [
+            'source', 'family', 'reg_operator', 'reg_param', 'decomposition',
+            'positive', 'sparse',
+        ]
+        sep = ['-'*len(kk) for kk in head]
+        lstr = [head, sep] + [
+            [k0] + [v0[k1] for k1 in head[1:]]
+            for k0, v0 in dalgo.items()
+        ]
+
+        nmax = np.max(np.char.str_len(np.char.array(lstr)), axis=0)
+        lstr = [
+            '  '.join([str(ss).ljust(nmax[ii]) for ii, ss in enumerate(line)])
+            for line in lstr
+        ]
+        msg = "\n".join(lstr)
+
+        if verb:
+            print(msg)
+
+    # -------
+    # return
+
+    if returnas is dict:
+        return dalgo
+    elif returnas is list:
+        return sorted(dalgo.keys())
+    elif returnas is str:
+        return msg
+
+
+def match_algo(
+    source=None,
+    family=None,
+    reg_operator=None,
+    reg_param=None,
+    decomposition=None,
+    positive=None,
+    sparse=None,
+    isotropic=None,
+):
+
+    # ------------
+    # check inputs
+
+    dargs = {
+        k0: v0 for k0, v0 in locals().items()
+        if v0 is not None
+    }
+
+    # --------------
+    # Get tofu algo
+
+    dalgo = _DALGO0
+
+    # -----------------
+    # Get tomotok algo
+
+    if tomotok2tofu is not False:
+        dalgo.update(tomotok2tofu.get_dalgo())
+
+    # ------------
+    # find matches
+
+    if len(dargs) > 0:
+        lmatch = [
+            k0 for k0, v0 in dalgo.items()
+            if all([v0[k1] == v1 for k1, v1 in dargs.items()])
+        ]
+        if len(lmatch) == 0:
+            lstr = [f'\t- {k0}: {v0}' for k0, v0 in dargs.items()]
+            msg = (
+                "No / several algorithms matching the following criteria:\n"
+                + "\n".join(lstr)
+            )
+            raise Exception(msg)
+        dalgo = {k0: v0 for k0, v0 in dalgo.items() if k0 in lmatch}
+
+    return copy.deepcopy(dalgo)
+
+
+# ################################################################
+# ################################################################
+#                      Basic routines - augmented tikhonov
+# ################################################################
+
+
 def inv_linear_augTikho_dense(
     Tn=None,
     TTn=None,
     Tyn=None,
     R=None,
     yn=None,
     sol0=None,
@@ -52,14 +298,15 @@
     b0=None,
     a1bis=None,
     b1=None,
     d=None,
     conv_reg=True,
     verb=None,
     verb2head=None,
+    maxiter_outer=None,
     **kwdargs,
 ):
     """
     Linear algorithm for Phillips-Tikhonov regularisation
     Called "Augmented Tikhonov", dense matrix version
     """
 
@@ -75,56 +322,41 @@
         print(
             f"{verb2head}\n\t\t\t {temp} = {nchan*chi2n + mu0*reg:.3e}",
             end='\n',
         )
 
     # loop
     # Continue until convergence criterion, and at least 2 iterations
-    while niter < 2 or conv > conv_crit:
+    while niter < 2 or (conv > conv_crit and niter < maxiter_outer):
 
         # call solver
         sol = scplin.solve(
             TTn + mu0*R, Tyn,
-            assume_a='pos',      # faster than 'sym'
+            assume_a='pos',      # 'pos' faster than 'sym'
             overwrite_a=True,    # no significant gain
             overwrite_b=False,   # True is faster, but a copy of Tyn is needed
             check_finite=False,  # small speed gain compared to True
             transposed=False,
         )  # 3
 
-        # compute residu, regularity...
-        res2 = np.sum((Tn.dot(sol)-yn)**2)  # residu**2
-        reg = sol.dot(R.dot(sol))           # regularity term
-
-        # update lamb, tau
-        lamb = a0bis/(0.5*reg + b0)           # Update reg. param. estimate
-        tau = a1bis/(0.5*res2 + b1)           # Update noise coef. estimate
-        mu1 = (lamb/tau) * (2*a1bis/res2)**d  # rescale mu with noise estimate
-
-        # Compute convergence variable
-        if conv_reg:
-            conv = np.abs(mu1 - mu0) / mu1
-        else:
-            sol2 = sol**2
-            sol2max = np.max(sol2)
-            sol2[sol2 < 0.001*sol2max] = 0.001*sol2max
-            conv = np.sqrt(np.sum((sol - sol0)**2 / sol2) / nbs)
-
-        # verb
-        if verb >= 2:
-            temp1 = f"{nchan} * {res2/nchan:.3e} + {mu1:.3e} * {reg:.3e}"
-            temp2 = f"{res2 + mu1*reg:.3e}"
-            temp = f"{temp1} = {temp2}"
-            print(f"\t\t{niter} \t {temp}   {tau:.3e}   {conv:.3e}")
+        # call augmented Tikhonov update of mu
+        mu1, conv, res2, reg, tau, lamb = _augTikho_update(
+            Tn, sol, yn, R,
+            a0bis, b0, a1bis, b1,
+            d, mu0, conv_reg, nbs, sol0,
+            # verb
+            verb=verb,
+            nchan=nchan,
+            niter=niter,
+        )
 
         # update sol0, mu0 for next iteration
         sol0[:] = sol[:]
         mu0 = mu1
         niter += 1
-
     return sol, mu1, res2/nchan, reg, niter, [tau, lamb]
 
 
 def inv_linear_augTikho_sparse(
     Tn=None,
     TTn=None,
     Tyn=None,
@@ -139,14 +371,15 @@
     b0=None,
     a1bis=None,
     b1=None,
     d=None,
     conv_reg=True,
     verb=None,
     verb2head=None,
+    maxiter_outer=None,
     maxiter=None,
     tol=None,
     precond=None,       # test
     **kwdargs,
 ):
     """
     Linear algorithm for Phillips-Tikhonov regularisation
@@ -164,17 +397,29 @@
         reg = sol0.dot(R.dot(sol0))
         temp = f"{nchan} * {chi2n:.3e} + {mu0:.3e} * {reg:.3e}"
         print(
             f"{verb2head}\n\t\t\t {temp} = {nchan*chi2n + mu0*reg:.3e}",
             end='\n',
         )
 
+    # import matplotlib.pyplot as plt # DB
+    # import datastock as ds
+    # print(R.shape, Tn.shape)
+    # print()
+    # ds.plot_as_array(R)
+    # ds.plot_as_array(Tn)
+    # ds.plot_as_array(yn)
+    # ds.plot_as_array(sol0)
+    # ds.plot_as_array(Tn.dot(sol0))
+
+    # raise Exception()
+
     # loop
     # Continue until convergence criterion, and at least 2 iterations
-    while niter < 2 or conv > conv_crit:
+    while niter < 2 or (conv > conv_crit and niter < maxiter_outer):
 
         # sol = scpsp.linalg.spsolve(
         #    TTn + mu0*R, Tyn,
         #    permc_spec=None,
         #    use_umfpack=True,
         # )
 
@@ -183,42 +428,29 @@
             TTn + mu0*R, Tyn,
             x0=sol0,
             tol=tol,
             maxiter=maxiter,
             M=precond,
         )
 
-        res2 = np.sum((Tn.dot(sol)-yn)**2)    # residu**2
-        reg = sol.dot(R.dot(sol))             # regularity term
-
-        lamb = a0bis/(0.5*reg + b0)           # Update reg. param. estimate
-        tau = a1bis/(0.5*res2 + b1)           # Update noise coef. estimate
-        mu1 = (lamb/tau) * (2*a1bis/res2)**d  # rescale mu with noise estimate
-
-        # Compute convergence variable
-        if conv_reg:
-            conv = np.abs(mu1 - mu0) / mu1
-        else:
-            sol2 = sol**2
-            sol2max = np.max(sol2)
-            sol2[sol2 < 0.001*sol2max] = 0.001*sol2max
-            conv = np.sqrt(np.sum((sol - sol0)**2 / sol2) / nbs)
-
-        # verb
-        if verb >= 2:
-            temp1 = f"{nchan} * {res2/nchan:.3e} + {mu1:.3e} * {reg:.3e}"
-            temp2 = f"{res2 + mu1*reg:.3e}"
-            temp = f"{temp1} = {temp2}"
-            print(
-                f"\t\t{niter} \t {temp}   {tau:.3e}   {conv:.3e}"
-            )
+        # call augmented Tikhonov update of mu
+        mu1, conv, res2, reg, tau, lamb = _augTikho_update(
+            Tn, sol, yn, R,
+            a0bis, b0, a1bis, b1,
+            d, mu0, conv_reg, nbs, sol0,
+            # verb
+            verb=verb,
+            nchan=nchan,
+            niter=niter,
+        )
 
         sol0[:] = sol[:]            # Update reference solution
         niter += 1                  # Update number of iterations
         mu0 = mu1
+
     return sol, mu1, res2/nchan, reg, niter, [tau, lamb]
 
 
 def inv_linear_augTikho_chol_dense(
     Tn=None,
     TTn=None,
     Tyn=None,
@@ -233,14 +465,15 @@
     b0=None,
     a1bis=None,
     b1=None,
     d=None,
     conv_reg=True,
     verb=None,
     verb2head=None,
+    maxiter_outer=None,
     **kwdargs,
 ):
     """
     """
 
     conv = 0.           # convergence variable
     niter = 0           # number of iterations
@@ -254,15 +487,15 @@
         print(
             f"{verb2head}\n\t\t\t {temp} = {nchan*chi2n + mu0*reg:.3e}",
             end='\n',
         )
 
     # loop
     # Continue until convergence criterion, and at least 2 iterations
-    while niter < 2 or conv > conv_crit:
+    while niter < 2 or (conv > conv_crit and niter < maxiter_outer):
         try:
             # choleski decomposition requires det(TT + mu0*LL) != 0
             # (chol(A).T * chol(A) = A
             chol = scplin.cholesky(
                 TTn + mu0*R,
                 lower=False,
                 check_finite=False,
@@ -281,38 +514,24 @@
                 assume_a='sym',         # chol failed => not 'pos'
                 overwrite_a=True,       # no significant gain
                 overwrite_b=False,      # True faster, but a copy of Tyn needed
                 check_finite=False,     # small speed gain compared to True
                 transposed=False,
             )  # 3
 
-        # compute residu, regularity...
-        res2 = np.sum((Tn.dot(sol)-yn)**2)  # residu**2
-        reg = sol.dot(R.dot(sol))           # regularity term
-
-        # update lamb, tau
-        lamb = a0bis/(0.5*reg + b0)           # Update reg. param. estimate
-        tau = a1bis/(0.5*res2 + b1)           # Update noise coef. estimate
-        mu1 = (lamb/tau) * (2*a1bis/res2)**d  # mu rescale with noise estimate
-
-        # Compute convergence variable
-        if conv_reg:
-            conv = np.abs(mu1 - mu0) / mu1
-        else:
-            sol2 = sol**2
-            sol2max = np.max(sol2)
-            sol2[sol2 < 0.001*sol2max] = 0.001*sol2max
-            conv = np.sqrt(np.sum((sol - sol0)**2 / sol2) / nbs)
-
-        # verb
-        if verb >= 2:
-            temp1 = f"{nchan} * {res2/nchan:.3e} + {mu1:.3e} * {reg:.3e}"
-            temp2 = f"{res2 + mu1*reg:.3e}"
-            temp = f"{temp1} = {temp2}"
-            print(f"\t\t{niter} \t {temp}   {tau:.3e}   {conv:.3e}")
+        # call augmented Tikhonov update of mu
+        mu1, conv, res2, reg, tau, lamb = _augTikho_update(
+            Tn, sol, yn, R,
+            a0bis, b0, a1bis, b1,
+            d, mu0, conv_reg, nbs, sol0,
+            # verb
+            verb=verb,
+            nchan=nchan,
+            niter=niter,
+        )
 
         # update sol0, mu0 for next iteration
         sol0[:] = sol[:]
         mu0 = mu1
         niter += 1
 
     return sol, mu1, res2/nchan, reg, niter, [tau, lamb]
@@ -333,44 +552,17 @@
     b0=None,
     a1bis=None,
     b1=None,
     d=None,
     conv_reg=True,
     verb=None,
     verb2head=None,
+    maxiter_outer=None,
     **kwdargs,
 ):
-    """
-    Linear algorithm for Phillips-Tikhonov regularisation
-    Called "Augmented Tikhonov"
-
-    Augmented in the sense that bayesian statistics are combined
-        with standard Tikhonov regularisation
-    Determines both noise (common multiplicative coefficient) and
-        regularisation parameter automatically
-    We assume here that all arrays are scaled (noise, conditioning...)
-    Sparse matrixes are also prefered to speed-up the computation
-
-    In this method:
-      tau is an approximation of the inverse of the noise coefficient
-      lamb is an approximation of the regularisation parameter
-
-    N.B.: The noise and reg. param. have probability densities of the form:
-        f(x) = x^(a-1) * exp(-bx)
-    This function's maximum is in x = (a-1)/b, so a = b+1 gives a maximum at 1.
-        (a0, b0) for the reg. param.
-        (a1, b1) for the noise estimate
-
-    Ref:
-      [1] Jin B., Zou J., Inverse Problems, vol.25, nb.2, 025001, 2009
-      [2] http://www.math.uni-bremen.de/zetem/cms/media.php/250/nov14talk_jin%20bangti.pdf
-      [3] Kazufumi Ito, Bangti Jin, Jun Zou,
-        "A New Choice Rule for Regularization Parameters in Tikhonov
-        Regularization", Research report, University of Hong Kong, 2008
-    """
 
     conv = 0.           # convergence variable
     niter = 0           # number of iterations
     mu1 = 0.            # regularisation param
 
     # verb
     if verb >= 2:
@@ -381,15 +573,15 @@
             f"{verb2head}\n\t\t\t {temp} = {nchan*chi2n + mu0*reg:.3e}",
             end='\n',
         )
 
     # loop
     # Continue until convergence criterion, and at least 2 iterations
     factor = None
-    while niter < 2 or conv > conv_crit:
+    while niter < 2 or (conv > conv_crit and niter < maxiter_outer):
         try:
             # choleski decomposition requires det(TT + mu0*LL) != 0
             # A = (chol(A).T * chol(A)
             # optimal if matrix is csc
             if sksp is False:
                 factor = scpsp.linalg.factorized(TTn + mu0*R)
                 sol = factor(Tyn)
@@ -410,38 +602,24 @@
             # call solver
             sol = scpsp.linalg.spsolve(
                 TTn + mu0*R, Tyn,
                 permc_spec=None,
                 use_umfpack=True,
             )
 
-        # compute residu, regularity...
-        res2 = np.sum((Tn.dot(sol)-yn)**2)  # residu**2
-        reg = sol.dot(R.dot(sol))           # regularity term
-
-        # update lamb, tau
-        lamb = a0bis/(0.5*reg + b0)             # Update reg. param. estimate
-        tau = a1bis/(0.5*res2 + b1)             # Update noise coef. estimate
-        mu1 = (lamb/tau) * (2*a1bis/res2)**d    # Update reg. param. rescaling
-
-        # Compute convergence variable
-        if conv_reg:
-            conv = np.abs(mu1 - mu0) / mu1
-        else:
-            sol2 = sol**2
-            sol2max = np.max(sol2)
-            sol2[sol2 < 0.001*sol2max] = 0.001*sol2max
-            conv = np.sqrt(np.sum((sol - sol0)**2 / sol2) / nbs)
-
-        # verb
-        if verb >= 2:
-            temp1 = f"{nchan} * {res2/nchan:.3e} + {mu1:.3e} * {reg:.3e}"
-            temp2 = f"{res2 + mu1*reg:.3e}"
-            temp = f"{temp1} = {temp2}"
-            print(f"\t\t{niter} \t {temp}   {tau:.3e}   {conv:.3e}")
+        # call augmented Tikhonov update of mu
+        mu1, conv, res2, reg, tau, lamb = _augTikho_update(
+            Tn, sol, yn, R,
+            a0bis, b0, a1bis, b1,
+            d, mu0, conv_reg, nbs, sol0,
+            # verb
+            verb=verb,
+            nchan=nchan,
+            niter=niter,
+        )
 
         # update sol0, mu0 for next iteration
         sol0[:] = sol[:]
         mu0 = mu1
         niter += 1
 
     return sol, mu1, res2/nchan, reg, niter, [tau, lamb]
@@ -462,14 +640,15 @@
     b0=None,
     a1bis=None,
     b1=None,
     d=None,
     conv_reg=True,
     verb=None,
     verb2head=None,
+    maxiter_outer=None,
     # specific
     method=None,
     options=None,
     bounds=None,
     func_val=None,
     func_jac=None,
     func_hess=None,
@@ -491,77 +670,140 @@
         reg = sol0.dot(R.dot(sol0))
         temp = f"{nchan} * {chi2n:.3e} + {mu0:.3e} * {reg:.3e}"
         print(
             f"{verb2head}\n\t\t\t {temp} = {nchan*chi2n + mu0*reg:.3e}",
             end='\n',
         )
 
-    while niter < 2 or conv > conv_crit:
+    while niter < 2 or (conv > conv_crit and niter < maxiter_outer):
         # quadratic method for positivity constraint
         sol = scpop.minimize(
             func_val, sol0,
             args=(mu0, Tn, yn, TTn, Tyn),
             jac=func_jac,
             hess=func_hess,
             method=method,
             bounds=bounds,
             options=options,
         ).x
 
-        # compute residu, regularity...
-        res2 = np.sum((Tn.dot(sol)-yn)**2)  # residu**2
-        reg = sol.dot(R.dot(sol))           # regularity term
-
-        # update lamb, tau
-        lamb = a0bis/(0.5*reg + b0)             # Update reg. param. estimate
-        tau = a1bis/(0.5*res2 + b1)             # Update noise coef. estimate
-        mu1 = (lamb/tau) * (2*a1bis/res2)**d    # Update reg. param. rescaling
-
-        # Compute convergence variable
-        if conv_reg:
-            conv = np.abs(mu1 - mu0) / mu1
-        else:
-            sol2 = sol**2
-            sol2max = np.max(sol2)
-            sol2[sol2 < 0.001*sol2max] = 0.001*sol2max
-            conv = np.sqrt(np.sum((sol - sol0)**2 / sol2) / nbs)
-
-        # verb
-        if verb >= 2:
-            temp1 = f"{nchan} * {res2/nchan:.3e} + {mu1:.3e} * {reg:.3e}"
-            temp2 = f"{res2 + mu1*reg:.3e}"
-            temp = f"{temp1} = {temp2}"
-            print(f"\t\t{niter} \t {temp}   {tau:.3e}   {conv:.3e}")
+        # call augmented Tikhonov update of mu
+        mu1, conv, res2, reg, tau, lamb = _augTikho_update(
+            Tn, sol, yn, R,
+            a0bis, b0, a1bis, b1,
+            d, mu0, conv_reg, nbs, sol0,
+            # verb
+            verb=verb,
+            nchan=nchan,
+            niter=niter,
+        )
 
         # update sol0, mu0 for next iteration
         sol0[:] = sol[:]
         mu0 = mu1
         niter += 1
 
     return sol, mu1, res2/nchan, reg, niter, [tau, lamb]
 
 
-# #############################################################################
-# #############################################################################
+def _augTikho_update(
+    Tn, sol, yn, R,
+    a0bis, b0, a1bis, b1,
+    d, mu0, conv_reg, nbs, sol0,
+    # verb
+    verb=None,
+    nchan=None,
+    niter=None,
+):
+    """
+    Linear algorithm for Phillips-Tikhonov regularisation
+    Called "Augmented Tikhonov"
+
+    Augmented in the sense that bayesian statistics are combined
+        with standard Tikhonov regularisation
+    Determines both noise (common multiplicative coefficient) and
+        regularisation parameter automatically
+    We assume here that all arrays are scaled (noise, conditioning...)
+    Sparse matrixes are also prefered to speed-up the computation
+
+    In this method:
+      tau is an approximation of the inverse of the noise coefficient
+      lamb is an approximation of the regularisation parameter
+
+    N.B.: The noise and reg. param. have probability densities of the form:
+        f(x) = x^(a-1) * exp(-bx)
+    This function's maximum is in x = (a-1)/b, so a = b+1 gives a maximum at 1.
+        (a0, b0) for the reg. param.
+        (a1, b1) for the noise estimate
+
+    Ref:
+      [1] Jin B., Zou J., Inverse Problems, vol.25, nb.2, 025001, 2009
+      [2] http://www.math.uni-bremen.de/zetem/cms/media.php/250/nov14talk_jin%20bangti.pdf
+      [3] Kazufumi Ito, Bangti Jin, Jun Zou,
+        "A New Choice Rule for Regularization Parameters in Tikhonov
+        Regularization", Research report, University of Hong Kong, 2008
+    """
+
+    res2 = np.sum((Tn.dot(sol)-yn)**2)    # residu**2
+    reg = sol.dot(R.dot(sol))             # regularity term
+
+    lamb = a0bis/(0.5*reg + b0)           # Update reg. param. estimate
+    tau = a1bis/(0.5*res2 + b1)           # Update noise coef. estimate
+
+    # original formula
+    mu1 = (lamb/tau) * (2*a1bis/res2)**d  # rescale mu with noise estimate
+    # mu1 = (lamb/tau) * (2*a1bis/max(res2, 1e-3))**d  # rescale mu with noise estimate
+
+    # print()
+    # print(conv_reg, d)
+    # print('\t a0bis, b0:', a0bis, b0)
+    # print('\t a1bis, b1', a1bis, b1)
+    # print('\t res2, reg:', res2, reg)
+    # print('\t lamb, tau:', lamb, tau)
+    # print('\t mu comp.:', lamb/tau, (2*a1bis/res2)**d, mu1)
+    # print()
+
+    # Compute convergence variable
+    if conv_reg:
+        conv = np.abs(mu1 - mu0) / mu1
+    else:
+        sol2 = sol**2
+        sol2max = np.max(sol2)
+        sol2[sol2 < 0.001*sol2max] = 0.001*sol2max
+        conv = np.sqrt(np.sum((sol - sol0)**2 / sol2) / nbs)
+
+    # verb
+    if verb >= 2:
+        temp1 = f"{nchan} * {res2/nchan:.3e} + {mu1:.3e} * {reg:.3e}"
+        temp2 = f"{res2 + mu1*reg:.3e}"
+        temp = f"{temp1} = {temp2}"
+        print(f"\t\t{niter} \t {temp}   {tau:.3e}   {conv:.3e}")
+
+    return mu1, conv, res2, reg, tau, lamb
+
+
+# ################################################################
+# ################################################################
 #               Basic routines - discrepancy principle
-# #############################################################################
+# ################################################################
 
 
 def inv_linear_DisPrinc_sparse(
     Tn=None,
     TTn=None,
     Tyn=None,
     R=None,
     yn=None,
     sol0=None,
     nchan=None,
     mu0=None,
     precond=None,
     verb=None,
     verb2head=None,
+    maxiter_outer=None,
     # specific
     chi2n_tol=None,
     chi2n_obj=None,
     maxiter=None,
     tol=None,
     **kwdargs,
 ):
@@ -579,15 +821,16 @@
         reg = sol0.dot(R.dot(sol0))
         temp = f"{nchan} * {lchi2n[0]:.3e} + {mu0:.3e} * {reg:.3e}"
         print(
             f"{verb2head}\n\t\t\t {temp} = {nchan*lchi2n[0] + mu0*reg:.3e}",
             end='\n',
         )
 
-    while niter == 0 or np.abs(lchi2n[-1] - chi2n_obj) > chi2n_tol:
+    while niter < 2 or (np.abs(lchi2n[-1] - chi2n_obj) > chi2n_tol and niter < maxiter_outer):
+
         sol, itconv = scpsp.linalg.cg(
             TTn + lmu[-1]*R, Tyn,
             x0=sol0,
             tol=tol,
             maxiter=maxiter,
             M=precond,
         )
@@ -730,7 +973,16 @@
 
     if dconstraints is None:
         return res.x, None, chi2n, None, res.nit, None
     else:
         return (
             dconstraints['coefs'].dot(res.x) + dconstraints['offset']
         )
+
+
+# ##################################################################
+# ##################################################################
+#               _DALGO at import time
+# ##################################################################
+
+
+_DALGO = get_available_inversions_algo(returnas=dict, verb=False)
```

### Comparing `tofu-1.6.5/tofu/data/_class10_checks.py` & `tofu-1.7.0/tofu/data/_class10_checks.py`

 * *Files 11% similar despite different names*

```diff
@@ -8,268 +8,29 @@
 
 # Common
 import numpy as np
 import scipy.sparse as scpsp
 import datastock as ds
 
 
-# optional
-try:
-    from .. import tomotok2tofu
-except Exception as err:
-    tomotok2tofu = False
+from . import _class10_algos as _algos
+from . import _class10_refs as _refs
 
 
 _SIGMA = 0.05
-
-
-_DALGO0 = {
-    'algo0': {
-        'source': 'tofu',
-        'family': 'Phillips-Tikhonov',
-        'reg_operator': 'any linear',
-        'reg_param': 'augTikho',
-        'decomposition': '',
-        'positive': False,
-        'sparse': True,
-        'isotropic': True,
-        'func': 'inv_linear_augTikho_sparse',
-    },
-    'algo1': {
-        'source': 'tofu',
-        'family': 'Phillips-Tikhonov',
-        'reg_operator': 'any linear',
-        'reg_param': 'augTikho',
-        'decomposition': '',
-        'positive': False,
-        'sparse': False,
-        'isotropic': True,
-        'func': 'inv_linear_augTikho_dense',
-    },
-    'algo2': {
-        'source': 'tofu',
-        'family': 'Phillips-Tikhonov',
-        'reg_operator': 'any linear',
-        'reg_param': 'augTikho',
-        'decomposition': 'cholesky',
-        'positive': False,
-        'sparse': False,
-        'isotropic': True,
-        'func': 'inv_linear_augTikho_chol_dense',
-    },
-    'algo3': {
-        'source': 'tofu',
-        'family': 'Phillips-Tikhonov',
-        'reg_operator': 'any linear',
-        'reg_param': 'augTikho',
-        'decomposition': 'cholesky',
-        'positive': False,
-        'sparse': True,
-        'isotropic': True,
-        'func': 'inv_linear_augTikho_chol_sparse',
-    },
-    'algo4': {
-        'source': 'tofu',
-        'family': 'Phillips-Tikhonov',
-        'reg_operator': 'any linear',
-        'reg_param': 'augTikho',
-        'decomposition': '',
-        'positive': True,
-        'sparse': False,
-        'isotropic': True,
-        'func': 'inv_linear_augTikho_pos_dense',
-    },
-    'algo5': {
-        'source': 'tofu',
-        'family': 'Phillips-Tikhonov',
-        'reg_operator': 'any linear',
-        'reg_param': 'DisPrinc',
-        'decomposition': '',
-        'positive': False,
-        'sparse': True,
-        'isotropic': True,
-        'func': 'inv_linear_DisPrinc_sparse',
-    },
-    'algo6': {
-        'source': 'tofu',
-        'family': 'Non-regularized',
-        'reg_operator': None,
-        'reg_param': None,
-        'decomposition': '',
-        'positive': False,
-        'sparse': True,
-        'isotropic': True,
-        'func': 'inv_linear_leastsquares_bounds',
-    },
-    'algo7': {
-        'source': 'tofu',
-        'family': 'Non-regularized',
-        'reg_operator': None,
-        'reg_param': None,
-        'decomposition': '',
-        'positive': True,
-        'sparse': True,
-        'isotropic': True,
-        'func': 'inv_linear_leastsquares_bounds',
-    },
-}
 _LREGPARAM_ALGO = [
     'augTikho',
     'DisPrinc',
 ]
 
 
-# #############################################################################
-# #############################################################################
-#                           info
-# #############################################################################
-
-
-def get_available_inversions_algo(
-    # for filtering
-    source=None,
-    family=None,
-    reg_operator=None,
-    reg_param=None,
-    decomposition=None,
-    positive=None,
-    sparse=None,
-    isotropic=None,
-    dalgo=None,
-    # parameters
-    returnas=None,
-    verb=None,
-):
-
-    # --------------
-    # check inputs
-
-    returnas = ds._generic_check._check_var(
-        returnas,
-        'returnas',
-        default=False,
-        allowed=[False, dict, list, str]
-    )
-
-    verb = ds._generic_check._check_var(
-        verb,
-        'verb',
-        default=returnas is False,
-        types=bool,
-    )
-
-    # ------------------------------------
-    # filter according to criteria, if any
-
-    dalgo = match_algo(
-        # filtering
-        source=source,
-        family=family,
-        reg_operator=reg_operator,
-        reg_param=reg_param,
-        decomposition=decomposition,
-        positive=positive,
-        sparse=sparse,
-        isotropic=isotropic,
-    )
-
-    # complemet with name
-    for k0 in dalgo.keys():
-        dalgo[k0]['name'] = k0
-
-    # ------------
-    # print or str
-
-    if verb is True or returnas is str:
-
-        head = ['key'] + [
-            'source', 'family', 'reg_operator', 'reg_param', 'decomposition',
-            'positive', 'sparse',
-        ]
-        sep = ['-'*len(kk) for kk in head]
-        lstr = [head, sep] + [
-            [k0] + [v0[k1] for k1 in head[1:]]
-            for k0, v0 in dalgo.items()
-        ]
-
-        nmax = np.max(np.char.str_len(np.char.array(lstr)), axis=0)
-        lstr = [
-            '  '.join([str(ss).ljust(nmax[ii]) for ii, ss in enumerate(line)])
-            for line in lstr
-        ]
-        msg = "\n".join(lstr)
-
-        if verb:
-            print(msg)
-
-    # -------
-    # return
-
-    if returnas is dict:
-        return dalgo
-    elif returnas is list:
-        return sorted(dalgo.keys())
-    elif returnas is str:
-        return msg
-
-
-def match_algo(
-    source=None,
-    family=None,
-    reg_operator=None,
-    reg_param=None,
-    decomposition=None,
-    positive=None,
-    sparse=None,
-    isotropic=None,
-):
-
-    # ------------
-    # check inputs
-
-    dargs = {
-        k0: v0 for k0, v0 in locals().items()
-        if v0 is not None
-    }
-
-    # --------------
-    # Get tofu algo
-
-    dalgo = _DALGO0
-
-    # -----------------
-    # Get tomotok algo
-
-    if tomotok2tofu is not False:
-        dalgo.update(tomotok2tofu.get_dalgo())
-
-    # ------------
-    # find matches
-
-    if len(dargs) > 0:
-        lmatch = [
-            k0 for k0, v0 in dalgo.items()
-            if all([v0[k1] == v1 for k1, v1 in dargs.items()])
-        ]
-        if len(lmatch) == 0:
-            lstr = [f'\t- {k0}: {v0}' for k0, v0 in dargs.items()]
-            msg = (
-                "No / several algorithms matching the following criteria:\n"
-                + "\n".join(lstr)
-            )
-            raise Exception(msg)
-        dalgo = {k0: v0 for k0, v0 in dalgo.items() if k0 in lmatch}
-
-    return copy.deepcopy(dalgo)
-
-
-# ##################################################################
-# ##################################################################
+# ################################################################
+# ################################################################
 #                           main
-# ##################################################################
+# ################################################################
 
 
 def _compute_check(
     # input data
     coll=None,
     key=None,
     key_matrix=None,
@@ -280,23 +41,26 @@
     dconstraints=None,
     # regularity operator
     solver=None,
     operator=None,
     geometry=None,
     # choice of algo
     algo=None,
+    maxiter_outer=None,
     # misc
     conv_crit=None,
     chain=None,
     verb=None,
     store=None,
     # algo and solver-specific options
     kwdargs=None,
     method=None,
     options=None,
+    # ref vector specifiers
+    dref_vector=None,
     **kwargs,
 ):
 
     # ----
     # key
 
     # key_matrix
@@ -304,19 +68,20 @@
     key_matrix = ds._generic_check._check_var(
         key_matrix, 'key_matrix',
         types=str,
         allowed=lk,
     )
 
     key_diag = coll.dobj['geom matrix'][key_matrix]['diagnostic']
-    key_cam = coll.dobj['geom matrix'][key_matrix]['camera']
+    # key_cam = coll.dobj['geom matrix'][key_matrix]['camera']
 
     keybs = coll.dobj['geom matrix'][key_matrix]['bsplines']
     deg = coll.dobj['bsplines'][keybs]['deg']
     keym = coll.dobj['bsplines'][keybs]['mesh']
+    nd = coll.dobj[coll._which_mesh][keym]['nd']
     mtype = coll.dobj[coll._which_mesh][keym]['type']
 
     # matrix itself
     matrix, ref, dind = coll.get_geometry_matrix_concatenated(key_matrix)
     lkmat = coll.dobj['geom matrix'][key_matrix]['data']
     units_gmat = coll.ddata[lkmat[0]]['units']
     nchan, nbs = matrix.shape[-2:]
@@ -353,32 +118,32 @@
 
     # -----------
     # constraints
 
     dconstraints = _check_constraints(
         coll=coll,
         keym=keym,
+        nd=nd,
         mtype=mtype,
         deg=deg,
         dconst=dconstraints,
     )
 
     # --------------------------------------------
     # Time synchronisation between matrix and data
 
-    # list of keys with potential time-dependence
-    lk = ddata['keys'] + coll.dobj['geom matrix'][key_matrix]['data']
-    if dconstraints is not None:
-        if isinstance(dconstraints.get('rmax', {}).get('val'), str):
-            lk.append(dconstraints['rmax']['val'])
-        if isinstance(dconstraints.get('rmin', {}).get('val'), str):
-            lk.append(dconstraints['rmin']['val'])
-
     # check if common / different time dependence
-    hastime, reft, keyt, t, dind = coll.get_time_common(keys=lk)
+    hastime, reft, keyt, t, dind = _refs._get_ref_vector_common(
+        coll=coll,
+        ddata=ddata,
+        key_matrix=key_matrix,
+        dconstraints=dconstraints,
+        dref_vector=dref_vector,
+    )
+
     if reft is None:
         reft = f'{key}-nt'
 
     # update all accordingly
     if hastime and dind is not None:
         # matrix side
         if dind.get(key_matrix, {}).get('ind') is not None:
@@ -414,49 +179,49 @@
         dind=dind,
         nbs=nbs,
     )
 
     # --------------
     # inversion refs
 
-    refbs = coll.dobj['bsplines'][keybs]['ref-bs']
+    # refbs = coll.dobj['bsplines'][keybs]['ref-bs']
     if hastime:
         refinv = (reft, keybs)
     else:
         refinv = keybs
 
     notime = (refinv == keybs)
 
     # --------------
     # choice of algo
 
     if algo is None:
         msg = (
             "\nPlease provide an algorithm, to be chosen from:\n"
-            + get_available_inversions_algo(verb=False, returnas=str)
+            + _algos.get_available_inversions_algo(verb=False, returnas=str)
         )
         raise Exception(msg)
 
     # regularization necessary ?
     if nbs >= nchan:
         lok = [
-            k0 for k0, v0 in _DALGO.items()
+            k0 for k0, v0 in _algos._DALGO.items()
             if v0.get('family') != 'Non-regularized'
         ]
     else:
-        lok = list(_DALGO.keys())
+        lok = list(_algos._DALGO.keys())
 
     algo = ds._generic_check._check_var(
         algo, 'algo',
         types=str,
         allowed=lok,
     )
 
     # define dalgo
-    dalgo = _DALGO[algo]
+    dalgo = _algos._DALGO[algo]
 
     # check vs deg
     deg = coll.dobj['bsplines'][keybs]['deg']
     if dalgo['source'] == 'tomotok' and dalgo['reg_operator'] == 'MinFisher':
         if deg != 0:
             msg = (
                 "MinFisher regularization from tomotok requires deg = 0\n"
@@ -467,14 +232,15 @@
     # regul
     regul = dalgo['family'] != 'Non-regularized'
 
     # --------------------------------------------
     # valid chan / time indices of data / sigma (+ constraints)
 
     indok = np.isfinite(ddata['data']) & np.isfinite(dsigma['data'])
+
     if not np.all(indok):
 
         # remove channels
         iok = np.any(indok, axis=0)
         if np.any(~iok):
 
             if not np.any(iok):
@@ -530,72 +296,106 @@
         raise NotImplementedError(msg)
 
     # -------------------
     # regularity operator
 
     # get operator
     if regul:
-        opmat, operator, geometry, dim, ref, crop = coll.add_bsplines_operator(
+
+        if 'N2' not in operator:
+            msg = (
+                "Quadratic operator needed for inversions!"
+                f"Provided: {operator}"
+            )
+            raise Exception(msg)
+
+        dopmat, dpar = coll.add_bsplines_operator(
             key=keybs,
             operator=operator,
             geometry=geometry,
             returnas=True,
+            return_param=True,
             store=False,
             crop=crop,
         )
 
-        if isinstance(opmat, tuple):
-            assert all([op.shape == (nbs, nbs) for op in opmat])
-        elif opmat.ndim == 1:
-            msg = "Inversion algorithm requires a quadratic operator!"
+        lk = dpar['keys']
+        operator = dpar['operator']
+        geometry = dpar['geometry']
+        crop = dpar['crop']
+
+        # safety check 0
+        lfail = [
+            k0 for k0 in lk
+            if not (
+                dopmat[k0]['data'].shape == (nbs, nbs)
+                and (
+                    scpsp.issparse(dopmat[k0]['data'])
+                    or np.all(np.isfinite(dopmat[k0]['data']))
+                )
+            )
+        ]
+        if len(lfail) > 0:
+            lstr = [f'\t- {k0}' for k0 in lfail]
+            msg = (
+                "Wrong operator shape or non-finite values!\n"
+                f"\t- operator: {operator}\n"
+                f"\t- operator shape: {dopmat[lk[0]]['data'].shape}\n"
+                f"\t- expected: {(nbs, nbs)}\n\n"
+                + "\n".join(lstr)
+            )
             raise Exception(msg)
-        else:
-            assert opmat.shape == (nbs,) or opmat.shape == (nbs, nbs)
-            opmat = (opmat,)
 
-        if not scpsp.issparse(opmat[0]):
-            assert all([np.all(np.isfinite(op)) for op in opmat])
     else:
-        opmat = None
+        dopmat = None
         operator = None
         geometry = None
-        dim = None
-        ref = None
 
     assert ddata['data'].shape[1] == nchan
-    nt = ddata['data'].shape[0]
+    # nt = ddata['data'].shape[0]
 
     # -------------------
     # consistent sparsity
 
     # sparse
     if m3d:
         dalgo['sparse'] = False
 
     if dalgo['sparse'] is True:
         if not scpsp.issparse(matrix):
             matrix = scpsp.csc_matrix(matrix)
-        if opmat is not None and not scpsp.issparse(opmat[0]):
-            opmat = [scpsp.csc_matrix(pp) for pp in opmat]
+        if dopmat is not None:
+            for k0, v0 in dopmat.items():
+                if not scpsp.issparse(v0['data']):
+                    dopmat[k0]['data'] = scpsp.csc_matrix(v0['data'])
     elif dalgo['sparse'] is False:
         if scpsp.issparse(matrix):
             matrix = matrix.toarray()
-        if opmat is not None and scpsp.issparse(opmat[0]):
-            opmat = [scpsp.csc_matrix(pp).toarray() for pp in opmat]
+        if dopmat is not None:
+            for k0, v0 in dopmat.items():
+                if scpsp.issparse(v0['data']):
+                    dopmat[k0]['data'] = v0['data'].toarray()
 
     # -----------------------
     # miscellaneous parameter
 
     # conv_crit
     conv_crit = ds._generic_check._check_var(
         conv_crit, 'conv_crit',
         default=1e-4,
         types=float,
     )
 
+    # maxiter_outer
+    maxiter_outer = ds._generic_check._check_var(
+        maxiter_outer, 'maxiter_outer',
+        default=1000,
+        types=(int, float),
+    )
+
     # chain
     chain = ds._generic_check._check_var(
         chain, 'chain',
         default=True,
         types=bool,
     )
 
@@ -635,27 +435,30 @@
     kwdargs, method, options = _algo_check(
         dalgo,
         kwdargs=kwdargs,
         options=options,
         nchan=nchan,
         nbs=nbs,
         conv_crit=conv_crit,
+        # scaling parameters for the hyperparameters of augTikhonov
+        sigma_rel=np.nanmean(dsigma['data']) / np.nanmean(ddata['data']),
     )
 
     return (
         key_matrix,
         key_diag, key_data, key_sigma,
-        keybs, keym, mtype,
+        keybs, keym, nd, mtype,
         ddata, dsigma, matrix, units_gmat,
         keyt, t, reft, notime,
         m3d, indok, iokt,
         dconstraints,
-        opmat, operator, geometry,
+        dopmat, operator, geometry,
         dalgo, dconstraints, dcon,
-        conv_crit, crop, chain, kwdargs, method, options,
+        conv_crit, maxiter_outer,
+        crop, chain, kwdargs, method, options,
         solver, verb, store,
         key, refinv, regul,
     )
 
 
 # #############
 #  input data
@@ -880,23 +683,24 @@
 # #############################################################################
 
 
 def _check_rminmax(
     coll=None,
     dconst=None,
     rm=None,
+    nd=None,
     mtype=None,
 ):
 
     # if exists
     if dconst.get(rm) is None:
         return
 
     # check against mesh type
-    if mtype != 'polar':
+    if nd != '1d':
         msg = f"constraint '{rm}' cannot be used with mesh type {mtype}"
         warnings.warn(msg)
         return
 
     # check format
     lok = [k0 for k0, v0 in coll.ddata.items() if len(v0['ref']) == 1]
     if isinstance(dconst[rm], str) and dconst[rm] in lok:
@@ -943,23 +747,24 @@
         allowed=lok,
     )
 
 
 def _check_deriv(
     coll=None,
     keym=None,
+    nd=None,
     mtype=None,
     dconst=None,
     deriv=None,
     deg=None,
 ):
 
     # check mesh type
-    if mtype != 'polar':
-        msg = f"constraint '{rm}' cannot be used with mesh type {mtype}"
+    if nd != '1d':
+        msg = f"constraint '{deriv}' cannot be used with mesh non-1d"
         warnings.warn(msg)
         return
 
     # check format
     err = False
     if isinstance(dconst[deriv], dict):
 
@@ -1036,48 +841,50 @@
 
     return dconst
 
 
 def _check_constraints(
     coll=None,
     keym=None,
+    nd=None,
     mtype=None,
     deg=None,
     dconst=None,
 ):
 
     # ----------------
     # check conformity
 
     if dconst is None:
         return
     elif not isinstance(dconst, dict):
-        msg = f"Arg dconstraints must be a dict!\nProvided: {dconstraints}"
+        msg = f"Arg dconstraints must be a dict!\nProvided: {dconst}"
         raise Exception(msg)
-    elif mtype != 'polar':
-        msg = "Arg dconstraints cannot be used with non-polar mesh!"
+    elif nd != '1d':
+        msg = "Arg dconstraints cannot be used with non-1d meshes!"
         warnings.warn(msg)
         return
 
     # copy to avoid modifying reference
     dconst = copy.deepcopy(dconst)
 
     # ----------
     # rmin, rmax
 
-    _check_rminmax(coll=coll, dconst=dconst, rm='rmin', mtype=mtype)
-    _check_rminmax(coll=coll, dconst=dconst, rm='rmax', mtype=mtype)
+    _check_rminmax(coll=coll, dconst=dconst, rm='rmin', mtype=mtype, nd=nd)
+    _check_rminmax(coll=coll, dconst=dconst, rm='rmax', mtype=mtype, nd=nd)
 
     # -----------
     # derivatives
 
     for deriv in set(['deriv0', 'deriv1']).intersection(dconst.keys()):
         dconst = _check_deriv(
             coll=coll,
             keym=keym,
+            nd=nd,
             mtype=mtype,
             dconst=dconst,
             deriv=deriv,
             deg=deg,
         )
 
     return dconst
@@ -1264,15 +1071,15 @@
     for deriv in ['deriv0', 'deriv1']:
         if dconst.get(deriv) is None:
             continue
 
         # get indbs, coefs and offset as 3 (nconstraints, nbs) arrays
         indbs, coefs, offset = clas.get_constraints_deriv(
             deriv=deriv,
-            rad=dconst[deriv]['rad'],
+            x0=dconst[deriv]['rad'],
             val=dconst[deriv]['val'],
         )
 
         # assemble
         if not np.any(indbs):
             msg = f"Constraint {deriv} not used (no match)"
             warnings.warn(msg)
@@ -1371,14 +1178,15 @@
     dalgo,
     kwdargs=None,
     method=None,
     options=None,
     nchan=None,
     nbs=None,
     conv_crit=None,
+    sigma_rel=None,
 ):
 
     # ------------------------
     # generic kwdargs
 
     # kwdargs
     if kwdargs is None:
@@ -1392,33 +1200,49 @@
         kwdargs['tol'] = 1.e-6
 
     # ------------------------
     # algo specific kwdargs
 
     # kwdargs specific to aug. tikhonov
     if dalgo['reg_param'] == 'augTikho':
-        a0 = kwdargs.get('a0', 10)
-        a1 = kwdargs.get('a1', 2)
-
-        # to have [x]=1
-        kwdargs['b0'] = np.math.factorial(a0)**(1 / (a0 + 1))
-        kwdargs['b1'] = np.math.factorial(a1)**(1 / (a1 + 1))
-        kwdargs['a0'] = a0
-        kwdargs['a1'] = a1
 
         # Exponent for rescaling of a0bis
         # typically in [1/3 ; 1/2], but real limits are 0 < d < 1 (or 2 ?)
         if kwdargs.get('d') is None:
-            kwdargs['d'] = 0.95
+            kwdargs['d'] = 0.4 # 0.95
+
+        # determination of a0 is an important parameter
+        # the result is sensitive to the order of magnitude of a0 (<1 or >1)
+        # change a0 is there is strong over or under-smoothing
+
+        # mu = lamb / tau
+
+        # # def a0
+        a0 = 0.1*sigma_rel**(-kwdargs['d'])
+        # typically set b0 to reg
+        b0 = 1
+
+        # (a0, b0) are the gamma distribution parameters for lamb
+        kwdargs['a0'] = kwdargs.get('a0', a0) # np.nanmean(dsigma['data']))  # 10 ?
+        # to have [x]=1
+        kwdargs['b0'] = kwdargs.get('b0', b0)   # np.math.factorial(a0)**(1 / (a0 + 1))
+
+        # (a1, b1) are the gamma distribution parameters for tau
+        kwdargs['a1'] = kwdargs.get('a1', 1)
+        # to have [x]=1
+        kwdargs['b1'] = kwdargs.get(
+            'b1',
+            np.math.factorial(kwdargs['a1'])**(1 / (kwdargs['a1'] + 1)),
+        )
 
         if kwdargs.get('conv_reg') is None:
             kwdargs['conv_reg'] = True
 
         if kwdargs.get('nbs_fixed') is None:
-            kwdargs['nbs_fixed'] = True
+            kwdargs['nbs_fixed'] = False    # True
 
         if kwdargs['nbs_fixed']:
             kwdargs['a0bis'] = kwdargs['a0'] - 1. + 1200./2.
         else:
             kwdargs['a0bis'] = kwdargs['a0'] - 1. + nbs/2.
         kwdargs['a1bis'] = kwdargs['a1'] - 1. + nchan/2.
 
@@ -1448,16 +1272,7 @@
                 options['ftol'] = conv_crit/100.
             if options.get('disp') is None:
                 options['disp'] = False
         elif dalgo['name'] != 'algo7':
             raise NotImplementedError
 
     return kwdargs, method, options
-
-
-# ##################################################################
-# ##################################################################
-#               _DALGO at import time
-# ##################################################################
-
-
-_DALGO = get_available_inversions_algo(returnas=dict, verb=False)
```

### Comparing `tofu-1.6.5/tofu/data/_class10_compute.py` & `tofu-1.7.0/tofu/data/_class10_compute.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,28 +10,25 @@
 import scipy.sparse as scpsp
 
 
 import datastock as ds
 
 
 # tofu
-from . import _generic_check
 from . import _class8_compute_signal
 from . import _class10_checks as _checks
 from . import _class10_algos as _algos
-tomotok2tofu = _checks.tomotok2tofu
+from . import _class10_refs as _refs
+tomotok2tofu = _algos.tomotok2tofu
 
 
-__all__ = ['get_available_inversions_algo']
-
-
-# ##################################################################
-# ##################################################################
+# ################################################################
+# ################################################################
 #                           main
-# ##################################################################
+# ################################################################
 
 
 def compute_inversions(
     # resources
     coll=None,
     # inversion name
     key=None,
@@ -41,42 +38,47 @@
     key_sigma=None,
     sigma=None,
     # constraints
     dconstraints=None,
     # regularity operator
     operator=None,
     geometry=None,
+    dop_coefs=None,
     # choice of algo
     algo=None,
+    maxiter_outer=None,
     # misc
     solver=None,
     conv_crit=None,
     chain=None,
     verb=None,
     store=None,
     # algo and solver-specific options
     kwdargs=None,
     method=None,
     options=None,
+    # ref vector specifier
+    dref_vector=None,
 ):
 
     # -------------
     # check inputs
 
     (
         key_matrix,
         key_diag, key_data, key_sigma,
-        keybs, keym, mtype,
+        keybs, keym, nd, mtype,
         ddata, dsigma, matrix, units_gmat,
         keyt, t, reft, notime,
         m3d, indok, iokt,
         dconstraints,
-        opmat, operator, geometry,
+        dopmat, operator, geometry,
         dalgo, dconstraints, dcon,
-        conv_crit, crop, chain, kwdargs, method, options,
+        conv_crit, maxiter_outer,
+        crop, chain, kwdargs, method, options,
         solver, verb, store,
         keyinv, refinv, regul,
     ) = _checks._compute_check(**locals())
 
     data = ddata['data']
     sigma = dsigma['data']
 
@@ -103,28 +105,20 @@
     # indt (later)
 
     # normalization
     data_n = (data / sigma)
     mu0 = 1.
 
     # Define Regularization operator
-    if dalgo['family'] == 'Non-regularized':
-        R = None
-    else:
-        if dalgo['source'] == 'tomotok' and dalgo['reg_operator'] == 'MinFisher':
-            R = opmat
-        elif operator == 'D0N2':
-            R = opmat[0]
-        elif operator == 'D1N2':
-            R = opmat[0] + opmat[1]
-        elif operator == 'D2N2':
-            R = opmat[0] + opmat[1]
-        else:
-            msg = 'unknown operator!'
-            raise Exception(msg)
+    R = _get_operator(
+        dalgo=dalgo,
+        operator=operator,
+        dopmat=dopmat,
+        dop_coefs=dop_coefs,
+    )
 
     # prepare computation intermediates
     precond = None
     Tyn = np.full((nbs,), np.nan)
     mat0 = matrix[0, ...] if m3d else matrix
     if dalgo['sparse'] is True:
         Tn = scpsp.diags(1./np.nanmean(sigma, axis=0)).dot(mat0)
@@ -147,17 +141,17 @@
     niter = np.zeros((nt,), dtype=int)
     spec = [None for ii in range(nt)]
 
     # -------------
     # initial guess
 
     if indok is None:
-        sol0 = np.full((nbs,), np.mean(data[0, :]) / mat0.mean())
+        sol0 = np.full((nbs,), np.mean(data[0, :] / np.sum(mat0, axis=1)))
     else:
-        sol0 = np.full((nbs,), np.mean(data[0, indok[0, :]]) / mat0.mean())
+        sol0 = np.full((nbs,), np.mean(data[0, indok[0, :]] / np.sum(mat0, axis=1)))
 
     if verb >= 1:
         # t1 = time.process_time()
         t1 = time.perf_counter()
         print(f"{t1-t0} s", end='\n', flush=True)
         print("Setting inital guess... ", end='', flush=True)
 
@@ -193,14 +187,15 @@
             chain=chain,
             verb=verb,
             kwdargs=kwdargs,
             method=method,
             options=options,
             dcon=dcon,
             regul=regul,
+            maxiter_outer=maxiter_outer,
             # output
             sol=sol,
             mu=mu,
             chi2n=chi2n,
             regularity=regularity,
             niter=niter,
             spec=spec,
@@ -247,30 +242,30 @@
         t3 = time.perf_counter()
         print(f"{t3-t2} s", end='\n', flush=True)
         print("Post-formatting results...", end='\n', flush=True)
 
     # ---------------------------------------------
     # estimate relative regularity for polar mesh of not regul
 
-    if not regul and mtype == 'polar':
+    if (not regul) and nd == '1d':
         clas = coll.dobj['bsplines'][keybs]['class']
 
-        if clas.knotsa is None:
-            # estimate 1d squared gradient
-            kr = coll.dobj[coll._which_mesh][keym]['knots'][0]
-            rr = coll.ddata[kr]['data']
-            regularity = np.nansum(
-                clas(
-                    radius=np.linspace(rr[0], rr[-1], rr.size*10),
-                    coefs=sol,
-                    radius_vs_time=False,
-                    deriv=1,
-                )**2,
-                axis=1,
-            )
+        # if clas.knotsa is None:
+            # # estimate 1d squared gradient
+            # kr = coll.dobj[coll._which_mesh][keym]['knots'][0]
+            # rr = coll.ddata[kr]['data']
+            # regularity = np.nansum(
+                # clas(
+                    # radius=np.linspace(rr[0], rr[-1], rr.size*10),
+                    # coefs=sol,
+                    # radius_vs_time=False,
+                    # deriv=1,
+                # )**2,
+                # axis=1,
+            # )
 
     # -------------
     # format output
 
     # reshape solution
     if crop is True:
         shapebs = coll.dobj['bsplines'][keybs]['shape']
@@ -286,20 +281,94 @@
 
     # -------------
     # store
 
     if store is True:
         units = ddata['units'] / units_gmat
         key_data = ddata['keys']
+
         _store(**locals())
 
     else:
         return sol_full, mu, chi2n, regularity, niter, spec, t
 
 
+# ##################################################################
+# ##################################################################
+#                   get operator
+# ##################################################################
+
+
+def _get_operator(
+    dalgo=None,
+    operator=None,
+    dop_coefs=None,
+    dopmat=None,
+):
+    """ Return time-independent operator """
+
+    # -------
+    # Trivial
+
+    if dalgo['family'] == 'Non-regularized':
+        return None
+
+    # -------
+    # check
+
+    if dop_coefs is None:
+        dop_coefs = {k0: 1. for k0 in dopmat.keys()}
+    c0 = (
+        isinstance(dop_coefs, dict)
+        and all([
+            isinstance(dop_coefs.get(k0), (float, int))
+            for k0 in dopmat.keys()
+        ])
+    )
+    if not c0:
+        msg = (
+            "Arg dop_coefs must be a dict of scalar coefficients\n"
+            "The key are the operator components they are applied to\n"
+            "\t- Expected keys: {sorted(dopmat.keys())}\n"
+            "\t- Provided: {dop_coefs}\n"
+        )
+        raise Exception(msg)
+
+    # -----------
+    # non-trivial
+
+    if dalgo['source'] == 'tomotok' and dalgo['reg_operator'] == 'MinFisher':
+        R = opmat
+
+    elif operator == 'D0N2':
+        R = dopmat['tMM']['data']
+
+    elif operator == 'D1N2':
+        R = 0
+        for k0 in dopmat:
+            R += dop_coefs[k0] * dopmat[k0]['data']
+
+    elif operator == 'D2N2':
+        R = 0
+        for k0 in dopmat:
+            R += dop_coefs[k0] * dopmat[k0]['data']
+
+    else:
+        msg = 'unknown operator!'
+        raise Exception(msg)
+
+    return R
+
+
+# ##################################################################
+# ##################################################################
+#                   store
+# ##################################################################
+
+
 def _store(
     coll=None,
     sol_full=None,
     notime=None,
     iokt=None,
     chi2n=None,
     mu=None,
@@ -317,22 +386,37 @@
     operator=None,
     geometry=None,
     dalgo=None,
     solver=None,
     chain=None,
     conv_crit=None,
     units=None,
+    dref_vector=None,
     **kwdargs,
 ):
 
+    # ------------
+    # check input
+
+    if dref_vector is None:
+        dref_vector = {}
+
     # ---------------------------
     # reshape if unique time step
 
     if notime:
-        assert sol_full.shape[0] == 1
+        if not sol_full.shape[0] == 1:
+            msg = (
+                "Inconsistency:\n"
+                "notime = True but sol_full.shape[0] > 1\n"
+                f"\t- key_data: '{key_data}'\n"
+                f"\t- key_matrix: '{key_matrix}'\n"
+                f"\t- ol_full.shape: {ol_full.shape}\n'"
+            )
+            raise Exception(msg)
         sol_full = sol_full[0, ...]
     else:
         # restore full size
         sol_full, chi2n, mu, regularity, niter = _restore_fullt(
             iokt=iokt,
             sol_full=sol_full,
             chi2n=chi2n,
@@ -357,42 +441,42 @@
     dref = None
     if notime is False:
         if keyt is None:
             dref = {
                 reft: {'size': nt},
             }
             ddata.update({
-                f'{keyinv}-t': {
+                f'{keyinv}_t': {
                     'data': t,
                     'ref': reft,
                     'dim': 'time',
                 },
             })
 
         ddata.update({
-            f'{keyinv}-chi2n': {
+            f'{keyinv}_chi2n': {
                 'data': chi2n,
                 'ref': reft,
             },
-            f'{keyinv}-mu': {
+            f'{keyinv}_mu': {
                 'data': mu,
                 'ref': reft,
             },
-            f'{keyinv}-reg': {
+            f'{keyinv}_reg': {
                 'data': regularity,
                 'ref': reft,
             },
-            f'{keyinv}-niter': {
+            f'{keyinv}_niter': {
                 'data': niter,
                 'ref': reft,
             },
         })
 
     # add synthetic data
-    kretro = f'{keyinv}-retro'
+    kretro = f'{keyinv}_retro'
 
     # add inversion
     dobj = {
         'inversions': {
             keyinv: {
                 'retrofit': kretro,
                 'data_in': key_data,
@@ -420,21 +504,22 @@
             'niter': niter,
         })
 
     # update instance
     coll.update(dobj=dobj, dref=dref, ddata=ddata)
 
     # add synthetic data
-    keyt = coll.get_time(key=keyinv)[3]
+    keyt = coll.get_ref_vector(key=keyinv, ref=reft, **dref_vector)[3]
     data_synth = coll.add_retrofit_data(
         key=kretro,
         key_diag=key_diag,
         key_matrix=key_matrix,
         key_profile2d=keyinv,
         t=keyt,
+        dref_vector=dref_vector,
         store=True,
     )
 
 
 def _restore_fullt(
     iokt=None,
     sol_full=None,
@@ -459,18 +544,18 @@
     mui[iokt] = mu
     regularityi[iokt] = regularity
     niteri[iokt] = niter
 
     return sol_fulli, chi2ni, mui, regularityi, niteri
 
 
-# ##################################################################
-# ##################################################################
+# ################################################################
+# ################################################################
 #                   _compute time loop
-# ##################################################################
+# ################################################################
 
 
 def _compute_inv_loop(
     # inputs
     dalgo=None,
     sol0=None,
     mu0=None,
@@ -492,14 +577,15 @@
     chain=None,
     verb=None,
     kwdargs=None,
     method=None,
     options=None,
     dcon=None,
     regul=None,
+    maxiter_outer=None,
     # output
     sol=None,
     mu=None,
     chi2n=None,
     regularity=None,
     niter=None,
     spec=None,
@@ -604,14 +690,15 @@
             nchan=nchani,
             nbs=nbsi,
             # parameters
             conv_crit=conv_crit,
             precond=precond,
             verb=verb,
             verb2head=verb2head,
+            maxiter_outer=maxiter_outer,
             # quad-only
             func_val=func_val,
             func_jac=func_jac,
             func_hess=func_hess,
             bounds=bi,
             method=method,
             options=options,
@@ -629,15 +716,15 @@
 
         # post
         if chain:
             sol0[:] = sol[ii, :]
         mu0 = mu[ii]
 
         if verb == 1:
-            msg = f"   chi2n = {chi2n[ii]:.3e}    niter = {niter[ii]}"
+            msg = f"   chi2n = {chi2n[ii]:.3e}    reg = {regularity[ii]:.3e}    niter = {niter[ii]}"
             print(msg, end='\n', flush=True)
 
 
 # ##################################################################
 # ##################################################################
 #                   _compute time loop - TOMOTOK
 # ##################################################################
@@ -750,15 +837,15 @@
             nchan=nchan,
             **kwdargs,
         )
 
         # post
         if chain:
             sol0[:] = sol[ii, :]
-        mu0 = mu[ii]
+        # mu0 = mu[ii]
 
         if verb == 1:
             msg = f"   chi2n = {chi2n[ii]:.3e}    niter = {niter[ii]}"
             print(msg, end='\n', flush=True)
 
 
 # ##################################################################
@@ -872,27 +959,29 @@
         bounds = (bounds[0][indbsi], bounds[1][indbsi])
 
     return nbsi, indbsi, Tni, TTni, Tyni, yni, bounds
 
 
 # ##################################################################
 # ##################################################################
-#               retrofit                   
+#               retrofit
 # ##################################################################
 
 
 def compute_retrofit_data(
     # resources
     coll=None,
     # inputs
     key=None,
     key_diag=None,
     key_matrix=None,
     key_profile2d=None,
     t=None,
+    # ref_vector_specifier
+    dref_vector=None,
     # parameters
     store=None,
     returnas=None,
 ):
 
     # ------------
     # check inputs
@@ -911,14 +1000,16 @@
         coll=coll,
         # inputs
         key=key,
         key_diag=key_diag,
         key_matrix=key_matrix,
         key_profile2d=key_profile2d,
         t=t,
+        # ref_vector_specifier
+        dref_vector=dref_vector,
         # parameters
         store=store,
         returnas=returnas,
     )
 
     # --------
     # prepare
@@ -938,15 +1029,15 @@
         if hastime and ist_prof:
             coefs = coefs[:, indbs_tf[0], indbs_tf[1]]
         else:
             coefs = coefs[indbs_tf[0], indbs_tf[1]]
 
     # --------
     # compute
-    # --------------
+    # ---------
 
     # time-dependent
     if hastime:
 
         # retro = np.full((nt, nchan, nbs), np.nan)
 
         # get time indices
@@ -966,15 +1057,15 @@
         if ist_mat and ist_prof:
             retro = np.array([
                 matrix[imat[ii], :, :].dot(coefs[iprof[ii], :])
                 for ii in range(nt)
             ])
         elif ist_mat:
             retro = np.array([
-                matrix[imar[ii], :, :].dot(coefs)
+                matrix[imat[ii], :, :].dot(coefs)
                 for ii in range(nt)
             ])
         elif ist_prof:
             retro = np.array([
                 matrix.dot(coefs[iprof[ii], :])
                 for ii in range(nt)
             ])
@@ -1005,37 +1096,36 @@
 
         # ref
         refi[axis] = coll.dobj['camera'][k0]['dgeom']['ref']
         refi = tuple(np.r_[refi[:axis], refi[axis], refi[axis+1:]])
 
         # dict
         dout[k0] = {
+            'key': f'{key}_{k0}',
             'data': retroi,
             'ref': refi,
+            'units': coll.ddata[key_profile2d]['units'] * gunits,
         }
         i0 += npix
 
-    units = coll.ddata[key_profile2d]['units'] * gunits
-
     # --------------
     # store
     # --------------
 
     if store:
         _class8_compute_signal._store(
             coll=coll,
             key=key,
             key_diag=key_diag,
             dout=dout,
-            units=units,
             key_matrix=key_matrix,
         )
 
     # -------------
-    # return 
+    # return
     # --------------
 
     if returnas is dict:
         return dout
 
 
 # ###################
@@ -1048,38 +1138,39 @@
     coll=None,
     # inputs
     key=None,
     key_diag=None,
     key_matrix=None,
     key_profile2d=None,
     t=None,
+    # ref vector specifier
+    dref_vector=None,
     # parameters
     store=None,
     returnas=None,
 ):
 
-    #----------
+    # ----------
     # keys
 
     # key_diag
     lok = list(coll.dobj.get('diagnostic', {}).keys())
     key_diag = ds._generic_check._check_var(
         key_diag, 'key_diag',
         types=str,
         allowed=lok,
     )
     is2d = coll.dobj['diagnostic'][key_diag]['is2d']
 
     # key
-    dsig = coll.dobj['diagnostic'][key_diag].get('dsignal', {})
-    lout = list(dsig.keys())
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        excluded=lout,
+    key = ds._generic_check._obj_key(
+        coll.dobj.get('synth sig', {}),
+        short='synth',
+        key=key,
+        ndigits=2,
     )
 
     # key_matrix
     lok = coll.dobj.get('geom matrix', {}).keys()
     key_matrix = ds._generic_check._check_var(
         key_matrix, 'key_matrix',
         types=str,
@@ -1089,40 +1180,52 @@
     key_cam = coll.dobj['geom matrix'][key_matrix]['camera']
     keybs = coll.dobj['geom matrix'][key_matrix]['bsplines']
     keym = coll.dobj['bsplines'][keybs]['mesh']
     mtype = coll.dobj[coll._which_mesh][keym]['type']
 
     matrix, ref, dindmat = coll.get_geometry_matrix_concatenated(key=key_matrix)
     nchan, nbs = matrix.shape[-2:]
-    refbs = ref[-1]
+    # refbs = ref[-1]
 
     # key_pofile2d
     lok = [
         k0 for k0, v0 in coll.ddata.items()
-        if v0['bsplines'] == keybs
+        if v0['bsplines'] is not None
+        and keybs in v0['bsplines']
     ]
     key_profile2d = ds._generic_check._check_var(
         key_profile2d, 'key_profile2d',
         types=str,
         allowed=lok,
     )
 
     # time management
     lkmat = coll.dobj['geom matrix'][key_matrix]['data']
-    hastime, reft, keyt, t_out, dind = coll.get_time_common(
-        keys=lkmat + [key_profile2d],
-        t=t,
-        ind_strict=False,
+
+    hastime, reft, keyt, t_out, dind = _refs._get_ref_vector_common(
+        coll=coll,
+        key_matrix=key_matrix,
+        key_profile2d=key_profile2d,
+        dref_vector=dref_vector,
     )
+
     if hastime and t_out is not None and reft is None:
-        reft = f'{key}-nt'
-        keyt = f'{key}-t'
+        reft = f'{key}_nt'
+        keyt = f'{key}_t'
 
-    ist_mat = coll.get_time(key=lkmat[0])[0]
-    ist_prof = coll.get_time(key=key_profile2d)[0]
+    ist_mat = coll.get_ref_vector(
+        key=lkmat[0],
+        ref=reft,
+        **dref_vector,
+    )[0]
+    ist_prof = coll.get_ref_vector(
+        key=key_profile2d,
+        ref=reft,
+        **dref_vector,
+    )[0]
 
     # reft, keyt and refs
     if hastime and t_out is not None:
         nt = t_out.size
         ref = (reft, None)
     else:
         nt = 0
```

### Comparing `tofu-1.6.5/tofu/data/_class10_plot.py` & `tofu-1.7.0/tofu/data/_class10_plot.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,32 +9,34 @@
 import matplotlib.pyplot as plt
 import matplotlib.gridspec as gridspec
 import datastock as ds
 
 
 # tofu
 # from tofu import __version__ as __version__
-from . import _generic_check
+from . import _class10_refs as _refs
 from . import _class8_plot
 
 
-# #############################################################################
-# #############################################################################
+# ################################################################
+# ################################################################
 #                           inversions
-# #############################################################################
+# ################################################################
 
 
 def _plot_inversion_check(
     coll=None,
     key=None,
+    plot_details=None,
     indbf=None,
     indchan=None,
     cmap=None,
     dcolorbar=None,
     dleg=None,
+    alpha=None,
     # los sampling
     los_res=None,
     # interactivity
     color_dict=None,
     nlos=None,
     dax=None,
     connect=None,
@@ -48,24 +50,28 @@
     lk = list(coll.dobj['inversions'].keys())
     keyinv = ds._generic_check._check_var(
         key, 'key',
         default=None,
         types=str,
         allowed=lk,
     )
+
+    wm = coll._which_mesh
+    wbs = coll._which_bsplines
     keymat = coll.dobj['inversions'][keyinv]['matrix']
     key_data = coll.dobj['inversions'][keyinv]['data_in']
     key_retro = coll.dobj['inversions'][keyinv]['retrofit']
     keybs = coll.dobj['geom matrix'][keymat]['bsplines']
     key_diag = coll.dobj['geom matrix'][keymat]['diagnostic']
     is2d = coll.dobj['diagnostic'][key_diag]['is2d']
     key_cam = coll.dobj['geom matrix'][keymat]['camera']
-    key_retro = coll.dobj['diagnostic'][key_diag]['dsignal'][key_retro]['data']
-    keym = coll.dobj['bsplines'][keybs]['mesh']
-    mtype = coll.dobj[coll._which_mesh][keym]['type']
+    key_retro = coll.dobj['synth sig'][key_retro]['data']
+    keym = coll.dobj[wbs][keybs]['mesh']
+    mtype = coll.dobj[wm][keym]['type']
+    nd = coll.dobj[wm][keym]['nd']
     # refbs = coll.dobj['bsplines'][keybs]['ref']
 
     crop = coll.dobj['geom matrix'][keymat]['crop']
     if crop is True:
         cropbs = coll.dobj['bsplines'][keybs]['crop']
         cropbs = coll.ddata[cropbs]['data']
     else:
@@ -83,25 +89,41 @@
     }
     dcolorbar = ds._generic_check._check_var(
         dcolorbar, 'dcolorbar',
         default=defdcolorbar,
         types=dict,
     )
 
+    # plot_details
+    plot_details = ds._generic_check._check_var(
+        plot_details, 'plot_details',
+        types=bool,
+        default=True,
+    )
+
     # los_res
     los_res = ds._generic_check._check_var(
         los_res, 'los_res',
         types=float,
         default=0.05,
         sign='> 0.',
     )
 
     # color_dict
     color_dict = _class8_plot._check_color_dict(color_dict)
 
+
+    # alpha
+    alpha = ds._generic_check._check_var(
+        alpha, 'alpha',
+        types=float,
+        default=0.2,
+        sign='> 0.',
+    )
+
     # nlos
     nlos = ds._generic_check._check_var(
         nlos, 'nlos',
         types=int,
         default=5,
     )
 
@@ -123,18 +145,18 @@
         default=True,
         types=bool,
     )
 
     return (
         keyinv, keymat,
         key_diag, key_cam, keybs, key_data, key_retro,
-        is2d, mtype,
+        is2d, mtype, nd,
         cropbs, cmap, dcolorbar,
-        nlos, los_res, color_dict,
-        dleg, connect,
+        nlos, los_res, color_dict, alpha,
+        dleg, plot_details, connect,
     )
 
 
 def _plot_inversion_prepare(
     coll=None,
     coll2=None,
     is2d=None,
@@ -142,16 +164,23 @@
     keyinv=None,
     key_matrix=None,
     key_diag=None,
     key_cam=None,
     key_data=None,
     key_retro=None,
     los_res=None,
+    dref_vector=None,
 ):
 
+    # ------------
+    # check
+
+    if dref_vector is None:
+        dref_vector = {}
+
     # -----------------
     # add nearest-neighbourg interpolated data
 
     # just for preparation
     ddata = {
         k0: {'data': coll.ddata[key_data[ii]]} for ii, k0 in enumerate(key_cam)
     }
@@ -160,40 +189,64 @@
     dcamref, drefx, drefy = _class8_plot._prepare_dcamref(
         coll=coll,
         key_cam=key_cam,
         is2d=is2d,
     )
 
     # los
-    dlos, dref_los = _class8_plot._prepare_los(
+    dlos_n, dref_los = _class8_plot._prepare_los(
+        coll=coll,
+        coll2=coll2,
+        dcamref=dcamref,
+        key_diag=key_diag,
+        key_cam=key_cam,
+        los_res=los_res,
+    )
+
+    # vos
+    dvos_n, dref_vos = _class8_plot._prepare_vos(
         coll=coll,
         coll2=coll2,
         dcamref=dcamref,
         key_diag=key_diag,
         key_cam=key_cam,
         los_res=los_res,
     )
 
     # ddatax, ddatay
     (
-        reft, dkeyx, dkeyy, ddatax, ddatay, dextent,
+        _, dkeyx, dkeyy, ddatax, ddatay, dextent,
     ) = _class8_plot._prepare_datarefxy(
         coll=coll,
         coll2=coll2,
         dcamref=dcamref,
         drefx=drefx,
         drefy=drefy,
         ddata=ddata,
         is2d=is2d,
     )
 
+    # -----------
+    # get reft
+
+    hastime, reft, keyt, t, dind = _refs._get_ref_vector_common(
+        coll=coll,
+        key_matrix=key_matrix,
+        key_profile2d=keyinv,
+        dref_vector=dref_vector,
+    )
+
     # -----------------
     # add nearest-neighbourg interpolated data
 
-    reft, keyt, time = coll.get_time(key=keyinv)[2:5]
+    reft, keyt, time = coll.get_ref_vector(
+        key=keyinv,
+        ref=reft,
+        **dref_vector,
+    )[2:5]
     lkmat = coll.dobj['geom matrix'][key_matrix]['data']
 
     dind = None
     if coll.get_time(key=lkmat[0])[0]:
         keyt_data = coll.get_time(key=key_data[0])[3]
         if keyt_data != keyt:
             dind = coll.get_time(
@@ -275,71 +328,80 @@
     # errmax
     errmax = max(np.abs(errmin), np.abs(errmax))
 
     # ----------------
     # inversion parameters
 
     if reft is not None:
-        chi2n = coll.ddata[f'{keyinv}-chi2n']['data']
-        mu = coll.ddata[f'{keyinv}-mu']['data']
-        reg = coll.ddata[f'{keyinv}-reg']['data']
-        niter = coll.ddata[f'{keyinv}-niter']['data']
+        chi2n = coll.ddata[f'{keyinv}_chi2n']['data']
+        mu = coll.ddata[f'{keyinv}_mu']['data']
+        reg = coll.ddata[f'{keyinv}_reg']['data']
+        niter = coll.ddata[f'{keyinv}_niter']['data']
     else:
         chi2n = None    # coll.dobj['inversions'][keyinv]['chi2n']
         mu = None       # coll.dobj['inversions'][keyinv]['mu']
         reg = None      # coll.dobj['inversions'][keyinv]['reg']
         niter = None    # coll.dobj['inversions'][keyinv]['niter']
 
     return (
-        dlos, dref_los,
+        dlos_n, dref_los,
+        dvos_n, dref_vos,
         drefx, drefy, dkeyx, dkeyy, ddatax, ddatay, dextent,
-        time, reft,
+        time, keyt, reft,
         chi2n, mu, reg, niter,
         datamin, datamax, errmax,
     )
 
 
 def plot_inversion(
     coll=None,
     key=None,
-    indt=None,
+    plot_details=None,
     res=None,
     vmin=None,
     vmax=None,
     cmap=None,
+    alpha=None,
+    # config
+    plot_config=None,
+    # figure
     dax=None,
     dmargin=None,
     fs=None,
     dcolorbar=None,
     dleg=None,
     # los sampling
     los_res=None,
+    # ref vector specifier
+    dref_vector=None,
     # interactivity
     color_dict=None,
     nlos=None,
     dinc=None,
     connect=None,
 ):
 
     # ------------
     # check inputs
 
     (
         keyinv, keymat,
         key_diag, key_cam, keybs, key_data, key_retro,
-        is2d, mtype,
+        is2d, mtype, nd,
         cropbs, cmap, dcolorbar,
-        nlos, los_res, color_dict,
-        dleg, connect,
+        nlos, los_res, color_dict, alpha,
+        dleg, plot_details, connect,
     ) = _plot_inversion_check(
         coll=coll,
         key=key,
+        plot_details=plot_details,
         cmap=cmap,
         dcolorbar=dcolorbar,
         dleg=dleg,
+        alpha=alpha,
         # los sampling
         los_res=los_res,
         # interactivity
         color_dict=color_dict,
         nlos=nlos,
         connect=connect,
     )
@@ -348,26 +410,30 @@
     # plot - prepare
 
     if dax is None:
 
         dax = _plot_inversion_create_axes(
             fs=fs,
             dmargin=dmargin,
-            mtype=mtype,
+            nd=nd,
             key_cam=key_cam,
         )
 
-    dax = _generic_check._check_dax(dax=dax, main='matrix')
+    dax = ds._generic_check._check_dax(dax=dax, main='matrix')
 
     # --------------
     # plot profile2d
 
-    coll2, dgroup = coll.plot_profile2d(
+    coll2, dgroup = coll.plot_as_profile2d(
         key=keyinv,
-        res=res,
+        dres=res,
+        plot_details=plot_details,
+        # ref vectors
+        dref_vectorZ=dref_vector,
+        dref_vectorU=None,          # U not handled yet
         # figure
         vmin=vmin,
         vmax=vmax,
         cmap=cmap,
         dax=dax,
         dmargin=dmargin,
         fs=fs,
@@ -379,30 +445,32 @@
     )
     dax = coll2.dax
 
     # ------------
     # prepare data
 
     (
-        dlos, dref_los,
+        dlos_n, dref_los,
+        dvos_n, dref_vos,
         drefx, drefy, dkeyx, dkeyy, ddatax, ddatay, dextent,
-        time, reft,
+        time, keyt, reft,
         chi2n, mu, reg, niter,
         datamin, datamax, errmax,
     ) = _plot_inversion_prepare(
         coll=coll,
         coll2=coll2,
         is2d=is2d,
         keyinv=keyinv,
         key_matrix=keymat,
         key_cam=key_cam,
         key_diag=key_diag,
         key_data=key_data,
         key_retro=key_retro,
         los_res=los_res,
+        dref_vector=dref_vector,
     )
 
     # ----------------
     # define and set dgroup
 
     dgroup.update({
         f'{k0}_i0': {
@@ -427,15 +495,14 @@
         dgroup['Z']['ref'].append(reft)
 
     # ---------
     # plot data
 
     for ii, k0 in enumerate(key_cam):
 
-
         # data vs retro
         kax = k0
         if dax.get(kax) is not None:
             ax = dax[kax]['handle']
 
             if is2d:
 
@@ -556,28 +623,32 @@
                 dkeyx=dkeyx,
                 dkeyy=dkeyy,
                 color_dict=color_dict,
             )
 
         # add los
         kax = 'matrix'
-        if dlos[k0]['rays'] is not None:
+        if dlos_n[k0] is not None:
             ax = dax[kax]['handle']
 
-            nan = np.full((dlos[k0]['x'].shape[0],), np.nan)
+            nan_los = np.full((dlos_n[k0],), np.nan)
+            nan_vos = np.full((dvos_n[k0],), np.nan)
 
             _class8_plot._add_camera_los_cross(
                 coll2=coll2,
                 k0=k0,
                 ax=ax,
                 kax=kax,
                 nlos=nlos,
                 dref_los=dref_los,
+                dref_vos=dref_vos,
                 color_dict=color_dict,
-                nan=nan,
+                nan_los=nan_los,
+                nan_vos=nan_vos,
+                alpha=alpha,
             )
 
         # err
         kax = f"{k0}_err"
         if dax.get(kax) is not None:
             ax = dax[kax]['handle']
 
@@ -680,79 +751,109 @@
     # # plot inversion parameters
 
     if reft is not None:
         kax = 'inv-param'
         if dax.get(kax) is not None:
             ax = dax[kax]['handle']
             ax.plot(
-                # time,
+                time,
                 chi2n / np.nanmax(chi2n),
                 c='k',
                 ls='-',
                 lw=1.,
                 marker='.',
-                label='nchi2n',
+                label='chi2n norm',
             )
 
             ax.plot(
-                # time,
+                time,
                 reg / np.nanmax(reg),
                 c='b',
                 ls='-',
                 lw=1.,
                 marker='.',
-                label='mu*reg',
+                label='mu*reg norm',
             )
 
             # add mobile
             l0 = ax.axvline(time[0], c='k', ls='-', lw=1.)
 
             # add mobile
             kl0 = 't-par'
             coll2.add_mobile(
                 key=kl0,
                 handle=l0,
                 refs=(reft,),
-                data=['index'],
+                data=[keyt],
                 dtype=['xdata'],
                 axes=kax,
                 ind=0,
             )
             ax.set_ylim(bottom=0)
 
+            ax.legend()
+
         kax = 'niter'
         if dax.get(kax) is not None:
             ax = dax[kax]['handle']
             ax.plot(
-                # time,
+                time,
                 niter,
                 c='k',
                 ls='-',
                 lw=1.,
                 marker='.',
             )
 
+            # add mobile
+            l0 = ax.axvline(time[0], c='k', ls='-', lw=1.)
+
+            # add mobile
+            kl0 = 't-niter'
+            coll2.add_mobile(
+                key=kl0,
+                handle=l0,
+                refs=(reft,),
+                data=[keyt],
+                dtype=['xdata'],
+                axes=kax,
+                ind=0,
+            )
+            ax.set_ylim(bottom=0)
+
             ax.set_ylim(bottom=0)
 
+    # -------
+    # config
+
+    if plot_config.__class__.__name__ == 'Config':
+
+        kax = 'matrix'
+        if dax.get(kax) is not None:
+            ax = dax[kax]['handle']
+            plot_config.plot(lax=ax, proj='cross', dLeg=False)
+
+    # -------
     # connect
+
     if connect is True:
         coll2.setup_interactivity(kinter='inter0', dgroup=dgroup, dinc=dinc)
         coll2.disconnect_old()
         coll2.connect()
 
         coll2.show_commands()
         return coll2
     else:
         return coll2, dgroup
 
 
 def _plot_inversion_create_axes(
     fs=None,
     dmargin=None,
-    mtype=None,
+    nd=None,
     key_cam=None,
 ):
 
     if fs is None:
         fs = (16, 10)
 
     if dmargin is None:
@@ -778,29 +879,29 @@
     # axes for vertical profile
     ax1 = fig.add_subplot(gs[:2*nblock, 4], sharey=ax0)
 
     # axes for horizontal profile
     ax2 = fig.add_subplot(gs[2*nblock:, 2:4], sharex=ax0)
 
     # axes for radius
-    if mtype == 'polar':
+    if nd == '1d':
         ax7 = fig.add_subplot(gs[:nblock, :2], sharey=ax2)
     else:
         ax7 = None
 
     # axes for traces
     ax3 = fig.add_subplot(gs[nblock:2*nblock, :2])
 
     # dax
     dax = {
         # data
-        'matrix': {'handle': ax0, 'type': 'matrix'},
-        'vertical': {'handle': ax1, 'type': 'misc'},
-        'horizontal': {'handle': ax2, 'type': 'misc'},
-        'traces': {'handle': ax3, 'type': 'misc'},
+        'matrix': {'handle': ax0},
+        'vertical': {'handle': ax1},
+        'horizontal': {'handle': ax2},
+        'tracesZ': {'handle': ax3},
     }
     # axes for text
     # ax4 = fig.add_subplot(gs[:3, 5], frameon=False)
     # ax5 = fig.add_subplot(gs[3:, 5], frameon=False)
     # ax6 = fig.add_subplot(gs[4:, :2], frameon=False)
 
     # ------------------
@@ -817,11 +918,10 @@
     # parameters (chi2, ...)
     dax['inv-param'] = fig.add_subplot(gs[2*nblock:2*nblock+ncam, :2], sharex=ax3)
 
     # nb of iterations
     dax['niter'] = fig.add_subplot(gs[2*nblock+ncam:, :2], sharex=ax3)
 
     if ax7 is not None:
-        dax['radial'] = {'handle': ax7, 'type': 'misc'}
+        dax['radial'] = {'handle': ax7}
 
     return dax
-
```

### Comparing `tofu-1.6.5/tofu/data/_class1_bsplines_polar.py` & `tofu-1.7.0/tofu/data/_class7_check.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,798 +1,1064 @@
+# -*- coding: utf-8 -*-
 
 
 import numpy as np
-import scipy.interpolate as scpinterp
+import scipy.constants as scpct
+import datastock as ds
 
 
-from . import _utils_bsplines
+from . import _utils_surface3d
+from . import _class4_check
+
+from ..geom._comp_solidangles import _check_polygon_2d
+
+
+_DMAT_KEYS = {
+    'name': {
+        'types': str,
+        'can_be_None': True,
+    },
+    'symbol': {
+        'types': str,
+        'can_be_None': True,
+    },
+    'thickness': {
+        'types': float,
+        'sign': '> 0.',
+        'can_be_None': True,
+    },
+    'qeff_E': {
+        'dtype': float,
+        'sign': '> 0.',
+        'can_be_None': True,
+    },
+    'qeff': {
+        'dtype': float,
+        'sign': ['>= 0.', '<= 1.'],
+        'can_be_None': True,
+    },
+    'mode': {
+        'types': str,
+        'default': 'current',
+        'allowed': ['current', 'PHA'],
+        'can_be_None': False,
+    },
+    'bins': {
+        'dtype': float,
+        'sign': '>0.',
+        'unique': True,
+        'can_be_None': True,
+    },
+}
+
 
 
 # #############################################################################
 # #############################################################################
-#                   class
+#                   Camera 1d
 # #############################################################################
 
 
-class BivariateSplinePolar():
-    """ Subclass for tofu
-
-    Defined from knots (unique) and deg
-    coefs set to 1 by default
+def _camera_1d_check(
+    coll=None,
+    key=None,
+    # outline
+    outline_x0=None,
+    outline_x1=None,
+    # centers of all pixels
+    cents_x=None,
+    cents_y=None,
+    cents_z=None,
+    # inwards normal vectors
+    nin_x=None,
+    nin_y=None,
+    nin_z=None,
+    # orthonormal direct base
+    e0_x=None,
+    e0_y=None,
+    e0_z=None,
+    e1_x=None,
+    e1_y=None,
+    e1_z=None,
+):
 
-    Used self.set_coefs() to update
-    """
+    # ----
+    # key
 
-    def __init__(self, knotsr=None, knotsa=None, deg=None):
+    key = ds._generic_check._obj_key(
+        d0=coll.dobj.get('camera', {}), short='cam', key=key,
+    )
 
-        assert deg in [0, 1, 2, 3], deg
+    # ---------
+    # outline
 
-        # get knots pr bs
-        self._get_knots_per_bs_for_basis_elements(
-            knotsr=knotsr,
-            knotsa=knotsa,
-            deg=deg,
-        )
+    outline_x0, outline_x1, area = _check_polygon_2d(
+        poly_x=outline_x0,
+        poly_y=outline_x1,
+        poly_name=f'{key}-outline',
+        can_be_None=False,
+        closed=False,
+        counter_clockwise=True,
+        return_area=True,
+    )
 
-        # get nbs
-        self.nbs = np.sum(self.nbs_a_per_r)
+    # -----------
+    # cents
 
-        if self.knotsa is None:
-            self.shapebs = (self.nbs,)
-        elif np.unique(self.nbs_a_per_r).size == 1:
-            self.shapebs = (self.nbs_r, self.nbs_a_per_r[0])
-        else:
-            self.shapebs = (self.nbs,)
+    cents_x = np.atleast_1d(cents_x).ravel().astype(float)
+    cents_y = np.atleast_1d(cents_y).ravel().astype(float)
+    cents_z = np.atleast_1d(cents_z).ravel().astype(float)
+
+    # shapes
+    if not (cents_x.shape == cents_y.shape == cents_z.shape):
+        lstr = [
+            ('cents_x', cents_x.shape),
+            ('cents_y', cents_y.shape),
+            ('cents_z', cents_z.shape),
+        ]
+        lstr = [f"\t- {kk}.shape: {vv}" for kk, vv in lstr]
+        msg = (
+            "Args cents_x, cents_y, cents_z must have the same shape!\n"
+            + "\n".join(lstr)
+        )
+        raise Exception(msg)
 
-        # func to get coef from (ii, jj)
-        if self.knotsa is not None:
-            self.func_coef_ind = self._get_func_coef_ind()
+    iout = ~(
+        np.isfinite(cents_x) & np.isfinite(cents_y) & np.isfinite(cents_z)
+    )
+    if np.any(iout):
+        msg = (
+            f"Non-finite cents detected for cam1d '{key}':\n"
+            f"\t- indices: {iout.nonzero()[0]}\n"
+            f"\t- cents_x: {cents_x[iout]}\n"
+            f"\t- cents_y: {cents_y[iout]}\n"
+            f"\t- cents_z: {cents_z[iout]}\n"
+        )
+        raise Exception(msg)
 
-        # deg
-        self.deg = deg
+    # total nb of pixels
+    npix = cents_x.size
 
-    def _get_knots_per_bs_for_basis_elements(
-        self,
-        knotsr=None,
-        knotsa=None,
-        deg=None,
-    ):
+    # make sure all cents are different
+    dist = np.full((npix,), np.nan)
+    for ii in range(npix):
+        dist[:] = (
+            (cents_x - cents_x[ii])**2
+            + (cents_y - cents_y[ii])**2
+            + (cents_z - cents_z[ii])**2
+        )
+        dist[ii] = 10
+        if np.any(dist < 1.e-15):
+            msg = (
+                "Identical cents detected:\n"
+                f"\t- ref: {ii}\n"
+                f"\t- identicals: {(dist < 1.e-15).nonzero()[0]}\n"
+            )
+            raise Exception(msg)
 
-        # ------------------------------------
-        # get knots per bs in radius direction
+    # -----------
+    # unit vectors
 
-        knots_per_bs_r = _utils_bsplines._get_knots_per_bs(
-            knotsr, deg=deg, returnas='data',
+    lv = [
+        ['nin_x', nin_x], ['nin_y', nin_y], ['nin_z', nin_z],
+        ['e0_x', e0_x], ['e0_y', e0_y], ['e0_z', e0_z],
+        ['e1_x', e1_x], ['e1_y', e1_y], ['e1_z', e1_z],
+    ]
+
+    # check they are all provided
+    lNone = [vv[0] for vv in lv if vv[1] is None]
+    if len(lNone) > 0:
+        msg = (
+            f"All unit vectors must be provided for camera '{key}'!\n"
+            f"The following are not provided: {lNone}"
         )
-        knotsr_with_mult, nbsr = _utils_bsplines._get_knots_per_bs(
-            knotsr, deg=deg, returnas='data', return_unique=True,
+        raise Exception(msg)
+
+    # particular case: scalar because common to all
+    c0 = all([np.isscalar(vv[1]) for vv in lv])
+    if c0:
+        parallel = True
+        nin, e0, e1 = ds._generic_check._check_vectbasis(
+            e0=np.r_[nin_x, nin_y, nin_z],
+            e1=np.r_[e0_x, e0_y, e0_z],
+            e2=np.r_[e1_x, e1_y, e1_z],
+            dim=3,
         )
 
-        if nbsr != knots_per_bs_r.shape[1]:
-            msg = "Inconsistent nb. of splines in r direction"
+    else:
+
+        parallel = False
+
+        # force into numpy array
+        for vv in lv:
+            vv[1] = np.atleast_1d(vv[1]).ravel().astype(float)
+
+        # check shapes
+        dshape = {vv[0]: vv[1].shape for vv in lv if vv[1].shape != (npix,)}
+        if len(set(dshape.values())) > 1:
+            lstr = [f"\t- {k0}: {v0}" for k0, v0 in dshape.items()]
+            msg = (
+                f"All unit vector componant must have shape ({npix},)!\n"
+                + "\n".join(lstr)
+            )
             raise Exception(msg)
 
-        # ----------------
-        # check angle
+        # force normalization
+        norm = np.sqrt((lv[0][1]**2 + lv[1][1]**2 + lv[2][1]**2))
+        nin_x = lv[0][1] / norm
+        nin_y = lv[1][1] / norm
+        nin_z = lv[2][1] / norm
+
+        norm = np.sqrt((lv[3][1]**2 + lv[4][1]**2 + lv[5][1]**2))
+        e0_x = lv[3][1] / norm
+        e0_y = lv[4][1] / norm
+        e0_z = lv[5][1] / norm
+
+        norm = np.sqrt((lv[6][1]**2 + lv[7][1]**2 + lv[8][1]**2))
+        e1_x = lv[6][1] / norm
+        e1_y = lv[7][1] / norm
+        e1_z = lv[8][1] / norm
+
+        # check perpendicularity
+        sca = (nin_x*e0_x + nin_y*e0_y + nin_z*e0_z)
+        if np.any(np.abs(sca) > 1e-14):
+            msg = "Non-perpendicular nin vs e0:\n{(sca > 1.e-14).nonzero()[0]}"
+            raise Exception(msg)
+
+        sca = (nin_x*e1_x + nin_y*e1_y + nin_z*e1_z)
+        if np.any(np.abs(sca) > 1e-14):
+            msg = "Non-perpendicular nin vs e1:\n{(sca > 1.e-14).nonzero()[0]}"
+            raise Exception(msg)
 
-        if isinstance(knotsa, np.ndarray) and knotsa.ndim == 1:
-            knotsa = [knotsa for ii in range(nbsr)]
+        sca = (e0_x*e1_x + e0_y*e1_y + e0_z*e1_z)
+        if np.any(np.abs(sca) > 1e-14):
+            msg = "Non-perpendicular e0 vs e1:\n{(sca > 1.e-14).nonzero()[0]}"
+            raise Exception(msg)
 
-        c0 = (
-            isinstance(knotsa, list)
-            and len(knotsa) == nbsr
-            and all([
-                aa is None
-                or (
-                    isinstance(aa, np.ndarray)
-                    and aa.ndim == 1
-                    and np.allclose(
-                        aa,
-                        np.unique(np.arctan2(np.sin(aa), np.cos(aa))),
-                        equal_nan=False,
-                    )
-                )
-                for aa in knotsa
-            ])
+        # check right-handedness
+        sca = (
+            e1_x * (nin_y * e0_z - nin_z * e0_y)
+            + e1_y * (nin_z * e0_x - nin_x * e0_z)
+            + e1_z * (nin_x * e0_y - nin_y * e0_x)
         )
-        if knotsa is not None and not c0:
+        if np.any(sca <= 0.):
             msg = (
-                f"Arg angle must a list of {nbsr} elements, where each can be:\n"
-                "\t- None: no poloidal discretization\n"
-                "\t- array: 1d array of sorted angles in radians in [-pi, pi[\n"
-                f"Provided: {knotsa}"
+                "The following unit vectors do not seem right-handed:\n"
+                f"{(sca <= 0.).nonzero()[0]}"
             )
             raise Exception(msg)
 
-        # make sure to remove double angles
-        # particularly at edges (-pi vs pi)
-        if knotsa is not None:
-            for ii, aa in enumerate(knotsa):
-                if aa is not None:
-                    aa = np.unique(np.arctan2(np.sin(aa), np.cos(aa)))
-                    damin = np.min(np.diff(aa))
-                    if np.abs(aa[-1] - (aa[0] + 2.*np.pi)) < damin/100.:
-                        aa = aa[:-1]
-                    knotsa[ii] = aa
-
-        # ----------------
-        # Pre-compute bsplines basis elements
-
-        lbr = [
-            scpinterp.BSpline.basis_element(
-                knots_per_bs_r[:, ii],
-                extrapolate=False,
-            )
-            for ii in range(nbsr)
-        ]
+        nin = (nin_x, nin_y, nin_z)
+        e0 = (e0_x, e0_y, e0_z)
+        e1 = (e1_x, e1_y, e1_z)
+
+    return (
+        key,
+        outline_x0, outline_x1,
+        area,
+        cents_x,
+        cents_y,
+        cents_z,
+        npix,
+        parallel,
+        nin, e0, e1,
+    )
 
-        # angle bsplines
-        nbsa = np.ones((nbsr,), dtype=int)
-        if knotsa is not None:
-            lba = [[] for ii in range(nbsr)]
-            knots_per_bs_a = []
-            for ii in range(nbsr):
-
-                if knotsa[ii] is None:
-                    lba.append(None)
-                    knots_per_bs_a.append(None)
-                    continue
-
-                knots_per_bsai = _utils_bsplines._get_knots_per_bs(
-                    knotsa[ii],
-                    deg=deg,
-                    returnas='data',
-                    poloidal=True,
-                )
-
-                nbsa[ii] = knots_per_bsai.shape[1]
-                knots_per_bs_a.append(knots_per_bsai)
-
-                for jj in range(nbsa[ii]):
-                    kj = knots_per_bsai[:, jj]
-                    lba[ii].append(scpinterp.BSpline.basis_element(
-                        kj,
-                        extrapolate=False,
-                    ))
-                    if kj[0] >= kj[-1]:
-                        i2pi = np.r_[False, np.diff(kj) < 0].nonzero()[0][0]
-                        lba[ii][-1].t[deg + i2pi:] += 2.*np.pi
-        else:
-            lba = None
-            knots_per_bs_a = None
-
-        # ----------------
-        # bsplines centers
-
-        cents_per_bs_r = _utils_bsplines._get_cents_per_bs(
-            0.5*(knotsr[1:] + knotsr[:-1]),
-            deg=deg,
-            returnas='data',
-        )
-        if knotsa is None:
-            cents_per_bs_a = None
-        else:
-            cents_per_bs_a = [None for ii in range(nbsr)]
-            for ii in range(nbsr):
-                if knotsa[ii] is None:
-                    pass
-                else:
-                    cents_per_bs_a[ii] = _utils_bsplines._get_cents_per_bs(
-                        0.5*(knotsa[ii][1:] + knotsa[ii][:-1]),
-                        deg=deg,
-                        returnas='data',
-                        poloidal=True,
-                    )
-
-        # ----------------
-        # bsplines apex
-
-        apex_per_bs_r = _utils_bsplines._get_apex_per_bs(
-            knots=knotsr,
-            knots_per_bs=knots_per_bs_r,
-            deg=deg,
-        )
-        if knotsa is None:
-            apex_per_bs_a = None
-        else:
-            apex_per_bs_a = [None for ii in range(nbsr)]
-            for ii in range(nbsr):
-                if knotsa[ii] is None:
-                    pass
-                else:
-                    apex_per_bs_a[ii] = _utils_bsplines._get_apex_per_bs(
-            knots=knotsa[ii],
-            knots_per_bs=knots_per_bs_a[ii],
-            deg=deg,
-            poloidal=True,
-        )
-
-        # ------
-        # store
-
-        self.knotsr = knotsr
-        self.knotsa = knotsa
-        self.knotsr_with_mult = knotsr_with_mult
-        self.knotsa_with_mult = knotsa
-        self.knots_per_bs_r = knots_per_bs_r
-        self.knots_per_bs_a = knots_per_bs_a
-        self.cents_per_bs_r = cents_per_bs_r
-        self.cents_per_bs_a = cents_per_bs_a
-        self.apex_per_bs_r = apex_per_bs_r
-        self.apex_per_bs_a = apex_per_bs_a
-        self.nbs_r = nbsr
-        self.nbs_a_per_r = nbsa
-        self.lbr = lbr
-        self.lba = lba
-
-        # -----------------
-        # compute knots per bs for flattened 
-
-        # if deg == 0:
-            # pass
-        # else:
-            # knots_per_bs_r = np.concatenate(
-                # (
-                    # np.tile(knots_per_bs_r[0, :] - 1, (deg, 1)),
-                    # knots_per_bs_r,
-                    # np.tile(knots_per_bs_r[-1, :] + 1, (deg, 1)),
-                # ),
-                # axis=0,
-            # )
-
-            # for ii in range(nbsr):
-                # if knotsa[ii] is not None:
-                    # knots_per_bs_a[ii] = np.concatenate(
-                        # (
-                            # np.tile(knots_per_bs_a[ii][0, :] - 1, (deg, 1)),
-                            # knots_per_bs_a[ii],
-                            # np.tile(knots_per_bs_a[ii][-1, :] + 1, (deg, 1)),
-                        # ),
-                        # axis=0,
-                    # )
-
-        # self.knots_per_bs_r_pad = np.asfortranarray(knots_per_bs_r)
-        # self.knots_per_bs_a_pad = np.asfortranarray(knots_per_bs_a)
-
-    def _get_func_coef_ind(self):
-        def func(ii, jj):
-            return np.r_[0, np.cumsum(self.nbs_a_per_r)][ii] + jj
-        return func
-
-    def _check_radiusangle_input(self, radius=None, angle=None):
-
-        if not isinstance(radius, np.ndarray):
-            radius = np.atleast_1d(radius)
-
-        if self.knotsa is not None:
-            err = False
-            if angle is not None:
-                if not isinstance(angle, np.ndarray):
-                    angle = np.atleast_1d(angle)
-                if angle.shape != radius.shape:
-                    err = True
-            else:
-                if len(self.shapebs) == 2:
-                    err = True
-                else:
-                    shape = np.r_[np.ones((radius.ndim,), dtype=int), -1]
-                    kpbrmin = self.knots_per_bs_r[0, :].reshape(shape)
-                    kpbrmax = self.knots_per_bs_r[-1, :].reshape(shape)
-                    indr = (
-                        (radius[..., None] >= kpbrmin)
-                        & (radius[..., None] <= kpbrmax)
-                    )
-                    for ii in range(radius.ndim):
-                        indr = np.any(indr, axis=0)
-
-                    if np.any((self.nbs_a_per_r > 1) & indr):
-                        err = True
-            if err:
-                msg = (
-                    "Arg angle must be a np.ndarray same shape as radius!\n"
-                    f"\t- radius.shape = {radius.shape}\n"
-                    f"\t- angle = {angle}\n"
-                    "It should be an array of poloidal angles in radians"
-                )
-                raise Exception(msg)
-
-        return radius, angle
-
-    def _check_coefs(self, coefs=None):
-        """ None for ev_details, (nt, shapebs) for sum """
-        if coefs is not None:
-            assert coefs.ndim == len(self.shapebs) + 1
-            assert coefs.shape[1:] == self.shapebs
-
-    def __call__(
-        self,
-        # coordiantes
-        radius=None,
-        angle=None,
-        # coefs
-        coefs=None,
-        # options
-        radius_vs_time=None,
-        val_out=None,
-        # for purely radial only
-        deriv=None,
-        # for compatibility (unused)
-        indbs_tf=None,
-    ):
-        """ Assumes
-
-        coefs.shape = (nt, shapebs)
-
-        """
-
-        # ------------
-        # check inputs
-
-        if deriv is None:
-            deriv = 0
-        if self.knotsa is not None and deriv != 0:
-            msg = "Derivatives not-implemented for non-purely radial bsplines!"
-            raise Exception(msg)
 
-        # coefs
-        self._check_coefs(coefs=coefs)
+def _camera_1d(
+    coll=None,
+    key=None,
+    # common 2d outline
+    outline_x0=None,
+    outline_x1=None,
+    # centers of all pixels
+    cents_x=None,
+    cents_y=None,
+    cents_z=None,
+    # inwards normal vectors
+    nin_x=None,
+    nin_y=None,
+    nin_z=None,
+    # orthonormal direct base
+    e0_x=None,
+    e0_y=None,
+    e0_z=None,
+    e1_x=None,
+    e1_y=None,
+    e1_z=None,
+):
 
-        radius, angle = self._check_radiusangle_input(
-            radius=radius,
-            angle=angle,
-        )
-        nt = coefs.shape[0]
-
-        if radius_vs_time:
-            val = np.zeros(radius.shape)
-        else:
-            val = np.zeros(tuple(np.r_[nt, radius.shape]))
-
-        # ------------
-        # compute
-
-        if self.knotsa is None:
-            if radius_vs_time:
-                for it in range(nt):
-                    val[it, ...] = scpinterp.BSpline(
-                        self.knotsr_with_mult,
-                        coefs[it, :],
-                        self.deg,
-                        extrapolate=False,
-                    )(radius[it, ...], nu=deriv)
-            else:
-                for it in range(nt):
-                    val[it, ...] = scpinterp.BSpline(
-                        self.knotsr_with_mult,
-                        coefs[it, :],
-                        self.deg,
-                        extrapolate=False,
-                    )(radius, nu=deriv)
-
-        elif radius_vs_time:
-
-            for it in range(nt):
-                for ii, nbsa in enumerate(self.nbs_a_per_r):
-                    iok = (
-                        (radius[it, ...] >= self.knots_per_bs_r[0, ii])
-                        & ((radius[it, ...] < self.knots_per_bs_r[-1, ii]))
-                    )
-                    valr = self.lbr[ii](radius[it, iok])
-                    if nbsa == 1:
-                        ind = self.func_coef_ind(ii, 0)
-                        val[it, iok] += coefs[it, ind] * valr
-                    else:
-                        for jj in range(nbsa):
-                            kj = self.knots_per_bs_a[ii][:, jj]
-                            if kj[0] > kj[-1]:
-                                atemp = np.copy(angle[it, iok])
-                                atemp[atemp < kj[0]] += 2.*np.pi
-                                vala = self.lba[ii][jj](atemp)
-                            else:
-                                vala = self.lba[ii][jj](angle[it, iok])
-
-                            iokj = ~np.isnan(vala)
-                            if np.any(iokj):
-                                iok2 = np.copy(iok)
-                                iok2[iok2] = iokj
-                            else:
-                                continue
-
-                            if len(self.shapebs) == 1:
-                                ind = self.func_coef_ind(ii, jj)
-                                val[it, iok2] += (
-                                    coefs[it, ind] * (valr[iokj]*vala[iokj])
-                                )
-                            else:
-                                val[it, iok2] += (
-                                    coefs[it, ii, jj] * (valr[iokj]*vala[iokj])
-                                )
-
-        else:
-            for ii, nbsa in enumerate(self.nbs_a_per_r):
-                iok = (
-                    (radius >= self.knots_per_bs_r[0, ii])
-                    & ((radius < self.knots_per_bs_r[-1, ii]))
-                )
-                valr = self.lbr[ii](radius[iok])
-                if nbsa == 1:
-                    ind = self.func_coef_ind(ii, 0)
-                    val[:, iok] += coefs[:, ind][:, None] * valr[None, ...]
-                else:
-                    for jj in range(nbsa):
-                        kj = self.knots_per_bs_a[ii][:, jj]
-                        if kj[0] > kj[-1]:
-                            atemp = np.copy(angle[iok])
-                            atemp[atemp < kj[0]] += 2.*np.pi
-                            vala = self.lba[ii][jj](atemp)
-                        else:
-                            vala = self.lba[ii][jj](angle[iok])
-
-                        iokj = np.isfinite(vala)
-                        if np.any(iokj):
-                            iok2 = np.copy(iok)
-                            iok2[iok2] = iokj
-                        else:
-                            continue
-
-                        if len(self.shapebs) == 1:
-                            ind = self.func_coef_ind(ii, jj)
-                            val[:, iok2] += (
-                                coefs[:, ind][:, None]
-                                * (valr[iokj]*vala[iokj])[None, ...]
-                            )
-                        else:
-                            val[:, iok2] += (
-                                coefs[:, ii, jj][:, None]
-                                * (valr[iokj]*vala[iokj])[None, ...]
-                            )
-
-        # clean out-of-mesh
-        if val_out is not False:
-            # pts out 
-            indout = (
-                (radius < self.knotsr.min())
-                | (radius > self.knotsr.max())
-            )
-            if radius_vs_time:
-                val[indout] = val_out
-            else:
-                val[:, indout] = val_out
-
-        return val
-
-    def ev_details(
-        self,
-        # coordiantes
-        radius=None,
-        angle=None,
-        # options
-        indbs_tf=None,
-        deriv=None,
-        # for compatibility (unused)
-        coefs=None,
-        radius_vs_time=None,
-        val_out=None,
-    ):
-        """ Assumes
-
-        coefs.shape = (nt, shapebs)
-        indbs_tf = flat array of int indices
-
-        """
-
-        # ------------
-        # check inputs
-
-        radius, angle = self._check_radiusangle_input(
-            radius=radius,
-            angle=angle,
-        )
-
-        if indbs_tf is None:
-            nbs = self.nbs
-        else:
-            indbs_tf = np.atleast_1d(indbs_tf).ravel()
-            assert 'int' in indbs_tf.dtype.name, indbs_tf
-            assert np.unique(indbs_tf).size == indbs_tf.size
-            nbs = indbs_tf.size
-
-        if deriv is None:
-            deriv = 0
-
-        # --------
-        # prepare
-
-        shape = tuple(np.r_[radius.shape, nbs])
-        val = np.zeros(shape)
-
-        # ------------
-        # compute
-
-        if self.knotsa is None:
-
-            # radius only
-            ni = 0
-            for ii in range(self.nbs_r):
-
-                if indbs_tf is not None and ii not in indbs_tf:
-                    continue
-
-                iok = (
-                    (radius >= self.knots_per_bs_r[0, ii])
-                    & ((radius < self.knots_per_bs_r[-1, ii]))
-                )
-                if np.any(iok):
-                    val[iok, ni] = self.lbr[ii](radius[iok], nu=deriv)
-                ni += 1
-
-        else:
-
-            # if np.abs(np.nanmin(radius) - 0.1800309517775584) < 0.0001:
-                # import pdb.set_trace()      # DB  # chan = 27
-
-            # radius + angle
-            ni = 0
-            for ii, nbsa in enumerate(self.nbs_a_per_r):
-
-                c0 = (
-                    nbsa == 1
-                    and indbs_tf is not None
-                    and self.func_coef_ind(ii, 0) not in indbs_tf
-                )
-                if c0:
-                    continue
-
-                # compute valr
-                iok = (
-                    (radius >= self.knots_per_bs_r[0, ii])
-                    & ((radius < self.knots_per_bs_r[-1, ii]))
-                )
-
-                if not np.any(iok):
-                    ni += nbsa
-                    continue
-
-                valr = self.lbr[ii](radius[iok], nu=deriv)
-
-                # compute vala
-                if nbsa == 1:
-                    val[iok, ni] = valr
-                    ni += 1
-                else:
-                    if deriv > 0:
-                        msg = "Derivative > 0 not implemented for 2d splines"
-                        raise Exception(msg)
-
-                    for jj in range(nbsa):
-                        ind = self.func_coef_ind(ii, jj)
-
-                        if indbs_tf is not None and ind not in indbs_tf:
-                            continue
-
-                        kj = self.knots_per_bs_a[ii][:, jj]
-                        if kj[0] >= kj[-1]:
-                            atemp = np.copy(angle[iok])
-                            atemp[atemp < kj[0]] += 2.*np.pi
-                            vala = self.lba[ii][jj](atemp)
-                        else:
-                            vala = self.lba[ii][jj](angle[iok])
-
-                        iokj = np.isfinite(vala)
-                        if np.any(iokj):
-                            iok2 = np.copy(iok)
-                            iok2[iok2] = iokj
-                            val[iok2, ni] = valr[iokj]*vala[iokj]
-
-                        # if ii == 4 and jj == 3:
-                            # import pdb; pdb.set_trace()         # DB
-                        ni += 1
+    # ------------
+    # check inputs
 
-        return val
+    (
+        key,
+        outline_x0, outline_x1,
+        area,
+        cents_x,
+        cents_y,
+        cents_z,
+        npix,
+        parallel,
+        nin, e0, e1,
+    ) = _camera_1d_check(
+        coll=coll,
+        key=key,
+        # outline
+        outline_x0=outline_x0,
+        outline_x1=outline_x1,
+        # centers of all pixels
+        cents_x=cents_x,
+        cents_y=cents_y,
+        cents_z=cents_z,
+        # inwards normal vectors
+        nin_x=nin_x,
+        nin_y=nin_y,
+        nin_z=nin_z,
+        # orthonormal direct base
+        e0_x=e0_x,
+        e0_y=e0_y,
+        e0_z=e0_z,
+        e1_x=e1_x,
+        e1_y=e1_y,
+        e1_z=e1_z,
+    )
 
-    # -----------------
-    # constraints methods
-    # -----------------
+    # ----------
+    # dref
 
-    def get_constraints_out_rlim(
-        self,
-        rlim=None,
-        rm=None,
-        lim=None,
-    ):
-        """
-        Return indices of bslines fully out of rlim (min or max)
-
-        Assumes rlim is a 1d array, one per time step
-        """
+    npts = outline_x0.size
+    knpts = f'{key}-npts'
+    knpix = f'{key}-npix'
+    dref = {
+        knpts: {'size': npts},
+        knpix: {'size': npix},
+    }
+
+    # -------------
+    # ddata
+
+    kcx = f'{key}-cx'
+    kcy = f'{key}-cy'
+    kcz = f'{key}-cz'
+    kout0 = f'{key}_outx0'
+    kout1 = f'{key}_outx1'
+
+    ddata = {
+        kout0: {
+            'data': outline_x0,
+            'ref': knpts,
+            'dim': 'distance',
+            'quant': 'x0',
+            'name': 'x0',
+            'units': 'm',
+        },
+        kout1: {
+            'data': outline_x1,
+            'ref': knpts,
+            'dim': 'distance',
+            'quant': 'x1',
+            'name': 'x1',
+            'units': 'm',
+        },
+        kcx: {
+            'data': cents_x,
+            'ref': knpix,
+            'dim': 'distance',
+            'quant': 'x',
+            'name': 'x',
+            'units': 'm',
+        },
+        kcy: {
+            'data': cents_y,
+            'ref': knpix,
+            'dim': 'distance',
+            'quant': 'y',
+            'name': 'y',
+            'units': 'm',
+        },
+        kcz: {
+            'data': cents_z,
+            'ref': knpix,
+            'dim': 'distance',
+            'quant': 'z',
+            'name': 'z',
+            'units': 'm',
+        },
+    }
+
+    # -----
+    # dobj
+
+    if parallel:
+        o_nin = nin
+        o_e0 = e0
+        o_e1 = e1
+
+    else:
+        kinx = f'{key}-nin_x'
+        kiny = f'{key}-nin_y'
+        kinz = f'{key}-nin_z'
+        ke0x = f'{key}-e0_x'
+        ke0y = f'{key}-e0_y'
+        ke0z = f'{key}-e0_z'
+        ke1x = f'{key}-e1_x'
+        ke1y = f'{key}-e1_y'
+        ke1z = f'{key}-e1_z'
+
+        o_nin = (kinx, kiny, kinz)
+        o_e0 = (ke0x, ke0y, ke0z)
+        o_e1 = (ke1x, ke1y, ke1z)
+
+    # dobj
+    dobj = {
+        'camera': {
+            key: {
+                'dgeom': {
+                    'type': '1d',
+                    'parallel': parallel,
+                    'shape': (npix,),
+                    'ref': (knpix,),
+                    'ref_flat': (knpix,),
+                    'pix_area': area,
+                    'pix_nb': npix,
+                    'outline': (kout0, kout1),
+                    'cent': None,
+                    'cents': (kcx, kcy, kcz),
+                    'nin': o_nin,
+                    'e0': o_e0,
+                    'e1': o_e1,
+                },
+            },
+        },
+    }
+
+    # ------------------------
+    # parallel vs non-parallel
+
+    if not parallel:
+        ddata.update({
+            kinx: {
+                'data': nin[0],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'x',
+                'name': 'x',
+                'units': 'm',
+            },
+            kiny: {
+                'data': nin[1],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'y',
+                'name': 'y',
+                'units': 'm',
+            },
+            kinz: {
+                'data': nin[2],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'z',
+                'name': 'z',
+                'units': 'm',
+            },
+            ke0x: {
+                'data': e0[0],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'x',
+                'name': 'x',
+                'units': 'm',
+            },
+            ke0y: {
+                'data': e0[1],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'y',
+                'name': 'y',
+                'units': 'm',
+            },
+            ke0z: {
+                'data': e0[2],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'z',
+                'name': 'z',
+                'units': 'm',
+            },
+            ke1x: {
+                'data': e1[0],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'x',
+                'name': 'x',
+                'units': 'm',
+            },
+            ke1y: {
+                'data': e1[1],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'y',
+                'name': 'y',
+                'units': 'm',
+            },
+            ke1z: {
+                'data': e1[2],
+                'ref': knpix,
+                'dim': 'distance',
+                'quant': 'z',
+                'name': 'z',
+                'units': 'm',
+            },
+        })
+
+    return dref, ddata, dobj
+
+
+# ##################################################################
+# ##################################################################
+#                           Camera 2d
+# ##################################################################
 
 
-        # ------------
-        # check inputs
+def _camera_2d_check(
+    coll=None,
+    key=None,
+    # outline
+    outline_x0=None,
+    outline_x1=None,
+    # centers of all pixels
+    cent=None,
+    cents_x0=None,
+    cents_x1=None,
+    # inwards normal vectors
+    nin=None,
+    e0=None,
+    e1=None,
+):
 
-        if rm not in ['rmin', 'rmax']:
-            msg = f"Invalid rm!\nShould be in ['rmax', 'rmin']\nProvided: {rm}"
-            raise Exception(msg)
+    # ----
+    # key
 
-        if np.isscalar(rlim):
-            rlim = np.r_[rlim]
+    key = ds._generic_check._obj_key(
+        d0=coll.dobj.get('camera', {}), short='cam', key=key,
+    )
 
-        if not (isinstance(rlim, np.ndarray) and rlim.ndim == 1):
-            msg = "rlim must ba a 1d array!"
-            raise Exception(msg)
+    # ---------
+    # outline
 
-        # ------------
-        # get index of bsplines out of limits
+    outline_x0, outline_x1, area = _check_polygon_2d(
+        poly_x=outline_x0,
+        poly_y=outline_x1,
+        poly_name=f'{key}-outline',
+        can_be_None=False,
+        closed=False,
+        counter_clockwise=True,
+        return_area=True,
+    )
 
-        kpbsr = self.knots_per_bs_r
-        if rm == 'rmax':
-            if lim == 'allout':
-                ind = np.all(
-                    kpbsr[None, :, :] > rlim[:, None, None],
-                    axis=1,
-                )
-            elif lim == 'outer':
-                ind = np.sum(
-                    kpbsr[None, :, :] > rlim[:, None, None],
-                    axis=1,
-                ) > 1
-            elif lim == 'inner':
-                ind = np.any(
-                    kpbsr[None, :, :] > rlim[:, None, None],
-                    axis=1,
-                )
-
-        else:
-            if lim == 'allin':
-                ind = np.all(
-                    kpbsr[None, :, :] < rlim[:, None, None],
-                    axis=1,
-                )
-            elif lim == 'inner':
-                ind = np.sum(
-                    kpbsr[None, :, :] < rlim[:, None, None],
-                    axis=1,
-                ) > 1
-            elif lim == 'outer':
-                ind = np.any(
-                    kpbsr[None, :, :] < rlim[:, None, None],
-                    axis=1,
-                )
-
-        if self.knotsa is None:
-            pass
-        else:
-            ind = np.repeat(ind, self.nbs_a_per_r, axis=1)
-
-        # ------------
-        # get coefs / offset
-
-        offset = np.zeros((self.nbs,), dtype=float)
-
-        return ind, offset
-
-    def get_bs_per_pts(self, radius=None, angle=None):
-        """ Given points in radius / angle, return the indices of bsplines
-
-        Assumes:
-            - radius and angle are arrays of the same shape
-
-        Return:
-            - ind = (radius.shape, nbs), using flattened indexing
-
-        """
-
-
-    def get_constraints_deriv(
-        self,
-        deriv=None,
-        rad=None,
-        val=None,
-    ):
-        """
-        To set constraints on a derivative
-        Retrun indices of bsplines + coefs + offset
-
-        Assumes:
-            - deriv in ['deriv0', 'deriv1']
-            - rad and val are 1d arrays of the same shape
-
-        return as flattened nbsplines indexing
-
-        """
-        # ------------
-        # check inputs
-
-        ld = ['deriv0', 'deriv1']
-        if deriv not in ld:
-            msg = f"Arg deriv must be in {ld}!\n Provided: {deriv}"
-            raise Exception(msg)
+    # -----------
+    # cent
 
-        # --------
-        # compute
+    cent = np.atleast_1d(cent).ravel().astype(float)
+    if cent.shape != (3,) or np.any(~np.isfinite(cent)):
+        msg = f"Arg cent non valid shape {cent.shape} vs (3,) or non-finite!"
+        raise Exception(msg)
+
+    # -----------
+    # cents
+
+    cents_x0 = np.atleast_1d(cents_x0).ravel().astype(float)
+    cents_x1 = np.atleast_1d(cents_x1).ravel().astype(float)
+
+    # finite
+    iout = ~np.isfinite(cents_x0)
+    if np.any(iout):
+        msg = "Non-finite cents_x0 detected:\n{iout.nonzero()[0]}"
+        raise Exception(msg)
+
+    iout = ~np.isfinite(cents_x1)
+    if np.any(iout):
+        msg = "Non-finite cents_x1 detected:\n{iout.nonzero()[0]}"
+        raise Exception(msg)
+
+    # total nb of pixels
+    npix0 = cents_x0.size
+    npix1 = cents_x1.size
+
+    # make sure all cents are different
+    if np.unique(cents_x0).size != cents_x0.size:
+        msg = "Double values found in cents_x0!"
+        raise Exception(msg)
+
+    if np.unique(cents_x1).size != cents_x1.size:
+        msg = "Double values found in cents_x1!"
+        raise Exception(msg)
+
+    # -----------
+    # unit vectors
+
+    lv = [('nin', nin), ('e0', e0), ('e1', e1)]
+
+    # check they are all provided
+    lNone = [vv[0] for vv in lv if vv[1] is None]
+    if len(lNone) > 0:
+        msg = (
+            f"All unit vectors must be provided for camera '{key}'!\n"
+            f"The following are not provided: {lNone}"
+        )
+        raise Exception(msg)
 
-        # coefs per radius per bs (nrad, nbs)
-        ideriv = int(deriv[-1])
-        vv = self.ev_details(radius=rad, deriv=ideriv)
-
-        # check conflicts
-        indok = (vv != 0)
-        if np.unique(indok, axis=0).shape[0] < indok.shape[0]:
-            msg = f"Conflicting constraints on {deriv}:\n{indok}"
-            raise Exception(msg)
+    # particular case: scalar because common to all
+    nin, e0, e1 = ds._generic_check._check_vectbasis(
+        e0=nin,
+        e1=e0,
+        e2=e1,
+        dim=3,
+    )
 
-        coefs = vv
-        offset = np.repeat(val[:, None], self.nbs, axis=1)
+    return (
+        key,
+        outline_x0, outline_x1,
+        area,
+        cent,
+        cents_x0, cents_x1,
+        npix0, npix1,
+        nin, e0, e1,
+    )
 
-        return indok, coefs, offset
 
-    # -----------------
-    # operator methods
-    # -----------------
+def _camera_2d(
+    coll=None,
+    key=None,
+    # common 2d outline
+    outline_x0=None,
+    outline_x1=None,
+    # centers of all pixels
+    cent=None,
+    cents_x0=None,
+    cents_x1=None,
+    # inwards normal vectors
+    nin=None,
+    e0=None,
+    e1=None,
+):
 
-    def get_overlap(self):
-        return _get_overlap(
-            deg=self.degrees[0],
-            knotsx=self.knots_per_bs_x,
-            knotsy=self.knots_per_bs_y,
-            shapebs=self.shapebs,
-        )
-
-    def get_operator(
-        self,
-        operator=None,
-        geometry=None,
-        cropbs_flat=None,
-        # specific to deg = 0
-        cropbs=None,
-        centered=None,
-        # to return gradR, gradZ, for D1N2 deg 0, for tomotok
-        returnas_element=None,
-    ):
-        """ Get desired operator """
+    # ------------
+    # check inputs
 
-        msg = (
-            "Operator not implemented yet for polar bsplines!"
-        )
-        raise NotImplementedError(msg)
+    (
+        key,
+        outline_x0, outline_x1,
+        area,
+        cent,
+        cents_x0, cents_x1,
+        npix0, npix1,
+        nin, e0, e1,
+    ) = _camera_2d_check(
+        coll=coll,
+        key=key,
+        # outline
+        outline_x0=outline_x0,
+        outline_x1=outline_x1,
+        # centers of all pixels
+        cent=cent,
+        cents_x0=cents_x0,
+        cents_x1=cents_x1,
+        # inwards normal vectors
+        nin=nin,
+        e0=e0,
+        e1=e1,
+    )
 
+    # ----------
+    # dref
 
-# #############################################################################
-# #############################################################################
-#                       Mesh2DPolar - bsplines - overlap
-# #############################################################################
+    npts = outline_x0.size
+    knpts = f'{key}-npts'
+    knpix0 = f'{key}-npix0'
+    knpix1 = f'{key}-npix1'
+    knpix = f'{key}-npix'
+    dref = {
+        knpts: {'size': npts},
+        knpix0: {'size': npix0},
+        knpix1: {'size': npix1},
+        knpix: {'size': npix0*npix1},
+    }
+
+    # -------------
+    # ddata
+
+    kc0 = f'{key}-c0'
+    kc1 = f'{key}-c1'
+    kout0 = f'{key}_outx0'
+    kout1 = f'{key}_outx1'
+
+    ddata = {
+        kout0: {
+            'data': outline_x0,
+            'ref': knpts,
+            'dim': 'distance',
+            'quant': 'x0',
+            'name': 'x0',
+            'units': 'm',
+        },
+        kout1: {
+            'data': outline_x1,
+            'ref': knpts,
+            'dim': 'distance',
+            'quant': 'x1',
+            'name': 'x1',
+            'units': 'm',
+        },
+        kc0: {
+            'data': cents_x0,
+            'ref': knpix0,
+            'dim': 'distance',
+            'quant': 'x0',
+            'name': 'x0',
+            'units': 'm',
+        },
+        kc1: {
+            'data': cents_x1,
+            'ref': knpix1,
+            'dim': 'distance',
+            'quant': 'x1',
+            'name': 'x1',
+            'units': 'm',
+        },
+    }
+
+    # -----
+    # dobj
+
+    dobj = {
+        'camera': {
+            key: {
+                'dgeom': {
+                    'type': '2d',
+                    'parallel': True,
+                    'shape': (npix0, npix1),
+                    'ref': (knpix0, knpix1),
+                    'ref_flat': (knpix,),
+                    'pix_area': area,
+                    'pix_nb': npix0 * npix1,
+                    'outline': (kout0, kout1),
+                    'cent': cent,
+                    'cents': (kc0, kc1),
+                    'nin': nin,
+                    'e0': e0,
+                    'e1': e1,
+                },
+            },
+        },
+    }
+
+    return dref, ddata, dobj
+
+
+# ##################################################################
+# ##################################################################
+#                       Camera dmat
+# ##################################################################
 
 
-def _get_overlap(
-    deg=None,
-    knotsx=None,
-    knotsy=None,
-    shapebs=None,
+def _dmat(
+    coll=None,
+    key=None,
+    dmat=None,
 ):
-    raise NotImplementedError()
-    return inter
+    """ Check qeff is provided as a 1d vector vs lamb or energy
 
+    lamb is assumed to be in m and converted to energy
+    energy is assumed to be in eV
 
-# #############################################################################
-# #############################################################################
-#                   Main
-# #############################################################################
+    """
+
+    # ------------
+    # trivial case
+
+    if dmat is None:
+        return None, None, None
+
+    dref, ddata = {}, {}
+
+    # ------
+    # Check
+
+    # Check dict type and content (each key is a valid string)
+    dmat = ds._generic_check._check_dict_valid_keys(
+        var=dmat,
+        varname='dmat',
+        has_all_keys=False,
+        has_only_keys=True,
+        keys_can_be_None=None,
+        dkeys=_DMAT_KEYS,
+        return_copy=True,
+    )
+
+    if dmat.get('bins') is not None:
+        dmat['mode'] = 'PHA'
+
+    # -----------------
+    # check PHA vs bins
+
+    if dmat['mode'] == 'PHA':
+        if dmat.get('bins') is None:
+            msg = (
+                f"The bins (eV) must be provided for camera {key} in mode PHA!"
+            )
+            raise Exception(msg)
+
+        kb = f'{key}_bin'
+        coll.add_bins(
+            key=kb,
+            edges=dmat['bins'],
+            units='eV',
+            quant='E',
+            dim='energy',
+        )
+        dmat['bins'] = kb
+
+    # -----------------------------------
+    # check energy / qeff values
 
+    if all([dmat.get(kk) is not None for kk in ['energy', 'qeff']]):
 
-def get_bs2d_func(
-    deg=None,
-    knotsr=None,
-    angle=None,
-    knots_per_bs_r=None,
+        dmat['qeff_E'], dmat['qeff'] = _class4_check._dmat_energy_trans(
+            energ=dmat['qeff_E'],
+            trans=dmat['qeff'],
+        )
+
+        # ----------
+        # dref
+
+        kne = f'{key}_qnE'
+        ne = dmat['qeff_E'].size
+        dref[kne] = {'size': ne}
+
+        # ----------
+        # ddata
+
+        kqE = f'{key}_qE'
+        kqeff = f'{key}_qeff'
+
+        ddata.update({
+            kqE: {
+                'data': dmat['qeff_E'],
+                'ref': kne,
+                'dim': 'energy',
+                'quant': 'E',
+                'name': 'E',
+                'units': 'eV',
+            },
+            kqeff: {
+                'data': dmat['qeff'],
+                'ref': kne,
+                'dim': None,
+                'quant': 'quantum eff.',
+                'name': '',
+                'units': '',
+            },
+        })
+
+        # -----------
+        # dmat
+
+        dmat['qeff_E'] = kqE
+        dmat['qeff'] = kqeff
+
+    return dref, ddata, dmat
+
+
+# ##################################################################
+# ##################################################################
+#                           Utilities
+# ##################################################################
+
+
+def get_camera_unitvectors(
     coll=None,
+    key=None,
 ):
 
+    # ---------
+    # check key
+
+    lok = list(coll.dobj.get('camera', {}).keys())
+    key = ds._generic_check._check_var(
+        key, 'key',
+        types=str,
+        allowed=lok,
+    )
+
+    # ---------------------------
+    # get unit vector components
+
+    dgeom = coll.dobj['camera'][key]['dgeom']
+    if dgeom['parallel']:
+        dout = {
+            'nin_x': dgeom['nin'][0],
+            'nin_y': dgeom['nin'][1],
+            'nin_z': dgeom['nin'][2],
+            'e0_x':  dgeom['e0'][0],
+            'e0_y':  dgeom['e0'][1],
+            'e0_z':  dgeom['e0'][2],
+            'e1_x':  dgeom['e1'][0],
+            'e1_y':  dgeom['e1'][1],
+            'e1_z':  dgeom['e1'][2],
+        }
+    else:
+        dout = {
+            'nin_x': coll.ddata[dgeom['nin'][0]]['data'],
+            'nin_y': coll.ddata[dgeom['nin'][1]]['data'],
+            'nin_z': coll.ddata[dgeom['nin'][2]]['data'],
+            'e0_x':  coll.ddata[dgeom['e0'][0]]['data'],
+            'e0_y':  coll.ddata[dgeom['e0'][1]]['data'],
+            'e0_z':  coll.ddata[dgeom['e0'][2]]['data'],
+            'e1_x':  coll.ddata[dgeom['e1'][0]]['data'],
+            'e1_y':  coll.ddata[dgeom['e1'][1]]['data'],
+            'e1_z':  coll.ddata[dgeom['e1'][2]]['data'],
+        }
+
+    return dout
+
+
+def get_camera_dxyz(coll=None, key=None, include_center=None):
+
+    # ---------
+    # check key
+
+    lok = [
+        k0 for k0, v0 in coll.dobj.get('camera', {}).items()
+        if v0['dgeom']['parallel'] is True
+    ]
+    key = ds._generic_check._check_var(
+        key, 'key',
+        types=str,
+        allowed=lok,
+    )
+
+    dgeom = coll.dobj['camera'][key]['dgeom']
+
+    # include_center
+    include_center = ds._generic_check._check_var(
+        include_center, 'include_center',
+        types=bool,
+        default=True,
+    )
+
     # ----------------
-    # Define functions
+    # get unit vectors
+
+    e0 = dgeom['e0']
+    e1 = dgeom['e1']
+
+    out0 = coll.ddata[dgeom['outline'][0]]['data']
+    out1 = coll.ddata[dgeom['outline'][1]]['data']
+
+    if include_center is True:
+        out0 = np.append(0, out0)
+        out1 = np.append(0, out1)
+
+    dx = out0 * e0[0] + out1 * e1[0]
+    dy = out0 * e0[1] + out1 * e1[1]
+    dz = out0 * e0[2] + out1 * e1[2]
+
+    return dx, dy, dz
+
+
+def get_camera_cents_xyz(coll=None, key=None):
+
+    # ---------
+    # check key
 
-    PolarBiv_scipy = BivariateSplinePolar(
-        knotsr=knotsr,
-        knotsa=angle,
-        deg=deg,
+    lok = list(coll.dobj.get('camera', {}).keys())
+    key = ds._generic_check._check_var(
+        key, 'key',
+        types=str,
+        allowed=lok,
     )
 
-    return PolarBiv_scipy.ev_details, PolarBiv_scipy.__call__, PolarBiv_scipy
+    # ---------------------------
+    # get unit vector components
+
+    dgeom = coll.dobj['camera'][key]['dgeom']
+    if dgeom['type'] == '1d':
+        cx = coll.ddata[dgeom['cents'][0]]['data']
+        cy = coll.ddata[dgeom['cents'][1]]['data']
+        cz = coll.ddata[dgeom['cents'][2]]['data']
+    else:
+        c0 = coll.ddata[dgeom['cents'][0]]['data']
+        c1 = coll.ddata[dgeom['cents'][1]]['data']
+
+        cx = (
+            dgeom['cent'][0]
+            + np.repeat(c0[:, None], c1.size, axis=1) * dgeom['e0'][0]
+            + np.repeat(c1[None, :], c0.size, axis=0) * dgeom['e1'][0]
+        )
+        cy = (
+            dgeom['cent'][1]
+            + np.repeat(c0[:, None], c1.size, axis=1) * dgeom['e0'][1]
+            + np.repeat(c1[None, :], c0.size, axis=0) * dgeom['e1'][1]
+        )
+        cz = (
+            dgeom['cent'][2]
+            + np.repeat(c0[:, None], c1.size, axis=1) * dgeom['e0'][2]
+            + np.repeat(c1[None, :], c0.size, axis=0) * dgeom['e1'][2]
+        )
+
+    return cx, cy, cz
+
+
+def get_camera_2d_outline(coll=None, key=None, closed=None):
+
+    # ---------
+    # check key
+
+    lok = [
+        k0 for k0, v0 in coll.dobj.get('camera', {}).items()
+        if v0['dgeom']['type'] == '2d'
+    ]
+    key = ds._generic_check._check_var(
+        key, 'key',
+        types=str,
+        allowed=lok,
+    )
+    
+    # closed
+    closed = ds._generic_check._check_var(
+        closed, 'closed',
+        types=bool,
+        default=False,
+    )
+
+    # ------------------
+    # prepare
+
+    dgeom = coll.dobj['camera'][key]['dgeom']
+
+    # camera nb pixels and pixel outline
+    n0, n1 = dgeom['shape']
+    kout0, kout1 = dgeom['outline']
+    out0 = coll.ddata[kout0]['data']
+    out1 = coll.ddata[kout1]['data']
+    
+    # ------------------
+    # get total outline
+    
+    # assuming pixels are rectangular
+    dx0 = out0.max() - out0.min()
+    dx1 = out1.max() - out1.min()
+    
+    # indices
+    ind0 = np.r_[-1, 1, 1, -1, -1]
+    ind1 = np.r_[-1, -1, 1, 1, -1]
+    if closed is True:
+        ind0 = np.r_[ind0, ind0[0]]
+        ind1 = np.r_[ind1, ind1[0]]
+        
+    # outline total
+    out_tot0 = dx0 * (n0/2.) * ind0
+    out_tot1 = dx1 * (n1/2.) * ind1
+    
+    return out_tot0, out_tot1
```

### Comparing `tofu-1.6.5/tofu/data/_class1_bsplines_rect.py` & `tofu-1.7.0/tofu/data/_class7_compute.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,434 +1,523 @@
 # -*- coding: utf-8 -*-
 
 
 # Built-in
+import copy
 
 
 # Common
 import numpy as np
-import scipy.interpolate as scpinterp
+import datastock as ds
 
 
-# specific
-from . import _generic_check
-from . import _utils_bsplines
-from . import _class1_bsplines_operators_rect
+_DPINHOLE = {
+    # center
+    'x': None,
+    'y': None,
+    'R': 3.,
+    'z': 0.,
+    'phi': 0.,
+    # angles
+    'theta': np.pi,
+    'dphi': 0.,
+    'tilt': 0,
+}
+
+
+# ##########################################################################
+# ##########################################################################
+#                   Add pinhole camera
+# ##########################################################################
+
+
+def add_camera_pinhole(
+    coll=None,
+    key=None,
+    key_pinhole=None,
+    key_diag=None,
+    cam_type=None,
+    # position
+    x=None,
+    y=None,
+    R=None,
+    z=None,
+    phi=None,
+    # orientation
+    theta=None,
+    dphi=None,
+    tilt=None,
+    # camera
+    focal=None,
+    pix_nb=None,
+    pix_size=None,
+    pix_spacing=None,
+    # pinhole
+    pinhole_radius=None,
+    pinhole_size=None,
+    # reflections
+    reflections_nb=None,
+    reflections_type=None,
+    # diagnostic
+    compute=None,
+    config=None,
+    length=None,
+    # dmat
+    dmat=None,
+):
 
+    # --------------
+    # check inputs
 
-# #############################################################################
-# #############################################################################
-#                       BivariateSplineRect - scipy subclass
-# #############################################################################
+    key, key_pinhole, key_diag, newdiag = _check_camera_pinhole(
+        coll=coll,
+        key=key,
+        key_pinhole=key_pinhole,
+        key_diag=key_diag,
+    )
 
+    # ------------------------
+    # compute pinhole position
 
-class BivariateSplineRect(scpinterp.BivariateSpline):
-    """ Subclass for tofu
+    pc, nin, e0, e1 = _pinhole_position(
+        # center
+        x=x,
+        y=y,
+        R=R,
+        z=z,
+        phi=phi,
+        # angles
+        theta=theta,
+        dphi=dphi,
+        tilt=tilt,
+    )
 
-    Defined from knots (unique) and deg
-    coefs set to 1 by default
+    # ------------------------
+    # compute pinhole contour
 
-    Used self.set_coefs() to update
-    """
+    pin_out0, pin_out1 = _pinhole_contour(
+        pinhole_radius=pinhole_radius,
+        pinhole_size=pinhole_size,
+    )
 
-    def __init__(self, knotsR=None, knotsZ=None, deg=None, shapebs=None):
+    dgeom_pin = {
+        'cent': pc,
+        'nin': nin,
+        'e0': e0,
+        'e1': e1,
+        'outline_x0': pin_out0,
+        'outline_x1': pin_out1,
+    }
+
+    # ------------------------
+    # compute camera position
+
+    dgeom_cam, cam_type = _camera_position(
+        dgeom_pin=dgeom_pin,
+        cam_type=cam_type,
+        focal=focal,
+        pix_nb=pix_nb,
+        pix_size=pix_size,
+        pix_spacing=pix_spacing,
+    )
 
-        assert np.allclose(np.unique(knotsR), knotsR)
-        assert np.allclose(np.unique(knotsZ), knotsZ)
-        assert deg in [0, 1, 2, 3]
+    # -------
+    # store
 
-        # get knots pr bs
-        self._get_knots_per_bs_for_basis_elements(
-            knotsR=knotsR,
-            knotsZ=knotsZ,
-            deg=deg,
-        )
+    _add_camera_pinhole_store(
+        coll=coll,
+        key=key,
+        key_pinhole=key_pinhole,
+        key_diag=key_diag,
+        cam_type=cam_type,
+        dgeom_pin=dgeom_pin,
+        dgeom_cam=dgeom_cam,
+        newdiag=newdiag,
+        # reflections
+        reflections_nb=reflections_nb,
+        reflections_type=reflections_type,
+        compute=compute,
+        config=config,
+        length=length,
+        # dmat
+        dmat=dmat,
+    )
 
-        # full knots with multiplicity
-        knotsR, nbsR = _utils_bsplines._get_knots_per_bs(
-            knotsR, deg=deg, returnas='data', return_unique=True,
-        )
-        knotsZ, nbsZ = _utils_bsplines._get_knots_per_bs(
-            knotsZ, deg=deg, returnas='data', return_unique=True,
-        )
 
-        coefs = np.ones((nbsR*nbsZ,), dtype=float)
+def _check_camera_pinhole(
+    coll=None,
+    key=None,
+    key_pinhole=None,
+    key_diag=None,
+):
+    # key
+    lout = list(coll.dobj.get('camera', {}).keys())
+    key = ds._generic_check._check_var(
+        key, 'key',
+        types=str,
+        excluded=lout,
+    )
 
-        self.__nbs = (nbsR, nbsZ)
-        self.tck = [knotsR, knotsZ, coefs]
-        self.degrees = [deg, deg]
-
-        # shapebs
-        self.shapebs = shapebs
-
-    def _get_knots_per_bs_for_basis_elements(
-        self,
-        knotsR=None,
-        knotsZ=None,
-        deg=None,
-    ):
-
-        # added for details
-        knots_per_bs_x = _utils_bsplines._get_knots_per_bs(
-            knotsR, deg=deg, returnas='data',
-        )
-        knots_per_bs_y = _utils_bsplines._get_knots_per_bs(
-            knotsZ, deg=deg, returnas='data',
+    # key_pinhole
+    if key_pinhole is None:
+        key_pinhole = f'{key}_pin'
+
+    lout = list(coll.dobj.get('aperture', {}).keys())
+    key_pinhole = ds._generic_check._check_var(
+        key_pinhole, 'key_pinhole',
+        types=str,
+        excluded=lout,
+    )
+
+    # key_diag
+    if key_diag is not None:
+        lok = list(coll.dobj.get('diagnostic', {}).keys())
+        key_diag = ds._generic_check._check_var(
+            key_diag, 'key_diag',
+            types=str,
         )
 
-        self.knots_per_bs_x = knots_per_bs_x
-        self.knots_per_bs_y = knots_per_bs_y
+        newdiag = key_diag not in lok
+    else:
+        newdiag = True
 
-        if deg == 0:
-            pass
-        else:
-            knots_per_bs_x = np.concatenate(
-                (
-                    np.tile(knots_per_bs_x[0, :] - 1, (deg, 1)),
-                    knots_per_bs_x,
-                    np.tile(knots_per_bs_x[-1, :] + 1, (deg, 1)),
-                ),
-                axis=0,
-            )
-            knots_per_bs_y = np.concatenate(
-                (
-                    np.tile(knots_per_bs_y[0, :] - 1, (deg, 1)),
-                    knots_per_bs_y,
-                    np.tile(knots_per_bs_y[-1, :] + 1, (deg, 1)),
-                ),
-                axis=0,
-            )
-
-        self.knots_per_bs_x_pad = np.asfortranarray(knots_per_bs_x)
-        self.knots_per_bs_y_pad = np.asfortranarray(knots_per_bs_y)
-
-    def _check_coefs(self, coefs=None):
-        """ None for ev_details, (nt, shapebs) for sum """
-        if coefs is not None:
-            assert coefs.ndim == len(self.shapebs) + 1
-            assert coefs.shape[1:] == self.shapebs
-
-    def set_coefs(
-        self,
-        coefs=None,
-        cropbs_neg_flat=None,
-    ):
-
-        nbs = self.__nbs[0]*self.__nbs[1]
-        if coefs.shape == self.shapebs:
-            self.tck[2][...] = coefs.ravel()
-        elif coefs.shape == (self.nbs,):
-            self.tck[2][...] = coefs
-        else:
-            msg = f"Wrong coefs shape!\nProvided: {coefs.shape}"
-            raise Exception(msg)
-
-        # ------------
-        # crop and set
-
-        if cropbs_neg_flat is not None:
-            self.tck[2][cropbs_neg_flat] = 0.
-
-    def __call__(
-        self,
-        R=None,
-        Z=None,
-        coefs=None,
-        crop=None,
-        cropbs=None,
-        val_out=None,
-        # for compatibility (unused)
-        indbs_tf=None,
-    ):
-
-        if val_out is None:
-            val_out = np.nan
-
-        # coefs
-        self._check_coefs(coefs=coefs)
-
-        # r, z
-        r, z, crop = _check_RZ_crop(
-            R=R,
-            Z=Z,
-            crop=crop,
-            cropbs=cropbs,
-        )
+    return key, key_pinhole, key_diag, newdiag
 
-        # prepare
-        nt = coefs.shape[0]
-        shape = tuple(np.r_[nt, r.shape])
-        val = np.zeros(shape, dtype=float)
-        cropbs_neg_flat = ~cropbs.ravel() if crop else None
-
-        # interpolate
-        for ii in range(nt):
-            # prepare
-            self.set_coefs(
-                coefs=coefs[ii, ...],
-                cropbs_neg_flat=cropbs_neg_flat,
-            )
-
-            # compute
-            val[ii, ...] = super().__call__(r, z, grid=False)
-
-        # clean
-        if val_out is not False:
-            indout = (
-                (r < self.tck[0][0]) | (r > self.tck[0][-1])
-                | (z < self.tck[1][0]) | (z > self.tck[1][-1])
-            )
-            val[:, indout] = val_out
-        return val
-
-    def ev_details(
-        self,
-        R=None,
-        Z=None,
-        indbs_tf=None,
-        crop=None,
-        cropbs=None,
-        # for compatibility (unused)
-        coefs=None,
-        val_out=None,
-    ):
-        """
-        indbs_tf = (ar0, ar1)
-            tuple of 2 flat arrays of int (for R and Z)
-        """
-
-        # -----------
-        # check input
-
-        x, y, crop = _check_RZ_crop(
-            R=R,
-            Z=Z,
-            crop=crop,
-            cropbs=cropbs,
-        )
 
-        # -----------
-        # prepare
+def _pinhole_position(
+    # center
+    x=None,
+    y=None,
+    R=None,
+    z=None,
+    phi=None,
+    # angles
+    theta=None,
+    dphi=None,
+    tilt=None,
+    # default
+    ddef=None,
+):
 
-        deg = self.degrees[0]
-        nbs = indbs_tf[0].size
-        shape = x.shape
-        x = np.ascontiguousarray(x.ravel(), dtype=float)
-        y = np.ascontiguousarray(y.ravel(), dtype=float)
-        coef = np.zeros((deg + 4, 1), dtype=float)
-        coef[deg] = 1.
-        outy = np.full((x.size, 1), np.nan)
+    # -------------
+    # check inputs
 
-        # -----------
-        # compute
+    # ddef
+    if ddef is None:
+        ddef = _DPINHOLE
+
+    # (x, y) vs (R, phi)
+    lc = [
+        x is not None or y is not None,
+        R is not None or phi is not None,
+    ]
+    if np.sum(lc) > 1:
+        msg = "Please provide (x, y) xor (R, phi) !"
+        raise Exception(msg)
 
-        val = np.zeros(tuple(np.r_[x.size, nbs]))
-        indtot = np.arange(0, nbs)
+    # (x, y) vs (R, phi)
+    if lc[0]:
+        if x is None:
+            x = ddef['x']
+        if y is None:
+            y = ddef['y']
+        R = np.hypot(x, y)
+        phi = np.arctan2(y, x)
+    else:
+        if R is None:
+            R = ddef['R']
+        if phi is None:
+            phi = ddef['phi']
+        x = R * np.cos(phi)
+        y = R * np.sin(phi)
+
+    # z
+    if z is None:
+        z = ddef['z']
+
+    # dphi
+    if dphi is None:
+        dphi = ddef['dphi']
+
+    # theta
+    if theta is None:
+        theta = ddef['theta']
+
+    # tilt
+    if tilt is None:
+        tilt = ddef['tilt']
+
+    # -------------
+    # compute
+
+    # unit vectors of reference
+    eR = np.r_[np.cos(phi), np.sin(phi), 0.]
+    ephi = np.r_[-np.sin(phi), np.cos(phi), 0.]
+    er = np.cos(theta) * eR + np.sin(theta) * np.r_[0, 0, 1]
+    etheta = -np.sin(theta) * eR + np.cos(theta) * np.r_[0, 0, 1]
+    e0bis = -np.cos(dphi) * ephi + np.sin(dphi) * er
+
+    # translation
+    pc = np.r_[x, y, z]
+
+    # unit vectors after rotation
+    nin = np.cos(dphi) * er + np.sin(dphi) * ephi
+    e0 = np.cos(tilt) * e0bis + np.sin(tilt) * etheta
+    e1 = np.cross(nin, e0)
+
+    # safety check
+    nin, e0, e1 = ds._generic_check._check_vectbasis(
+        e0=nin,
+        e1=e0,
+        e2=e1,
+        dim=3,
+        tol=1e-12,
+    )
 
-        iz_u = np.unique(indbs_tf[1])
+    return pc, nin, e0, e1
 
-        for iz in iz_u:
 
-            scpinterp._bspl.evaluate_spline(
-                self.knots_per_bs_y_pad[:, iz],
-                coef,
-                self.degrees[1],
-                y,
-                0,
-                False,
-                outy,
-            )
-
-            indoky = ~np.isnan(outy)
-            if not np.any(indoky):
-                continue
-            indokx = np.copy(indoky)
-
-            indr = indbs_tf[1] == iz
-            ir = indbs_tf[0][indr]
-            for ii, iir in enumerate(ir):
-
-                if ii > 0:
-                    indokx[...] = indoky
-
-                outx = np.full((indoky.sum(), 1), np.nan)
-
-                scpinterp._bspl.evaluate_spline(
-                    self.knots_per_bs_x_pad[:, iir],
-                    coef,
-                    self.degrees[0],
-                    x[indoky[:, 0]],
-                    0,
-                    False,
-                    outx,
-                )
-
-                ixok = ~np.isnan(outx)
-                if not np.any(ixok):
-                    continue
-
-                indokx[indoky] = ixok[:, 0]
-                val[indokx[:, 0], indtot[indr][ii]] = (outx[ixok]*outy[indokx])
-
-        if shape != x.shape:
-            val = np.reshape(val, tuple(np.r_[shape, -1]))
-
-        return val
-
-    def get_overlap(self):
-        return _get_overlap(
-            deg=self.degrees[0],
-            knotsx=self.knots_per_bs_x,
-            knotsy=self.knots_per_bs_y,
-            shapebs=self.shapebs,
-        )
+def _pinhole_contour(
+    pinhole_radius=None,
+    pinhole_size=None,
+):
+
+    # ------
+    # check
 
-    def get_operator(
-        self,
-        operator=None,
-        geometry=None,
-        cropbs_flat=None,
-        # specific to deg = 0
-        cropbs=None,
-        centered=None,
-        # to return gradR, gradZ, for D1N2 deg 0, for tomotok
-        returnas_element=None,
-    ):
-        """ Get desired operator """
-        return _class1_bsplines_operators_rect.get_mesh2dRect_operators(
-            deg=self.degrees[0],
-            operator=operator,
-            geometry=geometry,
-            knotsx_mult=self.tck[0],
-            knotsy_mult=self.tck[1],
-            knotsx_per_bs=self.knots_per_bs_x,
-            knotsy_per_bs=self.knots_per_bs_y,
-            overlap=self.get_overlap(),
-            cropbs_flat=cropbs_flat,
-            # specific to deg = 0
-            cropbs=cropbs,
-            centered=centered,
-            # to return gradR, gradZ, for D1N2 deg 0, for tomotok
-            returnas_element=returnas_element,
+    if pinhole_radius is not None and pinhole_size is not None:
+        msg = (
+            "Please provide pinhole_radius xor pinhole_size!\n"
+            "\t- pinhole_radius: created a circular pinhole\n"
+            "\t- pinhole_size: created a rectangular pinhole\n"
         )
+        raise Exception(msg)
 
+    # ----------
+    # compute
 
-# #############################################################################
-# #############################################################################
-#                       Mesh2DRect - bsplines - overlap
-# #############################################################################
+    # circular
+    if pinhole_radius is not None:
 
+        # check
+        pinhole_radius = ds._generic_check._check_var(
+            pinhole_radius, 'pinhole_radius',
+            types=(int, float),
+            sign='> 0.',
+        )
 
-def _get_overlap(
-    deg=None,
-    knotsx=None,
-    knotsy=None,
-    shapebs=None,
-):
-    # nb of overlapping, inc. itself in 1d
-    nbsR, nbsZ = shapebs
-    indR0 = np.tile(np.arange(0, nbsR), nbsZ)
-    indZ0 = np.repeat(np.arange(0, nbsZ), nbsR)
+        # compute
+        theta = np.pi * np.linspace(-1, 1, 50)[:-1]
+        out0 = pinhole_radius * np.cos(theta)
+        out1 = pinhole_radius * np.sin(theta)
+
+    else:
+        # check
+        if np.isscalar(pinhole_size):
+            pinhole_size = [pinhole_size, pinhole_size]
+
+        pinhole_size = ds._generic_check._check_flat1darray(
+            pinhole_size, 'pinhole_size',
+            dtype=float,
+            size=2,
+            sign='> 0.',
+            norm=False,
+            can_be_None=False,
+        )
 
-    # complete
-    ntot = 2*deg + 1
+        # compute
+        out0 = pinhole_size[0] * np.r_[-1, 1, 1, -1]
+        out1 = pinhole_size[1] * np.r_[-1, -1, 1, 1]
 
-    addR = np.tile(np.arange(-deg, deg+1), ntot)
-    addZ = np.repeat(np.arange(-deg, deg+1), ntot)
+    return out0, out1
 
-    interR = indR0[None, :] + addR[:, None]
-    interZ = indZ0[None, :] + addZ[:, None]
+def _camera_position(
+    dgeom_pin=None,
+    cam_type=None,
+    focal=None,
+    pix_nb=None,
+    pix_size=None,
+    pix_spacing=None,
+):
 
-    # purge
-    inter = interR + interZ*nbsR
-    indneg = (
-        (interR < 0) | (interR >= nbsR) | (interZ < 0) | (interZ >= nbsZ)
+    # -------------
+    # check
+
+    # cam_type
+    cam_type = ds._generic_check._check_var(
+        cam_type, 'cam_type',
+        types=str,
+        default='1d',
+        allowed=['1d', '2d'],
     )
-    inter[indneg] = -1
 
-    return inter
+    # cam_type
+    focal = ds._generic_check._check_var(
+        focal,'focal',
+        types=(int, float),
+        default=0.1,
+        sign='>0.',
+    )
 
+    if cam_type == '1d':
 
-# #############################################################################
-# #############################################################################
-#                           Mesh2DRect - bsplines
-# #############################################################################
+        # pix_nb
+        pix_nb = ds._generic_check._check_var(
+            pix_nb, 'pix_nb',
+            types=int,
+            sign='> 0',
+        )
 
+        # pix_spacing
+        pix_spacing = ds._generic_check._check_var(
+            pix_spacing, 'pix_spacing',
+            types=(float, int),
+            default=0,
+            sign='>= 0',
+        )
 
-def _check_RZ_crop(
-    R=None,
-    Z=None,
-    crop=None,
-    cropbs=None,
-):
+    else:
 
-    # R, Z
-    if not isinstance(R, np.ndarray):
-        R = np.atleast_1d(R)
-    if not isinstance(Z, np.ndarray):
-        Z = np.atleast_1d(Z)
-    assert R.shape == Z.shape
-
-    # crop
-    if crop is None:
-        crop = True
-    if not isinstance(crop, bool):
-        msg = (
-            "Arg crop must be a bool!\n"
-            f"Provided: {crop}"
+        # pix_nb
+        if np.isscalar(pix_nb):
+            pix_nb = pix_nb * np.r_[1, 1]
+
+        pix_nb = ds._generic_check._check_flat1darray(
+            pix_nb, 'pix_nb',
+            size=2,
+            dtype=int,
+            sign='> 0',
         )
-        raise Exception(msg)
-    crop = crop and cropbs is not None and cropbs is not False
 
-    return R, Z, crop
+        # pix_spacing
+        if pix_spacing is None:
+            pix_spacing = 0.
+        if np.isscalar(pix_spacing):
+            pix_spacing = pix_spacing * np.r_[1, 1]
+
+        pix_spacing = ds._generic_check._check_flat1darray(
+            pix_spacing, 'pix_spacing',
+            size=2,
+            dtype=float,
+            sign='>= 0',
+        )
 
+    # pix_size
+    if np.isscalar(pix_size):
+        pix_size = pix_size * np.r_[1, 1]
+
+    pix_size = ds._generic_check._check_flat1darray(
+        pix_size, 'pix_size',
+        size=2,
+        dtype=float,
+        sign='> 0',
+    )
 
-def get_bs2d_RZ(deg=None, Rknots=None, Zknots=None):
+    # ----------
+    # compute
 
-    # ----------------
-    # get knots per bspline, nb of bsplines...
+    dgeom_cam = copy.deepcopy(dgeom_pin)
+    cent = dgeom_pin['cent'] - focal * dgeom_pin['nin']
 
-    knots_per_bs_R = _utils_bsplines._get_knots_per_bs(
-        Rknots, deg=deg, returnas='data',
-    )
-    knots_per_bs_Z = _utils_bsplines._get_knots_per_bs(
-        Zknots, deg=deg, returnas='data',
-    )
-    nbkbs = knots_per_bs_R.shape[0]
-    shapebs = (knots_per_bs_R.shape[1], knots_per_bs_Z.shape[1])
+    if cam_type == '1d':
 
-    # ----------------
-    # get centers of bsplines
+        # vectors
+        for k0 in ['nin', 'e0', 'e1']:
+            for ii, ss in enumerate(['x', 'y', 'z']):
+                dgeom_cam[f'{k0}_{ss}'] = dgeom_cam[k0][ii]
+            del dgeom_cam[k0]
+
+        # cents
+        dd = (pix_size[0] + pix_spacing) * np.arange(0, pix_nb)
+        dd = dd - np.mean(dd)
+        dgeom_cam['cents_x'] = cent[0] + dd * dgeom_pin['e0'][0]
+        dgeom_cam['cents_y'] = cent[1] + dd * dgeom_pin['e0'][1]
+        dgeom_cam['cents_z'] = cent[2] + dd * dgeom_pin['e0'][2]
+        del dgeom_cam['cent']
+
+    else:
+        for ii in [0, 1]:
+            dd = (pix_size[ii] + pix_spacing[ii]) * np.arange(0, pix_nb[ii])
+            dgeom_cam[f'cents_x{ii}'] = dd - np.mean(dd)
+
+        dgeom_cam['cent'] = cent
+
+    # -------------
+    # pixel outline
+
+    dgeom_cam['outline_x0'] = 0.5 * pix_size[0] * np.r_[-1, 1, 1, -1]
+    dgeom_cam['outline_x1'] = 0.5 * pix_size[1] * np.r_[-1, -1, 1, 1]
+
+    return dgeom_cam, cam_type
+
+
+def _add_camera_pinhole_store(
+    coll=None,
+    key=None,
+    key_pinhole=None,
+    key_diag=None,
+    cam_type=None,
+    dgeom_pin=None,
+    dgeom_cam=None,
+    newdiag=None,
+    # reflections
+    reflections_nb=None,
+    reflections_type=None,
+    compute=None,
+    config=None,
+    length=None,
+    # dmat
+    dmat=None,
+):
 
-    Rbs_apex = _utils_bsplines._get_apex_per_bs(
-        knots=Rknots,
-        knots_per_bs=knots_per_bs_R,
-        deg=deg
+    # compute
+    compute = ds._generic_check._check_var(
+        compute, 'compute',
+        types=bool,
+        default=True,
     )
-    Zbs_apex = _utils_bsplines._get_apex_per_bs(
-        knots=Zknots,
-        knots_per_bs=knots_per_bs_Z,
-        deg=deg
+
+    # pinhole aperture
+    coll.add_aperture(
+        key=key_pinhole,
+        **dgeom_pin,
     )
-    return shapebs, Rbs_apex, Zbs_apex, knots_per_bs_R, knots_per_bs_Z
 
+    # camera
+    if cam_type == '1d':
+        coll.add_camera_1d(
+            key=key,
+            dgeom=dgeom_cam,
+            dmat=dmat,
+        )
+    else:
+        coll.add_camera_2d(
+            key=key,
+            dgeom=dgeom_cam,
+            dmat=dmat,
+        )
 
-def get_bs2d_func(
-    deg=None,
-    Rknots=None,
-    Zknots=None,
-    shapebs=None,
-    # knots_per_bs_R=None,
-    # knots_per_bs_Z=None,
-):
+    # doptics
+    doptics = {key: [key_pinhole]}
 
-    # ----------------
-    # Define functions
+    # diagnostic
+    if newdiag is False:
 
-    clas = BivariateSplineRect(
-        knotsR=Rknots,
-        knotsZ=Zknots,
-        deg=deg,
-        shapebs=shapebs,
+        # delete and recreate diagnostic
+        dop = {
+            k0: v0['optics']
+            for k0, v0 in coll._dobj['diagnostic'][key_diag]['doptics'].items()
+        }
+        dop.update(doptics)
+        doptics = dop
+        coll.remove_diagnostic(key=key_diag)
+
+    # create
+    coll.add_diagnostic(
+        key=key_diag,
+        doptics=doptics,
+        reflections_nb=reflections_nb,
+        reflections_type=reflections_type,
+        compute=compute,
+        config=config,
+        length=length,
     )
-
-    return clas.ev_details, clas.__call__, clas
```

### Comparing `tofu-1.6.5/tofu/data/_class1_checks.py` & `tofu-1.7.0/tofu/geom/_comp_solidangles.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,1646 +1,1569 @@
-# -*- coding: utf-8 -*-
-
-
 # Built-in
-import warnings
-
+# import warnings
 
 # Common
 import numpy as np
-from matplotlib.tri import Triangulation as mplTri
+# import scipy.interpolate as scpinterp
+# import scipy.integrate as scpintg
+# from inspect import signature as insp
+import matplotlib.pyplot as plt
 import datastock as ds
 
 
-_ELEMENTS = 'knots'
+import datetime as dtm
 
 
-# #############################################################################
-# #############################################################################
-#               DEPRECATED ?
-# #############################################################################
-
-
-# def _get_RZ(arr, name=None, shapeRZ=None):
-    # if arr.ndim == 1:
-        # if np.any(np.diff(arr) <= 0.):
-            # msg = "Non-increasing {}".format(name)
-            # raise Exception(msg)
-    # else:
-        # lc = [np.all(np.diff(arr[0, :])) > 0.,
-              # np.all(np.diff(arr[:, 0])) > 0.]
-        # if np.sum(lc) != 1:
-            # msg = "Impossible to know {} dimension!".format(name)
-            # raise Exception(msg)
-        # if lc[0]:
-            # arr = arr[0, :]
-            # if shapeRZ[1] is None:
-                # shapeRZ[1] = name
-            # if shapeRZ[1] != name:
-                # msg = "Inconsistent shapeRZ"
-                # raise Exception(msg)
-        # else:
-            # arr = arr[:, 0]
-            # if shapeRZ[0] is None:
-                # shapeRZ[0] = name
-            # if shapeRZ[0] != name:
-                # msg = "Inconsistent shapeRZ"
-                # raise Exception(msg)
-    # return arr, shapeRZ
-
-
-# def _duplicates(arr, arru, nn, name=None, msg=None):
-    # msg += (
-        # "  Duplicate {}: {}\n".format(name, nn - arru.shape[0])
-        # + "\t- {}.shape: {}\n".format(name, arr.shape)
-        # + "\t- unique shape: {}".format(arru.shape)
-    # )
-    # return msg
-
-
-# def _check_trimesh_conformity(nodes, faces, key=None):
-    # nnodes = nodes.shape[0]
-    # nfaces = faces.shape[0]
-
-    # # Test for duplicates
-    # nodesu = np.unique(nodes, axis=0)
-    # facesu = np.unique(faces, axis=0)
-    # lc = [nodesu.shape[0] != nnodes,
-          # facesu.shape[0] != nfaces]
-    # if any(lc):
-        # msg = "Non-valid mesh ddata[{0}]: \n".format(key)
-        # if lc[0]:
-            # msg = _duplicates(nodes, nodesu, nnodes, name='nodes', msg=msg)
-        # if lc[1]:
-            # msg = _duplicates(faces, facesu, nfaces, name='faces', msg=msg)
-        # raise Exception(msg)
-
-    # # Test for unused nodes
-    # facesu = np.unique(facesu)
-    # c0 = np.all(facesu >= 0) and facesu.size == nnodes
-    # if not c0:
-        # ino = str([ii for ii in range(0, nnodes) if ii not in facesu])
-        # msg = "Unused nodes in ddata[{0}]:\n".format(key)
-        # msg += "    - unused nodes indices: {}".format(ino)
-        # warnings.warn(msg)
-
-    # # Check counter-clockwise orientation
-    # x, y = nodes[faces, 0], nodes[faces, 1]
-    # orient = ((y[:, 1] - y[:, 0])*(x[:, 2] - x[:, 1])
-              # - (y[:, 2] - y[:, 1])*(x[:, 1] - x[:, 0]))
-
-    # clock = orient > 0.
-    # if np.any(clock):
-        # msg = ("Some triangles not counter-clockwise\n"
-               # + "  (necessary for matplotlib.tri.Triangulation)\n"
-               # + "    => {}/{} triangles reshaped".format(clock.sum(), nfaces))
-        # warnings.warn(msg)
-        # faces[clock, 1], faces[clock, 2] = faces[clock, 2], faces[clock, 1]
-    # return faces
-
-# DEPRECATED ?
-# def _check_mesh_temp(data=None, key=None):
-    # # Check if provided data is mesh (as a dict)
-
-    # # ------------
-    # # Check basics
-    # lmok = ['rect', 'tri', 'quadtri']
-    # c0 = (
-        # isinstance(data, dict)
-        # and all([ss in data.keys() for ss in ['type']])
-        # and data['type'] in lmok
-        # and (
-            # (
-                # data['type'] == 'rect'
-                # and all([ss in data.keys() for ss in ['R', 'Z']])
-                # and isinstance(data['R'], np.ndarray)
-                # and isinstance(data['Z'], np.ndarray)
-                # and data['R'].ndim in [1, 2]
-                # and data['Z'].ndim in [1, 2]
-            # )
-            # or (
-                # data['type'] in ['tri', 'quadtri', 'quad']
-                # and all([ss in data.keys() for ss in ['nodes', 'faces']])
-                # and isinstance(data['nodes'], np.ndarray)
-                # and isinstance(data['faces'], np.ndarray)
-                # and data['nodes'].ndim == 2
-                # and data['faces'].ndim == 2
-                # and data['faces'].dtype == np.int
-                # and data['nodes'].shape[1] == 2
-                # and (
-                    # (
-                        # data['type'] in ['tri', 'quadtri']
-                        # and data['faces'].shape[1] == 3
-                    # )
-                    # or (
-                        # data['type'] == 'quad'
-                        # and data['faces'].shape[1] == 4
-                    # )
-                # )
-                # and np.max(data['faces']) <= data['nodes'].shape[0]
-            # )
-        # )
-    # )
-    # if not c0:
-        # msg = (
-            # """
-            # A mesh should be a dict of one of the following form:
-
-                # dict(
-                 # 'type': 'rect',
-                 # 'R': np.ndarray (with ndim in [1, 2]),
-                 # 'Z': np.ndarray (with ndim in [1, 2]),
-                 # 'shapeRZ': ('R', 'Z') or ('Z', 'R')
-                # )
-
-                 # dict(
-                 # 'type': 'tri' or 'quadtri',
-                 # 'nodes': np.ndarray of shape (N, 2),
-                 # 'faces': np.ndarray of int of shape (N, 3)
-                # )
-
-                # dict(
-                 # 'type': 'quad',
-                 # 'nodes': np.ndarray of shape (N, 2),
-                 # 'faces': np.ndarray of int of shape (N, 4)
-                # )
-
-            # Provided:
-            # {}
-            # """.format(data)
-        # )
-        # raise Exception(msg)
-
-    # # ------------
-    # # Check per type
-    # if data['type'] == 'rect':
-
-        # shapeRZ = data.get('shapeRZ', [None, None])
-        # if shapeRZ is None:
-            # shapeRZ = [None, None]
-        # else:
-            # shapeRZ = list(shapeRZ)
-
-        # R, shapeRZ = _get_RZ(data['R'], name='R', shapeRZ=shapeRZ)
-        # Z, shapeRZ = _get_RZ(data['Z'], name='Z', shapeRZ=shapeRZ)
-        # shapeRZ = tuple(shapeRZ)
-
-        # if shapeRZ not in [('R', 'Z'), ('Z', 'R')]:
-            # msg = "Inconsistent shapeRZ"
-            # raise Exception(msg)
-
-        # def trifind(
-            # r, z,
-            # Rbin=0.5*(R[1:] + R[:-1]),
-            # Zbin=0.5*(Z[1:] + Z[:-1]),
-            # nR=R.size, nZ=Z.size,
-            # shapeRZ=shapeRZ
-        # ):
-            # indR = np.searchsorted(Rbin, r)
-            # indZ = np.searchsorted(Zbin, z)
-            # indR[(r < R[0]) | (r > R[-1])] = -1
-            # indZ[(z < Z[0]) | (z > Z[-1])] = -1
-            # return indR, indZ
-            # # if shapeRZ == ('R', 'Z'):
-            # #     indpts = indR*nZ + indZ
-            # # else:
-            # #     indpts = indZ*nR + indR
-            # # indout = ((r < R[0]) | (r > R[-1])
-            # #           | (z < Z[0]) | (z > Z[-1]))
-            # # indpts[indout] = -1
-            # # return indpts
-
-        # data['R'] = R
-        # data['Z'] = Z
-        # data['shapeRZ'] = shapeRZ
-        # data['nR'] = R.size
-        # data['nZ'] = Z.size
-        # data['shape'] = (R.size, Z.size)
-        # data['trifind'] = trifind
-        # data['ftype'] = data.get('ftype', 0)
-
-        # if data['ftype'] != 0:
-            # msg = "Linear interpolation not handled yet !"
-            # raise Exception(msg)
-
-    # else:
-        # # Check mesh conformity for triangulation
-        # data['faces'] = _check_trimesh_conformity(
-            # nodes=data['nodes'], faces=data['faces'], key=key
-        # )
-
-        # data['nnodes'] = data['nodes'].shape[0]
-        # data['nfaces'] = data['faces'].shape[0]
-        # data['ftype'] = data.get('ftype', 0)
-
-        # # Convert 'quad' to 'quadtri' if relevant
-        # if data['type'] == 'quad':
-            # # Convert to tri mesh (solution for unstructured meshes)
-            # faces = np.empty((data['nfaces']*2, 3), dtype=int)
-            # faces[::2, :] = data['faces'][:, :3]
-            # faces[1::2, :-1] = data['faces'][:, 2:]
-            # faces[1::2, -1] = data['faces'][:, 0]
-            # data['faces'] = faces
-            # data['type'] = 'quadtri'
-            # data['ntri'] = 2
-
-            # # Re-check mesh conformity
-            # data['faces'] = _check_trimesh_conformity(
-                # nodes=data['nodes'], faces=data['faces'], key=key
-            # )
-
-        # # Check ntri
-        # if data['type'] == 'tri':
-            # data['ntri'] = 1
-        # elif 'ntri' not in data.keys():
-            # msg = (
-                # """
-                # For ddata[{}] of type 'quadtri', 'ntri' must be provided
-                # """.format(key)
-            # )
-            # raise Exception(msg)
-
-        # # Only triangular meshes so far
-        # if 'tri' in data['type']:
-            # if data.get('mpltri', None) is None:
-                # data['mpltri'] = mplTri(
-                    # data['nodes'][:, 0],
-                    # data['nodes'][:, 1],
-                    # data['faces']
-                # )
-            # if not isinstance(data['mpltri'], mplTri):
-                # msg = (
-                    # """
-                    # ddata[{}]['mpltri'] must be a matplotlib Triangulation
-                    # Provided:
-                    # {}
-                    # """.format(key, data['mpltri'])
-                # )
-            # assert data['ftype'] in [0, 1]
-            # if data['ftype'] == 1:
-                # data['shape'] = (data['nnodes'],)
-            # else:
-                # data['shape'] = (int(data['nfaces'] / data['ntri']),)
-
-    # return data, data['shape']
-
-
-# ALL USEFUL FROM HERE
-
-# #############################################################################
-# #############################################################################
-#                          add data on mesh / bsplines
-# #############################################################################
-
-
-def add_data_meshbsplines_ref(
-    ref=None,
-    data=None,
-    # ressources
-    dmesh=None,
-    dbsplines=None,
-):
+# local
+from . import _GG
 
-    if dmesh is None or dbsplines is None:
-        return ref, data
 
-    # ref is str
-    if isinstance(ref, str):
-        ref = [ref]
-
-    # ref is tuple
-    if isinstance(ref, (tuple, list)):
-
-        # ref contains mesh
-        rm = [(ii, rr) for ii, rr in enumerate(ref) if rr in dmesh.keys()]
-        if len(rm) > 1:
-            msg = (
-                "ref contains references to several meshes!\n"
-                f"\t- ref: {ref}\n"
-                f"\t- meshes: {rm}\n"
-            )
-            raise Exception(msg)
+_APPROX = True
+_ANISO = False
+_BLOCK = True
+_LTYPES = [int, float, np.int_, np.float_]
 
-        elif len(rm) == 1:
-            ref = list(ref)
-            kbs = [
-                k0 for k0, v0 in dbsplines.items()
-                if v0['mesh'] == rm[0][1]
-            ]
-            if len(kbs) == 1:
-                ref[rm[0][0]] = kbs[0]
-            elif len(kbs) > 1:
-                msg = (
-                    "ref contains reference to mesh with several bsplines!\n"
-                    f"\t- ref: {ref}\n"
-                    f"\t- mesh bsplines: {kbs}\n"
-                )
-                raise Exception(msg)
-
-        # ref contains bsplines
-        rbs = [(ii, rr) for ii, rr in enumerate(ref) if rr in dbsplines.keys()]
-        if len(rbs) > 1:
-            msg = (
-                "ref contains references to several bsplines!"
-                f"\t- ref: {ref}\n"
-                f"\t- splines: {rbs}\n"
-            )
-            raise Exception(msg)
 
-        elif len(rbs) == 1:
-            ref = np.r_[
-                ref[:rbs[0][0]],
-                dbsplines[rbs[0][1]]['ref'],
-                ref[rbs[0][0]+1:],
-            ]
-
-            # repeat data if taken from ntri > 1 
-            data = _repeat_data_ntri(
-                ref=ref,
-                rbs1=rbs[0][1],
-                refbs=dbsplines[rbs[0][1]]['ref'],
-                data=data,
-                # mesh
-                km=dbsplines[rbs[0][1]]['mesh'],
-                dmesh=dmesh,
-                dbsplines=dbsplines,
-            )
+__all__ = [
+    'calc_solidangle_particle',
+    'calc_solidangle_apertures',
+]
 
-    return tuple(ref), data
 
+###############################################################################
+###############################################################################
+#                       Check inputs - Particle
+###############################################################################
 
-def _repeat_data_ntri(
-    ref=None,
-    rbs1=None,
-    refbs=None,
-    data=None,
-    # mesh
-    km=None,
-    dmesh=None,
-    dbsplines=None,
+
+def _check_calc_solidangle_particle(
+    traj=None,
+    pts=None,
+    rad=None,
+    config=None,
+    approx=None,
+    aniso=None,
+    block=None,
 ):
-    """ If triangular mesh with ntri > 1 => repeat data """
 
-    c0 = (
-        dmesh[km]['type'] == 'tri'
-        and dmesh[km]['ntri'] > 1
-    )
-    if c0:
-        ntri = dmesh[km]['ntri']
-        indr = ref.tolist().index(refbs[0])
-        nbs = dbsplines[rbs1]['shape'][0]
-        ndata = data.shape[indr]
-        if ndata == nbs:
-            pass
-        elif ndata == nbs / ntri:
-            data = np.repeat(data, ntri, axis=indr)
-        else:
-            msg = (
-                "Mismatching data shape vs multi-triangular mesh:\n"
-                f"\t- data.shape[tribs] = {ndata}\n"
-                f"\t- expected {nbs} / {ntri} = {nbs / ntri}\n"
-            )
+    # Check booleans
+    if approx is None:
+        approx = _APPROX
+    if aniso is None:
+        aniso = _ANISO
+
+    lbool = [('approx', approx), ('aniso', aniso)]
+    for kk, vv in lbool:
+        if not isinstance(vv, bool):
+            msg = ("Arg {} must be a bool\n".format(kk)
+                   + "\t- provided: {}".format(vv))
             raise Exception(msg)
 
-    return data
-
+    # Check config
+    c0 = [config is None, config.__class__.__name__ == "Config"]
+    if not any(c0):
+        msg = ("Arg config must be either Noen or a tf.geom.Config instance!\n"
+               + "\t- provided: {}".format(config))
+        raise Exception(msg)
 
-# #############################################################################
-# #############################################################################
-#                           mesh generic check
-# #############################################################################
-
-
-def _mesh2D_check(
-    coll=None,
-    domain=None,
-    res=None,
-    R=None,
-    Z=None,
-    knots=None,
-    cents=None,
-    trifind=None,
-    key=None,
-):
+    # Double-check block vs config
+    if block is None:
+        if config is None:
+            block = False
+        else:
+            block = _BLOCK
+    if not isinstance(block, bool):
+        msg = ("Arg {} must be a bool\n".format('block')
+               + "\t- provided: {}".format(block))
+        raise Exception(msg)
+    if config is None and block is True:
+        msg = ("Arg block cannot be True of config is not provided!")
+        raise Exception(msg)
 
-    # key
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        excluded=list(coll.dobj.get('mesh', {}).keys())
-    )
+    # arrays
+    try:
+        traj = np.ascontiguousarray(traj, dtype=float)
+        rad = np.r_[rad].astype(float).ravel()
 
-    # rect of tri ?
-    lc = [
-        domain is not None or (R is not None and Z is not None),
-        knots is not None and cents is not None,
-    ]
-    if all(lc) or not any(lc):
+        # Check pts, traj and r are array of good shape
+        c0 = traj.ndim in [1, 2] and 3 in traj.shape
+        if pts is not False:
+            pts = np.ascontiguousarray(pts, dtype=float)
+            c0 = c0 and pts.ndim in [1, 2] and 3 in pts.shape
+        assert c0
+        if traj.ndim == 1:
+            traj = traj.reshape((3, 1))
+        if traj.shape[0] != 3:
+            traj = traj.T
+        traj = np.ascontiguousarray(traj)
+        if pts is not False:
+            if pts.ndim == 1:
+                pts = pts.reshape((3, 1))
+            if pts.shape[0] != 3:
+                pts = pts.T
+            pts = np.ascontiguousarray(pts)
+    except Exception:
         msg = (
-            "Either domain xor (R, Z) xor (knots, cents) must be provided!\n"
-            "Provided:\n"
-            f"\t- domain, res: {domain}, {res}\n"
-            f"\t- type(R), type(Z): {type(R)}, {type(Z)}\n"
-            f"\t- type(knots), type(cents): {type(knots)}, {type(cents)}\n"
+            "Args traj and pts must be convertible to np.ndarrays of shape"
+            + "\n\t- traj: (N,), (3, N) or (N, 3)"
+            + "\n\t- pts: (M,), (3, M) or (M, 3)"
+            + "\n\n   You provided:\n"
+            + "\n\t- traj: {}".format(traj)
+            + "\n\t- pts: {}".format(pts)
+            + "\n\t- rad: {}".format(rad)
         )
         raise Exception(msg)
 
-    elif lc[0]:
-        dref, ddata, dmesh = _mesh2DRect_to_dict(
-            domain=domain,
-            res=res,
-            R=R,
-            Z=Z,
-            key=key,
-        )
-
-    elif lc[1]:
-        dref, ddata, dmesh = _mesh2DTri_to_dict(
-            knots=knots,
-            cents=cents,
-            trifind=trifind,
-            key=key,
-        )
-
-    return dref, ddata, dmesh
-
-
-def _mesh2D_polar_check(
-    coll=None,
-    radius=None,
-    angle=None,
-    radius2d=None,
-    angle2d=None,
-    key=None,
-    # parameters
-    radius_dim=None,
-    radius_quant=None,
-    radius_name=None,
-    radius_units=None,
-    angle_dim=None,
-    angle_quant=None,
-    angle_name=None,
+    # check rad vs traj
+    ntraj = traj.shape[1]
+    nrad = rad.size
+
+    nmax = max(nrad, ntraj)
+    if not (nrad in [1, nmax] and ntraj in [1, nmax]):
+        msg = ("rad must be an array with shape (1,) or (N,)\n"
+               + "  provided: {}".format(rad))
+        raise Exception(msg)
+    if nrad < nmax:
+        rad = np.full((nmax,), rad[0])
+    if ntraj < nmax:
+        traj = np.repeat(traj, nmax, axis=1)
+    return traj, pts, rad, config, approx, aniso, block
+
+
+###############################################################################
+###############################################################################
+#                       Solid Angle particle
+###############################################################################
+
+
+def calc_solidangle_particle(
+    pts=None,
+    part_traj=None,
+    part_radius=None,
+    config=None,
+    approx=None,
+    aniso=None,
+    block=None,
 ):
+    """ Compute the solid angle subtended by a particle along a trajectory
+
+    The particle has radius r, and trajectory (array of points) traj
+    It is observed from pts (array of points)
+
+    traj and pts are (3, N) and (3, M) arrays of cartesian coordinates
 
-    # key
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        excluded=list(coll.dobj.get('mesh', {}).keys())
+    approx = True => use approximation
+    aniso = True => return also unit vector of emission
+    block = True consider LOS collisions (with Ves, Struct...)
+
+    if block:
+        config used for LOS collisions
+
+    Parameters
+    ----------
+    pts:            np.ndarray
+        Array of (3, M) pts coordinates (X, Y, Z) representing the points from
+        which the particle is observed
+    part_traj:      np.ndarray
+        Array of (3, N) pts coordinates (X, Y, Z) representing the particle
+        positions
+    part_radius:    float / np.ndarray
+        Unique of multiple values for the radius of the spherical particle
+            if multiple, rad is a np.ndarray of shape (N,)
+    config:         None / tf.geom.Config
+        if block = True, solid angles are non-zero only if the field of view is
+        not blocked bya structural element in teh chamber
+    approx:         None / bool
+        Flag indicating whether to compute the solid angle using an 1st-order
+        series development (in whichcase the solid angle becomes proportional
+        to the radius of the particle, see Notes_Upgrades/)
+    aniso:          None / bool
+        Flag indicating whether to consider anisotropic emissivity, meaning the
+        routine must also compute and return the unit vector directing the flux
+        from each pts to each position on the trajectory of the particle
+    block:          None / bool
+        Flag indicating whether to check for vignetting by structural elements
+        provided by config
+
+    Return:
+    -------
+    sang:           np.ndarray
+        (N, M) Array of floats, solid angles
+
+    """
+    ################
+    # Prepare inputs
+    (
+        part_traj, pts, part_radius, config,
+        approx, aniso, block
+    ) = _check_calc_solidangle_particle(
+        traj=part_traj,
+        pts=pts,
+        rad=part_radius,
+        config=config,
+        approx=approx,
+        aniso=aniso,
+        block=block,
     )
 
-    # --------------------
-    # check / format input
+    ################
+    # Main computation
+
+    # traj2pts vector, with length (3d array (3, N, M))
+    vect = - pts[:, :, None] + part_traj[:, None, :]
+    len_v = np.ascontiguousarray(np.sqrt(np.sum(vect**2, axis=0)))
+
+    # If aniso or block, normalize
+    if aniso or block:
+        vect = vect / len_v[None, :, :]
+
+    # Solid angle
+    r_d = part_radius[None, :] / len_v
+    where_zero = len_v <= part_radius[None, :]
+    r_d[where_zero] = 0.  # temporary value
+    if approx:
+        sang = np.pi * (r_d**2 + r_d**4 / 4. + r_d**6 / 8. + r_d**8 * 5 / 64)
+    else:
+        sang = 2.*np.pi * (1 - np.sqrt(1. - r_d ** 2))
+
+    # when particle in mesh point, distance len_v = 0 thus sang neglected
+    sang[where_zero] = 0.
+
+    # block
+    if block:
+        kwdargs = config.get_kwdargs_LOS_isVis()
+        indvis = _GG.LOS_areVis_PtsFromPts_VesStruct(
+            pts, part_traj, dist=len_v, **kwdargs
+        )
+        iout = indvis == 0
+        sang[iout] = 0.
+        vect[:, iout] = np.nan
+
+    ################
+    # Return
+    if aniso:
+        return sang, vect
+
+    return sang
+
+
+def calc_solidangle_particle_integ(
+    part_traj=None,
+    part_radius=None,
+    config=None,
+    approx=True,
+    block=True,
+    resolution=None,
+    DR=None,
+    DZ=None,
+    DPhi=None,
+):
+
+    # step0: if block : generate kwdargs from config
+
+    # step 1: sample cross-section
+
+    # step 2: loop on R of  pts of cross-section (parallelize ?)
+    # => fix nb. of phi for the rest of the loop
+
+    # loop of Z
+
+    # step 3: loop phi
+    # Check visibility (if block = True) for each phi (LOS collision)
+    # If visible => compute solid angle
+    # integrate (sum * res) on each phi the solid angle
 
-    krk, krc = f'{key}-r-nk', f'{key}-r-nc'
-    kkr, kcr = f'{key}-r-k', f'{key}-r-c'
+    # Return sang as (N,nR,nZ) array
 
-    kak, kac = f'{key}-ang-nk', f'{key}-ang-nc'
-    kka, kca = f'{key}-ang-k', f'{key}-ang-c'
+    # ----------------
+    # check resolution
 
-    # radius data
+    if resolution is None:
+        resolution = 0.1
+    if type(resolution) in _LTYPES:
+        resolution = [resolution, resolution, resolution]
     c0 = (
-        hasattr(radius, '__iter__')
-        and np.asarray(radius).ndim == 1
-        and np.unique(radius).size == np.array(radius).size
-        and np.allclose(np.unique(radius), radius)
+        isinstance(resolution, list)
+        and all([type(ss) in _LTYPES for ss in resolution])
     )
     if not c0:
         msg = (
-            "Arg radius must be convertible to a 1d increasing array\n"
-            f"\t- Provided: {radius}"
+            "Arg resolution must be a list of 3 floats [r, z, rphi]\n"
+            "Each representing the spatial sampling step in a direction\n"
+            "If a single float is provided, the same is used for all"
         )
         raise Exception(msg)
+    resolution = [float(rr) for rr in resolution]
 
-    # angle data
-    c0 = (
-        angle is None
-        or (
-            hasattr(angle, '__iter__')
-            and np.asarray(angle).ndim == 1
-            and np.unique(angle).size == np.array(angle).size
-            and np.allclose(
-                np.unique(np.arctan2(np.sin(angle), np.cos(angle))),
-                angle,
+    # ------------------
+    # Check DR, DZ, DPhi
+    dD = {'DR': DR, 'DZ': DZ, 'DPhi': DPhi}
+    dfail = {}
+    for k0, v0 in dD.items():
+        c0 = (
+            v0 is None
+            or (
+                isinstance(v0, list)
+                and len(v0) == 2
+                and all([v1 is None or type(v1) in _LTYPES for v1 in v0])
             )
         )
-    )
-    if not c0:
+        if not c0:
+            dfail[k0] = str(v0)
+    if len(dfail) > 0:
+        lstr = [f'\t- {k0}: {v0}' for k0, v0 in dfail.items()]
         msg = (
-            "Arg angle either\n:"
-            "\t- None: radial-only polar mesh"
-            "\t- convertible to a 1d increasing array\n"
-            "\t\t it must be in radians\n"
-            "\t\t it must be in the [-pi; pi] interval\n"
-            f"\t- Provided: {angle}"
+            "The following arguments are invalid:\n"
+            "Expected None or a list of len(2) of None or floats!\n"
+            + "\n".join(lstr)
         )
         raise Exception(msg)
 
-    # extract data
-    rknot = np.unique(radius)
-    rcent = 0.5*(rknot[1:] + rknot[:-1])
-
-    # radius2d
-    dradius = _check_polar_2dquant(
-        coll=coll,
-        quant2d=radius2d,
-        quant2d_name='radius2d',
-        dim=radius_dim,
-        quant=radius_quant,
-        name=radius_name,
-        units=radius_units,
-    )
+    # ------------------
+    # check other inputs
 
-    if callable(radius2d):
-        keysm = None
-    else:
-        keysm = coll.dobj['bsplines'][coll.ddata[radius2d]['bsplines']]['mesh']
-
-    if angle is not None:
-        aknot = np.unique(np.arctan2(np.sin(angle), np.cos(angle)))
-        acent = 0.5*(aknot[1:] + aknot[:-1])
-        amid = 0.5*(aknot[-1] + (2.*np.pi + aknot[0]))
-        amid = np.arctan2(np.sin(amid), np.cos(amid))
-        if amid < acent[0]:
-            acent = np.r_[amid, acent]
-        else:
-            acent = np.r_[acent, amid]
+    (
+        part_traj, _, part_radius, config,
+        approx, _, block
+    ) = _check_calc_solidangle_particle(
+        traj=part_traj,
+        pts=False,
+        rad=part_radius,
+        config=config,
+        approx=approx,
+        aniso=False,
+        block=block,
+    )
 
-    # -------
-    # angle2d
+    # ------------------
+    # Define the volume to be sampled: smallest vessel
 
-    if angle2d is not None:
-        dangle = _check_polar_2dquant(
-            coll=coll,
-            quant2d=angle2d,
-            quant2d_name='angle2d',
-            dim=angle_dim,
-            quant=angle_quant,
-            name=angle_name,
-            units='rad',
-        )
-
-        # check angle units = rad
-        if dangle['units'] != 'rad':
-            msg = (
-                "Angle units must be rad\n"
-                f"\t Provided: {dangle['units']}"
-            )
-            raise Exception(msg)
+    # Get kwdargs for LOS blocking
+    kwdargs = config.get_kwdargs_LOS_isVis()
 
-        # check angle2d is like radius2d
-        c0 = (
-            (callable(radius2d) and callable(angle2d))
-            or coll._ddata[radius2d]['ref'] == coll._ddata[angle2d]['ref']
-        )
-        if not c0:
-            msg = (
-                "radius2d and angle2d must be of the same type, either:\n"
-                "\t- both callable\n"
-                "\t- both data keys with identical ref!\n"
-                f"Provided:\n"
-                f"\t- radius2d: {radius2d}\n"
-                f"\t- angle2d: {angle2d}\n"
-            )
-            raise Exception(msg)
-
-    # --------------------
-    # prepare dict
-
-    # dref
-    dref = {
-        krk: {'size': rknot.size},
-        krc: {'size': rcent.size},
-    }
+    # derive limits for sampling
+    limits_r = np.r_[
+        np.min(kwdargs['ves_poly'][0, :]),
+        np.max(kwdargs['ves_poly'][0, :]),
+    ]
+    limits_z = np.r_[
+        np.min(kwdargs['ves_poly'][1, :]),
+        np.max(kwdargs['ves_poly'][1, :]),
+    ]
 
-    if angle is not None:
-        dref.update({
-            kak: {
-                'size': aknot.size,
-            },
-            kac: {
-                'size': acent.size,
-            },
-        })
-
-    # ddata
-    ddata = {
-        kkr: {
-            'data': rknot,
-            'ref': krk,
-            **dradius,
-        },
-        kcr: {
-            'data': rcent,
-            'ref': krc,
-            **dradius,
-        },
-    }
+    return _GG.compute_solid_angle_map(
+        part_traj, part_radius,
+        resolution[0], resolution[1], resolution[2],
+        limits_r, limits_z,
+        DR=DR, DZ=DZ,
+        DPhi=DPhi,
+        block=block,
+        approx=approx,
+        limit_vpoly=kwdargs['ves_poly'],
+        **kwdargs,
+    )
 
-    if angle is not None:
-        ddata.update({
-            kka: {
-                'data': aknot,
-                'ref': kak,
-                **dangle,
-            },
-            kca: {
-                'data': acent,
-                'ref': kac,
-                **dangle,
-            },
-        })
-
-    # dobj
-    if angle is None:
-        dmesh = {
-            key: {
-                'type': 'polar',
-                'knots': (kkr,),
-                'cents': (kcr,),
-                'shape-c': rcent.shape,
-                'shape-k': rknot.shape,
-                'radius2d': radius2d,
-                'angle2d': angle2d,
-                'submesh': keysm,
-                'crop': False,
-            },
-        }
-    else:
-        dmesh = {
-            key: {
-                'type': 'polar',
-                'knots': (kkr, kka),
-                'cents': (kcr, kca),
-                'shape-c': (rcent.size, acent.size),
-                'shape-k': (rknot.size, aknot.size),
-                'radius2d': radius2d,
-                'angle2d': angle2d,
-                'submesh': keysm,
-                'crop': False,
-            },
-        }
 
-    return dref, ddata, dmesh
+###############################################################################
+###############################################################################
+#           Triangulation
+###############################################################################
 
 
-def _check_polar_2dquant(
-    quant2d=None,
-    coll=None,
-    quant2d_name=None,
-    # parameters
-    dim=None,
-    quant=None,
-    name=None,
-    units=None,
+def triangulate_polygon_2d(
+    poly_x=None,
+    poly_y=None,
 ):
 
-    if coll.dobj.get('bsplines') is not None:
-        lok = [
-            k0 for k0, v0 in coll.ddata.items()
-            if v0['bsplines'] in coll.dobj['bsplines'].keys()
-        ]
-    else:
-        lok = []
+    # ----------
+    # check
 
-    lc = [
-        callable(quant2d),
-        isinstance(quant2d, str) and quant2d in lok
-    ]
-    if not any(lc):
-        msg = (
-            f"Arg {quant2d_name} must be either:\n"
-            f"\t- callable: {quant2d_name} = func(R, Z)\n"
-            f"\t- key to existing 2d data in {lok}\n"
-            f"Provided: {quant2d}\n"
-        )
+    if not (isinstance(poly_x, np.ndarray) and isinstance(poly_x, np.ndarray)):
+        msg = "both poly_x and poly_y must be nd.ndarray"
         raise Exception(msg)
 
-    # quantities
-    dquant = {'dim': dim, 'quant': quant, 'name': name, 'units': units}
-    if isinstance(quant2d, str):
-        for k0 in dquant.keys():
-            if dquant[k0] is None:
-                dquant[k0] = str(coll.ddata[quant2d][k0])
-
-    return dquant
+    if not (poly_x.shape == poly_y.shape and poly_x.ndim == 1):
+        msg = "poly_x and poly_y must be 1d arrays of the same shape"
+        raise Exception(msg)
 
+    poly_x = poly_x.astype(float)
+    poly_y = poly_y.astype(float)
 
-# #############################################################################
-# #############################################################################
-#                           Mesh2DTri
-# #############################################################################
+    # ----------
+    # un-close
 
+    if poly_x[-1] == poly_x[0] and poly_y[-1] == poly_y[0]:
+        poly_x = poly_x[:-1]
+        poly_y = poly_y[:-1]
 
-def _mesh2DTri_conformity(knots=None, cents=None, key=None):
+    # ------------------
+    # couter-clockwise
 
-    # ---------------------------------
-    # make sure np.ndarrays of dim = 2
+    clock = np.sum((poly_x[1:] - poly_x[:-1]) * (poly_y[:1] + poly_y[:-1]))
+    if clock > 0:
+        poly_x = poly_x[::-1]
+        poly_y = poly_y[::-1]
 
-    knots = np.atleast_2d(knots).astype(float)
-    cents = np.atleast_2d(cents).astype(int)
+    # ----------------
+    # triangulate
 
-    # --------------
-    # check shapes
+    tri = _GG.triangulate_by_earclipping_2d(np.array([poly_x, poly_y]))
 
-    c0 = (
-        knots.shape[1] == 2
-        and knots.shape[0] >= 3
-        and cents.shape[1] in [3, 4]
-        and cents.shape[0] >= 1
-        and cents.dtype == int
-    )
-    if not c0:
-        msg = (
-            "Arg knots must be of shape (nknots>=3, 2) and "
-            "arg cents must be of shape (ncents>=1, 3 or 4) and dtype = int\n"
-            "Provided:\n"
-            f"\t- knots.shape: {knots.shape}\n"
-            f"\t- cents.shape: {cents.shape}\n"
-            f"\t- cents.dtype: {cents.dtype}\n"
-        )
-        raise Exception(msg)
+    # -------
+    # format
 
-    nknots = knots.shape[0]
-    ncents = cents.shape[0]
+    if clock > 0:
+        tri = poly_x.size - 1 - tri
 
-    # -------------------
-    # Test for duplicates
+    return tri
 
-    # knots (floats => distance)
-    dist = np.full((nknots, nknots), np.nan)
-    ind = np.zeros(dist.shape, dtype=bool)
-    for ii in range(nknots):
-        dist[ii, ii+1:] = np.sqrt(
-            (knots[ii+1:, 0] - knots[ii, 0])**2
-            + (knots[ii+1:, 1] - knots[ii, 1])**2
-        )
-        ind[ii, ii+1:] = True
-
-    ind[ind] = dist[ind] < 1.e-6
-    if np.any(ind):
-        iind = np.any(ind, axis=1).nonzero()[0]
-        lstr = [f'\t\t- {ii}: {ind[ii, :].nonzero()[0]}' for ii in iind]
-        msg = (
-            f"Non-valid mesh {key}: \n"
-            f"  Duplicate knots: {ind.sum()}\n"
-            f"\t- knots.shape: {cents.shape}\n"
-            f"\t- duplicate indices:\n"
-            + "\n".join(lstr)
-        )
-        raise Exception(msg)
 
-    # cents (indices)
-    centsu = np.unique(cents, axis=0)
-    if centsu.shape[0] != ncents:
-        msg = (
-            f"Non-valid mesh {key}: \n"
-            f"  Duplicate cents: {ncents - centsu.shape[0]}\n"
-            f"\t- cents.shape: {cents.shape}\n"
-            f"\t- unique shape: {centsu.shape}"
-        )
-        raise Exception(msg)
+###############################################################################
+###############################################################################
+#           Check inputs - arbitrary points, multiple apertures
+###############################################################################
 
-    # -------------------------------
-    # Test for unused / unknown knots
 
-    centsu = np.unique(centsu)
-    c0 = np.all(centsu >= 0) and centsu.size == nknots
+def _check_pts(pts=None, pts_name=None):
 
-    # unused knots
-    ino = (~np.in1d(
-        range(0, nknots),
-        centsu,
-        assume_unique=False,
-        invert=False,
-    )).nonzero()[0]
-
-    # unknown knots
-    unknown = np.setdiff1d(centsu, range(nknots), assume_unique=True)
-
-    if ino.size > 0 or unknown.size > 0:
-        msg = "Knots non-conformity identified:\n"
-        if ino.size > 0:
-            msg += f"\t- Unused knots indices: {ino}\n"
-        if unknown.size > 0:
-            msg += f"\t- Unknown knots indices: {unknown}\n"
-        raise Exception(msg)
+    if not isinstance(pts, np.ndarray):
+        try:
+            pts = np.atleast_1d(pts)
+        except Exception as err:
+            msg = (
+                f"Arg {pts_name} must be convertible to a np.ndarray float\n"
+                "Provided: {pts}"
+            )
+            raise Exception(msg)
+    return pts.astype(float)
 
-    if centsu.size < nknots:
-        msg = (
-            f"Unused knots in {key}:\n"
-            f"\t- unused knots indices: {ino}"
-        )
-        warnings.warn(msg)
 
-    elif centsu.size > nknots or centsu.max() != nknots - 1:
-        unknown = np.setdiff1d(centsu, range(nknots), assume_unique=True)
-        msg = (
-            "Unknown knots refered to in cents!\n"
-            f"\t- unknown knots: {unknown}"
-        )
-        raise Exception(msg)
+def _check_polygon_2d_area_ccw(
+    poly_x0=None,
+    poly_x1=None,
+):
+    """ Assumes non-closed polygon """
 
-    return cents, knots
+    assert not (poly_x0[0] == poly_x0[-1] and poly_x1[0] == poly_x1[-1])
+    i0 = np.arange(0, poly_x0.size)
+    i1 = np.r_[np.arange(1, poly_x0.size), 0]
+    return 0.5*np.sum(
+        (poly_x0[i1] + poly_x0[i0]) * (poly_x1[i1] - poly_x1[i0])
+    )
 
 
-def _mesh2DTri_clockwise(knots=None, cents=None, key=None):
+def _check_polygon_3d_counter_clockwise(
+    poly_x=None,
+    poly_y=None,
+    poly_z=None,
+    normal=None,
+):
+    """ Assumes non-closed polygon """
 
-    x, y = knots[cents, 0], knots[cents, 1]
-    orient = (
-        (y[:, 1] - y[:, 0])*(x[:, 2] - x[:, 1])
-        - (y[:, 2] - y[:, 1])*(x[:, 1] - x[:, 0])
+    cent = np.r_[np.mean(poly_x), np.mean(poly_y), np.mean(poly_z)]
+    normal = normal / np.linalg.norm(normal)
+    if np.abs(normal[2]) < 0.99:
+        e0 = np.r_[-normal[1], normal[0], 0.]
+    else:
+        e0 = np.r_[-normal[2], 0., normal[0]]
+    e0 = e0 / np.linalg.norm(e0)
+    e1 = np.cross(normal, e0)
+
+    # project in 2d
+    px0 = (
+        (poly_x - cent[0]) * e0[0]
+        + (poly_y - cent[1]) * e0[1]
+        + (poly_z - cent[2]) * e0[2]
     )
 
-    clock = orient > 0.
-    if np.any(clock):
-        msg = (
-            "Some triangles not counter-clockwise\n"
-            "  (necessary for matplotlib.tri.Triangulation)\n"
-            f"    => {clock.sum()}/{cents.shape[0]} triangles reshaped"
-        )
-        warnings.warn(msg)
-        cents[clock, 1], cents[clock, 2] = cents[clock, 2], cents[clock, 1]
-    return cents
-
+    px1 = (
+        (poly_x - cent[0]) * e1[0]
+        + (poly_y - cent[1]) * e1[1]
+        + (poly_z - cent[2]) * e1[2]
+    )
 
-def _mesh2DTri_to_dict(knots=None, cents=None, key=None, trifind=None):
+    # counter-clockwise?
+    return _check_polygon_2d_area_ccw(
+        poly_x0=px0,
+        poly_x1=px1,
+    ) > 0
 
-    # ---------------------
-    # check mesh conformity
 
-    cents, knots = _mesh2DTri_conformity(knots=knots, cents=cents, key=key)
+def _check_polygon_2d(
+    poly_x=None,
+    poly_y=None,
+    poly_name=None,
+    can_be_None=None,
+    closed=None,
+    counter_clockwise=None,
+    return_area=None,
+):
 
-    # ---------------------------------------------
-    # define triangular mesh and trifinder function
+    # -------------
+    # check inputs
 
-    # triangular mesh
-    if cents.shape[1] == 3:
+    # closed
+    closed = ds._generic_check._check_var(
+        closed, 'closed',
+        types=bool,
+        default=True,
+    )
 
-        # check clock-wise triangles
-        cents = _mesh2DTri_clockwise(knots=knots, cents=cents, key=key)
-        ntri = 1
+    # counter_clockwise
+    counter_clockwise = ds._generic_check._check_var(
+        counter_clockwise, 'counter_clockwise',
+        types=bool,
+        default=True,
+    )
 
-    # Quadrangular mesh => convert to triangular
-    elif cents.shape[1] == 4:
+    # can_be_None
+    can_be_None = ds._generic_check._check_var(
+        can_be_None, 'can_be_None',
+        types=bool,
+        default=False,
+    )
 
-        cents2 = np.empty((cents.shape[0]*2, 3), dtype=int)
-        cents2[::2, :] = cents[:, :3]
-        cents2[1::2, :-1] = cents[:, 2:]
-        cents2[1::2, -1] = cents[:, 0]
-        cents = cents2
+    # return_area
+    return_area = ds._generic_check._check_var(
+        return_area, 'return_area',
+        types=bool,
+        default=False,
+    )
 
-        # Re-check mesh conformity
-        cents, knots = _mesh2DTri_conformity(knots=knots, cents=cents, key=key)
-        cents = _mesh2DTri_clockwise(knots=knots, cents=cents, key=key)
-        ntri = 2
+    # -------------
+    # Trivial case
 
-    # check trifinder
-    if trifind is None:
-        mpltri = mplTri(knots[:, 0], knots[:, 1], cents)
-        trifind = mpltri.get_trifinder()
+    if can_be_None and poly_x is None:
+        return None, None
 
-    # ----------------------------
-    # Check on trifinder function
+    # ------------------------
+    # check each is a 1d array
 
-    assert callable(trifind), "Arg trifind must be a callable!"
+    if isinstance(poly_x, (list, tuple)):
+        poly_x = np.atleast_1d(poly_x)
+        poly_y = np.atleast_1d(poly_y)
 
-    try:
-        out = trifind(np.r_[0.], np.r_[0])
-        assert isinstance(out, np.ndarray)
-    except Exception as err:
+    c0 = (
+        all([
+            isinstance(pp, np.ndarray) for pp in [poly_x, poly_y]
+        ])
+        and poly_x.ndim == poly_y.ndim == 1
+        and poly_x.shape == poly_y.shape
+    )
+    if not c0:
         msg = (
-            "Arg trifind must return an array of indices when fed with arrays "
-            "of (R, Z) coordinates!\n"
-            f"\ttrifind(np.r_[0], np.r_[0.]) = {out}"
+            f"Arg {poly_name} must be 2 (npts,) arrays, where\n"
+            "\t- poly_x, poly_y are (X, Y) coordinates\n"
+            "\t- npts is the number of vertices\n"
+            f"Provided:\n{poly_x, poly_y}"
         )
         raise Exception(msg)
 
-    # -----------------
-    # Format ouput dict
+    # ------------------------
+    # make sure not closed for ccw test
 
-    kk = f"{key}-nk"
-    kc = f"{key}-nc"
-    ki = f"{key}-nind"
-
-    kcR = f"{key}-c-R"
-    kcZ = f"{key}-c-Z"
-    kkR = f"{key}-k-R"
-    kkZ = f"{key}-k-Z"
-    kii = f"{key}-ind"
-
-    # dref
-    dref = {
-        kk: {
-            'size': knots.shape[0],
-        },
-        kc: {
-            'size': cents.shape[0],
-        },
-        ki: {
-            'size': 3,
-        },
-    }
-
-    # ddata
-    ddata = {
-        kkR: {
-            'data': knots[:, 0],
-            'units': 'm',
-            'quant': 'R',
-            'dim': 'distance',
-            'ref': kk,
-        },
-        kkZ: {
-            'data': knots[:, 1],
-            'units': 'm',
-            'quant': 'Z',
-            'dim': 'distance',
-            'ref': kk,
-        },
-        kcR: {
-            'data': np.mean(knots[cents, 0], axis=1),
-            'units': 'm',
-            'quant': 'R',
-            'dim': 'distance',
-            'ref': kc,
-        },
-        kcZ: {
-            'data': np.mean(knots[cents, 1], axis=1),
-            'units': 'm',
-            'quant': 'Z',
-            'dim': 'distance',
-            'ref': kc,
-        },
-        kii: {
-            'data': cents,
-            # 'units': '',
-            'quant': 'indices',
-            'dim': 'indices',
-            'ref': (kc, ki),
-        },
-    }
-
-    # dobj
-    dmesh = {
-        key: {
-            'type': 'tri',
-            'ntri': ntri,
-            'cents': (kcR, kcZ),
-            'knots': (kkR, kkZ),
-            'ind': kii,
-            # 'ref-k': (kk,),
-            # 'ref-c': (kc,),
-            'shape-c': (cents.shape[0],),
-            'shape-k': (knots.shape[0],),
-            'func_trifind': trifind,
-            'crop': False,
-        },
-    }
-    return dref, ddata, dmesh
+    pt0 = np.r_[poly_x[0], poly_y[0]]
+    pt1 = np.r_[poly_x[-1], poly_y[-1]]
+    if np.allclose(pt0, pt1):
+        poly_x = poly_x[:-1]
+        poly_y = poly_y[:-1]
+
+    # ------------------------
+    # make sure float
+
+    poly_x = poly_x.astype(float)
+    poly_y = poly_y.astype(float)
+
+    # ------------------------
+    # check counter-clockwise ass seen from normal vector
+
+    area_ccw = _check_polygon_2d_area_ccw(
+        poly_x0=poly_x,
+        poly_x1=poly_y,
+    )
+    if counter_clockwise != (area_ccw > 0):
+        poly_x = np.ascontiguousarray(poly_x[::-1])
+        poly_y = np.ascontiguousarray(poly_y[::-1])
+
+    # ------------------------
+    # check if closed vs close
+
+    if closed:
+        poly_x = np.r_[poly_x, poly_x[0]]
+        poly_y = np.r_[poly_y, poly_y[0]]
 
+    # --------------
+    # return
 
-# #############################################################################
-# #############################################################################
-#                           Mesh2DRect
-# #############################################################################
+    if return_area:
+        return poly_x, poly_y, np.abs(area_ccw)
+    else:
+        return poly_x, poly_y
 
 
-def _mesh2DRect_X_check(
-    x=None,
-    res=None,
+def _check_polygon_3d(
+    poly_x=None,
+    poly_y=None,
+    poly_z=None,
+    poly_name=None,
+    can_be_None=None,
+    closed=None,
+    counter_clockwise=None,
+    normal=None,
 ):
-    """ Returns knots (x) and associated resolution
 
-    res can be:
-        - int: numbr of mesh elements desired between knots
-        - float: desired average mesh element size
-        - array of floats: (one for each x, desired approximate mesh size)
+    # -------------
+    # check inputs
 
-    """
+    # closed
+    closed = ds._generic_check._check_var(
+        closed, 'closed',
+        types=bool,
+        default=True,
+    )
 
-    # ------------
-    # Check inputs
+    # counter_clockwise
+    counter_clockwise = ds._generic_check._check_var(
+        counter_clockwise, 'counter_clockwise',
+        types=bool,
+        default=True,
+    )
 
-    # x
-    try:
-        x = np.unique(np.ravel(x).astype(float))
-    except Exception as err:
-        msg = "x must be convertible to a sorted, flat array of floats!"
-        raise Exception(msg)
+    # can_be_None
+    can_be_None = ds._generic_check._check_var(
+        can_be_None, 'can_be_None',
+        types=bool,
+        default=False,
+    )
 
-    # res
-    if res is None:
-        res = 10
-
-    lc = [
-        isinstance(res, (int, np.int64, np.int32)) and len(x) == 2,
-        isinstance(res, (float, np.floating)) and len(x) == 2,
-        isinstance(res, (list, tuple, np.ndarray)) and len(x) == len(res),
-    ]
-    if not any(lc):
-        msg = (
-            "Arg res must be:\n"
-            "\t- int: nb of mesh elements along x\n"
-            "\t       requires len(x) = 2\n"
-            "\t- float: approximate desired mesh element size along x\n"
-            "\t       requires len(x) = 2\n"
-            "\t- iterable: approximate desired mesh element sizes along x\n"
-            "\t       requires len(x) = len(res)\n"
-        )
-        raise Exception(msg)
+    # -------------
+    # Trivial case
 
-    if lc[0]:
-        x_new = np.linspace(x[0], x[1], int(res)+1)
-        res_new = res
-        indsep = None
-
-    elif lc[1]:
-        nb = int(np.ceil((x[1]-x[0]) / res))
-        x_new = np.linspace(x[0], x[1], nb+1)
-        res_new = np.mean(np.diff(x))
-        indsep = None
+    if can_be_None and poly_x is None:
+        return None, None, None
 
-    else:
+    # ------------------------
+    # check each is a 1d array
 
-        # check conformity
-        res = np.ravel(res).astype(float)
-        delta = np.diff(x)
-        res_sum = res[:-1] + res[1:]
-        ind = res_sum > delta + 1.e-14
-        if np.any(ind):
-            msg = (
-                "Desired resolution is not achievable for the following:\n"
-                f"res_sum: {res_sum[ind]}\n"
-                f"delta  : {delta[ind]}"
-            )
-            raise Exception(msg)
+    if isinstance(poly_x, (list, tuple)):
+        poly_x = np.atleast_1d(poly_x)
+        poly_y = np.atleast_1d(poly_y)
+        poly_z = np.atleast_1d(poly_z)
 
-        # compute nn
-        # nn = how many pairs can fit in the interval
-        npairs = np.round(delta/res_sum).astype(int)
-        res_sum_new = delta / npairs
-
-        fract = res[:-1] / res_sum
-
-        res_new = [None for ii in range(len(x)-1)]
-        x_new = [None for ii in range(len(x)-1)]
-        for ii in range(len(x)-1):
-            res_new[ii] = (
-                res_sum_new[ii]
-                * np.linspace(fract[ii], 1.-fract[ii], 2*npairs[ii])
-            )
-            if ii == 0:
-                res_add = np.concatenate(([0], np.cumsum(res_new[ii])))
-            else:
-                res_add = np.cumsum(res_new[ii])
-            x_new[ii] = x[ii] + res_add
-
-        indsep = np.cumsum(npairs[:-1]*2)
-        res_new = np.concatenate(res_new)
-        x_new = np.concatenate(x_new)
-
-    return x_new, res_new, indsep
-
-
-def _mesh2DRect_check(
-    domain=None,
-    res=None,
-    R=None,
-    Z=None,
-):
+    c0 = (
+        all([
+            isinstance(pp, np.ndarray) for pp in [poly_x, poly_y, poly_z]
+        ])
+        and poly_x.ndim == poly_y.ndim == poly_z.ndim == 1
+        and poly_x.shape == poly_y.shape == poly_z.shape
+    )
+    if not c0:
+        msg = (
+            f"Arg {poly_name} must be 3 (npts,) arrays, where\n"
+            "\t- poly_x, poly_y, poly_z are (X, Y, Z) coordinates\n"
+            "\t- npts is the number of vertices\n"
+            f"Provided:\n{poly_x, poly_y, poly_z}"
+        )
+        raise Exception(msg)
 
-    # --------------
-    # check inputs
+    # ------------------------
+    # make sure not closed for ccw test
 
-    # (domain, res) vs (R, Z)
-    lc = [
-        domain is not None,
-        R is not None and Z is not None,
-    ]
-    if all(lc) or not any(lc):
+    pt0 = np.r_[poly_x[0], poly_y[0], poly_z[0]]
+    pt1 = np.r_[poly_x[-1], poly_y[-1], poly_z[-1]]
+    if np.allclose(pt0, pt1):
+        poly_x = poly_x[:-1]
+        poly_y = poly_y[:-1]
+        poly_z = poly_z[:-1]
+
+    # ------------------------
+    # make sure float
+
+    poly_x = poly_x.astype(float)
+    poly_y = poly_y.astype(float)
+    poly_z = poly_z.astype(float)
+
+    # ------------------------
+    # check counter-clockwise ass seen from normal vector
+
+    ccw = _check_polygon_3d_counter_clockwise(
+        poly_x=poly_x,
+        poly_y=poly_y,
+        poly_z=poly_z,
+        normal=normal,
+    )
+    if counter_clockwise != ccw:
+        poly_x = poly_x[::-1]
+        poly_y = poly_y[::-1]
+        poly_z = poly_z[::-1]
+
+    # ------------------------
+    # check if closed vs close
+
+    if closed:
+        poly_x = np.r_[poly_x, poly_x[0]]
+        poly_y = np.r_[poly_y, poly_y[0]]
+        poly_z = np.r_[poly_z, poly_z[0]]
+
+    return poly_x, poly_y, poly_z
+
+
+def _check_unit_vectors(det=None):
+    # check normalization
+    dnorm = {
+        k0: np.sqrt(det[f'{k0}_x']**2 + det[f'{k0}_y']**2 + det[f'{k0}_z']**2)
+        for k0 in ['e0', 'e1', 'nin']
+    }
+    if not np.allclose(list(dnorm.values()), 1):
+        lstr = [f"\t- {k0} = {v0}" for k0, v0 in dnorm.items()]
         msg = (
-            "Please provide (domain, res) xor (R, Z), not both:\n"
-            "Provided:\n"
-            f"\t- domain, res: {domain}, {res}\n"
-            f"\t- R, Z: {R}, {Z}\n"
+            "All unit vectors ['e0', 'e1', 'nin'] must be normalized!\n"
+            + "\n".join(lstr)
         )
         raise Exception(msg)
 
-    if lc[0]:
-        # domain
-        c0 = (
-            isinstance(domain, list)
-            and len(domain) == 2
-            and all([
-                hasattr(dd, '__iter__') and len(dd) >= 2 for dd in domain
-            ])
+    # check perpendicularity
+    dsca = {
+        f'{v0}.{v1}': (
+            det[f'{v0}_x']*det[f'{v1}_x']
+            + det[f'{v0}_y']*det[f'{v1}_y']
+            + det[f'{v0}_z']*det[f'{v1}_z']
         )
-        if not c0:
-            msg = (
-                "Arg domain must be a list of 2 iterables of len() >= 2\n"
-                f"Provided: {domain}"
-            )
-            raise Exception(msg)
-
-        # res
-        c0 = (
-            res is None
-            or np.isscalar(res)
-            or isinstance(res, list) and len(res) == 2
+        for v0, v1 in [('e0', 'e1'), ('e0', 'nin'), ('e1', 'nin')]
+    }
+    if not np.allclose(list(dsca.values()), 0):
+        lstr = [f"\t- {k0} = {v0}" for k0, v0 in dsca.items()]
+        msg = (
+            "All unit vectors ['e0', 'e1', 'nin'] must be perpendicular!\n"
+            + "\n".join(lstr)
         )
-        if not c0:
-            msg = (
-                "Arg res must be a int, float or array or a list of 2 such\n"
-                f"Provided: {res}"
-            )
-            raise Exception(msg)
+        raise Exception(msg)
 
-        if np.isscalar(res) or res is None:
-            res = [res, res]
 
-        # -------------
-        # check R and Z
+def _check_det_dict(detectors=None):
 
-        R, resR, indR = _mesh2DRect_X_check(domain[0], res=res[0])
-        Z, resZ, indZ = _mesh2DRect_X_check(domain[1], res=res[1])
+    lk_out = ['outline_x0', 'outline_x1']
+    lk_shape = [
+        'cents_x', 'cents_y', 'cents_z',
+        'e0_x', 'e0_y', 'e0_z',
+        'e1_x', 'e1_y', 'e1_z',
+        'nin_x', 'nin_y', 'nin_z',
+    ]
 
-    elif lc[1]:
+    # make sure array + float
+    for k0 in set(lk_shape).intersection(detectors.keys()):
+        detectors[k0] = np.atleast_1d(detectors[k0]).astype(float)
 
-        # R, Z check
-        c0 = (
-            hasattr(R, '__iter__')
-            and np.asarray(R).ndim == 1
-            and np.unique(R).size == np.array(R).size
-            and np.allclose(np.unique(R), R)
-        )
-        if not c0:
-            msg = "Arg R must be convertible to a 1d increasing array"
-            raise Exception(msg)
-
-        c0 = (
-            hasattr(Z, '__iter__')
-            and np.asarray(Z).ndim == 1
-            and np.unique(Z).size == np.array(Z).size
-            and np.allclose(np.unique(Z), Z)
+    # check shapes
+    c0 = (
+        all([
+            isinstance(detectors.get(ss), np.ndarray)
+            for ss in lk_out + lk_shape
+        ])
+        and all([
+            detectors[ss].shape == detectors['outline_x0'].shape
+            for ss in lk_out
+        ])
+        and all([
+            detectors[ss].shape == detectors['cents_x'].shape
+            for ss in lk_shape
+        ])
+    )
+    if not c0:
+        lmis = [kk for kk in lk_out + lk_shape if kk not in detectors.keys()]
+        msg = (
+            "Arg detectors, if a dict, must contain the following keys:\n"
+            + f"\t- missing keys: {lmis}\n"
+            "And the following keys should be array of identical shape:\n"
+            + "\n".join([f"\t- {kk}" for kk in lk_out])
+            + "\nAnd the following keys should be array of identical shape:\n"
+            + "\n".join([f"\t- {kk}" for kk in lk_shape])
+            + f"\nProvided:\n{detectors}"
         )
-        if not c0:
-            msg = "Arg Z must be convertible to a 1d increasing array"
-            raise Exception(msg)
+        raise Exception(msg)
 
-        R = np.unique(R)
-        Z = np.unique(Z)
+    # check outline
+    detectors['outline_x0'], detectors['outline_x1'] = _check_polygon_2d(
+        poly_x=detectors['outline_x0'],
+        poly_y=detectors['outline_x1'],
+        poly_name='det',
+        can_be_None=False,
+        closed=False,
+        counter_clockwise=True,
+    )
 
-        resR = np.diff(R)
-        resZ = np.diff(Z)
+    # check unit vectors (normalize + perpendicular)
+    _check_unit_vectors(detectors)
 
-        if np.allclose(resR, np.mean(resR), atol=1e-12, rtol=0):
-            resR = resR[0]
-            indR = None
-        else:
-            msg = (
-                "Non-uniform resolution for user-provided rectangular mesh\n"
-                f"\t- unique resR: {np.unique(resR)}\n"
-                f"\t- diff resR: {np.diff(np.unique(resR))}\n"
-                f"\t- resR: {resR}\n"
-                )
-            raise NotImplementedError(msg)
-            
-        if np.allclose(resZ, np.mean(resZ), atol=1e-12, rtol=0):
-            resZ = resZ[0]
-            indZ = None
-        else:
-            msg = (
-                "Non-uniform resolution for user-provided rectangular mesh\n"
-                f"\t- unique resZ: {np.unique(resZ)}\n"
-                f"\t- diff resZ: {np.diff(np.unique(resZ))}\n"
-                f"\t- resZ: {resZ}\n"
-                )
-            raise NotImplementedError(msg)
+    # copy dict and flatten (if not 1d)
+    if detectors['cents_x'].ndim > 1:
+        detectors = dict(detectors)
+        lk = [k0 for k0 in detectors.keys() if 'outline' not in k0]
+        for k0 in lk:
+            detectors[k0] = detectors[k0].ravel()
 
-    return R, Z, resR, resZ, indR, indZ
+    return detectors
 
 
-def _mesh2DRect_to_dict(
-    domain=None,
-    res=None,
-    R=None,
-    Z=None,
-    key=None,
-):
+def _check_ap_dict(apertures=None):
 
-    # --------------------
-    # check / format input
+    lk0 = ['poly_x', 'poly_y', 'poly_z']
+    lk1 = ['nin']
 
-    kRk, kZk = f'{key}-R-nk', f'{key}-Z-nk'
-    kRc, kZc = f'{key}-R-nc', f'{key}-Z-nc'
-    kkR, kkZ = f"{key}-k-R", f"{key}-k-Z"
-    kcR, kcZ = f"{key}-c-R", f"{key}-c-Z"
-
-    R, Z, resR, resZ, indR, indZ = _mesh2DRect_check(
-        domain=domain,
-        res=res,
-        R=R,
-        Z=Z,
-    )
-    Rcent = 0.5*(R[1:] + R[:-1])
-    Zcent = 0.5*(Z[1:] + Z[:-1])
-
-    variable = not (np.isscalar(resR) and np.isscalar(resZ))
-
-    # --------------------
-    # prepare dict
-
-    # dref
-    dref = {
-        kRk: {
-            'size': R.size,
-        },
-        kZk: {
-            'size': Z.size,
-        },
-        kRc: {
-            'size': Rcent.size,
-        },
-        kZc: {
-            'size': Zcent.size,
-        },
-    }
+    err = False
+    if not isinstance(apertures, dict):
+        err = True
+    else:
+        if all([k0 in apertures.keys() for k0 in lk0 + lk1]):
+            apertures = {'ap0': apertures}
 
-    # ddata
-    ddata = {
-        kkR: {
-            'data': R,
-            'units': 'm',
-            # 'source': None,
-            'dim': 'distance',
-            'quant': 'R',
-            'name': 'R',
-            'ref': kRk,
-        },
-        kkZ: {
-            'data': Z,
-            'units': 'm',
-            # 'source': None,
-            'dim': 'distance',
-            'quant': 'Z',
-            'name': 'Z',
-            'ref': kZk,
-        },
-        kcR: {
-            'data': Rcent,
-            'units': 'm',
-            # 'source': None,
-            'dim': 'distance',
-            'quant': 'R',
-            'name': 'R',
-            'ref': kRc,
-        },
-        kcZ: {
-            'data': Zcent,
-            'units': 'm',
-            # 'source': None,
-            'dim': 'distance',
-            'quant': 'Z',
-            'name': 'Z',
-            'ref': kZc,
-        },
-    }
+        lkout = [
+            k0 for k0, v0 in apertures.items()
+            if not (
+                all([k1 in v0.keys() for k1 in lk0 + lk1])
+                and all([
+                    isinstance(v0[k1], np.ndarray)
+                    and v0['poly_x'].shape == v0[k1].shape
+                    for k1 in lk0
+                ])
+                and all([v0[k1].shape == (3,) for k1 in lk1])
+                and np.sqrt(np.sum([v0[k1]**2 for k1 in lk1])) == 1.
+            )
+        ]
+        if len(lkout) > 1:
+            err = True
 
-    # dobj
-    dmesh = {
-        key: {
-            'type': 'rect',
-            'knots': (kkR, kkZ),
-            'cents': (kcR, kcZ),
-            # 'ref-k': (kRk, kZk),
-            # 'ref-c': (kRc, kZc),
-            'shape-c': (Rcent.size, Zcent.size),
-            'shape-k': (R.size, Z.size),
-            'variable': variable,
-            'crop': False,
-        },
-    }
-    return dref, ddata, dmesh
+    if err:
+        msg = (
+            "Arg apertures must be a dict with keys:\n"
+            "\t- 'nin': normal vector oriented towards the plasma\n"
+            "\t- 'poly_x', 'poly_y', 'poly_z': 3d (x, y, z) polygon\n"
+            "        must be counter-clockwise from 'nin'"
+        )
+        raise Exception(msg)
 
+    # make sure float
+    for k0, v0 in apertures.items():
+        for k1 in lk0 + lk1:
+            apertures[k0][k1] = np.atleast_1d(v0[k1]).ravel().astype(float)
 
-def _mesh2DRect_from_croppoly(crop_poly=None, domain=None):
+    # check polygons
+    for k0, v0 in apertures.items():
+        (
+            apertures[k0]['poly_x'],
+            apertures[k0]['poly_y'],
+            apertures[k0]['poly_z'],
+        ) = _check_polygon_3d(
+            poly_x=v0['poly_x'],
+            poly_y=v0['poly_y'],
+            poly_z=v0['poly_z'],
+            poly_name=k0,
+            can_be_None=False,
+            closed=False,
+            counter_clockwise=True,
+            normal=v0['nin'],
+        )
+
+    return apertures
+
+
+def _calc_solidangle_apertures_check(
+    # observation points
+    pts_x=None,
+    pts_y=None,
+    pts_z=None,
+    # polygons
+    apertures=None,
+    detectors=None,
+    # possible obstacles
+    config=None,
+    # parameters
+    summed=None,
+    visibility=None,
+    return_vector=None,
+    # output formatting
+    return_flat_pts=None,
+    return_flat_det=None,
+    # options
+    timing=None,
+):
 
-    # ------------
-    # check inputs
+    # ---------------
+    # pts coordinates
 
-    c0 = hasattr(crop_poly, '__iter__') and len(crop_poly) == 2
-    lc = [
-        crop_poly is None,
-        (
-            c0
-            and isinstance(crop_poly, tuple)
-            and crop_poly[0].__class__.__name__ == 'Config'
-            and (isinstance(crop_poly[1], str) or crop_poly[1] is None)
-        )
-        or crop_poly.__class__.__name__ == 'Config',
-        c0
-        and all([
-            hasattr(cc, '__iter__') and len(cc) == len(crop_poly[0])
-            for cc in crop_poly[1:]
-        ])
-        and np.asarray(crop_poly).ndim == 2
-    ]
+    pts_x = _check_pts(pts=pts_x)
+    pts_y = _check_pts(pts=pts_y)
+    pts_z = _check_pts(pts=pts_z)
 
-    if not any(lc):
+    if not (pts_x.shape == pts_y.shape == pts_z.shape):
         msg = (
-            "Arg config must be a Config instance!"
+            "Arg pts_x, pts_y and pts_z must share the same shape!\n"
+            f"\t- pts_x.shape = {pts_x.shape}\n"
+            f"\t- pts_y.shape = {pts_y.shape}\n"
+            f"\t- pts_z.shape = {ptszz.shape}\n"
         )
         raise Exception(msg)
 
-    # -------------
-    # Get polyand domain
-
-    if lc[0]:
-        # trivial case
-        poly = None
+    mask = np.isfinite(pts_x) & np.isfinite(pts_y) & np.isfinite(pts_z)
+    if np.all(mask):
+        mask = None
 
-    else:
+    # ---------
+    # detectors
 
-        # -------------
-        # Get poly from input
+    detectors = _check_det_dict(detectors)
 
-        if lc[1]:
-            # (config, structure name)
+    # ---------
+    # apertures
 
-            if crop_poly.__class__.__name__ == 'Config':
-                config = crop_poly
-                key_struct = None
-            else:
-                config, key_struct = crop_poly
-
-            # key_struct if None
-            if key_struct is None:
-                lk, ls = zip(*[
-                    (ss.Id.Name, ss.dgeom['Surf']) for ss in config.lStructIn
-                ])
-                key_struct = lk[np.argmin(ls)]
+    if apertures is not None:
+        apertures = _check_ap_dict(apertures)
 
-            # poly
-            poly = config.dStruct['dObj']['Ves'][key_struct].Poly_closed
+    # ----------
+    # summed
 
-        else:
+    summed = ds._generic_check._check_var(
+        summed, 'summed',
+        types=bool,
+        default=False,
+    )
 
-            # make sure poly is np.ndarraya and closed
-            poly = np.asarray(crop_poly).astype(float)
-            if not np.allclose(poly[:, 0], poly[:, -1]):
-                poly = np.concatenate((poly, poly[:, 0:1]))
-
-        # -------------
-        # Get domain from poly
-
-        if domain is None:
-            domain = [
-                [poly[0, :].min(), poly[0, :].max()],
-                [poly[1, :].min(), poly[1, :].max()],
-            ]
-
-    return domain, poly
-
-
-# #############################################################################
-# #############################################################################
-#                           Mesh2DRect - select
-# #############################################################################
-
-
-def _select_ind_check(
-    ind=None,
-    elements=None,
-    returnas=None,
-    crop=None,
-    meshtype=None,
-    shape2d=None,
-):
+    # ----------
+    # visibility
 
-    # ----------------------
-    # check basic conditions
+    visibility = ds._generic_check._check_var(
+        visibility, 'visibility',
+        types=bool,
+        default=False,
+    )
 
-    if shape2d:
-        lc = [
-            ind is None,
-            isinstance(ind, tuple)
-            and len(ind) == 2
-            and (
-                all([np.isscalar(ss) for ss in ind])
-                or all([
-                    hasattr(ss, '__iter__')
-                    and len(ss) == len(ind[0])
-                    for ss in ind
-                ])
-                or all([isinstance(ss, np.ndarray) for ss in ind])
-            ),
-            (
-                np.isscalar(ind)
-                or (
-                    hasattr(ind, '__iter__')
-                    and all([np.isscalar(ss) for ss in ind])
-                )
-                or isinstance(ind, np.ndarray)
-            )
-        ]
+    # -------------
+    # return_vector
 
-    else:
-        lc = [
-            ind is None,
-            np.isscalar(ind)
-            or (
-                hasattr(ind, '__iter__')
-                and all([np.isscalar(ss) for ss in ind])
-            )
-            or isinstance(ind, np.ndarray)
-        ]
+    return_vector = ds._generic_check._check_var(
+        return_vector, 'return_vector',
+        types=bool,
+        default=False,
+    )
 
-    # check lc
-    if not any(lc):
-        if shape2d:
-            msg = (
-                "Arg ind must be either:\n"
-                "\t- None\n"
-                "\t- int or array of int: int indices in mixed (R, Z) index\n"
-                "\t- tuple of such: int indices in (R, Z) index respectively\n"
-                f"Provided: {ind}"
-            )
-        else:
-            msg = (
-                "Arg ind must be either:\n"
-                "\t- None\n"
-                "\t- int or array of int: int indices\n"
-                "\t- array of bool: bool indices\n"
-                f"Provided: {ind}"
-            )
-        raise Exception(msg)
+    # -------------
+    # timing
 
-    # ----------------------
-    # adapt to each case
+    timing = ds._generic_check._check_var(
+        timing, 'timing',
+        types=bool,
+        default=False,
+    )
 
-    if lc[0]:
-        pass
+    # -------------
+    # compatibility
 
-    elif lc[1] and shape2d:
-        if any([not isinstance(ss, np.ndarray) for ss in ind]):
-            ind = (
-                np.atleast_1d(ind[0]).astype(int),
-                np.atleast_1d(ind[1]).astype(int),
-            )
-        lc0 = [
-            [
-                isinstance(ss, np.ndarray),
-                np.issubdtype(ss.dtype, np.integer),
-                ss.shape == ind[0].shape,
-            ]
-                for ss in ind
-        ]
-        if not all([all(cc) for cc in lc0]):
-            ltype = [type(ss) for ss in ind]
-            ltypes = [
-                ss.dtype if isinstance(ss, np.ndarray) else False
-                for ss in ind
-            ]
-            lshapes = [
-                ss.shape if isinstance(ss, np.ndarray) else len(ss)
-                for ss in ind
-            ]
+    if summed is True:
+        if (visibility or return_vector or apertures is None):
             msg = (
-                "Arg ind must be a tuple of 2 arrays of int of same shape\n"
-                f"\t- lc0: {lc0}\n"
-                f"\t- types: {ltype}\n"
-                f"\t- type each: {ltypes}\n"
-                f"\t- shape: {lshapes}\n"
-                f"\t- ind: {ind}"
+                "Arg summed = True only usable with (so far):\n"
+                "\t- visibility = False\n"
+                "\t- return_vector = False\n"
+                "\t- aperture != None"
             )
-            raise Exception(msg)
+            raise NotImplementedError(msg)
 
-    elif lc[1] and not shape2d:
-        if not isinstance(ind, np.ndarray):
-            ind = np.atleast_1d(ind).astype(int)
-        c0 = (
-            np.issubdtype(ind.dtype, np.integer)
-            or np.issubdtype(ind.dtype, np.bool_)
-        )
-        if not c0:
+    # ------
+    # config
+
+    if visibility:
+        if not config.__class__.__name__ == 'Config':
             msg = (
-                "Arg ind must be an array of bool or int\n"
-                f"Provided: {ind.dtype}"
+                "If visibility, config must be provided (Config instance)\n"
+                f"Provided: {config}"
             )
             raise Exception(msg)
 
-    else:
-        if not isinstance(ind, np.ndarray):
-             ind = np.atleast_1d(ind).astype(int)
-        c0 = (
-            np.issubdtype(ind.dtype, np.integer)
-            or np.issubdtype(ind.dtype, np.bool_)
+    # ----------
+    # check aperture vs visibility
+
+    if apertures is None and (visibility is True or return_vector is True):
+        msg = (
+            "No apertures provided!\n"
+            "=> visibility must be False\n"
+            "=> return_vector must be False\n"
         )
-        if not c0:
-            msg = (
-                 "Arg ind must be an array of bool or int\n"
-                 f"Provided: {ind.dtype}"
-            )
-            raise Exception(msg)
+        raise Exception(msg)
 
-    # elements
-    elements = ds._generic_check._check_var(
-        elements, 'elements',
-        types=str,
-        default=_ELEMENTS,
-        allowed=['knots', 'cents'],
+    return (
+        pts_x, pts_y, pts_z, mask,
+        apertures, detectors,
+        summed, visibility,
+        return_vector, timing,
     )
 
-    # returnas
-    if shape2d:
-        retdef = tuple
-        retok = [tuple, np.ndarray, 'tuple-flat', 'array-flat', bool]
-    else:
-        retdef = bool
-        retok = [int, bool]
 
-    returnas = ds._generic_check._check_var(
-        returnas, 'returnas',
-        types=None,
-        default=retdef,
-        allowed=retok,
-    )
+###############################################################################
+###############################################################################
+#           Prepare data - arbitrary points, multiple apertures
+###############################################################################
+
+
+def _calc_solidangle_apertures_prepare(
+    # observation points
+    pts_x=None,
+    pts_y=None,
+    pts_z=None,
+    mask=None,
+    # polygons
+    apertures=None,
+    detectors=None,
+    # possible obstacles
+    config=None,
+):
 
-    # crop
-    crop = ds._generic_check._check_var(
-        crop, 'crop',
-        types=bool,
-        default=True,
+    # -----------------------------
+    # pts as 1d C-contiguous arrays
+
+    ndim0 = pts_x.ndim
+    shape0 = pts_x.shape
+
+    if mask is not None:
+        pts_x = pts_x[mask]
+        pts_y = pts_y[mask]
+        pts_z = pts_z[mask]
+
+    if ndim0 > 1:
+        pts_x = pts_x.ravel()
+        pts_y = pts_y.ravel()
+        pts_z = pts_z.ravel()
+
+    # ---------
+    # apertures
+
+    if apertures is None:
+        ap_ind, ap_x, ap_y, ap_z = None, None, None, None
+        ap_nin_x, ap_nin_y, ap_nin_z = None, None, None
+    else:
+        lka = list(apertures.keys())
+        ap_ind = np.r_[
+            0, np.cumsum([apertures[k0]['poly_x'].size for k0 in lka])
+        ]
+        ap_x = np.concatenate([apertures[k0]['poly_x'] for k0 in lka])
+        ap_y = np.concatenate([apertures[k0]['poly_y'] for k0 in lka])
+        ap_z = np.concatenate([apertures[k0]['poly_z'] for k0 in lka])
+        ap_nin_x = np.array([apertures[k0]['nin'][0] for k0 in lka])
+        ap_nin_y = np.array([apertures[k0]['nin'][1] for k0 in lka])
+        ap_nin_z = np.array([apertures[k0]['nin'][2] for k0 in lka])
+
+    # ---------
+    # detectors
+
+    det_shape0 = detectors['cents_x'].shape
+
+    det_outline_x0 = detectors['outline_x0']
+    det_outline_x1 = detectors['outline_x1']
+    det_cents_x = detectors['cents_x'].ravel()
+    det_cents_y = detectors['cents_y'].ravel()
+    det_cents_z = detectors['cents_z'].ravel()
+    det_nin_x = detectors['nin_x'].ravel()
+    det_nin_y = detectors['nin_y'].ravel()
+    det_nin_z = detectors['nin_z'].ravel()
+    det_e0_x = detectors['e0_x'].ravel()
+    det_e0_y = detectors['e0_y'].ravel()
+    det_e0_z = detectors['e0_z'].ravel()
+    det_e1_x = detectors['e1_x'].ravel()
+    det_e1_y = detectors['e1_y'].ravel()
+    det_e1_z = detectors['e1_z'].ravel()
+
+    return (
+        ndim0, shape0, mask,
+        pts_x, pts_y, pts_z,
+        ap_ind, ap_x, ap_y, ap_z,
+        ap_nin_x, ap_nin_y, ap_nin_z,
+        det_shape0, det_outline_x0, det_outline_x1,
+        det_cents_x, det_cents_y, det_cents_z,
+        det_nin_x, det_nin_y, det_nin_z,
+        det_e0_x, det_e0_y, det_e0_z,
+        det_e1_x, det_e1_y, det_e1_z,
     )
 
-    return ind, elements, returnas, crop
 
+def _visibility_unit_vectors(
+    # points
+    pts_x=None,
+    pts_y=None,
+    pts_z=None,
+    # det
+    det_cents_x=None,
+    det_cents_y=None,
+    det_cents_z=None,
+    det_nin_x=None,
+    det_nin_y=None,
+    det_nin_z=None,
+    # results
+    solid_angle=None,
+    unit_vector_x=None,
+    unit_vector_y=None,
+    unit_vector_z=None,
+    **kwdargs,
+):
+    """
 
-def _select_check(
-    elements=None,
-    returnas=None,
-    return_ind_as=None,
-    return_neighbours=None,
+    """
+
+    # compute pts on det surfaces
+    # re-use pre-existing code (TBF)
+    for ii in range(pts_x.size):
+
+        iok = solid_angle[:, ii] > 0
+        if not np.any(iok):
+            continue
+
+        # Compute point P such that:
+        #   MP = kk * unit_vect
+        #   CP.norm = 0
+        #   => kk = (MC.norm) / (unit_vect.norm)
+
+        # un = unit_vect.norm
+        un = (
+            unit_vector_x[iok, ii]*det_nin_x[iok]
+            + unit_vector_y[iok, ii]*det_nin_y[iok]
+            + unit_vector_z[iok, ii]*det_nin_z[iok]
+        )
+
+        # MC = point to centers
+        MCx = det_cent_x[iok] - pts_x[ii]
+        MCy = det_cent_y[iok] - pts_y[ii]
+        MCz = det_cent_z[iok] - pts_z[ii]
+
+        # MCn = MC.norm
+        MCn = (
+            MCx*det_nin_x[iok]
+            + MCy*det_nin_y[iok]
+            + MCz*det_nin_z[iok]
+        )
+
+        # kk = (MC.norm) / (unit_vect.norm)
+        kk = MCn / un
+
+        # P = M + kk * unit_vect
+        Px = pts_x[ii] + kk * unit_vector_x[iok, ii]
+        Py = pts_y[ii] + kk * unit_vector_y[iok, ii]
+        Pz = pts_z[ii] + kk * unit_vector_z[iok, ii]
+
+        # Estimate visibility
+        vis = _GG.LOS_areVis_PtsFromPts_VesStruct(
+            np.array([pts_x[ii], pts_y[ii], pts_z[ii]]),
+            np.array([Px, Py, Pz]),
+            dist=kk[ii, iok],
+            **kwdargs,
+        )
+
+        # Set non-visible to 0 / nan
+        iout = vis == 0
+        solid_angle[ii, iout] = 0.
+        unit_vector_x[ii, iout] = np.nan
+        unit_vector_y[ii, iout] = np.nan
+        unit_vector_z[ii, iout] = np.nan
+
+
+###############################################################################
+###############################################################################
+#                           Main entry
+#       arbitrary points, multiple detectors, multiple apertures
+###############################################################################
+
+
+def calc_solidangle_apertures(
+    # observation points
+    pts_x=None,
+    pts_y=None,
+    pts_z=None,
+    # polygons
+    apertures=None,
+    detectors=None,
+    # possible obstacles
+    config=None,
+    # parameters
+    summed=None,
+    visibility=None,
+    return_vector=None,
+    return_flat_pts=None,
+    return_flat_det=None,
+    timing=None,
 ):
+    """ Return the solid angle subtended by na apertures and nd detectors
 
-    # elements
-    elements = ds._generic_check._check_var(
-        elements, 'elements',
-        types=str,
-        default=_ELEMENTS,
-        allowed=['knots', 'cents'],
-    )
-
-    # returnas
-    returnas = ds._generic_check._check_var(
-        returnas, 'returnas',
-        types=None,
-        default='ind',
-        allowed=['ind', 'data'],
-    )
-
-    # return_ind_as
-    return_ind_as = ds._generic_check._check_var(
-        return_ind_as, 'return_ind_as',
-        types=None,
-        default=int,
-        allowed=[int, bool],
-    )
-
-    # return_neighbours
-    return_neighbours = ds._generic_check._check_var(
-        return_neighbours, 'return_neighbours',
-        types=bool,
-        default=True,
-    )
+    Uses non-closed polygons
 
-    return elements, returnas, return_ind_as, return_neighbours,
+    See the following issue for details on the implementation:
+        https://github.com/ToFuProject/tofu/issues/653
 
+    The observation points are:
+        - defined in (X, Y, Z) coordinates using arrays pts_x, pts_y, pts_z
+        - They should have the same shape (shape0)
+
+    The apertures are defined as a list of closed 3d polygons:
+        - defined in (X, Y, Z) coordinates
+
+    The detectors are defined another list of closed 3d polygon:
+        - defined in (X, Y, Z) coordinates
+
+    Alternatively, detectors can also be provided as:
+        - being planar and sharing the same 2d outline
+        - using a dict with keys:
+            - 'outline_x0': 1d array of (ncorners,) coordinates
+            - 'outline_x1': 1d array of (ncorners,) coordinates
+            - 'centers_x': detector's center position x as (nd,) array
+            - 'centers_y': detector's center position y as (nd,) array
+            - 'centers_z': detector's center position z as (nd,) array
+            - 'nin_x': normal unit vector x as (nd,) array
+            - 'nin_y': normal unit vector y as (nd,) array
+            - 'nin_z': normal unit vector z as (nd,) array
+            - 'e1_x': x0 unit vector x as (nd,) array
+            - 'e1_y': x0 unit vector y as (nd,) array
+            - 'e1_z': x0 unit vector z as (nd,) array
+            - 'e2_x': x1 unit vector x as (nd,) array
+            - 'e2_y': x1 unit vector y as (nd,) array
+            - 'e2_z': x1 unit vector z as (nd,) array
+
+    Config is needed if visibility = True to check for obstacles (ray-tracing)
+    It is a tofu Config class
+
+    Return
+    ----------
+    solid_angle:        np.ndarray of shape (nd, shape0)
+        The solid angles
+            computed for each point / det pair
+            considering all apertures
+    unit_vector_x:      np.ndarray of shape (nd, shape0)  (optional)
+        The local unit vectors x coordinates
+    unit_vector_y:      np.ndarray of shape (nd, shape0) (optional)
+        The local unit vectors y coordinates
+    unit_vector_z:      np.ndarray of shape (nd, shape0)  (optional)
+        The local unit vectors z coordinates
 
-# #############################################################################
-# #############################################################################
-#                           Mesh2DRect - bsplines
-# #############################################################################
+    """
 
+    # --------------------------------------
+    # check inputs (robust vs user mistakes)
 
-def _mesh2D_bsplines(key=None, lkeys=None, deg=None):
+    if timing:
+        t0 = dtm.datetime.now()     # DB
 
-    # key
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        allowed=lkeys,
+    (
+        # observation points
+        pts_x,
+        pts_y,
+        pts_z,
+        mask,
+        # polygons
+        apertures,
+        detectors,
+        # parameters
+        summed,
+        visibility,
+        return_vector,
+        timing,
+    ) = _calc_solidangle_apertures_check(
+        # observation points
+        pts_x=pts_x,
+        pts_y=pts_y,
+        pts_z=pts_z,
+        # polygons
+        apertures=apertures,
+        detectors=detectors,
+        # possible obstacles
+        config=config,
+        # parameters
+        summed=summed,
+        visibility=visibility,
+        return_vector=return_vector,
+        # output formatting
+        return_flat_pts=return_flat_pts,
+        return_flat_det=return_flat_det,
+        # options
+        timing=timing,
     )
 
-    # deg
-    deg = ds._generic_check._check_var(
-        deg, 'deg',
-        types=int,
-        default=2,
-        allowed=[0, 1, 2, 3],
+    # ----------------
+    # pre-format input
+
+    (
+        ndim0, shape0, mask,
+        pts_x, pts_y, pts_z,
+        ap_ind, ap_x, ap_y, ap_z,
+        ap_nin_x, ap_nin_y, ap_nin_z,
+        det_shape0, det_outline_x0, det_outline_x1,
+        det_cents_x, det_cents_y, det_cents_z,
+        det_nin_x, det_nin_y, det_nin_z,
+        det_e0_x, det_e0_y, det_e0_z,
+        det_e1_x, det_e1_y, det_e1_z,
+    ) = _calc_solidangle_apertures_prepare(
+        # observation points
+        pts_x=pts_x,
+        pts_y=pts_y,
+        pts_z=pts_z,
+        mask=mask,
+        # polygons
+        apertures=apertures,
+        detectors=detectors,
     )
 
-    # keybs
-    keybs = f'{key}-bs{deg}'
+    nd = det_cents_x.size
 
-    return key, keybs, deg
+    # Get kwdargs for LOS blocking
+    if config is not None:
+        kwdargs = {
+            k0: v0 for k0, v0 in config.get_kwdargs_LOS_isVis().items()
+            if 'eps' not in k0
+            and k0 not in ['ves_type', 'test', 'forbid', 'k']
+        }
+
+    if timing:
+        t1 = dtm.datetime.now()     # DB
+        dt1 = (t1 - t0).total_seconds()
+
+    # ------------------------------------------------
+    # compute (call appropriate version for each case)
+
+    if apertures is None:
+        # call fastest / simplest version without apertures
+        # (no computation / storing of unit vector)
+
+        solid_angle = _GG.compute_solid_angle_noapertures(
+            # pts as 1d arrays
+            pts_x=pts_x,
+            pts_y=pts_y,
+            pts_z=pts_z,
+            # detector polygons as 1d arrays
+            det_outline_x0=det_outline_x0,
+            det_outline_x1=det_outline_x1,
+            det_cents_x=det_cents_x,
+            det_cents_y=det_cents_y,
+            det_cents_z=det_cents_z,
+            det_norm_x=det_nin_x,
+            det_norm_y=det_nin_y,
+            det_norm_z=det_nin_z,
+            det_e0_x=det_e0_x,
+            det_e0_y=det_e0_y,
+            det_e0_z=det_e0_z,
+            det_e1_x=det_e1_x,
+            det_e1_y=det_e1_y,
+            det_e1_z=det_e1_z,
+        )
+
+    elif return_vector:
+        # call most complete version
+        # (computation + storing of unit vector)
+        (
+            solid_angle,
+            unit_vector_x, unit_vector_y, unit_vector_z,
+        ) = _GG.compute_solid_angle_apertures_unitvectors(
+            # pts as 1d arrays
+            pts_x=pts_x,
+            pts_y=pts_y,
+            pts_z=pts_z,
+            # detector polygons as 1d arrays
+            det_outline_x0=det_outline_x0,
+            det_outline_x1=det_outline_x1,
+            det_cents_x=det_cents_x,
+            det_cents_y=det_cents_y,
+            det_cents_z=det_cents_z,
+            det_norm_x=det_nin_x,
+            det_norm_y=det_nin_y,
+            det_norm_z=det_nin_z,
+            det_e0_x=det_e0_x,
+            det_e0_y=det_e0_y,
+            det_e0_z=det_e0_z,
+            det_e1_x=det_e1_x,
+            det_e1_y=det_e1_y,
+            det_e1_z=det_e1_z,
+            # apertures
+            ap_ind=ap_ind,
+            ap_x=ap_x,
+            ap_y=ap_y,
+            ap_z=ap_z,
+            ap_norm_x=ap_nin_x,
+            ap_norm_y=ap_nin_y,
+            ap_norm_z=ap_nin_z,
+        )
+
+        if visibility:
+            _visibility_unit_vectors(
+                # points
+                pts_x=pts_x,
+                pts_y=pts_y,
+                pts_z=pts_z,
+                # det
+                det_cents_x=det_cents_x,
+                det_cents_y=det_cents_y,
+                det_cents_z=det_cents_z,
+                det_nin_x=det_nin_x,
+                det_nin_y=det_nin_y,
+                det_nin_z=det_nin_z,
+                # results
+                solid_angle=solid_angle,
+                unit_vector_x=unit_vector_x,
+                unit_vector_y=unit_vector_y,
+                unit_vector_z=unit_vector_z,
+                **kwdargs,
+            )
+
+    elif visibility:
+        # call intermediate version
+        # (computation for visibility but no storing of unit vector)
+        solid_angle = _GG.compute_solid_angle_apertures_visibility(
+            # pts as 1d arrays
+            pts_x=pts_x,
+            pts_y=pts_y,
+            pts_z=pts_z,
+            # detector polygons as 1d arrays
+            det_outline_x0=det_outline_x0,
+            det_outline_x1=det_outline_x1,
+            det_cents_x=det_cents_x,
+            det_cents_y=det_cents_y,
+            det_cents_z=det_cents_z,
+            det_norm_x=det_nin_x,
+            det_norm_y=det_nin_y,
+            det_norm_z=det_nin_z,
+            det_e0_x=det_e0_x,
+            det_e0_y=det_e0_y,
+            det_e0_z=det_e0_z,
+            det_e1_x=det_e1_x,
+            det_e1_y=det_e1_y,
+            det_e1_z=det_e1_z,
+            # apertures
+            ap_ind=ap_ind,
+            ap_x=ap_x,
+            ap_y=ap_y,
+            ap_z=ap_z,
+            ap_norm_x=ap_nin_x,
+            ap_norm_y=ap_nin_y,
+            ap_norm_z=ap_nin_z,
+            # possible obstacles
+            **kwdargs,
+        )
+
+    else:
+        # call fastest / simplest version
+        # (no computation / storing of unit vector)
+
+        if summed is True:
+            solid_angle = _GG.compute_solid_angle_apertures_light_summed(
+                # pts as 1d arrays
+                pts_x=pts_x,
+                pts_y=pts_y,
+                pts_z=pts_z,
+                # detector polygons as 1d arrays
+                det_outline_x0=det_outline_x0,
+                det_outline_x1=det_outline_x1,
+                det_cents_x=det_cents_x,
+                det_cents_y=det_cents_y,
+                det_cents_z=det_cents_z,
+                det_norm_x=det_nin_x,
+                det_norm_y=det_nin_y,
+                det_norm_z=det_nin_z,
+                det_e0_x=det_e0_x,
+                det_e0_y=det_e0_y,
+                det_e0_z=det_e0_z,
+                det_e1_x=det_e1_x,
+                det_e1_y=det_e1_y,
+                det_e1_z=det_e1_z,
+                # apertures
+                ap_ind=ap_ind,
+                ap_x=ap_x,
+                ap_y=ap_y,
+                ap_z=ap_z,
+                ap_norm_x=ap_nin_x,
+                ap_norm_y=ap_nin_y,
+                ap_norm_z=ap_nin_z,
+            )
+
+        else:
+            solid_angle = _GG.compute_solid_angle_apertures_light(
+                # pts as 1d arrays
+                pts_x=pts_x,
+                pts_y=pts_y,
+                pts_z=pts_z,
+                # detector polygons as 1d arrays
+                det_outline_x0=det_outline_x0,
+                det_outline_x1=det_outline_x1,
+                det_cents_x=det_cents_x,
+                det_cents_y=det_cents_y,
+                det_cents_z=det_cents_z,
+                det_norm_x=det_nin_x,
+                det_norm_y=det_nin_y,
+                det_norm_z=det_nin_z,
+                det_e0_x=det_e0_x,
+                det_e0_y=det_e0_y,
+                det_e0_z=det_e0_z,
+                det_e1_x=det_e1_x,
+                det_e1_y=det_e1_y,
+                det_e1_z=det_e1_z,
+                # apertures
+                ap_ind=ap_ind,
+                ap_x=ap_x,
+                ap_y=ap_y,
+                ap_z=ap_z,
+                ap_norm_x=ap_nin_x,
+                ap_norm_y=ap_nin_y,
+                ap_norm_z=ap_nin_z,
+            )
+
+    if timing:
+        t2 = dtm.datetime.now()     # DB
+        dt2 = (t2 - t1).total_seconds()
+
+    # -------------
+    # format output
+
+    # solid_angle = 0 => nan for unit vectors
+    if return_vector:
+        i0 = solid_angle == 0
+        unit_vector_x[i0] = np.nan
+        unit_vector_y[i0] = np.nan
+        unit_vector_z[i0] = np.nan
+
+    # reshape if necessary
+    if summed is False:
+        shape = tuple(np.r_[det_shape0, shape0])
+        if mask is None:
+            if ndim0 > 1:
+                solid_angle = np.reshape(solid_angle, shape)
+                if return_vector:
+                    unit_vector_x = np.reshape(unit_vector_x, shape)
+                    unit_vector_y = np.reshape(unit_vector_y, shape)
+                    unit_vector_z = np.reshape(unit_vector_z, shape)
+        else:
+            sa = np.zeros(shape, dtype=float)
+            sa[:, mask] = solid_angle
+            if return_vector:
+                ux = np.fill(shape0, np.nan)
+                uy = np.fill(shape0, np.nan)
+                uz = np.fill(shape0, np.nan)
+                ux[:, mask] = unit_vector_x
+                uy[:, mask] = unit_vector_y
+                uz[:, mask] = unit_vector_z
+
+            # replace
+            solid_angle = sa
+            if return_vector:
+                unit_vector_x, unit_vector_y, unit_vector_z = ux, uy, uz
+
+    if timing:
+        t3 = dtm.datetime.now()     # DB
+        dt3 = (t3 - t2).total_seconds()
+
+    # ------
+    # return
+
+    if return_vector:
+        if timing:
+            return (
+                solid_angle, unit_vector_x, unit_vector_y, unit_vector_z,
+                dt1, dt2, dt3,
+            )
+        else:
+            return solid_angle, unit_vector_x, unit_vector_y, unit_vector_z
+
+    else:
+        if timing:
+            return solid_angle, dt1, dt2, dt3
+        else:
+            return solid_angle
```

### Comparing `tofu-1.6.5/tofu/data/_class1_plot.py` & `tofu-1.7.0/tofu/data/_class8_plot.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,1630 +3,1252 @@
 
 # Built-in
 
 
 # Common
 import numpy as np
 import matplotlib.pyplot as plt
-import matplotlib.gridspec as gridspec
-import matplotlib.colors as mcolors
 import datastock as ds
 
+
 # specific
 from . import _generic_check
-from . import _class1_compute as _compute
+from . import _generic_plot
 
 
-# #############################################################################
-# #############################################################################
-#                           plot mesh
-# #############################################################################
+# ##################################################################
+# ##################################################################
+#                           plot check
+# ##################################################################
 
 
-def _plot_mesh_check(
+def _plot_diagnostic_check(
     coll=None,
     key=None,
-    ind_knot=None,
-    ind_cent=None,
-    crop=None,
-    bck=None,
-    color=None,
-    dleg=None,
+    key_cam=None,
+    # parameters
+    vmin=None,
+    vmax=None,
+    alpha=None,
+    # figure
+    proj=None,
+    data=None,
+    units=None,
+    rocking_curve=None,
+    los_res=None,
+    # interactivity
+    color_dict=None,
+    nlos=None,
+    connect=None,
 ):
 
+    # -------
     # key
-    key = ds._generic_check._check_var(
-        key, 'key',
-        default=None,
-        types=str,
-        allowed=list(coll.dobj.get('mesh', {}).keys()),
-    )
-
-    # crop, bck
-    crop = ds._generic_check._check_var(crop, 'crop', default=True, types=bool)
-    bck = ds._generic_check._check_var(bck, 'bck', default=True, types=bool)
-
-    # ind_knot
-    if ind_knot is not None:
-        ind_knot = coll.select_mesh_elements(
-            key=key, ind=ind_knot, elements='knots',
-            returnas='data', return_neighbours=True, crop=crop,
-        )
-
-    # ind_cent
-    if ind_cent is not None:
-        ind_cent = coll.select_mesh_elements(
-            key=key, ind=ind_cent, elements='cents',
-            returnas='data', return_neighbours=True, crop=crop,
-        )
-
-    # color
-    if color is None:
-        color = 'k'
-    if not mcolors.is_color_like(color):
-        msg = (
-            "Arg color must be a valid matplotlib color identifier!\n"
-            f"Provided: {color}"
-        )
-        raise Exception(msg)
-
-    # dleg
-    defdleg = {
-        'bbox_to_anchor': (1.1, 1.),
-        'loc': 'upper left',
-        'frameon': True,
-    }
-    dleg = ds._generic_check._check_var(
-        dleg, 'dleg',
-        default=defdleg,
-        types=(bool, dict),
-    )
 
-    return key, ind_knot, ind_cent, crop, bck, color, dleg
-
-
-def _plot_mesh_prepare(
-    coll=None,
-    key=None,
-    crop=None,
-    bck=None,
-):
-
-    # --------
-    # prepare
+    # key
+    key, key_cam = coll.get_diagnostic_cam(key, key_cam)
+    is2d = coll.dobj['diagnostic'][key]['is2d']
+    # spectro = coll.dobj['diagnostic'][key]['spectro']
+
+    # if spectro:
+    #     assert len(key_cam) == 1
+    #     doptics = coll.dobj['diagnostic'][key]['doptics'][key_cam[0]]
+    #     kcryst = doptics['optics'][doptics['ispectro'][0]]
+    # else:
+    #    pass
+    #    kcryst = None
 
-    meshtype = coll.dobj['mesh'][key]['type']
+    # -------
+    # data
 
-    grid_bck = None
-    if meshtype == 'rect':
-        Rk, Zk = coll.dobj['mesh'][key]['knots']
-        R = coll.ddata[Rk]['data']
-        Z = coll.ddata[Zk]['data']
-
-        vert = np.array([
-            np.repeat(R, 3),
-            np.tile((Z[0], Z[-1], np.nan), R.size),
-        ])
-        hor = np.array([
-            np.tile((R[0], R[-1], np.nan), Z.size),
-            np.repeat(Z, 3),
+    defdata = 'etendue'
+    c0 = (
+        data is None
+        and all([
+            v0.get(defdata) is not None
+            for v0 in coll.dobj['diagnostic'][key]['doptics'].values()
         ])
+    )
+    if c0:
+        data = defdata
 
-        # --------
-        # compute
-
-        if crop is False or coll.dobj['mesh'][key]['crop'] is False:
-            grid = np.concatenate((vert, hor), axis=1)
-
-        else:
-
-            crop = coll.ddata[coll.dobj['mesh'][key]['crop']]['data']
-
-            grid = []
-            icropR = np.r_[range(R.size-1), R.size-2]
-            jcropZ = np.r_[range(Z.size-1), Z.size-2]
-
-            # vertical lines  TBC
-            for ii, ic in enumerate(icropR):
-                if np.any(crop[ic, :]):
-                    if ii in [0, R.size-1]:
-                        cropi = crop[ic, :]
-                    else:
-                        cropi = crop[ic, :] | crop[ic-1, :]
-                    lseg = []
-                    for jj, jc in enumerate(jcropZ):
-                        if jj == 0 and cropi[jc]:
-                            lseg.append(Z[jj])
-                        elif jj == Z.size-1 and cropi[jc]:
-                            lseg.append(Z[jj])
-                        elif cropi[jc] and not cropi[jc-1]:
-                            if len(lseg) > 0:
-                                lseg.append(np.nan)
-                            lseg.append(Z[jj])
-                        elif (not cropi[jc]) and cropi[jc-1]:
-                            lseg.append(Z[jc])
-                    grid.append(np.concatenate(
-                        (
-                            np.array([R[ii]*np.ones((len(lseg),)), lseg]),
-                            np.full((2, 1), np.nan)
-                        ),
-                        axis=1,
-                    ))
-
-            # horizontal lines
-            for jj, jc in enumerate(jcropZ):
-                if np.any(crop[:, jc]):
-                    if jj in [0, Z.size-1]:
-                        cropj = crop[:, jc]
-                    else:
-                        cropj = crop[:, jc] | crop[:, jc-1]
-                    lseg = []
-                    for ii, ic in enumerate(icropR):
-                        if ii in [0, R.size-1] and cropj[ic]:
-                            lseg.append(R[ii])
-                        elif cropj[ic] and not cropj[ic-1]:
-                            if len(lseg) > 0:
-                                lseg.append(np.nan)
-                            lseg.append(R[ii])
-                        elif (not cropj[ic]) and cropj[ic-1]:
-                            lseg.append(R[ic])
-                    grid.append(np.concatenate(
-                        (
-                            np.array([lseg, Z[jj]*np.ones((len(lseg),))]),
-                            np.full((2, 1), np.nan)
-                        ),
-                        axis=1,
-                    ))
-
-            grid = np.concatenate(tuple(grid), axis=1)
-
-            if bck is True:
-                grid_bck = np.concatenate((vert, hor), axis=1)
-
-    else:
-        kknots = coll.dobj['mesh'][key]['knots']
-        R = coll.ddata[kknots[0]]['data']
-        Z = coll.ddata[kknots[1]]['data']
-
-        indtri = coll.ddata[coll.dobj['mesh'][key]['ind']]['data']
-
-        # find unique segments from all triangles
-        segs = np.unique(
-            np.sort(np.concatenate(
-                (indtri[:, 0:2], indtri[:, 1:], indtri[:, ::2]),
-                axis=0,
-            )),
-            axis=0,
-        )
+    ddata, dref, units, static, daxis = coll.get_diagnostic_data(
+        key=key,
+        key_cam=key_cam,
+        data=data,
+        units=units,
+    )
 
-        # build long segments if possible
-        ind = np.ones((segs.shape[0],), dtype=bool)
-        ind[0] = False
-        lseg = [segs[0, :]]
-        last = segs[0, :]
-        while np.any(ind):
-            ii = segs[ind, 0] == last[-1]
-            if np.any(ii):
-                ii = ind.nonzero()[0][ii]
-                dR0 = R[last[1]] - R[last[0]]
-                dZ0 = Z[last[1]] - Z[last[0]]
-                dR = np.diff(R[segs[ii, :]], axis=1)[:, 0]
-                dZ = np.diff(Z[segs[ii, :]], axis=1)[:, 0]
-                norm0 = np.sqrt(dR0**2 + dZ0**2)
-                norm = np.sqrt(dR**2 + dZ**2)
-                sca = (dR0*dR + dZ0*dZ) / (norm0 * norm)
-                iwin = ii[np.argmax(sca)]
-                lseg.append([segs[iwin, 1]])
+    refz = None
+    if static is False:
+        lnr = [len(v0) for v0 in dref.values()]
+        refz = [v0[daxis[k0]] for k0, v0 in dref.items()]
 
-            else:
-                lseg.append([-1])
-                iwin = ind.nonzero()[0][0]
-                lseg.append(segs[iwin, :])
+        if len(set(lnr)) != 1:
+            msg = f"data '{data}' shall have the same ndims for all cameras!"
+            raise Exception(msg)
 
-            last = segs[iwin, :]
-            ind[iwin] = False
+        if len(set(refz)) != 1:
+            msg = f"data '{data}' shall have the same extra ref for all cameras"
+            raise Exception(msg)
 
-        lseg = np.concatenate(lseg)
-        grid = np.array([R[lseg], Z[lseg]])
-        grid[0, lseg == -1] = np.nan
+        refz = refz[0]
 
-    return grid, grid_bck
+    ylab = f"{data} ({units})"
 
+    # ----------
+    # vmin, vmax
 
-def _plot_mesh_prepare_polar_cont(
-    coll=None,
-    key=None,
-    k2d=None,
-    RR=None,
-    ZZ=None,
-    ind=None,
-    nn=None,
-):
+    if vmin is None and len(ddata) > 0:
+        vmin = np.nanmin([np.nanmin(v0) for v0 in ddata.values()])
 
-    # ---------------------
-    # sample mesh if needed
+    if vmax is None and len(ddata) > 0:
+        vmax = np.nanmax([np.nanmax(v0) for v0 in ddata.values()])
 
-    # ---------------------
-    # get map of rr / angle
+    # -----
+    # alpha
 
-    if callable(k2d):
+    alpha = ds._generic_check._check_var(
+        alpha, 'alpha',
+        types=float,
+        default=0.2,
+        sign='> 0.',
+    )
 
-        # check RR
-        if RR is None:
-            msg = (
-                "radius2d / angle2d are callable => provide RR and ZZ!"
-            )
-            raise Exception(msg)
+    # -----
+    # proj
 
-        # compute map
-        rr = k2d(RR, ZZ)[None, ...]
-        assert rr.ndim == RR.ndim + 1
-        reft = None
-        nt = 1
+    pall = ['cross', 'hor', '3d', 'camera', 'traces']
+    proj = _generic_plot._proj(
+        proj=proj,
+        pall=pall,
+    )
 
-        if nn is None:
-            nn = 50
+    if static is True:
+        proj = [pp for pp in proj if pp != 'traces']
 
-        # create vector
-        rad = np.linspace(np.nanmin(rr), np.nanmax(rr), nn)
+    # ----------
+    # los_res
 
-    else:
-        kn = coll.dobj[coll._which_mesh][key]['knots'][ind]
-        rad = coll.ddata[kn]['data']
-        kb2 = coll.ddata[k2d]['bsplines']
-
-        if RR is None:
-            km2 = coll.dobj['bsplines'][kb2]['mesh']
-            RR, ZZ = coll.get_sample_mesh(
-                key=km2,
-                res=None,
-                grid=True,
-                mode=None,
-                R=None,
-                Z=None,
-                DR=None,
-                DZ=None,
-                imshow=True,
-            )
+    los_res = ds._generic_check._check_var(
+        los_res, 'los_res',
+        types=float,
+        default=0.05,
+        sign='> 0.',
+    )
 
-        rr = coll.interpolate_profile2d(
-            key=k2d,
-            R=RR,
-            Z=ZZ,
-            grid=False,
-            return_params=False,
-        )[0]
-
-        refr2d = coll.ddata[k2d]['ref']
-        refbs = coll.dobj['bsplines'][kb2]['ref']
-        if refr2d == refbs:
-            reft = None
-            nt = 1
-            rr = rr[None, ...]
-        elif len(refr2d) == len(refbs) + 1 and refr2d[1:] == refbs:
-            reft = refr2d[0]
-            nt = coll.dref[reft]['size']
+    # -------
+    # color_dict
 
-    assert rr.shape[0] == nt
+    color_dict = _check_color_dict(color_dict)
 
-    # ----------------
-    # Compute contours
+    # -------
+    # nlos
 
-    contR, contZ = _compute._get_contours(
-        RR=RR,
-        ZZ=ZZ,
-        val=rr,
-        levels=rad,
+    nlos = ds._generic_check._check_var(
+        nlos, 'nlos',
+        types=int,
+        default=5,
     )
 
-    # refrad
-    refrad = coll.dobj[coll._which_mesh][key]['knots'][ind]
-
-    return contR, contZ, rad, reft, refrad, RR, ZZ
-
-
-def _plot_mesh_prepare_polar(
-    coll=None,
-    key=None,
-    # Necessary for callable radius2d
-    RR=None,
-    ZZ=None,
-):
+    # -------
+    # connect
 
-    # --------
-    # prepare
+    connect = ds._generic_check._check_var(
+        connect, 'connect',
+        types=bool,
+        default=True,
+    )
 
-    # create rectangular grid and compute radius at each point
-    k2d = coll.dobj[coll._which_mesh][key]['radius2d']
-    (
-        contRrad, contZrad,
-        rad, reft, refrad,
-        RR, ZZ,
-    ) = _plot_mesh_prepare_polar_cont(
-        coll=coll,
-        key=key,
-        k2d=k2d,
-        RR=RR,
-        ZZ=ZZ,
-        ind=0,
-        nn=None,        # nrad if k2d callable
+    return (
+        key,
+        key_cam,
+        is2d,
+        proj,
+        ddata,
+        dref,
+        static,
+        daxis,
+        refz,
+        vmin,
+        vmax,
+        alpha,
+        units,
+        los_res,
+        color_dict,
+        nlos,
+        ylab,
+        connect,
     )
 
-    # -----------
-    # contour of angle if angle not None
 
-    contRang, contZang, ang, refang = None, None, None, None
-    if len(coll.dobj[coll._which_mesh][key]['shape-c']) == 2:
-        # create rectangular grid and compute radius at each point
-        k2d = coll.dobj[coll._which_mesh][key]['angle2d']
-        (
-            contRang, contZang,
-            ang, _, refang,
-            _, _,
-        ) = _plot_mesh_prepare_polar_cont(
-            coll=coll,
-            key=key,
-            k2d=k2d,
-            RR=RR,
-            ZZ=ZZ,
-            ind=1,
-            nn=None,        # nang if k2d callable
-        )
+def _check_color_dict(color_dict=None):
+    if color_dict is None:
+        lc = ['r', 'g', 'b', 'm', 'c', 'y']
+        color_dict = {
+            'x': lc,
+            'y': lc,
+        }
+    return color_dict
 
-    return (
-        contRrad, contZrad, rad, refrad,
-        contRang, contZang, ang, refang,
-        reft,
-    )
+
+# ##################################################################
+# ##################################################################
+#                           plot main
+# ##################################################################
 
 
-def plot_mesh(
+def _plot_diagnostic(
     coll=None,
     key=None,
-    ind_knot=None,
-    ind_cent=None,
-    crop=None,
-    bck=None,
-    nmax=None,
-    color=None,
+    key_cam=None,
+    optics=None,
+    elements=None,
+    proj=None,
+    los_res=None,
+    # data plot
+    data=None,
+    units=None,
+    cmap=None,
+    vmin=None,
+    vmax=None,
+    keyZ=None,
+    alpha=None,
+    # config
+    plot_config=None,
+    # figure
     dax=None,
     dmargin=None,
     fs=None,
-    dleg=None,
+    wintit=None,
+    # interactivity
+    color_dict=None,
+    nlos=None,
+    dinc=None,
     connect=None,
 ):
-    """ Plot the desired mesh
-
-    rect and tri meshes are constant
-    polar meshes can vary in time
 
-    """
+    # ------------
+    # check inputs
 
-    # --------------
-    # check input
-
-    key, ind_knot, ind_cent, crop, bck, color, dleg = _plot_mesh_check(
+    (
+        key,
+        key_cam,
+        is2d,
+        proj,
+        ddata,
+        dref,
+        static,
+        daxis,
+        refz,
+        vmin,
+        vmax,
+        alpha,
+        units,
+        los_res,
+        color_dict,
+        nlos,
+        ylab,
+        connect,
+    ) = _plot_diagnostic_check(
         coll=coll,
         key=key,
-        ind_knot=ind_knot,
-        ind_cent=ind_cent,
-        crop=crop,
-        bck=bck,
-        color=color,
-        dleg=dleg,
+        key_cam=key_cam,
+        # parameters
+        vmin=vmin,
+        vmax=vmax,
+        alpha=alpha,
+        # figure
+        proj=proj,
+        data=data,
+        units=units,
+        los_res=los_res,
+        # interactivity
+        color_dict=color_dict,
+        nlos=nlos,
+        connect=connect,
     )
 
-    # ------------------------
-    # call appropriate routine
-
-    if coll.dobj[coll._which_mesh][key]['type'] in ['rect', 'tri']:
-        # time-fixed meshes
-        return _plot_mesh_recttri(
-            coll=coll,
-            key=key,
-            ind_knot=ind_knot,
-            ind_cent=ind_cent,
-            crop=crop,
-            bck=bck,
-            color=color,
-            dax=dax,
-            fs=fs,
-            dmargin=dmargin,
-            dleg=dleg,
-        )
+    # ------------
+    # prepare data
 
-    else:
-        # possibly time-varying mesh
-        return _plot_mesh_polar(
-            coll=coll,
-            key=key,
-            nmax=nmax,
-            color=color,
-            dax=dax,
-            fs=fs,
-            dmargin=dmargin,
-            dleg=dleg,
-            connect=connect,
-        )
-
-
-def _plot_mesh_recttri(
-    coll=None,
-    key=None,
-    ind_knot=None,
-    ind_cent=None,
-    crop=None,
-    bck=None,
-    color=None,
-    dax=None,
-    fs=None,
-    dmargin=None,
-    dleg=None,
-):
-
-    # --------------
-    #  Prepare data
-
-    grid, grid_bck = _plot_mesh_prepare(
-        coll=coll,
+    dplot = coll.get_diagnostic_dplot(
         key=key,
-        crop=crop,
-        bck=bck,
+        key_cam=key_cam,
+        optics=optics,
+        elements=elements,
     )
 
-    # --------------
-    # plot - prepare
-
-    if dax is None:
-
-        if dmargin is None:
-            dmargin = {
-                'left': 0.1, 'right': 0.9,
-                'bottom': 0.1, 'top': 0.9,
-                'hspace': 0.1, 'wspace': 0.1,
-            }
-
-        fig = plt.figure(figsize=fs)
-        gs = gridspec.GridSpec(ncols=1, nrows=1, **dmargin)
-        ax0 = fig.add_subplot(gs[0, 0], aspect='equal')
-        ax0.set_xlabel(f'R (m)')
-        ax0.set_ylabel(f'Z (m)')
-
-        dax = {'cross': ax0}
-
-    dax = _generic_check._check_dax(dax=dax, main='cross')
-
-    # --------------
-    # plot
-
-    kax = 'cross'
-    if dax.get(kax) is not None:
-        ax = dax[kax]['handle']
-
-        if grid_bck is not None and bck is True:
-            ax.plot(
-                grid_bck[0, :],
-                grid_bck[1, :],
-                ls='-',
-                lw=0.5,
-                color=color,
-                alpha=0.5,
-                label=key,
-            )
-
-        ax.plot(
-            grid[0, :],
-            grid[1, :],
-            color=color,
-            ls='-',
-            lw=1.,
-            label=key,
-        )
-
-        if ind_knot is not None:
-            ax.plot(
-                ind_knot[0][0],
-                ind_knot[0][1],
-                marker='o',
-                ms=8,
-                ls='None',
-                color=color,
-                label='knots',
-            )
-            ax.plot(
-                ind_knot[1][0, :, :],
-                ind_knot[1][1, :, :],
-                marker='x',
-                ms=4,
-                ls='None',
-                color=color,
-            )
-
-        if ind_cent is not None:
-            ax.plot(
-                ind_cent[0][0],
-                ind_cent[0][1],
-                marker='x',
-                ms=8,
-                ls='None',
-                color=color,
-                label='cents',
-            )
-            ax.plot(
-                ind_cent[1][0, :, :],
-                ind_cent[1][1, :, :],
-                marker='o',
-                ms=4,
-                ls='None',
-                color=color,
-            )
-
-    # --------------
-    # dleg
-
-    if dleg is not False:
-        for kax in dax.keys():
-            dax[kax]['handle'].legend(**dleg)
+    # -------------------------
+    # prepare los interactivity
 
-    return dax
+    # instanciate new Datastock
+    coll2 = coll.__class__()
 
+    # ---------------------
+    # prepare los and ddata
 
-def _plot_mesh_polar(
-    coll=None,
-    key=None,
-    npts=None,
-    nmax=None,
-    color=None,
-    dax=None,
-    fs=None,
-    dmargin=None,
-    dleg=None,
-    connect=None,
-):
+    # dcamref
+    dcamref, drefx, drefy = _prepare_dcamref(
+        coll=coll,
+        key_cam=key_cam,
+        is2d=is2d,
+    )
 
-    # --------------
-    #  Prepare data
+    # los
+    dlos_n, dref_los = _prepare_los(
+        coll=coll,
+        coll2=coll2,
+        dcamref=dcamref,
+        key_diag=key,
+        key_cam=key_cam,
+        los_res=los_res,
+    )
 
-    if nmax is None:
-        nmax = 2
+    # vos
+    dvos_n, dref_vos = _prepare_vos(
+        coll=coll,
+        coll2=coll2,
+        dcamref=dcamref,
+        key_diag=key,
+        key_cam=key_cam,
+        los_res=los_res,
+    )
 
-    (
-        contRrad, contZrad, rad, refrad,
-        contRang, contZang, ang, refang,
-        reft,
-    ) = _plot_mesh_prepare_polar(
+    # ddatax, ddatay
+    _, dkeyx, dkeyy, ddatax, ddatay, dextent = _prepare_datarefxy(
         coll=coll,
-        key=key,
+        coll2=coll2,
+        dcamref=dcamref,
+        drefx=drefx,
+        drefy=drefy,
+        ddata=ddata,
+        static=static,
+        is2d=is2d,
     )
-    refptsr = 'ptsr'
-    nt, nr, nptsr = contRrad.shape
-    if contRang is not None:
-        refptsa = 'ptsa'
-        _, nang, nptsa = contRang.shape
 
-    # --------------------
-    # Instanciate Plasma2D
+    # ---------------------
+    # prepare non-static
 
-    coll2 = coll.__class__()
+    if static is False and len(ddata) > 0:
 
-    # ref
-    coll2.add_ref(
-        key=reft,
-        size=nt,
-    )
-    reft = list(coll2.dref.keys())[0]
-    coll2.add_ref(
-        key=refrad,
-        size=nr,
-    )
-    coll2.add_ref(
-        key=refptsr,
-        size=nptsr,
-    )
+        k0 = key_cam[0]
+        keyz = coll.get_ref_vector(ref=refz)[3]
+        nz = ddata[k0].shape[daxis[k0]]
 
-    if contRang is not None:
-        coll2.add_ref(
-            key=refang,
-            size=nang,
-        )
-        coll2.add_ref(
-            key=refptsa,
-            size=nptsa,
+        keyz, zstr, dataz, dz2, labz = ds._plot_as_array._get_str_datadlab(
+            keyX=keyz, nx=nz, islogX=False, coll=coll,
         )
 
-    # data
-    coll2.add_data(
-        key='radius',
-        data=rad,
-        ref=(refrad,)
-    )
-    coll2.add_data(
-        key='contRrad',
-        data=contRrad,
-        ref=(reft, refrad, refptsr)
-    )
-    coll2.add_data(
-        key='contZrad',
-        data=contZrad,
-        ref=(reft, refrad, refptsr)
-    )
+        npts = 0
+        for k0 in key_cam:
+            npts = max(npts, ddata[k0].size)
 
-    if contRang is not None:
-        coll2.add_data(
-            key='angle',
-            data=ang,
-            ref=(refang,)
-        )
-        coll2.add_data(
-            key='contRang',
-            data=contRang,
-            ref=(reft, refang, refptsa)
-        )
-        coll2.add_data(
-            key='contZang',
-            data=contZang,
-            ref=(reft, refang, refptsa)
-        )
+        bck = 'envelop' if npts > 10000 else 'lines'
 
-    # -----
-    # plot
+        coll2.add_ref(key=refz, size=nz)
+        coll2.add_data(key=keyz, data=dataz, ref=refz)
 
-    if contRang is None:
-        return coll2.plot_as_mobile_lines(
-            keyX='contRrad',
-            keyY='contZrad',
-            key_time=reft,
-            key_chan='radius',
-            connect=connect,
-        )
+        # add camera data
+        for k0 in key_cam:
+            coll2.add_data(
+                key=f'{k0}_{data}',
+                data=ddata[k0].T,
+                ref=dref[k0][::-1],
+                units=units,
+            )
 
-    else:
+    # -----------------
+    # prepare figure
 
-        daxrad, dgrouprad = coll2.plot_as_mobile_lines(
-            keyX='contRrad',
-            keyY='contZrad',
-            key_time=reft,
-            key_chan='radius',
-            connect=False,
-            inplace=False,
-        )
+    if dax is None:
 
-        daxang, dgroupang = coll2.plot_as_mobile_lines(
-            keyX='contRang',
-            keyY='contZang',
-            key_time=reft,
-            key_chan='angle',
-            connect=False,
-            inplace=False,
+        dax = _generic_plot.get_dax_diag(
+            proj=proj,
+            dmargin=dmargin,
+            fs=fs,
+            wintit=wintit,
+            tit=key,
+            is2d=is2d,
+            key_cam=key_cam,
         )
 
-        # connect
-        if connect is False:
-            return (daxrad, daxang), (dgrouprad, dgroupang)
+    dax = _generic_check._check_dax(dax=dax, main=proj[0])
 
-        else:
-            daxrad.setup_interactivity(
-                kinter='inter0', dgroup=dgrouprad, dinc=None,
-            )
-            daxrad.disconnect_old()
-            daxrad.connect()
+    # -----------------
+    # plot static parts
 
-            daxang.setup_interactivity(
-                kinter='inter0', dgroup=dgroupang, dinc=None,
-            )
-            daxang.disconnect_old()
-            daxang.connect()
+    for k0, v0 in dplot.items():
 
-            daxrad.show_commands()
-            return daxrad, daxang
+        for k1, v1 in v0.items():
 
+            # cross
+            kax = 'cross'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
 
-# #############################################################################
-# #############################################################################
-#                           plot bspline
-# #############################################################################
-
-
-def _plot_bsplines_get_dRdZ(coll=None, km=None, meshtype=None):
-    # Get minimum distances
-
-    if meshtype == 'rect':
-        kR, kZ = coll.dobj['mesh'][km]['knots']
-        Rk = coll.ddata[kR]['data']
-        Zk = coll.ddata[kZ]['data']
-        dR = np.min(np.diff(Rk))
-        dZ = np.min(np.diff(Zk))
-
-    elif meshtype == 'tri':
-        indtri = coll.ddata[coll.dobj['mesh'][km]['ind']]['data']
-        kknots = coll.dobj['mesh'][km]['knots']
-        Rk = coll.ddata[kknots[0]]['data']
-        Zk = coll.ddata[kknots[1]]['data']
-        R = Rk[indtri]
-        Z = Zk[indtri]
-        dist = np.mean(np.array([
-            np.sqrt((R[:, 1] - R[:, 0])**2 + (Z[:, 1] - Z[:, 0])**2),
-            np.sqrt((R[:, 2] - R[:, 1])**2 + (Z[:, 2] - Z[:, 1])**2),
-            np.sqrt((R[:, 2] - R[:, 0])**2 + (Z[:, 2] - Z[:, 0])**2),
-        ]))
-        dR, dZ = dist, dist
+                if k1.startswith('v-'):
+                    ax.quiver(
+                        v1['r'],
+                        v1['z'],
+                        v1['ur'],
+                        v1['uz'],
+                        **v1.get('props', {}),
+                    )
 
-    else:
-        km2 = coll.dobj[coll._which_mesh][km]['submesh']
-        meshtype = coll.dobj[coll._which_mesh][km2]['type']
-        return _plot_bsplines_get_dRdZ(
-            coll=coll, km=km2, meshtype=meshtype,
-        )
+                else:
+                    ax.plot(
+                        v1['r'],
+                        v1['z'],
+                        **v1.get('props', {}),
+                    )
 
-    Rminmax = [Rk.min(), Rk.max()]
-    Zminmax = [Zk.min(), Zk.max()]
-    return dR, dZ, Rminmax, Zminmax
+            # hor
+            kax = 'hor'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+
+                if k1.startswith('v-'):
+                    ax.quiver(
+                        v1['x'],
+                        v1['y'],
+                        v1['ux'],
+                        v1['uy'],
+                        **v1.get('props', {}),
+                    )
 
+                else:
+                    ax.plot(
+                        v1['x'],
+                        v1['y'],
+                        **v1.get('props', {}),
+                    )
 
-def _plot_bspline_check(
-    coll=None,
-    key=None,
-    indbs=None,
-    indt=None,
-    knots=None,
-    cents=None,
-    plot_mesh=None,
-    cmap=None,
-    dleg=None,
-):
+            # 3d
+            kax = '3d'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+
+                if k1.startswith('v-'):
+                    ax.quiver(
+                        v1['x'],
+                        v1['y'],
+                        v1['z'],
+                        v1['ux'],
+                        v1['uy'],
+                        v1['uz'],
+                        **v1.get('props', {}),
+                    )
 
-    # key
-    lk = list(coll.dobj.get('bsplines', {}).keys())
-    key = ds._generic_check._check_var(
-        key, 'key',
-        default=None,
-        types=str,
-        allowed=lk,
-    )
-    keym0 = coll.dobj['bsplines'][key]['mesh']
-    mtype0 = coll.dobj[coll._which_mesh][keym0]['type']
-    if mtype0 == 'polar':
-        keym = coll.dobj[coll._which_mesh][keym0]['submesh']
-        mtype = coll.dobj[coll._which_mesh][keym]['type']
-    else:
-        keym = keym0
-        mtype = mtype0
+                else:
+                    ax.plot(
+                        v1['x'],
+                        v1['y'],
+                        v1['z'],
+                        **v1.get('props', {}),
+                    )
 
-    # knots, cents
-    knots = ds._generic_check._check_var(
-        knots, 'knots', default=True, types=bool,
-    )
-    cents = ds._generic_check._check_var(
-        cents, 'cents', default=True, types=bool,
-    )
+            # plotting of 2d camera contour
+            kax = f"{k0}_sig"
+            if is2d and k0 in key_cam and dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+                if k1 == 'o':
+                    ax.plot(
+                        v1['x0'],
+                        v1['x1'],
+                        **v1.get('props', {}),
+                    )
 
-    # ind_bspline
-    if indbs is not None:
-        indbs = coll.select_bsplines(
-            key=key,
-            ind=indbs,
-            returnas='ind',
-            return_knots=False,
-            return_cents=False,
-            crop=False,
-        )
+    # plot data
+    if static is True:
 
-    _, knotsi, centsi = coll.select_bsplines(
-        key=key,
-        ind=indbs,
-        returnas='data',
-        return_knots=True,
-        return_cents=True,
-        crop=False,
-    )
+        for k0 in key_cam:
+            kax = f'{k0}_sig'
+            if dax.get(kax) is not None:
+                if ddata is None or ddata.get(k0) is None:
+                    continue
+
+                ax = dax[kax]['handle']
+
+                if is2d:
+                    im = ax.imshow(
+                        ddata[k0].T,
+                        extent=dextent[k0],
+                        cmap=cmap,
+                        vmin=vmin,
+                        vmax=vmax,
+                        origin='lower',
+                        interpolation='nearest',
+                    )
+                    plt.colorbar(im, ax=ax)
 
-    # indt
-    nt = False
-    if mtype0 == 'polar':
-        radius2d = coll.dobj[coll._which_mesh][keym0]['radius2d']
-        r2d_reft = coll.get_time(key=radius2d)[2]
-        if r2d_reft is not None:
-            nt = coll.dref[r2d_reft]['size']
+                else:
+                    ax.plot(
+                        ddata[k0],
+                        c='k',
+                        ls='-',
+                        lw=1.,
+                        marker='.',
+                        ms=6,
+                    )
+                    ax.set_xlim(-1, ddata[k0].size)
+                    ax.set_ylabel(ylab)
+                    ax.set_title(k0, size=12, fontweight='bold')
+
+                    if vmin is not None:
+                        ax.set_ylim(bottom=vmin)
+                    if vmax is not None:
+                        ax.set_ylim(top=vmax)
 
-    if nt is False:
-        indt = None
     else:
-        if indt is None:
-            indt = 0
-        indt = np.atleast_1d(indt).ravel()[0]
-
-    # plot_mesh
-    plot_mesh = ds._generic_check._check_var(
-        plot_mesh, 'plot_mesh',
-        default=True,
-        types=bool,
-    )
+        # plot traces envelop
+        for k0 in key_cam:
 
-    # cmap
-    if cmap is None:
-        cmap = 'viridis'
-
-    # dleg
-    defdleg = {
-        'bbox_to_anchor': (1.1, 1.),
-        'loc': 'upper left',
-        'frameon': True,
-    }
-    dleg = ds._generic_check._check_var(
-        dleg, 'dleg',
-        default=defdleg,
-        types=(bool, dict),
-    )
+            kax = f'{k0}_trace'
+            if dax.get(kax) is None or ddata.get(k0) is None:
+                continue
+
+            ax = dax[kax]['handle']
+
+            if bck == 'lines':
+                shap = list(ddata[k0].shape)
+                shap[daxis[k0]] = 1
+                bckl = np.concatenate(
+                    (ddata[k0], np.full(shap, np.nan)),
+                    axis=daxis[k0],
+                )
+                bckl = np.swapaxes(bckl, daxis[k0], -1).ravel()
 
-    return (
-        key, keym0, keym, mtype0, mtype,
-        indbs, indt,
-        knots, cents, knotsi, centsi,
-        plot_mesh, cmap, dleg,
-    )
+                ax.plot(
+                    np.tile(np.r_[dataz, np.nan], int(np.prod(shap))),
+                    bckl,
+                    c=(0.8, 0.8, 0.8),
+                    ls='-',
+                    lw=1.,
+                    marker='None',
+                )
 
+            else:
+                tax = tuple([
+                    ii for ii in range(ddata[k0].ndim) if ii != daxis[k0]
+                ])
+
+                ax.fill_between(
+                    dataz,
+                    np.nanmin(ddata[k0], axis=tax),
+                    np.nanmax(ddata[k0], axis=tax),
+                    facecolor=(0.8, 0.8, 0.8, 0.8),
+                    edgecolor='None',
+                )
 
-def _plot_bspline_prepare(
-    coll=None,
-    # keys
-    key=None,
-    keym0=None,
-    keym=None,
-    mtype0=None,
-    mtype=None,
-    # indices
-    indbs=None,
-    indt=None,
-    # options
-    res=None,
-    knotsi=None,
-    centsi=None,
-    val_out=None,
-    nan0=None,
-):
+            if vmin is not None:
+                ax.set_ylim(bottom=vmin)
+            if vmax is not None:
+                ax.set_ylim(top=vmax)
 
-    # check input
-    deg = coll.dobj['bsplines'][key]['deg']
+    # ----------------
+    # define and set dgroup
 
-    # get dR, dZ
-    dR, dZ, _, _ = _plot_bsplines_get_dRdZ(
-        coll=coll, km=keym, meshtype=mtype,
-    )
+    if coll2 is not None:
+        dgroup = {
+            f'{k0}_x': {
+                'ref': [drefx[k0]],
+                'data': ['index'],
+                'nmax': nlos,
+            }
+            for k0 in key_cam
+        }
 
-    # resolution of sampling
-    if res is None:
-        if mtype == 'rect':
-            res_coef = 0.05
-        else:
-            res_coef = 0.25
-        res = [res_coef*dR, res_coef*dZ]
+        if is2d:
+            dgroup.update({
+                'y': {
+                    'ref': list(drefy.values()),
+                    'data': ['index'],
+                    'nmax': nlos,
+                },
+            })
+
+        if static is False is not None:
+            dgroup.update({
+                't': {
+                    'ref': [refz],
+                    'data': ['index'],
+                    'nmax': 1,
+                },
+            })
+
+    # ------------------
+    # plot mobile parts
+
+    for k0 in key_cam:
+
+        if dlos_n[k0] is not None:
+
+            nan_los = np.full((dlos_n[k0],), np.nan)
+            nan_vos = np.full((dvos_n[k0],), np.nan)
+
+            # cross
+            kax = 'cross'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+
+                _add_camera_los_cross(
+                    coll2=coll2,
+                    k0=k0,
+                    ax=ax,
+                    kax=kax,
+                    nlos=nlos,
+                    dref_los=dref_los,
+                    dref_vos=dref_vos,
+                    color_dict=color_dict,
+                    nan_los=nan_los,
+                    nan_vos=nan_vos,
+                    alpha=alpha,
+                )
 
-    # sampling domain
-    if mtype0 == 'polar':
-        DR = None
-        DZ = None
-    else:
-        knotsiR, knotsiZ = knotsi
-        DR = [np.nanmin(knotsiR) + dR*1.e-10, np.nanmax(knotsiR) - dR*1.e-10]
-        DZ = [np.nanmin(knotsiZ) + dZ*1.e-10, np.nanmax(knotsiZ) - dZ*1.e-10]
-
-    # sample
-    R, Z = coll.get_sample_mesh(
-        key=keym,
-        res=res,
-        DR=DR,
-        DZ=DZ,
-        mode='abs', grid=True, imshow=True,
-    )
+            # hor
+            kax = 'hor'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+
+                _add_camera_los_hor(
+                    coll2=coll2,
+                    k0=k0,
+                    ax=ax,
+                    kax=kax,
+                    nlos=nlos,
+                    dref_los=dref_los,
+                    dref_vos=dref_vos,
+                    color_dict=color_dict,
+                    nan_los=nan_los,
+                    nan_vos=nan_vos,
+                    alpha=alpha,
+                )
 
-    # bspline
-    bspline = coll.interpolate_profile2d(
-        key=key,
-        R=R,
-        Z=Z,
-        # coefs=coefs,
-        indt=indt,
-        indbs=indbs,
-        details=indbs is not None,
-        grid=False,
-        nan0=nan0,
-        val_out=val_out,
-        return_params=False,
-    )[0]
-
-    if indbs is None:
-        if bspline.ndim == R.ndim + 1:
-            assert bspline.shape[1:] == R.shape
-            bspline = bspline[0, ...]
-    else:
-        if bspline.ndim == R.ndim + 1:
-            assert bspline.shape[:-1] == R.shape
-            bspline = np.nansum(bspline, axis=-1)
-        elif bspline.ndim == R.ndim + 2:
-            assert bspline.shape[1:-1] == R.shape
-            bspline = np.nansum(bspline[0, ...], axis=-1)
-
-    if bspline.shape != R.shape:
-        import pdb; pdb.set_trace() # DB
-        pass
-
-    # extent
-    if mtype0 == 'polar':
-        extent = (
-            R.min(), R.max(),
-            Z.min(), Z.max(),
-        )
-    else:
-        extent = (
-            DR[0], DR[1],
-            DZ[0], DZ[1],
-        )
+            # 3d
+            kax = '3d'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
 
-    # interpolation
-    if deg == 0:
-        interp = 'nearest'
-    elif deg == 1:
-        interp = 'bilinear'
-    elif deg >= 2:
-        interp = 'bicubic'
+                for ii in range(nlos):
+                    l0, = ax.plot(
+                        nan_los,
+                        nan_los,
+                        nan_los,
+                        c=color_dict['x'][ii],
+                        ls='-',
+                        lw=1.,
+                    )
 
-    return bspline, extent, interp
+                    # add mobile
+                    kl0 = f'{k0}_los-3d-{ii}'
+                    # coll2.add_mobile(
+                    # key=kl0,
+                    # handle=l0,
+                    # refs=reflos,
+                    # data=['index', 'index', 'index'],
+                    # dtype=['xdata', 'ydata', 'zdata'],
+                    # axes=kax,
+                    # ind=ii,
+                    # )
+
+            # camera
+            kax = f'{k0}_sig'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+
+                _add_camera_vlines_marker(
+                    coll2=coll2,
+                    dax=dax,
+                    ax=ax,
+                    kax=kax,
+                    is2d=is2d,
+                    k0=k0,
+                    nlos=nlos,
+                    ddatax=ddatax,
+                    ddatay=ddatay,
+                    drefx=drefx,
+                    drefy=drefy,
+                    dkeyx=dkeyx,
+                    dkeyy=dkeyy,
+                    color_dict=color_dict,
+                )
 
+            # vline on traces
+            if static is False:
 
-def plot_bspline(
-    # ressources
-    coll=None,
-    # inputs
-    key=None,
-    indbs=None,
-    indt=None,
-    # parameters
-    knots=None,
-    cents=None,
-    res=None,
-    plot_mesh=None,
-    val_out=None,
-    nan0=None,
-    # plot-specific
-    cmap=None,
-    dax=None,
-    dmargin=None,
-    fs=None,
-    dleg=None,
-):
+                kax = f'{k0}_trace'
+                if dax.get(kax) is not None:
+                    ax = dax[kax]['handle']
+
+                    lv = ax.axvline(
+                        dataz[0],
+                        c='k',
+                        lw=1.,
+                        ls='-',
+                    )
 
-    # --------------
-    # check input
+                    kv = f'{k0}_zline'
+                    coll2.add_mobile(
+                        key=kv,
+                        handle=lv,
+                        refs=(refz,),
+                        data=[keyz],
+                        dtype=['xdata'],
+                        axes=kax,
+                        ind=0,
+                    )
 
-    (
-        key, keym0, keym, mtype0, mtype,
-        indbs, indt,
-        knots, cents, knotsi, centsi,
-        plot_mesh, cmap, dleg,
-    ) = _plot_bspline_check(
-        coll=coll,
-        key=key,
-        indbs=indbs,
-        indt=indt,
-        knots=knots,
-        cents=cents,
-        plot_mesh=plot_mesh,
-        cmap=cmap,
-        dleg=dleg,
-    )
+                    dax[kax].update(refx=[refz], datax=[keyz])
 
-    # --------------
-    #  Prepare data
+    # -------------------
+    # data if not static
 
-    bspline, extent, interp = _plot_bspline_prepare(
-        coll=coll,
-        key=key,
-        keym=keym,
-        mtype0=mtype0,
-        mtype=mtype,
-        indbs=indbs,
-        indt=indt,
-        knotsi=knotsi,
-        centsi=centsi,
-        res=res,
-        val_out=val_out,
-        nan0=nan0,
-    )
+    if static is False:
 
-    # --------------
-    # plot - prepare
+        for k0 in key_cam:
 
-    if dax is None:
+            # line/im plot on data
+            kax = f'{k0}_sig'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+
+                tax = tuple([
+                    ii for ii in range(ddata[k0].ndim) if ii != daxis[k0]
+                ])
+
+                if is2d:
+                    im = ax.imshow(
+                        np.take(ddata[k0], 0, axis=daxis[k0]).T,
+                        extent=dextent[k0],
+                        cmap=cmap,
+                        vmin=vmin,
+                        vmax=vmax,
+                        origin='lower',
+                        interpolation='nearest',
+                    )
+                    plt.colorbar(im, ax=ax)
 
-        if dmargin is None:
-            dmargin = {
-                'left': 0.1, 'right': 0.9,
-                'bottom': 0.1, 'top': 0.9,
-                'hspace': 0.1, 'wspace': 0.1,
-            }
+                    km = f'{k0}_{data}'
+                    coll2.add_mobile(
+                        key=km,
+                        handle=im,
+                        refs=((refz,),),
+                        data=[f'{k0}_{data}'],
+                        dtype='data',
+                        axes=kax,
+                        ind=0,
+                    )
 
-        fig = plt.figure(figsize=fs)
-        gs = gridspec.GridSpec(ncols=1, nrows=1, **dmargin)
-        ax0 = fig.add_subplot(gs[0, 0], aspect='equal')
-        ax0.set_xlabel(f'R (m)')
-        ax0.set_ylabel(f'Z (m)')
-
-        dax = {'cross': ax0}
-
-    dax = _generic_check._check_dax(dax=dax, main='cross')
-
-    # --------------
-    # plot
-
-    if plot_mesh is True:
-        keym = coll.dobj['bsplines'][key]['mesh']
-        if mtype0 == 'polar':
-            _ = coll.plot_mesh(key=keym, dleg=False)
-        else:
-            dax = coll.plot_mesh(key=keym, dax=dax, dleg=False)
+                else:
 
-    kax = 'cross'
-    if dax.get(kax) is not None:
-        ax = dax[kax]['handle']
-
-        ax.imshow(
-            bspline,
-            extent=extent,
-            interpolation=interp,
-            origin='lower',
-            aspect='equal',
-            cmap=cmap,
-            vmin=0.,
-            vmax=1.,
-        )
+                    l0, = ax.plot(
+                        np.take(ddata[k0], 0, axis=daxis[k0]),
+                        c='k',
+                        ls='-',
+                        lw=1.,
+                        marker='.',
+                        ms=6,
+                    )
+                    ax.set_xlim(-1, ddata[k0].size / nz)
+                    ax.set_ylabel(ylab)
+                    ax.set_title(k0, size=12, fontweight='bold')
+
+                    if vmin is not None:
+                        ax.set_ylim(bottom=vmin)
+                    if vmax is not None:
+                        ax.set_ylim(top=vmax)
+
+                    km = f'{k0}_{data}'
+                    coll2.add_mobile(
+                        key=km,
+                        handle=l0,
+                        refs=((refz,),),
+                        data=[f'{k0}_{data}'],
+                        dtype='ydata',
+                        axes=kax,
+                        ind=0,
+                    )
 
-        if mtype0 != 'polar':
-            if knots is not False:
-                ax.plot(
-                    knotsi[0].ravel(),
-                    knotsi[1].ravel(),
-                    marker='x',
-                    ms=6,
-                    ls='None',
-                    color='k',
-                )
+                    if vmin is not None:
+                        ax.set_ylim(bottom=vmin)
+                    if vmax is not None:
+                        ax.set_ylim(top=vmax)
+
+            # line plot on traces
+            kax = f'{k0}_trace'
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+
+                sli = tuple([
+                    slice(None) if ii == daxis[k0] else 0
+                    for ii in range(ddata[k0].ndim)
+                ])
 
-            if cents is not False:
-                ax.plot(
-                    centsi[0].ravel(),
-                    centsi[1].ravel(),
-                    marker='o',
-                    ms=6,
-                    ls='None',
-                    color='k',
-                )
+                for ii in range(nlos):
+                    l0, = ax.plot(
+                        dataz,
+                        ddata[k0][sli],
+                        c=color_dict['x'][ii],
+                        lw=1.,
+                        ls='-',
+                    )
+
+                    refi = dref_los[k0][0] if is2d else dref_los[k0][0]
+                    kv = f'{k0}_trace{ii}'
+                    coll2.add_mobile(
+                        key=kv,
+                        handle=l0,
+                        refs=(refi,),
+                        data=[f'{k0}_{data}'],
+                        dtype=['ydata'],
+                        axes=kax,
+                        ind=ii,
+                    )
 
-        ax.relim()
-        ax.autoscale()
+    # -------
+    # config
 
-        # --------------
-        # dleg
+    if plot_config.__class__.__name__ == 'Config':
 
-        if dleg is not False:
-            ax.legend(**dleg)
+        kax = 'cross'
+        if dax.get(kax) is not None:
+            ax = dax[kax]['handle']
+            plot_config.plot(lax=ax, proj=kax, dLeg=False)
+
+        kax = 'hor'
+        if dax.get(kax) is not None:
+            ax = dax[kax]['handle']
+            plot_config.plot(lax=ax, proj=kax, dLeg=False)
+
+    # -------
+    # connect
+
+    if coll2.dobj.get('mobile') is not None:
+        # add axes
+        for ii, kax in enumerate(dax.keys()):
+            harmonize = ii == len(dax.keys()) - 1
+            coll2.add_axes(key=kax, harmonize=harmonize, **dax[kax])
 
-    return dax
+        # connect
+        if connect is True:
+            coll2.setup_interactivity(
+                kinter='inter0',
+                dgroup=dgroup,
+                dinc=dinc,
+            )
+            coll2.disconnect_old()
+            coll2.connect()
+
+            coll2.show_commands()
+            return coll2
+        else:
+            return coll2, dgroup
+    else:
+        return dax
 
 
-# #############################################################################
-# #############################################################################
-#                           plot profile2d
-# #############################################################################
+# ##################################################################
+# ##################################################################
+#                       Prepare
+# ##################################################################
 
 
-def _plot_profile2d_check(
+def _prepare_dcamref(
     coll=None,
-    key=None,
-    cmap=None,
-    dcolorbar=None,
-    dleg=None,
+    key_cam=None,
+    is2d=None,
 ):
-
-    # key
-    dk = coll.get_profiles2d()
-    key = ds._generic_check._check_var(
-        key, 'key', types=str, allowed=list(dk.keys())
-    )
-    keybs = dk[key]
-    refbs = coll.dobj['bsplines'][keybs]['ref']
-    keym = coll.dobj['bsplines'][keybs]['mesh']
-    mtype = coll.dobj[coll._which_mesh][keym]['type']
-
-    # cmap
-    if cmap is None:
-        cmap = 'viridis'
-
-    # dcolorbar
-    defdcolorbar = {
-        # 'location': 'right',
-        'fraction': 0.15,
-        'orientation': 'vertical',
-    }
-    dcolorbar = ds._generic_check._check_var(
-        dcolorbar, 'dcolorbar',
-        default=defdcolorbar,
-        types=dict,
-    )
-
-    # dleg
-    defdleg = {
-        'bbox_to_anchor': (1.1, 1.),
-        'loc': 'upper left',
-        'frameon': True,
+    dcamref = {
+        k0: coll.dobj['camera'][k0]['dgeom']['ref']
+        for k0 in key_cam
     }
-    dleg = ds._generic_check._check_var(
-        dleg, 'dleg',
-        default=defdleg,
-        types=(bool, dict),
-    )
+    drefx = {k0: v0[0] for k0, v0 in dcamref.items()}
 
-    # polar1d
-    polar1d = False
-    if mtype  == 'polar':
-        if coll.dobj['bsplines'][keybs]['class'].knotsa is None:
-            polar1d = True
-        elif len(coll.dobj['bsplines'][keybs]['ref']) == 2:
-            polar1d = True
-        else:
-            apbs = coll.dobj['bsplines'][keybs]['class'].apex_per_bs_a
-            if np.sum([aa is not None for aa in apbs]) == 1:
-                polar1d = True
+    if is2d:
+        drefy = {k0: v0[1] for k0, v0 in dcamref.items()}
+    else:
+        drefy = None
 
-    return key, keybs, keym, cmap, dcolorbar, dleg, polar1d
+    return dcamref, drefx, drefy
 
 
-def _plot_profiles2d_prepare(
+def _prepare_los(
     coll=None,
-    key=None,
-    keybs=None,
-    keym=None,
-    coefs=None,
-    indt=None,
-    res=None,
-    mtype=None,
+    coll2=None,
+    dcamref=None,
+    key_diag=None,
+    key_cam=None,
+    los_res=None,
 ):
 
-    # check input
-    deg = coll.dobj['bsplines'][keybs]['deg']
+    # -----------------
+    # create dlos, dvos
 
-    # get dR, dZ
-    dR, dZ, Rminmax, Zminmax = _plot_bsplines_get_dRdZ(
-        coll=coll, km=keym, meshtype=mtype,
-    )
+    # dlos
+    dlos_n = {
+        k0: coll.dobj['diagnostic'][key_diag]['doptics'][k0]['los']
+        for k0 in key_cam
+    }
+    dref_los = {}
 
-    if res is None:
-        res_coef = 0.2
-        res = [res_coef*dR, res_coef*dZ]
+    # -------------
+    # los
 
-    # compute
-    coll2 = coll.interpolate_profile2d(
-        key=key,
-        R=None,
-        Z=None,
-        coefs=coefs,
-        indt=indt,
-        res=res,
-        details=False,
-        nan0=True,
-        imshow=False,
-        return_params=False,
-        store=True,
-        inplace=False,
-    )
+    # los on cams
+    for k0, v0 in dcamref.items():
+        for rr in v0:
+            coll2.add_ref(key=rr, size=coll.dref[rr]['size'])
+
+        # los
+        if dlos_n[k0] is not None:
+            los_x, los_y, los_z = coll.sample_rays(
+                key=dlos_n[k0],
+                res=los_res,
+                mode='rel',
+                concatenate=False,
+            )
+            los_r = np.hypot(los_x, los_y)
+            reflos = coll.dobj['rays'][dlos_n[k0]]['ref']
+            dref_los[k0] = (reflos[1:], reflos[1:])
 
-    keymap = [k0 for k0, v0 in coll2.ddata.items() if v0['data'].ndim > 1][0]
-    ndim = coll2.ddata[keymap]['data'].ndim
+            if reflos[0] not in coll2.dref.keys():
+                coll2.add_ref(key=reflos[0], size=los_x.shape[0])
 
-    refmap = coll2.ddata[keymap]['ref']
-    dkeys = {
-        'key': keymap,
-        'keyX': coll2.get_ref_vector(key=keymap, ref=refmap[-2])[3],
-        'keyY': coll2.get_ref_vector(key=keymap, ref=refmap[-1])[3],
-        'keyZ': None,
-    }
-    if ndim == 3:
-        keyZ = coll2.get_ref_vector(key=keymap, ref=refmap[0])[3]
-        import datastock as ds
-        uniform = ds._plot_as_array._check_uniform_lin(
-            k0=keyZ, ddata=coll2.ddata,
-        )
-        if not uniform:
-            keyZ = None
+            coll2.add_data(key=f'{k0}_los_x', data=los_x, ref=reflos)
+            coll2.add_data(key=f'{k0}_los_y', data=los_y, ref=reflos)
+            coll2.add_data(key=f'{k0}_los_z', data=los_z, ref=reflos)
+            coll2.add_data(key=f'{k0}_los_r', data=los_r, ref=reflos)
 
-    if deg == 0:
-        interp = 'nearest'
-    elif deg == 1:
-        interp = 'bilinear'
-    elif deg >= 2:
-        interp = 'bicubic'
-
-    # radial of polar
-    if mtype == 'polar':
-        # lcol
-        lcol = ['k', 'r', 'b', 'g', 'm', 'c', 'y']
+            # store x, y, z
+            dlos_n[k0] = los_x.shape[0]
 
-    else:
-        lcol = None
-
-    return coll2, dkeys, interp, lcol
+    return dlos_n, dref_los
 
 
-def _plot_profile2d_polar_add_radial(
+def _prepare_vos(
     coll=None,
-    key=None,
-    keym=None,
-    keybs=None,
-    dax=None,
+    coll2=None,
+    dcamref=None,
+    key_diag=None,
+    key_cam=None,
+    los_res=None,
 ):
 
-    # key to radius
-    kr2d = coll.dobj[coll._which_mesh][keym]['radius2d']
-    kr = coll.dobj[coll._which_mesh][keym]['knots'][0]
-    rr = coll.ddata[kr]['data']
-    rad = np.linspace(rr[0], rr[-1], rr.size*20)
-
-    # get angle if any
-    clas = coll.dobj['bsplines'][keybs]['class']
-    if clas.knotsa is None:
-        angle = None
-    elif len(clas.shapebs) == 2:
-        ka = coll.dobj['bsplines'][keybs]['apex'][1]
-        angle = coll.ddata[ka]['data']
-    elif np.sum(clas.nbs_a_per_r > 1) == 1:
-        i0 = (clas.nbs_a_per_r > 1).nonzero()[0][0]
-        angle = coll.dobj['bsplines'][keybs]['class'].apex_per_bs_a[i0]
-    else:
-        pass
+    doptics = coll.dobj['diagnostic'][key_diag]['doptics']
+    if doptics[key_cam[0]].get('vos_pcross') is None:
+        return None, None
+
+    # -----------------
+    # create dlos, dvos
+
+    # dvos
+    dvos_n = {
+        k0: {'pc': doptics[k0]['vos_pcross']}
+        for k0 in key_cam
+    }
+    dref_vos = {}
 
-    if angle is None:
-        radmap = rad
-        anglemap = angle
-    else:
-        radmap = np.repeat(rad[:, None], angle.size, axis=1)
-        anglemap = np.repeat(angle[None, :], rad.size, axis=0)
+    # ----
+    # vos
 
-    # reft
-    reft, keyt, _, dind = coll.get_time_common(keys=[key, kr2d])[1:]
+    # vos on cams
+    for k0, v0 in dcamref.items():
 
-    # radial total profile
-    radial, t_radial, _ = coll.interpolate_profile2d(
-        key=key,
-        radius=radmap,
-        angle=anglemap,
-        grid=False,
-        t=keyt,
-    )
+        krxy = f'{k0}_xy2'
+        coll2.add_ref(key=krxy, size=2)
 
-    if reft is not None and radial.ndim == radmap.ndim:
-        radial = np.repeat(radial[None, ...], t_radial.size, axis=0)
+        # vos
+        if dvos_n[k0]['pc'] is not None:
 
-    # details for purely-radial cases
-    if clas.knotsa is None:
-        radial_details, t_radial, _ = coll.interpolate_profile2d(
-            key=keybs,
-            radius=rad,
-            angle=None,
-            grid=False,
-            details=True,
-        )
+            pc0 = coll.ddata[dvos_n[k0]['pc'][0]]['data']
+            pc1 = coll.ddata[dvos_n[k0]['pc'][1]]['data']
+            pcref = coll.ddata[dvos_n[k0]['pc'][0]]['ref']
+            if doptics[k0].get('vos_phor') is not None:
+                ph0 = coll.ddata[doptics[k0]['vos_phor'][0]]['data']
+                ph1 = coll.ddata[doptics[k0]['vos_phor'][1]]['data']
+                phref = coll.ddata[doptics[k0]['vos_phor'][0]]['ref']
 
-        if reft is None:
-            radial_details = radial_details * coll.ddata[key]['data'][None, :]
-            refdet = ('nradius',)
-        else:
-            refdet = (reft, 'nradius')
-            if reft == coll.get_time(key)[2]:
-                radial_details = (
-                    radial_details[None, :, :]
-                    * coll.ddata[key]['data'][:, None, :]
-                )
-            elif key in dind.keys():
-                radial_details = (
-                    radial_details[None, :, :]
-                    * coll.ddata[key]['data'][dind[key]['ind'], None, :]
-                )
+            if pcref[0] not in coll2.dref.keys():
+                coll2.add_ref(key=pcref[0], size=pc0.shape[0])
 
-        nbs = radial_details.shape[-1]
+            dref_vos[k0] = (pcref[1:],)
 
-    # add to dax
-    dax.add_ref(key='nradius', size=rad.size)
-    if angle is not None:
-        dax.add_ref(key='nangle', size=angle.size)
-
-    if reft is not None:
-        assert radial.ndim > 1 and radial.shape[0] > 1
-        # if angle is not None:
-            # ref = (reft, 'nangle', 'nradius')
-        # else:
-        ref = (reft, 'nradius')
-    else:
-        # if angle is not None:
-            # ref = ('nangle', 'nradius')
-        # else:
-        ref = 'nradius'
-
-    # add to ddata
-    kradius = 'radius'
-    dax.add_data(key=kradius, data=rad, ref='nradius')
-    if angle is None:
-        lk = ['radial']
-        dax.add_data(key=lk[0], data=radial, ref=ref)
-        lkdet = [f'radial-detail-{ii}' for ii in range(nbs)]
-        for ii in range(nbs):
-            dax.add_data(
-                key=lkdet[ii], data=radial_details[..., ii], ref=refdet,
-            )
+            ref = tuple(list(pcref[::-1]) + [krxy])
+            pcxy = np.array([pc0, pc1]).T
+            coll2.add_data(key=f'{k0}_vos_cross', data=pcxy, ref=ref)
+            if doptics[k0].get('vos_phor') is not None:
+                ref = tuple(list(phref[::-1]) + [krxy])
+                phxy = np.array([ph0, ph1]).T
+                coll2.add_data(key=f'{k0}_vos_hor', data=phxy, ref=ref)
 
-    else:
-        kangle = 'angle'
-        dax.add_data(key=kangle, data=angle, ref='nangle')
-        lkdet = None
-        lk = [f'radial-{ii}' for ii in range(angle.size)]
-        if reft is None:
-            for ii in range(angle.size):
-                dax.add_data(key=lk[ii], data=radial[:, ii], ref=ref)
-        else:
-            for ii in range(angle.size):
-                dax.add_data(key=lk[ii], data=radial[:, :, ii], ref=ref)
+            # store
+            dvos_n[k0] = pc0.shape[0]
 
-    return kradius, lk, lkdet, reft
+    return dvos_n, dref_vos
 
 
-def plot_profile2d(
-    # ressources
+def _prepare_datarefxy(
     coll=None,
-    # inputs
-    key=None,
-    # parameters
-    coefs=None,
-    indt=None,
-    res=None,
-    # figure
-    vmin=None,
-    vmax=None,
-    cmap=None,
-    dax=None,
-    dmargin=None,
-    fs=None,
-    dcolorbar=None,
-    dleg=None,
-    # interactivity
-    dinc=None,
-    connect=None,
+    coll2=None,
+    dcamref=None,
+    drefx=None,
+    drefy=None,
+    ddata=None,
+    static=None,
+    is2d=None,
 ):
+    # prepare dict
+    dkeyx, ddatax = {}, {}
+    if is2d:
+        dkeyy, ddatay, dextent = {}, {}, {}
+    else:
+        dkeyy, ddatay, dextent = None, None, None
 
-    # --------------
-    # check input
+    # loop on cams
+    for k0, v0 in dcamref.items():
 
-    if connect is None:
-        connect = True
+        # datax, datay
+        if ddata is not None:
+            if is2d:
+                dkeyx[k0], dkeyy[k0] = coll.dobj['camera'][k0]['dgeom']['cents']
 
-    (
-        key, keybs, keym, cmap, dcolorbar, dleg, polar1d,
-    ) = _plot_profile2d_check(
-        coll=coll,
-        key=key,
-        cmap=cmap,
-        dcolorbar=dcolorbar,
-        dleg=dleg,
-    )
-    mtype = coll.dobj[coll._which_mesh][keym]['type']
-    hastime = coll.get_time(key=key)[0]
+                ddatax[k0] = coll.ddata[dkeyx[k0]]['data']
+                ddatay[k0] = coll.ddata[dkeyy[k0]]['data']
 
-    # --------------
-    #  Prepare data
+                coll2.add_data(key=dkeyx[k0], data=ddatax[k0], ref=drefx[k0])
+                coll2.add_data(key=dkeyy[k0], data=ddatay[k0], ref=drefy[k0])
+            else:
+                dkeyx[k0] = f'{k0}_i0'
+                ddatax[k0] = np.arange(0, coll.dref[drefx[k0]]['size'])
+                coll2.add_data(key=dkeyx[k0], data=ddatax[k0], ref=drefx[k0])
 
-    (
-        coll2, dkeys, interp, lcol,
-    ) = _plot_profiles2d_prepare(
-        coll=coll,
-        key=key,
-        keybs=keybs,
-        keym=keym,
-        coefs=coefs,
-        indt=indt,
-        res=res,
-        mtype=mtype,
-    )
+            # -------------------------
+            # extent
 
-    # ---------------
-    # call right function
+            reft = None
+            if is2d:
+                if ddatax[k0].size == 1:
+                    ddx = coll.ddata[coll.dobj['camera'][k0]['dgeom']['outline'][0]]['data']
+                    ddx = np.max(ddx) - np.min(ddx)
+                else:
+                    ddx = ddatax[k0][1] - ddatax[k0][0]
+                if ddatay[k0].size == 1:
+                    ddy = coll.ddata[coll.dobj['camera'][k0]['dgeom']['outline'][1]]['data']
+                    ddy = np.max(ddy) - np.min(ddy)
+                else:
+                    ddy = ddatay[k0][1] - ddatay[k0][0]
 
-    if mtype in ['rect', 'tri']:
-        return coll2.plot_as_array(
-            vmin=vmin,
-            vmax=vmax,
-            cmap=cmap,
-            dax=dax,
-            dmargin=dmargin,
-            fs=fs,
-            dcolorbar=dcolorbar,
-            dleg=dleg,
-            interp=interp,
-            connect=connect,
-            **dkeys,
-        )
+                dextent[k0] = (
+                    ddatax[k0][0] - 0.5*ddx,
+                    ddatax[k0][-1] + 0.5*ddx,
+                    ddatay[k0][0] - 0.5*ddy,
+                    ddatay[k0][-1] + 0.5*ddy,
+                )
 
-    else:
+    return reft, dkeyx, dkeyy, ddatax, ddatay, dextent
 
-        if dax is None:
-            dax = _plot_profile2d_polar_create_axes(
-                fs=fs,
-                dmargin=dmargin,
-            )
 
-        dax, dgroup = coll2.plot_as_array(
-            vmin=vmin,
-            vmax=vmax,
-            cmap=cmap,
-            dax=dax,
-            dmargin=dmargin,
-            fs=fs,
-            dcolorbar=dcolorbar,
-            dleg=dleg,
-            connect=False,
-            interp=interp,
-            label=True,
-            **dkeys,
-        )
+# ##################################################################
+# ##################################################################
+#                       add mobile
+# ##################################################################
+
+
+def _add_camera_los_cross(
+    coll2=None,
+    k0=None,
+    ax=None,
+    kax=None,
+    nlos=None,
+    dref_los=None,
+    dref_vos=None,
+    color_dict=None,
+    nan_los=None,
+    nan_vos=None,
+    alpha=None,
+):
+
+    for ii in range(nlos):
 
-        # ------------------
-        # add radial profile to dax
+        # ------
+        # los
 
-        kradius, lkradial, lkdet, reft = _plot_profile2d_polar_add_radial(
-            coll=coll,
-            key=key,
-            keym=keym,
-            keybs=keybs,
-            dax=dax,
+        l0, = ax.plot(
+            nan_los,
+            nan_los,
+            c=color_dict['x'][ii],
+            ls='-',
+            lw=1.,
         )
 
+        # add mobile
+        kl0 = f'{k0}_los_cross{ii}'
+        coll2.add_mobile(
+            key=kl0,
+            handle=l0,
+            refs=dref_los[k0],
+            data=[f'{k0}_los_r', f'{k0}_los_z'],
+            dtype=['xdata', 'ydata'],
+            axes=kax,
+            ind=ii,
+        )
+
+        # ------
+        # vos
+
+        l0, = ax.fill(
+            nan_vos,
+            nan_vos,
+            fc=color_dict['x'][ii],
+            alpha=alpha,
+            ls='None',
+            lw=0.,
+        )
+
+        # add mobile
+        kl0 = f'{k0}_vos_cross{ii}'
+        coll2.add_mobile(
+            key=kl0,
+            handle=l0,
+            refs=dref_vos[k0],
+            data=[f'{k0}_vos_cross'],
+            dtype=['xy'],
+            axes=kax,
+            ind=ii,
+        )
 
-        assert (reft is not None) == ('Z' in dgroup.keys())
-        if reft is not None and reft not in dgroup['Z']['ref']:
-            dgroup['Z']['ref'].append(reft)
-            dgroup['Z']['data'].append('index')
-
-        # ------------------
-        # add radial profile
-
-        kax = 'radial'
-        if dax.dax.get(kax) is not None:
-            ax = dax.dax[kax]['handle']
-            for ii in range(len(lkradial)):
 
-                if reft is None:
-                    l0, = ax.plot(
-                        dax.ddata[kradius]['data'],
-                        dax.ddata[lkradial[ii]]['data'],
-                        c=lcol[ii],
-                        ls='-',
-                        lw=2,
-                    )
-                else:
-                    l0, = ax.plot(
-                        dax.ddata[kradius]['data'],
-                        dax.ddata[lkradial[ii]]['data'][0, :],
-                        c=lcol[ii],
-                        ls='-',
-                        lw=2,
-                    )
-
-                    kl = f"radial{ii}"
-                    dax.add_mobile(
-                        key=kl,
-                        handle=l0,
-                        refs=(reft,),
-                        data=[lkradial[ii]],
-                        dtype=['ydata'],
-                        axes=kax,
-                        ind=0,
-                    )
+def _add_camera_los_hor(
+    coll2=None,
+    k0=None,
+    ax=None,
+    kax=None,
+    nlos=None,
+    dref_los=None,
+    dref_vos=None,
+    color_dict=None,
+    nan_los=None,
+    nan_vos=None,
+    alpha=None,
+):
 
-            if lkdet is not None:
-                for ii in range(len(lkdet)):
-                    if reft is None:
-                        l0, = ax.plot(
-                            dax.ddata[kradius]['data'],
-                            dax.ddata[lkdet[ii]]['data'],
-                            ls='-',
-                            lw=1,
-                        )
-                    else:
-                        l0, = ax.plot(
-                            dax.ddata[kradius]['data'],
-                            dax.ddata[lkdet[ii]]['data'][0, :],
-                            ls='-',
-                            lw=1,
-                        )
-
-                        kl = f"radial_det{ii}"
-                        dax.add_mobile(
-                            key=kl,
-                            handle=l0,
-                            refs=(reft,),
-                            data=[lkdet[ii]],
-                            dtype=['ydata'],
-                            axes=kax,
-                            ind=0,
-                        )
-
-            ax.set_xlim(
-                dax.ddata[kradius]['data'].min(),
-                dax.ddata[kradius]['data'].max(),
-            )
+    for ii in range(nlos):
 
-            if vmin is not None:
-                ax.set_ylim(bottom=vmin)
-            if vmax is not None:
-                ax.set_ylim(top=vmax)
+        # ------
+        # los
 
-        # connect
-        if connect is True:
-            dax.setup_interactivity(kinter='inter0', dgroup=dgroup, dinc=dinc)
-            dax.disconnect_old()
-            dax.connect()
+        l0, = ax.plot(
+            nan_los,
+            nan_los,
+            c=color_dict['x'][ii],
+            ls='-',
+            lw=1.,
+        )
 
-            dax.show_commands()
-            return dax
-        else:
-            return dax, dgroup
+        # add mobile
+        kl0 = f'{k0}_los_hor{ii}'
+        coll2.add_mobile(
+            key=kl0,
+            handle=l0,
+            refs=dref_los[k0],
+            data=[f'{k0}_los_x', f'{k0}_los_y'],
+            dtype=['xdata', 'ydata'],
+            axes=kax,
+            ind=ii,
+        )
+
+        # ------
+        # vos
+
+        if f'{k0}_vos_hor' in coll2.ddata.keys():
+
+            l0, = ax.fill(
+                nan_vos,
+                nan_vos,
+                fc=color_dict['x'][ii],
+                alpha=alpha,
+                ls='None',
+                lw=0.,
+            )
 
+            # add mobile
+            kl0 = f'{k0}_vos_hor{ii}'
+            coll2.add_mobile(
+                key=kl0,
+                handle=l0,
+                refs=dref_vos[k0],
+                data=[f'{k0}_vos_hor'],
+                dtype=['xy'],
+                axes=kax,
+                ind=ii,
+            )
 
 
-def _plot_profile2d_polar_create_axes(
-    fs=None,
-    dmargin=None,
+def _add_camera_vlines_marker(
+    coll2=None,
+    dax=None,
+    ax=None,
+    kax=None,
+    is2d=None,
+    k0=None,
+    nlos=None,
+    ddatax=None,
+    ddatay=None,
+    drefx=None,
+    drefy=None,
+    dkeyx=None,
+    dkeyy=None,
+    color_dict=None,
+    suffix=None,
 ):
 
-    if fs is None:
-        fs = (15, 9)
+    if suffix is None:
+        suffix = ''
 
-    if dmargin is None:
-        dmargin = {
-            'left': 0.05, 'right': 0.95,
-            'bottom': 0.05, 'top': 0.95,
-            'hspace': 0.4, 'wspace': 0.3,
-        }
+    if is2d:
+        for ii in range(nlos):
+            mi, = ax.plot(
+                ddatax[k0][0:1],
+                ddatay[k0][0:1],
+                marker='s',
+                ms=6,
+                markeredgecolor=color_dict['x'][ii],
+                markerfacecolor='None',
+            )
+
+            km = f'{k0}_m{ii:02.0f}{suffix}'
+            coll2.add_mobile(
+                key=km,
+                handle=mi,
+                refs=[drefx[k0], drefy[k0]],
+                data=[dkeyx[k0], dkeyy[k0]],
+                dtype=['xdata', 'ydata'],
+                axes=kax,
+                ind=ii,
+            )
 
-    fig = plt.figure(figsize=fs)
-    gs = gridspec.GridSpec(ncols=6, nrows=6, **dmargin)
+        dax[kax].update(
+            refx=[drefx[k0]],
+            refy=[drefy[k0]],
+            datax=[dkeyx[k0]],
+            datay=[dkeyy[k0]],
+        )
 
-    # axes for image
-    ax0 = fig.add_subplot(gs[:4, 2:4], aspect='auto')
+    else:
 
-    # axes for vertical profile
-    ax1 = fig.add_subplot(gs[:4, 4], sharey=ax0)
+        for ii in range(nlos):
+            lv = ax.axvline(
+                ddatax[k0][0], c=color_dict['y'][ii], lw=1., ls='-',
+            )
+            kv = f'{k0}_v{ii:02.0f}{suffix}'
+            coll2.add_mobile(
+                key=kv,
+                handle=lv,
+                refs=drefx[k0],
+                data=dkeyx[k0],
+                dtype='xdata',
+                axes=kax,
+                ind=ii,
+            )
 
-    # axes for horizontal profile
-    ax2 = fig.add_subplot(gs[4:, 2:4], sharex=ax0)
-
-    # axes for traces
-    ax3 = fig.add_subplot(gs[2:4, :2])
-
-    # axes for traces
-    ax7 = fig.add_subplot(gs[:2, :2], sharey=ax2)
-
-    # axes for text
-    ax4 = fig.add_subplot(gs[:3, 5], frameon=False)
-    ax5 = fig.add_subplot(gs[3:, 5], frameon=False)
-    ax6 = fig.add_subplot(gs[4:, :2], frameon=False)
-
-    # dax
-    dax = {
-        # data
-        'matrix': {'handle': ax0, 'type': 'matrix'},
-        'vertical': {'handle': ax1, 'type': 'misc'},
-        'horizontal': {'handle': ax2, 'type': 'misc'},
-        'traces': {'handle': ax3, 'type': 'misc'},
-        'radial': {'handle': ax7, 'type': 'misc'},
-        # text
-        'textX': {'handle': ax4, 'type': 'text'},
-        'textY': {'handle': ax5, 'type': 'text'},
-        'textZ': {'handle': ax6, 'type': 'text'},
-    }
-    return dax
+        dax[kax].update(refx=[drefx[k0]], datax=[dkeyx[k0]])
```

### Comparing `tofu-1.6.5/tofu/data/_class2_check.py` & `tofu-1.7.0/tofu/data/_class2_check.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,18 +5,18 @@
 import datastock as ds
 
 
 from ..geom import CamLOS1D
 from ..geom import _comp
 
 
-# ##################################################################
-# ##################################################################
+# ################################################################
+# ################################################################
 #                   Rays
-# ##################################################################
+# ################################################################
 
 
 def _start_vect(ax=None, ay=None, az=None, name=None):
     dk = {
         f'x': ax,
         f'y': ay,
         f'z': az,
@@ -278,18 +278,18 @@
         shref,
         config, reflections_nb, reflections_type,
         key_nseg,
         diag, key_cam, lspectro,
     )
 
 
-# ##################################################################
-# ##################################################################
+# ################################################################
+# ################################################################
 #                   Main
-# ##################################################################
+# ################################################################
 
 
 def _rays(
     coll=None,
     key=None,
     # start points
     start_x=None,
@@ -305,14 +305,15 @@
     pts_z=None,
     # from ray-tracing (vect + length or config or diag)
     vect_x=None,
     vect_y=None,
     vect_z=None,
     length=None,
     config=None,
+    strict=None,
     reflections_nb=None,
     reflections_type=None,
     key_nseg=None,
     diag=None,
     key_cam=None,
 ):
 
@@ -361,66 +362,58 @@
     # prepare
 
     alpha, kalpha = None, None
     dalpha, kdalpha = None, None
     dbeta, kdbeta = None, None
 
     # -----------------------------
-    # -----------------------------
     # compute from pts
     # ----------------------------
 
     if pts_x is not None:
 
         if pts_x.shape[0] == 1:
-            angles = None
+            pass
         else:
             v0x = pts_x[0, ...] - start_x
             v0y = pts_y[0, ...] - start_y
             v0z = pts_z[0, ...] - start_z
             vx = np.concatenate((v0x, np.diff(pts_x, axis=0)), axis=0)
             vy = np.concatenate((v0y, np.diff(pts_y, axis=0)), axis=0)
             vz = np.concatenate((v0z, np.diff(pts_z, axis=0)), axis=0)
 
             norm = np.sqrt(vx**2 + vy**2 + vz**2)
             vx = vx / norm
             vy = vy / norm
             vz = vz / norm
 
-            sca = (
-                vx[1:, ...] * vx[:-1, ...]
-                + vy[1:, ...] * vy[:-1, ...]
-                + vz[1:, ...] * vz[:-1, ...]
-            )
+            # sca = (
+                # vx[1:, ...] * vx[:-1, ...]
+                # + vy[1:, ...] * vy[:-1, ...]
+                # + vz[1:, ...] * vz[:-1, ...]
+            # )
 
-            angle_in = None
-            angle = np.arcos(sca)
-
-    # -----------------------------
     # -----------------------------
     # compute ray-tracing
     # -----------------------------
 
     else:
 
-        kk = None
-
         # final shape
         i0 = 0
         nbref = reflections_nb + 1
         if lspectro is not None and len(lspectro) > 0:
             i0 = len(lspectro)
             nbref += i0
         shape = tuple(np.r_[nbref, shaperef])
 
         # extract angles and pts
         pts_x = np.full(shape, np.nan)
         pts_y = np.full(shape, np.nan)
         pts_z = np.full(shape, np.nan)
-        Rmin = np.full(shaperef, np.nan)
 
         pts_x[0, ...] = start_x
         pts_y[0, ...] = start_y
         pts_z[0, ...] = start_z
 
         if reflections_nb >= 0 or diag is not None:
             alpha = np.full(shape, np.nan)
@@ -495,14 +488,15 @@
             # call legacy code
             cam = CamLOS1D(
                 dgeom=(D[:, mask], uu[:, mask]),
                 config=config,
                 Name='',
                 Diag='',
                 Exp='',
+                strict=strict,
             )
 
             # add reflections
             if reflections_nb > 0:
                 cam.add_reflections(nb=reflections_nb)
 
             if cam.dgeom['dreflect'] is not None:
@@ -517,15 +511,20 @@
                 )
             else:
                 pout = cam.dgeom['PkOut']
 
             pts_x[-1, maskre] = pout[0, :]
             pts_y[-1, maskre] = pout[1, :]
             pts_z[-1, maskre] = pout[2, :]
-            
+
+            # reset to nan where relevant
+            pts_x[:, ~maskre] = np.nan
+            pts_y[:, ~maskre] = np.nan
+            pts_z[:, ~maskre] = np.nan
+
             # RMin
             # kRMin = _comp.LOS_PRMin(cam.D, cam.u, kOut=None)
             # PRMin = cam.D + kRMin[None, :]*cam.u
             # Rmin[maskre] = np.hypot(PRMin[0, :], PRMin[1, :])
 
             vperp = cam.dgeom['vperp']
             u_perp = np.sum(cam.u*vperp, axis=0)
@@ -557,45 +556,244 @@
 
             shape = tuple(np.r_[1., shaperef])
             pts_x = (start_x + length * vect_x).reshape(shape)
             pts_y = (start_y + length * vect_y).reshape(shape)
             pts_z = (start_z + length * vect_z).reshape(shape)
 
     # --------------------------------
-    # --------------------------------
     # store
     # --------------------------------
 
+    return _make_dict(
+        coll=coll,
+        key=key,
+        pts_x=pts_x,
+        pts_y=pts_y,
+        pts_z=pts_z,
+        start_x=start_x,
+        start_y=start_y,
+        start_z=start_z,
+        alpha=alpha,
+        dalpha=dalpha,
+        dbeta=dbeta,
+        lamb=lamb,
+        lspectro=lspectro,
+        diag=diag,
+        reflections_nb=reflections_nb,
+        key_nseg=key_nseg,
+        ref=ref,
+        shaperef=shaperef,
+    )
+
+
+# ##################################################################
+# ##################################################################
+#                   Rays - check key
+# ##################################################################
+
+
+def _check_key(coll=None, key=None, key_cam=None):
+
+    # check key
+    lrays = list(coll.dobj.get('rays', {}).keys())
+    ldiag = [
+        k0 for k0, v0 in coll.dobj.get('diagnostic', {}).items()
+        if any([
+                v1.get('los') is not None
+                and v1['los'] in lrays
+                for k1, v1 in v0['doptics'].items()
+            ])
+    ]
+
+    key = ds._generic_check._check_var(
+        key, 'key',
+        types=str,
+        allowed=lrays + ldiag,
+    )
+
+    # Derive kray
+    if key in lrays:
+        kray = key
+    else:
+
+        # key_cam
+        lok = list(coll.dobj['diagnostic'][key]['doptics'].keys())
+        key_cam = ds._generic_check._check_var(
+            key_cam, 'key_cam',
+            types=str,
+            allowed=lok,
+        )
+
+        kray = coll.dobj['diagnostic'][key]['doptics'][key_cam]['los']
+
+    return kray
+
+
+# ##################################################################
+# ##################################################################
+#                   Rays - get start and vect
+# ##################################################################
+
+
+def _get_start(
+    coll=None,
+    key=None,
+    key_cam=None,
+):
+
+    # ---------
+    # check key
+
+    key = _check_key(coll=coll, key=key, key_cam=key_cam)
+
+    # ---------------
+    # get start
+
+    stx, sty, stz = coll.dobj['rays'][key]['start']
+    if isinstance(stx, str):
+        stx = coll.ddata[stx]['data']
+        sty = coll.ddata[sty]['data']
+        stz = coll.ddata[stz]['data']
+
+    return stx, sty, stz
+
+
+def _get_pts(
+    coll=None,
+    key=None,
+    key_cam=None,
+):
+
+    # ---------
+    # check key
+
+    key = _check_key(coll=coll, key=key, key_cam=key_cam)
+
+    # ---------
+    # get start
+
+    stx, sty, stz = _get_start(coll=coll, key=key)
+
+    # ---------------
+    # get other pts
+
+    ptsx, ptsy, ptsz = coll.dobj['rays'][key]['pts']
+    ptsx = coll.ddata[ptsx]['data']
+    ptsy = coll.ddata[ptsy]['data']
+    ptsz = coll.ddata[ptsz]['data']
+
+    # concatenate
+    ptsx = np.insert(ptsx, 0, stx, axis=0)
+    ptsy = np.insert(ptsy, 0, sty, axis=0)
+    ptsz = np.insert(ptsz, 0, stz, axis=0)
+
+    return ptsx, ptsy, ptsz
+
+
+def _get_vect(
+    coll=None,
+    key=None,
+    key_cam=None,
+    norm=None,
+):
+
+    # ---------
+    # check key
+
+    key = _check_key(coll=coll, key=key, key_cam=key_cam)
+
+    # norm
+    norm = ds._generic_check._check_var(
+        norm, 'norm',
+        types=bool,
+        default=True,
+    )
+
+    # ---------------
+    # get start
+
+    stx, sty, stz = _get_start(coll=coll, key=key)
+
+    ptsx, ptsy, ptsz = coll.dobj['rays'][key]['pts']
+    ptsx = coll.ddata[ptsx]['data']
+    ptsy = coll.ddata[ptsy]['data']
+    ptsz = coll.ddata[ptsz]['data']
+
+    vx = (ptsx[0, ...] - stx)[None, ...]
+    vy = (ptsy[0, ...] - sty)[None, ...]
+    vz = (ptsz[0, ...] - stz)[None, ...]
+    if ptsx.shape[0] > 1:
+        vx = np.concatenate((vx, np.diff(ptsx, axis=0)), axis=0)
+        vy = np.concatenate((vy, np.diff(ptsy, axis=0)), axis=0)
+        vz = np.concatenate((vz, np.diff(ptsz, axis=0)), axis=0)
+
+    # normalize
+    if norm is True:
+        norm = np.sqrt(vx**2 + vy**2 + vz**2)
+        vx = vx / norm
+        vy = vy / norm
+        vz = vz / norm
+
+    return vx, vy, vz
+
+
+# ##################################################################
+# ##################################################################
+#                   store
+# ##################################################################
+
+
+def _make_dict(
+    coll=None,
+    key=None,
+    pts_x=None,
+    pts_y=None,
+    pts_z=None,
+    start_x=None,
+    start_y=None,
+    start_z=None,
+    alpha=None,
+    dalpha=None,
+    dbeta=None,
+    lamb=None,
+    lspectro=None,
+    diag=None,
+    reflections_nb=None,
+    key_nseg=None,
+    ref=None,
+    shaperef=None,
+):
+
     # --------
     # dref
 
     shape = pts_x.shape
     nseg = shape[0]
     nextra = len(lspectro) if diag is not None else 0
     assert nseg == reflections_nb + 1 + nextra
-    
+
     # key_nseg
     if key_nseg is None:
         knseg = f'{key}-nseg'
         dref = {
             knseg: {'size': nseg},
         }
-    else:       
+    else:
         if coll.dref[key_nseg]['size'] != nseg:
             msg = (
                 "Wrong size of key_nseg:\n"
                 f"\t- dref['key_nseg']['size] = coll.dref[key_nseg]['size']\n"
                 f"\t- nseg = {nseg}"
             )
             raise Exception(msg)
-            
+
         knseg = key_nseg
         dref = {}
 
-    # if ref is None  
+    # if ref is None
     if ref is None:
         ref = []
         for ii, ss in enumerate(shaperef):
             kr = f'{key}-n{ii}'
             dref.update({
                 kr: {'size': ss}
             })
@@ -721,15 +919,15 @@
                 'dim': 'angle',
                 'quant': 'angle',
                 'name': 'beta',
                 'units': 'rad',
             },
         })
 
-    # --------
+    # ------
     # dobj
 
     # start
     if start_x.shape == (1,):
         start = np.r_[start_x, start_y, start_z]
     else:
         start = (ksx, ksy, ksz)
@@ -761,164 +959,14 @@
                 'reflect_dbeta': kdbeta,
             },
         },
     }
 
     return dref, ddata, dobj
 
-# ##################################################################
-# ##################################################################
-#                   Rays - check key
-# ##################################################################
-
-
-def _check_key(coll=None, key=None, key_cam=None):
-
-    # check key
-    lrays = list(coll.dobj.get('rays', {}).keys())
-    ldiag = [
-        k0 for k0, v0 in coll.dobj.get('diagnostic', {}).items()
-        if any([
-                v1.get('los') is not None
-                and v1['los'] in lrays
-                for k1, v1 in v0['doptics'].items()
-            ])
-    ]
-    
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        allowed=lrays + ldiag,
-    )
-    
-    # Derive kray
-    if key in lrays:
-        kray = key
-    else:
-        
-        # key_cam
-        lok = list(coll.dobj['diagnostic'][key]['doptics'].keys())
-        key_cam = ds._generic_check._check_var(
-            key_cam, 'key_cam',
-            types=str,
-            allowed=lok,
-        )    
-        
-        kray = coll.dobj['diagnostic'][key]['doptics'][key_cam]['los']
-    
-    return kray
-
-
-# ##################################################################
-# ##################################################################
-#                   Rays - get start and vect
-# ##################################################################
-
-
-def _get_start(
-    coll=None,
-    key=None,
-    key_cam=None,
-):
-
-    # ---------
-    # check key
-
-    key = _check_key(coll=coll, key=key, key_cam=key_cam)
-
-    # ---------------
-    # get start
-
-    stx, sty, stz = coll.dobj['rays'][key]['start']
-    if isinstance(stx, str):
-        stx = coll.ddata[stx]['data']
-        sty = coll.ddata[sty]['data']
-        stz = coll.ddata[stz]['data']
-
-    return stx, sty, stz
-
-
-def _get_pts(
-    coll=None,
-    key=None,
-    key_cam=None,
-):
-
-    # ---------
-    # check key
-
-    key = _check_key(coll=coll, key=key, key_cam=key_cam)
-    
-    # ---------
-    # get start
-
-    stx, sty, stz = _get_start(coll=coll, key=key)
-
-    # ---------------
-    # get other pts
-
-    ptsx, ptsy, ptsz = coll.dobj['rays'][key]['pts']
-    ptsx = coll.ddata[ptsx]['data']
-    ptsy = coll.ddata[ptsy]['data']
-    ptsz = coll.ddata[ptsz]['data']
-
-    # concatenate
-    ptsx = np.insert(ptsx, 0, stx, axis=0)
-    ptsy = np.insert(ptsy, 0, sty, axis=0)
-    ptsz = np.insert(ptsz, 0, stz, axis=0)
-
-    return ptsx, ptsy, ptsz
-
-
-def _get_vect(
-    coll=None,
-    key=None,
-    key_cam=None,
-    norm=None,
-):
-
-    # ---------
-    # check key
-
-    key = _check_key(coll=coll, key=key, key_cam=key_cam)
-
-    # norm
-    norm = ds._generic_check._check_var(
-        norm, 'norm',
-        types=bool,
-        default=True,
-    )
-
-    # ---------------
-    # get start
-
-    stx, sty, stz = _get_start(coll=coll, key=key)
-
-    ptsx, ptsy, ptsz = coll.dobj['rays'][key]['pts']
-    ptsx = coll.ddata[ptsx]['data']
-    ptsy = coll.ddata[ptsy]['data']
-    ptsz = coll.ddata[ptsz]['data']
-
-    vx = (ptsx[0, ...] - stx)[None, ...]
-    vy = (ptsy[0, ...] - sty)[None, ...]
-    vz = (ptsz[0, ...] - stz)[None, ...]
-    if ptsx.shape[0] > 1:
-        vx = np.concatenate((vx, np.diff(ptsx, axis=0)), axis=0)
-        vy = np.concatenate((vy, np.diff(ptsy, axis=0)), axis=0)
-        vz = np.concatenate((vz, np.diff(ptsz, axis=0)), axis=0)
-
-    # normalize
-    if norm is True:
-        norm = np.sqrt(vx**2 + vy**2 + vz**2)
-        vx = vx / norm
-        vy = vy / norm
-        vz = vz / norm
-
-    return vx, vy, vz
-
 
 # ##################################################################
 # ##################################################################
 #                   Rays - remove
 # ##################################################################
```

### Comparing `tofu-1.6.5/tofu/data/_class2_compute.py` & `tofu-1.7.0/tofu/data/_class2_compute.py`

 * *Files 2% similar despite different names*

```diff
@@ -120,14 +120,21 @@
             pts_z = pts_z[i0, ...]
             length0 = length0[iseg, ...]
             length1 = length1[iseg, ...]
 
         length_rad = length0[1:, ...]
 
     # -----------
+    # trivial
+    # -----------
+
+    if pts_x.size == 0 or not np.any(np.isfinite(pts_x)):
+        return [None]*len(return_coords)
+
+    # -----------
     # compute
     # -----------
 
     # -------------------------
     # prepare sampling indices
 
     # rel
@@ -168,65 +175,88 @@
 
     # abs => for pts.ndim >= 3 (2d cameras and above), flattened list
     else:
 
         iok = np.isfinite(pts_x)
         nn = np.ceil(length_rad / res).astype(int)
 
+        nan = np.r_[np.nan, np.nan]
         lpx, lpy, lpz, itot, llen, lentot = [], [], [], [], [], []
         for ind in itt.product(*[range(ss) for ss in pts_x.shape[1:]]):
 
             sli = tuple([slice(None)] + list(ind))
-            if not np.any(iok[sli]):
+            ioki = iok[sli]
+            iokin = ioki[:-1] * ioki[1:]
+
+            if not np.any(iokin):
+                itot.append(nan)
+                if out_xyz:
+                    lpx.append(nan)
+                    lpy.append(nan)
+                    lpz.append(nan)
+                if 'l' in return_coords or 'ltot' in return_coords:
+                    llen.append(nan)
+                    lentot.append(nan)
                 continue
 
+            # get sli2 and i0i
+            sli2 = tuple([ioki] + list(ind))
             if radius_max is None:
-                i0i = i0[iok[sli]]
+                i0i = i0[ioki]
             else:
-                i0i = i0[sli]
+                i0i = i0[sli2]
+            nni = nn[tuple([iokin] + list(ind))]
 
-            itoti = np.concatenate(tuple(
-                [
-                    np.linspace(
-                        i0i[jj], i0i[jj+1], nn[tuple(np.r_[jj, ind])] + 1,
+            # itoti
+            itoti = []
+            for jj in range(i0i.size - 1):
+                if np.all(np.isfinite(i0i[jj:jj+2])):
+                    itoti.append(
+                        np.linspace(
+                            i0i[jj],
+                            i0i[jj+1],
+                            nni[jj] + 1,
                         )[:-1]
-                    for jj in range(i0i.size - 1)
-                ]
-                + [[i0i[-1]]]
-                ))
+                    )
+
+            if np.isfinite(i0i[-1]):
+                itoti.append([i0i[-1]])
+
+            itoti = np.concatenate(tuple(itoti))
             itot.append(itoti)
 
             # interpolate
             if out_xyz:
                 lpx.append(scpinterp.interp1d(
                     i0i,
-                    pts_x[sli],
+                    pts_x[sli2],
                     kind='linear',
                     axis=0,
                 )(itoti))
 
                 lpy.append(scpinterp.interp1d(
                     i0i,
-                    pts_y[sli],
+                    pts_y[sli2],
                     kind='linear',
                     axis=0,
                 )(itoti))
 
                 lpz.append(scpinterp.interp1d(
                     i0i,
-                    pts_z[sli],
+                    pts_z[sli2],
                     kind='linear',
                     axis=0,
                 )(itoti))
 
             if 'l' in return_coords or 'ltot' in return_coords:
                 i1 = np.floor(itoti).astype(int)
-                i1[i1 == length0.shape[0] - 1] -= 1
-                llen.append(length1[sli][i1])
-                lentot.append(length0[sli][i1])
+                # i1[i1 == length0.shape[0] - 1] -= 1
+                i1[i1 == ioki.sum()] -= 1
+                llen.append(length1[sli2][i1])
+                lentot.append(length0[sli2][i1])
 
         if out_xyz:
             pts_x, pts_y, pts_z = lpx, lpy, lpz
         if 'l' in return_coords or 'ltot' in return_coords:
             length = llen
             lengthtot = lentot
 
@@ -557,15 +587,15 @@
         AOz = axis_pt[2] - pts_z[:-1, ...]
 
         # --------
         # get kk
 
         # Eq:
         # k^2 |AB x v|^2 + 2k((AB.v)(AO.v) - AB.AO) + |AO x v|^2 = dist^2
-        # 
+        #
         # minimum:
         # k |AB x v|^2 + (AB.v)(AO.v) - AB.AO = 0
 
         ABvn2 = (
             (ABy*axis_vect[2] - ABz*axis_vect[1])**2
             + (ABz*axis_vect[0] - ABx*axis_vect[2])**2
             + (ABx*axis_vect[1] - ABy*axis_vect[0])**2
@@ -828,15 +858,15 @@
         iok2[iok] = k1[iok] < 1.
 
         false = np.zeros(tuple(np.r_[1, iok.shape[1:]]), dtype=bool)
         iok0 = np.concatenate((iok, false), axis=0)
         iok02 = np.concatenate((iok2, false), axis=0)
         iok12 = np.concatenate((false, iok2), axis=0)
 
-        # Make sure there a single continued sequence per ray 
+        # Make sure there a single continued sequence per ray
         # build index and check continuity
 
         px = np.full(pts_x.shape, np.nan)
         py = np.full(pts_x.shape, np.nan)
         pz = np.full(pts_x.shape, np.nan)
 
         px[iok0] = pts_x[iok0] + k0[iok] * ABx[iok]
```

### Comparing `tofu-1.6.5/tofu/data/_class2_plot.py` & `tofu-1.7.0/tofu/data/_class2_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_class3_check.py` & `tofu-1.7.0/tofu/data/_class3_check.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_class4_check.py` & `tofu-1.7.0/tofu/data/_class4_check.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_class5_compute.py` & `tofu-1.7.0/tofu/data/_class5_compute.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,18 +3,18 @@
 import numpy as np
 import datastock as ds
 
 
 from ..spectro import _rockingcurve
 
 
-# #################################################################
-# #################################################################
+# ###############################################################
+# ###############################################################
 #                   Rocking curve
-# #################################################################
+# ###############################################################
 
 
 def rocking_curve(coll=None, key=None):
 
     # ------------
     # check inputs
 
@@ -34,18 +34,18 @@
 
     # -------
     # store
 
     return
 
 
-# #################################################################
-# #################################################################
+# ###############################################################
+# ###############################################################
 #                   get bragg lambda
-# #################################################################
+# ###############################################################
 
 
 def _bragglamb(
     coll=None,
     key=None,
     lamb=None,
     bragg=None,
@@ -88,15 +88,24 @@
         default=False,
     )
 
     # -------------------
     # no input => default
 
     if bragg is None and lamb is None:
-        lamb = np.r_[coll.dobj['crystal'][key]['dmat']['target_lamb']]
+        dmat = coll.dobj['crystal'][key]['dmat']
+        if dmat is None or dmat.get('target') is None:
+            msg = (
+                f"Crystal '{key}' has no target lamb!\n"
+                f"dmat:\n{dmat}"
+            )
+            raise Exception(msg)
+        else:
+            lamb = np.r_[dmat['target']['lamb']]
+
     if bragg is not None:
         bragg = np.atleast_1d(bragg).astype(float)
     if lamb is not None:
         lamb = np.atleast_1d(lamb).astype(float)
 
     if rocking_curve is False:
         dist = coll.dobj['crystal'][key]['dmat']['d_hkl']
@@ -123,18 +132,18 @@
     else:
         msg = "Interpolate on rocking curve"
         raise NotImplementedError(msg)
 
     return bragg, lamb
 
 
-# #################################################################
-# #################################################################
+# ###############################################################
+# ###############################################################
 #                   Ideal configurations
-# #################################################################
+# ###############################################################
 
 
 def _ideal_configuration_check(
     coll=None,
     key=None,
     configuration=None,
     # parameters
@@ -168,15 +177,15 @@
     # gtype
     gtype = coll.dobj['crystal'][key]['dgeom']['type']
 
     # configuration
     if gtype == 'planar':
         conf = ['pinhole']
     elif gtype == 'cylindrical':
-        conf = ['pinhole', 'von hamos']
+        conf = ['pinhole', 'von hamos', 'johann']
     elif gtype == 'spherical':
         conf = ['pinhole', 'johann']
     elif gtype == 'toroidal':
         conf = []
 
     if isinstance(configuration, str):
         configuration = configuration.lower()
@@ -416,17 +425,17 @@
 
     # ----------------------
     # compute configuration
     # ----------------------
 
     # --------
     # johann
-    
+
     if configuration == 'johann':
-        
+
         if rc < 0:
             msg = (
                 f"crystal {key} is convex: Johann not possible!\n"
                 f" \t- curve_r = {curve_r}"
                 )
             raise Exception(msg)
 
@@ -453,23 +462,23 @@
                 'cent': sagittal,
                 'dist': sag,
             },
         }
 
     # --------
     # von hamos
-    
+
     elif configuration == 'von hamos':
 
         if rc < 0:
             msg = (
                 f"crystal {key} is convex: von hamos not possible!\n"
                 f" \t- curve_r = {curve_r}"
                 )
-            raise Exception(msg)        
+            raise Exception(msg)
 
         dist_pin = rc / np.sin(bragg)
         pin_cent = cent + dist_pin * vect_los
         pin_nin = vect_los
 
         cam_cent = cent + dist_pin * vect_cam
         if cam_tangential is True:
@@ -482,70 +491,70 @@
                 'cent': pin_cent,
                 'nin': pin_nin,
             },
         }
 
     # --------
     # pinhole
-    
+
     elif configuration == 'pinhole':
 
         # pinhole
         if pinhole_distance is None:
-            if gtype == 'cylindrical': 
+            if gtype == 'cylindrical':
                 pin_dist = np.abs(rc) / np.sin(bragg)
             elif gtype == 'spherical':
                 pin_dist = np.abs(rc) * np.sin(bragg)
             else:
                 msg = "Please provide pinhole_distance!"
                 raise Exception(msg)
-        
+
         else:
             pin_dist = pinhole_distance
-            
+
         pin_cent = cent + pin_dist * vect_los
-        pin_nin = vect_los    
-        
+        pin_nin = vect_los
+
         # camera
         if cam_distance is None:
             cam_height = cam_dimensions[1]
-    
+
             if gtype == 'planar' or (gtype == 'cylindrical' and icurv == 0):
                 cryst_height = 2. * extenthalf[1]
-    
+
                 if cam_height <= cryst_height:
                     msg = (
                         f"Height for ideal camera of '{key}' too small:\n"
                         f"\t- crystal height (flat): {cryst_height}\n"
                         f"\t- camera height: {cam_height}\n"
                     )
                     raise Exception(msg)
-    
+
                 cam_dist = pinhole_distance * (cam_height / cryst_height - 1.)
-    
+
             else:
                 if gtype == 'cylindrical':
                     cryst_height = 2. * extenthalf[icurv] * np.abs(rc)
-    
+
                 elif gtype == 'spherical':
                     cryst_height = 2. * extenthalf[1] * np.abs(rc)
-    
+
                 if cam_height >= cryst_height:
                     msg = (
                         f"Height for ideal camera of '{key}' too large:\n"
                         f"\t- crystal height (gtype): {cryst_height}\n"
                         f"\t- camera height: {cam_height}\n"
                     )
                     raise Exception(msg)
-    
+
                 cam_dist = np.abs(rc) * (1. - cam_height / cryst_height)
-                
+
         else:
             cam_dist = cam_distance
-                
+
         cam_nin = -vect_cam
         cam_cent = cent + cam_dist * vect_cam
 
         dout = {
             'aperture': {
                 'cent': pin_cent,
                 'nin': pin_nin,
@@ -555,15 +564,15 @@
     # ----------------------------------
     # complete with missing unit vectors
 
     if 'aperture' in dout.keys():
 
         # check against existing aperture is any
         if key_aperture_in is True:
-            
+
             dd = coll.dobj['aperture'][key_aperture]['dgeom']
             temp_dist = np.linalg.norm(dd['cent'] - pin_cent)
             temp_ang = np.arctan2(
                 np.linalg.norm(np.cross(dd['nin'], pin_nin)),
                 np.sum(dd['nin'] * pin_nin),
                 )
 
@@ -577,15 +586,15 @@
                     f"\t\t- ideal: {pin_cent}\n"
                     f"\t- nin: {temp_ang} deg.\n"
                     f"\t\t- {key_aperture}: {dd['nin']}\n"
                     f"\t\t- ideal: {pin_nin}\n"
                     )
                 raise Exception(msg)
             del dout['aperture']
-            
+
         # new aperture
         else:
             ap_e0 = np.cross(e1, dout['aperture']['nin'])
             ap_e0 = ap_e0 / np.linalg.norm(ap_e0)
             ap_e1 = np.cross(dout['aperture']['nin'], ap_e0)
             dout['aperture']['e0'] = ap_e0
             dout['aperture']['e1'] = ap_e1
@@ -655,16 +664,16 @@
     # pixels dimensions, outline and cents
     dim0, dim1 = cam_dimensions
     nx0, nx1 = cam_pixels_nb
 
     dx0 = dim0 / nx0
     dx1 = dim1 / nx1
 
-    outline_x0 = dx0 * np.r_[-1., 1., 1., -1.]
-    outline_x1 = dx1 * np.r_[-1., -1., 1., 1.]
+    outline_x0 = 0.5 * dx0 * np.r_[-1., 1., 1., -1.]
+    outline_x1 = 0.5 * dx1 * np.r_[-1., -1., 1., 1.]
 
     cents_x0 = 0.5 * dim0 * np.linspace(-1., 1., nx0 + 1)
     cents_x1 = 0.5 * dim1 * np.linspace(-1., 1., nx1 + 1)
     cents_x0 = 0.5 * (cents_x0[:-1] + cents_x0[1:])
     cents_x1 = 0.5 * (cents_x1[:-1] + cents_x1[1:])
 
     # complement camera
```

### Comparing `tofu-1.6.5/tofu/data/_class5_coordinates.py` & `tofu-1.7.0/tofu/data/_class5_coordinates.py`

 * *Files 4% similar despite different names*

```diff
@@ -55,15 +55,15 @@
     # ----------------
 
     elif dgeom['type'] == 'cylindrical':
 
         iplan = np.isinf(dgeom['curve_r']).nonzero()[0][0]
         eax = ['e0', 'e1'][iplan]
         erot = ['e0', 'e1'][1-iplan]
-        
+
         rc = dgeom['curve_r'][1 - iplan]
         rcs = np.sign(rc)
         rca = np.abs(rc)
 
         def x01toxyz(
             x0=None,
             x1=None,
@@ -98,15 +98,15 @@
     #   Spherical
     # ----------------
 
     elif dgeom['type'] == 'spherical':
 
         rc = dgeom['curve_r'][0]
         rcs = np.sign(rc)
-        rca = np.abs(rc)        
+        rca = np.abs(rc)
 
         def x01toxyz(
             x0=None,
             x1=None,
             # surface
             O=dgeom['cent'] + dgeom['nin'] * rc,
             rcs=rcs,
```

### Comparing `tofu-1.6.5/tofu/data/_class5_projections.py` & `tofu-1.7.0/tofu/data/_class5_projections.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,14 @@
 # -*- coding: utf-8 -*-
 
 
-import warnings
-import datetime as dtm
-
-
 import numpy as np
-import matplotlib.pyplot as plt    # DB
 
 
 import Polygon as plg
-import datastock as ds
 
 
 from . import _class8_compute
 
 
 # ##############################################################
 # ##############################################################
@@ -87,17 +81,17 @@
     p_a = pa & plg.Polygon(np.array([p0, p1]).T)
     if p_a.nPoints() < 3:
         # print('pts < 3')
         return None, None
 
     # plt.figure()
     # plt.plot(
-    #     poly_x0, poly_x1, '.-k',
-    #     p0, p1, '.-r',
-    #     )
+        # poly_x0, poly_x1, '.-k',
+        # p0, p1, '.-r',
+    # )
 
     p0, p1 = np.array(p_a.contour(0)).T
 
     # interpolate to add points
     if p0.size < 50:
         p0, p1 = _class8_compute._interp_poly(
             lp=[p0, p1],
@@ -124,15 +118,15 @@
         strict=False,
         return_xyz=False,
         return_x01=True,
         debug=False,
         # timing
         dt=dt,
     )
-    
+
     return p0, p1
 
 
 # ##############################################################
 # ##############################################################
 #           Global to local coordinates
 # ##############################################################
```

### Comparing `tofu-1.6.5/tofu/data/_class5_reflections_pts2pt.py` & `tofu-1.7.0/tofu/data/_class5_reflections_pts2pt.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,22 +1,14 @@
 # -*- coding: utf-8 -*-
 
 
-import warnings
-
-
 import numpy as np
-import scipy.interpolate as scpinterp
 import matplotlib.pyplot as plt
 
 
-import Polygon as plg
-import datastock as ds
-
-
 # ##############################################################
 # ##############################################################
 #           Finding reflection points
 # ##############################################################
 
 
 def _get_pts2pt(
@@ -128,15 +120,15 @@
     # ----------------
 
     elif dgeom['type'] == 'cylindrical':
 
         iplan = np.isinf(dgeom['curve_r']).nonzero()[0][0]
         eax = ['e0', 'e1'][iplan]
         erot = ['e0', 'e1'][1-iplan]
-        
+
         rc = dgeom['curve_r'][1 - iplan]
         rcs = np.sign(rc)
         rca = np.abs(rc)
 
         def pts2pt(
             pt_x=None,
             pt_y=None,
@@ -181,38 +173,38 @@
 
             if strict:
                 xmargin = 1.
                 thetatot = thetamax
             else:
                 xmargin = 1. + 0.01
                 thetatot = thetamax*(1. + 0.01)
-                 
+
             # defining zones for kk (point , plane unit vector)
             em = np.cos(thetatot)*(erot) + rcs * np.sin(thetatot)*(-nin)
-            eM = np.cos(thetatot)*(erot) - rcs * np.sin(thetatot)*(-nin) 
+            eM = np.cos(thetatot)*(erot) - rcs * np.sin(thetatot)*(-nin)
 
             lzones = [
                 (
                     (O - (xmax*xmargin)*eax, eax),
                     (O + (xmax*xmargin)*eax, -eax),
                     (O, em),
                     (O, -eM),
                 ),
-                
+
             ]
-            
+
             if rcs > 0:
                 lzones.append((
                     (O - (xmax*xmargin)*eax, eax),
                     (O + (xmax*xmargin)*eax, -eax),
                     (O, -em),
                     (O, eM),
                 ))
 
-            # loop on pts 
+            # loop on pts
             for ii in range(pts_x.size):
                 B = np.r_[pts_x[ii], pts_y[ii], pts_z[ii]]
                 AB = B - A
                 eAB = AB / np.linalg.norm(AB)
 
                 # compute kmin, kmax
                 kk = _kminmax_plane(
@@ -387,15 +379,15 @@
                 (
                     (O, epm),
                     (O, -epM),
                     (O, etm),
                     (O, -etM),
                 ),
             ]
-            
+
             if rcs > 0:
                 lzones.append((
                     (O, -epm),
                     (O, epM),
                     (O, -etm),
                     (O, etM),
                 ))
@@ -661,15 +653,15 @@
     ninorm = np.sqrt(nix**2 + niy**2 + niz**2)
     nix = - rcs * nix / ninorm
     niy = - rcs * niy / ninorm
     niz = - rcs * niz / ninorm
 
     # handle 2 zones
     sign = np.sign(nix*nin[0] + niy*nin[1] + niz*nin[2])
-    if rcs > 0:   
+    if rcs > 0:
         nix = sign*nix
         niy = sign*niy
         niz = sign*niz
     else:
         assert np.all(sign > 0.)
 
     Dx = O[0] + xx*eax[0] - rcs * rca*nix
@@ -693,15 +685,15 @@
 
     ninorm = np.sqrt((Ex - O[0])**2 + (Ey - O[1])**2 + (Ez - O[2])**2)
     nix = - rcs * (Ex - O[0]) / ninorm
     niy = - rcs * (Ey - O[1]) / ninorm
     niz = - rcs * (Ez - O[2]) / ninorm
 
     sign = np.sign(nix*nin[0] + niy*nin[1] + niz*nin[2])
-    if rcs > 0:   
+    if rcs > 0:
         nix = sign*nix
         niy = sign*niy
         niz = sign*niz
     else:
         assert np.all(sign > 0.)
 
     Dx = O[0] - rcs * rca*nix
```

### Comparing `tofu-1.6.5/tofu/data/_class5_reflections_ptsvect.py` & `tofu-1.7.0/tofu/data/_class5_reflections_ptsvect.py`

 * *Files 1% similar despite different names*

```diff
@@ -57,19 +57,19 @@
 
     elif dgeom['type'] == 'cylindrical':
 
         iplan = np.isinf(dgeom['curve_r']).nonzero()[0][0]
         icurv = 1 - iplan
         eax = ['e0', 'e1'][iplan]
         erot = ['e0', 'e1'][icurv]
-        
+
         rc = dgeom['curve_r'][icurv]
         rcs = np.sign(rc)
         rca = np.abs(rc)
-        
+
         minmax = np.maximum if rcs > 0 else np.minimum
 
         def ptsvect(
             # pts
             pts_x=None,
             pts_y=None,
             pts_z=None,
@@ -147,23 +147,23 @@
                 Dz = pts_z + kk*vect_z
 
                 ODx = Dx[iok] - O[0]
                 ODy = Dy[iok] - O[1]
                 ODz = Dz[iok] - O[2]
 
                 xxi = ODx * eax[0] + ODy * eax[1] + ODz * eax[2]
-                
+
                 nox = ODx - xxi * eax[0]
                 noy = ODy - xxi * eax[1]
                 noz = ODz - xxi * eax[2]
                 nn = np.sqrt(nox**2 + noy**2 + noz**2)
                 nox = rcs * nox / nn
                 noy = rcs * noy / nn
                 noz = rcs * noz / nn
-                
+
 
                 # ODzx = (Dy[iok] - O[1])*eax[2] - (Dz[iok] - O[2])*eax[1]
                 # ODzy = (Dz[iok] - O[2])*eax[0] - (Dx[iok] - O[0])*eax[2]
                 # ODzz = (Dx[iok] - O[0])*eax[1] - (Dy[iok] - O[1])*eax[0]
                 # ODzn = np.sqrt(ODzx**2 + ODzy**2 + ODzz**2)
 
                 # nox = -rcs*(ODzy * eax[2] - ODzz * eax[1]) / ODzn
@@ -188,15 +188,15 @@
                     vry[iok] = vect_y[iok] + 2.*scavn * noy
                     vrz[iok] = vect_z[iok] + 2.*scavn * noz
 
                 angle[iok] = -np.arcsin(scavn)
 
                 # x0, x1
                 if strict is True or return_x01 is True:
-                    
+
                     theta[iok] =  rcs * np.arctan2(
                         nox*erot[0] + noy*erot[1] + noz*erot[2],
                         -nox*nin[0] - noy*nin[1] - noz*nin[2],
                     )
 
                     xx[iok] = xxi
```

### Comparing `tofu-1.6.5/tofu/data/_class7_check.py` & `tofu-1.7.0/tofu/data/_class8_vos.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,912 +1,1073 @@
 # -*- coding: utf-8 -*-
 
 
 import numpy as np
-import scipy.constants as scpct
+from matplotlib.path import Path
 import datastock as ds
+import bsplines2d as bs2
+from contourpy import contour_generator
+from scipy.spatial import ConvexHull
+import scipy.interpolate as scpinterp
 
 
-from . import _utils_surface3d
-from . import _class4_check
+import datetime as dtm      # DB
 
-from ..geom._comp_solidangles import _check_polygon_2d
 
+import Polygon as plg
 
-_DMAT_KEYS = {
-    'name': {'types': str},
-    'symbol': {'types': str},
-    'thickness': {'types': float, 'sign': '> 0.'},
-    'energy': {'dtype': float, 'sign': '> 0.'},
-    'qeff': {'dtype': float, 'sign': ['>= 0.', '<= 1.']},
-}
 
+from ..geom import _comp_solidangles
 
 
-# #############################################################################
-# #############################################################################
-#                   Camera 1d
-# #############################################################################
+# ###############################################################
+# ###############################################################
+#                       Main
+# ###############################################################
 
 
-def _camera_1d_check(
+def compute_vos(
     coll=None,
-    key=None,
-    # outline
-    outline_x0=None,
-    outline_x1=None,
-    # centers of all pixels
-    cents_x=None,
-    cents_y=None,
-    cents_z=None,
-    # inwards normal vectors
-    nin_x=None,
-    nin_y=None,
-    nin_z=None,
-    # orthonormal direct base
-    e0_x=None,
-    e0_y=None,
-    e0_z=None,
-    e1_x=None,
-    e1_y=None,
-    e1_z=None,
+    key_diag=None,
+    key_mesh=None,
+    config=None,
+    # parameters
+    res=None,
+    margin_poly=None,
+    margin_par=None,
+    margin_perp=None,
+    # options
+    add_points=None,
+    # spectro-only
+    rocking_curve_fw=None,
+    rocking_curve_max=None,
+    # bool
+    visibility=None,
+    convex=None,
+    check=None,
+    verb=None,
+    plot=None,
+    store=None,
+    timing=None,
 ):
 
-    # ----
-    # key
+    if timing:
+        t0 = dtm.datetime.now()     # DB
 
-    key = ds._generic_check._obj_key(
-        d0=coll.dobj.get('camera', {}), short='cam', key=key,
-    )
+    # ------------
+    # check inputs
 
-    # ---------
-    # outline
-
-    outline_x0, outline_x1, area = _check_polygon_2d(
-        poly_x=outline_x0,
-        poly_y=outline_x1,
-        poly_name=f'{key}-outline',
-        can_be_None=False,
-        closed=False,
-        counter_clockwise=True,
-        return_area=True,
+    (
+        key_diag,
+        key_mesh,
+        spectro,
+        is2d,
+        doptics,
+        dcompute,
+        res,
+        margin_par,
+        margin_perp,
+        visibility,
+        verb,
+        plot,
+        store,
+        timing,
+    ) = _check(
+        coll=coll,
+        key_diag=key_diag,
+        key_mesh=key_mesh,
+        res=res,
+        margin_par=margin_par,
+        margin_perp=margin_perp,
+        visibility=visibility,
+        verb=verb,
+        plot=plot,
+        store=store,
+        timing=timing,
     )
 
-    # -----------
-    # cents
+    if verb is True:
+        msg = f"\nComputing vos for diag '{key_diag}':"
+        print(msg)
 
-    cents_x = np.atleast_1d(cents_x).ravel().astype(float)
-    cents_y = np.atleast_1d(cents_y).ravel().astype(float)
-    cents_z = np.atleast_1d(cents_z).ravel().astype(float)
-
-    # shapes
-    if not (cents_x.shape == cents_y.shape == cents_z.shape):
-        lstr = [
-            ('cents_x', cents_x.shape),
-            ('cents_y', cents_y.shape),
-            ('cents_z', cents_z.shape),
-        ]
-        lstr = [f"\t- {kk}.shape: {vv}" for kk, vv in lstr]
-        msg = (
-            "Args cents_x, cents_y, cents_z must have the same shape!\n"
-            + "\n".join(lstr)
-        )
-        raise Exception(msg)
+    # ------------
+    # sample mesh
 
-    iout = ~(
-        np.isfinite(cents_x) & np.isfinite(cents_y) & np.isfinite(cents_z)
+    dsamp = coll.get_sample_mesh(
+        key=key_mesh,
+        res=res,
+        mode='abs',
+        grid=True,
+        in_mesh=True,
+        # non-used
+        x0=None,
+        x1=None,
+        Dx0=None,
+        Dx1=None,
+        imshow=False,
+        store=False,
+        kx0=None,
+        kx1=None,
     )
-    if np.any(iout):
-        msg = (
-            f"Non-finite cents detected for cam1d '{key}':\n"
-            f"\t- indices: {iout.nonzero()[0]}\n"
-            f"\t- cents_x: {cents_x[iout]}\n"
-            f"\t- cents_y: {cents_y[iout]}\n"
-            f"\t- cents_z: {cents_z[iout]}\n"
-        )
-        raise Exception(msg)
 
-    # total nb of pixels
-    npix = cents_x.size
+    sh = dsamp['x0']['data'].shape
+    x0f = dsamp['x0']['data'].ravel()
+    x1f = dsamp['x1']['data'].ravel()
+
+    sh1 = tuple([ss + 2 for ss in sh])
+    bool_cross = np.zeros(sh1, dtype=bool)
+
+    x0u = dsamp['x0']['data'][:, 0]
+    x1u = dsamp['x1']['data'][0, :]
+    x0l = np.r_[x0u[0] - (x0u[1] - x0u[0]), x0u, x0u[-1] + (x0u[-1] - x0u[-2])]
+    x1l = np.r_[x1u[0] - (x1u[1] - x1u[0]), x1u, x1u[-1] + (x1u[-1] - x1u[-2])]
+    x0l = np.repeat(x0l[:, None], x1l.size, axis=1)
+    x1l = np.repeat(x1l[None, :], x0l.shape[0], axis=0)
 
-    # make sure all cents are different
-    dist = np.full((npix,), np.nan)
-    for ii in range(npix):
-        dist[:] = (
-            (cents_x - cents_x[ii])**2
-            + (cents_y - cents_y[ii])**2
-            + (cents_z - cents_z[ii])**2
-        )
-        dist[ii] = 10
-        if np.any(dist < 1.e-15):
-            msg = (
-                "Identical cents detected:\n"
-                f"\t- ref: {ii}\n"
-                f"\t- identicals: {(dist < 1.e-15).nonzero()[0]}\n"
-            )
-            raise Exception(msg)
+    # ------------
+    # prepare output
 
-    # -----------
-    # unit vectors
+    # dvos = _prepare_output(
+        # coll=coll,
+        # key_diag=key_diag,
+        # shape_samp=sh,
+        # spectro=spectro,
+    # )
+
+    # --------------
+    # prepare optics
+
+    doptics = coll._dobj['diagnostic'][key_diag]['doptics']
+
+    # timing
+    if timing:
+        t1 = dtm.datetime.now()     # DB
+        dt1 = (t1 - t0).total_seconds()
+        dt11, dt22 = 0, 0
+        dt111, dt222, dt333 = 0, 0, 0
+    dt1111, dt2222, dt3333, dt4444 = 0, 0, 0, 0
+
+    # --------------
+    # prepare optics
+
+    dvos = {}
+    for key_cam in dcompute.keys():
+
+        # ---------------
+        # prepare polygon
+
+        if timing:
+            t00 = dtm.datetime.now()     # DB
+
+        # get temporary vos
+        kpc0, kpc1 = doptics[key_cam]['vos_pcross']
+        shape = coll.ddata[kpc0]['data'].shape
+        pcross0 = coll.ddata[kpc0]['data'].reshape((shape[0], -1))
+        pcross1 = coll.ddata[kpc1]['data'].reshape((shape[0], -1))
+        kph0, kph1 = doptics[key_cam]['vos_phor']
+        shapeh = coll.ddata[kph0]['data'].shape
+        phor0 = coll.ddata[kph0]['data'].reshape((shapeh[0], -1))
+        phor1 = coll.ddata[kph1]['data'].reshape((shapeh[0], -1))
+
+        dphi = doptics[key_cam]['vos_dphi']
+
+        # ---------------
+        # prepare det
+
+        dgeom = coll.dobj['camera'][key_cam]['dgeom']
+        par = dgeom['parallel']
+        is2d = dgeom['type'] == '2d'
+        cx, cy, cz = coll.get_camera_cents_xyz(key=key_cam)
+        dvect = coll.get_camera_unit_vectors(key=key_cam)
+        outline = dgeom['outline']
+        out0 = coll.ddata[outline[0]]['data']
+        out1 = coll.ddata[outline[1]]['data']
+
+        if is2d:
+            cx = cx.ravel()
+            cy = cy.ravel()
+            cz = cz.ravel()
 
-    lv = [
-        ['nin_x', nin_x], ['nin_y', nin_y], ['nin_z', nin_z],
-        ['e0_x', e0_x], ['e0_y', e0_y], ['e0_z', e0_z],
-        ['e1_x', e1_x], ['e1_y', e1_y], ['e1_z', e1_z],
-    ]
+        # -----------
+        # prepare lap
 
-    # check they are all provided
-    lNone = [vv[0] for vv in lv if vv[1] is None]
-    if len(lNone) > 0:
-        msg = (
-            f"All unit vectors must be provided for camera '{key}'!\n"
-            f"The following are not provided: {lNone}"
-        )
-        raise Exception(msg)
+        if spectro is False:
+            lap = coll.get_optics_as_input_solid_angle(
+                keys=doptics[key_cam]['optics'],
+            )
 
-    # particular case: scalar because common to all
-    c0 = all([np.isscalar(vv[1]) for vv in lv])
-    if c0:
-        parallel = True
-        nin, e0, e1 = ds._generic_check._check_vectbasis(
-            e0=np.r_[nin_x, nin_y, nin_z],
-            e1=np.r_[e0_x, e0_y, e0_z],
-            e2=np.r_[e1_x, e1_y, e1_z],
-            dim=3,
-        )
+        if timing:
+            t11 = dtm.datetime.now()     # DB
+            dt11 += (t11-t00).total_seconds()
 
-    else:
+        # -----------
+        # loop on pix
+
+        lpcross = []
+        for ii in range(pcross0.shape[1]):
 
-        parallel = False
+            # -----------------
+            # get volume limits
 
-        # force into numpy array
-        for vv in lv:
-            vv[1] = np.atleast_1d(vv[1]).ravel().astype(float)
-
-        # check shapes
-        dshape = {vv[0]: vv[1].shape for vv in lv if vv[1].shape != (npix,)}
-        if len(set(dshape.values())) > 1:
-            lstr = [f"\t- {k0}: {v0}" for k0, v0 in dshape.items()]
-            msg = (
-                f"All unit vector componant must have shape ({npix},)!\n"
-                + "\n".join(lstr)
+            if timing:
+                t000 = dtm.datetime.now()     # DB
+
+            if np.isnan(pcross0[0, ii]):
+                continue
+
+            # get cross-section polygon
+            ind, path_hor = _get_cross_section_indices(
+                dsamp=dsamp,
+                # polygon
+                pcross0=pcross0[:, ii],
+                pcross1=pcross1[:, ii],
+                phor0=phor0[:, ii],
+                phor1=phor1[:, ii],
+                margin_poly=margin_poly,
+                # points
+                x0f=x0f,
+                x1f=x1f,
+                sh=sh,
             )
-            raise Exception(msg)
 
-        # force normalization
-        norm = np.sqrt((lv[0][1]**2 + lv[1][1]**2 + lv[2][1]**2))
-        nin_x = lv[0][1] / norm
-        nin_y = lv[1][1] / norm
-        nin_z = lv[2][1] / norm
-
-        norm = np.sqrt((lv[3][1]**2 + lv[4][1]**2 + lv[5][1]**2))
-        e0_x = lv[3][1] / norm
-        e0_y = lv[4][1] / norm
-        e0_z = lv[5][1] / norm
-
-        norm = np.sqrt((lv[6][1]**2 + lv[7][1]**2 + lv[8][1]**2))
-        e1_x = lv[6][1] / norm
-        e1_y = lv[7][1] / norm
-        e1_z = lv[8][1] / norm
-
-        # check perpendicularity
-        sca = (nin_x*e0_x + nin_y*e0_y + nin_z*e0_z)
-        if np.any(np.abs(sca) > 1e-14):
-            msg = "Non-perpendicular nin vs e0:\n{(sca > 1.e-14).nonzero()[0]}"
-            raise Exception(msg)
+            # re-initialize
+            bool_cross[...] = False
 
-        sca = (nin_x*e1_x + nin_y*e1_y + nin_z*e1_z)
-        if np.any(np.abs(sca) > 1e-14):
-            msg = "Non-perpendicular nin vs e1:\n{(sca > 1.e-14).nonzero()[0]}"
-            raise Exception(msg)
+            # verb
+            if verb is True:
+                msg = (
+                    f"\tcam '{key_cam}' pixel {ii+1} / {pcross0.shape[1]}\t"
+                    f"npts in cross_section = {ind.sum()}   "
+                )
+                end = '\n 'if ii == pcross0.shape[1] - 1 else '\r'
+                print(msg, end=end, flush=True)
+
+            # ---------------------
+            # loop on volume points
+
+
+            if spectro:
+                dvos[key_cam] = _vos_spectro(
+                    x0=x0,
+                    x1=x1,
+                    ind=ind,
+                    dphi=dphi[:, ii],
+                )
+
+            else:
+                # get detector / aperture
+                deti = _get_deti(
+                    coll=coll,
+                    cxi=cx[ii],
+                    cyi=cy[ii],
+                    czi=cz[ii],
+                    dvect=dvect,
+                    par=par,
+                    out0=out0,
+                    out1=out1,
+                    ii=ii,
+                )
+
+                if timing:
+                    t111 = dtm.datetime.now()     # DB
+                    dt111 += (t111-t000).total_seconds()
+
+                # compute
+                out = _vos_broadband(
+                    x0=x0u,
+                    x1=x1u,
+                    ind=ind,
+                    dphi=dphi[:, ii],
+                    deti=deti,
+                    lap=lap,
+                    res=res,
+                    config=config,
+                    visibility=visibility,
+                    # output
+                    key_cam=key_cam,
+                    dvos=dvos,
+                    sli=None,
+                    ii=ii,
+                    bool_cross=bool_cross,
+                    path_hor=path_hor,
+                    # timing
+                    timing=timing,
+                    dt1111=dt1111,
+                    dt2222=dt2222,
+                    dt3333=dt3333,
+                    dt4444=dt4444,
+                )
+
+                if timing:
+                    dt1111, dt2222, dt3333, dt4444 = out
+                    t222 = dtm.datetime.now()     # DB
+                    dt222 += (t222-t111).total_seconds()
+
+            # -----------------------
+            # get pcross and simplify
+
+            if np.any(bool_cross):
+                pc0, pc1 = _get_polygons(
+                    bool_cross=bool_cross,
+                    x0=x0l,
+                    x1=x1l,
+                    res=res,
+                )
+            else:
+                pc0, pc1 = None, None
+
+            # -----------
+            # replace
+
+            lpcross.append((pc0, pc1))
+
+            if timing:
+                t333 = dtm.datetime.now()     # DB
+                dt333 += (t333-t222).total_seconds()
+
+        # ----------------
+        # harmonize pcross
+
+        if timing:
+            t22 = dtm.datetime.now()     # DB
+
+        ln = [pp[0].size if pp[0] is not None else 0 for pp in lpcross]
+        nmax = np.max(ln)
+        sh2 = (nmax, pcross0.shape[1])
+        pcross0 = np.full(sh2, np.nan)
+        pcross1 = np.full(sh2, np.nan)
+        for ii, nn in enumerate(ln):
+
+            if nn == 0:
+                continue
+
+            if nmax > nn:
+                ind = np.r_[0, np.linspace(0.1, 0.9, nmax-nn), np.arange(1, nn)]
+                pcross0[:, ii] = scpinterp.interp1d(
+                    range(0, nn),
+                    lpcross[ii][0],
+                    kind='linear',
+                )(ind)
+
+                pcross1[:, ii] = scpinterp.interp1d(
+                    range(0, nn),
+                    lpcross[ii][1],
+                    kind='linear',
+                )(ind)
+
+            else:
+                pcross0[:, ii] = lpcross[ii][0]
+                pcross1[:, ii] = lpcross[ii][1]
+
+        # -------------
+        # reshape
+
+        if is2d:
+            newsh = tuple(np.r_[nmax, shape])
+            pcross0 = pcross0.reshape(newsh)
+            pcross1 = pcross1.reshape(newsh)
+
+        dvos[key_cam] = {
+            'pcross0': pcross0,
+            'pcross1': pcross1,
+        }
 
-        sca = (e0_x*e1_x + e0_y*e1_y + e0_z*e1_z)
-        if np.any(np.abs(sca) > 1e-14):
-            msg = "Non-perpendicular e0 vs e1:\n{(sca > 1.e-14).nonzero()[0]}"
-            raise Exception(msg)
+        if timing:
+            t33 = dtm.datetime.now()
+            dt22 += (t33 - t22).total_seconds()
+
+    # timing
+    if timing:
+        t2 = dtm.datetime.now()     # DB
+        print("\nTIMING\n--------")
+        print(f'Prepare: {dt1} s')
+        print(f'\tdt11 (pepare cam): {dt11} s')
+        print(f'\t\tdt111 (prepare pix): {dt111} s')
+        print(f"\t\t\tdt1111 (prepare): {dt1111} s")
+        print(f"\t\t\tdt2222 (compute): {dt2222} s")
+        print(f"\t\t\tdt3333 (format):  {dt3333} s")
+        print(f"\t\t\tdt4444 (ind_bool):  {dt4444} s")
+        print(f'\t\tdt222 (compute): {dt222} s')
+        print(f'\t\tdt333 (get poly): {dt333} s')
+        print(f'\tdt22 (interp poly): {dt22} s')
+        print(f'loop total: {(t2-t1).total_seconds()} s')
 
-        # check right-handedness
-        sca = (
-            e1_x * (nin_y * e0_z - nin_z * e0_y)
-            + e1_y * (nin_z * e0_x - nin_x * e0_z)
-            + e1_z * (nin_x * e0_y - nin_y * e0_x)
+    # -------------
+    # replace
+
+    if store is True:
+
+        _store(
+            coll=coll,
+            key_diag=key_diag,
+            dvos=dvos,
         )
-        if np.any(sca <= 0.):
-            msg = (
-                "The following unit vectors do not seem right-handed:\n"
-                f"{(sca <= 0.).nonzero()[0]}"
-            )
-            raise Exception(msg)
 
-        nin = (nin_x, nin_y, nin_z)
-        e0 = (e0_x, e0_y, e0_z)
-        e1 = (e1_x, e1_y, e1_z)
+    return dvos
 
-    return (
-        key,
-        outline_x0, outline_x1,
-        area,
-        cents_x,
-        cents_y,
-        cents_z,
-        npix,
-        parallel,
-        nin, e0, e1,
-    )
+
+# ###########################################################
+# ###########################################################
+#               check
+# ###########################################################
 
 
-def _camera_1d(
+def _check(
     coll=None,
-    key=None,
-    # common 2d outline
-    outline_x0=None,
-    outline_x1=None,
-    # centers of all pixels
-    cents_x=None,
-    cents_y=None,
-    cents_z=None,
-    # inwards normal vectors
-    nin_x=None,
-    nin_y=None,
-    nin_z=None,
-    # orthonormal direct base
-    e0_x=None,
-    e0_y=None,
-    e0_z=None,
-    e1_x=None,
-    e1_y=None,
-    e1_z=None,
+    key_diag=None,
+    key_mesh=None,
+    res=None,
+    margin_par=None,
+    margin_perp=None,
+    visibility=None,
+    check=None,
+    verb=None,
+    plot=None,
+    store=None,
+    timing=None,
 ):
 
-    # ------------
-    # check inputs
+    # --------
+    # key_diag
 
-    (
-        key,
-        outline_x0, outline_x1,
-        area,
-        cents_x,
-        cents_y,
-        cents_z,
-        npix,
-        parallel,
-        nin, e0, e1,
-    ) = _camera_1d_check(
-        coll=coll,
-        key=key,
-        # outline
-        outline_x0=outline_x0,
-        outline_x1=outline_x1,
-        # centers of all pixels
-        cents_x=cents_x,
-        cents_y=cents_y,
-        cents_z=cents_z,
-        # inwards normal vectors
-        nin_x=nin_x,
-        nin_y=nin_y,
-        nin_z=nin_z,
-        # orthonormal direct base
-        e0_x=e0_x,
-        e0_y=e0_y,
-        e0_z=e0_z,
-        e1_x=e1_x,
-        e1_y=e1_y,
-        e1_z=e1_z,
+    lok = [
+        k0 for k0, v0 in coll.dobj.get('diagnostic', {}).items()
+        if any([len(v1['optics']) > 0 for v1 in v0['doptics'].values()])
+    ]
+    key_diag = ds._generic_check._check_var(
+        key_diag, 'key_diag',
+        types=str,
+        allowed=lok,
     )
 
-    # ----------
-    # dref
-
-    npts = outline_x0.size
-    knpts = f'{key}-npts'
-    knpix = f'{key}-npix'
-    dref = {
-        knpts: {'size': npts},
-        knpix: {'size': npix},
-    }
-
-    # -------------
-    # ddata
-
-    kcx = f'{key}-cx'
-    kcy = f'{key}-cy'
-    kcz = f'{key}-cz'
-    kout0 = f'{key}_outx0'
-    kout1 = f'{key}_outx1'
-
-    ddata = {
-        kout0: {
-            'data': outline_x0,
-            'ref': knpts,
-            'dim': 'distance',
-            'quant': 'x0',
-            'name': 'x0',
-            'units': 'm',
-        },
-        kout1: {
-            'data': outline_x1,
-            'ref': knpts,
-            'dim': 'distance',
-            'quant': 'x1',
-            'name': 'x1',
-            'units': 'm',
-        },
-        kcx: {
-            'data': cents_x,
-            'ref': knpix,
-            'dim': 'distance',
-            'quant': 'x',
-            'name': 'x',
-            'units': 'm',
-        },
-        kcy: {
-            'data': cents_y,
-            'ref': knpix,
-            'dim': 'distance',
-            'quant': 'y',
-            'name': 'y',
-            'units': 'm',
-        },
-        kcz: {
-            'data': cents_z,
-            'ref': knpix,
-            'dim': 'distance',
-            'quant': 'z',
-            'name': 'z',
-            'units': 'm',
-        },
+    # spectro, is2d
+    spectro = coll.dobj['diagnostic'][key_diag]['spectro']
+    is2d = coll.dobj['diagnostic'][key_diag]['is2d']
+
+    # doptics
+    doptics = coll.dobj['diagnostic'][key_diag]['doptics']
+    dcompute = {
+        k0: {'compute': len(v0['optics']) > 0}
+        for k0, v0 in doptics.items()
     }
 
-    # -----
-    # dobj
+    # --------
+    # key_mesh
 
-    if parallel:
-        o_nin = nin
-        o_e0 = e0
-        o_e1 = e1
-
-    else:
-        kinx = f'{key}-nin_x'
-        kiny = f'{key}-nin_y'
-        kinz = f'{key}-nin_z'
-        ke0x = f'{key}-e0_x'
-        ke0y = f'{key}-e0_y'
-        ke0z = f'{key}-e0_z'
-        ke1x = f'{key}-e1_x'
-        ke1y = f'{key}-e1_y'
-        ke1z = f'{key}-e1_z'
-
-        o_nin = (kinx, kiny, kinz)
-        o_e0 = (ke0x, ke0y, ke0z)
-        o_e1 = (ke1x, ke1y, ke1z)
-
-    # dobj
-    dobj = {
-        'camera': {
-            key: {
-                'dgeom': {
-                    'type': '1d',
-                    'parallel': parallel,
-                    'shape': (npix,),
-                    'ref': (knpix,),
-                    'ref_flat': (knpix,),
-                    'pix_area': area,
-                    'pix_nb': npix,
-                    'outline': (kout0, kout1),
-                    'cent': None,
-                    'cents': (kcx, kcy, kcz),
-                    'nin': o_nin,
-                    'e0': o_e0,
-                    'e1': o_e1,
-                },
-            },
-        },
-    }
+    wm = coll._which_mesh
+    lok = list(coll.dobj.get(wm, {}).keys())
+    key_mesh = ds._generic_check._check_var(
+        key_mesh, 'key_mesh',
+        types=str,
+        allowed=lok,
+    )
 
-    # ------------------------
-    # parallel vs non-parallel
+    # -------------------------------------------------
+    # ldeti: list of individual camera dict (per pixel)
 
-    if not parallel:
-        ddata.update({
-            kinx: {
-                'data': nin[0],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'x',
-                'name': 'x',
-                'units': 'm',
-            },
-            kiny: {
-                'data': nin[1],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'y',
-                'name': 'y',
-                'units': 'm',
-            },
-            kinz: {
-                'data': nin[2],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'z',
-                'name': 'z',
-                'units': 'm',
-            },
-            ke0x: {
-                'data': e0[0],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'x',
-                'name': 'x',
-                'units': 'm',
-            },
-            ke0y: {
-                'data': e0[1],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'y',
-                'name': 'y',
-                'units': 'm',
-            },
-            ke0z: {
-                'data': e0[2],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'z',
-                'name': 'z',
-                'units': 'm',
-            },
-            ke1x: {
-                'data': e1[0],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'x',
-                'name': 'x',
-                'units': 'm',
-            },
-            ke1y: {
-                'data': e1[1],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'y',
-                'name': 'y',
-                'units': 'm',
-            },
-            ke1z: {
-                'data': e1[2],
-                'ref': knpix,
-                'dim': 'distance',
-                'quant': 'z',
-                'name': 'z',
-                'units': 'm',
-            },
-        })
-
-    return dref, ddata, dobj
-
-
-# ##################################################################
-# ##################################################################
-#                           Camera 2d
-# ##################################################################
+    for k0, v0 in doptics.items():
 
+        dgeom = coll.dobj['camera'][k0]['dgeom']
+        cx, cy, cz = coll.get_camera_cents_xyz(key=k0)
+        dvect = coll.get_camera_unit_vectors(key=k0)
+        outline = dgeom['outline']
+        out0 = coll.ddata[outline[0]]['data']
+        out1 = coll.ddata[outline[1]]['data']
+        is2d = dgeom['type'] == '2d'
+        par = dgeom['parallel']
+        dcompute[k0]['shape0'] = cx.shape
+
+        if is2d:
+            cx = cx.ravel()
+            cy = cy.ravel()
+            cz = cz.ravel()
+
+        nd = cx.size
+
+        dcompute[k0]['ldet'] = [
+            {
+                'cents_x': cx[ii],
+                'cents_y': cy[ii],
+                'cents_z': cz[ii],
+                'outline_x0': out0,
+                'outline_x1': out1,
+                'nin_x': dvect['nin_x'] if par else dvect['nin_x'][ii],
+                'nin_y': dvect['nin_y'] if par else dvect['nin_y'][ii],
+                'nin_z': dvect['nin_z'] if par else dvect['nin_z'][ii],
+                'e0_x': dvect['e0_x'] if par else dvect['e0_x'][ii],
+                'e0_y': dvect['e0_y'] if par else dvect['e0_y'][ii],
+                'e0_z': dvect['e0_z'] if par else dvect['e0_z'][ii],
+                'e1_x': dvect['e1_x'] if par else dvect['e1_x'][ii],
+                'e1_y': dvect['e1_y'] if par else dvect['e1_y'][ii],
+                'e1_z': dvect['e1_z'] if par else dvect['e1_z'][ii],
+            }
+            for ii in range(nd)
+        ]
 
-def _camera_2d_check(
-    coll=None,
-    key=None,
-    # outline
-    outline_x0=None,
-    outline_x1=None,
-    # centers of all pixels
-    cent=None,
-    cents_x0=None,
-    cents_x1=None,
-    # inwards normal vectors
-    nin=None,
-    e0=None,
-    e1=None,
-):
+    # -----------
+    # res
 
-    # ----
-    # key
+    if res is None:
+        res = 0.01
 
-    key = ds._generic_check._obj_key(
-        d0=coll.dobj.get('camera', {}), short='cam', key=key,
-    )
+    # -----------
+    # margin_par
 
-    # ---------
-    # outline
-
-    outline_x0, outline_x1, area = _check_polygon_2d(
-        poly_x=outline_x0,
-        poly_y=outline_x1,
-        poly_name=f'{key}-outline',
-        can_be_None=False,
-        closed=False,
-        counter_clockwise=True,
-        return_area=True,
+    margin_par = ds._generic_check._check_var(
+        margin_par, 'margin_par',
+        types=float,
+        default=0.05,
     )
 
     # -----------
-    # cent
+    # margin_perp
 
-    cent = np.atleast_1d(cent).ravel().astype(float)
-    if cent.shape != (3,) or np.any(~np.isfinite(cent)):
-        msg = f"Arg cent non valid shape {cent.shape} vs (3,) or non-finite!"
-        raise Exception(msg)
+    margin_perp = ds._generic_check._check_var(
+        margin_perp, 'margin_perp',
+        types=float,
+        default=0.05,
+    )
 
     # -----------
-    # cents
+    # visibility
 
-    cents_x0 = np.atleast_1d(cents_x0).ravel().astype(float)
-    cents_x1 = np.atleast_1d(cents_x1).ravel().astype(float)
+    visibility = ds._generic_check._check_var(
+        visibility, 'visibility',
+        types=bool,
+        default=True,
+    )
 
-    # finite
-    iout = ~np.isfinite(cents_x0)
-    if np.any(iout):
-        msg = "Non-finite cents_x0 detected:\n{iout.nonzero()[0]}"
-        raise Exception(msg)
+    # -----------
+    # verb
 
-    iout = ~np.isfinite(cents_x1)
-    if np.any(iout):
-        msg = "Non-finite cents_x1 detected:\n{iout.nonzero()[0]}"
-        raise Exception(msg)
+    verb = ds._generic_check._check_var(
+        verb, 'verb',
+        types=bool,
+        default=True,
+    )
 
-    # total nb of pixels
-    npix0 = cents_x0.size
-    npix1 = cents_x1.size
-
-    # make sure all cents are different
-    if np.unique(cents_x0).size != cents_x0.size:
-        msg = "Double values found in cents_x0!"
-        raise Exception(msg)
+    # -----------
+    # plot
 
-    if np.unique(cents_x1).size != cents_x1.size:
-        msg = "Double values found in cents_x1!"
+    if plot is None:
+        plot = True
+    if not isinstance(plot, bool):
+        msg = "Arg plot must be a bool"
         raise Exception(msg)
 
     # -----------
-    # unit vectors
+    # store
 
-    lv = [('nin', nin), ('e0', e0), ('e1', e1)]
+    store = ds._generic_check._check_var(
+        store, 'store',
+        types=bool,
+        default=True,
+    )
 
-    # check they are all provided
-    lNone = [vv[0] for vv in lv if vv[1] is None]
-    if len(lNone) > 0:
-        msg = (
-            f"All unit vectors must be provided for camera '{key}'!\n"
-            f"The following are not provided: {lNone}"
-        )
-        raise Exception(msg)
+    # -----------
+    # timing
 
-    # particular case: scalar because common to all
-    nin, e0, e1 = ds._generic_check._check_vectbasis(
-        e0=nin,
-        e1=e0,
-        e2=e1,
-        dim=3,
+    timing = ds._generic_check._check_var(
+        timing, 'timing',
+        types=bool,
+        default=False,
     )
 
     return (
-        key,
-        outline_x0, outline_x1,
-        area,
-        cent,
-        cents_x0, cents_x1,
-        npix0, npix1,
-        nin, e0, e1,
+        key_diag,
+        key_mesh,
+        spectro,
+        is2d,
+        doptics,
+        dcompute,
+        res,
+        margin_par,
+        margin_perp,
+        visibility,
+        verb,
+        plot,
+        store,
+        timing,
     )
 
 
-def _camera_2d(
+# ###########################################################
+# ###########################################################
+#               Prepare ouput
+# ###########################################################
+
+
+def _prepare_output(
     coll=None,
-    key=None,
-    # common 2d outline
-    outline_x0=None,
-    outline_x1=None,
-    # centers of all pixels
-    cent=None,
-    cents_x0=None,
-    cents_x1=None,
-    # inwards normal vectors
-    nin=None,
-    e0=None,
-    e1=None,
+    key_diag=None,
+    shape_samp=None,
+    spectro=None,
 ):
 
-    # ------------
-    # check inputs
+    # -------
+    # spectro
 
-    (
-        key,
-        outline_x0, outline_x1,
-        area,
-        cent,
-        cents_x0, cents_x1,
-        npix0, npix1,
-        nin, e0, e1,
-    ) = _camera_2d_check(
-        coll=coll,
-        key=key,
-        # outline
-        outline_x0=outline_x0,
-        outline_x1=outline_x1,
-        # centers of all pixels
-        cent=cent,
-        cents_x0=cents_x0,
-        cents_x1=cents_x1,
-        # inwards normal vectors
-        nin=nin,
-        e0=e0,
-        e1=e1,
-    )
+    if spectro is True:
+        pass
 
-    # ----------
-    # dref
+    # -----------
+    # non-spectro
 
-    npts = outline_x0.size
-    knpts = f'{key}-npts'
-    knpix0 = f'{key}-npix0'
-    knpix1 = f'{key}-npix1'
-    knpix = f'{key}-npix'
-    dref = {
-        knpts: {'size': npts},
-        knpix0: {'size': npix0},
-        knpix1: {'size': npix1},
-        knpix: {'size': npix0*npix1},
-    }
+    else:
 
-    # -------------
-    # ddata
+        dvos = {'solid_angle_int': {}}
+        for k0 in coll.dobj['diagnostic'][key_diag]['doptics'].keys():
+            dgeom = coll.dobj['camera'][k0]['dgeom']
+            sh = dgeom['shape']
+            shape = tuple(np.r_[shape_samp, sh])
+            ref = tuple([None, None] + list(dgeom['ref']))
+
+            # --------
+            # slice
+
+            if is2d:
+                def sli(ir, iz, ii):
+                    pass
+
+            else:
+                def sli(ir, iz, ii):
+                    pass
 
-    kc0 = f'{key}-c0'
-    kc1 = f'{key}-c1'
-    kout0 = f'{key}_outx0'
-    kout1 = f'{key}_outx1'
-
-    ddata = {
-        kout0: {
-            'data': outline_x0,
-            'ref': knpts,
-            'dim': 'distance',
-            'quant': 'x0',
-            'name': 'x0',
-            'units': 'm',
-        },
-        kout1: {
-            'data': outline_x1,
-            'ref': knpts,
-            'dim': 'distance',
-            'quant': 'x1',
-            'name': 'x1',
-            'units': 'm',
-        },
-        kc0: {
-            'data': cents_x0,
-            'ref': knpix0,
-            'dim': 'distance',
-            'quant': 'x0',
-            'name': 'x0',
-            'units': 'm',
-        },
-        kc1: {
-            'data': cents_x1,
-            'ref': knpix1,
-            'dim': 'distance',
-            'quant': 'x1',
-            'name': 'x1',
-            'units': 'm',
-        },
-    }
 
-    # -----
-    # dobj
 
-    dobj = {
-        'camera': {
-            key: {
-                'dgeom': {
-                    'type': '2d',
-                    'parallel': True,
-                    'shape': (npix0, npix1),
-                    'ref': (knpix0, knpix1),
-                    'ref_flat': (knpix,),
-                    'pix_area': area,
-                    'pix_nb': npix0 * npix1,
-                    'outline': (kout0, kout1),
-                    'cent': cent,
-                    'cents': (kc0, kc1),
-                    'nin': nin,
-                    'e0': e0,
-                    'e1': e1,
-                },
-            },
-        },
-    }
+            # --------
+            # dvos
+
+            dvos['solid_angle_int'][k0] = {
+                'data': None,
+                'units': 'sr.m',
+                'dim': '',
+                'quant': '',
+                'name': '',
+                'ref': ref,
+            }
 
-    return dref, ddata, dobj
+    return dvos
 
 
-# ##################################################################
-# ##################################################################
-#                       Camera dmat
-# ##################################################################
+# ###########################################################
+# ###########################################################
+#               Get cross-section indices
+# ###########################################################
+
+
+def _get_cross_section_indices(
+    dsamp=None,
+    # polygon
+    pcross0=None,
+    pcross1=None,
+    phor0=None,
+    phor1=None,
+    margin_poly=None,
+    # points
+    x0f=None,
+    x1f=None,
+    sh=None,
+):
 
+    # ----------
+    # check
 
-def _dmat(
-    key=None,
-    dmat=None,
-):
-    """ Check qeff is provided as a 1d vector vs lamb or energy
+    margin_poly = ds._generic_check._check_var(
+        margin_poly, 'margin_poly',
+        types=float,
+        default=0.2,
+        sign='>0'
+    )
 
-    lamb is assumed to be in m and converted to energy
-    energy is assumed to be in eV
+    # ---------------------------
+    # add extra margin to pcross
 
-    """
+    # get centroid
+    center = plg.Polygon(np.array([pcross0, pcross1]).T).center()
 
-    # ------------
-    # trivial case
+    # add margin
+    pcross02 = center[0] + (1. + margin_poly) * (pcross0 - center[0])
+    pcross12 = center[1] + (1. + margin_poly) * (pcross1 - center[1])
 
-    if dmat is None:
-        return None, None, None
+    # define path
+    pcross = Path(np.array([pcross02, pcross12]).T)
 
-    # ------
-    # Check
+    # ---------------------------
+    # add extra margin to phor
 
-    # Check dict type and content (each key is a valid string)
-    dmat = ds._generic_check._check_dict_valid_keys(
-        var=dmat,
-        varname='dmat',
-        has_all_keys=False,
-        has_only_keys=True,
-        keys_can_be_None=True,
-        dkeys=_DMAT_KEYS,
-    )
-
-    # -----------------------------------
-    # check energy / qeff values
-
-    dref, ddata = None, None
-    if all([dmat.get(kk) is not None for kk in ['energy', 'qeff']]):
-        
-        dmat['energy'], dmat['qeff'] = _class4_check._dmat_energy_trans(
-            energ=dmat['energy'],
-            trans=dmat['qeff'],
-        )
+    # get center
+    center = plg.Polygon(np.array([phor0, phor1]).T).center()
 
-        # ----------
-        # dref
-    
-        kne = f'{key}-nE'
-        ne = dmat['energy'].size
-        dref = {
-            kne: {'size': ne},
-        }
-    
-        # ----------
-        # ddata
-    
-        kE = f'{key}-E'
-        kqeff = f'{key}-qeff'
-    
-        ddata = {
-            kE: {
-                'data': dmat['energy'],
-                'ref': kne,
-                'dim': 'energy',
-                'quant': 'energy',
-                'name': 'E',
-                'units': 'eV',
-            },
-            kqeff: {
-                'data': dmat['qeff'],
-                'ref': kne,
-                'dim': None,
-                'quant': 'quantum eff.',
-                'name': '',
-                'units': '',
-            },
-        }
-    
-        # -----------
-        # dmat
-    
-        dmat['energy'] = kE
-        dmat['qeff'] = kqeff
+    # add margin
+    phor02 = center[0] + (1. + margin_poly) * (phor0 - center[0])
+    phor12 = center[1] + (1. + margin_poly) * (phor1 - center[1])
+
+    # define path
+    phor = Path(np.array([phor02, phor12]).T)
 
-    return dref, ddata, dmat
+    # get ind
+    return (
+        dsamp['ind']['data']
+        & pcross.contains_points(np.array([x0f, x1f]).T).reshape(sh)
+    ), phor
 
 
-# ##################################################################
-# ##################################################################
-#                           Utilities
-# ##################################################################
+# ###########################################################
+# ###########################################################
+#               Detector
+# ###########################################################
 
 
-def get_camera_unitvectors(
+def _get_deti(
     coll=None,
-    key=None,
+    cxi=None,
+    cyi=None,
+    czi=None,
+    dvect=None,
+    par=None,
+    out0=None,
+    out1=None,
+    ii=None,
 ):
 
-    # ---------
-    # check key
+    # ------------
+    # detector
 
-    lok = list(coll.dobj.get('camera', {}).keys())
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        allowed=lok,
+    if not par:
+        msg = "Maybe dvect needs to be flattened?"
+        raise Exception(msg)
+
+    det = {
+        'cents_x': cxi,
+        'cents_y': cyi,
+        'cents_z': czi,
+        'outline_x0': out0,
+        'outline_x1': out1,
+        'nin_x': dvect['nin_x'] if par else dvect['nin_x'][ii],
+        'nin_y': dvect['nin_y'] if par else dvect['nin_y'][ii],
+        'nin_z': dvect['nin_z'] if par else dvect['nin_z'][ii],
+        'e0_x': dvect['e0_x'] if par else dvect['e0_x'][ii],
+        'e0_y': dvect['e0_y'] if par else dvect['e0_y'][ii],
+        'e0_z': dvect['e0_z'] if par else dvect['e0_z'][ii],
+        'e1_x': dvect['e1_x'] if par else dvect['e1_x'][ii],
+        'e1_y': dvect['e1_y'] if par else dvect['e1_y'][ii],
+        'e1_z': dvect['e1_z'] if par else dvect['e1_z'][ii],
+    }
+
+    return det
+
+
+# ###########################################################
+# ###########################################################
+#               Broadband
+# ###########################################################
+
+
+def _vos_broadband(
+    x0=None,
+    x1=None,
+    ind=None,
+    dphi=None,
+    deti=None,
+    lap=None,
+    res=None,
+    config=None,
+    visibility=None,
+    # output
+    key_cam=None,
+    dvos=None,
+    sli=None,
+    ii=None,
+    bool_cross=None,
+    path_hor=None,
+    # timing
+    timing=None,
+    dt1111=None,
+    dt2222=None,
+    dt3333=None,
+    dt4444=None,
+):
+
+    # --------------------------
+    # prepare points and indices
+
+    ir, iz = ind.nonzero()
+    iru = np.unique(ir)
+    izru = [iz[ir == i0] for i0 in iru]
+
+    nphi = np.ceil(x0[ir]*(dphi[1] - dphi[0]) / res).astype(int)
+
+    irf = np.repeat(ir, nphi)
+    izf = np.repeat(iz, nphi)
+    phi = np.concatenate(tuple([
+        np.linspace(dphi[0], dphi[1], nn) for nn in nphi
+    ]))
+
+    xx = x0[irf] * np.cos(phi)
+    yy = x0[irf] * np.sin(phi)
+    zz = x1[izf]
+
+    out = _comp_solidangles.calc_solidangle_apertures(
+        # observation points
+        pts_x=xx,
+        pts_y=yy,
+        pts_z=zz,
+        # polygons
+        apertures=lap,
+        detectors=deti,
+        # possible obstacles
+        config=config,
+        # parameters
+        summed=False,
+        visibility=visibility,
+        return_vector=False,
+        return_flat_pts=None,
+        return_flat_det=None,
+        timing=timing,
     )
 
-    # ---------------------------
-    # get unit vector components
+    # ------------
+    # get indices
 
-    dgeom = coll.dobj['camera'][key]['dgeom']
-    if dgeom['parallel']:
-        dout = {
-            'nin_x': dgeom['nin'][0],
-            'nin_y': dgeom['nin'][1],
-            'nin_z': dgeom['nin'][2],
-            'e0_x':  dgeom['e0'][0],
-            'e0_y':  dgeom['e0'][1],
-            'e0_z':  dgeom['e0'][2],
-            'e1_x':  dgeom['e1'][0],
-            'e1_y':  dgeom['e1'][1],
-            'e1_z':  dgeom['e1'][2],
-        }
+    if timing:
+        t0 = dtm.datetime.now()     # DB
+        out, dt1, dt2, dt3 = out
+
+    for ii, i0 in enumerate(iru):
+        ind0 = irf == i0
+        for i1 in izru[ii]:
+            ind = ind0 & (izf == i1)
+            bool_cross[i0 + 1, i1 + 1] = np.any(out[0, ind] > 0.)
+
+    # timing
+    if timing:
+        dt4444 += (dtm.datetime.now() - t0).total_seconds()
+        dt1111 += dt1
+        dt2222 += dt2
+        dt3333 += dt3
+
+        return dt1111, dt2222, dt3333, dt4444
     else:
-        dout = {
-            'nin_x': coll.ddata[dgeom['nin'][0]]['data'],
-            'nin_y': coll.ddata[dgeom['nin'][1]]['data'],
-            'nin_z': coll.ddata[dgeom['nin'][2]]['data'],
-            'e0_x':  coll.ddata[dgeom['e0'][0]]['data'],
-            'e0_y':  coll.ddata[dgeom['e0'][1]]['data'],
-            'e0_z':  coll.ddata[dgeom['e0'][2]]['data'],
-            'e1_x':  coll.ddata[dgeom['e1'][0]]['data'],
-            'e1_y':  coll.ddata[dgeom['e1'][1]]['data'],
-            'e1_z':  coll.ddata[dgeom['e1'][2]]['data'],
-        }
+        return
 
-    return dout
 
+# ###########################################################
+# ###########################################################
+#               get polygons
+# ###########################################################
 
-def get_camera_cents_xyz(coll=None, key=None):
 
-    # ---------
-    # check key
+def _get_polygons(
+    x0=None,
+    x1=None,
+    bool_cross=None,
+    res=None,
+):
 
-    lok = list(coll.dobj.get('camera', {}).keys())
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        allowed=lok,
+    # ------------
+    # get contour
+
+    contgen = contour_generator(
+        x=x0,
+        y=x1,
+        z=bool_cross,
+        name='serial',
+        corner_mask=None,
+        line_type='Separate',
+        fill_type=None,
+        chunk_size=None,
+        chunk_count=None,
+        total_chunk_count=None,
+        quad_as_tri=True,       # for sub-mesh precision
+        # z_interp=<ZInterp.Linear: 1>,
+        thread_count=0,
     )
 
-    # ---------------------------
-    # get unit vector components
+    no_cont, cj = bs2._class02_contours._get_contours_lvls(
+        contgen=contgen,
+        level=0.5,
+        largest=True,
+    )
 
-    dgeom = coll.dobj['camera'][key]['dgeom']
-    if dgeom['type'] == '1d':
-        cx = coll.ddata[dgeom['cents'][0]]['data']
-        cy = coll.ddata[dgeom['cents'][1]]['data']
-        cz = coll.ddata[dgeom['cents'][2]]['data']
-    else:
-        c0 = coll.ddata[dgeom['cents'][0]]['data']
-        c1 = coll.ddata[dgeom['cents'][1]]['data']
+    assert no_cont is False
 
-        cx = (
-            dgeom['cent'][0]
-            + np.repeat(c0[:, None], c1.size, axis=1) * dgeom['e0'][0]
-            + np.repeat(c1[None, :], c0.size, axis=0) * dgeom['e1'][0]
-        )
-        cy = (
-            dgeom['cent'][1]
-            + np.repeat(c0[:, None], c1.size, axis=1) * dgeom['e0'][1]
-            + np.repeat(c1[None, :], c0.size, axis=0) * dgeom['e1'][1]
-        )
-        cz = (
-            dgeom['cent'][2]
-            + np.repeat(c0[:, None], c1.size, axis=1) * dgeom['e0'][2]
-            + np.repeat(c1[None, :], c0.size, axis=0) * dgeom['e1'][2]
-        )
+    # -------------
+    # simplify poly
+
+    return _simplify_polygon(cj[:, 0], cj[:, 1], res=res)
+
+
+def _simplify_polygon(c0, c1, res=None):
+
+    # -----------
+    # convex hull
+
+    npts = c0.size
+
+    # get hull
+    convh = ConvexHull(np.array([c0, c1]).T)
+    indh = convh.vertices
+    ch0 = c0[indh]
+    ch1 = c1[indh]
+    nh = indh.size
+
+    sign = np.median(np.diff(indh))
+
+    # segments norms
+    seg0 = np.r_[ch0[1:] - ch0[:-1], ch0[0] - ch0[-1]]
+    seg1 = np.r_[ch1[1:] - ch1[:-1], ch1[0] - ch1[-1]]
+    norms = np.sqrt(seg0**2 + seg1**2)
+
+    # keep egdes that match res
+    lind = []
+    for ii, ih in enumerate(indh):
+
+        # ind of points in between
+        i1 = indh[(ii + 1) % nh]
+        if sign > 0:
+            if i1 > ih:
+                ind = np.arange(ih, i1 + 1)
+            else:
+                ind = np.r_[np.arange(ih, npts), np.arange(0, i1 + 1)]
+        else:
+            if i1 < ih:
+                ind = np.arange(ih, i1 - 1, -1)
+            else:
+                ind = np.r_[np.arange(ih, -1, -1), np.arange(npts - 1, i1 - 1, -1)]
+
+        # trivial
+        if ind.size == 2:
+            lind.append((ih, i1))
+            continue
+
+        # get distances
+        x0 = c0[ind]
+        x1 = c1[ind]
+
+        # segment unit vect
+        vect0 = x0 - ch0[ii]
+        vect1 = x1 - ch1[ii]
+
+        # perpendicular distance
+        cross = (vect0*seg1[ii] - vect1*seg0[ii]) / norms[ii]
+
+        # criterion
+        if np.all(np.abs(cross) <= 0.8*res):
+            lind.append((ih, i1))
+        else:
+            lind += _simplify_concave(
+                x0=x0,
+                x1=x1,
+                ind=ind,
+                cross=cross,
+                res=res,
+            )
+
+    # ------------------------------------
+    # point by point on remaining segments
+
+    iok = np.unique(np.concatenate(tuple(lind)))
+
+    return c0[iok], c1[iok]
+
+
+def _simplify_concave(
+    x0=None,
+    x1=None,
+    ind=None,
+    cross=None,
+    res=None,
+):
+
+    # ------------
+    # safety check
+
+    sign = np.sign(cross)
+    sign0 = np.mean(sign)
+    assert np.all(cross * sign0 >= -1e-12)
+
+    # ------------
+    # loop
+
+    i0 = 0
+    i1 = 1
+    iok = 1
+    lind_loc, lind = [], []
+    while iok <= ind.size - 1:
+
+        # reference normalized vector
+        vref0, vref1 = x0[i1] - x0[i0], x1[i1] - x1[i0]
+        normref = np.sqrt(vref0**2 + vref1**2)
+        vref0, vref1 = vref0 / normref, vref1 / normref
+
+        # intermediate vectors
+        indi = np.arange(i0 + 1, i1)
+        v0 = x0[indi] - x0[i0]
+        v1 = x1[indi] - x1[i0]
+
+        # sign and distance (from cross product)
+        cross = v0 * vref1 - v1 * vref0
+        dist = np.abs(cross)
+
+        # conditions
+        c0 = np.all(dist <= 0.8*res)
+        c1 = np.all(cross * sign0 >= -1e-12)
+        c2 = i1 == ind.size - 1
+
+        append = False
+        # cases
+        if c0 and c1 and (not c2):
+            iok = int(i1)
+            i1 += 1
+        elif c0 and c1 and c2:
+            iok = int(i1)
+            append = True
+        elif c0 and (not c1) and (not c2):
+            i1 += 1
+        elif c0 and (not c1) and c2:
+            append = True
+        elif not c0:
+            append = True
+
+        # append
+        if append is True:
+            lind_loc.append((i0, iok))
+            lind.append((ind[i0], ind[iok]))
+            i0 = iok
+            i1 = i0 + 1
+            iok = int(i1)
+
+        if i1 > ind.size - 1:
+            break
+
+    return lind
+
+
+# ###########################################################
+# ###########################################################
+#               store
+# ###########################################################
+
+
+def _store(
+    coll=None,
+    key_diag=None,
+    dvos=None,
+):
+
+    doptics = coll._dobj['diagnostic'][key_diag]['doptics']
+
+    for k0, v0 in dvos.items():
+
+        # re-use previous keys
+        kpc0, kpc1 = doptics[k0]['vos_pcross']
+        kr = coll.ddata[kpc0]['ref'][0]
+
+        # safety check
+        if coll.ddata[kpc0]['data'].shape[1:] != v0['pcross0'].shape[1:]:
+            msg = "Something is wrong"
+            raise Exception(msg)
 
-    return cx, cy, cz
+        coll._dref[kr]['size'] = v0['pcross0'].shape[0]
+        coll._ddata[kpc0]['data'] = v0['pcross0']
+        coll._ddata[kpc1]['data'] = v0['pcross1']
```

### Comparing `tofu-1.6.5/tofu/data/_class7_compute.py` & `tofu-1.7.0/tofu/data/_class8_move.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,517 +1,497 @@
 # -*- coding: utf-8 -*-
 
 
-# Built-in
 import copy
+import itertools as itt
 
-
-# Common
 import numpy as np
+import scipy.interpolate as scpinterp
+import matplotlib.pyplot as plt
+import matplotlib.colors as mcolors
+
+
 import datastock as ds
 
 
-_DPINHOLE = {
-    # center
-    'x': None,
-    'y': None,
-    'R': 3.,
-    'z': 0.,
-    'phi': 0.,
-    # angles
-    'theta': np.pi,
-    'dphi': 0.,
-    'tilt': 0,
-}
+from . import _class7_compute
 
 
-# ##########################################################################
-# ##########################################################################
-#                   Add pinhole camera
-# ##########################################################################
+# ##################################################################
+# ##################################################################
+#             MOVE
+# ##################################################################
 
 
-def add_camera_pinhole(
+def move_to(
     coll=None,
     key=None,
-    key_pinhole=None,
-    key_diag=None,
-    cam_type=None,
-    # position
+    key_cam=None,
+    optics=None,
+    # location
     x=None,
     y=None,
     R=None,
     z=None,
     phi=None,
-    # orientation
     theta=None,
     dphi=None,
     tilt=None,
-    # camera
-    focal=None,
-    pix_nb=None,
-    pix_size=None,
-    pix_spacing=None,
-    # pinhole
-    pinhole_radius=None,
-    pinhole_size=None,
-    # reflections
-    reflections_nb=None,
-    reflections_type=None,
-    # diagnostic
-    compute=None,
-    config=None,
-    length=None,
 ):
 
-    # --------------
+    # ------------
     # check inputs
 
-    key, key_pinhole, key_diag, newdiag = _check_camera_pinhole(
-        coll=coll,
-        key=key,
-        key_pinhole=key_pinhole,
-        key_diag=key_diag,
+    # trivial case
+    nochange = all([ss is None for ss in [x, y, z, R, phi, theta, dphi, tilt]])
+
+    # key, key_cam
+    key, key_cam = coll.get_diagnostic_cam(key=key, key_cam=key_cam)
+    is2d = coll.dobj['diagnostic'][key]['is2d']
+
+    if len(key_cam) != 1:
+        msg = "move_diagnostic_to() can only be used on one camera"
+        raise Exception(msg)
+    key_cam = key_cam[0]
+    doptics = coll.dobj['diagnostic'][key]['doptics'][key_cam]
+
+    # optics
+    lok = [key_cam] + doptics['optics']
+    op_ref = ds._generic_check._check_var(
+        optics, 'optics',
+        types=str,
+        default=doptics['optics'][0],
+        allowed=lok,
+    )
+
+    # get optics, op_cls
+    optics = doptics['optics']
+    op_cls = doptics['cls']
+
+    # ----------------------------------
+    # use the chosen optics center as reference
+
+    if op_ref == key_cam:
+        if is2d:
+            cls_ref = 'camera'
+            cc = coll.dobj[cls_ref][op_ref]['dgeom']['cent']
+            nin = coll.dobj[cls_ref][op_ref]['dgeom']['nin']
+            e0 = coll.dobj[cls_ref][op_ref]['dgeom']['e0']
+            e1 = coll.dobj[cls_ref][op_ref]['dgeom']['e1']
+
+        else:
+            raise NotImplementedError()
+
+    else:
+        cls_ref = op_cls[optics.index(op_ref)]
+        cc = coll.dobj[cls_ref][op_ref]['dgeom']['cent']
+        nin = coll.dobj[cls_ref][op_ref]['dgeom']['nin']
+        e0 = coll.dobj[cls_ref][op_ref]['dgeom']['e0']
+        e1 = coll.dobj[cls_ref][op_ref]['dgeom']['e1']
+
+    # ----------------------------------
+    # get initial local coordinates in this frame
+
+    dinit = _get_initial_parameters(
+        cc=cc,
+        nin=nin,
+        e0=e0,
+        e1=e1,
     )
 
-    # ------------------------
-    # compute pinhole position
+    # ----------------------------------
+    # get all local coordinates in this frame
+
+    dcoords = {}
+
+    # camera
+    if is2d:
+        dcoords[key_cam] = _extract_coords(
+            dg=coll.dobj['camera'][key_cam]['dgeom'],
+            cc=cc,
+            nin=nin,
+            e0=e0,
+            e1=e1,
+        )
+    else:
+        dcoords[key_cam] = _extract_coords_cam1d(
+            coll=coll,
+            key_cam=key_cam,
+            cc=cc,
+            nin=nin,
+            e0=e0,
+            e1=e1,
+        )
+
+    # optics
+    for op, opc in zip(optics, op_cls):
+        dcoords[op] = _extract_coords(
+            dg=coll.dobj[opc][op]['dgeom'],
+            cc=cc,
+            nin=nin,
+            e0=e0,
+            e1=e1,
+        )
+
+    # ----------------------------------
+    # get new default values
 
-    pc, nin, e0, e1 = _pinhole_position(
+    cc_new, nin_new, e0_new, e1_new = _class7_compute._pinhole_position(
         # center
         x=x,
         y=y,
         R=R,
         z=z,
         phi=phi,
         # angles
         theta=theta,
         dphi=dphi,
         tilt=tilt,
+        # default
+        ddef=dinit,
     )
 
-    # ------------------------
-    # compute pinhole contour
+    # ----------------------------------
+    # Update all coordinates
 
-    pin_out0, pin_out1 = _pinhole_contour(
-        pinhole_radius=pinhole_radius,
-        pinhole_size=pinhole_size,
-    )
+    # camera
+    if is2d:
+        reset_coords(
+            coll=coll,
+            op=key_cam,
+            opc='camera',
+            dcoords=dcoords,
+            cc_new=cc_new,
+            nin_new=nin_new,
+            e0_new=e0_new,
+            e1_new=e1_new,
+        )
+    else:
+        reset_coords_cam1d(
+            coll=coll,
+            op=key_cam,
+            opc='camera',
+            dcoords=dcoords,
+            cc_new=cc_new,
+            nin_new=nin_new,
+            e0_new=e0_new,
+            e1_new=e1_new,
+        )
 
-    dgeom_pin = {
-        'cent': pc,
-        'nin': nin,
-        'e0': e0,
-        'e1': e1,
-        'outline_x0': pin_out0,
-        'outline_x1': pin_out1,
-    }
+    # optics
+    for op, opc in zip(optics, op_cls):
+        reset_coords(
+            coll=coll,
+            op=op,
+            opc=opc,
+            dcoords=dcoords,
+            cc_new=cc_new,
+            nin_new=nin_new,
+            e0_new=e0_new,
+            e1_new=e1_new,
+        )
 
-    # ------------------------
-    # compute camera position
+    return
 
-    dgeom_cam, cam_type = _camera_position(
-        dgeom_pin=dgeom_pin,
-        cam_type=cam_type,
-        focal=focal,
-        pix_nb=pix_nb,
-        pix_size=pix_size,
-        pix_spacing=pix_spacing,
-    )
 
-    # -------
-    # store
 
-    _add_camera_pinhole_store(
-        coll=coll,
-        key=key,
-        key_pinhole=key_pinhole,
-        key_diag=key_diag,
-        cam_type=cam_type,
-        dgeom_pin=dgeom_pin,
-        dgeom_cam=dgeom_cam,
-        newdiag=newdiag,
-        # reflections
-        reflections_nb=reflections_nb,
-        reflections_type=reflections_type,
-        compute=compute,
-        config=config,
-        length=length,
-    )
+def _get_initial_parameters(
+    cc=None,
+    nin=None,
+    e0=None,
+    e1=None,
+):
 
+    # cordinates
+    x, y, z = cc
+    R = np.hypot(x, y)
 
-def _check_camera_pinhole(
-    coll=None,
-    key=None,
-    key_pinhole=None,
-    key_diag=None,
-):
-    # key
-    lout = list(coll.dobj.get('camera', {}).keys())
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        excluded=lout,
-    )
+    # angles
+    phi = np.arctan2(y, x)
 
-    # key_pinhole
-    if key_pinhole is None:
-        key_pinhole = f'{key}_pin'
-
-    lout = list(coll.dobj.get('aperture', {}).keys())
-    key_pinhole = ds._generic_check._check_var(
-        key_pinhole, 'key_pinhole',
-        types=str,
-        excluded=lout,
-    )
+    # unit vectors
+    eR = np.r_[np.cos(phi), np.sin(phi), 0.]
+    ephi = np.r_[-np.sin(phi), np.cos(phi), 0.]
 
-    # key_diag
-    if key_diag is not None:
-        lok = list(coll.dobj.get('diagnostic', {}).keys())
-        key_diag = ds._generic_check._check_var(
-            key_diag, 'key_diag',
-            types=str,
-        )
+    # orientation angles: dphi
+    dphi = np.pi/2. - np.arccos(np.sum(nin * ephi))
 
-        newdiag = key_diag not in lok
-    else:
-        newdiag = True
+    # orientation angles: theta
+    ni = nin - np.sum(nin*ephi)*ephi
+    ni = ni / np.linalg.norm(ni)
+    theta = np.arctan2(ni[2], np.sum(ni * eR))
+
+    # orientation: tilt
+    er = np.cos(theta) * eR + np.sin(theta) * np.r_[0, 0, 1]
+    etheta = -np.sin(theta) * eR + np.cos(theta) * np.r_[0, 0, 1]
+    e0bis = -np.cos(dphi) * ephi + np.sin(dphi) * er
+
+    tilt = np.arctan2(np.sum(e0*etheta), np.sum(e0*e0bis))
 
-    return key, key_pinhole, key_diag, newdiag
+    return {
+        'x': x,
+        'y': y,
+        'z': z,
+        'R': R,
+        'phi': phi,
+        'dphi': dphi,
+        'theta': theta,
+        'tilt': tilt,
+    }
 
 
-def _pinhole_position(
-    # center
+def get_new_frame(
+    key_cam=None,
+    dinit=None,
     x=None,
     y=None,
-    R=None,
     z=None,
     phi=None,
-    # angles
-    theta=None,
     dphi=None,
+    theta=None,
     tilt=None,
-    # default
-    ddef=None,
+    # safety check
+    nochange=None,
+    cc=None,
+    nin=None,
+    e0=None,
+    e1=None,
 ):
 
-    # -------------
-    # check inputs
-
-    # ddef
-    if ddef is None:
-        ddef = _DPINHOLE
-
-    # (x, y) vs (R, phi)
-    lc = [
-        x is not None or y is not None,
-        R is not None or phi is not None,
-    ]
-    if np.sum(lc) > 1:
-        msg = "Please provide (x, y) xor (R, phi) !"
-        raise Exception(msg)
-
-    # (x, y) vs (R, phi)
-    if lc[0]:
-        if x is None:
-            x = ddef['x']
-        if y is None:
-            y = ddef['y']
-        R = np.hypot(x, y)
-        phi = np.arctan2(y, x)
-    else:
-        if R is None:
-            R = ddef['R']
-        if phi is None:
-            phi = ddef['phi']
-        x = R * np.cos(phi)
-        y = R * np.sin(phi)
-
-    # z
-    if z is None:
-        z = ddef['z']
-
-    # dphi
-    if dphi is None:
-        dphi = ddef['dphi']
-
-    # theta
-    if theta is None:
-        theta = ddef['theta']
-
-    # tilt
-    if tilt is None:
-        tilt = ddef['tilt']
-
-    # -------------
-    # compute
-
-    # unit vectors of reference
+    # orientation
     eR = np.r_[np.cos(phi), np.sin(phi), 0.]
     ephi = np.r_[-np.sin(phi), np.cos(phi), 0.]
     er = np.cos(theta) * eR + np.sin(theta) * np.r_[0, 0, 1]
     etheta = -np.sin(theta) * eR + np.cos(theta) * np.r_[0, 0, 1]
     e0bis = -np.cos(dphi) * ephi + np.sin(dphi) * er
 
     # translation
-    pc = np.r_[x, y, z]
+    cc_new = np.r_[x, y, z]
 
-    # unit vectors after rotation
-    nin = np.cos(dphi) * er + np.sin(dphi) * ephi
-    e0 = np.cos(tilt) * e0bis + np.sin(tilt) * etheta
-    e1 = np.cross(nin, e0)
+    # new unit vectors
+    nin_new = np.cos(dphi) * er + np.sin(dphi) * ephi
+    e0_new = np.cos(tilt) * e0bis + np.sin(tilt) * etheta
+    e1_new = np.cross(nin_new, e0_new)
 
     # safety check
-    nin, e0, e1 = ds._generic_check._check_vectbasis(
-        e0=nin,
-        e1=e0,
-        e2=e1,
+    nin_new, e0_new, e1_new = ds._generic_check._check_vectbasis(
+        e0=nin_new,
+        e1=e0_new,
+        e2=e1_new,
         dim=3,
         tol=1e-12,
     )
 
-    return pc, nin, e0, e1
-
-
-def _pinhole_contour(
-    pinhole_radius=None,
-    pinhole_size=None,
-):
-
-    # ------
-    # check
-
-    if pinhole_radius is not None and pinhole_size is not None:
-        msg = (
-            "Please provide pinhole_radius xor pinhole_size!\n"
-            "\t- pinhole_radius: created a circular pinhole\n"
-            "\t- pinhole_size: created a rectangular pinhole\n"
-        )
-        raise Exception(msg)
-
-    # ----------
-    # compute
-
-    # circular
-    if pinhole_radius is not None:
+    # safety check
+    if nochange:
+        dout = {}
+        for ss in ['cc', 'nin', 'e0', 'e1']:
+            if not np.allclose(eval(ss), eval(f'{ss}_new')):
+                dout[ss] = (eval(ss), eval(f'{ss}_new'))
+
+        if len(dout) > 0:
+            lstr = [f"\t- '{k0}': {v0[0]} vs {v0[1]}" for k0, v0 in dout.items()]
+            msg = (
+                f"Immobile diagnostic camera '{key_cam}' has moved:\n"
+                + "\n".join(lstr)
+                + f"\n\ndinit = {dinit}"
+            )
+            raise Exception(msg)
+
+    return cc_new, nin_new, e0_new, e1_new
+
+
+def _extract_coords(
+    dg=None,
+    cc=None,
+    nin=None,
+    e0=None,
+    e1=None,
+    ):
+
+    return {
+        'c_n01': np.r_[
+            np.sum((dg['cent'] - cc) * nin),
+            np.sum((dg['cent'] - cc) * e0),
+            np.sum((dg['cent'] - cc) * e1),
+        ],
+        'n_n01': np.r_[
+            np.sum(dg['nin'] * nin),
+            np.sum(dg['nin'] * e0),
+            np.sum(dg['nin'] * e1),
+        ],
+        'e0_n01': np.r_[
+            np.sum(dg['e0'] * nin),
+            np.sum(dg['e0'] * e0),
+            np.sum(dg['e0'] * e1),
+        ],
+        'e1_n01': np.r_[
+            np.sum(dg['e1'] * nin),
+            np.sum(dg['e1'] * e0),
+            np.sum(dg['e1'] * e1),
+        ],
+    }
 
-        # check
-        pinhole_radius = ds._generic_check._check_var(
-            pinhole_radius, 'pinhole_radius',
-            types=(int, float),
-            sign='> 0.',
-        )
-
-        # compute
-        theta = np.pi * np.linspace(-1, 1, 50)[:-1]
-        out0 = pinhole_radius * np.cos(theta)
-        out1 = pinhole_radius * np.sin(theta)
 
+def _extract_coords_cam1d(
+    coll=None,
+    key_cam=None,
+    cc=None,
+    nin=None,
+    e0=None,
+    e1=None,
+    ):
+
+    dout = {}
+    kc = coll.dobj['camera'][key_cam]['dgeom']['cents']
+    parallel = coll.dobj['camera'][key_cam]['dgeom']['parallel']
+
+    # cents 
+    shape = tuple(np.r_[3, coll.ddata[kc[0]]['data'].shape])
+    dout['cents'] = np.zeros(shape)
+    for ss, ii in [('x', 0), ('y', 1), ('z', 2)]:
+        dout['cents'] += np.array([
+            (coll.ddata[kc[ii]]['data'] - cc[ii]) * nin[ii],
+            (coll.ddata[kc[ii]]['data'] - cc[ii]) * e0[ii],
+            (coll.ddata[kc[ii]]['data'] - cc[ii]) * e1[ii],
+        ])
+
+    # unit vectors
+    if parallel:
+        for kk in ['nin', 'e0', 'e1']:
+            dout[f'{kk}_n01'] = np.array([
+                np.sum(coll.dobj['camera'][key_cam]['dgeom'][kk] * nin),
+                np.sum(coll.dobj['camera'][key_cam]['dgeom'][kk] * e0),
+                np.sum(coll.dobj['camera'][key_cam]['dgeom'][kk] * e1),
+            ])
     else:
-        # check
-        if np.isscalar(pinhole_size):
-            pinhole_size = [pinhole_size, pinhole_size]
-
-        pinhole_size = ds._generic_check._check_flat1darray(
-            pinhole_size, 'pinhole_size',
-            dtype=float,
-            size=2,
-            sign='> 0.',
-            norm=False,
-            can_be_None=False,
-        )
-
-        # compute
-        out0 = pinhole_size[0] * np.r_[-1, 1, 1, -1]
-        out1 = pinhole_size[1] * np.r_[-1, -1, 1, 1]
-
-    return out0, out1
-
-def _camera_position(
-    dgeom_pin=None,
-    cam_type=None,
-    focal=None,
-    pix_nb=None,
-    pix_size=None,
-    pix_spacing=None,
-):
+        for kk in ['nin', 'e0', 'e1']:
+            dout[kk] = np.zeros(shape)
+            kv = coll.dobj['camera'][key_cam]['dgeom'][kk]
+            for ss, ii in [('x', 0), ('y', 1), ('z', 2)]:
+                dout[kk] += np.array([
+                    coll.ddata[kv[ii]]['data'] * nin[ii],
+                    coll.ddata[kv[ii]]['data'] * e0[ii],
+                    coll.ddata[kv[ii]]['data'] * e1[ii],
+                ])
+    return dout
 
-    # -------------
-    # check
 
-    # cam_type
-    cam_type = ds._generic_check._check_var(
-        cam_type, 'cam_type',
-        types=str,
-        default='1d',
-        allowed=['1d', '2d'],
-    )
-
-    # cam_type
-    focal = ds._generic_check._check_var(
-        focal,'focal',
-        types=(int, float),
-        default=0.1,
-        sign='>0.',
+def reset_coords(
+    coll=None,
+    op=None,
+    opc=None,
+    dcoords=None,
+    cc_new=None,
+    nin_new=None,
+    e0_new=None,
+    e1_new=None,
+    ):
+
+    if coll._dobj[opc][op]['dgeom']['type'] == '3d':
+        raise NotImplementedError()
+
+    # translate
+    coll._dobj[opc][op]['dgeom']['cent'] = (
+        cc_new
+        + dcoords[op]['c_n01'][0] * nin_new
+        + dcoords[op]['c_n01'][1] * e0_new
+        + dcoords[op]['c_n01'][2] * e1_new
+    )
+
+    # rotate
+    nin = (
+        dcoords[op]['n_n01'][0] * nin_new
+        + dcoords[op]['n_n01'][1] * e0_new
+        + dcoords[op]['n_n01'][2] * e1_new
+    )
+    e0 = (
+        dcoords[op]['e0_n01'][0] * nin_new
+        + dcoords[op]['e0_n01'][1] * e0_new
+        + dcoords[op]['e0_n01'][2] * e1_new
+    )
+    e1 = (
+        dcoords[op]['e1_n01'][0] * nin_new
+        + dcoords[op]['e1_n01'][1] * e0_new
+        + dcoords[op]['e1_n01'][2] * e1_new
     )
 
-    if cam_type == '1d':
-
-        # pix_nb
-        pix_nb = ds._generic_check._check_var(
-            pix_nb, 'pix_nb',
-            types=int,
-            sign='> 0',
-        )
-
-        # pix_spacing
-        pix_spacing = ds._generic_check._check_var(
-            pix_spacing, 'pix_spacing',
-            types=(float, int),
-            default=0,
-            sign='>= 0',
-        )
-
-    else:
+    # --------------
+    # safety check
 
-        # pix_nb
-        if np.isscalar(pix_nb):
-            pix_nb = pix_nb * np.r_[1, 1]
-
-        pix_nb = ds._generic_check._check_flat1darray(
-            pix_nb, 'pix_nb',
-            size=2,
-            dtype=int,
-            sign='> 0',
-        )
-
-        # pix_spacing
-        if pix_spacing is None:
-            pix_spacing = 0.
-        if np.isscalar(pix_spacing):
-            pix_spacing = pix_spacing * np.r_[1, 1]
-
-        pix_spacing = ds._generic_check._check_flat1darray(
-            pix_spacing, 'pix_spacing',
-            size=2,
-            dtype=float,
-            sign='>= 0',
-        )
-
-    # pix_size
-    if np.isscalar(pix_size):
-        pix_size = pix_size * np.r_[1, 1]
-
-    pix_size = ds._generic_check._check_flat1darray(
-        pix_size, 'pix_size',
-        size=2,
-        dtype=float,
-        sign='> 0',
+    nin, e0, e1 = ds._generic_check._check_vectbasis(
+        e0=nin,
+        e1=e0,
+        e2=e1,
+        dim=3,
+        tol=1e-12,
     )
 
-    # ----------
-    # compute
-
-    dgeom_cam = copy.deepcopy(dgeom_pin)
-    cent = dgeom_pin['cent'] - focal * dgeom_pin['nin']
-
-    if cam_type == '1d':
-
-        # vectors
-        for k0 in ['nin', 'e0', 'e1']:
-            for ii, ss in enumerate(['x', 'y', 'z']):
-                dgeom_cam[f'{k0}_{ss}'] = dgeom_cam[k0][ii]
-            del dgeom_cam[k0]
-
-        # cents
-        dd = (pix_size[0] + pix_spacing) * np.arange(0, pix_nb)
-        dd = dd - np.mean(dd)
-        dgeom_cam['cents_x'] = cent[0] + dd * dgeom_pin['e0'][0]
-        dgeom_cam['cents_y'] = cent[1] + dd * dgeom_pin['e0'][1]
-        dgeom_cam['cents_z'] = cent[2] + dd * dgeom_pin['e0'][2]
-        del dgeom_cam['cent']
-
-    else:
-        for ii in [0, 1]:
-            dd = (pix_size[ii] + pix_spacing[ii]) * np.arange(0, pix_nb[ii])
-            dgeom_cam[f'cents_x{ii}'] = dd - np.mean(dd)
-
-        dgeom_cam['cent'] = cent
-
-    # -------------
-    # pixel outline
-
-    dgeom_cam['outline_x0'] = 0.5 * pix_size[0] * np.r_[-1, 1, 1, -1]
-    dgeom_cam['outline_x1'] = 0.5 * pix_size[1] * np.r_[-1, -1, 1, 1]
-
-    return dgeom_cam, cam_type
+    # store
+    coll._dobj[opc][op]['dgeom']['nin'] = nin
+    coll._dobj[opc][op]['dgeom']['e0'] = e0
+    coll._dobj[opc][op]['dgeom']['e1'] = e1
 
 
-def _add_camera_pinhole_store(
+def reset_coords_cam1d(
     coll=None,
-    key=None,
-    key_pinhole=None,
-    key_diag=None,
-    cam_type=None,
-    dgeom_pin=None,
-    dgeom_cam=None,
-    newdiag=None,
-    # reflections
-    reflections_nb=None,
-    reflections_type=None,
-    compute=None,
-    config=None,
-    length=None,
+    op=None,
+    opc=None,
+    dcoords=None,
+    cc_new=None,
+    nin_new=None,
+    e0_new=None,
+    e1_new=None,
 ):
 
-    # compute
-    compute = ds._generic_check._check_var(
-        compute, 'compute',
-        types=bool,
-        default=True,
-    )
+    kc = coll.dobj[opc][op]['dgeom']['cents']
+    parallel = coll.dobj[opc][op]['dgeom']['parallel']
 
-    # pinhole aperture
-    coll.add_aperture(
-        key=key_pinhole,
-        **dgeom_pin,
-    )
+    # cents 
+    for ss, ii in [('x', 0), ('y', 1), ('z', 2)]:
+        coll._ddata[kc[ii]]['data'] = (
+            cc_new[ii]
+            + dcoords[op]['cents'][0] * nin_new[ii]
+            + dcoords[op]['cents'][1] * e0_new[ii]
+            + dcoords[op]['cents'][2] * e1_new[ii]
+        )
 
-    # camera
-    if cam_type == '1d':
-        coll.add_camera_1d(
-            key=key,
-            dgeom=dgeom_cam,
-            dmat=None,
+    # rotate
+    if parallel:
+        nin = (
+            dcoords[op]['nin_n01'][0] * nin_new
+            + dcoords[op]['nin_n01'][1] * e0_new
+            + dcoords[op]['nin_n01'][2] * e1_new
         )
+        e0 = (
+            dcoords[op]['e0_n01'][0] * nin_new
+            + dcoords[op]['e0_n01'][1] * e0_new
+            + dcoords[op]['e0_n01'][2] * e1_new
+        )
+        e1 = (
+            dcoords[op]['e1_n01'][0] * nin_new
+            + dcoords[op]['e1_n01'][1] * e0_new
+            + dcoords[op]['e1_n01'][2] * e1_new
+        )
+
+        # safety check
+        nin, e0, e1 = ds._generic_check._check_vectbasis(
+            e0=nin,
+            e1=e0,
+            e2=e1,
+            dim=3,
+            tol=1e-12,
+        )
+
+        coll._dobj[opc][op]['dgeom']['nin'] = nin
+        coll._dobj[opc][op]['dgeom']['e0'] = e0
+        coll._dobj[opc][op]['dgeom']['e1'] = e1
+
     else:
-        coll.add_camera_2d(
-            key=key,
-            dgeom=dgeom_cam,
-            dmat=None,
-        )
-
-    # doptics
-    doptics = {key: [key_pinhole]}
-
-    # diagnostic
-    if newdiag is False:
-
-        # delete and recreate diagnostic
-        dop = {
-            k0: v0['optics']
-            for k0, v0 in coll._dobj['diagnostic'][key_diag]['doptics'].items()
-        }
-        dop.update(doptics)
-        doptics = dop
-        coll.remove_diagnostic(key=key_diag)
-
-    # create
-    coll.add_diagnostic(
-        key=key_diag,
-        doptics=doptics,
-        reflections_nb=reflections_nb,
-        reflections_type=reflections_type,
-        compute=compute,
-        config=config,
-        length=length,
-    )
+        for kk in ['nin', 'e0', 'e1']:
+            kv = coll.dobj[opc][op]['dgeom'][kk]
+            for ss, ii in [('x', 0), ('y', 1), ('z', 2)]:
+                coll.ddata[kv[ii]]['data'] = (
+                    dcoords[op][kk][0] * nin_new[ii]
+                    + dcoords[op][kk][1] * e0_new[ii]
+                    + dcoords[op][kk][2] * e1_new[ii]
+                )
```

### Comparing `tofu-1.6.5/tofu/data/_class8_check.py` & `tofu-1.7.0/tofu/data/_class8_check.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,32 +6,34 @@
 
 
 import numpy as np
 import matplotlib.colors as mcolors
 import datastock as ds
 
 
-# #############################################################################
-# #############################################################################
-#                           Diagnostics
-# #############################################################################
+# ##################################################################
+# ##################################################################
+#                       Diagnostics
+# ##################################################################
 
 
 def _diagnostics_check(
     coll=None,
     key=None,
     doptics=None,
     stack=None,
 ):
 
     # ----
     # key
 
     key = ds._generic_check._obj_key(
-        d0=coll.dobj.get('diagnostic', {}), short='diag', key=key,
+        d0=coll.dobj.get('diagnostic', {}),
+        short='d',
+        key=key,
     )
 
     # ------
     # doptics
 
     # preliminary checks
     if isinstance(doptics, str):
@@ -193,37 +195,63 @@
         for k0, v0 in doptics.items()
     }
 
     lc = [
         all([v0 for v0 in dspectro.values()]),
         all([not v0 for v0 in dspectro.values()]),
     ]
-    if not any(lc):
+    if np.sum(lc) != 1:
         msg = (
             f"diag '{key}' must be either all spectro or all non-spectro!\n"
             + "\n".join([f"\t- {k0}: {v0}" for k0, v0 in dspectro.items()])
             )
         raise Exception(msg)
 
     spectro = lc[0] is True
 
+    # --------
+    # is PHA
+
+    dPHA = {
+        k0 : coll.dobj['camera'][k0]['dmat']['mode'] == 'PHA'
+        for k0 in lcam
+        if coll.dobj['camera'][k0].get('dmat') is not None
+    }
+
+    if len(dPHA) > 0:
+        lc = [
+            all([v0 for v0 in dPHA.values()]),
+            all([not v0 for v0 in dPHA.values()]),
+        ]
+
+        if np.sum(lc) != 1:
+            msg = (
+                f"diag '{key}' must be either all PHA or all non-PHA!\n"
+                + "\n".join([f"\t- {k0}: {v0}" for k0, v0 in dPHA.items()])
+            )
+            raise Exception(msg)
+
+        PHA = lc[0]
+    else:
+        PHA = False
+
     # -----------------
     # rearrange doptics
 
     doptics2 = {}
     for k0, v0 in doptics.items():
         doptics2[k0] = {
             'camera': k0,
             'los': None,
             'vos': None,
             'etendue': None,
             'etend_type': None,
             'amin': None,
             'amax': None,
-            }
+        }
 
         doptics2[k0]['optics'], doptics2[k0]['cls'] = _get_optics_cls(
             coll=coll,
             optics=v0,
         )
 
     # -----------
@@ -242,29 +270,29 @@
     stack = ds._generic_check._check_var(
         stack, 'stack',
         types=str,
         default='horizontal',
         allowed=['horizontal', 'vertical'],
         )
 
-    return key, lcam, doptics2, is2d, spectro,stack
+    return key, lcam, doptics2, is2d, spectro, stack, PHA
 
 
 def _diagnostics(
     coll=None,
     key=None,
     doptics=None,
     stack=None,
     **kwdargs,
 ):
 
     # ------------
     # check inputs
 
-    key, lcam, doptics, is2d, spectro, stack = _diagnostics_check(
+    key, lcam, doptics, is2d, spectro, stack, PHA = _diagnostics_check(
         coll=coll,
         key=key,
         doptics=doptics,
         stack=stack,
     )
 
     # --------
@@ -275,15 +303,17 @@
             key: {
                 'camera': lcam,
                 'doptics': doptics,
                 'ncam': len(doptics),
                 # 'npix tot.': np.sum(),
                 'is2d': is2d,
                 'spectro': spectro,
+                'PHA': PHA,
                 'stack': stack,
+                'signal': None,
             },
         },
     }
 
     # -----------
     # kwdargs
 
@@ -358,21 +388,18 @@
     # -----------
     # return
 
     cam = coll.dobj['diagnostic'][key]['optics'][0]
     return coll.dobj['camera'][cam]['dgeom']['ref']
 
 
-
-
-
-# ##################################################################
-# ##################################################################
-#                       get optics
-# ##################################################################
+# ################################################################
+# ################################################################
+#                      get optics
+# ################################################################
 
 
 def _get_optics_cls(coll=None, optics=None):
 
     # ---------
     # check key
```

### Comparing `tofu-1.6.5/tofu/data/_class8_compute.py` & `tofu-1.7.0/tofu/data/_class8_compute.py`

 * *Files 3% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 import matplotlib.colors as mcolors
 
 
 import datastock as ds
 
 
 from . import _utils_surface3d
+from . import _spectralunits
 
 
 # ##################################################################
 # ##################################################################
 #                   optics outline
 # ##################################################################
 
@@ -214,14 +215,69 @@
         return p0, p1, px, py, pz
     else:
         return px, py, pz
 
 
 # ##################################################################
 # ##################################################################
+#           optics as input dict for solid angle computation
+# ##################################################################
+
+
+def get_optics_as_input_solid_angle(
+    coll=None,
+    keys=None,
+):
+
+    # ------------
+    # check inputs
+
+    if isinstance(keys, str):
+        keys = [keys]
+
+    lap = list(coll.dobj.get('aperture', {}).keys())
+    lfilt = list(coll.dobj.get('filter', {}).keys())
+    lcryst = list(coll.dobj.get('crystal', {}).keys())
+    lgrat = list(coll.dobj.get('grating', {}).keys())
+
+    lok = lap + lfilt + lcryst + lgrat
+
+    keys = ds._generic_check._check_var_iter(
+        keys, 'keys',
+        types=(list, tuple),
+        types_iter=str,
+        allowed=lok,
+    )
+
+    # -----------
+    # prepare
+
+    # get classes
+    lcls = coll.get_optics_cls(keys)[1]
+
+    # ------------------
+    # build list of dict
+
+    dap = {}
+    for ii, k0 in enumerate(keys):
+
+        poly_x, poly_y, poly_z = coll.get_optics_poly(k0)
+
+        dap[k0] = {
+            'poly_x': poly_x,
+            'poly_y': poly_y,
+            'poly_z': poly_z,
+            'nin': coll.dobj[lcls[ii]][k0]['dgeom']['nin'],
+        }
+
+    return dap
+
+
+# ##################################################################
+# ##################################################################
 #                   Poly interpolation utilities
 # ##################################################################
 
 
 def _interp_poly_check(
     add_points=None,
     mode=None,
@@ -231,15 +287,15 @@
 
     # -------
     # mode
 
     mode = ds._generic_check._check_var(
         mode, 'mode',
         default=None,
-        allowed=[None, 'min'],
+        allowed=[None, 'mean', 'min'],
     )
 
     # ----------
     # add_points
 
     defadd = 1 if mode == 'min' else 0
     add_points = ds._generic_check._check_var(
@@ -309,15 +365,15 @@
                 lp[ii] = np.concatenate((pp, pp[:, 0:1]), axis=1)
             else:
                 lp[ii] = np.append(pp, pp[0])
 
     # -----------
     # mode
 
-    if mode == 'min':
+    if mode is not None:
         if len(lp) == 3:
             dist = np.sqrt(
                 np.diff(lp[0], axis=-1)**2
                 + np.diff(lp[1], axis=-1)**2
                 + np.diff(lp[2], axis=-1)**2
             )
         elif len(lp) == 2:
@@ -326,15 +382,19 @@
                 + np.diff(lp[1], axis=-1)**2
             )
 
         if dist.ndim == 2:
             import pdb; pdb.set_trace()     # DB
 
         min_threshold = min(min_threshold, np.max(dist)/3.)
-        mindist = np.min(dist[dist > min_threshold])
+        if mode == 'min':
+            mindist = np.min(dist[dist > min_threshold])
+        elif mode == 'mean':
+            mindist = np.mean(dist[dist > min_threshold])
+
         add_points = add_points * np.ceil(dist / mindist).astype(int) - 1
 
     # -----------
     # add_points
 
     shape = [pp for pp in lp if pp is not None][0].shape
     nb = shape[-1]
@@ -416,14 +476,15 @@
 
     if isinstance(optics, str):
         optics = [optics]
 
     lok = list(itt.chain.from_iterable([
         [k0] + v0['optics']
         for k0, v0 in coll.dobj['diagnostic'][key]['doptics'].items()
+        if k0 in key_cam
     ]))
     optics = ds._generic_check._check_var_iter(
         optics, 'optics',
         default=lok,
         allowed=lok,
     )
 
@@ -753,14 +814,16 @@
 
 def get_lamb_from_angle(
     coll=None,
     key=None,
     key_cam=None,
     lamb=None,
     rocking_curve=None,
+    units=None,
+    returnas=None,
 ):
     """"""
 
     # ----------
     # check
 
     # key
@@ -786,30 +849,32 @@
 
     kcryst = doptics['optics'][doptics['cls'].index('crystal')]
 
     dok = {
         'lamb': 'alpha',
         'lambmin': 'amin',
         'lambmax': 'amax',
+        'dlamb': 'dlamb',
         'res': 'res',
     }
     lok = list(dok.keys())
     lamb = ds._generic_check._check_var(
         lamb, 'lamb',
         types=str,
         allowed=lok,
     )
 
     # ----------
     # compute
 
     lv = []
+    data = None
     lk = ['lamb', 'lambmin', 'lambmax']
     for kk in lk:
-        if lamb in [kk, 'res']:
+        if lamb in [kk, 'dlamb', 'res']:
 
             if kk == 'lamb':
                 klos = coll.dobj['diagnostic'][key]['doptics'][key_cam]['los']
                 ka = coll.dobj['rays'][klos][dok[kk]]
                 ang = coll.ddata[ka]['data'][0, ...]
                 ref = coll.ddata[ka]['ref'][1:]
             else:
@@ -820,19 +885,45 @@
             dd = coll.get_crystal_bragglamb(
                 key=kcryst,
                 bragg=ang,
                 rocking_curve=rocking_curve,
             )[1]
             if lamb == kk:
                 data = dd
+                break
             else:
                 lv.append(dd)
 
-    if lamb == 'res':
-        data = lv[0] / (lv[2] - lv[1])
+    # ----------------
+    # units conversion
+
+    if units not in [None, 'm']:
+        if data is None:
+
+            for ii in range(3):
+                lv[ii] = _spectralunits.convert_spectral(
+                    data_in=lv[ii],
+                    units_in='m',
+                    units_out=units,
+                )[0]
+
+        else:
+            data = _spectralunits.convert_spectral(
+                data_in=data,
+                units_in='m',
+                units_out=units,
+            )[0]
+
+    # -----------
+    # return
+
+    if lamb == 'dlamb':
+        data = np.abs(lv[2] - lv[1])
+    elif lamb == 'res':
+        data = lv[0] / np.abs(lv[2] - lv[1])
 
     return data, ref
 
 
 # ##################################################################
 # ##################################################################
 #                   get data
@@ -841,50 +932,58 @@
 
 def _get_data(
     coll=None,
     key=None,
     key_cam=None,
     data=None,
     rocking_curve=None,
+    units=None,
     **kwdargs,
-    ):
+):
 
     # key, key_cam
     key, key_cam = coll.get_diagnostic_cam(key=key, key_cam=key_cam)
     spectro = coll.dobj['diagnostic'][key]['spectro']
     # is2d = coll.dobj['diagnostic'][key]['is2d']
 
     # basic check on data
     if data is not None:
         lquant = ['etendue', 'amin', 'amax']  # 'los'
         lcomp = ['length', 'tangency radius', 'alpha']
+        llamb = ['lamb', 'lambmin', 'lambmax', 'dlamb', 'res']
+        lsynth = coll.dobj['diagnostic'][key]['signal']
+        if lsynth is None:
+            lsynth = []
         if spectro:
-            lcomp += ['lamb', 'lambmin', 'lambmax', 'res']
+            lcomp += llamb
 
         data = ds._generic_check._check_var(
             data, 'data',
             types=str,
-            allowed=lquant + lcomp,
+            allowed=lquant + lcomp + lsynth,
         )
 
     # build ddata
     ddata = {}
+    static = True
+    daxis = None
+
     # comp = False
     if data is None or data in lquant:
 
         # --------------------------
         # data is None => kwdargs
 
         if data is None:
             # check kwdargs
             dparam = coll.get_param(which='data', returnas=dict)
             lkout = [k0 for k0 in kwdargs.keys() if k0 not in dparam.keys()]
 
             if len(lkout) > 0:
-                msg= (
+                msg = (
                     "The following args correspond to no data parameter:\n"
                     + "\n".join([f"\t- {k0}" for k0 in lkout])
                 )
                 raise Exception(msg)
 
             # list all available data
             lok = [
@@ -909,14 +1008,15 @@
                 msg = (
                     "There are more / less data identified than cameras:\n"
                     f"\t- key_cam:  {key_cam}\n"
                     f"\t- data cam: {lcam}\n"
                     f"\t- data: {data}"
                 )
                 raise Exception(msg)
+
             elif len(set(lcam)) < len(key_cam):
                 pass
 
             # reorder
             ddata = {
                 cc: lok[lcam.index(cc)]
                 for cc in key_cam if cc in lcam
@@ -950,14 +1050,20 @@
 
         # dref
         dref = {
             k0: coll.ddata[v0]['ref']
             for k0, v0 in ddata.items()
         }
 
+        # units
+        if len(ddata) > 0:
+            units = coll.ddata[ddata[key_cam[0]]]['units']
+        else:
+            units = None
+
         # get actual data
         ddata = {
             k0 : coll.ddata[v0]['data']
             for k0, v0 in ddata.items()
         }
 
     # --------------------
@@ -965,34 +1071,79 @@
 
     elif data in lcomp:
 
         # comp = True
         ddata = {}
         dref = {}
 
-        if data in ['lamb', 'lambmin', 'lambmax', 'res']:
+        if data in llamb:
             for cc in key_cam:
                ddata[cc], dref[cc] = coll.get_diagnostic_lamb(
                    key=key,
                    key_cam=cc,
                    rocking_curve=rocking_curve,
                    lamb=data,
+                   units=units,
                )
+            if data in ['lamb', 'lambmin', 'lambmax', 'dlamb']:
+                units = 'm'
+            else:
+                units = ''
 
         elif data in ['length', 'tangency radius', 'alpha']:
             for cc in key_cam:
                 ddata[cc], _, dref[cc] = coll.get_rays_quantity(
                     key=key,
                     key_cam=cc,
                     quantity=data,
                     segment=-1,
                     lim_to_segments=False,
                 )
+            if data in ['length', 'tangency radius']:
+                units = 'm'
+            else:
+                units = 'rad'
+
+    elif data in lsynth:
+
+        dref = {}
+        daxis = {}
+        dsynth = coll.dobj['synth sig'][data]
+        for cc in key_cam:
+            kdat = dsynth['data'][dsynth['camera'].index(cc)]
+            refcam = coll.dobj['camera'][cc]['dgeom']['ref']
+            ref = coll.ddata[kdat]['ref']
+
+            c0 = (
+                tuple([rr for rr in ref if rr in refcam]) == refcam
+                and len(ref) in [len(refcam), len(refcam) + 1]
+            )
+            if not c0:
+                msg = (
+                    "Can only plot data that is either:\n"
+                    "\t- static: same refs as the camera\n"
+                    "\t- has a unique extra dimension\n"
+                    "Provided:\n"
+                    "\t- refcam: {refcam}\n"
+                    "\t- ['{kdat}']['ref']: {ref}"
+                )
+                raise Exception(msg)
+
+            if len(ref) == len(refcam) + 1:
+                static = False
+                daxis[cc] = [
+                    ii for ii, rr in enumerate(ref) if rr not in refcam
+                ][0]
+
+            ddata[cc] = coll.ddata[kdat]['data']
+            dref[cc] = ref
+
+            units = coll.ddata[kdat]['units']
 
-    return ddata, dref
+    return ddata, dref, units, static, daxis
 
 
 # ##################################################################
 # ##################################################################
 #                   concatenate data
 # ##################################################################
 
@@ -1328,22 +1479,24 @@
     # key_data
     if isinstance(key_data, str):
 
         if key_data in coll.ddata.keys():
             key_data = [key_data]
 
         else:
-            lok = list(coll.dobj['diagnostic'][key].get('dsignal').keys())
+            lok = coll.dobj['diagnostic'][key]['signal']
+            if lok is None:
+                lok = []
             key_data = ds._generic_check._check_var(
                 key_data, 'key_data',
                 types=str,
                 allowed=lok,
             )
 
-            key_data = coll.dobj['diagnostic'][key]['dsignal'][key_data]['data']
+            key_data = coll.dobj['synth sig'][key_data]['data']
 
     # basic check
     c0 = (
         isinstance(key_data, list)
         and all([
             isinstance(kk, str) and kk in coll.ddata.keys()
             for kk in key_data
@@ -1442,28 +1595,28 @@
 
     flat = ds._generic_check._check_var(
         flat, 'flat',
         types=bool,
         default=is2d,
     )
 
-    return key, key_data, is2d, stack, ref, flat
+    return key, key_data, key_cam, is2d, stack, ref, flat
 
 
 def _concatenate_data(
     coll=None,
     key=None,
     key_data=None,
     flat=None,
 ):
 
     # ------------
     # check inputs
 
-    key, key_data, is2d, stack, ref, flat = _concatenate_data_check(
+    key, key_data, key_cam, is2d, stack, ref, flat = _concatenate_data_check(
         coll=coll,
         key=key,
         key_data=key_data,
         flat=flat,
     )
 
     # ------------
@@ -1510,13 +1663,14 @@
         ind = i0 + np.arange(0, npix)
         dind[k0] = ind
         i0 += npix
 
     return {
         'data': data,
         'keys': key_data,
+        'keys_cam': key_cam,
         'units': units,
         'ref': ref,
         'axis': axis,
         'flat': flat,
         'dind': dind,
     }
```

### Comparing `tofu-1.6.5/tofu/data/_class8_compute_signal.py` & `tofu-1.7.0/tofu/data/_class9_compute.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,510 +1,716 @@
+# -*- coding: utf-8 -*-
 
 
-import itertools as itt
+# Built-in
+import copy
+import warnings
 
 
+# Common
 import numpy as np
 import scipy.integrate as scpinteg
 import astropy.units as asunits
-import matplotlib.pyplot as plt     # DB
 
 
 import datastock as ds
 
 
-# ##################################################################
-# ##################################################################
-#               Main routine
-# ##################################################################
+from . import _generic_plot
+
 
+# #############################################################################
+# #############################################################################
+#                           Matrix - compute
+# #############################################################################
 
-def compute_signal(
+
+def compute(
     coll=None,
     key=None,
+    key_bsplines=None,
     key_diag=None,
     key_cam=None,
-    # to be integrated
-    key_integrand=None,
     # sampling
-    method=None,
     res=None,
     mode=None,
-    groupby=None,
-    val_init=None,
-    # signal
+    method=None,
+    crop=None,
+    # options
     brightness=None,
-    # store
+    # output
     store=None,
-    # return
-    returnas=None,
+    verb=None,
 ):
-
-    # -------------
-    # check inputs 
-    # --------------
+    """ Compute the geometry matrix using:
+            - a Plasma2DRect instance with a key to a bspline set
+            - a cam instance with a resolution
+    """
+
+    # -----------
+    # check input
+    # -----------
 
     (
-        key_diag, key_cam, spectro, is2d,
-        method, mode, groupby, val_init, brightness,
-        key_integrand, key_mesh0,
-        store, key,
-        returnas,
-    ) = _compute_signal_check(
+        key,
+        key_bs, key_m, ndim,
+        subkey, key_bs0, key_m0,
+        key_diag, key_cam,
+        radius_max, method, res, mode, crop,
+        brightness,
+        store, verb,
+    ) = _compute_check(
         coll=coll,
+        key=key,
+        key_bsplines=key_bsplines,
         key_diag=key_diag,
         key_cam=key_cam,
         # sampling
         method=method,
         res=res,
         mode=mode,
-        groupby=groupby,
-        val_init=val_init,
-        # signal
+        crop=crop,
+        # options
         brightness=brightness,
-        # to be integrated
-        key_integrand=key_integrand,
-        # store
+        # output
         store=store,
-        key=key,
-        # return
-        returnas=returnas,
+        verb=verb,
     )
 
-    # -------------
-    # prepare 
-    # --------------
+    # -----------
+    # prepare
+    # -----------
 
-    shape_emiss = coll.ddata[key_integrand]['shape']
+    wm = coll._which_mesh
+    wbs = coll._which_bsplines
+    shapebs = coll.dobj[wbs][key_bs]['shape']
 
-    if mode == 'abs':
-        key_kR = coll.dobj['mesh'][key_mesh0]['knots'][0]
-        radius_max = np.max(coll.ddata[key_kR]['data'])
-    else:
-        radius_max = None
+    # prepare indices
+    indbs = coll.select_ind(
+        key=key_bs,
+        returnas=bool,
+        crop=crop,
+    )
 
-    # -------------
-    # compute 
-    # --------------
+    # prepare slicing
+    shape_mat, sli_mat, axis_pix, axis_bs, axis_other = _prepare(
+        coll=coll,
+        indbs=indbs,
+        key_bs0=key_bs0,
+        subkey=subkey,
+    )
+
+    if verb is True:
+        msg = f"Geom matrix for diag '{key_diag}' and bs '{key_bs}':"
+        print(msg)
+
+    # -----------
+    # compute
+    # -----------
 
     if method == 'los':
-        dout, units = _compute_los(
+        dout, axis = _compute_los(
             coll=coll,
-            is2d=is2d,
+            key=key,
+            key_bs=key_bs,
             key_diag=key_diag,
             key_cam=key_cam,
+            # sampling
+            indbs=indbs,
             res=res,
             mode=mode,
-            key_integrand=key_integrand,
             radius_max=radius_max,
-            groupby=groupby,
-            val_init=val_init,
+            # groupby=groupby,
+            shape_mat=shape_mat,
+            sli_mat=sli_mat,
+            axis_pix=axis_pix,
+            # other
             brightness=brightness,
+            verb=verb,
         )
 
     else:
-        pass
+        raise NotImplementedError()
 
-    # -------------
-    # store 
-    # --------------
+    # ---------------
+    # check
+    # ---------------
 
-    if store is True:
+    if axis is None:
+        _no_interaction(
+            coll=coll,
+            key=key,
+            key_bs=key_bs,
+            key_diag=key_diag,
+            key_cam=key_cam,
+        )
+        store = False
+        import pdb; pdb.set_trace() # DB
+
+    # ---------------
+    # store / return
+    # ---------------
+
+    if store:
         _store(
             coll=coll,
             key=key,
+            key_bs=key_bs,
             key_diag=key_diag,
-            dout=dout,
-            key_integrand=key_integrand,
+            key_cam=key_cam,
             method=method,
             res=res,
-            units=units,
+            crop=crop,
+            dout=dout,
+            axis_chan=axis,
+            axis_bs=axis_bs,
+            axis_other=axis_other,
         )
 
-    # -------------
-    # return 
-    # --------------
-
-    if returnas is dict:
+    else:
         return dout
 
 
-# ##################################################################
-# ##################################################################
-#               STORE
-# ##################################################################
+# ###################
+#   checking
+# ###################
 
 
-def _store(
+def _compute_check(
     coll=None,
     key=None,
+    key_bsplines=None,
     key_diag=None,
-    dout=None,
-    units=None,
-    # synthetic signal
-    key_integrand=None,
+    key_cam=None,
+    # sampling
     method=None,
     res=None,
-    # retrofit
-    key_matrix=None,
+    mode=None,
+    crop=None,
+    # options
+    brightness=None,
+    # output
+    store=None,
+    verb=None,
 ):
 
-    # ---------
-    # check
-
-    lc = [key_integrand is not None, key_matrix is not None]
-    if np.sum(lc) != 1:
-        msg = "Please provide key_integrand xor key_matrix"
-        raise Exception(msg)
-
-    typ = 'retrofit' if key_integrand is None else 'synthetic'
-
-    # ---------
-    # prepare
-
-    doptics = coll._dobj['diagnostic'][key_diag]['doptics']
-    dsig = coll._dobj['diagnostic'][key_diag].get('dsignal')
-    if dsig is None:
-        dsig = {}
-
-    lkc = list(dout.keys())
-    lksig = [f'{key}_{k0}' for k0 in lkc]
-
-    # ----------
-    # build dict
+    # --------------
+    # keys
 
-    dsig.update({
-        key: {
-            'type': typ,
-            'camera': lkc,
-            'data': lksig,
-            # synthetic
-            'integrand': key_integrand,
-            'method': method,
-            'res': res,
-            # retrofit
-            'geom matrix': key_matrix,
-        },
-    })
+    wm = coll._which_mesh
+    wbs = coll._which_bsplines
 
-    # ----------
-    # add data
+    # key
+    key = ds._generic_check._obj_key(
+        d0=coll.dobj.get('geom matrix', {}),
+        short='gmat',
+        key=key,
+    )
 
-    for ii, k0 in enumerate(lkc):
+    # key_diag, key_cam
+    key_diag, key_cam = coll.get_diagnostic_cam(
+        key=key_diag,
+        key_cam=key_cam,
+    )
 
-        # add data
-        coll.add_data(
-            key=lksig[ii],
-            data=dout[k0]['data'],
-            ref=dout[k0]['ref'],
-            units=units,
-        )
+    # key_bs
+    lk = list(coll.dobj.get(wbs, {}).keys())
+    key_bs = ds._generic_check._check_var(
+        key_bsplines, 'key_bsplines',
+        types=str,
+        allowed=lk,
+    )
 
-    coll._dobj['diagnostic'][key_diag]['dsignal'] = dsig
+    # key_m
+    key_m = coll.dobj[wbs][key_bs][wm]
+    submesh = coll.dobj[wm][key_m]['submesh']
+    if submesh is not None:
+        key_m0 = submesh
+        key_bs0 = coll.dobj[wm][key_m]['subbs']
+        subkey = coll.dobj[wm][key_m]['subkey'][0]
+    else:
+        key_m0, key_bs0, subkey = None, None, None
 
+    # -------------------
+    # dimensions and axis
 
-# ##################################################################
-#               CHECK
-# ##################################################################
-
+    if submesh is None:
+        key_kR = coll.dobj[wm][key_m]['knots'][0]
+        ndim = len(coll.dobj[wbs][key_bs]['shape'])
+    else:
+        key_kR = coll.dobj[wm][key_m0]['knots'][0]
+        ndim = len(coll.ddata[subkey]['shape'])
 
-def _compute_signal_check(
-    coll=None,
-    key=None,
-    key_diag=None,
-    key_cam=None,
-    # sampling
-    method=None,
-    res=None,
-    mode=None,
-    groupby=None,
-    val_init=None,
-    # signal
-    brightness=None,
-    # to be integrated
-    key_integrand=None,
-    # store
-    store=None,
-    # return
-    returnas=None,
-):
+    radius_max = np.max(coll.ddata[key_kR]['data'])
 
-    # key_diag, key_cam
-    key_diag, key_cam = coll.get_diagnostic_cam(key=key_diag, key_cam=key_cam)
-    spectro = coll.dobj['diagnostic'][key_diag]['spectro']
-    is2d = coll.dobj['diagnostic'][key_diag]['is2d']
+    # --------------
+    # parameters
 
     # method
     method = ds._generic_check._check_var(
         method, 'method',
-        types=str,
         default='los',
-        allowed=['los', 'vos'],
+        types=str,
+        allowed=['los'],
+    )
+
+    # res
+    res = ds._generic_check._check_var(
+        res, 'res',
+        default=0.01,
+        types=float,
+        sign='> 0.',
     )
 
     # mode
     mode = ds._generic_check._check_var(
         mode, 'mode',
-        types=str,
         default='abs',
+        types=str,
         allowed=['abs', 'rel'],
     )
 
-    # groupby
-    groupby = ds._generic_check._check_var(
-        groupby, 'groupby',
-        types=int,
-        default=200,
+    # crop
+    crop = ds._generic_check._check_var(
+        crop, 'crop',
+        default=True,
+        types=bool,
+    )
+    crop = (
+        crop
+        and coll.dobj[wbs][key_bs]['crop'] not in [None, False]
     )
 
     # brightness
     brightness = ds._generic_check._check_var(
         brightness, 'brightness',
         types=bool,
         default=False,
     )
 
-    # key_integrand
-    lok = [
-        k0 for k0, v0 in coll.ddata.items()
-        if v0.get('bsplines') is not None
-    ]
-    key_integrand = ds._generic_check._check_var(
-        key_integrand, 'key_integrand',
-        types=str,
-        allowed=lok,
-    )
-
-    # key_mesh0
-    key_bs = coll.ddata[key_integrand]['bsplines']
-    key_mesh = coll.dobj['bsplines'][key_bs]['mesh']
-    mtype = coll.dobj['mesh'][key_mesh]['type']
-    if mtype == 'polar':
-        key_mesh0 = coll.dobj['mesh'][key_mesh]['submesh']
-    else:
-        key_mesh0 = key_mesh
-
-    # val_init
-    val_init = ds._generic_check._check_var(
-        val_init, 'val_init',
-        default=np.nan,
-        allowed=[np.nan, 0.]
-    )
-
     # store
     store = ds._generic_check._check_var(
         store, 'store',
-        types=bool,
         default=True,
+        types=bool,
     )
 
-    # key
-    lsig = list(coll.dobj['diagnostic'][key_diag].get('dsignal', {}).keys())
-    lout = list(coll.ddata.keys()) + lsig
-    key = ds._generic_check._check_var(
-        key, 'key',
-        types=str,
-        default=f'{key_diag}_synth',
-        excluded=lout,
-    )
-
-    # returnas
-    returnas = ds._generic_check._check_var(
-        returnas, 'returnas',
-        default=False if store is True else dict,
-        allowed=[dict, False],
-    )
+    # verb
+    if verb is None:
+        verb = True
+    if not isinstance(verb, bool):
+        msg = (
+            f"Arg verb must be a bool!\n"
+            f"\t- provided: {verb}"
+        )
+        raise Exception(msg)
 
     return (
-        key_diag, key_cam, spectro, is2d,
-        method, mode, groupby, val_init, brightness,
-        key_integrand, key_mesh0,
-        store, key,
-        returnas,
+        key,
+        key_bs, key_m, ndim,
+        subkey, key_bs0, key_m0,
+        key_diag, key_cam,
+        radius_max, method, res, mode, crop,
+        brightness,
+        store, verb,
     )
 
 
-# ##################################################################
-# ##################################################################
-#               LOS
-# ##################################################################
+# ###################
+#   prepare
+# ###################
+
+
+def _prepare(
+    coll=None,
+    indbs=None,
+    key_bs0=None,
+    subkey=None,
+):
+
+    # shapes
+    nbs = indbs.sum()
+    nchan = None        # depends on cam
+
+    # cases
+    wbs = coll._which_bsplines
+    if subkey is None:
+        shape_mat = (nchan, nbs)
+
+        sli_mat = [None, slice(None)]
+        axis_pix = 0
+        axis_other = None
+
+    else:
+        sh = list(coll.ddata[subkey]['shape'])
+        ref = coll.ddata[subkey]['ref']
+        refbs = coll.dobj[wbs][key_bs0]['ref']
+
+        for ii, rr in enumerate(refbs):
+            if ii == 0:
+                axis_pix = ref.index(rr)
+            else:
+                axis_bs = ref.index(rr)
+
+        axis_other = [ii for ii, rr in enumerate(ref) if rr not in refbs]
+        if len(axis_other) == 1:
+            axis_other = axis_other[0]
+            sh[axis_pix] = nchan
+            sh[axis_bs] = nbs
+            shape_mat = tuple(sh)
+
+            sli_mat = [None, None, None]
+            sli_mat[axis_bs] = slice(None)
+            sli_mat[axis_other] = slice(None)
+        else:
+            shape_mat = (nchan, nbs)
+
+            sli_mat = [None, slice(None)]
+            axis_pix = 0
+            axis_other = None
+
+    axis_bs = axis_pix + 1
+
+    return shape_mat, sli_mat, axis_pix, axis_bs, axis_other
+
+
+# ###################
+#   compute_los
+# ###################
 
 
 def _compute_los(
     coll=None,
-    is2d=None,
+    key=None,
+    key_bs=None,
     key_diag=None,
     key_cam=None,
+    # sampling
+    indbs=None,
     res=None,
     mode=None,
     key_integrand=None,
     radius_max=None,
-    groupby=None,
-    val_init=None,
+    is3d=None,
+    # slicing
+    shape_mat=None,
+    sli_mat=None,
+    axis_pix=None,
+    # parameters
     brightness=None,
+    verb=None,
 ):
 
+    # -----
+    # units
+
+    units = asunits.m
+    units_coefs = asunits.Unit()
+
     # ----------------
     # loop on cameras
 
     dout = {}
     doptics = coll.dobj['diagnostic'][key_diag]['doptics']
     for k0 in key_cam:
 
         npix = coll.dobj['camera'][k0]['dgeom']['pix_nb']
         key_los = doptics[k0]['los']
+        key_mat = f'{key}_{k0}'
 
-        ngroup = npix // groupby
-        if groupby * ngroup < npix:
-            ngroup += 1
+        sh = tuple([npix if ss is None else ss for ss in shape_mat])
+        mat = np.zeros(sh, dtype=float)
 
         # -----------------------
         # loop on group of pixels (to limit memory footprint)
 
-        for ii in range(ngroup):
+        anyok = False
+        for ii in range(npix):
 
-            i0 = ii*groupby
-            i1 = min((ii + 1)*groupby, npix)
-            ni = i1 - i0
+            # verb
+            if verb is True:
+                msg = f"\t- '{key_mat}': pixel {ii + 1} / {npix}"
+                msg += f"\t{(mat > 0).sum()} / {mat.size}"
+                end = '\n' if ii == npix - 1 else '\r'
+                print(msg, flush=True, end=end)
 
-            R, Z, length = coll.sample_rays(
+            # sample los
+            out_sample = coll.sample_rays(
                 key=key_los,
                 res=res,
                 mode=mode,
                 segment=None,
-                ind_flat=np.arange(i0, i1),
+                ind_flat=ii,
                 radius_max=radius_max,
-                concatenate=True,
+                concatenate=False,
                 return_coords=['R', 'z', 'ltot'],
             )
 
-            inan = np.isnan(R)
-            inannb = np.r_[-1, inan.nonzero()[0]]
-            nnan = inan.sum()
-            assert nnan == ni, f"{nnan} vs {ni}"
-            iok = ~inan
+            if out_sample is None:
+                continue
+
+            R, Z, length = out_sample
 
             # -------------
             # interpolate
 
-            datai, units, refi = coll.interpolate_profile2d(
-                key=key_integrand,
-                R=R,
-                Z=Z,
+            # datai, units, refi = coll.interpolate(
+            douti = coll.interpolate(
+                keys=None,
+                ref_key=key_bs,
+                x0=R[0],
+                x1=Z[0],
+                submesh=True,
                 grid=False,
-                radius_vs_time=None,
-                azone=None,
-                t=None,
-                indt=None,
-                indt_strict=None,
-                indbs=None,
-                details=False,
-                reshape=None,
+                # azone=None,
+                indbs_tf=indbs,
+                details=True,
                 crop=None,
                 nan0=True,
                 val_out=np.nan,
                 return_params=False,
                 store=False,
-            )
+            )[f'{key_bs}_details']
 
+            datai, refi = douti['data'], douti['ref']
             axis = refi.index(None)
-            if ii == 0:
-                shape = list(datai.shape)
-                shape[axis] = npix
-                data = np.full(shape, val_init)
-                ref = list(refi)
+            iok = np.isfinite(datai)
+
+            if not np.any(iok):
+                continue
+
+            datai[~iok] = 0.
 
             # ------------
             # integrate
 
-            iok2 = np.isfinite(datai)
-            sli0 = [slice(None) for aa in range(len(refi))]
-            for jj in range(nnan):
-
-                # slice datai
-                indi = np.arange(inannb[jj]+1, inannb[jj+1])
-                sli0[axis] = indi
-                slii = tuple(sli0)
-                if not np.any(iok2[slii]):
-                    continue
-
-                # set nan to 0 for integration
-                dataii = datai[slii]
-                dataii[~iok2[slii]] = 0.
-
-                # slice data
-                ind = i0 + jj
-                sli0[axis] = ind
-                sli = tuple(sli0)
-
-                # if jj in [50, 51]:
-                    # plt.figure();
-                    # plt.subplot(1,2,1)
-                    # plt.plot(dataii)
-                    # plt.subplot(1,2,2)
-                    # plt.plot(dataii.T)
-                    # plt.gcf().suptitle(f"jj = {jj}", size=12)
-
-                # integrate
-                data[sli] = scpinteg.simpson(
-                    dataii,
-                    x=length[indi],
-                    axis=axis,
-                )
+            # check and update slice
+            assert datai.ndim in [2, 3], datai.shape
+            sli_mat[axis_pix] = ii
+
+            # integrate
+            mat[tuple(sli_mat)] = scpinteg.simpson(
+                datai,
+                x=length[0],
+                axis=axis,
+            )
+
+            anyok = True
 
         # --------------
         # post-treatment
 
-        # brightness
-        if brightness is False:
-            ketend = doptics[k0]['etendue']
-            etend = coll.ddata[ketend]['data']
-            sh_etend = [-1 if aa == axis else 1 for aa in range(len(refi))]
-            data *= etend.reshape(sh_etend)
-
-        # reshape if 2d
-        if is2d:
-            sh_data = list(data.shape)
-            sh_data[axis] = coll.dobj['camera'][k0]['dgeom']['shape']
-            sh_data = tuple(np.r_[
-                sh_data[:axis], sh_data[axis], sh_data[axis+1:]
-            ].astype(int))
-            data = data.reshape(sh_data)
-
-        # set ref
-        ref[axis] = coll.dobj['camera'][k0]['dgeom']['ref']
-        ref = tuple(np.r_[ref[:axis], ref[axis], ref[axis+1:]])
+        if anyok:
+            # brightness
+            if brightness is False:
+                ketend = doptics[k0]['etendue']
+                units_coefs = coll.ddata[ketend]['units']
+                etend = coll.ddata[ketend]['data']
+                sh_etend = [-1 if aa == axis else 1 for aa in range(len(refi))]
+                mat *= etend.reshape(sh_etend)
+
+            # set ref
+            refi = list(refi)
+            refi[axis] = coll.dobj['camera'][k0]['dgeom']['ref_flat']
+            refi = tuple(np.r_[refi[:axis], refi[axis], refi[axis+1:]])
+
+        else:
+            refi = None
+            axis = None
 
         # fill dout
-        dout[k0] = {
-            'data': data,
-            'ref': ref,
+        dout[key_mat] = {
+            'data': mat,
+            'ref': refi,
+            'units': units * units_coefs,
         }
 
-    # -----
-    # units
+    return dout, axis
 
-    units0 = coll.ddata[key_integrand]['units']
-    units = units0 * asunits.m
-    if brightness is False:
-        units = units * coll.ddata[ketend]['units']
 
-    return dout, units
+# ###################
+#   compute_vos
+# ###################
+
+
+def _compute_vos(
+    coll=None,
+    is2d=None,
+    key_diag=None,
+    key_cam=None,
+    res=None,
+    mode=None,
+    key_integrand=None,
+    radius_max=None,
+    groupby=None,
+    val_init=None,
+    brightness=None,
+):
+
+
+
+    return None, None
+
+
+# ###################
+#   storing
+# ###################
+
+
+def _store(
+    coll=None,
+    key=None,
+    key_bs=None,
+    key_diag=None,
+    key_cam=None,
+    method=None,
+    res=None,
+    crop=None,
+    dout=None,
+    axis_chan=None,
+    axis_bs=None,
+    axis_other=None,
+):
+
+    # shapes
+    shapes = [v0['data'].shape for v0 in dout.values()]
+    assert all([len(ss) == len(shapes[0]) for ss in shapes[1:]])
+    shapes = np.array(shapes)
+    assert np.allclose(shapes[1:, :axis_chan], shapes[0:1, :axis_chan])
+    assert np.allclose(shapes[1:, axis_bs:], shapes[0:1, axis_bs:])
+
+    # add matrix obj
+    dobj = {
+        'geom matrix': {
+            key: {
+                'data': list(dout.keys()),
+                'bsplines': key_bs,
+                'diagnostic': key_diag,
+                'camera': key_cam,
+                'method': method,
+                'res': res,
+                'crop': crop,
+                'shape': tuple(shapes[0, :]),
+                'axis_chan': axis_chan,
+                'axis_bs': axis_bs,
+                'axis_other': axis_other,
+            },
+        },
+    }
+
+    coll.update(ddata=dout, dobj=dobj)
 
 
 # ##################################################################
 # ##################################################################
-#               VOS
+#               retrofit
 # ##################################################################
 
 
-def _compute_vos(
+def _concatenate(
+    coll=None,
+    key=None,
+):
+
+    # ------------
+    # check inputs
+
+    lok = list(coll.dobj.get('geom matrix', {}).keys())
+    key = ds._generic_check._check_var(
+        key, 'key',
+        types=str,
+        allowed=lok,
+    )
+
+    # -----------
+    # concatenate
+
+    key_data = coll.dobj['geom matrix'][key]['data']
+    key_cam = coll.dobj['geom matrix'][key]['camera']
+    axis = coll.dobj['geom matrix'][key]['axis_chan']
+
+    ref = list(coll.ddata[key_data[0]]['ref'])
+    ref[axis] = None
+
+    ind = 0
+    dind = {}
+    ldata = []
+    for ii, k0 in enumerate(key_cam):
+        datai = coll.ddata[key_data[ii]]['data']
+        dind[k0] = ind + np.arange(0, datai.shape[axis])
+        ldata.append(datai)
+        ind += datai.shape[axis]
+
+    data = np.concatenate(ldata, axis=axis)
+
+    return data, ref, dind
+
+
+# ###################
+#   no interaction
+# ###################
+
+
+def _no_interaction(
     coll=None,
+    key=None,
+    key_bs=None,
+    key_diag=None,
     key_cam=None,
-    res=None,
-    mode=None,
-    key_integrand=None,
 ):
 
-    dout = None
+    # ----------
+    # plot
+
+    wm = coll._which_mesh
+    wbs = coll._which_bsplines
+    keym = coll.dobj[wbs][key_bs][wm]
+    submesh = coll.dobj[wm][keym]['submesh']
 
-    return dout
+    is2d = coll.dobj['diagnostic'][key_diag]['is2d']
+
+    # prepare dax
+    dax0 = _generic_plot.get_dax_diag(
+        proj=['cross', 'hor', '3d', 'camera'],
+        dmargin=None,
+        fs=None,
+        wintit=None,
+        tit='debug',
+        is2d=is2d,
+        key_cam=key_cam,
+    )
+
+    # mesh
+    if submesh is None:
+        dax = coll.plot_mesh(
+            key=keym,
+            dax={'cross': dax0['cross']},
+            crop=True,
+        )
+
+    else:
+        dax = coll.plot_mesh(
+            key=submesh,
+            dax={'cross': dax0['cross']},
+            crop=True,
+        )
+
+        dax = coll.plot_mesh(keym)
+
+    # cam
+    dax = coll.plot_diagnostic(
+        key=key_diag,
+        key_cam=key_cam,
+        elements='o',
+        dax=dax0,
+    )
+
+    # -----
+    # msg
+
+    msg = (
+        "No interaction detected between:\n"
+        f"\t- camera: {key_cam}\n"
+        f"\t- bsplines: {key_bs}\n"
+        f"\t- submesh: {submesh}\n"
+    )
+    warnings.warn(msg)
```

### Comparing `tofu-1.6.5/tofu/data/_class8_equivalent_apertures.py` & `tofu-1.7.0/tofu/data/_class8_equivalent_apertures.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 
 import numpy as np
 import scipy.interpolate as scpinterp
 import matplotlib.pyplot as plt
 
 
 import Polygon as plg
-from Polygon import Utils as plgUtils
+# from Polygon import Utils as plgUtils
+from scipy.spatial import ConvexHull
 import datastock as ds
 
 
 from . import _class5_projections
 from . import _class8_compute as _compute
 
 
@@ -119,15 +120,15 @@
     ]
 
     # pts2pts func
     if spectro:
         pts2pt = coll.get_optics_reflect_pts2pt(key=kref)
     else:
         pts2pt = None
-        
+
     # ptsvect func
     ptsvect = coll.get_optics_reflect_ptsvect(key=kref)
     lptsvect_poly = [
         coll.get_optics_reflect_ptsvect(key=oo)
         for oo in lop_post
     ]
 
@@ -144,16 +145,27 @@
     x1 = []
 
     # ---------------
     # loop on pixels
 
     # dt = np.zeros((14,), dtype=float)
 
+    # add pts to initial polygon only if curved
+    if spectro:
+        rcurv = np.r_[coll.dobj[cref][kref]['dgeom']['curve_r']]
+        ind = ~np.isinf(rcurv)
+        if np.any(rcurv[ind] > 0):
+            addp0 = add_points
+        else:
+            addp0 = False
+    else:
+        addp0 = False
+
     # intial polygon
-    p_a = coll.get_optics_outline(key=kref, add_points=False)
+    p_a = coll.get_optics_outline(key=kref, add_points=addp0)
     p_a = plg.Polygon(np.array([p_a[0], p_a[1]]).T)
 
     iok = np.ones((pixel.size,), dtype=bool)
 
     for ii, ij in enumerate(pixel):
 
         if verb is True:
@@ -181,45 +193,52 @@
             # timing
             # dt=dt,
         )
 
         # convex hull
         if p0 is None or p0.size == 0:
             iok[ii] = False
+
         elif convex:
-            p0, p1 = np.array(plgUtils.convexHull(
-                plg.Polygon(np.array([p0, p1]).T)
-            ).contour(0)).T
+            # p0, p1 = np.array(plgUtils.convexHull(
+                # plg.Polygon(np.array([p0, p1]).T)
+            # ).contour(0)).T
+            vert = ConvexHull(np.array([p0, p1]).T).vertices
+            p0, p1 = p0[vert], p1[vert]
 
             p0, p1 = _compute._interp_poly(
                 lp=[p0, p1],
                 add_points=add_points,
-                mode='min',
+                mode='mean',
                 isclosed=False,
                 closed=False,
                 ravel=True,
                 min_threshold=1.e-5,
             )
 
         # append
         x0.append(p0)
         x1.append(p1)
 
-    # --------------------
-    # harmonize if necessary
-    # --------------------
+    # -------------------------------------------
+    # harmonize if necessary the initial polygons
+    # -------------------------------------------
 
     if harmonize:
+
         ln = [p0.size if p0 is not None else 0 for p0 in x0]
         nmax = np.max(ln)
         nan = np.full((nmax,), np.nan)
+
         for ii in range(pixel.size):
-            if x0[ii] is None:
+
+            if ln[ii] == 0:
                 x0[ii] = nan
                 x1[ii] = nan
+
             elif ln[ii] < nmax:
                 ndif = nmax - ln[ii]
                 irand = np.random.random(ndif)
                 irand = irand + np.random.randint(0, ln[ii]-1, ndif)
                 imax = np.sort(np.r_[np.arange(0, ln[ii]), irand])
                 imax = np.linspace(0, ln[ii]-1, nmax)
                 x0[ii] = scpinterp.interp1d(
@@ -459,18 +478,19 @@
         default=3,
         sign='>0',
     )
 
     # -----------
     # convex
 
+    isconvex = any(coll.get_optics_isconvex(doptics['optics']))
     convex = ds._generic_check._check_var(
         convex, 'convex',
         types=bool,
-        default=True,
+        default=isconvex,
     )
 
     # -----------
     # harmonnize
 
     harmonize = ds._generic_check._check_var(
         harmonize, 'harmonize',
@@ -551,15 +571,15 @@
     p_a=None,
     pt=None,
     nop_pre=None,
     lpoly_pre=None,
     ptsvect=None,
     **kwdargs,
 ):
-    
+
     # loop on optics
     for jj in range(nop_pre):
 
         # project on reference frame
         p0, p1 = ptsvect(
             pts_x=pt[0],
             pts_y=pt[1],
@@ -667,44 +687,47 @@
             # print('\t \t None 0')
             return p0, p1
 
         if np.all([p_a.isInside(xx, yy) for xx, yy in zip(p0, p1)]):
             # print('inside: ', p1)
             # plt.figure()
             # plt.plot(
-            #     np.array(p_a.contour(0))[:, 0],
-            #     np.array(p_a.contour(0))[:, 1], 
-            #     '.-k',
-            #     p0, p1, '.-r'
-            #     )
+                # np.array(p_a.contour(0))[:, 0],
+                # np.array(p_a.contour(0))[:, 1],
+                # '.-k',
+                # p0, p1, '.-r'
+            # )
             p_a = plg.Polygon(np.array([p0, p1]).T)
         else:
             # convex hull
             if convex:
-                p0, p1 = np.array(plgUtils.convexHull(
-                    plg.Polygon(np.array([p0, p1]).T)
-                ).contour(0)).T
+                # p0, p1 = np.array(plgUtils.convexHull(
+                    # plg.Polygon(np.array([p0, p1]).T)
+                # ).contour(0)).T
+                vert = ConvexHull(np.array([p0, p1]).T).vertices
+                p0, p1 = p0[vert], p1[vert]
 
             # plt.figure()
             # plt.plot(
-            #     np.array(p_a.contour(0))[:, 0],
-            #     np.array(p_a.contour(0))[:, 1], 
-            #     '.-k',
-            #     p0, p1, '.-r'
-            #     )
+                # np.array(p_a.contour(0))[:, 0],
+                # np.array(p_a.contour(0))[:, 1],
+                # '.-k',
+                # p0, p1, '.-r'
+            # )
+            # import pdb; pdb.set_trace()     # DB
 
             # intersection
             p_a = p_a & plg.Polygon(np.array([p0, p1]).T)
             if p_a.nPoints() < 3:
                 # print('\t \t None 1')       # DB
                 return None, None
 
             # update
             p0, p1 = np.array(p_a.contour(0)).T
-            
+
             # interpolate
             if jj < nop_post - 1:
                 p0, p1 = _compute._interp_poly(
                     lp=[p0, p1],
                     add_points=add_points,
                     mode='min',
                     isclosed=False,
@@ -742,18 +765,18 @@
 
     ax.set_title(tit)
     ax.set_xlabel(xlab)
     ax.set_ylabel(ylab)
 
     i0 = np.r_[np.arange(0, poly_x0.size), 0]
     ax.plot(poly_x0[i0], poly_x1[i0], '.-k')
-    
+
     if p0.shape[1] > 0:
         i1 = np.r_[np.arange(0, p0.shape[1]), 0]
         for ii in range(p0.shape[0]):
             ax.plot(p0[ii, i1], p1[ii, i1], '.-', label=f'pix {ii}')
 
     if cents0 is not None:
         ax.plot(cents0, cents1, 'xr')
-        
+
     ax.legend()
     return
```

### Comparing `tofu-1.6.5/tofu/data/_class8_etendue_los.py` & `tofu-1.7.0/tofu/data/_class8_etendue_los.py`

 * *Files 3% similar despite different names*

```diff
@@ -15,31 +15,34 @@
 
 from ..geom import _comp_solidangles
 
 
 __all__ = ['compute_etendue_los']
 
 
-# ##################################################################
-# ##################################################################
+# ###############################################################
+# ###############################################################
 #                       Main
-# ##################################################################
+# ###############################################################
 
 
 def compute_etendue_los(
     coll=None,
     key=None,
     # parameters
     analytical=None,
     numerical=None,
     res=None,
     margin_par=None,
     margin_perp=None,
     # options
     add_points=None,
+    # spectro-only
+    rocking_curve_fw=None,
+    rocking_curve_max=None,
     # bool
     convex=None,
     check=None,
     verb=None,
     plot=None,
     store=None,
 ):
@@ -58,15 +61,15 @@
         res,
         margin_par,
         margin_perp,
         check,
         verb,
         plot,
         store,
-    ) = _diag_compute_etendue_check(
+    ) = _check(
         coll=coll,
         key=key,
         analytical=analytical,
         numerical=numerical,
         res=res,
         margin_par=margin_par,
         margin_perp=margin_perp,
@@ -105,26 +108,46 @@
             # plot
             plot=False,
             verb=verb,
             store=False,
             return_for_etendue=True,
         )
 
+        # ------------------------
+        # spectro => rocking curve
+
+        if spectro:
+            dmat = coll.dobj['crystal'][kref]['dmat']
+            if rocking_curve_fw is None:
+                if dmat.get('drock') is not None:
+                    rocking_curve_fw = dmat['drock']['FW']
+                else:
+                    rocking_curve_fw = np.inf
+
+            if rocking_curve_max is None:
+                if dmat.get('drock') is not None:
+                    kpow = dmat['drock']['power_ratio']
+                    rocking_curve_max = np.max(coll.ddata[kpow]['data'])
+                else:
+                    rocking_curve_max = 1.
+
         # ------------------------------------------
-        # get distance, area, solid_angle, los, dlos
+        # get distance, area, solid_angle, los
 
         (
             det_area, distances,
             los_x, los_y, los_z,
-            dlos_x, dlos_y, dlos_z,
             cos_los_det, cos_los_ap, solid_angles, res,
         ) = _loop_on_pix(
             coll=coll,
             ldet=v0['ldet'],
+            # spectro
             spectro=spectro,
+            rocking_curve_fw=rocking_curve_fw,
+            rocking_curve_max=rocking_curve_max,
             # optics
             x0=x0,
             x1=x1,
             px=px,
             py=py,
             pz=pz,
             iok=iok,
@@ -180,106 +203,106 @@
             )
 
         else:
             etend1 = None
 
         # --------------------
         # optional plotting
-    
+
         if plot is True:
             dax = _plot_etendues(
                 etend0=etend0,
                 etend1=etend1,
                 res=res,
             )
-    
+
         # --------
         # reshape
-    
+
         # etend0
         if etend0 is not None and is2d:
             etend0 = etend0.reshape(tuple(np.r_[3, v0['shape0']]))
-    
+
         # etend1
         if etend1 is not None and is2d:
             etend1 = etend1.reshape(tuple(np.r_[res.size, v0['shape0']]))
-    
+
         # los
         if los_x.shape != v0['shape0']:
             los_x = los_x.reshape(v0['shape0'])
             los_y = los_y.reshape(v0['shape0'])
             los_z = los_z.reshape(v0['shape0'])
 
         # --------------------
         # return dict
-    
+
         dcompute[key_cam].update({
             'analytical': etend0,
             'numerical': etend1,
             'res': res,
             'kref': kref,
             'los_x': los_x,
             'los_y': los_y,
             'los_z': los_z,
-            'dlos_x': dlos_x,
-            'dlos_y': dlos_y,
-            'dlos_z': dlos_z,
+            'spectro': spectro,
             'iok': iok,
             'is2d': is2d,
             'cx': cx,
             'cy': cy,
             'cz': cz,
+            'x0': x0,
+            'x1': x1,
         })
 
     # ----------
     # store
 
     if store is not False:
 
         for key_cam, v0 in dcompute.items():
-        
+
             # ref
             ref = coll.dobj['camera'][key_cam]['dgeom']['ref']
-    
+
             # data
             etendue = v0[store][-1, ...]
-    
+
             if store == 'analytical':
                 etend_type = store
             else:
                 etend_type = v0['res'][-1]
-    
+
             # keys
             ketendue = f'{key}_{key_cam}_etend'
             ddata = {
                 ketendue: {
                     'data': etendue,
                     'ref': ref,
                     'dim': 'etendue',
                     'quant': 'etendue',
                     'name': 'etendue',
                     'units': 'm2.sr',
                 },
             }
-            
+
             coll.update(ddata=ddata)
-    
+
             coll._dobj['diagnostic'][key]['doptics'][key_cam]['etendue'] = ketendue
             coll._dobj['diagnostic'][key]['doptics'][key_cam]['etend_type'] = etend_type
 
     return dcompute, store
 
 
-# ##################################################################
-# ##################################################################
+# ################################################################
+# ################################################################
 #                       Check
-# ##################################################################
+# ################################################################
 
 
-def _diag_compute_etendue_check(
+def _check(
     coll=None,
     key=None,
     analytical=None,
     numerical=None,
     res=None,
     margin_par=None,
     margin_perp=None,
@@ -323,21 +346,22 @@
         dvect = coll.get_camera_unit_vectors(key=k0)
         outline = dgeom['outline']
         out0 = coll.ddata[outline[0]]['data']
         out1 = coll.ddata[outline[1]]['data']
         is2d = dgeom['type'] == '2d'
         par = dgeom['parallel']
         dcompute[k0]['shape0'] = cx.shape
-    
+
         if is2d:
             cx = cx.ravel()
             cy = cy.ravel()
             cz = cz.ravel()
+
         nd = cx.size
-    
+
         dcompute[k0]['ldet'] = [
             {
                 'cents_x': cx[ii],
                 'cents_y': cy[ii],
                 'cents_z': cz[ii],
                 'outline_x0': out0,
                 'outline_x1': out1,
@@ -461,15 +485,18 @@
 # ##################################################################
 
 
 def _loop_on_pix(
     coll=None,
     # detectors
     ldet=None,
+    # spectro
     spectro=None,
+    rocking_curve_fw=None,
+    rocking_curve_max=None,
     # equivalent aperture
     x0=None,
     x1=None,
     px=None,
     py=None,
     pz=None,
     iok=None,
@@ -500,14 +527,27 @@
 
     nd = x0.shape[0]
     for ii in range(nd):
 
         if not iok[ii]:
             continue
 
+        # rocking curve
+        if spectro:
+            out0 = ldet[ii]['outline_x0']
+            width0 = np.max(np.abs(np.diff(out0)))
+            dist = np.sqrt(
+                (centsx[ii] - ldet[ii]['cents_x'])**2
+                + (centsy[ii] - ldet[ii]['cents_y'])**2
+                + (centsz[ii] - ldet[ii]['cents_z'])**2
+            )
+            withrc = dist * rocking_curve_fw
+            out0_norm = out0 / width0
+            ldet[ii]['outline_x0'] = out0_norm * min(width0, withrc)
+
         # ------------
         # solid angles
 
         solid_angles[ii] = _comp_solidangles.calc_solidangle_apertures(
             # observation points
             pts_x=centsx[ii],
             pts_y=centsy[ii],
@@ -516,42 +556,37 @@
             apertures=None,
             detectors=ldet[ii],
             # possible obstacles
             config=None,
             # parameters
             visibility=False,
             return_vector=False,
+            # timing
+            timing=False,
         )[0, 0]
 
+    # -----------
+    # rocking curve
+
+    if spectro:
+        solid_angles *= rocking_curve_max
+
     # -------------
     # normalize los
 
     los_x = centsx - cx
     los_y = centsy - cy
     los_z = centsz - cz
 
     distances = np.sqrt(los_x**2 + los_y**2 + los_z**2)
 
     los_x = los_x / distances
     los_y = los_y / distances
     los_z = los_z / distances
 
-    if spectro:
-        dlos_x = px - cx[:, None]
-        dlos_y = py - cy[:, None]
-        dlos_z = pz - cz[:, None]
-        ddist = np.sqrt(dlos_x**2 + dlos_y**2 + dlos_z**2)
-        dlos_x = dlos_x / ddist
-        dlos_y = dlos_y / ddist
-        dlos_z = dlos_z / ddist
-    else:
-        dlos_x = None
-        dlos_y = None
-        dlos_z = None
-
     # ------
     # angles
 
     for ii in range(nd):
         cos_los_det[ii] = (
             los_x[ii] * ldet[ii]['nin_x']
             + los_y[ii] * ldet[ii]['nin_y']
@@ -578,15 +613,17 @@
         det_area = ldet[0]['pix_area']
 
     # -------------------------------------
     # det outline discretization resolution
 
     if res is None:
 
-        res = min(np.sqrt(det_area), np.nanmin(mindiff))
+        res = np.sqrt(det_area)
+        if np.any(np.isfinite(mindiff)):
+            res = min(res, np.nanmin(mindiff))
         if np.any(ap_area > 0.):
             res = min(res, np.sqrt(np.min(ap_area[ap_area > 0.])))
 
         res = res * np.r_[1., 0.5, 0.1]
 
     iok = np.isfinite(res)
     iok[iok] = res[iok] > 0
@@ -594,15 +631,14 @@
         res = np.r_[0.001]
     else:
         res = res[iok]
 
     return (
         det_area, distances,
         los_x, los_y, los_z,
-        dlos_x, dlos_y, dlos_z,
         cos_los_det, cos_los_ap, solid_angles, res,
     )
 
 
 # ##################################################################
 # ##################################################################
 #                   op_post interpolation
@@ -626,14 +662,15 @@
         else:
             px, py, pz = dgeom['poly']
             lpoly_post.append((
                 coll.ddata[px]['data'],
                 coll.ddata[py]['data'],
                 coll.ddata[pz]['data'],
             ))
+
     return lpoly_post
 
 
 # ##################################################################
 # ##################################################################
 #           Numerical etendue estimation routine
 # ##################################################################
```

### Comparing `tofu-1.6.5/tofu/data/_class8_los_data.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_real0.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,522 +1,571 @@
-# -*- coding: utf-8 -*-
+"""
+Creating and using diagnostic
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
+"""
 
 import numpy as np
-import matplotlib.pyplot as plt
-import matplotlib.colors as mcolors
 
 
-import datastock as ds
+import tofu as tf
 
 
-from ..geom._comp_solidangles import calc_solidangle_apertures
+__all__ = ['main']
 
 
-# ##################################################################
-# ##################################################################
-#             solid angles from any points
-# ##################################################################
+# #####################################################
+# #####################################################
+#           Main
+# #####################################################
 
 
-def compute_solid_angles(
-    coll=None,
-    key=None,
-    key_cam=None,
-    # pts
-    ptsx=None,
-    ptsy=None,
-    ptsz=None,
-    # options
-    config=None,
-    visibility=None,
-    # return
-    return_vect=None,
-    return_alpha=None,
-):
-    # ---------
-    # check
+def main():
+
+    # ------------------------
+    # create plasma
+
+    conf, coll = _create_plasma()
+
+    # ------------------------
+    # add several diagnostics
+
+    # add broadband
+    _add_broadband(coll, conf)
+
+    # add 2d camera
+    # _add_2d(coll, conf)
+
+    # add PHA
+    # _add_PHA(coll, conf)
+
+    # add spectrometer
+    # _add_spectrometer(coll, conf) # , crystals=['c0'])
+
+    # ------------------------
+    # compute synthetic signal
+
+    # _compute_synth_signal(coll) # , ldiag=['diag00'])
+
+    # ------------------
+    # geometry matrices
+
+    # ----------
+    # inversions
+
+    return conf, coll
+
+
+# #####################################################
+# #####################################################
+#           Routines - PLasma
+# #####################################################
+
+
+def _create_plasma():
+
+    # -----------------
+    # load a simple geometry
+
+    conf = tf.load_config('WEST-V0')
+
+    # -----------------
+    # Instanciate a collection
+
+    coll = tf.data.Collection()
+
+    # -----------------
+    # add a rect mesh with 2d bsplines
 
-    (
-        key, key_cam, spectro,
-        ptsx, ptsy, ptsz, shape0_pts,
-        return_vect, return_alpha,
-    ) = _compute_solid_angles_check(
-        coll=coll,
-        key=key,
-        key_cam=key_cam,
-        # pts
-        ptsx=ptsx,
-        ptsy=ptsy,
-        ptsz=ptsz,
-        # return
-        return_vect=return_vect,
-        return_alpha=return_alpha,
-    )
-
-    # -----------
-    # prepare
-
-    if spectro:
-        raise NotImplementedError()
-
-    else:
-
-        dout = _compute_solid_angles_regular(
-            coll=coll,
-            key=key,
-            key_cam=key_cam,
-            # pts
-            ptsx=ptsx,
-            ptsy=ptsy,
-            ptsz=ptsz,
-            shape0_pts=shape0_pts,
-            # options
-            config=config,
-            visibility=visibility,
-            # return
-            return_vect=return_vect,
+    coll.add_mesh_2d_rect(
+        key='m0',
+        res=0.1,
+        crop_poly=conf,
+        units='m',
+        deg=1,
+    )
+
+    # --------
+    # add time
+
+    nt = 11
+    t = np.linspace(0, 10, nt)
+
+    coll.add_ref('nt', nt)
+    coll.add_data('t', data=t, ref='nt', units='s', dime='time')
+
+    # ------------------
+    # add a spectra mesh
+
+    nE = 100
+    E = np.linspace(1000, 30000, nE)
+
+    coll.add_mesh_1d(
+        key='mE',
+        knots=E,
+        deg=1,
+        units='eV',
+    )
+
+    # ---------------------
+    # get shape of bs coefs to set a time-vaying 2d radius
+
+    kapR, kapZ = coll.dobj['bsplines']['m0_bs1']['apex']
+    apR = coll.ddata[kapR]['data']
+    apZ = coll.ddata[kapZ]['data']
+
+    # rho2d
+    rho2d = (
+        (1 + 0.1*np.cos(t[:, None, None]))
+        * (1. - np.exp(
+            -(apR[None, :, None]-2.5)**2/0.4**2
+            -(apZ[None, None, :]-0)**2/0.6**2
+        ))
+    )
+
+    coll.add_data(
+        'rho2d',
+        data=rho2d,
+        ref=('nt', 'm0_bs1'),
+        units='',
+    )
+
+    # add 1d radial mesh based on rho2d
+    nrho = 20
+    rho = np.linspace(0, 1, nrho)
+    coll.add_mesh_1d(
+        key='mr',
+        knots=rho,
+        units='',
+        subkey='rho2d',
+        deg=1,
+    )
+
+    # emiss1dE
+    r0 = (0. + np.exp(-rho**2/0.4**2)[None, :, None])
+    r1 = np.exp(-(rho-0.3)**2/0.15**2)[None, :, None]
+    emiss1dE = (
+        (1 + 0.1*np.cos(t[:, None, None]))
+        * (
+            r0 * (0.1 + np.exp(-E/10000))[None, None, :]
+            + r1 * np.exp(-(E-15000)**2/1000**2)[None, None, :]
         )
+    )
+
+    coll.add_data(
+        'emiss1d',
+        data=np.sum(emiss1dE, axis=-1),
+        ref=('nt', 'mr_bs1'),
+        units='ph/(m3.s.sr)',
+    )
+
+    # emiss1dE
+    coll.add_data(
+        'emiss1dE',
+        data=emiss1dE,
+        ref=('nt', 'mr_bs1', 'mE_bs1'),
+        units='ph/(m3.s.sr.eV)',
+    )
+
+    # emiss2dE
+    r0 = (0. + np.exp(-rho2d**2/0.4**2)[:, :, :, None])
+    r1 = np.exp(-(rho2d-0.3)**2/0.15**2)[:, :, :, None]
+    emiss2dE = (
+        (1 + 0.1*np.cos(t[:, None, None, None]))
+        * (
+            r0 * (1. + np.exp(-E/10000))[None, None, None, :]
+            + r1 * np.exp(-(E-15000)**2/1000**2)[None, None, None, :]
+        )
+    )
+
+    coll.add_data(
+        'emiss2dE',
+        data=emiss2dE,
+        ref=('nt', 'm0_bs1', 'mE_bs1'),
+        units='ph/(m3.s.sr.eV)',
+    )
+
+    return conf, coll
+
 
-    return dout
+# #####################################################
+# #####################################################
+#           Routines - Diags
+# #####################################################
 
 
-def _compute_solid_angles_check(
+def _add_broadband(
     coll=None,
-    key=None,
-    key_cam=None,
-    # pts
-    ptsx=None,
-    ptsy=None,
-    ptsz=None,
-    # options
-    config=None,
-    visibility=None,
-    # return
-    return_vect=None,
-    return_alpha=None,
+    conf=None,
 ):
-    # ---------
-    # check
 
-    # key_cam
-    key, key_cam = coll.get_diagnostic_cam(key=key, key_cam=key_cam)
-    spectro = coll.dobj['diagnostic'][key]['spectro']
-
-    # pts
-    ptsx = np.atleast_1d(ptsx)
-    ptsy = np.atleast_1d(ptsy)
-    ptsz = np.atleast_1d(ptsz)
-
-    if not (ptsx.shape == ptsy.shape == ptsz.shape):
-        msg = (
-            "Args ptsx, ptsy, ptsz must be 3 np.ndarray of the same shape!"
-        )
-        raise Exception(msg)
+    # ---------------------
+    # add 2 pinhole cameras
 
-    shape0_pts = ptsx.shape
-    if ptsx.ndim > 1:
-        ptsx = ptsx.ravel()
-        ptsy = ptsy.ravel()
-        ptsz = ptsz.ravel()
+    coll.add_camera_pinhole(
+        key='bb0',
+        key_pinhole=None,
+        key_diag='d0',
+        cam_type='1d',
+        R=3.2,
+        z=-0.5,
+        phi=0,
+        theta=3.*np.pi/4,
+        dphi=np.pi/10,
+        tilt=np.pi/2,
+        focal=0.1,
+        pix_nb=10,
+        pix_size=3e-3,
+        pix_spacing=5e-3,
+        pinhole_radius=None,
+        pinhole_size=[1e-3, 1e-3],
+        reflections_nb=0,
+        reflections_type=None,
+        compute=False,
+        config=conf,
+    )
 
-    # return_vect
-    return_vect = ds._generic_check._check_var(
-        return_vect, 'return_vect',
-        types=bool,
-        default=False,
+    coll.add_camera_pinhole(
+        key='bb1',
+        key_pinhole=None,
+        key_diag='d0',
+        cam_type='1d',
+        R=3.2,
+        z=0.5,
+        phi=0,
+        theta=-3.*np.pi/4,
+        dphi=np.pi/10,
+        tilt=np.pi/2,
+        focal=0.1,
+        pix_nb=10,
+        pix_size=3e-3,
+        pix_spacing=5e-3,
+        pinhole_radius=None,
+        pinhole_size=[1e-3, 1e-3],
+        reflections_nb=0,
+        reflections_type=None,
+        compute=True,
+        config=conf,
     )
 
-    # return_alpha
-    return_alpha = ds._generic_check._check_var(
-        return_alpha, 'return_alpha',
-        types=bool,
-        default=False,
+    return
+
+
+def _add_2d(
+    coll=None,
+    conf=None,
+):
+
+    # ---------------------
+    # add 2 pinhole cameras
+
+    coll.add_camera_pinhole(
+        key='c2d',
+        key_diag='d1',
+        key_pinhole=None,
+        cam_type='2d',
+        R=3.2,
+        z=-0.5,
+        phi=0,
+        theta=3.*np.pi/4,
+        dphi=np.pi/10,
+        tilt=np.pi/2,
+        focal=0.1,
+        pix_nb=15,
+        pix_size=3e-3,
+        pix_spacing=5e-3,
+        pinhole_radius=1e-2,
+        pinhole_size=None,
+        reflections_nb=0,
+        reflections_type=None,
+        compute=True,
+        config=conf,
     )
 
-    return (
-        key, key_cam, spectro,
-        ptsx, ptsy, ptsz, shape0_pts,
-        return_vect, return_alpha,
+
+def _add_PHA(
+    coll=None,
+    conf=None,
+):
+
+    nEb = 14
+    Ebins = np.linspace(4000, 20000, nEb)
+
+    # Single pinhole cam
+    coll.add_camera_pinhole(
+        key='pha0',
+        key_pinhole=None,
+        key_diag='d2',
+        cam_type='1d',
+        R=5,
+        z=0,
+        phi=0,
+        theta=np.pi,
+        dphi=0,
+        tilt=0,
+        focal=0.1,
+        pix_nb=5,
+        pix_size=1e-2,
+        pix_spacing=0,
+        pinhole_radius=1e-3,
+        pinhole_size=None,
+        reflections_nb=0,
+        reflections_type=None,
+        compute=True,
+        config=conf,
+        dmat={'bins': Ebins},
     )
 
+    return
+
 
-def _compute_solid_angles_regular(
+def _add_spectrometer(
     coll=None,
-    key=None,
-    key_cam=None,
-    # pts
-    ptsx=None,
-    ptsy=None,
-    ptsz=None,
-    shape0_pts=None,
-    # options
-    config=None,
-    visibility=None,
-    # return
-    return_vect=None,
+    conf=None,
+    crystals=None,
 ):
 
-    doptics = coll.dobj['diagnostic'][key]['doptics']
-    dout = {k0: {} for k0 in key_cam}
+    # ------------------
+    # add crystal optics
 
-    for k0 in key_cam:
+    doptics = {}
+    dcrystals = _crystals(coll, crystals=crystals)
 
-        # prepare apertures
-        dap = {}
-        for op, opc in zip(doptics[k0]['optics'], doptics[k0]['cls']):
-            dg = coll.dobj[opc][op]['dgeom']
-            if dg['type'] == '3d':
-                px, py, pz = dg['poly_x'], dg['poly_y'], dg['poly_z']
-            else:
-                cc = dg['cent']
-                out0, out1 = dg['outline']
-                out0, out1 = coll.ddata[out0]['data'], coll.ddata[out1]['data']
-                px = cc[0] + out0*dg['e0'][0] + out1*dg['e1'][0]
-                py = cc[1] + out0*dg['e0'][1] + out1*dg['e1'][1]
-                pz = cc[2] + out0*dg['e0'][2] + out1*dg['e1'][2]
-
-            dap[op] = {
-                'nin': dg['nin'],
-                'poly_x': px,
-                'poly_y': py,
-                'poly_z': pz,
-            }
-
-        # prepare camera
-        dg = coll.dobj['camera'][k0]['dgeom']
-        ddet = {}
-
-        # cents
-        cx, cy, cz = coll.get_camera_cents_xyz(k0)
-        npts = cx.size
-        sh = cx.shape
-        ddet['cents_x'] = cx
-        ddet['cents_y'] = cy
-        ddet['cents_z'] = cz
-
-        # vectors
-        ddet.update(coll.get_camera_unit_vectors(k0))
-        for k1 in ['nin', 'e0', 'e1']:
-            for ii, ss in enumerate(['x', 'y', 'z']):
-                kk = f'{k1}_{ss}'
-                if np.isscalar(ddet[kk]):
-                    ddet[kk] = np.full(sh, ddet[kk])
-
-        out0, out1 = dg['outline']
-        out0, out1 = coll.ddata[out0]['data'], coll.ddata[out1]['data']
-        ddet['outline_x0'] = out0
-        ddet['outline_x1'] = out1
+    # ----------------------
+    # add camera / apertures
 
-        # compute
-        out = calc_solidangle_apertures(
-            # observation points
-            pts_x=ptsx,
-            pts_y=ptsy,
-            pts_z=ptsz,
-            # polygons
-            apertures=dap,
-            detectors=ddet,
-            # possible obstacles
-            config=config,
+    for k0, v0 in dcrystals.items():
+
+        loptics = coll.get_crystal_ideal_configuration(
+            key=k0,
+            configuration=v0['configuration'],
             # parameters
-            summed=False,
-            visibility=visibility,
-            return_vector=return_vect,
-            return_flat_pts=True,
-            return_flat_det=None,
+            cam_on_e0=False,
+            cam_tangential=True,
+            cam_dimensions=[5e-2, 3e-2],
+            pinhole_distance=2.,
+            # store
+            store=True,
+            key_cam=f'{k0}_cam',
+            aperture_dimensions=[100e-6, 1e-2],
+            pinhole_radius=100e-6,
+            cam_pixels_nb=[10, 5],
+            # returnas
+            returnas=list,
         )
 
-        # store
-        if return_vect is True:
-            dout[k0]['solid_angle'] = out[0]
-            dout[k0]['vectx'] = out[1]
-            dout[k0]['vecty'] = out[2]
-            dout[k0]['vectz'] = out[3]
-        else:
-            dout[k0]['solid_angle'] = out
+        # add diag
+        gtype = coll.dobj['crystal'][k0]['dgeom']['type']
+        if gtype not in ['toroidal']:
+            doptics.update({
+                k0: loptics,
+            })
+
+    # ------------------
+    # add diagnostic
+
+    for k0, v0 in doptics.items():
+        coll.add_diagnostic(
+            doptics=v0,
+            config=conf,
+            compute=True,
+            add_points=3,
+            rocking_curve_fwhm=0.0001*np.pi/180,
+            # rocking_curve_fwhm=None,
+        )
 
-        # reshape
-        if shape0_pts != ptsx.shape:
-            shape = tuple(np.r_[dout[k0]['solid_angle'].shape, shape0_pts])
-            for k1, v1 in dout[k0].items():
-                dout[k0][k1] = v1.reshape(shape)
+    return
 
-    return dout
 
+def _crystals(coll=None, crystals=None):
 
-# ##################################################################
-# ##################################################################
-#             interpolated along los
-# ##################################################################
+    # -------
+    # check
 
+    if crystals is None:
+        crystals = ['c0', 'c1', 'c2']
 
-def _interpolated_along_los(
-    coll=None,
-    key=None,
-    key_cam=None,
-    key_data_x=None,
-    key_data_y=None,
-    # sampling
-    res=None,
-    mode=None,
-    segment=None,
-    radius_max=None,
-    # plotting
-    vmin=None,
-    vmax=None,
-    plot=None,
-    dcolor=None,
-    dax=None,
-    ):
+    # -------
+    # geom
 
-    # ------------
-    # check inputs
+    start, vect, v0, v1 = _ref_line(start=np.r_[7, 0., 0.001])
 
-    # key_cam
-    key, key_cam = coll.get_diagnostic_cam(key=key, key_cam=key_cam)
+    # cryst0: planar
+    cent = start + 0. * vect
+
+    nin, e0, e1 = _nine0e1_from_orientations(
+        vect=vect,
+        v0=v0,
+        v1=v1,
+        theta=-np.pi/4,
+        phi=0.,
+    )
+
+    dc = {}
+
+    # c1: cylindrical (von hamos)
+    if 'c0' in crystals:
+        size = 1.e-2
+        rc = 2.
+        c0 = {
+            'key': 'c0',
+            'dgeom': {
+                'cent': cent,
+                'nin': nin,
+                'e0': e0,
+                'e1': e1,
+                'extenthalf': size * np.r_[1, 1/rc],
+                'curve_r': [np.inf, rc],
+            },
+            'dmat': 'Quartz_110',
+            'configuration': 'von hamos',
+        }
+        dc['c0'] = c0
+        coll.add_crystal(c0['key'], dgeom=c0['dgeom'], dmat=c0['dmat'])
+
+    # c3: cylindrical (convex)
+    if 'c1' in crystals:
+        rc = 2.
+        ang = np.linspace(-0.0001, 0.0005, 100)
+        c1 = {
+            'key': 'c1',
+            'dgeom': {
+                'cent': cent,
+                'nin': nin,
+                'e0': e0,
+                'e1': e1,
+                'extenthalf': size * np.r_[1/rc, 1],
+                'curve_r': [-rc, np.inf],
+            },
+            'dmat': {
+                'target': {'lamb': 3.94e-10},
+                'd_hkl': 2.45652e-10,
+                'drock': {
+                    'angle_rel': ang,
+                    'power_ratio': np.exp(-(ang-0.00025)**2/0.0001**2),
+                },
+            },
+            'configuration': 'pinhole',
+        }
+        dc['c1'] = c1
+        coll.add_crystal(c1['key'], dgeom=c1['dgeom'], dmat=c1['dmat'])
+
+    # c2: spherical
+    if 'c2' in crystals:
+        rc = 2.
+        c2 = {
+            'key': 'c2',
+            'dgeom': {
+                'cent': cent,
+                'nin': nin,
+                'e0': e0,
+                'e1': e1,
+                'extenthalf': size * np.r_[1 / rc, 1 / rc],
+                'curve_r': rc,
+            },
+            'dmat': 'Quartz_110',
+            'configuration': 'johann',
+        }
+        dc['c2'] = c2
+        coll.add_crystal(c2['key'], dgeom=c2['dgeom'], dmat=c2['dmat'])
+
+    return dc
+
+
+def _ref_line(start=np.r_[4, 0, 0], vect=np.r_[-1, 0, 0]):
+
+    vect = vect / np.linalg.norm(vect)
+
+    v0 = np.r_[-vect[1], vect[0], 0.]
+    v0 = v0 / np.linalg.norm(v0)
+
+    v1 = np.cross(vect, v0)
+
+    return start, vect, v0, v1
+
+
+def _nine0e1_from_orientations(
+    vect=None,
+    v0=None,
+    v1=None,
+    theta=None,
+    phi=None,
+):
+
+    nin = (
+        vect * np.cos(theta)
+        + np.sin(theta) * (np.cos(phi) * v0 + np.sin(phi) * v1)
+    )
+
+    e0 = (
+        - vect * np.sin(theta)
+        + np.cos(theta) * (np.cos(phi) * v0 + np.sin(phi) * v1)
+    )
+
+    e1 = np.cross(nin, e0)
+
+    return nin, e0, e1
 
-    # key_data
-    lok_coords = [
-        'x', 'y', 'z', 'R', 'phi', 'ang_vs_ephi',
-        'k', 'l', 'ltot', 'itot',
-    ]
-    lok_2d = [
-        k0 for k0, v0 in coll.ddata.items()
-        if v0.get('bsplines') is not None
-    ]
-
-    key_data_x = ds._generic_check._check_var(
-        key_data_x, 'key_data_x',
-        types=str,
-        default='k',
-        allowed=lok_coords + lok_2d,
-    )
-
-    key_data_y = ds._generic_check._check_var(
-        key_data_y, 'key_data_y',
-        types=str,
-        default='k',
-        allowed=lok_coords + lok_2d,
-    )
-
-    # segment
-    segment = ds._generic_check._check_var(
-        segment, 'segment',
-        types=int,
-        default=-1,
-    )
-
-    # plot
-    plot = ds._generic_check._check_var(
-        plot, 'plot',
-        types=bool,
-        default=True,
-    )
-
-    # dcolor
-    if not isinstance(dcolor, dict):
-        if dcolor is None:
-            lc = ['k', 'r', 'g', 'b', 'm', 'c']
-        elif mcolors.is_color_like(dcolor):
-            lc = [dcolor]
-
-        dcolor = {
-            kk: lc[ii%len(lc)]
-            for ii, kk in enumerate(key_cam)
-            }
-
-    # --------------
-    # prepare output
-
-    ncam = len(key_cam)
-
-    xx = [None for ii in range(ncam)]
-    yy = [None for ii in range(ncam)]
-
-    # ---------------
-    # loop on cameras
-
-    if key_data_x in lok_coords and key_data_y in lok_coords:
-
-        for ii, kk in enumerate(key_cam):
-
-            klos = coll.dobj['diagnostic'][key]['doptics'][kk]['los']
-            if klos is None:
-                continue
-
-            xx[ii], yy[ii] = coll.sample_rays(
-                key=klos,
-                res=res,
-                mode=mode,
-                segment=segment,
-                radius_max=radius_max,
-                concatenate=True,
-                return_coords=[key_data_x, key_data_y],
-                )
-
-            if key_data_x in ['x', 'y', 'z', 'R', 'l', 'ltot']:
-                xlab = f"{key_data_x} (m)"
-            else:
-                xlab = key_data_x
-
-            if key_data_y in ['x', 'y', 'z', 'R', 'l', 'ltot']:
-                ylab = f"{key_data_y} (m)"
-            else:
-                ylab = key_data_y
-
-    elif key_data_x in lok_coords or key_data_y in lok_coords:
-
-        if key_data_x in lok_coords:
-            cll = key_data_x
-            c2d = key_data_y
-            if key_data_x in ['x', 'y', 'z', 'R', 'l', 'ltot']:
-                xlab = f"{key_data_x} (m)"
-            else:
-                xlab = key_data_x
-            ylab = f"{key_data_y} ({coll.ddata[key_data_y]['units']})"
-        else:
-            cll = key_data_y
-            c2d = key_data_x
-            if key_data_y in ['x', 'y', 'z', 'R', 'l', 'ltot']:
-                ylab = f"{key_data_y} (m)"
-            else:
-                ylab = key_data_y
-            xlab = f"{key_data_x} ({coll.ddata[key_data_x]['units']})"
-
-        for ii, kk in enumerate(key_cam):
-
-            klos = coll.dobj['diagnostic'][key]['doptics'][kk]['los']
-            if klos is None:
-                continue
-
-            pts_x, pts_y, pts_z, pts_ll = coll.sample_rays(
-                key=klos,
-                res=res,
-                mode=mode,
-                segment=segment,
-                radius_max=radius_max,
-                concatenate=True,
-                return_coords=['x', 'y', 'z', cll],
-                )
-
-            Ri = np.hypot(pts_x, pts_y)
-
-            q2d, _ = coll.interpolate_profile2d(
-                key=c2d,
-                R=Ri,
-                Z=pts_z,
-                grid=False,
-                crop=True,
-                nan0=True,
-                val_out=True,
-                imshow=False,
-                return_params=None,
-                store=False,
-                inplace=False,
-            )
-
-            isok = ~(np.isnan(q2d) & (~np.isnan(Ri)))
-            if key_data_x in lok_coords:
-                xx[ii] = pts_ll[isok]
-                yy[ii] = q2d[isok]
-            else:
-                xx[ii] = q2d[isok]
-                yy[ii] = pts_ll[isok]
-
-    else:
-        for ii, kk in enumerate(key_cam):
-
-            klos = coll.dobj['diagnostic'][key]['doptics'][kk]['los']
-            if klos is None:
-                continue
-
-            pts_x, pts_y, pts_z = coll.sample_rays(
-                key=klos,
-                res=res,
-                mode=mode,
-                segment=segment,
-                radius_max=radius_max,
-                concatenate=True,
-                return_coords=['x', 'y', 'z'],
-                )
-
-            Ri = np.hypot(pts_x, pts_y)
-
-            q2dx, _ = coll.interpolate_profile2d(
-                key=key_data_x,
-                R=Ri,
-                Z=pts_z,
-                grid=False,
-                crop=True,
-                nan0=True,
-                val_out=True,
-                imshow=False,
-                return_params=None,
-                store=False,
-                inplace=False,
-            )
-
-            q2dy, _ = coll.interpolate_profile2d(
-                key=key_data_y,
-                R=Ri,
-                Z=pts_z,
-                grid=False,
-                crop=True,
-                nan0=True,
-                val_out=True,
-                imshow=False,
-                return_params=None,
-                store=False,
-                inplace=False,
-            )
-
-            isok = ~((np.isnan(q2dx) | np.isnan(q2dy)) & (~np.isnan(Ri)))
-            xx[ii] = q2dx[isok]
-            yy[ii] = q2dy[isok]
 
-            xlab = f"{key_data_x} ({coll.ddata[key_data_x]['units']})"
-            ylab = f"{key_data_y} ({coll.ddata[key_data_y]['units']})"
+# #####################################################
+# #####################################################
+#           Synthetic signal
+# #####################################################
+
+
+def _compute_synth_signal(coll=None, ldiag=None):
+
+    # -------------
+    # list of diags
+
+    if ldiag is None:
+        ldiag = [
+            'd0',
+            'd1',
+            'diag00', 'diag01', 'diag02',
+        ]
 
     # ------------
-    # plot
+    # loop n diags
+
+    for k0 in ldiag:
+
+        if k0 not in coll.dobj['diagnostic'].keys():
+            continue
+
+        # params
+        if k0 == 'd0':
+            key_integrand = 'emiss1d'
+            ref_com = 'nt'
+        # elif k0 == 'diag00':
+            # key_integrand = 'emiss2dE'
+            # ref_com = None
+        else:
+            key_integrand = 'emiss1dE'
+            ref_com = 'nt'
+
+        # compute
+        coll.compute_diagnostic_signal(
+            key=None,
+            key_diag=k0,
+            key_cam=None,
+            key_integrand=key_integrand,
+            method='los',
+            res=0.001,
+            mode='abs',
+            groupby=None,
+            val_init=None,
+            ref_com=ref_com,
+            brightness=None,
+            store=True,
+            returnas=False,
+        )
 
-    if plot is True:
-        if dax is None:
 
-            fig = plt.figure()
+# #####################################################
+# #####################################################
+#           Script
+# #####################################################
 
-            ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
 
-            tit = f"{key} LOS"
-            ax.set_title(tit, size=12, fontweight='bold')
-            ax.set_xlabel(xlab)
-            ax.set_ylabel(ylab)
-
-            dax = {'main': ax}
-
-        # main
-        kax = 'main'
-        if dax.get(kax) is not None:
-            ax = dax[kax]
-
-            for ii, kk in enumerate(key_cam):
-                ax.plot(
-                    xx[ii],
-                    yy[ii],
-                    c=dcolor[kk],
-                    marker='.',
-                    ls='-',
-                    ms=8,
-                    label=kk,
-                )
-
-            ax.legend()
-            
-            if vmin is not None:
-                ax.set_ylim(bottom=vmin)
-            if vmax is not None:
-                ax.set_ylim(top=vmax)
-
-        return xx, yy, dax
-    else:
-        return xx, yy
+if __name__ == '__main__':
+    main()
```

### Comparing `tofu-1.6.5/tofu/data/_class8_plot.py` & `tofu-1.7.0/tofu/data/_class8_compute_signal.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,794 +1,748 @@
-# -*- coding: utf-8 -*-
 
 
-# Built-in
+import numpy as np
+import scipy.integrate as scpinteg
+import astropy.units as asunits
 
 
-# Common
-import numpy as np
-import matplotlib.pyplot as plt
-import matplotlib.colors as mcolors
 import datastock as ds
 
 
-# specific
-from . import _generic_check
-from . import _generic_plot
-
+# ################################################################
+# ################################################################
+#               Main routine
+# ################################################################
 
-# ##################################################################
-# ##################################################################
-#                           plot check
-# ##################################################################
 
-
-def _plot_diagnostic_check(
+def compute_signal(
     coll=None,
     key=None,
+    key_diag=None,
     key_cam=None,
-    # figure
-    proj=None,
-    data=None,
-    rocking_curve=None,
-    los_res=None,
-    # interactivity
-    color_dict=None,
-    nlos=None,
-    connect=None,
+    # to be integrated
+    key_integrand=None,
+    # sampling
+    method=None,
+    res=None,
+    mode=None,
+    groupby=None,
+    val_init=None,
+    ref_com=None,
+    # signal
+    brightness=None,
+    # verb
+    verb=None,
+    # store
+    store=None,
+    # return
+    returnas=None,
 ):
 
-    # -------
-    # key
+    # -------------
+    # check inputs
+    # --------------
 
-    # key
-    key, key_cam = coll.get_diagnostic_cam(key, key_cam)
-    is2d = coll.dobj['diagnostic'][key]['is2d']
-    spectro = coll.dobj['diagnostic'][key]['spectro']
+    (
+        key_diag, key_cam, spectro, PHA, is2d,
+        method, mode, groupby, val_init, brightness,
+        key_integrand, key_mesh0, key_bs,
+        key_ref_spectro, key_bs_spectro,
+        verb, store, key,
+        returnas,
+    ) = _compute_signal_check(
+        coll=coll,
+        key_diag=key_diag,
+        key_cam=key_cam,
+        # sampling
+        method=method,
+        res=res,
+        mode=mode,
+        groupby=groupby,
+        val_init=val_init,
+        # signal
+        brightness=brightness,
+        # to be integrated
+        key_integrand=key_integrand,
+        # verb
+        verb=verb,
+        # store
+        store=store,
+        key=key,
+        # return
+        returnas=returnas,
+    )
 
-    if spectro:
-        assert len(key_cam) == 1
-        doptics = coll.dobj['diagnostic'][key]['doptics'][key_cam[0]]
-        kcryst = doptics['optics'][doptics['ispectro'][0]]
-    else:
-        kcryst = None
+    # -------------
+    # prepare
+    # --------------
 
-    # -------
-    # data
+    # shape_emiss = coll.ddata[key_integrand]['shape']
 
-    defdata = 'etendue'
-    c0 = data is None and coll.dobj['diagnostic'][key].get(defdata) is not None
-    if c0:
-        data = defdata
+    if mode == 'abs':
+        key_kR = coll.dobj['mesh'][key_mesh0]['knots'][0]
+        radius_max = np.max(coll.ddata[key_kR]['data'])
+    else:
+        radius_max = None
 
-    ddata, dref = coll.get_diagnostic_data(
-        key=key,
-        key_cam=key_cam,
-        data=data,
-    )
+    # -------------
+    # verb
+    # --------------
+
+    if verb is True:
+        msg = (
+            "\nComputing synthetic signal for:\n"
+            f"\t- diag: {key_diag}\n"
+            f"\t- cam: {key_cam}\n"
+            f"\t- integrand: {key_integrand}\n"
+            f"\t- method: {method}\n"
+            f"\t- res: {res}, {mode}\n"
+        )
+        print(msg)
 
-    ylab = None # f"{ddata[key_cam[0]]['quant']} ({ddata[key_cam[0]]['units']})"
+    # -------------
+    # compute
+    # --------------
+
+    if method == 'los':
+        dout = _compute_los(
+            coll=coll,
+            is2d=is2d,
+            spectro=spectro,
+            PHA=PHA,
+            key=key,
+            key_diag=key_diag,
+            key_cam=key_cam,
+            key_bs=key_bs,
+            res=res,
+            mode=mode,
+            key_integrand=key_integrand,
+            key_ref_spectro=key_ref_spectro,
+            key_bs_spectro=key_bs_spectro,
+            radius_max=radius_max,
+            groupby=groupby,
+            val_init=val_init,
+            ref_com=ref_com,
+            brightness=brightness,
+        )
 
-    # -----
-    # proj
+    else:
+        pass
 
-    proj = _generic_plot._proj(
-        proj=proj,
-        pall=['cross', 'hor', '3d', 'camera'],
-    )
+    # -------------
+    # store
+    # --------------
+
+    if store is True:
+        _store(
+            coll=coll,
+            key=key,
+            key_diag=key_diag,
+            dout=dout,
+            key_integrand=key_integrand,
+            method=method,
+            res=res,
+        )
 
-    # ----------
-    # los_res
+    # -------------
+    # return
+    # --------------
 
-    los_res = ds._generic_check._check_var(
-        los_res, 'los_res',
-        types=float,
-        default=0.05,
-        sign='> 0.',
-    )
+    if returnas is dict:
+        return dout
 
-    # -------
-    # color_dict
 
-    color_dict = _check_color_dict(color_dict)
+# ##################################################################
+# ##################################################################
+#               STORE
+# ##################################################################
 
-    # -------
-    # nlos
 
-    nlos = ds._generic_check._check_var(
-        nlos, 'nlos',
-        types=int,
-        default=5,
-    )
+def _store(
+    coll=None,
+    key=None,
+    key_diag=None,
+    dout=None,
+    # synthetic signal
+    key_integrand=None,
+    method=None,
+    res=None,
+    # retrofit
+    key_matrix=None,
+):
 
-    # -------
-    # connect
+    # ---------
+    # check
 
-    connect = ds._generic_check._check_var(
-        connect, 'connect',
-        types=bool,
-        default=True,
-    )
+    lc = [key_integrand is not None, key_matrix is not None]
+    if np.sum(lc) != 1:
+        msg = "Please provide key_integrand xor key_matrix"
+        raise Exception(msg)
+
+    typ = 'retrofit' if key_integrand is None else 'synthetic'
+
+    # ---------
+    # prepare
+
+    dobj = {
+        'synth sig':{
+            key: {
+                'diag': key_diag,
+                'camera': list(dout.keys()),
+                'data': [v0['key'] for v0 in dout.values()],
+                # synthetic
+                'integrand': key_integrand,
+                'method': method,
+                'res': res,
+                # retrofit
+                'geom matrix': key_matrix,
+            },
+        },
+    }
 
-    return (
-        key,
-        key_cam,
-        is2d,
-        proj,
-        ddata,
-        dref,
-        los_res,
-        color_dict,
-        nlos,
-        ylab,
-        connect,
-    )
+    # ----------
+    # add data
 
+    for k0, v0 in dout.items():
+        coll.add_data(**v0)
 
-def _check_color_dict(color_dict=None):
-    if color_dict is None:
-        lc = ['r', 'g', 'b', 'm', 'c', 'y']
-        color_dict = {
-            'x': lc,
-            'y': lc,
-        }
-    return color_dict
+    # add obj
+    lsynth = coll._dobj['diagnostic'][key_diag].get('signal')
+    if lsynth is None:
+        lsynth = [key]
+    else:
+        lsynth.append(key)
+    coll._dobj['diagnostic'][key_diag]['signal'] = lsynth
+    coll.update(dobj=dobj)
 
 
 # ##################################################################
-# ##################################################################
-#                           plot main
+#               CHECK
 # ##################################################################
 
 
-def _plot_diagnostic(
+def _compute_signal_check(
     coll=None,
     key=None,
+    key_diag=None,
     key_cam=None,
-    optics=None,
-    elements=None,
-    proj=None,
-    los_res=None,
-    # data plot
-    data=None,
-    cmap=None,
-    vmin=None,
-    vmax=None,
-    # config
-    plot_config=None,
-    # figure
-    dax=None,
-    dmargin=None,
-    fs=None,
-    wintit=None,
-    # interactivity
-    color_dict=None,
-    nlos=None,
-    dinc=None,
-    connect=None,
+    # sampling
+    method=None,
+    res=None,
+    mode=None,
+    groupby=None,
+    val_init=None,
+    # signal
+    brightness=None,
+    # to be integrated
+    key_integrand=None,
+    # verb
+    verb=None,
+    # store
+    store=None,
+    # return
+    returnas=None,
 ):
 
-    # ------------
-    # check inputs
+    wm = coll._which_mesh
+    wbs = coll._which_bsplines
 
-    (
-        key,
-        key_cam,
-        is2d,
-        proj,
-        ddata,
-        dref,
-        los_res,
-        color_dict,
-        nlos,
-        ylab,
-        connect,
-    ) = _plot_diagnostic_check(
-        coll=coll,
-        key=key,
-        # figure
-        proj=proj,
-        data=data,
-        los_res=los_res,
-        # interactivity
-        color_dict=color_dict,
-        nlos=nlos,
-        connect=connect,
+    # key_diag, key_cam
+    key_diag, key_cam = coll.get_diagnostic_cam(key=key_diag, key_cam=key_cam)
+    spectro = coll.dobj['diagnostic'][key_diag]['spectro']
+    PHA = coll.dobj['diagnostic'][key_diag]['PHA']
+    is2d = coll.dobj['diagnostic'][key_diag]['is2d']
+
+    # method
+    method = ds._generic_check._check_var(
+        method, 'method',
+        types=str,
+        default='los',
+        allowed=['los', 'vos'],
+    )
+
+    # mode
+    mode = ds._generic_check._check_var(
+        mode, 'mode',
+        types=str,
+        default='abs',
+        allowed=['abs', 'rel'],
+    )
+
+    # groupby
+    groupby = ds._generic_check._check_var(
+        groupby, 'groupby',
+        types=int,
+        default=1 if (PHA or spectro) else 200,
+        allowed=[1] if (PHA or spectro) else None,
     )
 
-    # ------------
-    # prepare data
-
-    dplot = coll.get_diagnostic_dplot(
-        key=key,
-        key_cam=key_cam,
-        optics=optics,
-        elements=elements,
+    # brightness
+    brightness = ds._generic_check._check_var(
+        brightness, 'brightness',
+        types=bool,
+        default=False,
     )
 
-    # -------------------------
-    # prepare los interactivity
+    # key_integrand
+    lok = [
+        k0 for k0, v0 in coll.ddata.items()
+        if v0.get(wbs) is not None
+        and any([
+            coll.dobj[wm][coll.dobj[wbs][k1][wm]]['nd'] == '2d'
+            or coll.dobj[wm][coll.dobj[wbs][k1][wm]]['submesh'] is not None
+            for k1 in v0[wbs]
+        ])
+    ]
+
+    key_integrand = ds._generic_check._check_var(
+        key_integrand, 'key_integrand',
+        types=str,
+        allowed=lok,
+    )
+
+    # key_mesh0
+    key_bs = [
+        kk for kk in coll.ddata[key_integrand][wbs]
+        if coll.dobj[wm][coll.dobj[wbs][kk][wm]]['nd'] == '2d'
+        or coll.dobj[wm][coll.dobj[wbs][kk][wm]]['submesh'] is not None
+    ]
+    if len(key_bs) == 1:
+        key_bs = key_bs[0]
+    else:
+        msg = f"Multiple possible 2d bsplines for integrand '{key_integrand}'"
+        raise Exception(msg)
 
-    # instanciate new Datastock
-    coll2 = coll.__class__()
+    key_mesh = coll.dobj[wbs][key_bs][wm]
+    mtype = coll.dobj[wm][key_mesh]['type']
+    submesh = coll.dobj[wm][key_mesh]['submesh']
+    if submesh is not None:
+        key_mesh0 = submesh
+    else:
+        key_mesh0 = key_mesh
 
-    # ---------------------
-    # prepare los and ddata
+    # key_ref_spectro
+    if spectro:
+        key_ref_spectro, key_bs_spectro = _get_ref_bs_spectro(
+            coll=coll,
+            key_integrand=key_integrand,
+            key_bs=key_bs,
+        )
+    else:
+        key_ref_spectro = None
+        key_bs_spectro = None
 
-    # dcamref
-    dcamref, drefx, drefy = _prepare_dcamref(
-        coll=coll,
-        key_cam=key_cam,
-        is2d=is2d,
+    # val_init
+    val_init = ds._generic_check._check_var(
+        val_init, 'val_init',
+        default=np.nan,
+        allowed=[np.nan, 0.]
     )
 
-    # los
-    dlos, dref_los = _prepare_los(
-        coll=coll,
-        coll2=coll2,
-        dcamref=dcamref,
-        key_diag=key,
-        key_cam=key_cam,
-        los_res=los_res,
+    # verb
+    verb = ds._generic_check._check_var(
+        verb, 'verb',
+        types=bool,
+        default=True,
     )
 
-    # ddatax, ddatay
-    reft, dkeyx, dkeyy, ddatax, ddatay, dextent = _prepare_datarefxy(
-        coll=coll,
-        coll2=coll2,
-        dcamref=dcamref,
-        drefx=drefx,
-        drefy=drefy,
-        ddata=ddata,
-        is2d=is2d,
+    # store
+    store = ds._generic_check._check_var(
+        store, 'store',
+        types=bool,
+        default=True,
     )
 
-    # -----------------
-    # prepare figure
-
-    if dax is None:
-
-        dax = _generic_plot.get_dax_diag(
-            proj=proj,
-            dmargin=dmargin,
-            fs=fs,
-            wintit=wintit,
-            tit=key,
-            is2d=is2d,
-            key_cam=key_cam,
+    # key
+    if store is True:
+        key = ds._generic_check._obj_key(
+            coll.dobj.get('synth sig', {}),
+            short='synth',
+            key=key,
+            ndigits=2,
         )
 
-    dax = _generic_check._check_dax(dax=dax, main=proj[0])
-
-    # -----------------
-    # plot static parts
-
-    for k0, v0 in dplot.items():
-
-        for k1, v1 in v0.items():
-
-            # cross
-            kax = 'cross'
-            if dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-
-                if k1.startswith('v-'):
-                    ax.quiver(
-                        v1['r'],
-                        v1['z'],
-                        v1['ur'],
-                        v1['uz'],
-                        **v1.get('props', {}),
-                    )
-
-                else:
-                    ax.plot(
-                        v1['r'],
-                        v1['z'],
-                        **v1.get('props', {}),
-                    )
-
-            # hor
-            kax = 'hor'
-            if dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-
-                if k1.startswith('v-'):
-                    ax.quiver(
-                        v1['x'],
-                        v1['y'],
-                        v1['ux'],
-                        v1['uy'],
-                        **v1.get('props', {}),
-                    )
-
-                else:
-                    ax.plot(
-                        v1['x'],
-                        v1['y'],
-                        **v1.get('props', {}),
-                    )
-
-            # 3d
-            kax = '3d'
-            if dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-
-                if k1.startswith('v-'):
-                    ax.quiver(
-                        v1['x'],
-                        v1['y'],
-                        v1['z'],
-                        v1['ux'],
-                        v1['uy'],
-                        v1['uz'],
-                        **v1.get('props', {}),
-                    )
-
-                else:
-                    ax.plot(
-                        v1['x'],
-                        v1['y'],
-                        v1['z'],
-                        **v1.get('props', {}),
-                    )
-
-            # plotting of 2d camera contour
-            kax = k0
-            if is2d and k0 in key_cam and dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-                if k1 == 'o':
-                    ax.plot(
-                        v1['x0'],
-                        v1['x1'],
-                        **v1.get('props', {}),
-                    )
-
-    # plot data
-    for k0 in key_cam:
-        kax = k0
-        if dax.get(kax) is not None and ddata is not None:
-            ax = dax[kax]['handle']
-
-            if is2d and reft is None:
-                im = ax.imshow(
-                    ddata[k0].T,
-                    extent=dextent[k0],
-                    cmap=cmap,
-                    vmin=vmin,
-                    vmax=vmax,
-                    origin='lower',
-                    interpolation='nearest',
-                )
-                plt.colorbar(im, ax=ax)
-
-            elif reft is None:
-                ax.plot(
-                    ddata[k0],
-                    c='k',
-                    ls='-',
-                    lw=1.,
-                    marker='.',
-                    ms=6,
-                )
-                ax.set_xlim(-1, ddata[k0].size)
-                ax.set_ylabel(ylab)
-
-                if vmin is not None:
-                    ax.set_ylim(bottom=vmin)
-                if vmax is not None:
-                    ax.set_ylim(top=vmax)
-
-    # ----------------
-    # define and set dgroup
-
-    if coll2 is not None:
-        dgroup = {
-            f'{k0}_x': {
-                'ref': [drefx[k0]],
-                'data': ['index'],
-                'nmax': nlos,
-            }
-            for k0 in key_cam
-        }
-
-        if is2d:
-            dgroup.update({
-                'y': {
-                    'ref': list(drefy.values()),
-                    'data': ['index'],
-                    'nmax': nlos,
-                },
-            })
-
-        if reft is not None:
-            dgroup.update({
-                't': {
-                    'ref': [reft],
-                    'data': ['index'],
-                    'nmax': 1,
-                },
-            })
-
-    # ------------------
-    # plot mobile parts
-
-    for k0 in key_cam:
+    # returnas
+    returnas = ds._generic_check._check_var(
+        returnas, 'returnas',
+        default=False if store is True else dict,
+        allowed=[dict, False],
+    )
 
-        if dlos[k0]['rays'] is not None:
+    return (
+        key_diag, key_cam, spectro, PHA, is2d,
+        method, mode, groupby, val_init, brightness,
+        key_integrand, key_mesh0, key_bs,
+        key_ref_spectro, key_bs_spectro,
+        verb, store, key,
+        returnas,
+    )
 
-            nan = np.full((dlos[k0]['x'].shape[0],), np.nan)
 
-            # cross
-            kax = 'cross'
-            if dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-
-                _add_camera_los_cross(
-                    coll2=coll2,
-                    k0=k0,
-                    ax=ax,
-                    kax=kax,
-                    nlos=nlos,
-                    dref_los=dref_los,
-                    color_dict=color_dict,
-                    nan=nan,
-                )
+def _get_ref_bs_spectro(coll=None, key_integrand=None, key_bs=None):
+
+    # get ref of integrand
+    kref = coll.ddata[key_integrand]['ref']
+    wbs = coll._which_bsplines
+
+    key_ref_spectro = None
+    key_bs_spectro = None
+
+    # get list of non-spatial ref
+    lkspectro = [
+        k0 for k0 in kref
+        if k0 not in coll.dobj[wbs][key_bs]['ref']
+    ]
+
+    # If none => error
+    if len(lkspectro) == 0:
+        msg = (
+            "Integrand '{key_integrand}' does not seem to "
+            "have a spectral dimension"
+        )
+        raise Exception(msg)
 
-            # hor
-            kax = 'hor'
-            if dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-
-                for ii in range(nlos):
-                    l0, = ax.plot(
-                        nan,
-                        nan,
-                        c=color_dict['x'][ii],
-                        ls='-',
-                        lw=1.,
-                    )
-
-                    # add mobile
-                    kl0 = f'{k0}-los-hor-{ii}'
-                    coll2.add_mobile(
-                        key=kl0,
-                        handle=l0,
-                        refs=dref_los[k0],
-                        data=[f'{k0}_los_x', f'{k0}_los_y'],
-                        dtype=['xdata', 'ydata'],
-                        axes=kax,
-                        ind=ii,
-                    )
-
-            # 3d
-            kax = '3d'
-            if dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-
-                for ii in range(nlos):
-                    l0, = ax.plot(
-                        nan,
-                        nan,
-                        nan,
-                        c=color_dict['x'][ii],
-                        ls='-',
-                        lw=1.,
-                    )
-
-                    # add mobile
-                    kl0 = f'{k0}_los-3d-{ii}'
-                    # coll2.add_mobile(
-                    # key=kl0,
-                    # handle=l0,
-                    # refs=reflos,
-                    # data=['index', 'index', 'index'],
-                    # dtype=['xdata', 'ydata', 'zdata'],
-                    # axes=kax,
-                    # ind=ii,
-                    # )
-
-            # camera
-            kax = k0
-            if dax.get(kax) is not None:
-                ax = dax[kax]['handle']
-
-                _add_camera_vlines_marker(
-                    coll2=coll2,
-                    dax=dax,
-                    ax=ax,
-                    kax=kax,
-                    is2d=is2d,
-                    k0=k0,
-                    nlos=nlos,
-                    ddatax=ddatax,
-                    ddatay=ddatay,
-                    drefx=drefx,
-                    drefy=drefy,
-                    dkeyx=dkeyx,
-                    dkeyy=dkeyy,
-                    color_dict=color_dict,
-                )
+    # unique => ok
+    if len(lkspectro) == 1:
+        key_ref_spectro = lkspectro[0]
+    else:
+        pass
 
-    # -------
-    # config
+    # check if bs
+    lbs_spectro = [
+        k0 for k0 in coll.ddata[key_integrand][wbs]
+        if k0 != key_bs
+    ]
+    if len(lbs_spectro) == 0:
+        pass
+    elif len(lbs_spectro) == 1:
+        key_bs_spectro = lbs_spectro[0]
+        if key_ref_spectro is None:
+            key_ref_spectro = coll.dobj[wbs][key_bs_spectro]['ref'][0]
+        assert key_ref_spectro == coll.dobj[wbs][key_bs_spectro]['ref'][0]
+    else:
+        pass
 
-    if plot_config.__class__.__name__ == 'Config':
+    # --------
+    # safety check
 
-        kax = 'cross'
-        if dax.get(kax) is not None:
-            ax = dax[kax]['handle']
-            plot_config.plot(lax=ax, proj=kax)
-
-        kax = 'hor'
-        if dax.get(kax) is not None:
-            ax = dax[kax]['handle']
-            plot_config.plot(lax=ax, proj=kax)
-
-    # -------
-    # connect
-
-    if coll2.dobj.get('mobile') is not None:
-        # add axes
-        for ii, kax in enumerate(dax.keys()):
-            harmonize = ii == len(dax.keys()) - 1
-            coll2.add_axes(key=kax, harmonize=harmonize, **dax[kax])
-
-        # connect
-        if connect is True:
-            coll2.setup_interactivity(
-                kinter='inter0',
-                dgroup=dgroup,
-                dinc=dinc,
-            )
-            coll2.disconnect_old()
-            coll2.connect()
+    if key_ref_spectro is None:
+        msg = "Spectral dimension of '{key_integrand} could not be identified'"
+        raise Exception(msg)
 
-            coll2.show_commands()
-            return coll2
-        else:
-            return coll2, dgroup
-    else:
-        return dax
+    return key_ref_spectro, key_bs_spectro
 
 
 # ##################################################################
 # ##################################################################
-#                       Prepare
+#               LOS
 # ##################################################################
 
 
-def _prepare_dcamref(
+def _compute_los(
     coll=None,
-    key_cam=None,
     is2d=None,
-):
-    dcamref = {
-        k0: coll.dobj['camera'][k0]['dgeom']['ref']
-        for k0 in key_cam
-    }
-    drefx = {k0: v0[0] for k0, v0 in dcamref.items()}
-
-    if is2d:
-        drefy = {k0: v0[1] for k0, v0 in dcamref.items()}
-    else:
-        drefy = None
-
-    return dcamref, drefx, drefy
-
-
-def _prepare_los(
-    coll=None,
-    coll2=None,
-    dcamref=None,
+    spectro=None,
+    PHA=None,
+    key=None,
     key_diag=None,
     key_cam=None,
-    los_res=None,
+    key_bs=None,
+    res=None,
+    mode=None,
+    key_integrand=None,
+    key_ref_spectro=None,
+    key_bs_spectro=None,
+    radius_max=None,
+    groupby=None,
+    val_init=None,
+    ref_com=None,
+    brightness=None,
 ):
 
-    # create dlos
-    dlos = {
-        k0: {'rays': coll.dobj['diagnostic'][key_diag]['doptics'][k0]['los']}
-        for k0 in key_cam
-    }
-    dref_los = {}
+    # -----------------
+    # prepare
 
-    # los on cams
-    for k0, v0 in dcamref.items():
-        for rr in v0:
-            coll2.add_ref(key=rr, size=coll.dref[rr]['size'])
-
-        # los
-        if dlos[k0]['rays'] is not None:
-            los_x, los_y, los_z = coll.sample_rays(
-                key=dlos[k0]['rays'],
-                res=los_res,
-                mode='rel',
-                concatenate=False,
-            )
-            los_r = np.hypot(los_x, los_y)
-            reflos = coll.dobj['rays'][dlos[k0]['rays']]['ref']
-            dref_los[k0] = (reflos[1:], reflos[1:])
+    if spectro:
 
-            if reflos[0] not in coll2.dref.keys():
-                coll2.add_ref(key=reflos[0], size=los_x.shape[0])
+        
 
-            coll2.add_data(key=f'{k0}_los_x', data=los_x, ref=reflos)
-            coll2.add_data(key=f'{k0}_los_y', data=los_y, ref=reflos)
-            coll2.add_data(key=f'{k0}_los_z', data=los_z, ref=reflos)
-            coll2.add_data(key=f'{k0}_los_r', data=los_r, ref=reflos)
+        kspect_ref_vect = coll.get_ref_vector(ref=key_ref_spectro)[3]
+        spect_ref_vect = coll.ddata[kspect_ref_vect]['data']
+        
+        ref = coll.ddata[key_integrand]['ref']
+        axis_spectro = ref.index(key_ref_spectro)
+
+        wbs = coll._which_bsplines
+        rbs = coll.dobj[wbs][key_bs]['ref'][0]
+        if axis_spectro > ref.index(rbs):
+            axis_spectro -= len(coll.dobj[wbs][key_bs]['ref']) - 1
+
+        units_spectro = coll.ddata[kspect_ref_vect]['units']
+
+        E, _ = coll.get_diagnostic_lamb(
+            key_diag,
+            lamb='lamb',
+            units=units_spectro,
+        )
+        dE, _ = coll.get_diagnostic_lamb(
+            key_diag,
+            lamb='dlamb',
+            units=units_spectro,
+        )
+        E_flat = E.ravel()
+        dE_flat = dE.ravel()
 
-            # store x, y, z
-            dlos[k0]['x'] = los_x
-            dlos[k0]['y'] = los_y
-            dlos[k0]['z'] = los_z
+    else:
+        dict_E = None
+        dict_dE = None
 
-    return dlos, dref_los
+    # units
+    units0, units_bs = _units_integration(
+        coll=coll,
+        key_integrand=key_integrand,
+        key_bs=key_bs,
+    )
+    units = units0 * units_bs
 
+    domain = None
 
-def _prepare_datarefxy(
-    coll=None,
-    coll2=None,
-    dcamref=None,
-    drefx=None,
-    drefy=None,
-    ddata=None,
-    is2d=None,
-):
-    # prepare dict
-    dkeyx, ddatax = {}, {}
-    if is2d:
-        dkeyy, ddatay, dextent = {}, {}, {}
-    else:
-        dkeyy, ddatay, dextent = None, None, None
+    # ----------------
+    # loop on cameras
 
-    # loop on cams
-    for k0, v0 in dcamref.items():
+    dout = {}
+    doptics = coll.dobj['diagnostic'][key_diag]['doptics']
+    for k0 in key_cam:
 
-        # datax, datay
-        if ddata is not None:
-            if is2d:
-                dkeyx[k0], dkeyy[k0] = coll.dobj['camera'][k0]['dgeom']['cents']
-
-                ddatax[k0] = coll.ddata[dkeyx[k0]]['data']
-                ddatay[k0] = coll.ddata[dkeyy[k0]]['data']
-
-                coll2.add_data(key=dkeyx[k0], data=ddatax[k0], ref=drefx[k0])
-                coll2.add_data(key=dkeyy[k0], data=ddatay[k0], ref=drefy[k0])
-            else:
-                dkeyx[k0] = f'{k0}_i0'
-                ddatax[k0] = np.arange(0, coll.dref[drefx[k0]]['size'])
-                coll2.add_data(key=dkeyx[k0], data=ddatax[k0], ref=drefx[k0])
-
-            # -------------------------
-            # extent
-
-            reft = None
-            if is2d:
-                if ddatax[k0].size == 1:
-                    ddx = coll.ddata[coll.dobj['camera'][k0]['dgeom']['outline'][0]]['data']
-                    ddx = np.max(ddx) - np.min(ddx)
-                else:
-                    ddx = ddatax[k0][1] - ddatax[k0][0]
-                if ddatay[k0].size == 1:
-                    ddy = coll.ddata[coll.dobj['camera'][k0]['dgeom']['outline'][1]]['data']
-                    ddy = np.max(ddy) - np.min(ddy)
-                else:
-                    ddy = ddatay[k0][1] - ddatay[k0][0]
-
-                dextent[k0] = (
-                    ddatax[k0][0] - 0.5*ddx,
-                    ddatax[k0][-1] + 0.5*ddx,
-                    ddatay[k0][0] - 0.5*ddy,
-                    ddatay[k0][-1] + 0.5*ddy,
+        npix = coll.dobj['camera'][k0]['dgeom']['pix_nb']
+        key_los = doptics[k0]['los']
+        key_pts0 = coll.dobj['rays'][key_los]['pts'][0]
+        ilosok = np.isfinite(coll.ddata[key_pts0]['data'][0, ...].ravel())
+
+        ngroup = npix // groupby
+        if groupby * ngroup < npix:
+            ngroup += 1
+
+        # ---------------------------------------------------
+        # loop on group of pixels (to limit memory footprint)
+
+        shape = None
+        for ii in range(ngroup):
+
+            # indices
+            i0 = ii*groupby
+            i1 = min((ii + 1)*groupby, npix)
+            ni = i1 - i0
+
+            # get rid of undefined LOS
+            ind_flat = [jj for jj in range(i0, i1) if ilosok[jj]]
+            ni = len(ind_flat)
+
+            # no valid los in group
+            if len(ind_flat) == 0:
+                continue
+
+            # LOS sampling
+            R, Z, length = coll.sample_rays(
+                key=key_los,
+                res=res,
+                mode=mode,
+                segment=None,
+                ind_flat=ind_flat,
+                radius_max=radius_max,
+                concatenate=True,
+                return_coords=['R', 'z', 'ltot'],
+            )
+            
+            if R is None:
+                continue
+
+            # safety checks
+            inan = np.isnan(R)
+            inannb = np.r_[-1, inan.nonzero()[0]]
+            nnan = inan.sum()
+
+            # some lines can be nan if non-existant
+            assert nnan == ni, f"{nnan} vs {ni}"
+
+            # -------------------
+            # domain for spectro
+
+            if spectro:
+                ind = np.argmin(np.abs(spect_ref_vect - E_flat[ind_flat[0]]))
+                domain = {key_ref_spectro: {'ind': np.r_[ind]}}
+
+            # ---------------------
+            # interpolate spacially
+
+            # datai, units, refi = coll.interpolate(
+            douti = coll.interpolate(
+                keys=key_integrand,
+                ref_key=key_bs,
+                x0=R,
+                x1=Z,
+                grid=False,
+                submesh=True,
+                ref_com=ref_com,
+                domain=domain,
+                # azone=None,
+                details=False,
+                crop=None,
+                nan0=True,
+                val_out=np.nan,
+                return_params=False,
+                store=False,
+            )[key_integrand]
+
+            # ----------------------
+            # interpolate spectrally
+
+            if spectro:             
+                douti['data'] = np.take(douti['data'], 0, axis_spectro)
+                douti['ref'] = tuple([
+                    rr for jj, rr in enumerate(douti['ref'])
+                    if jj != axis_spectro
+                ])
+
+            # ------------
+            # extract data
+
+            datai, refi = douti['data'], douti['ref']
+            axis = refi.index(None)
+            if shape is None:
+                shape = list(datai.shape)
+                shape[axis] = npix
+                data = np.full(shape, val_init)
+                ref = list(refi)
+
+            # ------------
+            # integrate
+
+            iok2 = np.isfinite(datai)
+            sli0 = [slice(None) for aa in range(len(refi))]
+            for jj in range(nnan):
+
+                # slice datai
+                indi = np.arange(inannb[jj]+1, inannb[jj+1])
+                sli0[axis] = indi
+                slii = tuple(sli0)
+                if not np.any(iok2[slii]):
+                    continue
+
+                # set nan to 0 for integration
+                dataii = datai[slii]
+                dataii[~iok2[slii]] = 0.
+
+                # slice data
+                sli0[axis] = ind_flat[jj]
+                sli = tuple(sli0)
+
+                # if jj in [50, 51]:
+                    # plt.figure();
+                    # plt.subplot(1,2,1)
+                    # plt.plot(dataii)
+                    # plt.subplot(1,2,2)
+                    # plt.plot(dataii.T)
+                    # plt.gcf().suptitle(f"jj = {jj}", size=12)
+
+                # integrate
+                data[sli] = scpinteg.simpson(
+                    dataii,
+                    x=length[indi],
+                    axis=axis,
                 )
 
-    return reft, dkeyx, dkeyy, ddatax, ddatay, dextent
-
+        # --------------
+        # post-treatment
 
-# ##################################################################
-# ##################################################################
-#                       add mobile
-# ##################################################################
+        # brightness
+        if brightness is False:
+            ketend = doptics[k0]['etendue']
+            etend = coll.ddata[ketend]['data']
+            sh_etend = [-1 if aa == axis else 1 for aa in range(len(refi))]
+            data *= etend.reshape(sh_etend)
+            unitsi = units * coll.ddata[ketend]['units']
+        else:
+            unitsi = units
 
+        # spectral bins if spectro
+        if spectro:
+            sh_dE = [-1 if aa == axis else 1 for aa in range(len(refi))]
+            data *= dE_flat.reshape(sh_dE)
+            unitsi = unitsi * units_spectro
 
-def _add_camera_los_cross(
-    coll2=None,
-    k0=None,
-    ax=None,
-    kax=None,
-    nlos=None,
-    dref_los=None,
-    color_dict=None,
-    nan=None,
-):
+        # reshape if 2d
+        if is2d:
+            sh_data = list(data.shape)
+            sh_data[axis] = coll.dobj['camera'][k0]['dgeom']['shape']
+            sh_data = tuple(np.r_[
+                sh_data[:axis], sh_data[axis], sh_data[axis+1:]
+            ].astype(int))
+            data = data.reshape(sh_data)
+
+        # set ref
+        ref[axis] = coll.dobj['camera'][k0]['dgeom']['ref']
+        ref = tuple(np.r_[ref[:axis], ref[axis], ref[axis+1:]])
+
+        # fill dout
+        dout[k0] = {
+            'key': f'{key}_{k0}',
+            'data': data,
+            'ref': ref,
+            'units': unitsi,
+        }
 
-    for ii in range(nlos):
-        l0, = ax.plot(
-            nan,
-            nan,
-            c=color_dict['x'][ii],
-            ls='-',
-            lw=1.,
-        )
+    # -----
+    # units
 
-        # add mobile
-        kl0 = f'{k0}-los-cross-{ii}'
-        coll2.add_mobile(
-            key=kl0,
-            handle=l0,
-            refs=dref_los[k0],
-            data=[f'{k0}_los_r', f'{k0}_los_z'],
-            dtype=['xdata', 'ydata'],
-            axes=kax,
-            ind=ii,
-        )
+    return dout
 
 
-def _add_camera_vlines_marker(
-    coll2=None,
-    dax=None,
-    ax=None,
-    kax=None,
-    is2d=None,
-    k0=None,
-    nlos=None,
-    ddatax=None,
-    ddatay=None,
-    drefx=None,
-    drefy=None,
-    dkeyx=None,
-    dkeyy=None,
-    color_dict=None,
-    suffix=None,
+def _units_integration(
+    coll=None,
+    key_integrand=None,
+    key_bs=None,
 ):
 
-    if suffix is None:
-        suffix = ''
+    units0 = coll.ddata[key_integrand]['units']
 
-    if is2d:
-        for ii in range(nlos):
-            mi, = ax.plot(
-                ddatax[k0][0:1],
-                ddatay[k0][0:1],
-                marker='s',
-                ms=6,
-                markeredgecolor=color_dict['x'][ii],
-                markerfacecolor='None',
-            )
+    wbs = coll._which_bsplines
+    kap = coll.dobj[wbs][key_bs]['apex']
+    lunits = list({coll.ddata[k0]['units'] for k0 in kap})
+    if len(lunits) == 1:
+        units_bs = lunits[0]
+    else:
+        msg = "Don't know how to interpret line-integration units from bspline"
+        raise Exception(msg)
 
-            km = f'{k0}_m{ii:02.0f}{suffix}'
-            coll2.add_mobile(
-                key=km,
-                handle=mi,
-                refs=[drefx[k0], drefy[k0]],
-                data=[dkeyx[k0], dkeyy[k0]],
-                dtype=['xdata', 'ydata'],
-                axes=kax,
-                ind=ii,
-            )
+    wm = coll._which_mesh
+    keym = coll.dobj[wbs][key_bs][wm]
+    subbs = coll.dobj[wm][keym]['subbs']
+    if subbs is not None:
+        kap = coll.dobj[wbs][subbs]['apex']
+        lunits = list({coll.ddata[k0]['units'] for k0 in kap})
+        if len(lunits) == 1:
+            units_bs = lunits[0]
+        else:
+            msg = "Don't know how to interpret line-integration units from bspline"
+            raise Exception(msg)
 
-        dax[kax].update(
-            refx=[drefx[k0]],
-            refy=[drefy[k0]],
-            datax=[dkeyx[k0]],
-            datay=[dkeyy[k0]],
-        )
+    return units0, units_bs
 
-    else:
 
-        for ii in range(nlos):
-            lv = ax.axvline(
-                ddatax[k0][0], c=color_dict['y'][ii], lw=1., ls='-',
-            )
-            kv = f'{k0}_v{ii:02.0f}{suffix}'
-            coll2.add_mobile(
-                key=kv,
-                handle=lv,
-                refs=drefx[k0],
-                data=dkeyx[k0],
-                dtype='xdata',
-                axes=kax,
-                ind=ii,
-            )
+# ##################################################################
+# ##################################################################
+#               VOS
+# ##################################################################
+
+
+def _compute_vos(
+    coll=None,
+    key_cam=None,
+    res=None,
+    mode=None,
+    key_integrand=None,
+):
+
+    dout = None
 
-        dax[kax].update(refx=[drefx[k0]], datax=[dkeyx[k0]])
+    return dout
```

### Comparing `tofu-1.6.5/tofu/data/_class9_plot.py` & `tofu-1.7.0/tofu/data/_class9_plot.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,19 +7,19 @@
 
 # Common
 import numpy as np
 import matplotlib.pyplot as plt
 import matplotlib.gridspec as gridspec
 import matplotlib.colors as mcolors
 import datastock as ds
+import bsplines2d as bs2
 
 
 # specific
 from . import _generic_check
-from ._class1_plot import _plot_bsplines_get_dRdZ
 
 
 # #############################################################################
 # #############################################################################
 #                           plot matrix
 # #############################################################################
 
@@ -53,48 +53,36 @@
     refbs = coll.dobj['bsplines'][keybs]['ref']
     keym = coll.dobj['bsplines'][keybs]['mesh']
 
     key_diag = coll.dobj['geom matrix'][key]['diagnostic']
     key_cam = coll.dobj['geom matrix'][key]['camera']
     key_data = coll.dobj['geom matrix'][key]['data']
     shape = coll.dobj['geom matrix'][key]['shape']
-    axis = coll.dobj['geom matrix'][key]['axis_chan']
-
-    # indbf
-    if indbf is None:
-        indbf = 0
-    try:
-        assert np.isscalar(indbf)
-        indbf = int(indbf)
-    except Exception as err:
-        msg = (
-            f"Arg indbf should be a int!\nProvided: {indt}"
-        )
-        raise Exception(msg)
+    axis_chan = coll.dobj['geom matrix'][key]['axis_chan']
+    axis_bs = coll.dobj['geom matrix'][key]['axis_bs']
+    axis_other = coll.dobj['geom matrix'][key]['axis_other']
+
+    # indbfi
+    indbf = ds._generic_check._check_var(
+        indbf, 'indbf',
+        types=int,
+        default=0,
+    )
 
     # indchan
-    if indchan is None:
-        indchan = 0
-    try:
-        assert np.isscalar(indchan)
-        indchan = int(indchan)
-    except Exception as err:
-        msg = (
-            f"Arg indchan should be a int!\nProvided: {indt}"
-        )
-        raise Exception(msg)
+    indchan = ds._generic_check._check_var(
+        indchan, 'indchan',
+        types=int,
+        default=0,
+    )
 
-    # indt
-    hastime = coll.get_time(key=key_data[0])[0]
-    if hastime:
-        if indt is None:
-            indt = 0
-        assert np.isscalar(indt), indt
-    else:
-        indt = None
+    # ind
+    indt = None
+    if axis_other is not None:
+        indt = 0
 
     # plot_mesh
     plot_mesh = ds._generic_check._check_var(
         plot_mesh, 'plot_mesh',
         default=coll.dobj[coll._which_mesh][keym]['type'] != 'polar',
         types=bool,
     )
@@ -142,196 +130,180 @@
         types=(bool, dict),
     )
 
     return (
         key,
         keybs, keym,
         key_diag, key_cam, key_data,
-        shape, axis,
+        shape, axis_chan, axis_bs, axis_other,
         indbf, indchan, indt,
         plot_mesh,
         cmap, vmin, vmax,
         aspect, dcolorbar, dleg,
     )
 
 
 def _plot_geometry_matrix_prepare(
     coll=None,
     key=None,
     key_data=None,
     keybs=None,
     keym=None,
+    axis_chan=None,
+    axis_bs=None,
+    axis_other=None,
     indbf=None,
     indchan=None,
     indt=None,
     res=None,
 ):
 
     # --------
     # prepare
 
     # res
     deg = coll.dobj['bsplines'][keybs]['deg']
     km = coll.dobj['bsplines'][keybs]['mesh']
-    meshtype = coll.dobj['mesh'][km]['type']
+    nd = coll.dobj['mesh'][km]['nd']
+    mtype = coll.dobj['mesh'][km]['type']
 
     # if polar => submesh
     km0 = km
-    meshtype0 = meshtype
-    if meshtype == 'polar':
-        km = coll.dobj[coll._which_mesh][km0]['submesh']
-        meshtype = coll.dobj[coll._which_mesh][km]['type']
-        shape2d = len(coll.dobj['bsplines'][keybs]['shape']) == 2
+    mtype0 = mtype
+    submesh = coll.dobj[coll._which_mesh][km0]['submesh']
+    if submesh is not None:
+        km = submesh
+        mtype = coll.dobj[coll._which_mesh][km]['type']
 
     # R, Z
     kR, kZ = coll.dobj['mesh'][km]['knots']
     Rk = coll.ddata[kR]['data']
     Zk = coll.ddata[kZ]['data']
 
     # get dR, dZ
-    dR, dZ, _, _ = _plot_bsplines_get_dRdZ(
-        coll=coll, km=km, meshtype=meshtype,
+    dR, dZ, _, _ = bs2._class02_plot_as_profile2d._plot_bsplines_get_dx01(
+        coll=coll, km=km,
     )
     if res is None:
-        if meshtype == 'rect':
-            res_coef = 0.05
+        if mtype == 'rect':
+            res_coef = 0.1
         else:
             res_coef = 0.25
-        res = [res_coef*dR, res_coef*dZ]
+        res = res_coef*dR
 
     # crop
     nchan, nbs = coll.dobj['geom matrix'][key]['shape'][-2:]
     crop = coll.dobj['geom matrix'][key]['crop']
 
     # --------
     # indices
 
     # indchan => indchan_bf
-    if meshtype0 == 'rect':
-        ich_bf_tup = coll.select_ind(
-            key=keybs,
-            returnas='tuple-flat',
-            crop=crop,
-        )
-        nbf = ich_bf_tup[0].size
-
-        # indbf_bool
-        indbf_bool = coll.select_ind(
-            key=keybs,
-            ind=(ich_bf_tup[0][indbf], ich_bf_tup[1][indbf]),
-            returnas=bool,
-            crop=crop,
-        )
-        ic = (np.zeros((nbf,), dtype=int), ich_bf_tup[0], ich_bf_tup[1])
-
-    elif meshtype0 == 'tri':
+    if nd == '1d':
         ich_bf_tup = coll.select_ind(
             key=keybs,
             returnas=int,
             crop=crop,
         )
         nbf = ich_bf_tup.size
 
         indbf_bool = coll.select_ind(
             key=keybs,
             ind=ich_bf_tup[indbf],
             returnas=bool,
             crop=crop,
         )
-        ic = (np.zeros((nbf,), dtype=int), ich_bf_tup)
 
     else:
-        if shape2d:
+        if mtype0 == 'rect':
             ich_bf_tup = coll.select_ind(
                 key=keybs,
                 returnas='tuple-flat',
                 crop=crop,
             )
             nbf = ich_bf_tup[0].size
 
             # indbf_bool
             indbf_bool = coll.select_ind(
                 key=keybs,
                 ind=(ich_bf_tup[0][indbf], ich_bf_tup[1][indbf]),
                 returnas=bool,
                 crop=crop,
             )
-            ic = (np.zeros((nbf,), dtype=int), ich_bf_tup[0], ich_bf_tup[1])
-        else:
+
+        elif mtype0 == 'tri':
             ich_bf_tup = coll.select_ind(
                 key=keybs,
                 returnas=int,
                 crop=crop,
             )
             nbf = ich_bf_tup.size
 
             indbf_bool = coll.select_ind(
                 key=keybs,
                 ind=ich_bf_tup[indbf],
                 returnas=bool,
                 crop=crop,
             )
-            ic = (np.zeros((nbf,), dtype=int), ich_bf_tup)
 
     assert nbs == nbf
 
-    hastime, hasref, reft, keyt, t, dind = coll.get_time(key=key_data[0])
-    if hastime:
-        nt = coll.dref[reft]['size']
-
     # -------------
     # mesh sampling
 
     # mesh sampling
-    km = coll.dobj['bsplines'][keybs]['mesh']
-    R, Z = coll.get_sample_mesh(
+    dout = coll.get_sample_mesh(
         key=km, res=res, mode='abs', grid=True, imshow=True,
     )
+    R = dout['x0']['data']
+    Z = dout['x1']['data']
 
     # -------------
     # interpolation
 
     # bspline details
-    shapebs = coll.dobj['bsplines'][keybs]['shape']
-
-    bsplinebase = coll.interpolate_profile2d(
-        key=keybs,
-        R=R,
-        Z=Z,
+    bsplinebase = coll.interpolate(
+        keys=None,
+        ref_key=keybs,
+        x0=R,
+        x1=Z,
+        grid=False,
+        submesh=True,
         crop=crop,
         nan0=True,
         details=True,
         return_params=False,
-    )[0]
+    )[f'{keybs}_details']['data']
+
+    gmat0 = coll.ddata[key_data[0]]['data']
+    if axis_other is not None:
+        diffdim = len(bsplinebase.shape) - 1 - len(gmat0.shape)
+        axo = axis_other if axis_other < axis_bs else axis_other + diffdim
+        bsplinebase = bsplinebase.take(indt, axis=axo)
 
     # bsplinetot
     coefstot = np.nansum(
         [
-            np.nansum(coll.ddata[kk]['data'], axis=-2)
+            np.nansum(coll.ddata[kk]['data'], axis=axis_chan)
             for kk in key_data
         ],
         axis=0,
     )
-    if hastime:
-        bsplinetot = np.nansum(
-            bsplinebase[0, ...] * coefstot[0, None, None, :],
-            axis=-1,
-        )
-    else:
-        bsplinetot = np.nansum(bsplinebase * coefstot[None, None, :], axis=-1)
+
+    if axis_other is not None:
+        coefstot = coefstot.take(indt, axis=axis_other)
+
+    bsplinetot = np.nansum(bsplinebase * coefstot[None, None, :], axis=-1)
 
     # bsplinedet
-    if hastime:
-        bsplinedet = np.zeros(tuple(np.r_[bsplinebase.shape[1:-1]]))#, nchan]))
-        for ii in range(0):
-            bsplinedet[...] = bsplinebase[0, ...].dot(
-                coll.ddata[key_data[0]]['data'][0, 0:1, :].T
-            )[..., 0]
-    else:
-        bsplinedet = bsplinebase.dot(coll.ddata[key_data[0]]['data'][0:1, :].T)[..., 0]
+    gmat0 = gmat0.take(indchan, axis=axis_chan)
+    if axis_other is not None:
+        axo = axis_other - 1 if axis_other > axis_chan else axis_other
+        gmat0 = gmat0.take(indt, axis=axo)
+    bsplinedet = np.nansum(bsplinebase * gmat0[None, None, :], axis=-1)
 
     # --------
     # LOS
 
     # los
     ptslos = None
     indlosok = None
@@ -390,15 +362,17 @@
     # resources
     coll=None,
     # parameters
     key=None,
     indbf=None,
     indchan=None,
     indt=None,
+    # options
     plot_mesh=None,
+    plot_config=None,
     # plotting
     vmin=None,
     vmax=None,
     res=None,
     cmap=None,
     aspect=None,
     dax=None,
@@ -411,15 +385,15 @@
     # --------------
     # check input
 
     (
         key,
         keybs, keym,
         key_diag, key_cam, key_data,
-        shape, axis,
+        shape, axis_chan, axis_bs, axis_other,
         indbf, indchan, indt,
         plot_mesh,
         cmap, vmin, vmax,
         aspect, dcolorbar, dleg,
     ) = _plot_geometry_matrix_check(
         coll=coll,
         key=key,
@@ -447,133 +421,38 @@
         coll1, refs,
     ) = _plot_geometry_matrix_prepare(
         coll=coll,
         key=key,
         key_data=key_data,
         keybs=keybs,
         keym=keym,
+        axis_chan=axis_chan,
+        axis_bs=axis_bs,
+        axis_other=axis_other,
         indbf=indbf,
         indchan=indchan,
         indt=indt,
         res=res,
     )
     nchan, nbs = shape[-2:]
 
     # --------------
     # plot - prepare
 
     if dax is None:
-
-        if fs is None:
-            fs = (16, 9)
-
-        if dmargin is None:
-            dmargin = {
-                'left': 0.05, 'right': 0.98,
-                'bottom': 0.05, 'top': 0.95,
-                'hspace': 0.20, 'wspace': 0.25,
-            }
-
-        fig = plt.figure(figsize=fs)
-        ncols = 4 + (indt is not None)
-        gs = gridspec.GridSpec(ncols=ncols, nrows=2, **dmargin)
-
-        # ax01 = matrix
-        ax01 = fig.add_subplot(gs[0, 1])
-        ax01.set_ylabel(f'channels')
-        ax01.set_xlabel(f'basis functions')
-        ax01.set_title(key, size=14)
-        ax01.tick_params(
-            axis="x",
-            bottom=False, top=True,
-            labelbottom=False, labeltop=True,
-        )
-        ax01.xaxis.set_label_position('top')
-
-        # ax00 = horizontal
-        ax00 = fig.add_subplot(gs[0, 0], sharex=ax01)
-        ax00.set_xlabel(f'basis functions')
-        ax00.set_ylabel(f'data')
-        ax00.set_ylim(vmin, vmax)
-
-        # ax02 = vertical
-        ax02 = fig.add_subplot(gs[0, 2], sharey=ax01)
-        ax02.set_xlabel(f'channels')
-        ax02.set_ylabel(f'data')
-        ax02.tick_params(
-            axis="x",
-            bottom=False, top=True,
-            labelbottom=False, labeltop=True,
-        )
-        ax02.xaxis.set_label_position('top')
-        ax02.tick_params(
-            axis="y",
-            left=False, right=True,
-            labelleft=False, labelright=True,
-        )
-        ax02.yaxis.set_label_position('right')
-        ax02.set_xlim(vmin, vmax)
-
-        if indt is not None:
-            axt = fig.add_subplot(gs[0, 3], sharey=ax00)
-            axt.set_xlabel(f'time')
-            axt.set_ylabel(f'data')
-
-
-        # ax10 = cross1
-        ax10 = fig.add_subplot(gs[1, 0], aspect='equal')
-        ax10.set_xlabel(f'R (m)')
-        ax10.set_ylabel(f'Z (m)')
-
-        # ax11 = crosstot
-        ax11 = fig.add_subplot(
-            gs[1, 1],
-            aspect='equal',
-            sharex=ax10,
-            sharey=ax10,
-        )
-        ax11.set_xlabel(f'R (m)')
-        ax11.set_ylabel(f'Z (m)')
-
-        # ax12 = cross2
-        ax12 = fig.add_subplot(
-            gs[1, 2],
-            aspect='equal',
-            sharex=ax10,
-            sharey=ax10,
+        dax = _create_dax(
+            fs=fs,
+            dmargin=dmargin,
+            indt=indt,
+            key=key,
+            vmin=vmin,
+            vmax=vmax,
         )
-        ax12.set_xlabel(f'R (m)')
-        ax12.set_ylabel(f'Z (m)')
-
-        # text
-        axt0 = fig.add_subplot(gs[0, -1], frameon=False)
-        axt0.set_xticks([])
-        axt0.set_yticks([])
-        axt1 = fig.add_subplot(gs[1, -1], frameon=False)
-        axt1.set_xticks([])
-        axt1.set_yticks([])
-
-        # define dax
-        dax = {
-            # matrix
-            'matrix': {'handle': ax01, 'inverty': True},
-            'vertical': {'handle': ax02, 'type': 'misc'},
-            'horizontal': {'handle': ax00, 'type': 'misc'},
-            # cross-section
-            'cross1': {'handle': ax10, 'type': 'cross'},
-            'cross2': {'handle': ax12, 'type': 'cross'},
-            'crosstot': {'handle': ax11, 'type': 'cross'},
-            # text
-            'text0': {'handle': axt0, 'type': 'text'},
-            'text1': {'handle': axt1, 'type': 'text'},
-        }
-        if indt is not None:
-            dax['traces'] = {'handle': axt, 'type': 'misc'}
 
-    dax = _generic_check._check_dax(dax=dax, main='matrix')
+    dax = ds._generic_check._check_dax(dax=dax, main='matrix')
 
     # --------------
     # plot mesh
 
     if plot_mesh is True:
         _ = coll.plot_mesh(
             key=keym, dax=dax, crop=True, dleg=False,
@@ -631,24 +510,24 @@
                 color='k',
             )
 
     kax = 'cross2'
     if dax.get(kax) is not None:
         ax = dax[kax]['handle']
 
-        coll.plot_bsplines(
-            key=keybs,
-            indbs=ich_bf,
-            indt=indt,
-            knots=False,
-            cents=False,
-            plot_mesh=False,
-            dax={'cross': dax[kax]},
-            dleg=False,
-        )
+        # coll.plot_bsplines(
+            # key=keybs,
+            # indbs=ich_bf,
+            # indt=indt,
+            # knots=False,
+            # cents=False,
+            # plot_mesh=False,
+            # dax={'cross': dax[kax]},
+            # dleg=False,
+        # )
 
         if ptslos is not None:
             for ii in indlosok:
                 ax.plot(
                     ptslos[ii][0, :],
                     ptslos[ii][1, :],
                     ls='-',
@@ -674,15 +553,148 @@
     # --------------
     # dleg
 
     # if dleg is not False:
         # dax['cross'].legend(**dleg)
 
     # -------
+    # config
+
+    if plot_config.__class__.__name__ == 'Config':
+
+        for kax in ['cross1', 'cross2', 'crosstot']:
+            if dax.get(kax) is not None:
+                ax = dax[kax]['handle']
+                plot_config.plot(lax=ax, proj='cross', dLeg=False)
+
+    # -------
     # connect
 
     coll2.setup_interactivity(kinter='inter0', dgroup=dgroup)
     coll2.disconnect_old()
     coll2.connect()
     coll2.show_commands()
 
     return coll2
+
+
+# ############################################################
+# ############################################################
+#           Create axes
+# ############################################################
+
+
+def _create_dax(
+    fs=None,
+    dmargin=None,
+    indt=None,
+    key=None,
+    vmin=None,
+    vmax=None,
+):
+    if fs is None:
+        fs = (16, 9)
+
+    if dmargin is None:
+        dmargin = {
+            'left': 0.05, 'right': 0.98,
+            'bottom': 0.05, 'top': 0.95,
+            'hspace': 0.20, 'wspace': 0.25,
+        }
+
+    fig = plt.figure(figsize=fs)
+    ncols = 4 + (indt is not None)
+    gs = gridspec.GridSpec(ncols=ncols, nrows=2, **dmargin)
+
+    # ax01 = matrix
+    ax01 = fig.add_subplot(gs[0, 1])
+    ax01.set_ylabel(f'channels')
+    ax01.set_xlabel(f'basis functions')
+    ax01.set_title(key, size=14)
+    ax01.tick_params(
+        axis="x",
+        bottom=False, top=True,
+        labelbottom=False, labeltop=True,
+    )
+    ax01.xaxis.set_label_position('top')
+
+    # ax00 = horizontal
+    ax00 = fig.add_subplot(gs[0, 0], sharex=ax01)
+    ax00.set_xlabel(f'basis functions')
+    ax00.set_ylabel(f'data')
+    ax00.set_ylim(vmin, vmax)
+
+    # ax02 = vertical
+    ax02 = fig.add_subplot(gs[0, 2], sharey=ax01)
+    ax02.set_xlabel(f'channels')
+    ax02.set_ylabel(f'data')
+    ax02.tick_params(
+        axis="x",
+        bottom=False, top=True,
+        labelbottom=False, labeltop=True,
+    )
+    ax02.xaxis.set_label_position('top')
+    ax02.tick_params(
+        axis="y",
+        left=False, right=True,
+        labelleft=False, labelright=True,
+    )
+    ax02.yaxis.set_label_position('right')
+    ax02.set_xlim(vmin, vmax)
+
+    if indt is not None:
+        axt = fig.add_subplot(gs[0, 3], sharey=ax00)
+        axt.set_xlabel(f'time')
+        axt.set_ylabel(f'data')
+
+
+    # ax10 = cross1
+    ax10 = fig.add_subplot(gs[1, 0], aspect='equal')
+    ax10.set_xlabel(f'R (m)')
+    ax10.set_ylabel(f'Z (m)')
+
+    # ax11 = crosstot
+    ax11 = fig.add_subplot(
+        gs[1, 1],
+        aspect='equal',
+        sharex=ax10,
+        sharey=ax10,
+    )
+    ax11.set_xlabel(f'R (m)')
+    ax11.set_ylabel(f'Z (m)')
+
+    # ax12 = cross2
+    ax12 = fig.add_subplot(
+        gs[1, 2],
+        aspect='equal',
+        sharex=ax10,
+        sharey=ax10,
+    )
+    ax12.set_xlabel(f'R (m)')
+    ax12.set_ylabel(f'Z (m)')
+
+    # text
+    axt0 = fig.add_subplot(gs[0, -1], frameon=False)
+    axt0.set_xticks([])
+    axt0.set_yticks([])
+    axt1 = fig.add_subplot(gs[1, -1], frameon=False)
+    axt1.set_xticks([])
+    axt1.set_yticks([])
+
+    # define dax
+    dax = {
+        # matrix
+        'matrix': {'handle': ax01, 'inverty': True},
+        'vertical': {'handle': ax02},
+        'horizontal': {'handle': ax00},
+        # cross-section
+        'cross1': {'handle': ax10, 'type': 'cross'},
+        'cross2': {'handle': ax12, 'type': 'cross'},
+        'crosstot': {'handle': ax11, 'type': 'cross'},
+        # text
+        'text0': {'handle': axt0, 'type': 'text'},
+        'text1': {'handle': axt1, 'type': 'text'},
+    }
+    if indt is not None:
+        dax['tracesZ'] = {'handle': axt}
+
+    return dax
```

### Comparing `tofu-1.6.5/tofu/data/_comp.py` & `tofu-1.7.0/tofu/data/_comp.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_core.py` & `tofu-1.7.0/tofu/data/_core.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_core_plot.py` & `tofu-1.7.0/tofu/data/_core_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_generic_check.py` & `tofu-1.7.0/tofu/data/_generic_check.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_generic_plot.py` & `tofu-1.7.0/tofu/data/_generic_plot.py`

 * *Files 18% similar despite different names*

```diff
@@ -13,18 +13,19 @@
 
 
 _GITHUB = "https://github.com/ToFuProject/tofu"
 _WINDEF = f"tofu {version.__version__} - report issues at {_GITHUB}"
 
 
 _DFS = {
-    1: (8, 5),
+    1: (10, 6),
     2: (16, 10),
     3: (16, 10),
     4: (16, 10),
+    5: (16, 10),
 }
 
 
 # #################################################################
 # #################################################################
 #               proj
 # #################################################################
@@ -32,15 +33,15 @@
 
 def _proj(
     proj=None,
     pall=None,
 ):
 
     if pall is None:
-        pall = ['cross', 'hor', '3d', 'camera']
+        pall = ['cross', 'hor', '3d', 'camera', 'traces']
 
     # proj
     if proj == 'all':
         proj = pall
 
     if isinstance(proj, str):
         proj = [proj]
@@ -135,28 +136,35 @@
     elif len(proj) == 3:
         gs, dgs = _ax_3(
             fig=fig,
             dmargin=dmargin,
             proj=proj,
             key_cam=key_cam,
         )
-    else:
+    elif len(proj) == 4:
         gs, dgs = _ax_4(
             fig=fig,
             dmargin=dmargin,
             proj=proj,
             key_cam=key_cam,
         )
-
+    else:
+        gs, dgs = _ax_5(
+            fig=fig,
+            dmargin=dmargin,
+            proj=proj,
+            key_cam=key_cam,
+        )
 
     # ----------------------
     # create figure and axes
 
     dax = {}
     for kk, vv in dgs.items():
+
         if vv['proj'] == '3d':
             ax = fig.add_subplot(
                 gs[vv['ind']],
                 projection='3d',
             )
         else:
             ax = fig.add_subplot(gs[vv['ind']])
@@ -191,28 +199,29 @@
             'bottom': 0.12, 'top': 0.9,
             'left': 0.10, 'right': 0.95,
         },
     )
 
     # ----------------------
     # prepare
-    
+
     nrows = 1
     nc = 1 if key_cam is None else len(key_cam)
-    if 'camera' in proj:
+    if 'camera' in proj or 'traces' in proj:
         nrows *= nc
-        
+
     gs = gridspec.GridSpec(ncols=1, nrows=nrows, **dmargin)
-        
+
     dgs = {}
     for ii, pp in enumerate(proj):
-        if pp == 'camera':
+        if pp in ['camera', 'traces']:
             for jj, k0 in enumerate(key_cam):
-                ind = (ii, 0)
-                dgs[k0] = {'proj': 'camera', 'ind': ind}
+                ind = (jj, 0)
+                kk = f'{k0}_sig' if pp == 'camera' else f'{k0}_trace'
+                dgs[kk] = {'proj': pp, 'ind': ind}
         else:
             ind = (slice(0, nc), 0)
             dgs[pp] = {'proj': pp, 'ind': ind}
 
     return gs, dgs
 
 
@@ -227,36 +236,39 @@
     # check inputs
 
     # dmargin
     dmargin = ds._generic_check._check_var(
         dmargin, 'dmargin',
         types=dict,
         default={
-            'bottom': 0.12, 'top': 0.9,
-            'left': 0.08, 'right': 0.98,
-            'wspace': 0.20, 'hspace': 0.05,
+            'bottom': 0.05, 'top': 0.95,
+            'left': 0.05, 'right': 0.98,
+            'wspace': 0.25, 'hspace': 0.2,
         },
     )
 
     # ----------------------
     # prepare
-    
+
     nrows = 1
     nc = 1 if key_cam is None else len(key_cam)
-    if 'camera' in proj:
+    if 'camera' in proj or 'traces' in proj:
         nrows *= nc
-        
+
     gs = gridspec.GridSpec(ncols=2, nrows=nrows, **dmargin)
-        
+
     dgs = {}
     for ii, pp in enumerate(proj):
-        if pp == 'camera':
+
+        if pp in ['camera', 'traces']:
             for jj, k0 in enumerate(key_cam):
                 ind = (jj, ii)
-                dgs[k0] = {'proj': 'camera', 'ind': ind}
+                kk = f'{k0}_sig' if pp == 'camera' else f'{k0}_trace'
+                dgs[kk] = {'proj': pp, 'ind': ind}
+
         else:
             ind = (slice(0, nc), ii)
             dgs[pp] = {'proj': pp, 'ind': ind}
 
     return gs, dgs
 
 
@@ -271,38 +283,54 @@
     # check inputs
 
     # dmargin
     dmargin = ds._generic_check._check_var(
         dmargin, 'dmargin',
         types=dict,
         default={
-            'bottom': 0.12, 'top': 0.9,
-            'left': 0.06, 'right': 0.98,
-            'wspace': 0.10, 'hspace': 0.05,
+            'bottom': 0.06, 'top': 0.92,
+            'left': 0.05, 'right': 0.98,
+            'wspace': 0.20, 'hspace': 0.3,
         },
     )
 
-    # ----------------------
+    # ----------
     # prepare
-    
+
+    hascam = 'camera' in proj or 'traces' in proj
+    hasboth = 'camera' in proj and 'traces' in proj
+
     nrows = 2
-    nc = 1 if key_cam is None else len(key_cam)
-    if 'camera' in proj:
-        nrows *= nc
-        
-    gs = gridspec.GridSpec(ncols=2, nrows=nrows, **dmargin)
-        
+    nc = len(key_cam) if hascam else 1
+
+    ncol = 2
+    colmult = 2 if hasboth else 1
+
+    gs = gridspec.GridSpec(ncols=ncol*colmult, nrows=nrows*nc, **dmargin)
+
+    # ---------
+    # assign
+
     dgs = {}
     for ii, pp in enumerate(proj):
-        if pp == 'camera':
+        if pp =='camera':
             for jj, k0 in enumerate(key_cam):
-                ind = (slice(2*jj, 2*(jj + 1)), 1)
-                dgs[k0] = {'proj': 'camera', 'ind': ind}
+                ind = (slice(2*jj, 2*(jj + 1)), colmult*ncol - 1)
+                kk = f'{k0}_sig'
+                dgs[kk] = {'proj': pp, 'ind': ind}
+        elif pp == 'traces':
+            for jj, k0 in enumerate(key_cam):
+                ind = (slice(2*jj, 2*(jj + 1)), colmult*(ncol - 1))
+                kk = f'{k0}_trace'
+                dgs[kk] = {'proj': pp, 'ind': ind}
         else:
-            ind = (slice(ii*nc, nc*(ii+1)), ii // 2)
+            if hascam:
+                ind = (slice(ii*nc, nc*(ii+1)), slice(0, colmult))
+            else:
+                ind = (ii%2, ii//2)
             dgs[pp] = {'proj': pp, 'ind': ind}
 
     return gs, dgs
 
 
 def _ax_4(
     fig=None,
@@ -315,41 +343,131 @@
     # check inputs
 
     # dmargin
     dmargin = ds._generic_check._check_var(
         dmargin, 'dmargin',
         types=dict,
         default={
-            'bottom': 0.08, 'top': 0.90,
-            'left': 0.06, 'right': 0.96,
-            'wspace': 0.20, 'hspace': 0.20,
+            'bottom': 0.05, 'top': 0.95,
+            'left': 0.05, 'right': 0.98,
+            'wspace': 0.30, 'hspace': 0.40,
             # 'width_ratios': [0.6, 0.4],
             # 'height_ratios': [0.4, 0.6],
         },
     )
 
-    # ----------------------
+    # -----------
     # prepare
-    
+
+    hascam = 'camera' in proj or 'traces' in proj
+    hasboth = 'camera' in proj and 'traces' in proj
+
+    ncol = 2
+    colmult = 2 if hasboth else 1
+
     nrows = 2
     nc = 1 if key_cam is None else len(key_cam)
-    if 'camera' in proj:
-        nrows *= nc
 
-    gs = gridspec.GridSpec(ncols=2, nrows=nrows, **dmargin)
-    
+    gs = gridspec.GridSpec(ncols=ncol*colmult, nrows=nrows*nc, **dmargin)
+
+    # -----------
+    # assign
+
+    dgs = {}
+    i0 = 0
+    for ii, pp in enumerate(proj):
+        if pp =='camera':
+            for jj, k0 in enumerate(key_cam):
+                if hasboth:
+                    ind = (slice(2*jj, 2*(jj + 1)), colmult*ncol - 1)
+                else:
+                    ind = (nc + jj, colmult*ncol - 1)
+                kk = f'{k0}_sig'
+                dgs[kk] = {'proj': pp, 'ind': ind}
+        elif pp == 'traces':
+            for jj, k0 in enumerate(key_cam):
+                if hasboth:
+                    ind = (slice(2*jj, 2*(jj + 1)), colmult*(ncol - 1))
+                else:
+                    ind = (nc + jj, colmult*(ncol - 1))
+                kk = f'{k0}_trace'
+                dgs[kk] = {'proj': pp, 'ind': ind}
+        else:
+            if hasboth:
+                ind = (slice((i0%2)*nc, nc*(i0%2+1)), slice(0, colmult))
+            else:
+                ind = (slice((i0%2)*nc, nc*(i0%2+1)), i0//2)
+            dgs[pp] = {'proj': pp, 'ind': ind}
+            i0 += 1
+
+    return gs, dgs
+
+
+def _ax_5(
+    fig=None,
+    dmargin=None,
+    proj=None,
+    key_cam=None,
+):
+
+    # ------------
+    # check inputs
+
+    # dmargin
+    dmargin = ds._generic_check._check_var(
+        dmargin, 'dmargin',
+        types=dict,
+        default={
+            'bottom': 0.05, 'top': 0.95,
+            'left': 0.05, 'right': 0.98,
+            'wspace': 0.30, 'hspace': 0.40,
+            # 'width_ratios': [0.6, 0.4],
+            # 'height_ratios': [0.4, 0.6],
+        },
+    )
+
+    # ----------
+    # prepare
+
+    hascam = 'camera' in proj or 'traces' in proj
+    hasboth = 'camera' in proj and 'traces' in proj
+
+    ncol = 3
+    colmult = 2 if hasboth else 1
+
+    nrows = 2
+    nc = 1 if key_cam is None else len(key_cam)
+
+    gs = gridspec.GridSpec(ncols=ncol*colmult, nrows=nrows*nc, **dmargin)
+
+    # -----------
+    # assign
+
     dgs = {}
+    i0 = 0
     for ii, pp in enumerate(proj):
         if pp == 'camera':
             for jj, k0 in enumerate(key_cam):
-                ind = (nc + jj, 1)
-                dgs[k0] = {'proj': 'camera', 'ind': ind}
+                ind = (slice(jj*2, (jj+1)*2), colmult*ncol - 1)
+                kk = f'{k0}_sig'
+                dgs[kk] = {'proj': 'camera', 'ind': ind}
+
+        elif pp == 'traces':
+            for jj, k0 in enumerate(key_cam):
+                ind = (slice(jj*2, (jj+1)*2), colmult*(ncol - 1))
+                kk = f'{k0}_trace'
+                dgs[kk] = {'proj': 'traces', 'ind': ind}
+
         else:
-            ind = (slice((ii % 2)*nc, (ii % 2)*nc + nc), ii//2)
+            ind = (
+                slice((i0 % 2)*nc, (i0 % 2)*nc + nc),
+                slice((i0 // 2)*colmult, (i0 // 2 + 1)*colmult),
+            )
             dgs[pp] = {'proj': pp, 'ind': ind}
+            i0 += 1
 
     return gs, dgs
 
 
 def _ax_set(ax=None, proj=None, is2d=None):
 
     if proj == 'cross':
@@ -376,8 +494,12 @@
         if is2d:
             ax.set_xlabel('x0 (m)')
             ax.set_ylabel('x1 (m)')
             ax.set_aspect('equal', adjustable='datalim')
         else:
             ax.set_xlabel('ind')
 
+    elif proj == 'traces':
+        # ax.set_xlabel()
+        ax.set_ylabel('data')
+
     return
```

### Comparing `tofu-1.6.5/tofu/data/_plot.py` & `tofu-1.7.0/tofu/data/_plot.py`

 * *Files 0% similar despite different names*

```diff
@@ -3269,16 +3269,16 @@
     Dlim = [min(0.,vmin), max(0.,vmax)]
     Dd = [Dlim[0]-0.05*np.diff(Dlim), Dlim[1]+0.05*np.diff(Dlim)]
     Dlab = r"{0} ({1})".format(Data.dlabels['data']['name'],
                                Data.dlabels['data']['units'])
     iddata = id(data)
 
     # singular values
-    Ds = (np.min(s),np.max(s))
-    Ds = (Ds[0], Ds[1]+0.05*np.diff(Ds))
+    Ds = (np.min(s), np.max(s))
+    Ds = (Ds[0], Ds[1] + 0.05*np.diff(Ds)[0])
     indmodes = np.arange(0,s.size)
     Dm = (-1, np.max(modes)+1)
     idm = id(indmodes)
 
     # chronos
     vabs_chronos = np.nanmax(np.abs(chronos[:,modes]))
     Dchronos = (-vabs_chronos, vabs_chronos)
```

### Comparing `tofu-1.6.5/tofu/data/_spectrallines_checks.py` & `tofu-1.7.0/tofu/data/_spectrallines_checks.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_spectrallines_class.py` & `tofu-1.7.0/tofu/data/_spectrallines_class.py`

 * *Files 8% similar despite different names*

```diff
@@ -33,27 +33,24 @@
 
 
 class SpectralLines(ds.DataStock):
 
     _ddef = copy.deepcopy(ds.DataStock._ddef)
     _ddef['params']['dobj'] = {
         'lines': {
-            'lambda0': (float, 0.),
-            'source': (str, 'unknown'),
-            'transition':    (str, 'unknown'),
-            'element':  (str, 'unknown'),
-            'charge':  (int, 0),
-            'ion':  (str, 'unknown'),
-            'symbol':   (str, 'unknown'),
+            'lambda0': {'cls': float, 'def': 0.},
+            'source': {'cls': str, 'def': 'unknown'},
+            'transition': {'cls': str, 'def': 'unknown'},
+            'element':  {'cls': str, 'def': 'unknown'},
+            'charge':  {'cls': int, 'def': 0},
+            'ion':  {'cls': str, 'def': 'unknown'},
+            'symbol':   {'cls': str, 'def': 'unknown'},
         },
     }
 
-    _show_in_summary_core = ['shape', 'ref']
-    _show_in_summary = 'all'
-
     _which_lines = _WHICH_LINES
     _quant_ne = _QUANT_NE
     _quant_Te = _QUANT_TE
 
     _units_lambda0 = _UNITS_LAMBDA0
 
     def add_line(
@@ -384,19 +381,18 @@
         }
 
         # Interpolate
         for ii, (k0, v0) in enumerate(dref.items()):
             douti, dparami = self.interpolate(
                 # interpolation base
                 keys=v0,
-                ref_keys=None,
-                ref_quant=[self._quant_ne, self._quant_Te],
+                ref_key=k0,
                 # interpolation pts
-                pts_axis0=dnTe['ne'],
-                pts_axis1=dnTe['Te'],
+                x0=dnTe['ne'],
+                x1=dnTe['Te'],
                 # parameters
                 deg=deg,
                 deriv=0,
                 grid=grid,
                 log_log=True,
                 return_params=True,
             )
@@ -404,25 +400,25 @@
             # update dict
             if ii == 0:
                 dout = douti
                 dparam = dparami
             else:
                 dout.update(**douti)
                 dparam['keys'] += dparami['keys']
-                dparam['ref_keys'] += dparami['ref_keys']
+                dparam['ref_key'] += dparami['ref_key']
 
         # -------
         # return
 
         if return_params is True:
             dparam['key'] = dparam['keys']
             del dparam['keys']
-            dparam['ne'] = dparam['pts_axis0']
-            dparam['Te'] = dparam['pts_axis1']
-            del dparam['pts_axis0'], dparam['pts_axis1'], dparam['pts_axis2']
+            dparam['ne'] = dparam['x0']
+            dparam['Te'] = dparam['x1']
+            del dparam['x0'], dparam['x1']
             return dout, dparam
         else:
             return dout
 
     def calc_intensity(
         self,
         key=None,
@@ -480,15 +476,15 @@
             key=[k0[:-4] for k0 in dparam['key']],
             concentration=concentration,
             shape=dparam['ne'].shape,
         )
 
         # Derive intensity
         for k0, v0 in dout.items():
-            dout[k0] = v0*dparam['ne']**2*concentration[k0[:-4]]
+            dout[k0] = v0['data']*dparam['ne']**2*concentration[k0[:-4]]
 
         return dout
 
     # -----------------
     # plotting
     # ------------------
 
@@ -599,18 +595,18 @@
         ne = float(ne)
         Te = float(Te)
         tit = (
             r'$n_e$' + f'= {ne} ' + r'$/m^3$'
             + r' -  $T_e$ = ' + f'{Te/1000.} keV'
         )
 
-        pmax = np.max([np.log10(v0) for v0 in dpec.values()])
-        pmin = np.min([np.log10(v0) for v0 in dpec.values()])
+        pmax = np.max([np.log10(v0['data']) for v0 in dpec.values()])
+        pmin = np.min([np.log10(v0['data']) for v0 in dpec.values()])
         dsize = {
-            k0[:-4]: (np.log10(v0) - pmin) / (pmax - pmin)*19 + 1
+            k0[:-4]: (np.log10(v0['data']) - pmin) / (pmax - pmin)*19 + 1
             for k0, v0 in dpec.items()
         }
 
         return _spectrallines_plot.plot_axvlines(
             din=self._dobj[self._which_lines],
             key=key,
             param_x=param_x,
```

### Comparing `tofu-1.6.5/tofu/data/_spectrallines_compute.py` & `tofu-1.7.0/tofu/data/_spectrallines_compute.py`

 * *Files 1% similar despite different names*

```diff
@@ -137,14 +137,15 @@
 
     # dobj (lines, ion, source)
     dobj = {
         which_lines: dlines,
         'ion': {k0: {} for k0 in lion},
         'source': dsource,
     }
+
     return ddata, dref, dobj
 
 
 # #############################################################################
 # #############################################################################
 #                       from nist
 # #############################################################################
@@ -343,22 +344,23 @@
         raise Exception(msg)
 
     # data_in
     if data_in is None:
         if returnas == 'data':
             msg = "If returnas='data', arg data cannot be None!"
             raise Exception(msg)
+
     else:
         if not isinstance(data_in, np.ndarray):
             try:
                 data_in = np.asarray(data_in)
             except Exception as err:
                 msg = "Arg data shall be convertible to a np.ndarray!"
                 raise Exception(msg)
-        if data_in.dtype not in [np.int, np.float]:
+        if data_in.dtype not in [int, float]:
             msg = (
                 """
                 Arg data must be a np.ndarray of dtype int or float!
                 data.dtype = {}
                 """.format(data.dtype.name)
             )
             raise Exception(msg)
```

### Comparing `tofu-1.6.5/tofu/data/_spectrallines_plot.py` & `tofu-1.7.0/tofu/data/_spectrallines_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/data/_utils_surface3d.py` & `tofu-1.7.0/tofu/data/_utils_surface3d.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/defaults.py` & `tofu-1.7.0/tofu/defaults.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/dumpro/_core.py` & `tofu-1.7.0/tofu/dumpro/_core.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/dust/_comp.py` & `tofu-1.7.0/tofu/dust/_comp.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/dust/_core.py` & `tofu-1.7.0/tofu/dust/_core.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/dust/_plot.py` & `tofu-1.7.0/tofu/dust/_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/entrypoints/_def.py` & `tofu-1.7.0/tofu/entrypoints/_def.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/entrypoints/tofucalc.py` & `tofu-1.7.0/tofu/entrypoints/tofucalc.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/entrypoints/tofuplot.py` & `tofu-1.7.0/tofu/entrypoints/tofuplot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_GG.pyx` & `tofu-1.7.0/tofu/geom/_GG.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -6870,9338 +6870,9338 @@
 0001ad50: 656e 206c 7374 7275 6374 5f6c 696d 730a  en lstruct_lims.
 0001ad60: 2020 2020 2222 220a 2020 2020 6364 6566      """.    cdef
 0001ad70: 206c 6973 7420 666c 6174 5f6c 6973 740a   list flat_list.
 0001ad80: 2020 2020 6364 6566 2064 6f75 626c 655b      cdef double[
 0001ad90: 3a3a 315d 206c 7374 7275 6374 5f6c 696d  ::1] lstruct_lim
 0001ada0: 735f 6e70 0a20 2020 2069 6620 6c73 7472  s_np.    if lstr
 0001adb0: 7563 745f 6c69 6d73 2069 7320 4e6f 6e65  uct_lims is None
-0001adc0: 206f 7220 6e70 2e73 697a 6528 6c73 7472   or np.size(lstr
-0001add0: 7563 745f 6c69 6d73 2920 3d3d 2030 3a0a  uct_lims) == 0:.
-0001ade0: 2020 2020 2020 2020 6c73 7472 7563 745f          lstruct_
-0001adf0: 6c69 6d73 5f6e 7020 3d20 6e70 2e61 7272  lims_np = np.arr
-0001ae00: 6179 285b 435f 4e41 4e5d 290a 2020 2020  ay([C_NAN]).    
-0001ae10: 656c 7365 3a0a 2020 2020 2020 2020 666c  else:.        fl
-0001ae20: 6174 5f6c 6973 7420 3d20 5b5d 0a20 2020  at_list = [].   
-0001ae30: 2020 2020 2066 6f72 2065 6c65 2069 6e20       for ele in 
-0001ae40: 6c73 7472 7563 745f 6c69 6d73 3a0a 2020  lstruct_lims:.  
-0001ae50: 2020 2020 2020 2020 2020 6966 2069 7369            if isi
-0001ae60: 6e73 7461 6e63 6528 656c 652c 2028 6c69  nstance(ele, (li
-0001ae70: 7374 2c20 6e70 2e6e 6461 7272 6179 2929  st, np.ndarray))
-0001ae80: 2061 6e64 206e 702e 7369 7a65 2865 6c65   and np.size(ele
-0001ae90: 2920 3e20 313a 0a20 2020 2020 2020 2020  ) > 1:.         
-0001aea0: 2020 2020 2020 2066 6f72 2065 6c65 6c65         for elele
-0001aeb0: 2069 6e20 656c 653a 0a20 2020 2020 2020   in ele:.       
-0001aec0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0001aed0: 7479 7065 2865 6c65 6c65 2920 6973 206c  type(elele) is l
-0001aee0: 6973 743a 0a20 2020 2020 2020 2020 2020  ist:.           
-0001aef0: 2020 2020 2020 2020 2020 2020 2066 6c61               fla
-0001af00: 745f 6c69 7374 202b 3d20 656c 656c 650a  t_list += elele.
+0001adc0: 206f 7220 6c65 6e28 6c73 7472 7563 745f   or len(lstruct_
+0001add0: 6c69 6d73 2920 3d3d 2030 3a0a 2020 2020  lims) == 0:.    
+0001ade0: 2020 2020 6c73 7472 7563 745f 6c69 6d73      lstruct_lims
+0001adf0: 5f6e 7020 3d20 6e70 2e61 7272 6179 285b  _np = np.array([
+0001ae00: 435f 4e41 4e5d 290a 2020 2020 656c 7365  C_NAN]).    else
+0001ae10: 3a0a 2020 2020 2020 2020 666c 6174 5f6c  :.        flat_l
+0001ae20: 6973 7420 3d20 5b5d 0a20 2020 2020 2020  ist = [].       
+0001ae30: 2066 6f72 2065 6c65 2069 6e20 6c73 7472   for ele in lstr
+0001ae40: 7563 745f 6c69 6d73 3a0a 2020 2020 2020  uct_lims:.      
+0001ae50: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+0001ae60: 6e63 6528 656c 652c 2028 6c69 7374 2c20  nce(ele, (list, 
+0001ae70: 6e70 2e6e 6461 7272 6179 2929 2061 6e64  np.ndarray)) and
+0001ae80: 206e 702e 7369 7a65 2865 6c65 2920 3e20   np.size(ele) > 
+0001ae90: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
+0001aea0: 2020 2066 6f72 2065 6c65 6c65 2069 6e20     for elele in 
+0001aeb0: 656c 653a 0a20 2020 2020 2020 2020 2020  ele:.           
+0001aec0: 2020 2020 2020 2020 2069 6620 7479 7065           if type
+0001aed0: 2865 6c65 6c65 2920 6973 206c 6973 743a  (elele) is list:
+0001aee0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001aef0: 2020 2020 2020 2020 2066 6c61 745f 6c69           flat_li
+0001af00: 7374 202b 3d20 656c 656c 650a 2020 2020  st += elele.    
 0001af10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001af20: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001af30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001af40: 2020 666c 6174 5f6c 6973 7420 2b3d 2065    flat_list += e
-0001af50: 6c65 6c65 2e66 6c61 7474 656e 2829 2e74  lele.flatten().t
-0001af60: 6f6c 6973 7428 290a 2020 2020 2020 2020  olist().        
-0001af70: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001af80: 2020 2020 2020 2020 2020 666c 6174 5f6c            flat_l
-0001af90: 6973 7420 2b3d 205b 435f 4e41 4e5d 0a20  ist += [C_NAN]. 
-0001afa0: 2020 2020 2020 206c 7374 7275 6374 5f6c         lstruct_l
-0001afb0: 696d 735f 6e70 203d 206e 702e 6172 7261  ims_np = np.arra
-0001afc0: 7928 666c 6174 5f6c 6973 7429 0a0a 2020  y(flat_list)..  
-0001afd0: 2020 7265 7475 726e 206c 7374 7275 6374    return lstruct
-0001afe0: 5f6c 696d 735f 6e70 0a0a 0a23 203d 3d3d  _lims_np...# ===
+0001af20: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001af30: 2020 2020 2020 2020 2020 2020 2020 666c                fl
+0001af40: 6174 5f6c 6973 7420 2b3d 2065 6c65 6c65  at_list += elele
+0001af50: 2e66 6c61 7474 656e 2829 2e74 6f6c 6973  .flatten().tolis
+0001af60: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
+0001af70: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001af80: 2020 2020 2020 666c 6174 5f6c 6973 7420        flat_list 
+0001af90: 2b3d 205b 435f 4e41 4e5d 0a20 2020 2020  += [C_NAN].     
+0001afa0: 2020 206c 7374 7275 6374 5f6c 696d 735f     lstruct_lims_
+0001afb0: 6e70 203d 206e 702e 6172 7261 7928 666c  np = np.array(fl
+0001afc0: 6174 5f6c 6973 7429 0a0a 2020 2020 7265  at_list)..    re
+0001afd0: 7475 726e 206c 7374 7275 6374 5f6c 696d  turn lstruct_lim
+0001afe0: 735f 6e70 0a0a 0a23 203d 3d3d 3d3d 3d3d  s_np...# =======
 0001aff0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001b000: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001b010: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001b020: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001b030: 3d3d 3d3d 3d3d 3d3d 3d3d 0a23 203d 2054  ==========.# = T
-0001b040: 6f6f 6c73 2074 6f20 6b6e 6f77 2069 6620  ools to know if 
-0001b050: 6f6e 6520 6f72 206d 756c 7469 706c 6520  one or multiple 
-0001b060: 706f 696e 7473 2061 7265 2076 6973 6962  points are visib
-0001b070: 6c65 2066 726f 6d20 6f74 6865 7220 706f  le from other po
-0001b080: 696e 7473 0a23 203d 3d3d 3d3d 3d3d 3d3d  ints.# =========
+0001b030: 3d3d 3d3d 3d3d 0a23 203d 2054 6f6f 6c73  ======.# = Tools
+0001b040: 2074 6f20 6b6e 6f77 2069 6620 6f6e 6520   to know if one 
+0001b050: 6f72 206d 756c 7469 706c 6520 706f 696e  or multiple poin
+0001b060: 7473 2061 7265 2076 6973 6962 6c65 2066  ts are visible f
+0001b070: 726f 6d20 6f74 6865 7220 706f 696e 7473  rom other points
+0001b080: 0a23 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  .# =============
 0001b090: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001b0a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001b0b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001b0c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001b0d0: 3d3d 3d3d 0a64 6566 204c 4f53 5f61 7265  ====.def LOS_are
-0001b0e0: 5669 735f 5074 7346 726f 6d50 7473 5f56  Vis_PtsFromPts_V
-0001b0f0: 6573 5374 7275 6374 286e 702e 6e64 6172  esStruct(np.ndar
-0001b100: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
-0001b110: 3d32 2c6d 6f64 653d 2763 275d 2070 7473  =2,mode='c'] pts
-0001b120: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
+0001b0d0: 0a64 6566 204c 4f53 5f61 7265 5669 735f  .def LOS_areVis_
+0001b0e0: 5074 7346 726f 6d50 7473 5f56 6573 5374  PtsFromPts_VesSt
+0001b0f0: 7275 6374 286e 702e 6e64 6172 7261 795b  ruct(np.ndarray[
+0001b100: 646f 7562 6c65 2c20 6e64 696d 3d32 2c6d  double, ndim=2,m
+0001b110: 6f64 653d 2763 275d 2070 7473 312c 0a20  ode='c'] pts1,. 
+0001b120: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b140: 2020 2020 2020 206e 702e 6e64 6172 7261         np.ndarra
-0001b150: 795b 646f 7562 6c65 2c20 6e64 696d 3d32  y[double, ndim=2
-0001b160: 2c6d 6f64 653d 2763 275d 2070 7473 322c  ,mode='c'] pts2,
-0001b170: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001b140: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
+0001b150: 7562 6c65 2c20 6e64 696d 3d32 2c6d 6f64  uble, ndim=2,mod
+0001b160: 653d 2763 275d 2070 7473 322c 0a20 2020  e='c'] pts2,.   
+0001b170: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b190: 2020 2020 2064 6f75 626c 655b 3a2c 203a       double[:, :
-0001b1a0: 3a31 5d20 7665 735f 706f 6c79 3d4e 6f6e  :1] ves_poly=Non
-0001b1b0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0001b190: 2064 6f75 626c 655b 3a2c 203a 3a31 5d20   double[:, ::1] 
+0001b1a0: 7665 735f 706f 6c79 3d4e 6f6e 652c 0a20  ves_poly=None,. 
+0001b1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b1d0: 2020 2020 2020 2064 6f75 626c 655b 3a2c         double[:,
-0001b1e0: 203a 3a31 5d20 7665 735f 6e6f 726d 3d4e   ::1] ves_norm=N
-0001b1f0: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
+0001b1d0: 2020 2064 6f75 626c 655b 3a2c 203a 3a31     double[:, ::1
+0001b1e0: 5d20 7665 735f 6e6f 726d 3d4e 6f6e 652c  ] ves_norm=None,
+0001b1f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0001b200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b210: 2020 2020 2020 2020 2064 6f75 626c 655b           double[
-0001b220: 3a2c 203a 3a31 5d20 6469 7374 3d4e 6f6e  :, ::1] dist=Non
-0001b230: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0001b210: 2020 2020 2064 6f75 626c 655b 3a2c 203a       double[:, :
+0001b220: 3a31 5d20 6469 7374 3d4e 6f6e 652c 0a20  :1] dist=None,. 
+0001b230: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b250: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
-0001b260: 315d 2076 6573 5f6c 696d 733d 4e6f 6e65  1] ves_lims=None
-0001b270: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001b250: 2020 2064 6f75 626c 655b 3a3a 315d 2076     double[::1] v
+0001b260: 6573 5f6c 696d 733d 4e6f 6e65 2c0a 2020  es_lims=None,.  
+0001b270: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b290: 2020 2020 2020 6c6f 6e67 5b3a 3a31 5d20        long[::1] 
-0001b2a0: 6c73 7472 7563 745f 6e6c 696d 3d4e 6f6e  lstruct_nlim=Non
-0001b2b0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0001b290: 2020 6c6f 6e67 5b3a 3a31 5d20 6c73 7472    long[::1] lstr
+0001b2a0: 7563 745f 6e6c 696d 3d4e 6f6e 652c 0a20  uct_nlim=None,. 
+0001b2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b2d0: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
-0001b2e0: 315d 206c 7374 7275 6374 5f70 6f6c 7978  1] lstruct_polyx
-0001b2f0: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
+0001b2d0: 2020 2064 6f75 626c 655b 3a3a 315d 206c     double[::1] l
+0001b2e0: 7374 7275 6374 5f70 6f6c 7978 3d4e 6f6e  struct_polyx=Non
+0001b2f0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
 0001b300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b310: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-0001b320: 655b 3a3a 315d 206c 7374 7275 6374 5f70  e[::1] lstruct_p
-0001b330: 6f6c 7979 3d4e 6f6e 652c 0a20 2020 2020  olyy=None,.     
+0001b310: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
+0001b320: 315d 206c 7374 7275 6374 5f70 6f6c 7979  1] lstruct_polyy
+0001b330: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
 0001b340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b350: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0001b360: 6973 7420 6c73 7472 7563 745f 6c69 6d73  ist lstruct_lims
-0001b370: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
+0001b350: 2020 2020 2020 2020 2020 206c 6973 7420             list 
+0001b360: 6c73 7472 7563 745f 6c69 6d73 3d4e 6f6e  lstruct_lims=Non
+0001b370: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
 0001b380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b390: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-0001b3a0: 655b 3a3a 315d 206c 7374 7275 6374 5f6e  e[::1] lstruct_n
-0001b3b0: 6f72 6d78 3d4e 6f6e 652c 0a20 2020 2020  ormx=None,.     
+0001b390: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
+0001b3a0: 315d 206c 7374 7275 6374 5f6e 6f72 6d78  1] lstruct_normx
+0001b3b0: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
 0001b3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b3d0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0001b3e0: 6f75 626c 655b 3a3a 315d 206c 7374 7275  ouble[::1] lstru
-0001b3f0: 6374 5f6e 6f72 6d79 3d4e 6f6e 652c 0a20  ct_normy=None,. 
+0001b3d0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+0001b3e0: 655b 3a3a 315d 206c 7374 7275 6374 5f6e  e[::1] lstruct_n
+0001b3f0: 6f72 6d79 3d4e 6f6e 652c 0a20 2020 2020  ormy=None,.     
 0001b400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b420: 2020 206c 6f6e 675b 3a3a 315d 206c 6e76     long[::1] lnv
-0001b430: 6572 743d 4e6f 6e65 2c0a 2020 2020 2020  ert=None,.      
+0001b410: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0001b420: 6f6e 675b 3a3a 315d 206c 6e76 6572 743d  ong[::1] lnvert=
+0001b430: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
 0001b440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b450: 2020 2020 2020 2020 2020 2020 2020 696e                in
-0001b460: 7420 6e73 7472 7563 745f 746f 743d 302c  t nstruct_tot=0,
-0001b470: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001b450: 2020 2020 2020 2020 2020 696e 7420 6e73            int ns
+0001b460: 7472 7563 745f 746f 743d 302c 0a20 2020  truct_tot=0,.   
+0001b470: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b490: 2020 2020 2069 6e74 206e 7374 7275 6374       int nstruct
-0001b4a0: 5f6c 696d 3d30 2c0a 2020 2020 2020 2020  _lim=0,.        
+0001b490: 2069 6e74 206e 7374 7275 6374 5f6c 696d   int nstruct_lim
+0001b4a0: 3d30 2c0a 2020 2020 2020 2020 2020 2020  =0,.            
 0001b4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b4c0: 2020 2020 2020 2020 2020 2020 646f 7562              doub
-0001b4d0: 6c65 2072 6d69 6e3d 2d31 2c0a 2020 2020  le rmin=-1,.    
+0001b4c0: 2020 2020 2020 2020 646f 7562 6c65 2072          double r
+0001b4d0: 6d69 6e3d 2d31 2c0a 2020 2020 2020 2020  min=-1,.        
 0001b4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b500: 646f 7562 6c65 2065 7073 5f75 7a3d 5f53  double eps_uz=_S
-0001b510: 4d41 4c4c 2c20 646f 7562 6c65 2065 7073  MALL, double eps
-0001b520: 5f61 3d5f 5653 4d41 4c4c 2c0a 2020 2020  _a=_VSMALL,.    
+0001b4f0: 2020 2020 2020 2020 2020 2020 646f 7562              doub
+0001b500: 6c65 2065 7073 5f75 7a3d 5f53 4d41 4c4c  le eps_uz=_SMALL
+0001b510: 2c20 646f 7562 6c65 2065 7073 5f61 3d5f  , double eps_a=_
+0001b520: 5653 4d41 4c4c 2c0a 2020 2020 2020 2020  VSMALL,.        
 0001b530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b550: 646f 7562 6c65 2065 7073 5f76 7a3d 5f56  double eps_vz=_V
-0001b560: 534d 414c 4c2c 2064 6f75 626c 6520 6570  SMALL, double ep
-0001b570: 735f 623d 5f56 534d 414c 4c2c 0a20 2020  s_b=_VSMALL,.   
+0001b540: 2020 2020 2020 2020 2020 2020 646f 7562              doub
+0001b550: 6c65 2065 7073 5f76 7a3d 5f56 534d 414c  le eps_vz=_VSMAL
+0001b560: 4c2c 2064 6f75 626c 6520 6570 735f 623d  L, double eps_b=
+0001b570: 5f56 534d 414c 4c2c 0a20 2020 2020 2020  _VSMALL,.       
 0001b580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b5a0: 2064 6f75 626c 6520 6570 735f 706c 616e   double eps_plan
-0001b5b0: 653d 5f56 534d 414c 4c2c 0a20 2020 2020  e=_VSMALL,.     
+0001b590: 2020 2020 2020 2020 2020 2020 2064 6f75               dou
+0001b5a0: 626c 6520 6570 735f 706c 616e 653d 5f56  ble eps_plane=_V
+0001b5b0: 534d 414c 4c2c 0a20 2020 2020 2020 2020  SMALL,.         
 0001b5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b5d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0001b5e0: 7472 2076 6573 5f74 7970 653d 2774 6f72  tr ves_type='tor
-0001b5f0: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
+0001b5d0: 2020 2020 2020 2020 2020 2073 7472 2076             str v
+0001b5e0: 6573 5f74 7970 653d 2774 6f72 272c 0a20  es_type='tor',. 
+0001b5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001b600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b610: 2020 2020 2020 2062 696e 7420 666f 7262         bint forb
-0001b620: 6964 3d54 7275 652c 0a20 2020 2020 2020  id=True,.       
+0001b610: 2020 2062 696e 7420 666f 7262 6964 3d54     bint forbid=T
+0001b620: 7275 652c 0a20 2020 2020 2020 2020 2020  rue,.           
 0001b630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b640: 2020 2020 2020 2020 2020 2020 2062 696e               bin
-0001b650: 7420 7465 7374 3d54 7275 652c 0a20 2020  t test=True,.   
+0001b640: 2020 2020 2020 2020 2062 696e 7420 7465           bint te
+0001b650: 7374 3d54 7275 652c 0a20 2020 2020 2020  st=True,.       
 0001b660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b680: 2069 6e74 206e 756d 5f74 6872 6561 6473   int num_threads
-0001b690: 3d31 3629 3a0a 2020 2020 2222 220a 2020  =16):.    """.  
-0001b6a0: 2020 5265 7475 726e 2061 6e20 6172 7261    Return an arra
-0001b6b0: 7920 6f66 2062 6f6f 6c65 616e 7320 696e  y of booleans in
-0001b6c0: 6469 6361 7469 6e67 2077 6865 7468 6572  dicating whether
-0001b6d0: 2065 6163 6820 706f 696e 7420 696e 2070   each point in p
-0001b6e0: 7473 3120 6361 6e20 7365 650a 2020 2020  ts1 can see.    
-0001b6f0: 6561 6368 2070 6f69 6e74 2069 6e20 7074  each point in pt
-0001b700: 7332 2063 6f6e 7369 6465 7269 6e67 2076  s2 considering v
-0001b710: 6967 6e65 7474 696e 6720 6120 6769 7665  ignetting a give
-0001b720: 6e0a 2020 2020 636f 6e66 6967 7572 6174  n.    configurat
-0001b730: 696f 6e2e 0a20 2020 2020 2020 2070 7473  ion..        pts
-0001b740: 3120 3a20 2833 2c20 6e70 7473 3129 2063  1 : (3, npts1) c
-0001b750: 6172 7465 7369 616e 2063 6f6f 7264 696e  artesian coordin
-0001b760: 6174 6573 206f 6620 7669 6577 696e 6720  ates of viewing 
-0001b770: 706f 696e 7473 0a20 2020 2020 2020 2070  points.        p
-0001b780: 7473 3220 3a20 2833 2c20 6e70 7473 3229  ts2 : (3, npts2)
-0001b790: 2063 6172 7465 7369 616e 2063 6f6f 7264   cartesian coord
-0001b7a0: 696e 6174 6573 206f 6620 706f 696e 7473  inates of points
-0001b7b0: 2074 6f20 6368 6563 6b20 6966 2076 6965   to check if vie
-0001b7c0: 7761 626c 650a 2020 2020 2020 2020 6469  wable.        di
-0001b7d0: 7374 203a 206f 7074 696f 6e61 6c20 6172  st : optional ar
-0001b7e0: 6775 6d65 6e74 203a 2064 6973 7461 6e63  gument : distanc
-0001b7f0: 6520 6265 7477 6565 6e20 7468 6520 706f  e between the po
-0001b800: 696e 7473 2070 7473 312c 2070 7473 320a  ints pts1, pts2.
-0001b810: 2020 2020 2020 2020 7665 735f 2a20 3a20          ves_* : 
-0001b820: 7665 7373 656c 2064 6573 6372 6970 746f  vessel descripto
-0001b830: 7273 2028 706f 6c79 2c20 6e6f 726d 2c20  rs (poly, norm, 
-0001b840: 6c69 6d69 7473 290a 2020 2020 2020 2020  limits).        
-0001b850: 6c73 7472 7563 745f 2a20 3a20 636f 6e66  lstruct_* : conf
-0001b860: 6967 2773 2073 7472 7563 7475 7265 2064  ig's structure d
-0001b870: 6573 6372 6970 746f 7273 2028 706f 6c79  escriptors (poly
-0001b880: 2c20 6c69 6d69 7473 2c20 6e6f 726d 732c  , limits, norms,
-0001b890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001b8a0: 2020 2020 206e 756d 6265 7220 6f66 2073       number of s
-0001b8b0: 7472 7563 7475 7265 732c 202e 2e2e 290a  tructures, ...).
-0001b8c0: 2020 2020 2020 2020 6570 735f 2a20 3a20          eps_* : 
-0001b8d0: 7661 6c75 6573 206f 6620 7072 6563 6973  values of precis
-0001b8e0: 696f 6e20 696e 2065 6163 6820 6469 7265  ion in each dire
-0001b8f0: 6374 696f 6e0a 2020 2020 2020 2020 666f  ction.        fo
-0001b900: 7262 6964 203a 2062 6f6f 6c65 616e 2069  rbid : boolean i
-0001b910: 6620 7472 7565 2066 6f72 6269 6473 2063  f true forbids c
-0001b920: 6865 636b 696e 6720 2262 6568 696e 6422  hecking "behind"
-0001b930: 2074 6865 2074 6f6b 616d 616b 0a20 2020   the tokamak.   
-0001b940: 2020 2020 2074 6573 7420 3a20 626f 6f6c       test : bool
-0001b950: 6561 6e20 6368 6563 6b20 6966 2069 6e70  ean check if inp
-0001b960: 7574 2069 7320 7661 6c69 6420 6f72 206e  ut is valid or n
-0001b970: 6f74 0a20 2020 2020 2020 206e 756d 5f74  ot.        num_t
-0001b980: 6872 6561 6473 203a 206e 756d 6265 7220  hreads : number 
-0001b990: 6f66 2074 6872 6561 6473 2066 6f72 2070  of threads for p
-0001b9a0: 6172 616c 6c65 6c69 7a61 7469 6f6e 0a20  arallelization. 
-0001b9b0: 2020 204f 7574 7075 743a 0a20 2020 2020     Output:.     
-0001b9c0: 2020 2061 7265 5f73 6565 6e3a 2028 6e70     are_seen: (np
-0001b9d0: 7473 312c 206e 7074 7332 2920 6172 7261  ts1, npts2) arra
-0001b9e0: 7920 6f66 2069 6e74 7320 696e 6469 6361  y of ints indica
-0001b9f0: 7469 6e67 2069 6620 7669 6577 696e 6720  ting if viewing 
-0001ba00: 706f 696e 7473 2070 7473 310a 2020 2020  points pts1.    
-0001ba10: 2020 2020 2020 2020 2020 2020 2020 6361                ca
-0001ba20: 6e20 7365 6520 7468 6520 6f74 6865 7220  n see the other 
-0001ba30: 706f 696e 7473 2070 7473 322e 0a20 2020  points pts2..   
-0001ba40: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0001ba50: 7265 5f73 6565 6e5b 692c 6a5d 203d 2031  re_seen[i,j] = 1
-0001ba60: 2069 6620 7074 7331 5b69 5d20 7365 6573   if pts1[i] sees
-0001ba70: 2070 6f69 6e74 2070 7473 325b 6a5d 0a20   point pts2[j]. 
+0001b670: 2020 2020 2020 2020 2020 2020 2069 6e74               int
+0001b680: 206e 756d 5f74 6872 6561 6473 3d31 3629   num_threads=16)
+0001b690: 3a0a 2020 2020 2222 220a 2020 2020 5265  :.    """.    Re
+0001b6a0: 7475 726e 2061 6e20 6172 7261 7920 6f66  turn an array of
+0001b6b0: 2062 6f6f 6c65 616e 7320 696e 6469 6361   booleans indica
+0001b6c0: 7469 6e67 2077 6865 7468 6572 2065 6163  ting whether eac
+0001b6d0: 6820 706f 696e 7420 696e 2070 7473 3120  h point in pts1 
+0001b6e0: 6361 6e20 7365 650a 2020 2020 6561 6368  can see.    each
+0001b6f0: 2070 6f69 6e74 2069 6e20 7074 7332 2063   point in pts2 c
+0001b700: 6f6e 7369 6465 7269 6e67 2076 6967 6e65  onsidering vigne
+0001b710: 7474 696e 6720 6120 6769 7665 6e0a 2020  tting a given.  
+0001b720: 2020 636f 6e66 6967 7572 6174 696f 6e2e    configuration.
+0001b730: 0a20 2020 2020 2020 2070 7473 3120 3a20  .        pts1 : 
+0001b740: 2833 2c20 6e70 7473 3129 2063 6172 7465  (3, npts1) carte
+0001b750: 7369 616e 2063 6f6f 7264 696e 6174 6573  sian coordinates
+0001b760: 206f 6620 7669 6577 696e 6720 706f 696e   of viewing poin
+0001b770: 7473 0a20 2020 2020 2020 2070 7473 3220  ts.        pts2 
+0001b780: 3a20 2833 2c20 6e70 7473 3229 2063 6172  : (3, npts2) car
+0001b790: 7465 7369 616e 2063 6f6f 7264 696e 6174  tesian coordinat
+0001b7a0: 6573 206f 6620 706f 696e 7473 2074 6f20  es of points to 
+0001b7b0: 6368 6563 6b20 6966 2076 6965 7761 626c  check if viewabl
+0001b7c0: 650a 2020 2020 2020 2020 6469 7374 203a  e.        dist :
+0001b7d0: 206f 7074 696f 6e61 6c20 6172 6775 6d65   optional argume
+0001b7e0: 6e74 203a 2064 6973 7461 6e63 6520 6265  nt : distance be
+0001b7f0: 7477 6565 6e20 7468 6520 706f 696e 7473  tween the points
+0001b800: 2070 7473 312c 2070 7473 320a 2020 2020   pts1, pts2.    
+0001b810: 2020 2020 7665 735f 2a20 3a20 7665 7373      ves_* : vess
+0001b820: 656c 2064 6573 6372 6970 746f 7273 2028  el descriptors (
+0001b830: 706f 6c79 2c20 6e6f 726d 2c20 6c69 6d69  poly, norm, limi
+0001b840: 7473 290a 2020 2020 2020 2020 6c73 7472  ts).        lstr
+0001b850: 7563 745f 2a20 3a20 636f 6e66 6967 2773  uct_* : config's
+0001b860: 2073 7472 7563 7475 7265 2064 6573 6372   structure descr
+0001b870: 6970 746f 7273 2028 706f 6c79 2c20 6c69  iptors (poly, li
+0001b880: 6d69 7473 2c20 6e6f 726d 732c 0a20 2020  mits, norms,.   
+0001b890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b8a0: 206e 756d 6265 7220 6f66 2073 7472 7563   number of struc
+0001b8b0: 7475 7265 732c 202e 2e2e 290a 2020 2020  tures, ...).    
+0001b8c0: 2020 2020 6570 735f 2a20 3a20 7661 6c75      eps_* : valu
+0001b8d0: 6573 206f 6620 7072 6563 6973 696f 6e20  es of precision 
+0001b8e0: 696e 2065 6163 6820 6469 7265 6374 696f  in each directio
+0001b8f0: 6e0a 2020 2020 2020 2020 666f 7262 6964  n.        forbid
+0001b900: 203a 2062 6f6f 6c65 616e 2069 6620 7472   : boolean if tr
+0001b910: 7565 2066 6f72 6269 6473 2063 6865 636b  ue forbids check
+0001b920: 696e 6720 2262 6568 696e 6422 2074 6865  ing "behind" the
+0001b930: 2074 6f6b 616d 616b 0a20 2020 2020 2020   tokamak.       
+0001b940: 2074 6573 7420 3a20 626f 6f6c 6561 6e20   test : boolean 
+0001b950: 6368 6563 6b20 6966 2069 6e70 7574 2069  check if input i
+0001b960: 7320 7661 6c69 6420 6f72 206e 6f74 0a20  s valid or not. 
+0001b970: 2020 2020 2020 206e 756d 5f74 6872 6561         num_threa
+0001b980: 6473 203a 206e 756d 6265 7220 6f66 2074  ds : number of t
+0001b990: 6872 6561 6473 2066 6f72 2070 6172 616c  hreads for paral
+0001b9a0: 6c65 6c69 7a61 7469 6f6e 0a20 2020 204f  lelization.    O
+0001b9b0: 7574 7075 743a 0a20 2020 2020 2020 2061  utput:.        a
+0001b9c0: 7265 5f73 6565 6e3a 2028 6e70 7473 312c  re_seen: (npts1,
+0001b9d0: 206e 7074 7332 2920 6172 7261 7920 6f66   npts2) array of
+0001b9e0: 2069 6e74 7320 696e 6469 6361 7469 6e67   ints indicating
+0001b9f0: 2069 6620 7669 6577 696e 6720 706f 696e   if viewing poin
+0001ba00: 7473 2070 7473 310a 2020 2020 2020 2020  ts pts1.        
+0001ba10: 2020 2020 2020 2020 2020 6361 6e20 7365            can se
+0001ba20: 6520 7468 6520 6f74 6865 7220 706f 696e  e the other poin
+0001ba30: 7473 2070 7473 322e 0a20 2020 2020 2020  ts pts2..       
+0001ba40: 2020 2020 2020 2020 2020 2061 7265 5f73             are_s
+0001ba50: 6565 6e5b 692c 6a5d 203d 2031 2069 6620  een[i,j] = 1 if 
+0001ba60: 7074 7331 5b69 5d20 7365 6573 2070 6f69  pts1[i] sees poi
+0001ba70: 6e74 2070 7473 325b 6a5d 0a20 2020 2020  nt pts2[j].     
 0001ba80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ba90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001baa0: 2030 2065 6c73 650a 2020 2020 2222 220a   0 else.    """.
-0001bab0: 2020 2020 6364 6566 2073 7472 206d 7367      cdef str msg
-0001bac0: 0a20 2020 2063 6465 6620 696e 7420 6e70  .    cdef int np
-0001bad0: 7473 313d 7074 7331 2e73 6861 7065 5b31  ts1=pts1.shape[1
-0001bae0: 5d0a 2020 2020 6364 6566 2069 6e74 206e  ].    cdef int n
-0001baf0: 7074 7332 3d70 7473 322e 7368 6170 655b  pts2=pts2.shape[
-0001bb00: 315d 0a20 2020 2063 6465 6620 6269 6e74  1].    cdef bint
-0001bb10: 2062 6f6f 6c31 2c20 626f 6f6c 320a 2020   bool1, bool2.  
-0001bb20: 2020 6364 6566 206e 702e 6e64 6172 7261    cdef np.ndarra
-0001bb30: 795b 6c6f 6e67 2c20 6e64 696d 3d32 2c20  y[long, ndim=2, 
-0001bb40: 6d6f 6465 3d27 6327 5d20 6172 655f 7365  mode='c'] are_se
-0001bb50: 656e 203d 206e 702e 656d 7074 7928 286e  en = np.empty((n
-0001bb60: 7074 7331 2c20 6e70 7473 3229 2c0a 2020  pts1, npts2),.  
+0001ba90: 2020 2020 2020 2020 2020 2020 2030 2065               0 e
+0001baa0: 6c73 650a 2020 2020 2222 220a 2020 2020  lse.    """.    
+0001bab0: 6364 6566 2073 7472 206d 7367 0a20 2020  cdef str msg.   
+0001bac0: 2063 6465 6620 696e 7420 6e70 7473 313d   cdef int npts1=
+0001bad0: 7074 7331 2e73 6861 7065 5b31 5d0a 2020  pts1.shape[1].  
+0001bae0: 2020 6364 6566 2069 6e74 206e 7074 7332    cdef int npts2
+0001baf0: 3d70 7473 322e 7368 6170 655b 315d 0a20  =pts2.shape[1]. 
+0001bb00: 2020 2063 6465 6620 6269 6e74 2062 6f6f     cdef bint boo
+0001bb10: 6c31 2c20 626f 6f6c 320a 2020 2020 6364  l1, bool2.    cd
+0001bb20: 6566 206e 702e 6e64 6172 7261 795b 6c6f  ef np.ndarray[lo
+0001bb30: 6e67 2c20 6e64 696d 3d32 2c20 6d6f 6465  ng, ndim=2, mode
+0001bb40: 3d27 6327 5d20 6172 655f 7365 656e 203d  ='c'] are_seen =
+0001bb50: 206e 702e 656d 7074 7928 286e 7074 7331   np.empty((npts1
+0001bb60: 2c20 6e70 7473 3229 2c0a 2020 2020 2020  , npts2),.      
 0001bb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001bb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001bb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bba0: 2020 2020 2020 2020 2020 2020 2020 6474                dt
-0001bbb0: 7970 653d 696e 7429 0a20 2020 2063 6465  ype=int).    cde
-0001bbc0: 6620 646f 7562 6c65 5b3a 3a31 5d20 6c73  f double[::1] ls
-0001bbd0: 7472 7563 745f 6c69 6d73 5f6e 700a 2020  truct_lims_np.  
-0001bbe0: 2020 2320 3d3d 2054 6573 7469 6e67 2069    # == Testing i
-0001bbf0: 6e70 7574 7320 3d3d 3d3d 3d3d 3d3d 3d3d  nputs ==========
+0001bba0: 2020 2020 2020 2020 2020 6474 7970 653d            dtype=
+0001bbb0: 696e 7429 0a20 2020 2063 6465 6620 646f  int).    cdef do
+0001bbc0: 7562 6c65 5b3a 3a31 5d20 6c73 7472 7563  uble[::1] lstruc
+0001bbd0: 745f 6c69 6d73 5f6e 700a 2020 2020 2320  t_lims_np.    # 
+0001bbe0: 3d3d 2054 6573 7469 6e67 2069 6e70 7574  == Testing input
+0001bbf0: 7320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  s ==============
 0001bc00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001bc10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001bc20: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a20  ==============. 
-0001bc30: 2020 2069 6620 7465 7374 3a0a 2020 2020     if test:.    
-0001bc40: 2020 2020 6d73 6720 3d20 2276 6573 5f70      msg = "ves_p
-0001bc50: 6f6c 7920 616e 6420 7665 735f 6e6f 726d  oly and ves_norm
-0001bc60: 2061 7265 206e 6f74 206f 7074 696f 6e61   are not optiona
-0001bc70: 6c20 6172 6775 6d65 6e74 7322 0a20 2020  l arguments".   
-0001bc80: 2020 2020 2061 7373 6572 7420 7665 735f       assert ves_
-0001bc90: 706f 6c79 2069 7320 6e6f 7420 4e6f 6e65  poly is not None
-0001bca0: 2061 6e64 2076 6573 5f6e 6f72 6d20 6973   and ves_norm is
-0001bcb0: 206e 6f74 204e 6f6e 652c 206d 7367 0a20   not None, msg. 
-0001bcc0: 2020 2020 2020 2062 6f6f 6c31 203d 2028         bool1 = (
-0001bcd0: 7665 735f 706f 6c79 2e73 6861 7065 5b30  ves_poly.shape[0
-0001bce0: 5d3d 3d32 2061 6e64 2076 6573 5f6e 6f72  ]==2 and ves_nor
-0001bcf0: 6d2e 7368 6170 655b 305d 3d3d 320a 2020  m.shape[0]==2.  
-0001bd00: 2020 2020 2020 2020 2020 2020 616e 6420              and 
-0001bd10: 7665 735f 6e6f 726d 2e73 6861 7065 5b31  ves_norm.shape[1
-0001bd20: 5d3d 3d76 6573 5f70 6f6c 792e 7368 6170  ]==ves_poly.shap
-0001bd30: 655b 315d 2d31 290a 2020 2020 2020 2020  e[1]-1).        
-0001bd40: 6d73 6720 3d20 2241 7267 7320 7665 735f  msg = "Args ves_
-0001bd50: 706f 6c79 2061 6e64 2076 6573 5f6e 6f72  poly and ves_nor
-0001bd60: 6d20 6d75 7374 2062 6520 6f66 2074 6865  m must be of the
-0001bd70: 2073 616d 6520 7368 6170 6520 2832 2c4e   same shape (2,N
-0001bd80: 5329 2122 0a20 2020 2020 2020 2061 7373  S)!".        ass
-0001bd90: 6572 7420 626f 6f6c 312c 206d 7367 0a20  ert bool1, msg. 
-0001bda0: 2020 2020 2020 2062 6f6f 6c31 203d 206c         bool1 = l
-0001bdb0: 7374 7275 6374 5f6c 696d 7320 6973 204e  struct_lims is N
-0001bdc0: 6f6e 6520 6f72 206c 656e 286c 7374 7275  one or len(lstru
-0001bdd0: 6374 5f6e 6f72 6d79 2920 3d3d 206c 656e  ct_normy) == len
-0001bde0: 286c 7374 7275 6374 5f6e 6f72 6d78 290a  (lstruct_normx).
-0001bdf0: 2020 2020 2020 2020 626f 6f6c 3220 3d20          bool2 = 
-0001be00: 6c73 7472 7563 745f 6e6f 726d 7820 6973  lstruct_normx is
-0001be10: 204e 6f6e 6520 6f72 206c 656e 286c 7374   None or len(lst
-0001be20: 7275 6374 5f70 6f6c 7978 2920 3d3d 206c  ruct_polyx) == l
-0001be30: 656e 286c 7374 7275 6374 5f70 6f6c 7979  en(lstruct_polyy
-0001be40: 290a 2020 2020 2020 2020 6d73 6720 3d20  ).        msg = 
-0001be50: 2241 7267 7320 6c73 7472 7563 745f 706f  "Args lstruct_po
-0001be60: 6c79 782c 206c 7374 7275 6374 5f70 6f6c  lyx, lstruct_pol
-0001be70: 7979 2c20 6c73 7472 7563 745f 6c69 6d73  yy, lstruct_lims
-0001be80: 2c20 6c73 7472 7563 745f 6e6f 726d 782c  , lstruct_normx,
-0001be90: 225c 0a20 2020 2020 2020 2020 2020 2020  "\.             
-0001bea0: 202b 2022 206c 7374 7275 6374 5f6e 6f72   + " lstruct_nor
-0001beb0: 6d79 2c20 6d75 7374 2062 6520 4e6f 6e65  my, must be None
-0001bec0: 206f 7220 6c69 7374 7320 6f66 2073 616d   or lists of sam
-0001bed0: 6520 6c65 6e28 2921 220a 2020 2020 2020  e len()!".      
-0001bee0: 2020 6173 7365 7274 2062 6f6f 6c31 2061    assert bool1 a
-0001bef0: 6e64 2062 6f6f 6c32 2c20 6d73 670a 2020  nd bool2, msg.  
-0001bf00: 2020 2020 2020 6d73 6720 3d20 225b 6570        msg = "[ep
-0001bf10: 735f 757a 2c65 7073 5f76 7a2c 6570 735f  s_uz,eps_vz,eps_
-0001bf20: 612c 6570 735f 625d 206d 7573 7420 6265  a,eps_b] must be
-0001bf30: 2066 6c6f 6174 7320 3c20 312e 652d 3421   floats < 1.e-4!
-0001bf40: 220a 2020 2020 2020 2020 6173 7365 7274  ".        assert
-0001bf50: 2061 6c6c 285b 6565 203c 2031 2e65 2d34   all([ee < 1.e-4
-0001bf60: 2066 6f72 2065 6520 696e 205b 6570 735f   for ee in [eps_
-0001bf70: 757a 2c20 6570 735f 612c 0a20 2020 2020  uz, eps_a,.     
+0001bc20: 3d3d 3d3d 3d3d 3d3d 3d3d 0a20 2020 2069  ==========.    i
+0001bc30: 6620 7465 7374 3a0a 2020 2020 2020 2020  f test:.        
+0001bc40: 6d73 6720 3d20 2276 6573 5f70 6f6c 7920  msg = "ves_poly 
+0001bc50: 616e 6420 7665 735f 6e6f 726d 2061 7265  and ves_norm are
+0001bc60: 206e 6f74 206f 7074 696f 6e61 6c20 6172   not optional ar
+0001bc70: 6775 6d65 6e74 7322 0a20 2020 2020 2020  guments".       
+0001bc80: 2061 7373 6572 7420 7665 735f 706f 6c79   assert ves_poly
+0001bc90: 2069 7320 6e6f 7420 4e6f 6e65 2061 6e64   is not None and
+0001bca0: 2076 6573 5f6e 6f72 6d20 6973 206e 6f74   ves_norm is not
+0001bcb0: 204e 6f6e 652c 206d 7367 0a20 2020 2020   None, msg.     
+0001bcc0: 2020 2062 6f6f 6c31 203d 2028 7665 735f     bool1 = (ves_
+0001bcd0: 706f 6c79 2e73 6861 7065 5b30 5d3d 3d32  poly.shape[0]==2
+0001bce0: 2061 6e64 2076 6573 5f6e 6f72 6d2e 7368   and ves_norm.sh
+0001bcf0: 6170 655b 305d 3d3d 320a 2020 2020 2020  ape[0]==2.      
+0001bd00: 2020 2020 2020 2020 616e 6420 7665 735f          and ves_
+0001bd10: 6e6f 726d 2e73 6861 7065 5b31 5d3d 3d76  norm.shape[1]==v
+0001bd20: 6573 5f70 6f6c 792e 7368 6170 655b 315d  es_poly.shape[1]
+0001bd30: 2d31 290a 2020 2020 2020 2020 6d73 6720  -1).        msg 
+0001bd40: 3d20 2241 7267 7320 7665 735f 706f 6c79  = "Args ves_poly
+0001bd50: 2061 6e64 2076 6573 5f6e 6f72 6d20 6d75   and ves_norm mu
+0001bd60: 7374 2062 6520 6f66 2074 6865 2073 616d  st be of the sam
+0001bd70: 6520 7368 6170 6520 2832 2c4e 5329 2122  e shape (2,NS)!"
+0001bd80: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+0001bd90: 626f 6f6c 312c 206d 7367 0a20 2020 2020  bool1, msg.     
+0001bda0: 2020 2062 6f6f 6c31 203d 206c 7374 7275     bool1 = lstru
+0001bdb0: 6374 5f6c 696d 7320 6973 204e 6f6e 6520  ct_lims is None 
+0001bdc0: 6f72 206c 656e 286c 7374 7275 6374 5f6e  or len(lstruct_n
+0001bdd0: 6f72 6d79 2920 3d3d 206c 656e 286c 7374  ormy) == len(lst
+0001bde0: 7275 6374 5f6e 6f72 6d78 290a 2020 2020  ruct_normx).    
+0001bdf0: 2020 2020 626f 6f6c 3220 3d20 6c73 7472      bool2 = lstr
+0001be00: 7563 745f 6e6f 726d 7820 6973 204e 6f6e  uct_normx is Non
+0001be10: 6520 6f72 206c 656e 286c 7374 7275 6374  e or len(lstruct
+0001be20: 5f70 6f6c 7978 2920 3d3d 206c 656e 286c  _polyx) == len(l
+0001be30: 7374 7275 6374 5f70 6f6c 7979 290a 2020  struct_polyy).  
+0001be40: 2020 2020 2020 6d73 6720 3d20 2241 7267        msg = "Arg
+0001be50: 7320 6c73 7472 7563 745f 706f 6c79 782c  s lstruct_polyx,
+0001be60: 206c 7374 7275 6374 5f70 6f6c 7979 2c20   lstruct_polyy, 
+0001be70: 6c73 7472 7563 745f 6c69 6d73 2c20 6c73  lstruct_lims, ls
+0001be80: 7472 7563 745f 6e6f 726d 782c 225c 0a20  truct_normx,"\. 
+0001be90: 2020 2020 2020 2020 2020 2020 202b 2022               + "
+0001bea0: 206c 7374 7275 6374 5f6e 6f72 6d79 2c20   lstruct_normy, 
+0001beb0: 6d75 7374 2062 6520 4e6f 6e65 206f 7220  must be None or 
+0001bec0: 6c69 7374 7320 6f66 2073 616d 6520 6c65  lists of same le
+0001bed0: 6e28 2921 220a 2020 2020 2020 2020 6173  n()!".        as
+0001bee0: 7365 7274 2062 6f6f 6c31 2061 6e64 2062  sert bool1 and b
+0001bef0: 6f6f 6c32 2c20 6d73 670a 2020 2020 2020  ool2, msg.      
+0001bf00: 2020 6d73 6720 3d20 225b 6570 735f 757a    msg = "[eps_uz
+0001bf10: 2c65 7073 5f76 7a2c 6570 735f 612c 6570  ,eps_vz,eps_a,ep
+0001bf20: 735f 625d 206d 7573 7420 6265 2066 6c6f  s_b] must be flo
+0001bf30: 6174 7320 3c20 312e 652d 3421 220a 2020  ats < 1.e-4!".  
+0001bf40: 2020 2020 2020 6173 7365 7274 2061 6c6c        assert all
+0001bf50: 285b 6565 203c 2031 2e65 2d34 2066 6f72  ([ee < 1.e-4 for
+0001bf60: 2065 6520 696e 205b 6570 735f 757a 2c20   ee in [eps_uz, 
+0001bf70: 6570 735f 612c 0a20 2020 2020 2020 2020  eps_a,.         
 0001bf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001bf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bfa0: 2020 2020 2065 7073 5f76 7a2c 2065 7073       eps_vz, eps
-0001bfb0: 5f62 2c0a 2020 2020 2020 2020 2020 2020  _b,.            
+0001bfa0: 2065 7073 5f76 7a2c 2065 7073 5f62 2c0a   eps_vz, eps_b,.
+0001bfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001bfc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bfd0: 2020 2020 2020 2020 2020 2020 2020 6570                ep
-0001bfe0: 735f 706c 616e 655d 5d29 2c20 6d73 670a  s_plane]]), msg.
-0001bff0: 2020 2020 2020 2020 6d73 6720 3d20 2276          msg = "v
-0001c000: 6573 5f74 7970 6520 6d75 7374 2062 6520  es_type must be 
-0001c010: 6120 7374 7220 696e 205b 2754 6f72 272c  a str in ['Tor',
-0001c020: 274c 696e 275d 2122 0a20 2020 2020 2020  'Lin']!".       
-0001c030: 2061 7373 6572 7420 7665 735f 7479 7065   assert ves_type
-0001c040: 2e6c 6f77 6572 2829 2069 6e20 5b27 746f  .lower() in ['to
-0001c050: 7227 2c20 276c 696e 275d 2c20 6d73 670a  r', 'lin'], msg.
-0001c060: 0a20 2020 206c 7374 7275 6374 5f6c 696d  .    lstruct_lim
-0001c070: 735f 6e70 203d 2066 6c61 7474 656e 5f6c  s_np = flatten_l
-0001c080: 7374 7275 6374 5f6c 696d 7328 6c73 7472  struct_lims(lstr
-0001c090: 7563 745f 6c69 6d73 290a 2020 2020 5f72  uct_lims).    _r
-0001c0a0: 742e 6172 655f 7669 7369 626c 655f 7665  t.are_visible_ve
-0001c0b0: 635f 7665 6328 7074 7331 2c20 6e70 7473  c_vec(pts1, npts
-0001c0c0: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
-0001c0d0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0001c0e0: 7473 322c 206e 7074 7332 2c0a 2020 2020  ts2, npts2,.    
+0001bfd0: 2020 2020 2020 2020 2020 6570 735f 706c            eps_pl
+0001bfe0: 616e 655d 5d29 2c20 6d73 670a 2020 2020  ane]]), msg.    
+0001bff0: 2020 2020 6d73 6720 3d20 2276 6573 5f74      msg = "ves_t
+0001c000: 7970 6520 6d75 7374 2062 6520 6120 7374  ype must be a st
+0001c010: 7220 696e 205b 2754 6f72 272c 274c 696e  r in ['Tor','Lin
+0001c020: 275d 2122 0a20 2020 2020 2020 2061 7373  ']!".        ass
+0001c030: 6572 7420 7665 735f 7479 7065 2e6c 6f77  ert ves_type.low
+0001c040: 6572 2829 2069 6e20 5b27 746f 7227 2c20  er() in ['tor', 
+0001c050: 276c 696e 275d 2c20 6d73 670a 0a20 2020  'lin'], msg..   
+0001c060: 206c 7374 7275 6374 5f6c 696d 735f 6e70   lstruct_lims_np
+0001c070: 203d 2066 6c61 7474 656e 5f6c 7374 7275   = flatten_lstru
+0001c080: 6374 5f6c 696d 7328 6c73 7472 7563 745f  ct_lims(lstruct_
+0001c090: 6c69 6d73 290a 2020 2020 5f72 742e 6172  lims).    _rt.ar
+0001c0a0: 655f 7669 7369 626c 655f 7665 635f 7665  e_visible_vec_ve
+0001c0b0: 6328 7074 7331 2c20 6e70 7473 312c 0a20  c(pts1, npts1,. 
+0001c0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c0d0: 2020 2020 2020 2020 2020 2070 7473 322c             pts2,
+0001c0e0: 206e 7074 7332 2c0a 2020 2020 2020 2020   npts2,.        
 0001c0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c100: 2020 2020 2020 2020 7665 735f 706f 6c79          ves_poly
-0001c110: 2c20 7665 735f 6e6f 726d 2c0a 2020 2020  , ves_norm,.    
+0001c100: 2020 2020 7665 735f 706f 6c79 2c20 7665      ves_poly, ve
+0001c110: 735f 6e6f 726d 2c0a 2020 2020 2020 2020  s_norm,.        
 0001c120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c130: 2020 2020 2020 2020 6172 655f 7365 656e          are_seen
-0001c140: 2c20 6469 7374 2c20 7665 735f 6c69 6d73  , dist, ves_lims
-0001c150: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001c160: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
-0001c170: 7472 7563 745f 6e6c 696d 2c0a 2020 2020  truct_nlim,.    
+0001c130: 2020 2020 6172 655f 7365 656e 2c20 6469      are_seen, di
+0001c140: 7374 2c20 7665 735f 6c69 6d73 2c0a 2020  st, ves_lims,.  
+0001c150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c160: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
+0001c170: 745f 6e6c 696d 2c0a 2020 2020 2020 2020  t_nlim,.        
 0001c180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c190: 2020 2020 2020 2020 6c73 7472 7563 745f          lstruct_
-0001c1a0: 706f 6c79 782c 206c 7374 7275 6374 5f70  polyx, lstruct_p
-0001c1b0: 6f6c 7979 2c0a 2020 2020 2020 2020 2020  olyy,.          
-0001c1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c1d0: 2020 6c73 7472 7563 745f 6c69 6d73 5f6e    lstruct_lims_n
-0001c1e0: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-0001c1f0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0001c200: 7374 7275 6374 5f6e 6f72 6d78 2c20 6c73  struct_normx, ls
-0001c210: 7472 7563 745f 6e6f 726d 792c 0a20 2020  truct_normy,.   
+0001c190: 2020 2020 6c73 7472 7563 745f 706f 6c79      lstruct_poly
+0001c1a0: 782c 206c 7374 7275 6374 5f70 6f6c 7979  x, lstruct_polyy
+0001c1b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001c1c0: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
+0001c1d0: 7472 7563 745f 6c69 6d73 5f6e 702c 0a20  truct_lims_np,. 
+0001c1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c1f0: 2020 2020 2020 2020 2020 206c 7374 7275             lstru
+0001c200: 6374 5f6e 6f72 6d78 2c20 6c73 7472 7563  ct_normx, lstruc
+0001c210: 745f 6e6f 726d 792c 0a20 2020 2020 2020  t_normy,.       
 0001c220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c230: 2020 2020 2020 2020 206c 6e76 6572 742c           lnvert,
-0001c240: 206e 7374 7275 6374 5f74 6f74 2c20 6e73   nstruct_tot, ns
-0001c250: 7472 7563 745f 6c69 6d2c 0a20 2020 2020  truct_lim,.     
+0001c230: 2020 2020 206c 6e76 6572 742c 206e 7374       lnvert, nst
+0001c240: 7275 6374 5f74 6f74 2c20 6e73 7472 7563  ruct_tot, nstruc
+0001c250: 745f 6c69 6d2c 0a20 2020 2020 2020 2020  t_lim,.         
 0001c260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c270: 2020 2020 2020 2072 6d69 6e2c 2065 7073         rmin, eps
-0001c280: 5f75 7a2c 2065 7073 5f61 2c20 6570 735f  _uz, eps_a, eps_
-0001c290: 767a 2c20 6570 735f 622c 0a20 2020 2020  vz, eps_b,.     
+0001c270: 2020 2072 6d69 6e2c 2065 7073 5f75 7a2c     rmin, eps_uz,
+0001c280: 2065 7073 5f61 2c20 6570 735f 767a 2c20   eps_a, eps_vz, 
+0001c290: 6570 735f 622c 0a20 2020 2020 2020 2020  eps_b,.         
 0001c2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c2b0: 2020 2020 2020 2065 7073 5f70 6c61 6e65         eps_plane
-0001c2c0: 2c20 7665 735f 7479 7065 2e6c 6f77 6572  , ves_type.lower
-0001c2d0: 2829 3d3d 2774 6f72 272c 0a20 2020 2020  ()=='tor',.     
+0001c2b0: 2020 2065 7073 5f70 6c61 6e65 2c20 7665     eps_plane, ve
+0001c2c0: 735f 7479 7065 2e6c 6f77 6572 2829 3d3d  s_type.lower()==
+0001c2d0: 2774 6f72 272c 0a20 2020 2020 2020 2020  'tor',.         
 0001c2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c2f0: 2020 2020 2020 2066 6f72 6269 642c 206e         forbid, n
-0001c300: 756d 5f74 6872 6561 6473 290a 2020 2020  um_threads).    
-0001c310: 7265 7475 726e 2061 7265 5f73 6565 6e0a  return are_seen.
-0001c320: 0a0a 6465 6620 4c4f 535f 6973 5669 735f  ..def LOS_isVis_
-0001c330: 5074 4672 6f6d 5074 735f 5665 7353 7472  PtFromPts_VesStr
-0001c340: 7563 7428 0a20 2020 2064 6f75 626c 6520  uct(.    double 
-0001c350: 7074 302c 2064 6f75 626c 6520 7074 312c  pt0, double pt1,
-0001c360: 2064 6f75 626c 6520 7074 322c 0a20 2020   double pt2,.   
-0001c370: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
-0001c380: 6c65 2c20 6e64 696d 3d32 2c6d 6f64 653d  le, ndim=2,mode=
-0001c390: 2763 275d 2070 7473 2c0a 2020 2020 646f  'c'] pts,.    do
-0001c3a0: 7562 6c65 5b3a 3a31 5d20 6469 7374 3d4e  uble[::1] dist=N
-0001c3b0: 6f6e 652c 0a20 2020 2064 6f75 626c 655b  one,.    double[
-0001c3c0: 3a2c 203a 3a31 5d20 7665 735f 706f 6c79  :, ::1] ves_poly
-0001c3d0: 3d4e 6f6e 652c 0a20 2020 2064 6f75 626c  =None,.    doubl
-0001c3e0: 655b 3a2c 203a 3a31 5d20 7665 735f 6e6f  e[:, ::1] ves_no
-0001c3f0: 726d 3d4e 6f6e 652c 0a20 2020 2064 6f75  rm=None,.    dou
-0001c400: 626c 655b 3a3a 315d 2076 6573 5f6c 696d  ble[::1] ves_lim
-0001c410: 733d 4e6f 6e65 2c0a 2020 2020 6c6f 6e67  s=None,.    long
-0001c420: 5b3a 3a31 5d20 6c73 7472 7563 745f 6e6c  [::1] lstruct_nl
-0001c430: 696d 3d4e 6f6e 652c 0a20 2020 2064 6f75  im=None,.    dou
-0001c440: 626c 655b 3a3a 315d 206c 7374 7275 6374  ble[::1] lstruct
-0001c450: 5f70 6f6c 7978 3d4e 6f6e 652c 0a20 2020  _polyx=None,.   
-0001c460: 2064 6f75 626c 655b 3a3a 315d 206c 7374   double[::1] lst
-0001c470: 7275 6374 5f70 6f6c 7979 3d4e 6f6e 652c  ruct_polyy=None,
-0001c480: 0a20 2020 206c 6973 7420 6c73 7472 7563  .    list lstruc
-0001c490: 745f 6c69 6d73 3d4e 6f6e 652c 0a20 2020  t_lims=None,.   
-0001c4a0: 2064 6f75 626c 655b 3a3a 315d 206c 7374   double[::1] lst
-0001c4b0: 7275 6374 5f6e 6f72 6d78 3d4e 6f6e 652c  ruct_normx=None,
-0001c4c0: 0a20 2020 2064 6f75 626c 655b 3a3a 315d  .    double[::1]
-0001c4d0: 206c 7374 7275 6374 5f6e 6f72 6d79 3d4e   lstruct_normy=N
-0001c4e0: 6f6e 652c 0a20 2020 206c 6f6e 675b 3a3a  one,.    long[::
-0001c4f0: 315d 206c 6e76 6572 743d 4e6f 6e65 2c0a  1] lnvert=None,.
-0001c500: 2020 2020 696e 7420 6e73 7472 7563 745f      int nstruct_
-0001c510: 746f 743d 302c 0a20 2020 2069 6e74 206e  tot=0,.    int n
-0001c520: 7374 7275 6374 5f6c 696d 3d30 2c0a 2020  struct_lim=0,.  
-0001c530: 2020 646f 7562 6c65 2072 6d69 6e3d 2d31    double rmin=-1
-0001c540: 2c0a 2020 2020 646f 7562 6c65 2065 7073  ,.    double eps
-0001c550: 5f75 7a3d 5f53 4d41 4c4c 2c20 646f 7562  _uz=_SMALL, doub
-0001c560: 6c65 2065 7073 5f61 3d5f 5653 4d41 4c4c  le eps_a=_VSMALL
-0001c570: 2c0a 2020 2020 646f 7562 6c65 2065 7073  ,.    double eps
-0001c580: 5f76 7a3d 5f56 534d 414c 4c2c 2064 6f75  _vz=_VSMALL, dou
-0001c590: 626c 6520 6570 735f 623d 5f56 534d 414c  ble eps_b=_VSMAL
-0001c5a0: 4c2c 0a20 2020 2064 6f75 626c 6520 6570  L,.    double ep
-0001c5b0: 735f 706c 616e 653d 5f56 534d 414c 4c2c  s_plane=_VSMALL,
-0001c5c0: 2073 7472 2076 6573 5f74 7970 653d 2754   str ves_type='T
-0001c5d0: 6f72 272c 0a20 2020 2062 696e 7420 666f  or',.    bint fo
-0001c5e0: 7262 6964 3d54 7275 652c 0a20 2020 2062  rbid=True,.    b
-0001c5f0: 696e 7420 7465 7374 3d54 7275 652c 0a20  int test=True,. 
-0001c600: 2020 2069 6e74 206e 756d 5f74 6872 6561     int num_threa
-0001c610: 6473 3d31 362c 0a29 3a0a 2020 2020 2222  ds=16,.):.    ""
-0001c620: 220a 2020 2020 5265 7475 726e 2061 6e20  ".    Return an 
-0001c630: 6172 7261 7920 6f66 2062 6f6f 6c65 616e  array of boolean
-0001c640: 7320 696e 6469 6361 7469 6e67 2077 6865  s indicating whe
-0001c650: 7468 6572 2065 6163 6820 706f 696e 7420  ther each point 
-0001c660: 696e 2070 7473 2069 730a 2020 2020 7669  in pts is.    vi
-0001c670: 7369 626c 6520 6672 6f6d 2074 6865 2070  sible from the p
-0001c680: 6f69 6e74 2050 203d 205b 7074 302c 2070  oint P = [pt0, p
-0001c690: 7431 2c20 7074 325d 2063 6f6e 7369 6465  t1, pt2] conside
-0001c6a0: 7269 6e67 2076 6967 6e65 7474 696e 6720  ring vignetting 
-0001c6b0: 6120 6769 7665 6e0a 2020 2020 636f 6e66  a given.    conf
-0001c6c0: 6967 7572 6174 696f 6e2e 0a20 2020 2020  iguration..     
-0001c6d0: 2020 2070 7430 203a 2078 202d 2063 6f6f     pt0 : x - coo
-0001c6e0: 7264 696e 6174 6520 6f66 2074 6865 2076  rdinate of the v
-0001c6f0: 6965 7769 6e67 2070 6f69 6e74 2050 0a20  iewing point P. 
-0001c700: 2020 2020 2020 2070 7431 203a 2079 202d         pt1 : y -
-0001c710: 2063 6f6f 7264 696e 6174 6520 6f66 2074   coordinate of t
-0001c720: 6865 2076 6965 7769 6e67 2070 6f69 6e74  he viewing point
-0001c730: 2050 0a20 2020 2020 2020 2070 7432 203a   P.        pt2 :
-0001c740: 207a 202d 2063 6f6f 7264 696e 6174 6520   z - coordinate 
-0001c750: 6f66 2074 6865 2076 6965 7769 6e67 2070  of the viewing p
-0001c760: 6f69 6e74 2050 0a20 2020 2020 2020 2070  oint P.        p
-0001c770: 7473 203a 2028 332c 206e 7074 7329 2063  ts : (3, npts) c
-0001c780: 6172 7465 7369 616e 2063 6f6f 7264 696e  artesian coordin
-0001c790: 6174 6573 206f 6620 706f 696e 7473 2074  ates of points t
-0001c7a0: 6f20 6368 6563 6b20 6966 2076 6965 7761  o check if viewa
-0001c7b0: 626c 650a 2020 2020 2020 2020 6469 7374  ble.        dist
-0001c7c0: 203a 206f 7074 696f 6e61 6c20 6172 6775   : optional argu
-0001c7d0: 6d65 6e74 203a 2064 6973 7461 6e63 6520  ment : distance 
-0001c7e0: 6265 7477 6565 6e20 706f 696e 7473 2061  between points a
-0001c7f0: 6e64 2050 0a20 2020 2020 2020 2076 6573  nd P.        ves
-0001c800: 5f2a 203a 2076 6573 7365 6c20 6465 7363  _* : vessel desc
-0001c810: 7269 7074 6f72 7320 2870 6f6c 792c 206e  riptors (poly, n
-0001c820: 6f72 6d2c 206c 696d 6974 7329 0a20 2020  orm, limits).   
-0001c830: 2020 2020 206c 7374 7275 6374 5f2a 203a       lstruct_* :
-0001c840: 2063 6f6e 6669 6727 7320 7374 7275 6374   config's struct
-0001c850: 7572 6520 6465 7363 7269 7074 6f72 7320  ure descriptors 
-0001c860: 2870 6f6c 792c 206c 696d 6974 732c 206e  (poly, limits, n
-0001c870: 6f72 6d73 2c0a 2020 2020 2020 2020 2020  orms,.          
-0001c880: 2020 2020 2020 2020 2020 6e75 6d62 6572            number
-0001c890: 206f 6620 7374 7275 6374 7572 6573 2c20   of structures, 
-0001c8a0: 2e2e 2e29 0a20 2020 2020 2020 2065 7073  ...).        eps
-0001c8b0: 5f2a 203a 2076 616c 7565 7320 6f66 2070  _* : values of p
-0001c8c0: 7265 6369 7369 6f6e 2069 6e20 6561 6368  recision in each
-0001c8d0: 2064 6972 6563 7469 6f6e 0a20 2020 2020   direction.     
-0001c8e0: 2020 2066 6f72 6269 6420 3a20 626f 6f6c     forbid : bool
-0001c8f0: 6561 6e20 6966 2074 7275 6520 666f 7262  ean if true forb
-0001c900: 6964 7320 6368 6563 6b69 6e67 2022 6265  ids checking "be
-0001c910: 6869 6e64 2220 7468 6520 746f 6b61 6d61  hind" the tokama
-0001c920: 6b0a 2020 2020 2020 2020 7465 7374 203a  k.        test :
-0001c930: 2062 6f6f 6c65 616e 2063 6865 636b 2069   boolean check i
-0001c940: 6620 696e 7075 7420 6973 2076 616c 6964  f input is valid
-0001c950: 206f 7220 6e6f 740a 2020 2020 2020 2020   or not.        
-0001c960: 6e75 6d5f 7468 7265 6164 7320 3a20 6e75  num_threads : nu
-0001c970: 6d62 6572 206f 6620 7468 7265 6164 7320  mber of threads 
-0001c980: 666f 7220 7061 7261 6c6c 656c 697a 6174  for parallelizat
-0001c990: 696f 6e0a 2020 2020 4f75 7470 7574 3a0a  ion.    Output:.
-0001c9a0: 2020 2020 2020 2020 6973 5f73 6565 6e3a          is_seen:
-0001c9b0: 2028 6e70 7473 3129 2061 7272 6179 206f   (npts1) array o
-0001c9c0: 6620 696e 7473 2069 6e64 6963 6174 696e  f ints indicatin
-0001c9d0: 6720 6966 2076 6965 7769 6e67 2070 6f69  g if viewing poi
-0001c9e0: 6e74 2050 0a20 2020 2020 2020 2020 2020  nt P.           
-0001c9f0: 2020 2020 2020 6361 6e20 7365 6520 7468        can see th
-0001ca00: 6520 6f74 6865 7220 706f 696e 7473 2070  e other points p
-0001ca10: 7473 2e0a 2020 2020 2020 2020 2020 2020  ts..            
-0001ca20: 2020 2020 2069 735f 7365 656e 5b69 5d20       is_seen[i] 
-0001ca30: 3d20 3120 6966 2050 2073 6565 7320 706f  = 1 if P sees po
-0001ca40: 696e 7420 7074 735b 695d 0a20 2020 2020  int pts[i].     
+0001c2f0: 2020 2066 6f72 6269 642c 206e 756d 5f74     forbid, num_t
+0001c300: 6872 6561 6473 290a 2020 2020 7265 7475  hreads).    retu
+0001c310: 726e 2061 7265 5f73 6565 6e0a 0a0a 6465  rn are_seen...de
+0001c320: 6620 4c4f 535f 6973 5669 735f 5074 4672  f LOS_isVis_PtFr
+0001c330: 6f6d 5074 735f 5665 7353 7472 7563 7428  omPts_VesStruct(
+0001c340: 0a20 2020 2064 6f75 626c 6520 7074 302c  .    double pt0,
+0001c350: 2064 6f75 626c 6520 7074 312c 2064 6f75   double pt1, dou
+0001c360: 626c 6520 7074 322c 0a20 2020 206e 702e  ble pt2,.    np.
+0001c370: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
+0001c380: 6e64 696d 3d32 2c6d 6f64 653d 2763 275d  ndim=2,mode='c']
+0001c390: 2070 7473 2c0a 2020 2020 646f 7562 6c65   pts,.    double
+0001c3a0: 5b3a 3a31 5d20 6469 7374 3d4e 6f6e 652c  [::1] dist=None,
+0001c3b0: 0a20 2020 2064 6f75 626c 655b 3a2c 203a  .    double[:, :
+0001c3c0: 3a31 5d20 7665 735f 706f 6c79 3d4e 6f6e  :1] ves_poly=Non
+0001c3d0: 652c 0a20 2020 2064 6f75 626c 655b 3a2c  e,.    double[:,
+0001c3e0: 203a 3a31 5d20 7665 735f 6e6f 726d 3d4e   ::1] ves_norm=N
+0001c3f0: 6f6e 652c 0a20 2020 2064 6f75 626c 655b  one,.    double[
+0001c400: 3a3a 315d 2076 6573 5f6c 696d 733d 4e6f  ::1] ves_lims=No
+0001c410: 6e65 2c0a 2020 2020 6c6f 6e67 5b3a 3a31  ne,.    long[::1
+0001c420: 5d20 6c73 7472 7563 745f 6e6c 696d 3d4e  ] lstruct_nlim=N
+0001c430: 6f6e 652c 0a20 2020 2064 6f75 626c 655b  one,.    double[
+0001c440: 3a3a 315d 206c 7374 7275 6374 5f70 6f6c  ::1] lstruct_pol
+0001c450: 7978 3d4e 6f6e 652c 0a20 2020 2064 6f75  yx=None,.    dou
+0001c460: 626c 655b 3a3a 315d 206c 7374 7275 6374  ble[::1] lstruct
+0001c470: 5f70 6f6c 7979 3d4e 6f6e 652c 0a20 2020  _polyy=None,.   
+0001c480: 206c 6973 7420 6c73 7472 7563 745f 6c69   list lstruct_li
+0001c490: 6d73 3d4e 6f6e 652c 0a20 2020 2064 6f75  ms=None,.    dou
+0001c4a0: 626c 655b 3a3a 315d 206c 7374 7275 6374  ble[::1] lstruct
+0001c4b0: 5f6e 6f72 6d78 3d4e 6f6e 652c 0a20 2020  _normx=None,.   
+0001c4c0: 2064 6f75 626c 655b 3a3a 315d 206c 7374   double[::1] lst
+0001c4d0: 7275 6374 5f6e 6f72 6d79 3d4e 6f6e 652c  ruct_normy=None,
+0001c4e0: 0a20 2020 206c 6f6e 675b 3a3a 315d 206c  .    long[::1] l
+0001c4f0: 6e76 6572 743d 4e6f 6e65 2c0a 2020 2020  nvert=None,.    
+0001c500: 696e 7420 6e73 7472 7563 745f 746f 743d  int nstruct_tot=
+0001c510: 302c 0a20 2020 2069 6e74 206e 7374 7275  0,.    int nstru
+0001c520: 6374 5f6c 696d 3d30 2c0a 2020 2020 646f  ct_lim=0,.    do
+0001c530: 7562 6c65 2072 6d69 6e3d 2d31 2c0a 2020  uble rmin=-1,.  
+0001c540: 2020 646f 7562 6c65 2065 7073 5f75 7a3d    double eps_uz=
+0001c550: 5f53 4d41 4c4c 2c20 646f 7562 6c65 2065  _SMALL, double e
+0001c560: 7073 5f61 3d5f 5653 4d41 4c4c 2c0a 2020  ps_a=_VSMALL,.  
+0001c570: 2020 646f 7562 6c65 2065 7073 5f76 7a3d    double eps_vz=
+0001c580: 5f56 534d 414c 4c2c 2064 6f75 626c 6520  _VSMALL, double 
+0001c590: 6570 735f 623d 5f56 534d 414c 4c2c 0a20  eps_b=_VSMALL,. 
+0001c5a0: 2020 2064 6f75 626c 6520 6570 735f 706c     double eps_pl
+0001c5b0: 616e 653d 5f56 534d 414c 4c2c 2073 7472  ane=_VSMALL, str
+0001c5c0: 2076 6573 5f74 7970 653d 2754 6f72 272c   ves_type='Tor',
+0001c5d0: 0a20 2020 2062 696e 7420 666f 7262 6964  .    bint forbid
+0001c5e0: 3d54 7275 652c 0a20 2020 2062 696e 7420  =True,.    bint 
+0001c5f0: 7465 7374 3d54 7275 652c 0a20 2020 2069  test=True,.    i
+0001c600: 6e74 206e 756d 5f74 6872 6561 6473 3d31  nt num_threads=1
+0001c610: 362c 0a29 3a0a 2020 2020 2222 220a 2020  6,.):.    """.  
+0001c620: 2020 5265 7475 726e 2061 6e20 6172 7261    Return an arra
+0001c630: 7920 6f66 2062 6f6f 6c65 616e 7320 696e  y of booleans in
+0001c640: 6469 6361 7469 6e67 2077 6865 7468 6572  dicating whether
+0001c650: 2065 6163 6820 706f 696e 7420 696e 2070   each point in p
+0001c660: 7473 2069 730a 2020 2020 7669 7369 626c  ts is.    visibl
+0001c670: 6520 6672 6f6d 2074 6865 2070 6f69 6e74  e from the point
+0001c680: 2050 203d 205b 7074 302c 2070 7431 2c20   P = [pt0, pt1, 
+0001c690: 7074 325d 2063 6f6e 7369 6465 7269 6e67  pt2] considering
+0001c6a0: 2076 6967 6e65 7474 696e 6720 6120 6769   vignetting a gi
+0001c6b0: 7665 6e0a 2020 2020 636f 6e66 6967 7572  ven.    configur
+0001c6c0: 6174 696f 6e2e 0a20 2020 2020 2020 2070  ation..        p
+0001c6d0: 7430 203a 2078 202d 2063 6f6f 7264 696e  t0 : x - coordin
+0001c6e0: 6174 6520 6f66 2074 6865 2076 6965 7769  ate of the viewi
+0001c6f0: 6e67 2070 6f69 6e74 2050 0a20 2020 2020  ng point P.     
+0001c700: 2020 2070 7431 203a 2079 202d 2063 6f6f     pt1 : y - coo
+0001c710: 7264 696e 6174 6520 6f66 2074 6865 2076  rdinate of the v
+0001c720: 6965 7769 6e67 2070 6f69 6e74 2050 0a20  iewing point P. 
+0001c730: 2020 2020 2020 2070 7432 203a 207a 202d         pt2 : z -
+0001c740: 2063 6f6f 7264 696e 6174 6520 6f66 2074   coordinate of t
+0001c750: 6865 2076 6965 7769 6e67 2070 6f69 6e74  he viewing point
+0001c760: 2050 0a20 2020 2020 2020 2070 7473 203a   P.        pts :
+0001c770: 2028 332c 206e 7074 7329 2063 6172 7465   (3, npts) carte
+0001c780: 7369 616e 2063 6f6f 7264 696e 6174 6573  sian coordinates
+0001c790: 206f 6620 706f 696e 7473 2074 6f20 6368   of points to ch
+0001c7a0: 6563 6b20 6966 2076 6965 7761 626c 650a  eck if viewable.
+0001c7b0: 2020 2020 2020 2020 6469 7374 203a 206f          dist : o
+0001c7c0: 7074 696f 6e61 6c20 6172 6775 6d65 6e74  ptional argument
+0001c7d0: 203a 2064 6973 7461 6e63 6520 6265 7477   : distance betw
+0001c7e0: 6565 6e20 706f 696e 7473 2061 6e64 2050  een points and P
+0001c7f0: 0a20 2020 2020 2020 2076 6573 5f2a 203a  .        ves_* :
+0001c800: 2076 6573 7365 6c20 6465 7363 7269 7074   vessel descript
+0001c810: 6f72 7320 2870 6f6c 792c 206e 6f72 6d2c  ors (poly, norm,
+0001c820: 206c 696d 6974 7329 0a20 2020 2020 2020   limits).       
+0001c830: 206c 7374 7275 6374 5f2a 203a 2063 6f6e   lstruct_* : con
+0001c840: 6669 6727 7320 7374 7275 6374 7572 6520  fig's structure 
+0001c850: 6465 7363 7269 7074 6f72 7320 2870 6f6c  descriptors (pol
+0001c860: 792c 206c 696d 6974 732c 206e 6f72 6d73  y, limits, norms
+0001c870: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001c880: 2020 2020 2020 6e75 6d62 6572 206f 6620        number of 
+0001c890: 7374 7275 6374 7572 6573 2c20 2e2e 2e29  structures, ...)
+0001c8a0: 0a20 2020 2020 2020 2065 7073 5f2a 203a  .        eps_* :
+0001c8b0: 2076 616c 7565 7320 6f66 2070 7265 6369   values of preci
+0001c8c0: 7369 6f6e 2069 6e20 6561 6368 2064 6972  sion in each dir
+0001c8d0: 6563 7469 6f6e 0a20 2020 2020 2020 2066  ection.        f
+0001c8e0: 6f72 6269 6420 3a20 626f 6f6c 6561 6e20  orbid : boolean 
+0001c8f0: 6966 2074 7275 6520 666f 7262 6964 7320  if true forbids 
+0001c900: 6368 6563 6b69 6e67 2022 6265 6869 6e64  checking "behind
+0001c910: 2220 7468 6520 746f 6b61 6d61 6b0a 2020  " the tokamak.  
+0001c920: 2020 2020 2020 7465 7374 203a 2062 6f6f        test : boo
+0001c930: 6c65 616e 2063 6865 636b 2069 6620 696e  lean check if in
+0001c940: 7075 7420 6973 2076 616c 6964 206f 7220  put is valid or 
+0001c950: 6e6f 740a 2020 2020 2020 2020 6e75 6d5f  not.        num_
+0001c960: 7468 7265 6164 7320 3a20 6e75 6d62 6572  threads : number
+0001c970: 206f 6620 7468 7265 6164 7320 666f 7220   of threads for 
+0001c980: 7061 7261 6c6c 656c 697a 6174 696f 6e0a  parallelization.
+0001c990: 2020 2020 4f75 7470 7574 3a0a 2020 2020      Output:.    
+0001c9a0: 2020 2020 6973 5f73 6565 6e3a 2028 6e70      is_seen: (np
+0001c9b0: 7473 3129 2061 7272 6179 206f 6620 696e  ts1) array of in
+0001c9c0: 7473 2069 6e64 6963 6174 696e 6720 6966  ts indicating if
+0001c9d0: 2076 6965 7769 6e67 2070 6f69 6e74 2050   viewing point P
+0001c9e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c9f0: 2020 6361 6e20 7365 6520 7468 6520 6f74    can see the ot
+0001ca00: 6865 7220 706f 696e 7473 2070 7473 2e0a  her points pts..
+0001ca10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ca20: 2069 735f 7365 656e 5b69 5d20 3d20 3120   is_seen[i] = 1 
+0001ca30: 6966 2050 2073 6565 7320 706f 696e 7420  if P sees point 
+0001ca40: 7074 735b 695d 0a20 2020 2020 2020 2020  pts[i].         
 0001ca50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ca60: 2020 2020 2020 2020 2030 2065 6c73 650a           0 else.
-0001ca70: 2020 2020 2222 220a 2020 2020 6364 6566      """.    cdef
-0001ca80: 2073 7472 206d 7367 0a20 2020 2063 6465   str msg.    cde
-0001ca90: 6620 696e 7420 6e70 7473 203d 2070 7473  f int npts = pts
-0001caa0: 2e73 6861 7065 5b31 5d0a 2020 2020 6364  .shape[1].    cd
-0001cab0: 6566 2062 696e 7420 626f 6f6c 312c 2062  ef bint bool1, b
-0001cac0: 6f6f 6c32 0a20 2020 2063 6465 6620 646f  ool2.    cdef do
-0001cad0: 7562 6c65 5b3a 3a31 5d20 6c73 7472 7563  uble[::1] lstruc
-0001cae0: 745f 6c69 6d73 5f6e 700a 2020 2020 6364  t_lims_np.    cd
-0001caf0: 6566 206e 702e 6e64 6172 7261 795b 6c6f  ef np.ndarray[lo
-0001cb00: 6e67 2c20 6e64 696d 3d31 2c20 6d6f 6465  ng, ndim=1, mode
-0001cb10: 3d27 6327 5d20 6973 5f73 6565 6e0a 2020  ='c'] is_seen.  
-0001cb20: 2020 2320 3d3d 2054 6573 7469 6e67 2069    # == Testing i
-0001cb30: 6e70 7574 7320 3d3d 3d3d 3d3d 3d3d 3d3d  nputs ==========
+0001ca60: 2020 2020 2030 2065 6c73 650a 2020 2020       0 else.    
+0001ca70: 2222 220a 2020 2020 6364 6566 2073 7472  """.    cdef str
+0001ca80: 206d 7367 0a20 2020 2063 6465 6620 696e   msg.    cdef in
+0001ca90: 7420 6e70 7473 203d 2070 7473 2e73 6861  t npts = pts.sha
+0001caa0: 7065 5b31 5d0a 2020 2020 6364 6566 2062  pe[1].    cdef b
+0001cab0: 696e 7420 626f 6f6c 312c 2062 6f6f 6c32  int bool1, bool2
+0001cac0: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+0001cad0: 5b3a 3a31 5d20 6c73 7472 7563 745f 6c69  [::1] lstruct_li
+0001cae0: 6d73 5f6e 700a 2020 2020 6364 6566 206e  ms_np.    cdef n
+0001caf0: 702e 6e64 6172 7261 795b 6c6f 6e67 2c20  p.ndarray[long, 
+0001cb00: 6e64 696d 3d31 2c20 6d6f 6465 3d27 6327  ndim=1, mode='c'
+0001cb10: 5d20 6973 5f73 6565 6e0a 2020 2020 2320  ] is_seen.    # 
+0001cb20: 3d3d 2054 6573 7469 6e67 2069 6e70 7574  == Testing input
+0001cb30: 7320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  s ==============
 0001cb40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001cb50: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001cb60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a20  ==============. 
-0001cb70: 2020 2069 6620 7465 7374 3a0a 2020 2020     if test:.    
-0001cb80: 2020 2020 6d73 6720 3d20 2276 6573 5f70      msg = "ves_p
-0001cb90: 6f6c 7920 616e 6420 7665 735f 6e6f 726d  oly and ves_norm
-0001cba0: 2061 7265 206e 6f74 206f 7074 696f 6e61   are not optiona
-0001cbb0: 6c20 6172 6775 6d65 6e74 7322 0a20 2020  l arguments".   
-0001cbc0: 2020 2020 2061 7373 6572 7420 7665 735f       assert ves_
-0001cbd0: 706f 6c79 2069 7320 6e6f 7420 4e6f 6e65  poly is not None
-0001cbe0: 2061 6e64 2076 6573 5f6e 6f72 6d20 6973   and ves_norm is
-0001cbf0: 206e 6f74 204e 6f6e 652c 206d 7367 0a20   not None, msg. 
-0001cc00: 2020 2020 2020 2062 6f6f 6c31 203d 2028         bool1 = (
-0001cc10: 7665 735f 706f 6c79 2e73 6861 7065 5b30  ves_poly.shape[0
-0001cc20: 5d3d 3d32 2061 6e64 2076 6573 5f6e 6f72  ]==2 and ves_nor
-0001cc30: 6d2e 7368 6170 655b 305d 3d3d 320a 2020  m.shape[0]==2.  
-0001cc40: 2020 2020 2020 2020 2020 2020 616e 6420              and 
-0001cc50: 7665 735f 6e6f 726d 2e73 6861 7065 5b31  ves_norm.shape[1
-0001cc60: 5d3d 3d76 6573 5f70 6f6c 792e 7368 6170  ]==ves_poly.shap
-0001cc70: 655b 315d 2d31 290a 2020 2020 2020 2020  e[1]-1).        
-0001cc80: 6d73 6720 3d20 2241 7267 7320 7665 735f  msg = "Args ves_
-0001cc90: 706f 6c79 2061 6e64 2076 6573 5f6e 6f72  poly and ves_nor
-0001cca0: 6d20 6d75 7374 2062 6520 6f66 2074 6865  m must be of the
-0001ccb0: 2073 616d 6520 7368 6170 6520 2832 2c4e   same shape (2,N
-0001ccc0: 5329 2122 0a20 2020 2020 2020 2061 7373  S)!".        ass
-0001ccd0: 6572 7420 626f 6f6c 312c 206d 7367 0a20  ert bool1, msg. 
-0001cce0: 2020 2020 2020 2062 6f6f 6c31 203d 206c         bool1 = l
-0001ccf0: 7374 7275 6374 5f6c 696d 7320 6973 204e  struct_lims is N
-0001cd00: 6f6e 6520 6f72 206c 656e 286c 7374 7275  one or len(lstru
-0001cd10: 6374 5f6e 6f72 6d79 2920 3d3d 206c 656e  ct_normy) == len
-0001cd20: 286c 7374 7275 6374 5f6e 6f72 6d78 290a  (lstruct_normx).
-0001cd30: 2020 2020 2020 2020 626f 6f6c 3220 3d20          bool2 = 
-0001cd40: 6c73 7472 7563 745f 6e6f 726d 7820 6973  lstruct_normx is
-0001cd50: 204e 6f6e 6520 6f72 206c 656e 286c 7374   None or len(lst
-0001cd60: 7275 6374 5f70 6f6c 7978 2920 3d3d 206c  ruct_polyx) == l
-0001cd70: 656e 286c 7374 7275 6374 5f70 6f6c 7979  en(lstruct_polyy
-0001cd80: 290a 2020 2020 2020 2020 6d73 6720 3d20  ).        msg = 
-0001cd90: 2241 7267 7320 6c73 7472 7563 745f 706f  "Args lstruct_po
-0001cda0: 6c79 782c 206c 7374 7275 6374 5f70 6f6c  lyx, lstruct_pol
-0001cdb0: 7979 2c20 6c73 7472 7563 745f 6c69 6d73  yy, lstruct_lims
-0001cdc0: 2c20 6c73 7472 7563 745f 6e6f 726d 782c  , lstruct_normx,
-0001cdd0: 225c 0a20 2020 2020 2020 2020 2020 2020  "\.             
-0001cde0: 202b 2022 206c 7374 7275 6374 5f6e 6f72   + " lstruct_nor
-0001cdf0: 6d79 2c20 6d75 7374 2062 6520 4e6f 6e65  my, must be None
-0001ce00: 206f 7220 6c69 7374 7320 6f66 2073 616d   or lists of sam
-0001ce10: 6520 6c65 6e28 2921 220a 2020 2020 2020  e len()!".      
-0001ce20: 2020 6173 7365 7274 2062 6f6f 6c31 2061    assert bool1 a
-0001ce30: 6e64 2062 6f6f 6c32 2c20 6d73 670a 2020  nd bool2, msg.  
-0001ce40: 2020 2020 2020 6d73 6720 3d20 225b 6570        msg = "[ep
-0001ce50: 735f 757a 2c65 7073 5f76 7a2c 6570 735f  s_uz,eps_vz,eps_
-0001ce60: 612c 6570 735f 625d 206d 7573 7420 6265  a,eps_b] must be
-0001ce70: 2066 6c6f 6174 7320 3c20 312e 652d 3421   floats < 1.e-4!
-0001ce80: 220a 2020 2020 2020 2020 6173 7365 7274  ".        assert
-0001ce90: 2061 6c6c 285b 6565 203c 2031 2e65 2d34   all([ee < 1.e-4
-0001cea0: 2066 6f72 2065 6520 696e 205b 6570 735f   for ee in [eps_
-0001ceb0: 757a 2c20 6570 735f 612c 0a20 2020 2020  uz, eps_a,.     
+0001cb60: 3d3d 3d3d 3d3d 3d3d 3d3d 0a20 2020 2069  ==========.    i
+0001cb70: 6620 7465 7374 3a0a 2020 2020 2020 2020  f test:.        
+0001cb80: 6d73 6720 3d20 2276 6573 5f70 6f6c 7920  msg = "ves_poly 
+0001cb90: 616e 6420 7665 735f 6e6f 726d 2061 7265  and ves_norm are
+0001cba0: 206e 6f74 206f 7074 696f 6e61 6c20 6172   not optional ar
+0001cbb0: 6775 6d65 6e74 7322 0a20 2020 2020 2020  guments".       
+0001cbc0: 2061 7373 6572 7420 7665 735f 706f 6c79   assert ves_poly
+0001cbd0: 2069 7320 6e6f 7420 4e6f 6e65 2061 6e64   is not None and
+0001cbe0: 2076 6573 5f6e 6f72 6d20 6973 206e 6f74   ves_norm is not
+0001cbf0: 204e 6f6e 652c 206d 7367 0a20 2020 2020   None, msg.     
+0001cc00: 2020 2062 6f6f 6c31 203d 2028 7665 735f     bool1 = (ves_
+0001cc10: 706f 6c79 2e73 6861 7065 5b30 5d3d 3d32  poly.shape[0]==2
+0001cc20: 2061 6e64 2076 6573 5f6e 6f72 6d2e 7368   and ves_norm.sh
+0001cc30: 6170 655b 305d 3d3d 320a 2020 2020 2020  ape[0]==2.      
+0001cc40: 2020 2020 2020 2020 616e 6420 7665 735f          and ves_
+0001cc50: 6e6f 726d 2e73 6861 7065 5b31 5d3d 3d76  norm.shape[1]==v
+0001cc60: 6573 5f70 6f6c 792e 7368 6170 655b 315d  es_poly.shape[1]
+0001cc70: 2d31 290a 2020 2020 2020 2020 6d73 6720  -1).        msg 
+0001cc80: 3d20 2241 7267 7320 7665 735f 706f 6c79  = "Args ves_poly
+0001cc90: 2061 6e64 2076 6573 5f6e 6f72 6d20 6d75   and ves_norm mu
+0001cca0: 7374 2062 6520 6f66 2074 6865 2073 616d  st be of the sam
+0001ccb0: 6520 7368 6170 6520 2832 2c4e 5329 2122  e shape (2,NS)!"
+0001ccc0: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+0001ccd0: 626f 6f6c 312c 206d 7367 0a20 2020 2020  bool1, msg.     
+0001cce0: 2020 2062 6f6f 6c31 203d 206c 7374 7275     bool1 = lstru
+0001ccf0: 6374 5f6c 696d 7320 6973 204e 6f6e 6520  ct_lims is None 
+0001cd00: 6f72 206c 656e 286c 7374 7275 6374 5f6e  or len(lstruct_n
+0001cd10: 6f72 6d79 2920 3d3d 206c 656e 286c 7374  ormy) == len(lst
+0001cd20: 7275 6374 5f6e 6f72 6d78 290a 2020 2020  ruct_normx).    
+0001cd30: 2020 2020 626f 6f6c 3220 3d20 6c73 7472      bool2 = lstr
+0001cd40: 7563 745f 6e6f 726d 7820 6973 204e 6f6e  uct_normx is Non
+0001cd50: 6520 6f72 206c 656e 286c 7374 7275 6374  e or len(lstruct
+0001cd60: 5f70 6f6c 7978 2920 3d3d 206c 656e 286c  _polyx) == len(l
+0001cd70: 7374 7275 6374 5f70 6f6c 7979 290a 2020  struct_polyy).  
+0001cd80: 2020 2020 2020 6d73 6720 3d20 2241 7267        msg = "Arg
+0001cd90: 7320 6c73 7472 7563 745f 706f 6c79 782c  s lstruct_polyx,
+0001cda0: 206c 7374 7275 6374 5f70 6f6c 7979 2c20   lstruct_polyy, 
+0001cdb0: 6c73 7472 7563 745f 6c69 6d73 2c20 6c73  lstruct_lims, ls
+0001cdc0: 7472 7563 745f 6e6f 726d 782c 225c 0a20  truct_normx,"\. 
+0001cdd0: 2020 2020 2020 2020 2020 2020 202b 2022               + "
+0001cde0: 206c 7374 7275 6374 5f6e 6f72 6d79 2c20   lstruct_normy, 
+0001cdf0: 6d75 7374 2062 6520 4e6f 6e65 206f 7220  must be None or 
+0001ce00: 6c69 7374 7320 6f66 2073 616d 6520 6c65  lists of same le
+0001ce10: 6e28 2921 220a 2020 2020 2020 2020 6173  n()!".        as
+0001ce20: 7365 7274 2062 6f6f 6c31 2061 6e64 2062  sert bool1 and b
+0001ce30: 6f6f 6c32 2c20 6d73 670a 2020 2020 2020  ool2, msg.      
+0001ce40: 2020 6d73 6720 3d20 225b 6570 735f 757a    msg = "[eps_uz
+0001ce50: 2c65 7073 5f76 7a2c 6570 735f 612c 6570  ,eps_vz,eps_a,ep
+0001ce60: 735f 625d 206d 7573 7420 6265 2066 6c6f  s_b] must be flo
+0001ce70: 6174 7320 3c20 312e 652d 3421 220a 2020  ats < 1.e-4!".  
+0001ce80: 2020 2020 2020 6173 7365 7274 2061 6c6c        assert all
+0001ce90: 285b 6565 203c 2031 2e65 2d34 2066 6f72  ([ee < 1.e-4 for
+0001cea0: 2065 6520 696e 205b 6570 735f 757a 2c20   ee in [eps_uz, 
+0001ceb0: 6570 735f 612c 0a20 2020 2020 2020 2020  eps_a,.         
 0001cec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001ced0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cee0: 2020 2020 2065 7073 5f76 7a2c 2065 7073       eps_vz, eps
-0001cef0: 5f62 2c0a 2020 2020 2020 2020 2020 2020  _b,.            
+0001cee0: 2065 7073 5f76 7a2c 2065 7073 5f62 2c0a   eps_vz, eps_b,.
+0001cef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001cf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cf10: 2020 2020 2020 2020 2020 2020 2020 6570                ep
-0001cf20: 735f 706c 616e 655d 5d29 2c20 6d73 670a  s_plane]]), msg.
-0001cf30: 2020 2020 2020 2020 6d73 6720 3d20 2276          msg = "v
-0001cf40: 6573 5f74 7970 6520 6d75 7374 2062 6520  es_type must be 
-0001cf50: 6120 7374 7220 696e 205b 2754 6f72 272c  a str in ['Tor',
-0001cf60: 274c 696e 275d 2122 0a20 2020 2020 2020  'Lin']!".       
-0001cf70: 2061 7373 6572 7420 7665 735f 7479 7065   assert ves_type
-0001cf80: 2e6c 6f77 6572 2829 2069 6e20 5b27 746f  .lower() in ['to
-0001cf90: 7227 2c20 276c 696e 275d 2c20 6d73 670a  r', 'lin'], msg.
-0001cfa0: 2020 2020 2320 2e2e 2e0a 2020 2020 6c73      # ....    ls
-0001cfb0: 7472 7563 745f 6c69 6d73 5f6e 7020 3d20  truct_lims_np = 
-0001cfc0: 666c 6174 7465 6e5f 6c73 7472 7563 745f  flatten_lstruct_
-0001cfd0: 6c69 6d73 286c 7374 7275 6374 5f6c 696d  lims(lstruct_lim
-0001cfe0: 7329 0a20 2020 2069 735f 7365 656e 203d  s).    is_seen =
-0001cff0: 206e 702e 656d 7074 7928 286e 7074 7329   np.empty((npts)
-0001d000: 2c20 6474 7970 653d 696e 7429 0a20 2020  , dtype=int).   
-0001d010: 205f 7274 2e69 735f 7669 7369 626c 655f   _rt.is_visible_
-0001d020: 7074 5f76 6563 2870 7430 2c20 7074 312c  pt_vec(pt0, pt1,
-0001d030: 2070 7432 2c0a 2020 2020 2020 2020 2020   pt2,.          
-0001d040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d050: 7074 732c 206e 7074 732c 0a20 2020 2020  pts, npts,.     
+0001cf10: 2020 2020 2020 2020 2020 6570 735f 706c            eps_pl
+0001cf20: 616e 655d 5d29 2c20 6d73 670a 2020 2020  ane]]), msg.    
+0001cf30: 2020 2020 6d73 6720 3d20 2276 6573 5f74      msg = "ves_t
+0001cf40: 7970 6520 6d75 7374 2062 6520 6120 7374  ype must be a st
+0001cf50: 7220 696e 205b 2754 6f72 272c 274c 696e  r in ['Tor','Lin
+0001cf60: 275d 2122 0a20 2020 2020 2020 2061 7373  ']!".        ass
+0001cf70: 6572 7420 7665 735f 7479 7065 2e6c 6f77  ert ves_type.low
+0001cf80: 6572 2829 2069 6e20 5b27 746f 7227 2c20  er() in ['tor', 
+0001cf90: 276c 696e 275d 2c20 6d73 670a 2020 2020  'lin'], msg.    
+0001cfa0: 2320 2e2e 2e0a 2020 2020 6c73 7472 7563  # ....    lstruc
+0001cfb0: 745f 6c69 6d73 5f6e 7020 3d20 666c 6174  t_lims_np = flat
+0001cfc0: 7465 6e5f 6c73 7472 7563 745f 6c69 6d73  ten_lstruct_lims
+0001cfd0: 286c 7374 7275 6374 5f6c 696d 7329 0a20  (lstruct_lims). 
+0001cfe0: 2020 2069 735f 7365 656e 203d 206e 702e     is_seen = np.
+0001cff0: 656d 7074 7928 286e 7074 7329 2c20 6474  empty((npts), dt
+0001d000: 7970 653d 696e 7429 0a20 2020 205f 7274  ype=int).    _rt
+0001d010: 2e69 735f 7669 7369 626c 655f 7074 5f76  .is_visible_pt_v
+0001d020: 6563 2870 7430 2c20 7074 312c 2070 7432  ec(pt0, pt1, pt2
+0001d030: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001d040: 2020 2020 2020 2020 2020 2020 7074 732c              pts,
+0001d050: 206e 7074 732c 0a20 2020 2020 2020 2020   npts,.         
 0001d060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d070: 2020 2020 2076 6573 5f70 6f6c 792c 2076       ves_poly, v
-0001d080: 6573 5f6e 6f72 6d2c 0a20 2020 2020 2020  es_norm,.       
-0001d090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d0a0: 2020 2026 6973 5f73 6565 6e5b 305d 2c20     &is_seen[0], 
-0001d0b0: 6469 7374 2c20 7665 735f 6c69 6d73 2c0a  dist, ves_lims,.
+0001d070: 2076 6573 5f70 6f6c 792c 2076 6573 5f6e   ves_poly, ves_n
+0001d080: 6f72 6d2c 0a20 2020 2020 2020 2020 2020  orm,.           
+0001d090: 2020 2020 2020 2020 2020 2020 2020 2026                 &
+0001d0a0: 6973 5f73 6565 6e5b 305d 2c20 6469 7374  is_seen[0], dist
+0001d0b0: 2c20 7665 735f 6c69 6d73 2c0a 2020 2020  , ves_lims,.    
 0001d0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d0d0: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
-0001d0e0: 745f 6e6c 696d 2c0a 2020 2020 2020 2020  t_nlim,.        
-0001d0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d100: 2020 6c73 7472 7563 745f 706f 6c79 782c    lstruct_polyx,
-0001d110: 206c 7374 7275 6374 5f70 6f6c 7979 2c0a   lstruct_polyy,.
+0001d0d0: 2020 2020 2020 6c73 7472 7563 745f 6e6c        lstruct_nl
+0001d0e0: 696d 2c0a 2020 2020 2020 2020 2020 2020  im,.            
+0001d0f0: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
+0001d100: 7472 7563 745f 706f 6c79 782c 206c 7374  truct_polyx, lst
+0001d110: 7275 6374 5f70 6f6c 7979 2c0a 2020 2020  ruct_polyy,.    
 0001d120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d130: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
-0001d140: 745f 6c69 6d73 5f6e 702c 0a20 2020 2020  t_lims_np,.     
+0001d130: 2020 2020 2020 6c73 7472 7563 745f 6c69        lstruct_li
+0001d140: 6d73 5f6e 702c 0a20 2020 2020 2020 2020  ms_np,.         
 0001d150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d160: 2020 2020 206c 7374 7275 6374 5f6e 6f72       lstruct_nor
-0001d170: 6d78 2c20 6c73 7472 7563 745f 6e6f 726d  mx, lstruct_norm
-0001d180: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
-0001d190: 2020 2020 2020 2020 2020 2020 206c 6e76               lnv
-0001d1a0: 6572 742c 206e 7374 7275 6374 5f74 6f74  ert, nstruct_tot
-0001d1b0: 2c20 6e73 7472 7563 745f 6c69 6d2c 0a20  , nstruct_lim,. 
+0001d160: 206c 7374 7275 6374 5f6e 6f72 6d78 2c20   lstruct_normx, 
+0001d170: 6c73 7472 7563 745f 6e6f 726d 792c 0a20  lstruct_normy,. 
+0001d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d190: 2020 2020 2020 2020 206c 6e76 6572 742c           lnvert,
+0001d1a0: 206e 7374 7275 6374 5f74 6f74 2c20 6e73   nstruct_tot, ns
+0001d1b0: 7472 7563 745f 6c69 6d2c 0a20 2020 2020  truct_lim,.     
 0001d1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d1d0: 2020 2020 2020 2020 2072 6d69 6e2c 2065           rmin, e
-0001d1e0: 7073 5f75 7a2c 2065 7073 5f61 2c20 6570  ps_uz, eps_a, ep
-0001d1f0: 735f 767a 2c20 6570 735f 622c 0a20 2020  s_vz, eps_b,.   
+0001d1d0: 2020 2020 2072 6d69 6e2c 2065 7073 5f75       rmin, eps_u
+0001d1e0: 7a2c 2065 7073 5f61 2c20 6570 735f 767a  z, eps_a, eps_vz
+0001d1f0: 2c20 6570 735f 622c 0a20 2020 2020 2020  , eps_b,.       
 0001d200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d210: 2020 2020 2020 2065 7073 5f70 6c61 6e65         eps_plane
-0001d220: 2c20 7665 735f 7479 7065 2e6c 6f77 6572  , ves_type.lower
-0001d230: 2829 3d3d 2774 6f72 272c 0a20 2020 2020  ()=='tor',.     
+0001d210: 2020 2065 7073 5f70 6c61 6e65 2c20 7665     eps_plane, ve
+0001d220: 735f 7479 7065 2e6c 6f77 6572 2829 3d3d  s_type.lower()==
+0001d230: 2774 6f72 272c 0a20 2020 2020 2020 2020  'tor',.         
 0001d240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d250: 2020 2020 2066 6f72 6269 642c 206e 756d       forbid, num
-0001d260: 5f74 6872 6561 6473 290a 2020 2020 7265  _threads).    re
-0001d270: 7475 726e 2069 735f 7365 656e 0a0a 0a23  turn is_seen...#
-0001d280: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+0001d250: 2066 6f72 6269 642c 206e 756d 5f74 6872   forbid, num_thr
+0001d260: 6561 6473 290a 2020 2020 7265 7475 726e  eads).    return
+0001d270: 2069 735f 7365 656e 0a0a 0a23 203d 3d3d   is_seen...# ===
+0001d280: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001d290: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001d2a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001d2b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
-0001d2c0: 230a 2320 2020 2020 2020 2020 2020 2020  #.#             
+0001d2b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 230a 2320  ===========.#.# 
+0001d2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001d2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d2e0: 2020 2020 5649 474e 4554 5449 4e47 0a23      VIGNETTING.#
-0001d2f0: 0a23 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  .# =============
+0001d2e0: 5649 474e 4554 5449 4e47 0a23 0a23 203d  VIGNETTING.#.# =
+0001d2f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001d300: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001d310: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001d320: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001d330: 3d3d 0a0a 0a64 6566 2074 7269 616e 6775  ==...def triangu
-0001d340: 6c61 7465 5f62 795f 6561 7263 6c69 7070  late_by_earclipp
-0001d350: 696e 675f 3264 280a 2020 2020 6e70 2e6e  ing_2d(.    np.n
-0001d360: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
-0001d370: 6469 6d3d 325d 2070 6f6c 792c 0a29 3a0a  dim=2] poly,.):.
-0001d380: 2020 2020 2222 220a 2020 2020 5472 6961      """.    Tria
-0001d390: 6e67 756c 6174 6573 2061 2073 696e 676c  ngulates a singl
-0001d3a0: 6520 3364 2070 6f6c 7967 6f6e 2062 7920  e 3d polygon by 
-0001d3b0: 7468 6520 6561 7263 6c69 7070 696e 6720  the earclipping 
-0001d3c0: 6d65 7468 6f64 2e0a 2020 2020 436f 6e76  method..    Conv
-0001d3d0: 6572 7473 2033 6420 706f 6c79 676f 6e20  erts 3d polygon 
-0001d3e0: 696e 746f 2032 6420 636f 756e 7465 722d  into 2d counter-
-0001d3f0: 636c 6f63 6b77 6973 6520 7072 6f6a 6563  clockwise projec
-0001d400: 7469 6f6e 0a0a 2020 2020 5061 7261 6d73  tion..    Params
-0001d410: 0a20 2020 203d 3d3d 3d3d 0a20 2020 2070  .    =====.    p
-0001d420: 6f6c 7920 3a20 2833 2c20 6e76 6572 7429  oly : (3, nvert)
-0001d430: 2064 6f75 626c 6520 6172 7261 790a 2020   double array.  
-0001d440: 2020 2020 2020 436f 6e74 6169 6e73 2033        Contains 3
-0001d450: 4420 636f 6f72 6469 6e61 7465 7320 6f66  D coordinates of
-0001d460: 206f 7065 6e20 706f 6c79 676f 6e20 696e   open polygon in
-0001d470: 2063 6f75 6e74 6572 2063 6c6f 636b 7769   counter clockwi
-0001d480: 7365 206f 7264 6572 0a20 2020 2052 6574  se order.    Ret
-0001d490: 7572 6e73 0a20 2020 203d 3d3d 3d3d 3d3d  urns.    =======
-0001d4a0: 0a20 2020 206c 7472 6920 3a20 2833 2a28  .    ltri : (3*(
-0001d4b0: 6e76 6572 742d 3229 2920 696e 7420 6172  nvert-2)) int ar
-0001d4c0: 7261 790a 2020 2020 2020 2020 496e 6469  ray.        Indi
-0001d4d0: 6365 7320 6f66 2074 7269 616e 676c 6573  ces of triangles
-0001d4e0: 0a20 2020 2022 2222 0a20 2020 2063 6465  .    """.    cde
-0001d4f0: 6620 696e 7420 6e76 6572 7420 3d20 706f  f int nvert = po
-0001d500: 6c79 2e73 6861 7065 5b31 5d0a 2020 2020  ly.shape[1].    
-0001d510: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
-0001d520: 6c6f 6e67 2c20 6e64 696d 3d31 5d20 6c74  long, ndim=1] lt
-0001d530: 7269 203d 206e 702e 656d 7074 7928 286e  ri = np.empty((n
-0001d540: 7665 7274 2d32 292a 332c 2064 7479 7065  vert-2)*3, dtype
-0001d550: 3d69 6e74 290a 2020 2020 6364 6566 2064  =int).    cdef d
-0001d560: 6f75 626c 652a 2064 6966 6620 3d20 4e55  ouble* diff = NU
-0001d570: 4c4c 0a20 2020 2063 6465 6620 6269 6e74  LL.    cdef bint
-0001d580: 2a20 6c72 6566 203d 204e 554c 4c0a 0a20  * lref = NULL.. 
-0001d590: 2020 2023 2049 6e69 7469 616c 697a 6174     # Initializat
-0001d5a0: 696f 6e20 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ion ............
+0001d320: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a  ==============..
+0001d330: 0a64 6566 2074 7269 616e 6775 6c61 7465  .def triangulate
+0001d340: 5f62 795f 6561 7263 6c69 7070 696e 675f  _by_earclipping_
+0001d350: 3264 280a 2020 2020 6e70 2e6e 6461 7272  2d(.    np.ndarr
+0001d360: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
+0001d370: 325d 2070 6f6c 792c 0a29 3a0a 2020 2020  2] poly,.):.    
+0001d380: 2222 220a 2020 2020 5472 6961 6e67 756c  """.    Triangul
+0001d390: 6174 6573 2061 2073 696e 676c 6520 3364  ates a single 3d
+0001d3a0: 2070 6f6c 7967 6f6e 2062 7920 7468 6520   polygon by the 
+0001d3b0: 6561 7263 6c69 7070 696e 6720 6d65 7468  earclipping meth
+0001d3c0: 6f64 2e0a 2020 2020 436f 6e76 6572 7473  od..    Converts
+0001d3d0: 2033 6420 706f 6c79 676f 6e20 696e 746f   3d polygon into
+0001d3e0: 2032 6420 636f 756e 7465 722d 636c 6f63   2d counter-cloc
+0001d3f0: 6b77 6973 6520 7072 6f6a 6563 7469 6f6e  kwise projection
+0001d400: 0a0a 2020 2020 5061 7261 6d73 0a20 2020  ..    Params.   
+0001d410: 203d 3d3d 3d3d 0a20 2020 2070 6f6c 7920   =====.    poly 
+0001d420: 3a20 2833 2c20 6e76 6572 7429 2064 6f75  : (3, nvert) dou
+0001d430: 626c 6520 6172 7261 790a 2020 2020 2020  ble array.      
+0001d440: 2020 436f 6e74 6169 6e73 2033 4420 636f    Contains 3D co
+0001d450: 6f72 6469 6e61 7465 7320 6f66 206f 7065  ordinates of ope
+0001d460: 6e20 706f 6c79 676f 6e20 696e 2063 6f75  n polygon in cou
+0001d470: 6e74 6572 2063 6c6f 636b 7769 7365 206f  nter clockwise o
+0001d480: 7264 6572 0a20 2020 2052 6574 7572 6e73  rder.    Returns
+0001d490: 0a20 2020 203d 3d3d 3d3d 3d3d 0a20 2020  .    =======.   
+0001d4a0: 206c 7472 6920 3a20 2833 2a28 6e76 6572   ltri : (3*(nver
+0001d4b0: 742d 3229 2920 696e 7420 6172 7261 790a  t-2)) int array.
+0001d4c0: 2020 2020 2020 2020 496e 6469 6365 7320          Indices 
+0001d4d0: 6f66 2074 7269 616e 676c 6573 0a20 2020  of triangles.   
+0001d4e0: 2022 2222 0a20 2020 2063 6465 6620 696e   """.    cdef in
+0001d4f0: 7420 6e76 6572 7420 3d20 706f 6c79 2e73  t nvert = poly.s
+0001d500: 6861 7065 5b31 5d0a 2020 2020 6364 6566  hape[1].    cdef
+0001d510: 206e 702e 6e64 6172 7261 795b 6c6f 6e67   np.ndarray[long
+0001d520: 2c20 6e64 696d 3d31 5d20 6c74 7269 203d  , ndim=1] ltri =
+0001d530: 206e 702e 656d 7074 7928 286e 7665 7274   np.empty((nvert
+0001d540: 2d32 292a 332c 2064 7479 7065 3d69 6e74  -2)*3, dtype=int
+0001d550: 290a 2020 2020 6364 6566 2064 6f75 626c  ).    cdef doubl
+0001d560: 652a 2064 6966 6620 3d20 4e55 4c4c 0a20  e* diff = NULL. 
+0001d570: 2020 2063 6465 6620 6269 6e74 2a20 6c72     cdef bint* lr
+0001d580: 6566 203d 204e 554c 4c0a 0a20 2020 2023  ef = NULL..    #
+0001d590: 2049 6e69 7469 616c 697a 6174 696f 6e20   Initialization 
+0001d5a0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 0001d5b0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-0001d5c0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20  ............... 
-0001d5d0: 2020 2064 6966 6620 3d20 3c64 6f75 626c     diff = <doubl
-0001d5e0: 652a 3e6d 616c 6c6f 6328 322a 6e76 6572  e*>malloc(2*nver
-0001d5f0: 742a 7369 7a65 6f66 2864 6f75 626c 6529  t*sizeof(double)
-0001d600: 290a 2020 2020 6c72 6566 203d 203c 6269  ).    lref = <bi
-0001d610: 6e74 2a3e 6d61 6c6c 6f63 286e 7665 7274  nt*>malloc(nvert
-0001d620: 2a73 697a 656f 6628 6269 6e74 2929 0a0a  *sizeof(bint))..
-0001d630: 2020 2020 5f76 742e 636f 6d70 7574 655f      _vt.compute_
-0001d640: 6469 6666 3264 2826 706f 6c79 5b30 2c20  diff2d(&poly[0, 
-0001d650: 305d 2c20 6e76 6572 742c 2026 6469 6666  0], nvert, &diff
-0001d660: 5b30 5d29 0a20 2020 205f 7674 2e61 7265  [0]).    _vt.are
-0001d670: 5f70 6f69 6e74 735f 7265 666c 6578 5f32  _points_reflex_2
-0001d680: 6428 6e76 6572 742c 2026 6469 6666 5b30  d(nvert, &diff[0
-0001d690: 5d2c 2026 6c72 6566 5b30 5d29 0a0a 2020  ], &lref[0])..  
-0001d6a0: 2020 2320 4361 6c6c 696e 6720 636f 7265    # Calling core
-0001d6b0: 2066 756e 6374 696f 6e2e 2e2e 2e2e 2e2e   function.......
+0001d5c0: 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020 2064  ...........    d
+0001d5d0: 6966 6620 3d20 3c64 6f75 626c 652a 3e6d  iff = <double*>m
+0001d5e0: 616c 6c6f 6328 322a 6e76 6572 742a 7369  alloc(2*nvert*si
+0001d5f0: 7a65 6f66 2864 6f75 626c 6529 290a 2020  zeof(double)).  
+0001d600: 2020 6c72 6566 203d 203c 6269 6e74 2a3e    lref = <bint*>
+0001d610: 6d61 6c6c 6f63 286e 7665 7274 2a73 697a  malloc(nvert*siz
+0001d620: 656f 6628 6269 6e74 2929 0a0a 2020 2020  eof(bint))..    
+0001d630: 5f76 742e 636f 6d70 7574 655f 6469 6666  _vt.compute_diff
+0001d640: 3264 2826 706f 6c79 5b30 2c20 305d 2c20  2d(&poly[0, 0], 
+0001d650: 6e76 6572 742c 2026 6469 6666 5b30 5d29  nvert, &diff[0])
+0001d660: 0a20 2020 205f 7674 2e61 7265 5f70 6f69  .    _vt.are_poi
+0001d670: 6e74 735f 7265 666c 6578 5f32 6428 6e76  nts_reflex_2d(nv
+0001d680: 6572 742c 2026 6469 6666 5b30 5d2c 2026  ert, &diff[0], &
+0001d690: 6c72 6566 5b30 5d29 0a0a 2020 2020 2320  lref[0])..    # 
+0001d6a0: 4361 6c6c 696e 6720 636f 7265 2066 756e  Calling core fun
+0001d6b0: 6374 696f 6e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ction...........
 0001d6c0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-0001d6d0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a  ................
-0001d6e0: 2020 2020 5f76 742e 6561 7263 6c69 7070      _vt.earclipp
-0001d6f0: 696e 675f 706f 6c79 5f32 6428 2670 6f6c  ing_poly_2d(&pol
-0001d700: 795b 302c 2030 5d2c 2026 6c74 7269 5b30  y[0, 0], &ltri[0
-0001d710: 5d2c 2026 6469 6666 5b30 5d2c 2026 6c72  ], &diff[0], &lr
-0001d720: 6566 5b30 5d2c 206e 7665 7274 290a 0a20  ef[0], nvert).. 
-0001d730: 2020 2023 2066 7265 6520 6d65 6d6f 7279     # free memory
-0001d740: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-0001d750: 0a20 2020 2066 7265 6528 6469 6666 290a  .    free(diff).
-0001d760: 2020 2020 6672 6565 286c 7265 6629 0a20      free(lref). 
-0001d770: 2020 2072 6574 7572 6e20 6c74 7269 2e72     return ltri.r
-0001d780: 6573 6861 7065 2828 6e76 6572 742d 322c  eshape((nvert-2,
-0001d790: 2033 2929 0a0a 0a64 6566 2076 6967 6e65   3))...def vigne
-0001d7a0: 7474 696e 6728 0a20 2020 2064 6f75 626c  tting(.    doubl
-0001d7b0: 655b 3a2c 203a 3a31 5d20 7261 795f 6f72  e[:, ::1] ray_or
-0001d7c0: 6967 2c0a 2020 2020 646f 7562 6c65 5b3a  ig,.    double[:
-0001d7d0: 2c20 3a3a 315d 2072 6179 5f76 6469 722c  , ::1] ray_vdir,
-0001d7e0: 0a20 2020 206c 6973 7420 7669 676e 6574  .    list vignet
-0001d7f0: 745f 706f 6c79 2c0a 2020 2020 6c6f 6e67  t_poly,.    long
-0001d800: 5b3a 3a31 5d20 6c6e 7665 7274 2c0a 2020  [::1] lnvert,.  
-0001d810: 2020 696e 7420 6e75 6d5f 7468 7265 6164    int num_thread
-0001d820: 733d 3136 2c0a 293a 0a20 2020 2022 2222  s=16,.):.    """
-0001d830: 0a20 2020 2072 6179 5f6f 7269 6720 3a20  .    ray_orig : 
-0001d840: 2833 2c20 6e6c 6f73 2920 646f 7562 6c65  (3, nlos) double
-0001d850: 2061 7272 6179 0a20 2020 2020 2020 4c4f   array.       LO
-0001d860: 5320 6f72 6967 696e 2070 6f69 6e74 7320  S origin points 
-0001d870: 636f 6f72 6469 6e61 7465 730a 2020 2020  coordinates.    
-0001d880: 7261 795f 7664 6972 203a 2028 332c 206e  ray_vdir : (3, n
-0001d890: 6c6f 7329 2064 6f75 626c 6520 6172 7261  los) double arra
-0001d8a0: 790a 2020 2020 2020 204c 4f53 206e 6f72  y.       LOS nor
-0001d8b0: 6d61 6c69 7a65 6420 6469 7265 6374 696f  malized directio
-0001d8c0: 6e20 7665 6374 6f72 0a20 2020 2076 6967  n vector.    vig
-0001d8d0: 6e65 7474 5f70 6f6c 7920 3a20 286e 756d  nett_poly : (num
-0001d8e0: 5f76 6967 6e2c 2033 2c20 6e75 6d5f 7665  _vign, 3, num_ve
-0001d8f0: 7274 6578 2920 646f 7562 6c65 206c 6973  rtex) double lis
-0001d900: 7420 6f66 2061 7272 6179 730a 2020 2020  t of arrays.    
-0001d910: 2020 2043 6f6f 7264 696e 6174 6573 206f     Coordinates o
-0001d920: 6620 7468 6520 7665 7274 6963 6573 206f  f the vertices o
-0001d930: 6620 7468 6520 506f 6c79 676f 6e20 6465  f the Polygon de
-0001d940: 6669 6e69 6e67 2074 6865 2033 4420 7669  fining the 3D vi
-0001d950: 676e 6574 742e 0a20 2020 2020 2020 504f  gnett..       PO
-0001d960: 4c59 2043 4c4f 5345 440a 2020 2020 6c6e  LY CLOSED.    ln
-0001d970: 7665 7274 203a 2028 6e75 6d5f 7669 676e  vert : (num_vign
-0001d980: 2920 6c6f 6e67 2061 7272 6179 0a20 2020  ) long array.   
-0001d990: 2020 2020 4e75 6d62 6572 206f 6620 7665      Number of ve
-0001d9a0: 7274 6963 6573 2066 6f72 2065 6163 6820  rtices for each 
-0001d9b0: 7669 676e 6574 7420 2877 6974 686f 7574  vignett (without
-0001d9c0: 2063 6f75 6e74 696e 6720 7468 6520 7265   counting the re
-0001d9d0: 626f 756e 6429 0a20 2020 2052 6574 7572  bound).    Retur
-0001d9e0: 6e73 0a20 2020 203d 3d3d 3d3d 3d0a 2020  ns.    ======.  
-0001d9f0: 2020 676f 6573 5f74 6872 6f75 6768 3a20    goes_through: 
-0001da00: 286e 756d 5f76 6967 6e2c 206e 6c6f 7329  (num_vign, nlos)
-0001da10: 2062 6f6f 6c20 6172 7261 790a 2020 2020   bool array.    
-0001da20: 2020 2049 6e64 6963 6174 6573 2066 6f72     Indicates for
-0001da30: 2065 6163 6820 7669 676e 6574 7420 6966   each vignett if
-0001da40: 2065 6163 6820 4c4f 5320 7765 6e74 7320   each LOS wents 
-0001da50: 7468 726f 7567 6820 6f72 206e 6f74 0a20  through or not. 
-0001da60: 2020 2022 2222 0a20 2020 2063 6465 6620     """.    cdef 
-0001da70: 696e 7420 6969 0a20 2020 2063 6465 6620  int ii.    cdef 
-0001da80: 696e 7420 6e76 6967 6e2c 206e 6c6f 730a  int nvign, nlos.
-0001da90: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-0001daa0: 7261 795b 6e70 2e75 696e 7438 5f74 2c6e  ray[np.uint8_t,n
-0001dab0: 6469 6d3d 312c 6361 7374 3d54 7275 655d  dim=1,cast=True]
-0001dac0: 2067 6f65 735f 7468 726f 7567 680a 2020   goes_through.  
-0001dad0: 2020 6364 6566 206c 6f6e 672a 2a20 6c74    cdef long** lt
-0001dae0: 7269 203d 204e 554c 4c0a 2020 2020 6364  ri = NULL.    cd
-0001daf0: 6566 2064 6f75 626c 652a 206c 626f 756e  ef double* lboun
-0001db00: 6473 203d 204e 554c 4c0a 2020 2020 6364  ds = NULL.    cd
-0001db10: 6566 2064 6f75 626c 652a 2a20 6461 7461  ef double** data
-0001db20: 203d 204e 554c 4c0a 2020 2020 6364 6566   = NULL.    cdef
-0001db30: 2062 696e 742a 2062 6f6f 6c5f 7265 7320   bint* bool_res 
-0001db40: 3d20 4e55 4c4c 0a20 2020 2063 6465 6620  = NULL.    cdef 
-0001db50: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0001db60: 652c 206e 6469 6d3d 322c 206d 6f64 653d  e, ndim=2, mode=
-0001db70: 2263 225d 2074 656d 700a 2020 2020 2320  "c"] temp.    # 
-0001db80: 2d2d 2049 6e69 7469 616c 697a 6174 696f  -- Initializatio
-0001db90: 6e20 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  n --------------
+0001d6d0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a 2020 2020  ............    
+0001d6e0: 5f76 742e 6561 7263 6c69 7070 696e 675f  _vt.earclipping_
+0001d6f0: 706f 6c79 5f32 6428 2670 6f6c 795b 302c  poly_2d(&poly[0,
+0001d700: 2030 5d2c 2026 6c74 7269 5b30 5d2c 2026   0], &ltri[0], &
+0001d710: 6469 6666 5b30 5d2c 2026 6c72 6566 5b30  diff[0], &lref[0
+0001d720: 5d2c 206e 7665 7274 290a 0a20 2020 2023  ], nvert)..    #
+0001d730: 2066 7265 6520 6d65 6d6f 7279 2e2e 2e2e   free memory....
+0001d740: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020  .............   
+0001d750: 2066 7265 6528 6469 6666 290a 2020 2020   free(diff).    
+0001d760: 6672 6565 286c 7265 6629 0a20 2020 2072  free(lref).    r
+0001d770: 6574 7572 6e20 6c74 7269 2e72 6573 6861  eturn ltri.resha
+0001d780: 7065 2828 6e76 6572 742d 322c 2033 2929  pe((nvert-2, 3))
+0001d790: 0a0a 0a64 6566 2076 6967 6e65 7474 696e  ...def vignettin
+0001d7a0: 6728 0a20 2020 2064 6f75 626c 655b 3a2c  g(.    double[:,
+0001d7b0: 203a 3a31 5d20 7261 795f 6f72 6967 2c0a   ::1] ray_orig,.
+0001d7c0: 2020 2020 646f 7562 6c65 5b3a 2c20 3a3a      double[:, ::
+0001d7d0: 315d 2072 6179 5f76 6469 722c 0a20 2020  1] ray_vdir,.   
+0001d7e0: 206c 6973 7420 7669 676e 6574 745f 706f   list vignett_po
+0001d7f0: 6c79 2c0a 2020 2020 6c6f 6e67 5b3a 3a31  ly,.    long[::1
+0001d800: 5d20 6c6e 7665 7274 2c0a 2020 2020 696e  ] lnvert,.    in
+0001d810: 7420 6e75 6d5f 7468 7265 6164 733d 3136  t num_threads=16
+0001d820: 2c0a 293a 0a20 2020 2022 2222 0a20 2020  ,.):.    """.   
+0001d830: 2072 6179 5f6f 7269 6720 3a20 2833 2c20   ray_orig : (3, 
+0001d840: 6e6c 6f73 2920 646f 7562 6c65 2061 7272  nlos) double arr
+0001d850: 6179 0a20 2020 2020 2020 4c4f 5320 6f72  ay.       LOS or
+0001d860: 6967 696e 2070 6f69 6e74 7320 636f 6f72  igin points coor
+0001d870: 6469 6e61 7465 730a 2020 2020 7261 795f  dinates.    ray_
+0001d880: 7664 6972 203a 2028 332c 206e 6c6f 7329  vdir : (3, nlos)
+0001d890: 2064 6f75 626c 6520 6172 7261 790a 2020   double array.  
+0001d8a0: 2020 2020 204c 4f53 206e 6f72 6d61 6c69       LOS normali
+0001d8b0: 7a65 6420 6469 7265 6374 696f 6e20 7665  zed direction ve
+0001d8c0: 6374 6f72 0a20 2020 2076 6967 6e65 7474  ctor.    vignett
+0001d8d0: 5f70 6f6c 7920 3a20 286e 756d 5f76 6967  _poly : (num_vig
+0001d8e0: 6e2c 2033 2c20 6e75 6d5f 7665 7274 6578  n, 3, num_vertex
+0001d8f0: 2920 646f 7562 6c65 206c 6973 7420 6f66  ) double list of
+0001d900: 2061 7272 6179 730a 2020 2020 2020 2043   arrays.       C
+0001d910: 6f6f 7264 696e 6174 6573 206f 6620 7468  oordinates of th
+0001d920: 6520 7665 7274 6963 6573 206f 6620 7468  e vertices of th
+0001d930: 6520 506f 6c79 676f 6e20 6465 6669 6e69  e Polygon defini
+0001d940: 6e67 2074 6865 2033 4420 7669 676e 6574  ng the 3D vignet
+0001d950: 742e 0a20 2020 2020 2020 504f 4c59 2043  t..       POLY C
+0001d960: 4c4f 5345 440a 2020 2020 6c6e 7665 7274  LOSED.    lnvert
+0001d970: 203a 2028 6e75 6d5f 7669 676e 2920 6c6f   : (num_vign) lo
+0001d980: 6e67 2061 7272 6179 0a20 2020 2020 2020  ng array.       
+0001d990: 4e75 6d62 6572 206f 6620 7665 7274 6963  Number of vertic
+0001d9a0: 6573 2066 6f72 2065 6163 6820 7669 676e  es for each vign
+0001d9b0: 6574 7420 2877 6974 686f 7574 2063 6f75  ett (without cou
+0001d9c0: 6e74 696e 6720 7468 6520 7265 626f 756e  nting the reboun
+0001d9d0: 6429 0a20 2020 2052 6574 7572 6e73 0a20  d).    Returns. 
+0001d9e0: 2020 203d 3d3d 3d3d 3d0a 2020 2020 676f     ======.    go
+0001d9f0: 6573 5f74 6872 6f75 6768 3a20 286e 756d  es_through: (num
+0001da00: 5f76 6967 6e2c 206e 6c6f 7329 2062 6f6f  _vign, nlos) boo
+0001da10: 6c20 6172 7261 790a 2020 2020 2020 2049  l array.       I
+0001da20: 6e64 6963 6174 6573 2066 6f72 2065 6163  ndicates for eac
+0001da30: 6820 7669 676e 6574 7420 6966 2065 6163  h vignett if eac
+0001da40: 6820 4c4f 5320 7765 6e74 7320 7468 726f  h LOS wents thro
+0001da50: 7567 6820 6f72 206e 6f74 0a20 2020 2022  ugh or not.    "
+0001da60: 2222 0a20 2020 2063 6465 6620 696e 7420  "".    cdef int 
+0001da70: 6969 0a20 2020 2063 6465 6620 696e 7420  ii.    cdef int 
+0001da80: 6e76 6967 6e2c 206e 6c6f 730a 2020 2020  nvign, nlos.    
+0001da90: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+0001daa0: 6e70 2e75 696e 7438 5f74 2c6e 6469 6d3d  np.uint8_t,ndim=
+0001dab0: 312c 6361 7374 3d54 7275 655d 2067 6f65  1,cast=True] goe
+0001dac0: 735f 7468 726f 7567 680a 2020 2020 6364  s_through.    cd
+0001dad0: 6566 206c 6f6e 672a 2a20 6c74 7269 203d  ef long** ltri =
+0001dae0: 204e 554c 4c0a 2020 2020 6364 6566 2064   NULL.    cdef d
+0001daf0: 6f75 626c 652a 206c 626f 756e 6473 203d  ouble* lbounds =
+0001db00: 204e 554c 4c0a 2020 2020 6364 6566 2064   NULL.    cdef d
+0001db10: 6f75 626c 652a 2a20 6461 7461 203d 204e  ouble** data = N
+0001db20: 554c 4c0a 2020 2020 6364 6566 2062 696e  ULL.    cdef bin
+0001db30: 742a 2062 6f6f 6c5f 7265 7320 3d20 4e55  t* bool_res = NU
+0001db40: 4c4c 0a20 2020 2063 6465 6620 6e70 2e6e  LL.    cdef np.n
+0001db50: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+0001db60: 6469 6d3d 322c 206d 6f64 653d 2263 225d  dim=2, mode="c"]
+0001db70: 2074 656d 700a 2020 2020 2320 2d2d 2049   temp.    # -- I
+0001db80: 6e69 7469 616c 697a 6174 696f 6e20 2d2d  nitialization --
+0001db90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001dba0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001dbb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001dbc0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 206e  ----------.    n
-0001dbd0: 7669 676e 203d 206c 656e 2876 6967 6e65  vign = len(vigne
-0001dbe0: 7474 5f70 6f6c 7929 0a20 2020 206e 6c6f  tt_poly).    nlo
-0001dbf0: 7320 3d20 7261 795f 6f72 6967 2e73 6861  s = ray_orig.sha
-0001dc00: 7065 5b31 5d0a 2020 2020 676f 6573 5f74  pe[1].    goes_t
-0001dc10: 6872 6f75 6768 203d 206e 702e 656d 7074  hrough = np.empt
-0001dc20: 7928 286e 6c6f 732a 6e76 6967 6e29 2c64  y((nlos*nvign),d
-0001dc30: 7479 7065 3d62 6f6f 6c29 0a20 2020 2023  type=bool).    #
-0001dc40: 2072 6520 7772 6974 7469 6e67 2076 6967   re writting vig
-0001dc50: 6e65 7474 5f70 6f6c 7920 746f 2043 2074  nett_poly to C t
-0001dc60: 7970 653a 0a20 2020 2064 6174 6120 3d20  ype:.    data = 
-0001dc70: 3c64 6f75 626c 6520 2a2a 3e20 6d61 6c6c  <double **> mall
-0001dc80: 6f63 286e 7669 676e 2a73 697a 656f 6628  oc(nvign*sizeof(
-0001dc90: 646f 7562 6c65 202a 2929 0a20 2020 2066  double *)).    f
-0001dca0: 6f72 2069 6920 696e 2072 616e 6765 286e  or ii in range(n
-0001dcb0: 7669 676e 293a 0a20 2020 2020 2020 2074  vign):.        t
-0001dcc0: 656d 7020 3d20 7669 676e 6574 745f 706f  emp = vignett_po
-0001dcd0: 6c79 5b69 695d 0a20 2020 2020 2020 2064  ly[ii].        d
-0001dce0: 6174 615b 6969 5d20 3d20 2674 656d 705b  ata[ii] = &temp[
-0001dcf0: 302c 305d 0a20 2020 2023 202d 2d20 5072  0,0].    # -- Pr
-0001dd00: 6570 6172 6174 696f 6e20 2d2d 2d2d 2d2d  eparation ------
+0001dbc0: 2d2d 2d2d 2d2d 0a20 2020 206e 7669 676e  ------.    nvign
+0001dbd0: 203d 206c 656e 2876 6967 6e65 7474 5f70   = len(vignett_p
+0001dbe0: 6f6c 7929 0a20 2020 206e 6c6f 7320 3d20  oly).    nlos = 
+0001dbf0: 7261 795f 6f72 6967 2e73 6861 7065 5b31  ray_orig.shape[1
+0001dc00: 5d0a 2020 2020 676f 6573 5f74 6872 6f75  ].    goes_throu
+0001dc10: 6768 203d 206e 702e 656d 7074 7928 286e  gh = np.empty((n
+0001dc20: 6c6f 732a 6e76 6967 6e29 2c64 7479 7065  los*nvign),dtype
+0001dc30: 3d62 6f6f 6c29 0a20 2020 2023 2072 6520  =bool).    # re 
+0001dc40: 7772 6974 7469 6e67 2076 6967 6e65 7474  writting vignett
+0001dc50: 5f70 6f6c 7920 746f 2043 2074 7970 653a  _poly to C type:
+0001dc60: 0a20 2020 2064 6174 6120 3d20 3c64 6f75  .    data = <dou
+0001dc70: 626c 6520 2a2a 3e20 6d61 6c6c 6f63 286e  ble **> malloc(n
+0001dc80: 7669 676e 2a73 697a 656f 6628 646f 7562  vign*sizeof(doub
+0001dc90: 6c65 202a 2929 0a20 2020 2066 6f72 2069  le *)).    for i
+0001dca0: 6920 696e 2072 616e 6765 286e 7669 676e  i in range(nvign
+0001dcb0: 293a 0a20 2020 2020 2020 2074 656d 7020  ):.        temp 
+0001dcc0: 3d20 7669 676e 6574 745f 706f 6c79 5b69  = vignett_poly[i
+0001dcd0: 695d 0a20 2020 2020 2020 2064 6174 615b  i].        data[
+0001dce0: 6969 5d20 3d20 2674 656d 705b 302c 305d  ii] = &temp[0,0]
+0001dcf0: 0a20 2020 2023 202d 2d20 5072 6570 6172  .    # -- Prepar
+0001dd00: 6174 696f 6e20 2d2d 2d2d 2d2d 2d2d 2d2d  ation ----------
 0001dd10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001dd20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001dd30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001dd40: 2d2d 2d2d 2d0a 2020 2020 6c62 6f75 6e64  -----.    lbound
-0001dd50: 7320 3d20 3c64 6f75 626c 652a 3e6d 616c  s = <double*>mal
-0001dd60: 6c6f 6328 7369 7a65 6f66 2864 6f75 626c  loc(sizeof(doubl
-0001dd70: 6529 202a 2036 202a 206e 7669 676e 290a  e) * 6 * nvign).
-0001dd80: 2020 2020 5f72 742e 636f 6d70 7574 655f      _rt.compute_
-0001dd90: 3364 5f62 626f 7865 7328 6461 7461 2c20  3d_bboxes(data, 
-0001dda0: 266c 6e76 6572 745b 305d 2c20 6e76 6967  &lnvert[0], nvig
-0001ddb0: 6e2c 2026 6c62 6f75 6e64 735b 305d 2c0a  n, &lbounds[0],.
+0001dd40: 2d0a 2020 2020 6c62 6f75 6e64 7320 3d20  -.    lbounds = 
+0001dd50: 3c64 6f75 626c 652a 3e6d 616c 6c6f 6328  <double*>malloc(
+0001dd60: 7369 7a65 6f66 2864 6f75 626c 6529 202a  sizeof(double) *
+0001dd70: 2036 202a 206e 7669 676e 290a 2020 2020   6 * nvign).    
+0001dd80: 5f72 742e 636f 6d70 7574 655f 3364 5f62  _rt.compute_3d_b
+0001dd90: 626f 7865 7328 6461 7461 2c20 266c 6e76  boxes(data, &lnv
+0001dda0: 6572 745b 305d 2c20 6e76 6967 6e2c 2026  ert[0], nvign, &
+0001ddb0: 6c62 6f75 6e64 735b 305d 2c0a 2020 2020  lbounds[0],.    
 0001ddc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ddd0: 2020 2020 2020 2020 2020 6e75 6d5f 7468            num_th
-0001dde0: 7265 6164 733d 6e75 6d5f 7468 7265 6164  reads=num_thread
-0001ddf0: 7329 0a20 2020 206c 7472 6920 3d20 3c6c  s).    ltri = <l
-0001de00: 6f6e 672a 2a3e 6d61 6c6c 6f63 2873 697a  ong**>malloc(siz
-0001de10: 656f 6628 6c6f 6e67 2a29 2a6e 7669 676e  eof(long*)*nvign
-0001de20: 290a 2020 2020 5f76 742e 7472 6961 6e67  ).    _vt.triang
-0001de30: 756c 6174 655f 706f 6c79 7328 6461 7461  ulate_polys(data
-0001de40: 2c20 266c 6e76 6572 745b 305d 2c20 6e76  , &lnvert[0], nv
-0001de50: 6967 6e2c 206c 7472 692c 0a20 2020 2020  ign, ltri,.     
+0001ddd0: 2020 2020 2020 6e75 6d5f 7468 7265 6164        num_thread
+0001dde0: 733d 6e75 6d5f 7468 7265 6164 7329 0a20  s=num_threads). 
+0001ddf0: 2020 206c 7472 6920 3d20 3c6c 6f6e 672a     ltri = <long*
+0001de00: 2a3e 6d61 6c6c 6f63 2873 697a 656f 6628  *>malloc(sizeof(
+0001de10: 6c6f 6e67 2a29 2a6e 7669 676e 290a 2020  long*)*nvign).  
+0001de20: 2020 5f76 742e 7472 6961 6e67 756c 6174    _vt.triangulat
+0001de30: 655f 706f 6c79 7328 6461 7461 2c20 266c  e_polys(data, &l
+0001de40: 6e76 6572 745b 305d 2c20 6e76 6967 6e2c  nvert[0], nvign,
+0001de50: 206c 7472 692c 0a20 2020 2020 2020 2020   ltri,.         
 0001de60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001de70: 2020 2020 206e 756d 5f74 6872 6561 6473       num_threads
-0001de80: 290a 2020 2020 2320 2d2d 2057 6520 6361  ).    # -- We ca
-0001de90: 6c6c 2063 6f72 6520 6675 6e63 7469 6f6e  ll core function
-0001dea0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+0001de70: 206e 756d 5f74 6872 6561 6473 290a 2020   num_threads).  
+0001de80: 2020 2320 2d2d 2057 6520 6361 6c6c 2063    # -- We call c
+0001de90: 6f72 6520 6675 6e63 7469 6f6e 202d 2d2d  ore function ---
+0001dea0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001deb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001dec0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001ded0: 2d2d 0a20 2020 2062 6f6f 6c5f 7265 7320  --.    bool_res 
-0001dee0: 3d20 3c62 696e 742a 3e6d 616c 6c6f 6328  = <bint*>malloc(
-0001def0: 6e6c 6f73 2a6e 7669 676e 2a73 697a 656f  nlos*nvign*sizeo
-0001df00: 6628 6269 6e74 2929 0a20 2020 205f 7674  f(bint)).    _vt
-0001df10: 2e76 6967 6e65 7474 696e 675f 636f 7265  .vignetting_core
-0001df20: 2872 6179 5f6f 7269 672c 2072 6179 5f76  (ray_orig, ray_v
-0001df30: 6469 722c 2064 6174 612c 2026 6c6e 7665  dir, data, &lnve
-0001df40: 7274 5b30 5d2c 2026 6c62 6f75 6e64 735b  rt[0], &lbounds[
-0001df50: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
-0001df60: 2020 2020 2020 2020 2020 2020 6c74 7269              ltri
-0001df70: 2c20 6e76 6967 6e2c 206e 6c6f 732c 2026  , nvign, nlos, &
-0001df80: 626f 6f6c 5f72 6573 5b30 5d2c 6e75 6d5f  bool_res[0],num_
-0001df90: 7468 7265 6164 7329 0a20 2020 2066 6f72  threads).    for
-0001dfa0: 2069 6920 696e 2072 616e 6765 286e 6c6f   ii in range(nlo
-0001dfb0: 732a 6e76 6967 6e29 3a0a 2020 2020 2020  s*nvign):.      
-0001dfc0: 2020 676f 6573 5f74 6872 6f75 6768 5b69    goes_through[i
-0001dfd0: 695d 203d 2062 6f6f 6c5f 7265 735b 6969  i] = bool_res[ii
-0001dfe0: 5d0a 2020 2020 2320 2d2d 2043 6c65 616e  ].    # -- Clean
-0001dff0: 696e 6720 7570 202d 2d2d 2d2d 2d2d 2d2d  ing up ---------
+0001dec0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
+0001ded0: 2020 2062 6f6f 6c5f 7265 7320 3d20 3c62     bool_res = <b
+0001dee0: 696e 742a 3e6d 616c 6c6f 6328 6e6c 6f73  int*>malloc(nlos
+0001def0: 2a6e 7669 676e 2a73 697a 656f 6628 6269  *nvign*sizeof(bi
+0001df00: 6e74 2929 0a20 2020 205f 7674 2e76 6967  nt)).    _vt.vig
+0001df10: 6e65 7474 696e 675f 636f 7265 2872 6179  netting_core(ray
+0001df20: 5f6f 7269 672c 2072 6179 5f76 6469 722c  _orig, ray_vdir,
+0001df30: 2064 6174 612c 2026 6c6e 7665 7274 5b30   data, &lnvert[0
+0001df40: 5d2c 2026 6c62 6f75 6e64 735b 305d 2c0a  ], &lbounds[0],.
+0001df50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001df60: 2020 2020 2020 2020 6c74 7269 2c20 6e76          ltri, nv
+0001df70: 6967 6e2c 206e 6c6f 732c 2026 626f 6f6c  ign, nlos, &bool
+0001df80: 5f72 6573 5b30 5d2c 6e75 6d5f 7468 7265  _res[0],num_thre
+0001df90: 6164 7329 0a20 2020 2066 6f72 2069 6920  ads).    for ii 
+0001dfa0: 696e 2072 616e 6765 286e 6c6f 732a 6e76  in range(nlos*nv
+0001dfb0: 6967 6e29 3a0a 2020 2020 2020 2020 676f  ign):.        go
+0001dfc0: 6573 5f74 6872 6f75 6768 5b69 695d 203d  es_through[ii] =
+0001dfd0: 2062 6f6f 6c5f 7265 735b 6969 5d0a 2020   bool_res[ii].  
+0001dfe0: 2020 2320 2d2d 2043 6c65 616e 696e 6720    # -- Cleaning 
+0001dff0: 7570 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  up -------------
 0001e000: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001e010: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001e020: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001e030: 2d2d 0a20 2020 2066 7265 6528 626f 6f6c  --.    free(bool
-0001e040: 5f72 6573 290a 2020 2020 6672 6565 286c  _res).    free(l
-0001e050: 626f 756e 6473 290a 2020 2020 2320 5765  bounds).    # We
-0001e060: 2068 6176 6520 746f 2066 7265 6520 6561   have to free ea
-0001e070: 6368 2061 7272 6179 2066 6f72 2065 6163  ch array for eac
-0001e080: 6820 7669 676e 6574 743a 0a20 2020 2066  h vignett:.    f
-0001e090: 6f72 2069 6920 696e 2072 616e 6765 286e  or ii in range(n
-0001e0a0: 7669 676e 293a 0a20 2020 2020 2020 2066  vign):.        f
-0001e0b0: 7265 6528 6c74 7269 5b69 695d 290a 2020  ree(ltri[ii]).  
-0001e0c0: 2020 6672 6565 286c 7472 6929 2023 2061    free(ltri) # a
-0001e0d0: 6e64 206e 6f77 2077 6520 6361 6e20 6672  nd now we can fr
-0001e0e0: 6565 2074 6865 206d 6169 6e20 706f 696e  ee the main poin
-0001e0f0: 7465 720a 2020 2020 6672 6565 2864 6174  ter.    free(dat
-0001e100: 6129 0a20 2020 2072 6574 7572 6e20 676f  a).    return go
-0001e110: 6573 5f74 6872 6f75 6768 0a0a 0a23 203d  es_through...# =
+0001e020: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
+0001e030: 2020 2066 7265 6528 626f 6f6c 5f72 6573     free(bool_res
+0001e040: 290a 2020 2020 6672 6565 286c 626f 756e  ).    free(lboun
+0001e050: 6473 290a 2020 2020 2320 5765 2068 6176  ds).    # We hav
+0001e060: 6520 746f 2066 7265 6520 6561 6368 2061  e to free each a
+0001e070: 7272 6179 2066 6f72 2065 6163 6820 7669  rray for each vi
+0001e080: 676e 6574 743a 0a20 2020 2066 6f72 2069  gnett:.    for i
+0001e090: 6920 696e 2072 616e 6765 286e 7669 676e  i in range(nvign
+0001e0a0: 293a 0a20 2020 2020 2020 2066 7265 6528  ):.        free(
+0001e0b0: 6c74 7269 5b69 695d 290a 2020 2020 6672  ltri[ii]).    fr
+0001e0c0: 6565 286c 7472 6929 2023 2061 6e64 206e  ee(ltri) # and n
+0001e0d0: 6f77 2077 6520 6361 6e20 6672 6565 2074  ow we can free t
+0001e0e0: 6865 206d 6169 6e20 706f 696e 7465 720a  he main pointer.
+0001e0f0: 2020 2020 6672 6565 2864 6174 6129 0a20      free(data). 
+0001e100: 2020 2072 6574 7572 6e20 676f 6573 5f74     return goes_t
+0001e110: 6872 6f75 6768 0a0a 0a23 203d 3d3d 3d3d  hrough...# =====
 0001e120: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001e130: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001e140: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001e150: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001e160: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 230a  =============.#.
-0001e170: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-0001e180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e190: 2020 204c 4f53 2053 414d 504c 494e 470a     LOS SAMPLING.
-0001e1a0: 230a 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  #.# ============
+0001e160: 3d3d 3d3d 3d3d 3d3d 3d0a 230a 2320 2020  =========.#.#   
+0001e170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e180: 2020 2020 2020 2020 2020 2020 2020 204c                 L
+0001e190: 4f53 2053 414d 504c 494e 470a 230a 2320  OS SAMPLING.#.# 
+0001e1a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001e1b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001e1c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0001e1d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001e1e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0001e1f0: 3d3d 0a64 6566 204c 4f53 5f67 6574 5f73  ==.def LOS_get_s
-0001e200: 616d 706c 6528 696e 7420 6e6c 6f73 2c20  ample(int nlos, 
-0001e210: 644c 2c20 646f 7562 6c65 5b3a 2c3a 3a31  dL, double[:,::1
-0001e220: 5d20 6c6f 735f 6c69 6d73 2c20 7374 7220  ] los_lims, str 
-0001e230: 646d 6574 686f 643d 2761 6273 272c 0a20  dmethod='abs',. 
-0001e240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e250: 2020 7374 7220 6d65 7468 6f64 3d27 7375    str method='su
-0001e260: 6d27 2c20 6269 6e74 2054 6573 743d 5472  m', bint Test=Tr
-0001e270: 7565 2c20 696e 7420 6e75 6d5f 7468 7265  ue, int num_thre
-0001e280: 6164 733d 3136 293a 0a20 2020 2022 2222  ads=16):.    """
-0001e290: 0a20 2020 2052 6574 7572 6e20 7468 6520  .    Return the 
-0001e2a0: 7361 6d70 6c65 6420 6c69 6e65 2c20 7769  sampled line, wi
-0001e2b0: 7468 2074 6865 2073 7065 6369 6669 6564  th the specified
-0001e2c0: 206d 6574 686f 640a 2020 2020 2d20 2020   method.    -   
-0001e2d0: 2773 756d 2720 3a20 2020 2020 7265 7475  'sum' :     retu
-0001e2e0: 726e 204e 2073 6567 6d65 6e74 7320 6365  rn N segments ce
-0001e2f0: 6e74 6572 730a 2020 2020 2d20 2020 2773  nters.    -   's
-0001e300: 696d 7073 273a 2020 2020 7265 7475 726e  imps':    return
-0001e310: 204e 2b31 2065 6764 6573 2c20 4e20 6576   N+1 egdes, N ev
-0001e320: 656e 2028 666f 7220 7363 6970 792e 696e  en (for scipy.in
-0001e330: 7465 6772 6174 652e 7369 6d70 7329 0a20  tegrate.simps). 
-0001e340: 2020 202d 2020 2027 726f 6d62 2720 3a20     -   'romb' : 
-0001e350: 2020 2072 6574 7572 6e20 4e2b 3120 6564     return N+1 ed
-0001e360: 6765 732c 204e 2b31 203d 2032 2a2a 6b2b  ges, N+1 = 2**k+
-0001e370: 3120 2866 6f72 2073 6369 7079 2e69 6e74  1 (for scipy.int
-0001e380: 6567 7261 7465 2e72 6f6d 6229 0a20 2020  egrate.romb).   
-0001e390: 2020 2054 6865 2064 6d65 7468 6f64 2064     The dmethod d
-0001e3a0: 6566 696e 6573 2069 6620 7468 6520 6469  efines if the di
-0001e3b0: 7363 7265 7469 7a61 7469 6f6e 2073 7465  scretization ste
-0001e3c0: 7020 6769 7665 6e20 6973 2061 6273 6f6c  p given is absol
-0001e3d0: 7574 6520 2827 6162 7327 290a 2020 2020  ute ('abs').    
-0001e3e0: 2020 6f72 2072 656c 6174 6976 6520 2827    or relative ('
-0001e3f0: 7265 6c27 290a 2020 2020 5061 7261 6d73  rel').    Params
-0001e400: 0a20 2020 203d 3d3d 3d3d 3d0a 2020 2020  .    ======.    
-0001e410: 644c 3a20 646f 7562 6c65 206f 7220 6c69  dL: double or li
-0001e420: 7374 206f 6620 646f 7562 6c65 730a 2020  st of doubles.  
-0001e430: 2020 2020 2020 4966 2064 4c20 6973 2061        If dL is a
-0001e440: 2073 696e 676c 6520 646f 7562 6c65 3a20   single double: 
-0001e450: 6469 7363 7265 7469 7a61 7469 6f6e 2073  discretization s
-0001e460: 7465 7020 666f 7220 616c 6c20 4c4f 532e  tep for all LOS.
-0001e470: 0a20 2020 2020 2020 2045 6c73 6520 644c  .        Else dL
-0001e480: 2073 686f 756c 6420 6265 2061 206c 6973   should be a lis
-0001e490: 7420 6f66 2073 697a 6520 6e6c 6f73 2077  t of size nlos w
-0001e4a0: 6974 6820 7468 6520 6469 7363 7265 7469  ith the discreti
-0001e4b0: 7a61 7469 6f6e 0a20 2020 2020 2020 2073  zation.        s
-0001e4c0: 7465 7020 666f 7220 6561 6368 206e 6c6f  tep for each nlo
-0001e4d0: 732e 0a20 2020 206c 6f73 5f6c 696d 733a  s..    los_lims:
-0001e4e0: 2028 322c 206e 6c6f 7329 2064 6f75 626c   (2, nlos) doubl
-0001e4f0: 6520 6172 7261 790a 2020 2020 2020 2020  e array.        
-0001e500: 466f 7220 6561 6368 206e 6c6f 732c 2069  For each nlos, i
-0001e510: 7420 6769 7665 6e20 7468 6520 6d61 7869  t given the maxi
-0001e520: 6d75 6d20 616e 6420 6d69 6e69 6d75 6d20  mum and minimum 
-0001e530: 6c69 6d69 7473 206f 6620 7468 6520 7261  limits of the ra
-0001e540: 790a 2020 2020 646d 6574 686f 643a 2073  y.    dmethod: s
-0001e550: 7472 696e 670a 2020 2020 2020 2020 7479  tring.        ty
-0001e560: 7065 206f 6620 6469 7363 7265 7469 7a61  pe of discretiza
-0001e570: 7469 6f6e 2073 7465 703a 2027 6162 7327  tion step: 'abs'
-0001e580: 2066 6f72 2061 6273 6f6c 7574 6520 6f72   for absolute or
-0001e590: 2027 7265 6c27 2066 6f72 2072 656c 6174   'rel' for relat
-0001e5a0: 6976 650a 2020 2020 6d65 7468 6f64 3a20  ive.    method: 
-0001e5b0: 7374 7269 6e67 0a20 2020 2020 2020 206d  string.        m
-0001e5c0: 6574 686f 6420 6f66 2071 7561 6472 6174  ethod of quadrat
-0001e5d0: 7572 6520 6f6e 2074 6865 204c 4f53 0a20  ure on the LOS. 
-0001e5e0: 2020 2054 6573 743a 2062 6f6f 6c0a 2020     Test: bool.  
-0001e5f0: 2020 2020 2020 746f 2069 6e64 6963 6174        to indicat
-0001e600: 6520 6966 2074 6573 7473 2073 686f 756c  e if tests shoul
-0001e610: 6420 6265 2064 6f6e 6520 6f72 206e 6f74  d be done or not
-0001e620: 0a0a 2020 2020 486f 7720 746f 2072 6563  ..    How to rec
-0001e630: 6f6d 7075 7465 2050 6f69 6e74 7320 636f  ompute Points co
-0001e640: 6f72 6469 6e61 7465 7320 6672 6f6d 2072  ordinates from r
-0001e650: 6573 756c 7473 0a20 2020 202d 2d2d 2d2d  esults.    -----
-0001e660: 2d2d 0a20 2020 206b 2c20 7265 732c 206c  --.    k, res, l
-0001e670: 696e 6420 3d20 4c6f 735f 6765 745f 7361  ind = Los_get_sa
-0001e680: 6d70 6c65 282e 2e2e 290a 2020 2020 6e62  mple(...).    nb
-0001e690: 7265 7065 7420 3d20 6e70 2e72 5f5b 6c69  repet = np.r_[li
-0001e6a0: 6e64 5b30 5d2c 206e 702e 6469 6666 286c  nd[0], np.diff(l
-0001e6b0: 696e 6429 2c20 6b2e 7369 7a65 202d 206c  ind), k.size - l
-0001e6c0: 696e 645b 2d31 5d5d 0a20 2020 206b 7573  ind[-1]].    kus
-0001e6d0: 203d 206b 202a 206e 702e 7265 7065 6174   = k * np.repeat
-0001e6e0: 2872 6179 5f76 6469 722c 206e 6272 6570  (ray_vdir, nbrep
-0001e6f0: 6574 2c20 6178 6973 3d31 290a 2020 2020  et, axis=1).    
-0001e700: 5074 7320 3d20 6e70 2e72 6570 6561 7428  Pts = np.repeat(
-0001e710: 7261 795f 6f72 6967 2c20 6e62 7265 7065  ray_orig, nbrepe
-0001e720: 742c 2061 7869 733d 3129 202b 206b 7573  t, axis=1) + kus
-0001e730: 0a20 2020 2022 2222 0a20 2020 2063 6465  .    """.    cde
-0001e740: 6620 7374 7220 6572 726f 725f 6d65 7373  f str error_mess
-0001e750: 6167 650a 2020 2020 6364 6566 2073 7472  age.    cdef str
-0001e760: 2064 6d6f 6465 203d 2064 6d65 7468 6f64   dmode = dmethod
-0001e770: 2e6c 6f77 6572 2829 0a20 2020 2063 6465  .lower().    cde
-0001e780: 6620 7374 7220 696d 6f64 6520 3d20 6d65  f str imode = me
-0001e790: 7468 6f64 2e6c 6f77 6572 2829 0a20 2020  thod.lower().   
-0001e7a0: 2063 6465 6620 696e 7420 737a 315f 646c   cdef int sz1_dl
-0001e7b0: 732c 2073 7a32 5f64 6c73 0a20 2020 2063  s, sz2_dls.    c
-0001e7c0: 6465 6620 696e 7420 737a 5f63 6f65 6666  def int sz_coeff
-0001e7d0: 0a20 2020 2063 6465 6620 696e 7420 6e5f  .    cdef int n_
-0001e7e0: 696d 6f64 652c 206e 5f64 6d6f 6465 0a20  imode, n_dmode. 
-0001e7f0: 2020 2063 6465 6620 6269 6e74 2064 6c5f     cdef bint dl_
-0001e800: 6973 5f6c 6973 740a 2020 2020 6364 6566  is_list.    cdef
-0001e810: 2062 696e 7420 626f 6f6c 312c 2062 6f6f   bint bool1, boo
-0001e820: 6c32 0a20 2020 2063 6465 6620 646f 7562  l2.    cdef doub
-0001e830: 6c65 5b3a 3a31 5d20 646c 5f76 6965 770a  le[::1] dl_view.
-0001e840: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-0001e850: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
-0001e860: 315d 2064 4c72 0a20 2020 2063 6465 6620  1] dLr.    cdef 
-0001e870: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0001e880: 652c 6e64 696d 3d31 5d20 636f 6566 665f  e,ndim=1] coeff_
-0001e890: 6172 720a 2020 2020 6364 6566 206e 702e  arr.    cdef np.
-0001e8a0: 6e64 6172 7261 795b 6c6f 6e67 2c6e 6469  ndarray[long,ndi
-0001e8b0: 6d3d 315d 206c 6f73 5f69 6e64 0a20 2020  m=1] los_ind.   
-0001e8c0: 2063 6465 6620 6c6f 6e67 2a20 746d 705f   cdef long* tmp_
-0001e8d0: 6172 720a 2020 2020 6364 6566 2064 6f75  arr.    cdef dou
-0001e8e0: 626c 652a 206c 6f73 5f63 6f65 6666 7320  ble* los_coeffs 
-0001e8f0: 3d20 4e55 4c4c 0a20 2020 2063 6465 6620  = NULL.    cdef 
-0001e900: 646f 7562 6c65 2a2a 2063 6f65 6666 5f70  double** coeff_p
-0001e910: 7472 203d 204e 554c 4c0a 2020 2020 6364  tr = NULL.    cd
-0001e920: 6566 206c 6f6e 672a 206c 6f73 5f69 6e64  ef long* los_ind
-0001e930: 5f70 7472 203d 204e 554c 4c0a 2020 2020  _ptr = NULL.    
-0001e940: 2320 2e2e 2072 6179 5f6f 7269 6720 7368  # .. ray_orig sh
-0001e950: 6170 6520 6e65 6564 6564 2066 6f72 2074  ape needed for t
-0001e960: 6573 7469 6e67 2061 6e64 2069 6e20 616c  esting and in al
-0001e970: 676f 202e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  go .............
-0001e980: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020  .............   
-0001e990: 2064 4c72 203d 206e 702e 7a65 726f 7328   dLr = np.zeros(
-0001e9a0: 286e 6c6f 732c 292c 2064 7479 7065 3d66  (nlos,), dtype=f
-0001e9b0: 6c6f 6174 290a 2020 2020 6c6f 735f 696e  loat).    los_in
-0001e9c0: 6420 3d20 6e70 2e7a 6572 6f73 2828 6e6c  d = np.zeros((nl
-0001e9d0: 6f73 2c29 2c20 6474 7970 653d 696e 7429  os,), dtype=int)
-0001e9e0: 0a20 2020 2064 6c5f 6973 5f6c 6973 7420  .    dl_is_list 
-0001e9f0: 3d20 6861 7361 7474 7228 644c 2c20 275f  = hasattr(dL, '_
-0001ea00: 5f69 7465 725f 5f27 290a 2020 2020 2320  _iter__').    # 
-0001ea10: 2e2e 2076 6572 6966 7969 6e67 2061 7267  .. verifying arg
-0001ea20: 756d 656e 7473 202e 2e2e 2e2e 2e2e 2e2e  uments .........
+0001e1e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a64  ==============.d
+0001e1f0: 6566 204c 4f53 5f67 6574 5f73 616d 706c  ef LOS_get_sampl
+0001e200: 6528 696e 7420 6e6c 6f73 2c20 644c 2c20  e(int nlos, dL, 
+0001e210: 646f 7562 6c65 5b3a 2c3a 3a31 5d20 6c6f  double[:,::1] lo
+0001e220: 735f 6c69 6d73 2c20 7374 7220 646d 6574  s_lims, str dmet
+0001e230: 686f 643d 2761 6273 272c 0a20 2020 2020  hod='abs',.     
+0001e240: 2020 2020 2020 2020 2020 2020 2020 7374                st
+0001e250: 7220 6d65 7468 6f64 3d27 7375 6d27 2c20  r method='sum', 
+0001e260: 6269 6e74 2054 6573 743d 5472 7565 2c20  bint Test=True, 
+0001e270: 696e 7420 6e75 6d5f 7468 7265 6164 733d  int num_threads=
+0001e280: 3136 293a 0a20 2020 2022 2222 0a20 2020  16):.    """.   
+0001e290: 2052 6574 7572 6e20 7468 6520 7361 6d70   Return the samp
+0001e2a0: 6c65 6420 6c69 6e65 2c20 7769 7468 2074  led line, with t
+0001e2b0: 6865 2073 7065 6369 6669 6564 206d 6574  he specified met
+0001e2c0: 686f 640a 2020 2020 2d20 2020 2773 756d  hod.    -   'sum
+0001e2d0: 2720 3a20 2020 2020 7265 7475 726e 204e  ' :     return N
+0001e2e0: 2073 6567 6d65 6e74 7320 6365 6e74 6572   segments center
+0001e2f0: 730a 2020 2020 2d20 2020 2773 696d 7073  s.    -   'simps
+0001e300: 273a 2020 2020 7265 7475 726e 204e 2b31  ':    return N+1
+0001e310: 2065 6764 6573 2c20 4e20 6576 656e 2028   egdes, N even (
+0001e320: 666f 7220 7363 6970 792e 696e 7465 6772  for scipy.integr
+0001e330: 6174 652e 7369 6d70 7329 0a20 2020 202d  ate.simps).    -
+0001e340: 2020 2027 726f 6d62 2720 3a20 2020 2072     'romb' :    r
+0001e350: 6574 7572 6e20 4e2b 3120 6564 6765 732c  eturn N+1 edges,
+0001e360: 204e 2b31 203d 2032 2a2a 6b2b 3120 2866   N+1 = 2**k+1 (f
+0001e370: 6f72 2073 6369 7079 2e69 6e74 6567 7261  or scipy.integra
+0001e380: 7465 2e72 6f6d 6229 0a20 2020 2020 2054  te.romb).      T
+0001e390: 6865 2064 6d65 7468 6f64 2064 6566 696e  he dmethod defin
+0001e3a0: 6573 2069 6620 7468 6520 6469 7363 7265  es if the discre
+0001e3b0: 7469 7a61 7469 6f6e 2073 7465 7020 6769  tization step gi
+0001e3c0: 7665 6e20 6973 2061 6273 6f6c 7574 6520  ven is absolute 
+0001e3d0: 2827 6162 7327 290a 2020 2020 2020 6f72  ('abs').      or
+0001e3e0: 2072 656c 6174 6976 6520 2827 7265 6c27   relative ('rel'
+0001e3f0: 290a 2020 2020 5061 7261 6d73 0a20 2020  ).    Params.   
+0001e400: 203d 3d3d 3d3d 3d0a 2020 2020 644c 3a20   ======.    dL: 
+0001e410: 646f 7562 6c65 206f 7220 6c69 7374 206f  double or list o
+0001e420: 6620 646f 7562 6c65 730a 2020 2020 2020  f doubles.      
+0001e430: 2020 4966 2064 4c20 6973 2061 2073 696e    If dL is a sin
+0001e440: 676c 6520 646f 7562 6c65 3a20 6469 7363  gle double: disc
+0001e450: 7265 7469 7a61 7469 6f6e 2073 7465 7020  retization step 
+0001e460: 666f 7220 616c 6c20 4c4f 532e 0a20 2020  for all LOS..   
+0001e470: 2020 2020 2045 6c73 6520 644c 2073 686f       Else dL sho
+0001e480: 756c 6420 6265 2061 206c 6973 7420 6f66  uld be a list of
+0001e490: 2073 697a 6520 6e6c 6f73 2077 6974 6820   size nlos with 
+0001e4a0: 7468 6520 6469 7363 7265 7469 7a61 7469  the discretizati
+0001e4b0: 6f6e 0a20 2020 2020 2020 2073 7465 7020  on.        step 
+0001e4c0: 666f 7220 6561 6368 206e 6c6f 732e 0a20  for each nlos.. 
+0001e4d0: 2020 206c 6f73 5f6c 696d 733a 2028 322c     los_lims: (2,
+0001e4e0: 206e 6c6f 7329 2064 6f75 626c 6520 6172   nlos) double ar
+0001e4f0: 7261 790a 2020 2020 2020 2020 466f 7220  ray.        For 
+0001e500: 6561 6368 206e 6c6f 732c 2069 7420 6769  each nlos, it gi
+0001e510: 7665 6e20 7468 6520 6d61 7869 6d75 6d20  ven the maximum 
+0001e520: 616e 6420 6d69 6e69 6d75 6d20 6c69 6d69  and minimum limi
+0001e530: 7473 206f 6620 7468 6520 7261 790a 2020  ts of the ray.  
+0001e540: 2020 646d 6574 686f 643a 2073 7472 696e    dmethod: strin
+0001e550: 670a 2020 2020 2020 2020 7479 7065 206f  g.        type o
+0001e560: 6620 6469 7363 7265 7469 7a61 7469 6f6e  f discretization
+0001e570: 2073 7465 703a 2027 6162 7327 2066 6f72   step: 'abs' for
+0001e580: 2061 6273 6f6c 7574 6520 6f72 2027 7265   absolute or 're
+0001e590: 6c27 2066 6f72 2072 656c 6174 6976 650a  l' for relative.
+0001e5a0: 2020 2020 6d65 7468 6f64 3a20 7374 7269      method: stri
+0001e5b0: 6e67 0a20 2020 2020 2020 206d 6574 686f  ng.        metho
+0001e5c0: 6420 6f66 2071 7561 6472 6174 7572 6520  d of quadrature 
+0001e5d0: 6f6e 2074 6865 204c 4f53 0a20 2020 2054  on the LOS.    T
+0001e5e0: 6573 743a 2062 6f6f 6c0a 2020 2020 2020  est: bool.      
+0001e5f0: 2020 746f 2069 6e64 6963 6174 6520 6966    to indicate if
+0001e600: 2074 6573 7473 2073 686f 756c 6420 6265   tests should be
+0001e610: 2064 6f6e 6520 6f72 206e 6f74 0a0a 2020   done or not..  
+0001e620: 2020 486f 7720 746f 2072 6563 6f6d 7075    How to recompu
+0001e630: 7465 2050 6f69 6e74 7320 636f 6f72 6469  te Points coordi
+0001e640: 6e61 7465 7320 6672 6f6d 2072 6573 756c  nates from resul
+0001e650: 7473 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ts.    -------. 
+0001e660: 2020 206b 2c20 7265 732c 206c 696e 6420     k, res, lind 
+0001e670: 3d20 4c6f 735f 6765 745f 7361 6d70 6c65  = Los_get_sample
+0001e680: 282e 2e2e 290a 2020 2020 6e62 7265 7065  (...).    nbrepe
+0001e690: 7420 3d20 6e70 2e72 5f5b 6c69 6e64 5b30  t = np.r_[lind[0
+0001e6a0: 5d2c 206e 702e 6469 6666 286c 696e 6429  ], np.diff(lind)
+0001e6b0: 2c20 6b2e 7369 7a65 202d 206c 696e 645b  , k.size - lind[
+0001e6c0: 2d31 5d5d 0a20 2020 206b 7573 203d 206b  -1]].    kus = k
+0001e6d0: 202a 206e 702e 7265 7065 6174 2872 6179   * np.repeat(ray
+0001e6e0: 5f76 6469 722c 206e 6272 6570 6574 2c20  _vdir, nbrepet, 
+0001e6f0: 6178 6973 3d31 290a 2020 2020 5074 7320  axis=1).    Pts 
+0001e700: 3d20 6e70 2e72 6570 6561 7428 7261 795f  = np.repeat(ray_
+0001e710: 6f72 6967 2c20 6e62 7265 7065 742c 2061  orig, nbrepet, a
+0001e720: 7869 733d 3129 202b 206b 7573 0a20 2020  xis=1) + kus.   
+0001e730: 2022 2222 0a20 2020 2063 6465 6620 7374   """.    cdef st
+0001e740: 7220 6572 726f 725f 6d65 7373 6167 650a  r error_message.
+0001e750: 2020 2020 6364 6566 2073 7472 2064 6d6f      cdef str dmo
+0001e760: 6465 203d 2064 6d65 7468 6f64 2e6c 6f77  de = dmethod.low
+0001e770: 6572 2829 0a20 2020 2063 6465 6620 7374  er().    cdef st
+0001e780: 7220 696d 6f64 6520 3d20 6d65 7468 6f64  r imode = method
+0001e790: 2e6c 6f77 6572 2829 0a20 2020 2063 6465  .lower().    cde
+0001e7a0: 6620 696e 7420 737a 315f 646c 732c 2073  f int sz1_dls, s
+0001e7b0: 7a32 5f64 6c73 0a20 2020 2063 6465 6620  z2_dls.    cdef 
+0001e7c0: 696e 7420 737a 5f63 6f65 6666 0a20 2020  int sz_coeff.   
+0001e7d0: 2063 6465 6620 696e 7420 6e5f 696d 6f64   cdef int n_imod
+0001e7e0: 652c 206e 5f64 6d6f 6465 0a20 2020 2063  e, n_dmode.    c
+0001e7f0: 6465 6620 6269 6e74 2064 6c5f 6973 5f6c  def bint dl_is_l
+0001e800: 6973 740a 2020 2020 6364 6566 2062 696e  ist.    cdef bin
+0001e810: 7420 626f 6f6c 312c 2062 6f6f 6c32 0a20  t bool1, bool2. 
+0001e820: 2020 2063 6465 6620 646f 7562 6c65 5b3a     cdef double[:
+0001e830: 3a31 5d20 646c 5f76 6965 770a 2020 2020  :1] dl_view.    
+0001e840: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+0001e850: 646f 7562 6c65 2c6e 6469 6d3d 315d 2064  double,ndim=1] d
+0001e860: 4c72 0a20 2020 2063 6465 6620 6e70 2e6e  Lr.    cdef np.n
+0001e870: 6461 7272 6179 5b64 6f75 626c 652c 6e64  darray[double,nd
+0001e880: 696d 3d31 5d20 636f 6566 665f 6172 720a  im=1] coeff_arr.
+0001e890: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+0001e8a0: 7261 795b 6c6f 6e67 2c6e 6469 6d3d 315d  ray[long,ndim=1]
+0001e8b0: 206c 6f73 5f69 6e64 0a20 2020 2063 6465   los_ind.    cde
+0001e8c0: 6620 6c6f 6e67 2a20 746d 705f 6172 720a  f long* tmp_arr.
+0001e8d0: 2020 2020 6364 6566 2064 6f75 626c 652a      cdef double*
+0001e8e0: 206c 6f73 5f63 6f65 6666 7320 3d20 4e55   los_coeffs = NU
+0001e8f0: 4c4c 0a20 2020 2063 6465 6620 646f 7562  LL.    cdef doub
+0001e900: 6c65 2a2a 2063 6f65 6666 5f70 7472 203d  le** coeff_ptr =
+0001e910: 204e 554c 4c0a 2020 2020 6364 6566 206c   NULL.    cdef l
+0001e920: 6f6e 672a 206c 6f73 5f69 6e64 5f70 7472  ong* los_ind_ptr
+0001e930: 203d 204e 554c 4c0a 2020 2020 2320 2e2e   = NULL.    # ..
+0001e940: 2072 6179 5f6f 7269 6720 7368 6170 6520   ray_orig shape 
+0001e950: 6e65 6564 6564 2066 6f72 2074 6573 7469  needed for testi
+0001e960: 6e67 2061 6e64 2069 6e20 616c 676f 202e  ng and in algo .
+0001e970: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
+0001e980: 2e2e 2e2e 2e2e 2e2e 0a20 2020 2064 4c72  .........    dLr
+0001e990: 203d 206e 702e 7a65 726f 7328 286e 6c6f   = np.zeros((nlo
+0001e9a0: 732c 292c 2064 7479 7065 3d66 6c6f 6174  s,), dtype=float
+0001e9b0: 290a 2020 2020 6c6f 735f 696e 6420 3d20  ).    los_ind = 
+0001e9c0: 6e70 2e7a 6572 6f73 2828 6e6c 6f73 2c29  np.zeros((nlos,)
+0001e9d0: 2c20 6474 7970 653d 696e 7429 0a20 2020  , dtype=int).   
+0001e9e0: 2064 6c5f 6973 5f6c 6973 7420 3d20 6861   dl_is_list = ha
+0001e9f0: 7361 7474 7228 644c 2c20 275f 5f69 7465  sattr(dL, '__ite
+0001ea00: 725f 5f27 290a 2020 2020 2320 2e2e 2076  r__').    # .. v
+0001ea10: 6572 6966 7969 6e67 2061 7267 756d 656e  erifying argumen
+0001ea20: 7473 202e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ts .............
 0001ea30: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 0001ea40: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-0001ea50: 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020 2069  ...........    i
-0001ea60: 6620 5465 7374 3a0a 2020 2020 2020 2020  f Test:.        
-0001ea70: 737a 315f 646c 7320 3d20 6c6f 735f 6c69  sz1_dls = los_li
-0001ea80: 6d73 2e73 6861 7065 5b30 5d0a 2020 2020  ms.shape[0].    
-0001ea90: 2020 2020 737a 325f 646c 7320 3d20 6c6f      sz2_dls = lo
-0001eaa0: 735f 6c69 6d73 2e73 6861 7065 5b31 5d0a  s_lims.shape[1].
-0001eab0: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
-0001eac0: 7a31 5f64 6c73 203d 3d20 322c 2022 4469  z1_dls == 2, "Di
-0001ead0: 6d20 3020 6f66 2061 7267 206c 6f73 5f6c  m 0 of arg los_l
-0001eae0: 696d 7320 7368 6f75 6c64 2062 6520 3222  ims should be 2"
-0001eaf0: 0a20 2020 2020 2020 2065 7272 6f72 5f6d  .        error_m
-0001eb00: 6573 7361 6765 203d 2022 4172 6773 206c  essage = "Args l
-0001eb10: 6f73 5f6c 696d 7320 7368 6f75 6c64 2068  os_lims should h
-0001eb20: 6176 6520 6469 6d20 3120 3d20 6e6c 6f73  ave dim 1 = nlos
-0001eb30: 220a 2020 2020 2020 2020 6173 7365 7274  ".        assert
-0001eb40: 206e 6c6f 7320 3d3d 2073 7a32 5f64 6c73   nlos == sz2_dls
-0001eb50: 2c20 6572 726f 725f 6d65 7373 6167 650a  , error_message.
-0001eb60: 2020 2020 2020 2020 626f 6f6c 3120 3d20          bool1 = 
-0001eb70: 6e6f 7420 646c 5f69 735f 6c69 7374 2061  not dl_is_list a
-0001eb80: 6e64 2064 4c20 3e20 302e 0a20 2020 2020  nd dL > 0..     
-0001eb90: 2020 2062 6f6f 6c32 203d 2064 6c5f 6973     bool2 = dl_is
-0001eba0: 5f6c 6973 7420 616e 6420 6c65 6e28 644c  _list and len(dL
-0001ebb0: 293d 3d6e 6c6f 7320 616e 6420 6e70 2e61  )==nlos and np.a
-0001ebc0: 6c6c 2864 4c3e 302e 290a 2020 2020 2020  ll(dL>0.).      
-0001ebd0: 2020 6173 7365 7274 2062 6f6f 6c31 206f    assert bool1 o
-0001ebe0: 7220 626f 6f6c 322c 2022 4172 6720 644c  r bool2, "Arg dL
-0001ebf0: 206d 7573 7420 6265 2061 2064 6f75 626c   must be a doubl
-0001ec00: 6520 6f72 2061 204c 6973 742c 2061 6e64  e or a List, and
-0001ec10: 2064 4c20 3e30 2e21 220a 2020 2020 2020   dL >0.!".      
-0001ec20: 2020 6572 726f 725f 6d65 7373 6167 6520    error_message 
-0001ec30: 3d20 2241 7267 756d 656e 7420 646d 6574  = "Argument dmet
-0001ec40: 686f 6420 2864 6973 6372 6574 697a 6174  hod (discretizat
-0001ec50: 696f 6e20 6d65 7468 6f64 2920 7368 6f75  ion method) shou
-0001ec60: 6c64 2062 6520 696e 225c 0a20 2020 2020  ld be in"\.     
-0001ec70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ec80: 2020 202b 2220 5b27 6162 7327 2c27 7265     +" ['abs','re
-0001ec90: 6c27 5d2c 2066 6f72 2061 6273 6f6c 7574  l'], for absolut
-0001eca0: 6520 6f72 2072 656c 6174 6976 652e 220a  e or relative.".
-0001ecb0: 2020 2020 2020 2020 6173 7365 7274 2064          assert d
-0001ecc0: 6d6f 6465 2069 6e20 5b27 6162 7327 2c27  mode in ['abs','
-0001ecd0: 7265 6c27 5d2c 2065 7272 6f72 5f6d 6573  rel'], error_mes
-0001ece0: 7361 6765 0a20 2020 2020 2020 2065 7272  sage.        err
-0001ecf0: 6f72 5f6d 6573 7361 6765 203d 2022 5772  or_message = "Wr
-0001ed00: 6f6e 6720 6d65 7468 6f64 206f 6620 696e  ong method of in
-0001ed10: 7465 6772 6174 696f 6e2e 2220 5c0a 2020  tegration." \.  
+0001ea50: 2e2e 2e2e 2e2e 0a20 2020 2069 6620 5465  .......    if Te
+0001ea60: 7374 3a0a 2020 2020 2020 2020 737a 315f  st:.        sz1_
+0001ea70: 646c 7320 3d20 6c6f 735f 6c69 6d73 2e73  dls = los_lims.s
+0001ea80: 6861 7065 5b30 5d0a 2020 2020 2020 2020  hape[0].        
+0001ea90: 737a 325f 646c 7320 3d20 6c6f 735f 6c69  sz2_dls = los_li
+0001eaa0: 6d73 2e73 6861 7065 5b31 5d0a 2020 2020  ms.shape[1].    
+0001eab0: 2020 2020 6173 7365 7274 2073 7a31 5f64      assert sz1_d
+0001eac0: 6c73 203d 3d20 322c 2022 4469 6d20 3020  ls == 2, "Dim 0 
+0001ead0: 6f66 2061 7267 206c 6f73 5f6c 696d 7320  of arg los_lims 
+0001eae0: 7368 6f75 6c64 2062 6520 3222 0a20 2020  should be 2".   
+0001eaf0: 2020 2020 2065 7272 6f72 5f6d 6573 7361       error_messa
+0001eb00: 6765 203d 2022 4172 6773 206c 6f73 5f6c  ge = "Args los_l
+0001eb10: 696d 7320 7368 6f75 6c64 2068 6176 6520  ims should have 
+0001eb20: 6469 6d20 3120 3d20 6e6c 6f73 220a 2020  dim 1 = nlos".  
+0001eb30: 2020 2020 2020 6173 7365 7274 206e 6c6f        assert nlo
+0001eb40: 7320 3d3d 2073 7a32 5f64 6c73 2c20 6572  s == sz2_dls, er
+0001eb50: 726f 725f 6d65 7373 6167 650a 2020 2020  ror_message.    
+0001eb60: 2020 2020 626f 6f6c 3120 3d20 6e6f 7420      bool1 = not 
+0001eb70: 646c 5f69 735f 6c69 7374 2061 6e64 2064  dl_is_list and d
+0001eb80: 4c20 3e20 302e 0a20 2020 2020 2020 2062  L > 0..        b
+0001eb90: 6f6f 6c32 203d 2064 6c5f 6973 5f6c 6973  ool2 = dl_is_lis
+0001eba0: 7420 616e 6420 6c65 6e28 644c 293d 3d6e  t and len(dL)==n
+0001ebb0: 6c6f 7320 616e 6420 6e70 2e61 6c6c 2864  los and np.all(d
+0001ebc0: 4c3e 302e 290a 2020 2020 2020 2020 6173  L>0.).        as
+0001ebd0: 7365 7274 2062 6f6f 6c31 206f 7220 626f  sert bool1 or bo
+0001ebe0: 6f6c 322c 2022 4172 6720 644c 206d 7573  ol2, "Arg dL mus
+0001ebf0: 7420 6265 2061 2064 6f75 626c 6520 6f72  t be a double or
+0001ec00: 2061 204c 6973 742c 2061 6e64 2064 4c20   a List, and dL 
+0001ec10: 3e30 2e21 220a 2020 2020 2020 2020 6572  >0.!".        er
+0001ec20: 726f 725f 6d65 7373 6167 6520 3d20 2241  ror_message = "A
+0001ec30: 7267 756d 656e 7420 646d 6574 686f 6420  rgument dmethod 
+0001ec40: 2864 6973 6372 6574 697a 6174 696f 6e20  (discretization 
+0001ec50: 6d65 7468 6f64 2920 7368 6f75 6c64 2062  method) should b
+0001ec60: 6520 696e 225c 0a20 2020 2020 2020 2020  e in"\.         
+0001ec70: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+0001ec80: 2220 5b27 6162 7327 2c27 7265 6c27 5d2c  " ['abs','rel'],
+0001ec90: 2066 6f72 2061 6273 6f6c 7574 6520 6f72   for absolute or
+0001eca0: 2072 656c 6174 6976 652e 220a 2020 2020   relative.".    
+0001ecb0: 2020 2020 6173 7365 7274 2064 6d6f 6465      assert dmode
+0001ecc0: 2069 6e20 5b27 6162 7327 2c27 7265 6c27   in ['abs','rel'
+0001ecd0: 5d2c 2065 7272 6f72 5f6d 6573 7361 6765  ], error_message
+0001ece0: 0a20 2020 2020 2020 2065 7272 6f72 5f6d  .        error_m
+0001ecf0: 6573 7361 6765 203d 2022 5772 6f6e 6720  essage = "Wrong 
+0001ed00: 6d65 7468 6f64 206f 6620 696e 7465 6772  method of integr
+0001ed10: 6174 696f 6e2e 2220 5c0a 2020 2020 2020  ation." \.      
 0001ed20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ed30: 2020 2020 2020 2b20 2220 4f70 7469 6f6e        + " Option
-0001ed40: 7320 6172 653a 205b 2773 756d 272c 2773  s are: ['sum','s
-0001ed50: 696d 7073 272c 2772 6f6d 6227 2c20 276c  imps','romb', 'l
-0001ed60: 696e 7370 6163 6527 5d22 0a20 2020 2020  inspace']".     
-0001ed70: 2020 2061 7373 6572 7420 696d 6f64 6520     assert imode 
-0001ed80: 696e 205b 2773 756d 272c 2773 696d 7073  in ['sum','simps
-0001ed90: 272c 2772 6f6d 6227 2c27 6c69 6e73 7061  ','romb','linspa
-0001eda0: 6365 275d 2c20 6572 726f 725f 6d65 7373  ce'], error_mess
-0001edb0: 6167 650a 2020 2020 2320 496e 6974 0a20  age.    # Init. 
-0001edc0: 2020 2063 6f65 6666 5f70 7472 203d 203c     coeff_ptr = <
-0001edd0: 646f 7562 6c65 2a2a 3e20 6d61 6c6c 6f63  double**> malloc
-0001ede0: 2873 697a 656f 6628 646f 7562 6c65 2a29  (sizeof(double*)
-0001edf0: 290a 2020 2020 6c6f 735f 696e 645f 7074  ).    los_ind_pt
-0001ee00: 7220 3d20 3c6c 6f6e 672a 3e20 6d61 6c6c  r = <long*> mall
-0001ee10: 6f63 286e 6c6f 732a 7369 7a65 6f66 286c  oc(nlos*sizeof(l
-0001ee20: 6f6e 6729 290a 2020 2020 636f 6566 665f  ong)).    coeff_
-0001ee30: 7074 725b 305d 203d 204e 554c 4c0a 2020  ptr[0] = NULL.  
-0001ee40: 2020 2320 4765 7474 696e 6720 6e75 6d62    # Getting numb
-0001ee50: 6572 206f 6620 6d6f 6465 733a 0a20 2020  er of modes:.   
-0001ee60: 206e 5f64 6d6f 6465 203d 205f 7374 2e67   n_dmode = _st.g
-0001ee70: 6574 5f6e 625f 646d 6f64 6528 646d 6f64  et_nb_dmode(dmod
-0001ee80: 6529 0a20 2020 206e 5f69 6d6f 6465 203d  e).    n_imode =
-0001ee90: 205f 7374 2e67 6574 5f6e 625f 696d 6f64   _st.get_nb_imod
-0001eea0: 6528 696d 6f64 6529 0a20 2020 2023 202d  e(imode).    # -
-0001eeb0: 2d20 436f 7265 2066 756e 6374 696f 6e73  - Core functions
-0001eec0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+0001ed30: 2020 2b20 2220 4f70 7469 6f6e 7320 6172    + " Options ar
+0001ed40: 653a 205b 2773 756d 272c 2773 696d 7073  e: ['sum','simps
+0001ed50: 272c 2772 6f6d 6227 2c20 276c 696e 7370  ','romb', 'linsp
+0001ed60: 6163 6527 5d22 0a20 2020 2020 2020 2061  ace']".        a
+0001ed70: 7373 6572 7420 696d 6f64 6520 696e 205b  ssert imode in [
+0001ed80: 2773 756d 272c 2773 696d 7073 272c 2772  'sum','simps','r
+0001ed90: 6f6d 6227 2c27 6c69 6e73 7061 6365 275d  omb','linspace']
+0001eda0: 2c20 6572 726f 725f 6d65 7373 6167 650a  , error_message.
+0001edb0: 2020 2020 2320 496e 6974 0a20 2020 2063      # Init.    c
+0001edc0: 6f65 6666 5f70 7472 203d 203c 646f 7562  oeff_ptr = <doub
+0001edd0: 6c65 2a2a 3e20 6d61 6c6c 6f63 2873 697a  le**> malloc(siz
+0001ede0: 656f 6628 646f 7562 6c65 2a29 290a 2020  eof(double*)).  
+0001edf0: 2020 6c6f 735f 696e 645f 7074 7220 3d20    los_ind_ptr = 
+0001ee00: 3c6c 6f6e 672a 3e20 6d61 6c6c 6f63 286e  <long*> malloc(n
+0001ee10: 6c6f 732a 7369 7a65 6f66 286c 6f6e 6729  los*sizeof(long)
+0001ee20: 290a 2020 2020 636f 6566 665f 7074 725b  ).    coeff_ptr[
+0001ee30: 305d 203d 204e 554c 4c0a 2020 2020 2320  0] = NULL.    # 
+0001ee40: 4765 7474 696e 6720 6e75 6d62 6572 206f  Getting number o
+0001ee50: 6620 6d6f 6465 733a 0a20 2020 206e 5f64  f modes:.    n_d
+0001ee60: 6d6f 6465 203d 205f 7374 2e67 6574 5f6e  mode = _st.get_n
+0001ee70: 625f 646d 6f64 6528 646d 6f64 6529 0a20  b_dmode(dmode). 
+0001ee80: 2020 206e 5f69 6d6f 6465 203d 205f 7374     n_imode = _st
+0001ee90: 2e67 6574 5f6e 625f 696d 6f64 6528 696d  .get_nb_imode(im
+0001eea0: 6f64 6529 0a20 2020 2023 202d 2d20 436f  ode).    # -- Co
+0001eeb0: 7265 2066 756e 6374 696f 6e73 202d 2d2d  re functions ---
+0001eec0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001eed0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001eee0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001eef0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 6966  ---------.    if
-0001ef00: 206e 6f74 2064 6c5f 6973 5f6c 6973 743a   not dl_is_list:
-0001ef10: 0a20 2020 2020 2020 2023 2043 6173 6520  .        # Case 
-0001ef20: 7769 7468 2075 6e69 7175 6520 6469 7363  with unique disc
-0001ef30: 7265 7469 7a61 7469 6f6e 2073 7465 7020  retization step 
-0001ef40: 644c 0a20 2020 2020 2020 2073 7a5f 636f  dL.        sz_co
-0001ef50: 6566 6620 3d20 5f73 742e 6c6f 735f 6765  eff = _st.los_ge
-0001ef60: 745f 7361 6d70 6c65 5f63 6f72 655f 636f  t_sample_core_co
-0001ef70: 6e73 745f 7265 7328 6e6c 6f73 2c0a 2020  nst_res(nlos,.  
+0001eef0: 2d2d 2d2d 2d0a 2020 2020 6966 206e 6f74  -----.    if not
+0001ef00: 2064 6c5f 6973 5f6c 6973 743a 0a20 2020   dl_is_list:.   
+0001ef10: 2020 2020 2023 2043 6173 6520 7769 7468       # Case with
+0001ef20: 2075 6e69 7175 6520 6469 7363 7265 7469   unique discreti
+0001ef30: 7a61 7469 6f6e 2073 7465 7020 644c 0a20  zation step dL. 
+0001ef40: 2020 2020 2020 2073 7a5f 636f 6566 6620         sz_coeff 
+0001ef50: 3d20 5f73 742e 6c6f 735f 6765 745f 7361  = _st.los_get_sa
+0001ef60: 6d70 6c65 5f63 6f72 655f 636f 6e73 745f  mple_core_const_
+0001ef70: 7265 7328 6e6c 6f73 2c0a 2020 2020 2020  res(nlos,.      
 0001ef80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001ef90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001efa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001efb0: 2020 2026 6c6f 735f 6c69 6d73 5b30 2c30     &los_lims[0,0
-0001efc0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001efa0: 2020 2020 2020 2020 2020 2020 2020 2026                 &
+0001efb0: 6c6f 735f 6c69 6d73 5b30 2c30 5d2c 0a20  los_lims[0,0],. 
+0001efc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001efd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001efe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eff0: 2020 2020 2020 2020 266c 6f73 5f6c 696d          &los_lim
-0001f000: 735b 312c 305d 2c0a 2020 2020 2020 2020  s[1,0],.        
+0001eff0: 2020 2020 266c 6f73 5f6c 696d 735b 312c      &los_lims[1,
+0001f000: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
 0001f010: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f030: 2020 2020 2020 2020 2020 2020 206e 5f64               n_d
-0001f040: 6d6f 6465 2c20 6e5f 696d 6f64 652c 0a20  mode, n_imode,. 
+0001f030: 2020 2020 2020 2020 206e 5f64 6d6f 6465           n_dmode
+0001f040: 2c20 6e5f 696d 6f64 652c 0a20 2020 2020  , n_imode,.     
 0001f050: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f060: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f080: 2020 2020 3c64 6f75 626c 653e 644c 2c0a      <double>dL,.
+0001f080: 3c64 6f75 626c 653e 644c 2c0a 2020 2020  <double>dL,.    
 0001f090: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f0c0: 2020 2020 2026 636f 6566 665f 7074 725b       &coeff_ptr[
-0001f0d0: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+0001f0c0: 2026 636f 6566 665f 7074 725b 305d 2c0a   &coeff_ptr[0],.
+0001f0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f100: 2020 2020 2020 2020 2026 644c 725b 305d           &dLr[0]
-0001f110: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001f100: 2020 2020 2026 644c 725b 305d 2c0a 2020       &dLr[0],.  
+0001f110: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f120: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f140: 2020 2020 2020 2026 6c6f 735f 696e 645f         &los_ind_
-0001f150: 7074 725b 305d 2c0a 2020 2020 2020 2020  ptr[0],.        
+0001f140: 2020 2026 6c6f 735f 696e 645f 7074 725b     &los_ind_ptr[
+0001f150: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
 0001f160: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f180: 2020 2020 2020 2020 2020 2020 206e 756d               num
-0001f190: 5f74 6872 6561 6473 290a 2020 2020 656c  _threads).    el
-0001f1a0: 7365 3a0a 2020 2020 2020 2020 2320 4361  se:.        # Ca
-0001f1b0: 7365 2077 6974 6820 6469 6666 6572 656e  se with differen
-0001f1c0: 7420 7265 736f 6c75 7469 6f6e 2066 6f72  t resolution for
-0001f1d0: 2065 6163 6820 4c4f 530a 2020 2020 2020   each LOS.      
-0001f1e0: 2020 646c 5f76 6965 773d 644c 0a20 2020    dl_view=dL.   
-0001f1f0: 2020 2020 205f 7374 2e6c 6f73 5f67 6574       _st.los_get
-0001f200: 5f73 616d 706c 655f 636f 7265 5f76 6172  _sample_core_var
-0001f210: 5f72 6573 286e 6c6f 732c 0a20 2020 2020  _res(nlos,.     
+0001f180: 2020 2020 2020 2020 206e 756d 5f74 6872           num_thr
+0001f190: 6561 6473 290a 2020 2020 656c 7365 3a0a  eads).    else:.
+0001f1a0: 2020 2020 2020 2020 2320 4361 7365 2077          # Case w
+0001f1b0: 6974 6820 6469 6666 6572 656e 7420 7265  ith different re
+0001f1c0: 736f 6c75 7469 6f6e 2066 6f72 2065 6163  solution for eac
+0001f1d0: 6820 4c4f 530a 2020 2020 2020 2020 646c  h LOS.        dl
+0001f1e0: 5f76 6965 773d 644c 0a20 2020 2020 2020  _view=dL.       
+0001f1f0: 205f 7374 2e6c 6f73 5f67 6574 5f73 616d   _st.los_get_sam
+0001f200: 706c 655f 636f 7265 5f76 6172 5f72 6573  ple_core_var_res
+0001f210: 286e 6c6f 732c 0a20 2020 2020 2020 2020  (nlos,.         
 0001f220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f240: 2020 2026 6c6f 735f 6c69 6d73 5b30 2c30     &los_lims[0,0
-0001f250: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001f230: 2020 2020 2020 2020 2020 2020 2020 2026                 &
+0001f240: 6c6f 735f 6c69 6d73 5b30 2c30 5d2c 0a20  los_lims[0,0],. 
+0001f250: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f270: 2020 2020 2020 2020 2020 2026 6c6f 735f             &los_
-0001f280: 6c69 6d73 5b31 2c30 5d2c 0a20 2020 2020  lims[1,0],.     
+0001f270: 2020 2020 2020 2026 6c6f 735f 6c69 6d73         &los_lims
+0001f280: 5b31 2c30 5d2c 0a20 2020 2020 2020 2020  [1,0],.         
 0001f290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f2b0: 2020 206e 5f64 6d6f 6465 2c20 6e5f 696d     n_dmode, n_im
-0001f2c0: 6f64 652c 0a20 2020 2020 2020 2020 2020  ode,.           
+0001f2a0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0001f2b0: 5f64 6d6f 6465 2c20 6e5f 696d 6f64 652c  _dmode, n_imode,
+0001f2c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0001f2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f2e0: 2020 2020 2020 2020 2020 2020 2026 646c               &dl
-0001f2f0: 5f76 6965 775b 305d 2c0a 2020 2020 2020  _view[0],.      
+0001f2e0: 2020 2020 2020 2020 2026 646c 5f76 6965           &dl_vie
+0001f2f0: 775b 305d 2c0a 2020 2020 2020 2020 2020  w[0],.          
 0001f300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f320: 2020 2663 6f65 6666 5f70 7472 5b30 5d2c    &coeff_ptr[0],
-0001f330: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001f310: 2020 2020 2020 2020 2020 2020 2020 2663                &c
+0001f320: 6f65 6666 5f70 7472 5b30 5d2c 0a20 2020  oeff_ptr[0],.   
+0001f330: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f350: 2020 2020 2020 2020 2026 644c 725b 305d           &dLr[0]
-0001f360: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001f350: 2020 2020 2026 644c 725b 305d 2c0a 2020       &dLr[0],.  
+0001f360: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001f370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f380: 2020 2020 2020 2020 2020 266c 6f73 5f69            &los_i
-0001f390: 6e64 5f70 7472 5b30 5d2c 0a20 2020 2020  nd_ptr[0],.     
+0001f380: 2020 2020 2020 266c 6f73 5f69 6e64 5f70        &los_ind_p
+0001f390: 7472 5b30 5d2c 0a20 2020 2020 2020 2020  tr[0],.         
 0001f3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f3c0: 2020 206e 756d 5f74 6872 6561 6473 290a     num_threads).
-0001f3d0: 2020 2020 2020 2020 737a 5f63 6f65 6666          sz_coeff
-0001f3e0: 203d 206c 6f73 5f69 6e64 5f70 7472 5b6e   = los_ind_ptr[n
-0001f3f0: 6c6f 732d 315d 0a20 2020 2063 6f65 6666  los-1].    coeff
-0001f400: 7320 203d 206e 702e 636f 7079 286e 702e  s  = np.copy(np.
-0001f410: 6173 6172 7261 7928 3c64 6f75 626c 655b  asarray(<double[
-0001f420: 3a73 7a5f 636f 6566 665d 3e63 6f65 6666  :sz_coeff]>coeff
-0001f430: 5f70 7472 5b30 5d29 290a 2020 2020 696e  _ptr[0])).    in
-0001f440: 6469 6365 7320 3d20 6e70 2e63 6f70 7928  dices = np.copy(
-0001f450: 6e70 2e61 7361 7272 6179 283c 6c6f 6e67  np.asarray(<long
-0001f460: 5b3a 6e6c 6f73 5d3e 6c6f 735f 696e 645f  [:nlos]>los_ind_
-0001f470: 7074 7229 2e61 7374 7970 6528 696e 7429  ptr).astype(int)
-0001f480: 290a 2020 2020 2320 2d2d 2066 7265 6569  ).    # -- freei
-0001f490: 6e67 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ng -------------
+0001f3b0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0001f3c0: 756d 5f74 6872 6561 6473 290a 2020 2020  um_threads).    
+0001f3d0: 2020 2020 737a 5f63 6f65 6666 203d 206c      sz_coeff = l
+0001f3e0: 6f73 5f69 6e64 5f70 7472 5b6e 6c6f 732d  os_ind_ptr[nlos-
+0001f3f0: 315d 0a20 2020 2063 6f65 6666 7320 203d  1].    coeffs  =
+0001f400: 206e 702e 636f 7079 286e 702e 6173 6172   np.copy(np.asar
+0001f410: 7261 7928 3c64 6f75 626c 655b 3a73 7a5f  ray(<double[:sz_
+0001f420: 636f 6566 665d 3e63 6f65 6666 5f70 7472  coeff]>coeff_ptr
+0001f430: 5b30 5d29 290a 2020 2020 696e 6469 6365  [0])).    indice
+0001f440: 7320 3d20 6e70 2e63 6f70 7928 6e70 2e61  s = np.copy(np.a
+0001f450: 7361 7272 6179 283c 6c6f 6e67 5b3a 6e6c  sarray(<long[:nl
+0001f460: 6f73 5d3e 6c6f 735f 696e 645f 7074 7229  os]>los_ind_ptr)
+0001f470: 2e61 7374 7970 6528 696e 7429 290a 2020  .astype(int)).  
+0001f480: 2020 2320 2d2d 2066 7265 6569 6e67 202d    # -- freeing -
+0001f490: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001f4a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 0001f4b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0001f4c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-0001f4d0: 2020 2069 6620 6e6f 7420 6c6f 735f 696e     if not los_in
-0001f4e0: 645f 7074 7220 3d3d 204e 554c 4c3a 0a20  d_ptr == NULL:. 
-0001f4f0: 2020 2020 2020 2066 7265 6528 6c6f 735f         free(los_
-0001f500: 696e 645f 7074 7229 0a20 2020 2069 6620  ind_ptr).    if 
-0001f510: 6e6f 7420 636f 6566 665f 7074 7220 3d3d  not coeff_ptr ==
-0001f520: 204e 554c 4c3a 0a20 2020 2020 2020 2069   NULL:.        i
-0001f530: 6620 6e6f 7420 636f 6566 665f 7074 725b  f not coeff_ptr[
-0001f540: 305d 203d 3d20 4e55 4c4c 3a0a 2020 2020  0] == NULL:.    
-0001f550: 2020 2020 2020 2020 6672 6565 2863 6f65          free(coe
-0001f560: 6666 5f70 7472 5b30 5d29 0a20 2020 2020  ff_ptr[0]).     
-0001f570: 2020 2066 7265 6528 636f 6566 665f 7074     free(coeff_pt
-0001f580: 7229 0a20 2020 2072 6574 7572 6e20 636f  r).    return co
-0001f590: 6566 6673 2c20 644c 722c 2069 6e64 6963  effs, dLr, indic
-0001f5a0: 6573 5b3a 6e6c 6f73 2d31 5d0a 0a0a 0a23  es[:nlos-1]....#
+0001f4c0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2069  ----------.    i
+0001f4d0: 6620 6e6f 7420 6c6f 735f 696e 645f 7074  f not los_ind_pt
+0001f4e0: 7220 3d3d 204e 554c 4c3a 0a20 2020 2020  r == NULL:.     
+0001f4f0: 2020 2066 7265 6528 6c6f 735f 696e 645f     free(los_ind_
+0001f500: 7074 7229 0a20 2020 2069 6620 6e6f 7420  ptr).    if not 
+0001f510: 636f 6566 665f 7074 7220 3d3d 204e 554c  coeff_ptr == NUL
+0001f520: 4c3a 0a20 2020 2020 2020 2069 6620 6e6f  L:.        if no
+0001f530: 7420 636f 6566 665f 7074 725b 305d 203d  t coeff_ptr[0] =
+0001f540: 3d20 4e55 4c4c 3a0a 2020 2020 2020 2020  = NULL:.        
+0001f550: 2020 2020 6672 6565 2863 6f65 6666 5f70      free(coeff_p
+0001f560: 7472 5b30 5d29 0a20 2020 2020 2020 2066  tr[0]).        f
+0001f570: 7265 6528 636f 6566 665f 7074 7229 0a20  ree(coeff_ptr). 
+0001f580: 2020 2072 6574 7572 6e20 636f 6566 6673     return coeffs
+0001f590: 2c20 644c 722c 2069 6e64 6963 6573 5b3a  , dLr, indices[:
+0001f5a0: 6e6c 6f73 2d31 5d0a 0a0a 0a23 2323 2323  nlos-1]....#####
 0001f5b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001f5c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001f5d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001f5e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f5f0: 2323 2323 230a 2320 2020 2020 2020 2020  #####.#         
-0001f600: 2020 2020 2020 5369 676e 616c 2063 616c        Signal cal
-0001f610: 6375 6c61 7469 6f6e 0a23 2323 2323 2323  culation.#######
+0001f5f0: 230a 2320 2020 2020 2020 2020 2020 2020  #.#             
+0001f600: 2020 5369 676e 616c 2063 616c 6375 6c61    Signal calcula
+0001f610: 7469 6f6e 0a23 2323 2323 2323 2323 2323  tion.###########
 0001f620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001f630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001f640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f650: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-0001f660: 0a64 6566 2069 6e74 6567 7261 7465 3164  .def integrate1d
-0001f670: 2879 2c20 646f 7562 6c65 2064 782c 2074  (y, double dx, t
-0001f680: 3d4e 6f6e 652c 2073 7472 206d 6574 686f  =None, str metho
-0001f690: 643d 2773 756d 2729 3a0a 2020 2020 2222  d='sum'):.    ""
-0001f6a0: 2220 4765 6e65 7269 6320 696e 7465 6772  " Generic integr
-0001f6b0: 6174 696f 6e20 6d65 7468 6f64 205b 2773  ation method ['s
-0001f6c0: 756d 272c 2773 696d 7073 272c 2772 6f6d  um','simps','rom
-0001f6d0: 6227 5d0a 0a20 2020 2020 2020 204e 6f74  b']..        Not
-0001f6e0: 2075 7365 6420 696e 7465 726e 616c 6c79   used internally
-0001f6f0: 0a20 2020 2020 2020 2055 7365 6675 6c20  .        Useful 
-0001f700: 7768 656e 2074 6865 2073 616d 706c 696e  when the samplin
-0001f710: 6720 706f 696e 7473 206e 6565 6420 746f  g points need to
-0001f720: 2062 6520 696e 7465 7270 6f6c 6174 6564   be interpolated
-0001f730: 2076 6961 2065 7175 696c 6962 7269 756d   via equilibrium
-0001f740: 0a20 2020 2022 2222 0a20 2020 2063 6465  .    """.    cde
-0001f750: 6620 756e 7369 676e 6564 2069 6e74 206e  f unsigned int n
-0001f760: 742c 2061 786d 0a20 2020 2069 6620 7420  t, axm.    if t 
-0001f770: 6973 204e 6f6e 6520 6f72 206e 6f74 2068  is None or not h
-0001f780: 6173 6174 7472 2874 2c27 5f5f 6974 6572  asattr(t,'__iter
-0001f790: 5f5f 2729 3a0a 2020 2020 2020 2020 6e74  __'):.        nt
-0001f7a0: 203d 2031 0a20 2020 2020 2020 2061 786d   = 1.        axm
-0001f7b0: 203d 2030 0a20 2020 2065 6c73 653a 0a20   = 0.    else:. 
-0001f7c0: 2020 2020 2020 206e 7420 3d20 6c65 6e28         nt = len(
-0001f7d0: 7429 0a20 2020 2020 2020 2061 786d 203d  t).        axm =
-0001f7e0: 2031 0a20 2020 2069 6e64 203d 206e 702e   1.    ind = np.
-0001f7f0: 6973 6e61 6e28 7929 0a20 2020 2069 6620  isnan(y).    if 
-0001f800: 6e70 2e61 6e79 2869 6e64 293a 0a20 2020  np.any(ind):.   
-0001f810: 2020 2020 2079 203d 2079 2e63 6f70 7928       y = y.copy(
-0001f820: 290a 2020 2020 2020 2020 795b 696e 645d  ).        y[ind]
-0001f830: 203d 2030 2e0a 0a20 2020 2063 6465 6620   = 0...    cdef 
-0001f840: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0001f850: 652c 6e64 696d 3d31 5d20 7320 3d20 6e70  e,ndim=1] s = np
-0001f860: 2e65 6d70 7479 2828 6e74 2c29 2c64 7479  .empty((nt,),dty
-0001f870: 7065 3d66 6c6f 6174 290a 0a20 2020 2069  pe=float)..    i
-0001f880: 6620 6d65 7468 6f64 3d3d 2773 756d 273a  f method=='sum':
-0001f890: 0a20 2020 2020 2020 2073 203d 206e 702e  .        s = np.
-0001f8a0: 7375 6d28 792c 2061 7869 733d 6178 6d29  sum(y, axis=axm)
-0001f8b0: 2a64 780a 2020 2020 656c 6966 206d 6574  *dx.    elif met
-0001f8c0: 686f 643d 3d27 7369 6d70 7327 3a0a 2020  hod=='simps':.  
-0001f8d0: 2020 2020 2020 7320 3d20 7363 7069 6e74        s = scpint
-0001f8e0: 672e 7369 6d70 7328 792c 2078 3d4e 6f6e  g.simps(y, x=Non
-0001f8f0: 652c 2064 783d 6478 2c20 6178 6973 3d61  e, dx=dx, axis=a
-0001f900: 786d 290a 2020 2020 656c 6966 206d 6574  xm).    elif met
-0001f910: 686f 643d 3d27 726f 6d62 273a 0a20 2020  hod=='romb':.   
-0001f920: 2020 2020 2073 203d 2073 6370 696e 7467       s = scpintg
-0001f930: 2e72 6f6d 6228 792c 2064 783d 6478 2c20  .romb(y, dx=dx, 
-0001f940: 6178 6973 3d61 786d 2c20 7368 6f77 3d46  axis=axm, show=F
-0001f950: 616c 7365 290a 2020 2020 656c 7365 3a0a  alse).    else:.
-0001f960: 2020 2020 2020 2020 7261 6973 6520 4578          raise Ex
-0001f970: 6365 7074 696f 6e28 2241 7267 206d 6574  ception("Arg met
-0001f980: 686f 6420 6d75 7374 2062 6520 696e 205b  hod must be in [
-0001f990: 2773 756d 272c 2773 696d 7073 272c 2772  'sum','simps','r
-0001f9a0: 6f6d 6227 5d22 290a 2020 2020 7265 7475  omb']").    retu
-0001f9b0: 726e 2073 0a0a 0a64 6566 204c 4f53 5f63  rn s...def LOS_c
-0001f9c0: 616c 635f 7369 676e 616c 2866 756e 632c  alc_signal(func,
-0001f9d0: 2064 6f75 626c 655b 3a2c 3a3a 315d 2072   double[:,::1] r
-0001f9e0: 6179 5f6f 7269 672c 2064 6f75 626c 655b  ay_orig, double[
-0001f9f0: 3a2c 3a3a 315d 2072 6179 5f76 6469 722c  :,::1] ray_vdir,
-0001fa00: 2072 6573 2c0a 2020 2020 2020 2020 2020   res,.          
-0001fa10: 2020 2020 2020 2020 2020 646f 7562 6c65            double
-0001fa20: 5b3a 2c3a 3a31 5d20 6c69 6d73 2c20 7374  [:,::1] lims, st
-0001fa30: 7220 646d 6574 686f 643d 2761 6273 272c  r dmethod='abs',
-0001fa40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001fa50: 2020 2020 2073 7472 206d 6574 686f 643d       str method=
-0001fa60: 2773 756d 272c 2062 696e 7420 616e 693d  'sum', bint ani=
-0001fa70: 4661 6c73 652c 0a20 2020 2020 2020 2020  False,.         
-0001fa80: 2020 2020 2020 2020 2020 2074 3d4e 6f6e             t=Non
-0001fa90: 652c 2066 6b77 6461 7267 733d 7b7d 2c20  e, fkwdargs={}, 
-0001faa0: 7374 7220 6d69 6e69 6d69 7a65 3d27 6361  str minimize='ca
-0001fab0: 6c6c 7327 2c0a 2020 2020 2020 2020 2020  lls',.          
-0001fac0: 2020 2020 2020 2020 2020 6269 6e74 2054            bint T
-0001fad0: 6573 743d 5472 7565 2c20 696e 7420 6e75  est=True, int nu
-0001fae0: 6d5f 7468 7265 6164 733d 3136 293a 0a20  m_threads=16):. 
-0001faf0: 2020 2022 2222 2043 6f6d 7075 7465 2074     """ Compute t
-0001fb00: 6865 2073 796e 7468 6574 6963 2073 6967  he synthetic sig
-0001fb10: 6e61 6c2c 206d 696e 696d 697a 696e 6720  nal, minimizing 
-0001fb20: 6569 7468 6572 2066 756e 6374 696f 6e20  either function 
-0001fb30: 6361 6c6c 7320 6f72 206d 656d 6f72 790a  calls or memory.
-0001fb40: 2020 2020 5061 7261 6d73 0a20 2020 203d      Params.    =
-0001fb50: 3d3d 3d3d 0a20 2020 2066 756e 6320 3a20  ====.    func : 
-0001fb60: 7079 7468 6f6e 2066 756e 6374 696f 6e20  python function 
-0001fb70: 7374 2e20 6675 6e63 2870 7473 2c20 743d  st. func(pts, t=
-0001fb80: 4e6f 6e65 2c20 7665 6374 3d4e 6f6e 6529  None, vect=None)
-0001fb90: 203d 3e20 6461 7461 0a20 2020 2020 2020   => data.       
-0001fba0: 2020 2020 7769 7468 2070 7473 203a 206e      with pts : n
-0001fbb0: 6461 7272 6179 2028 332c 206e 7074 7329  darray (3, npts)
-0001fbc0: 202d 2070 6f69 6e74 7320 7768 6572 6520   - points where 
-0001fbd0: 6675 6e63 7469 6f6e 2069 7320 6576 616c  function is eval
-0001fbe0: 7561 7465 640a 2020 2020 2020 2020 2020  uated.          
-0001fbf0: 2020 2020 2020 7665 6374 203a 206e 6461        vect : nda
-0001fc00: 7272 6179 2833 2c20 6e70 7473 2920 2d20  rray(3, npts) - 
-0001fc10: 6966 2061 6e69 736f 7472 6f70 6963 2073  if anisotropic s
-0001fc20: 6967 6e61 6c20 7665 6374 6f72 206f 6620  ignal vector of 
-0001fc30: 656d 6973 732e 0a20 2020 2020 2020 2020  emiss..         
-0001fc40: 2020 2020 2020 2074 3a20 6e64 6172 7261         t: ndarra
-0001fc50: 7928 6d29 202d 2074 696d 6573 2077 6865  y(m) - times whe
-0001fc60: 7265 2074 6f20 636f 6d70 7574 6520 7468  re to compute th
-0001fc70: 6520 6675 6e63 7469 6f6e 0a20 2020 2020  e function.     
-0001fc80: 2020 2020 2020 7265 7475 726e 733a 2064        returns: d
-0001fc90: 6174 6120 3a20 6e64 6172 7261 7928 6e74  ata : ndarray(nt
-0001fca0: 2c6e 7261 6629 2069 6620 6e74 203d 2031  ,nraf) if nt = 1
-0001fcb0: 2c20 7468 6520 6172 7261 7920 6d75 7374  , the array must
-0001fcc0: 2062 6520 3244 0a20 2020 2020 2020 2020   be 2D.         
-0001fcd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fce0: 2020 7661 6c75 6573 206f 6620 6675 6e63    values of func
-0001fcf0: 2061 7420 7074 732c 2061 7420 6769 7665   at pts, at give
-0001fd00: 6e20 7469 6d65 0a20 2020 2020 2020 2020  n time.         
-0001fd10: 2020 6675 6e63 2069 7320 7468 6520 6675    func is the fu
-0001fd20: 6e63 7469 6f6e 2074 6f20 6265 2069 6e74  nction to be int
-0001fd30: 6567 7261 7465 6420 616c 6f6e 6720 7468  egrated along th
-0001fd40: 6520 4c4f 530a 2020 2020 7261 795f 6f72  e LOS.    ray_or
-0001fd50: 6967 3a20 6e64 6172 7261 7920 2833 2c20  ig: ndarray (3, 
-0001fd60: 6e6c 6f73 2920 4c4f 5320 6f72 6967 696e  nlos) LOS origin
-0001fd70: 730a 2020 2020 7261 795f 7664 6972 3a20  s.    ray_vdir: 
-0001fd80: 6e64 6172 7261 7920 2833 2c20 6e6c 6f73  ndarray (3, nlos
-0001fd90: 2920 4c4f 5320 6469 7265 6374 696f 6e61  ) LOS directiona
-0001fda0: 6c20 7665 6374 6f72 0a20 2020 2072 6573  l vector.    res
-0001fdb0: 3a20 646f 7562 6c65 206f 7220 6c69 7374  : double or list
-0001fdc0: 206f 6620 646f 7562 6c65 730a 2020 2020   of doubles.    
-0001fdd0: 2020 2020 4966 2072 6573 2069 7320 6120      If res is a 
-0001fde0: 7369 6e67 6c65 2064 6f75 626c 653a 2064  single double: d
-0001fdf0: 6973 6372 6574 697a 6174 696f 6e20 7374  iscretization st
-0001fe00: 6570 2066 6f72 2061 6c6c 204c 4f53 2e0a  ep for all LOS..
-0001fe10: 2020 2020 2020 2020 456c 7365 2072 6573          Else res
-0001fe20: 2073 686f 756c 6420 6265 2061 206c 6973   should be a lis
-0001fe30: 7420 6f66 2073 697a 6520 6e6c 6f73 2077  t of size nlos w
-0001fe40: 6974 6820 7468 6520 6469 7363 7265 7469  ith the discreti
-0001fe50: 7a61 7469 6f6e 0a20 2020 2020 2020 2073  zation.        s
-0001fe60: 7465 7020 666f 7220 6561 6368 206e 6c6f  tep for each nlo
-0001fe70: 732e 0a20 2020 206c 696d 733a 2028 322c  s..    lims: (2,
-0001fe80: 206e 6c6f 7329 2064 6f75 626c 6520 6172   nlos) double ar
-0001fe90: 7261 790a 2020 2020 2020 2020 466f 7220  ray.        For 
-0001fea0: 6561 6368 206e 6c6f 732c 2069 7420 6769  each nlos, it gi
-0001feb0: 7665 6e20 7468 6520 6d61 7869 6d75 6d20  ven the maximum 
-0001fec0: 616e 6420 6d69 6e69 6d75 6d20 6c69 6d69  and minimum limi
-0001fed0: 7473 206f 6620 7468 6520 7261 790a 2020  ts of the ray.  
-0001fee0: 2020 646d 6574 686f 643a 2073 7472 696e    dmethod: strin
-0001fef0: 670a 2020 2020 2020 2020 7479 7065 206f  g.        type o
-0001ff00: 6620 6469 7363 7265 7469 7a61 7469 6f6e  f discretization
-0001ff10: 2073 7465 703a 2027 6162 7327 2066 6f72   step: 'abs' for
-0001ff20: 2061 6273 6f6c 7574 6520 6f72 2027 7265   absolute or 're
-0001ff30: 6c27 2066 6f72 2072 656c 6174 6976 650a  l' for relative.
-0001ff40: 2020 2020 6d65 7468 6f64 3a20 7374 7269      method: stri
-0001ff50: 6e67 0a20 2020 2020 2020 206d 6574 686f  ng.        metho
-0001ff60: 6420 6f66 2071 7561 6472 6174 7572 6520  d of quadrature 
-0001ff70: 6f6e 2074 6865 204c 4f53 0a20 2020 2061  on the LOS.    a
-0001ff80: 6e69 203a 2062 6f6f 6c0a 2020 2020 2020  ni : bool.      
-0001ff90: 2020 746f 2069 6e64 6963 6174 6520 6966    to indicate if
-0001ffa0: 2065 6d69 7373 696f 6e20 6973 2061 6e69   emission is ani
-0001ffb0: 736f 7472 6f70 6963 206f 7220 6e6f 740a  sotropic or not.
-0001ffc0: 2020 2020 7420 3a20 4e6f 6e65 206f 7220      t : None or 
-0001ffd0: 6172 7261 792d 6c69 6b65 0a20 2020 2020  array-like.     
-0001ffe0: 2020 2074 696d 6573 2077 6865 7265 2074     times where t
-0001fff0: 6f20 696e 7465 6772 6174 650a 2020 2020  o integrate.    
-00020000: 6d69 6e69 6d69 7a65 3a20 7374 7269 6e67  minimize: string
-00020010: 0a20 2020 2020 2020 2022 6361 6c6c 7322  .        "calls"
-00020020: 203a 2077 6520 7573 6520 616c 676f 7269   : we use algori
-00020030: 7468 6d20 746f 206d 696e 696d 697a 6520  thm to minimize 
-00020040: 7468 6520 6361 6c6c 7320 746f 2027 6675  the calls to 'fu
-00020050: 6e63 2720 2864 6566 6175 6c74 290a 2020  nc' (default).  
-00020060: 2020 2020 2020 226d 656d 6f72 7922 3a20        "memory": 
-00020070: 7765 2075 7365 2061 6c67 6f72 6974 686d  we use algorithm
-00020080: 2074 6f20 6d69 6e69 6d69 7a65 206d 656d   to minimize mem
-00020090: 6f72 7920 7573 6564 0a20 2020 2020 2020  ory used.       
-000200a0: 2022 6879 6272 6964 223a 2061 206d 6978   "hybrid": a mix
-000200b0: 206f 6620 626f 7468 206d 6574 686f 6473   of both methods
-000200c0: 0a20 2020 2054 6573 7420 3a20 626f 6f6c  .    Test : bool
-000200d0: 0a20 2020 2020 2020 2077 6520 7465 7374  .        we test
-000200e0: 2069 6620 7468 6520 696e 7075 7473 2061   if the inputs a
-000200f0: 7265 2067 6976 696e 6720 696e 2061 2070  re giving in a p
-00020100: 726f 7065 7220 7761 792e 0a20 2020 206e  roper way..    n
-00020110: 756d 5f74 6872 6561 6473 3a20 696e 740a  um_threads: int.
-00020120: 2020 2020 2020 2020 6e75 6d62 6572 206f          number o
-00020130: 6620 7468 7265 6164 7320 6966 2077 6520  f threads if we 
-00020140: 7761 6e74 2074 6f20 7061 7261 6c6c 656c  want to parallel
-00020150: 697a 6520 7468 6520 636f 6465 2e0a 2020  ize the code..  
-00020160: 2020 2222 220a 2020 2020 6364 6566 2073    """.    cdef s
-00020170: 7472 2065 7272 6f72 5f6d 6573 7361 6765  tr error_message
-00020180: 0a20 2020 2063 6465 6620 7374 7220 646d  .    cdef str dm
-00020190: 6f64 6520 3d20 646d 6574 686f 642e 6c6f  ode = dmethod.lo
-000201a0: 7765 7228 290a 2020 2020 6364 6566 2073  wer().    cdef s
-000201b0: 7472 2069 6d6f 6465 203d 206d 6574 686f  tr imode = metho
-000201c0: 642e 6c6f 7765 7228 290a 2020 2020 6364  d.lower().    cd
-000201d0: 6566 2073 7472 206d 696e 696d 203d 206d  ef str minim = m
-000201e0: 696e 696d 697a 652e 6c6f 7765 7228 290a  inimize.lower().
-000201f0: 2020 2020 6364 6566 2069 6e74 206a 6a70      cdef int jjp
-00020200: 310a 2020 2020 6364 6566 2069 6e74 2073  1.    cdef int s
-00020210: 7a31 5f64 730a 2020 2020 6364 6566 2069  z1_ds.    cdef i
-00020220: 6e74 2073 7a31 5f75 732c 2073 7a32 5f75  nt sz1_us, sz2_u
-00020230: 730a 2020 2020 6364 6566 2069 6e74 2073  s.    cdef int s
-00020240: 7a31 5f64 6c73 2c20 737a 325f 646c 730a  z1_dls, sz2_dls.
-00020250: 2020 2020 6364 6566 2069 6e74 206e 5f69      cdef int n_i
-00020260: 6d6f 6465 2c20 6e5f 646d 6f64 650a 2020  mode, n_dmode.  
-00020270: 2020 6364 6566 2069 6e74 206e 6c6f 730a    cdef int nlos.
-00020280: 2020 2020 6364 6566 2069 6e74 206e 743d      cdef int nt=
-00020290: 302c 2069 692c 206a 6a0a 2020 2020 6364  0, ii, jj.    cd
-000202a0: 6566 2062 696e 7420 7265 735f 6973 5f6c  ef bint res_is_l
-000202b0: 6973 740a 2020 2020 6364 6566 2062 696e  ist.    cdef bin
-000202c0: 7420 4330 2c20 4331 0a20 2020 2063 6465  t C0, C1.    cde
-000202d0: 6620 6c69 7374 206c 7469 6d65 0a20 2020  f list ltime.   
-000202e0: 2063 6465 6620 646f 7562 6c65 206c 6f63   cdef double loc
-000202f0: 5f72 0a20 2020 2063 6465 6620 6c6f 6e67  _r.    cdef long
-00020300: 5b31 5d20 6e62 5f72 6f77 730a 2020 2020  [1] nb_rows.    
-00020310: 6364 6566 206c 6f6e 675b 3a3a 315d 2069  cdef long[::1] i
-00020320: 6e64 6269 730a 2020 2020 6364 6566 2064  ndbis.    cdef d
-00020330: 6f75 626c 655b 315d 206c 6f63 5f65 6666  ouble[1] loc_eff
-00020340: 5f72 6573 0a20 2020 2063 6465 6620 646f  _res.    cdef do
-00020350: 7562 6c65 5b3a 3a31 5d20 7265 7365 6666  uble[::1] reseff
-00020360: 5f6d 760a 2020 2020 6364 6566 2064 6f75  _mv.    cdef dou
-00020370: 626c 655b 3a3a 315d 2072 6573 5f6d 760a  ble[::1] res_mv.
-00020380: 2020 2020 6364 6566 2064 6f75 626c 655b      cdef double[
-00020390: 3a2c 3a3a 315d 2076 616c 5f6d 760a 2020  :,::1] val_mv.  
-000203a0: 2020 6364 6566 2064 6f75 626c 655b 3a2c    cdef double[:,
-000203b0: 3a3a 315d 2070 7473 5f6d 760a 2020 2020  ::1] pts_mv.    
-000203c0: 6364 6566 2064 6f75 626c 655b 3a2c 3a3a  cdef double[:,::
-000203d0: 315d 2075 7362 6973 5f6d 760a 2020 2020  1] usbis_mv.    
-000203e0: 6364 6566 2064 6f75 626c 655b 3a2c 3a3a  cdef double[:,::
-000203f0: 315d 2076 616c 5f32 640a 2020 2020 6364  1] val_2d.    cd
-00020400: 6566 206e 702e 6e64 6172 7261 795b 646f  ef np.ndarray[do
-00020410: 7562 6c65 2c6e 6469 6d3d 325d 2075 7362  uble,ndim=2] usb
-00020420: 6973 0a20 2020 2063 6465 6620 6e70 2e6e  is.    cdef np.n
-00020430: 6461 7272 6179 5b64 6f75 626c 652c 6e64  darray[double,nd
-00020440: 696d 3d32 5d20 7074 730a 2020 2020 6364  im=2] pts.    cd
-00020450: 6566 206e 702e 6e64 6172 7261 795b 646f  ef np.ndarray[do
-00020460: 7562 6c65 2c6e 6469 6d3d 322c 206d 6f64  uble,ndim=2, mod
-00020470: 653d 2766 6f72 7472 616e 275d 2073 6967  e='fortran'] sig
-00020480: 0a20 2020 2063 6465 6620 6e70 2e6e 6461  .    cdef np.nda
-00020490: 7272 6179 5b64 6f75 626c 652c 6e64 696d  rray[double,ndim
-000204a0: 3d31 5d20 7265 7365 6666 0a20 2020 2063  =1] reseff.    c
-000204b0: 6465 6620 6e70 2e6e 6461 7272 6179 5b64  def np.ndarray[d
-000204c0: 6f75 626c 652c 6e64 696d 3d31 5d20 6b0a  ouble,ndim=1] k.
-000204d0: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-000204e0: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
-000204f0: 315d 2072 6573 5f61 7272 0a20 2020 2063  1] res_arr.    c
-00020500: 6465 6620 6e70 2e6e 6461 7272 6179 5b6c  def np.ndarray[l
-00020510: 6f6e 672c 6e64 696d 3d31 5d20 696e 640a  ong,ndim=1] ind.
-00020520: 2020 2020 6364 6566 206c 6f6e 672a 2069      cdef long* i
-00020530: 6e64 5f61 7272 203d 204e 554c 4c0a 2020  nd_arr = NULL.  
-00020540: 2020 6364 6566 2064 6f75 626c 652a 2072    cdef double* r
-00020550: 6573 6566 665f 6172 7220 3d20 4e55 4c4c  eseff_arr = NULL
-00020560: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-00020570: 2a2a 2063 6f65 6666 5f70 7472 203d 204e  ** coeff_ptr = N
-00020580: 554c 4c0a 2020 2020 2320 2e2e 2072 6179  ULL.    # .. ray
-00020590: 5f6f 7269 6720 7368 6170 6520 6e65 6564  _orig shape need
-000205a0: 6564 2066 6f72 2074 6573 7469 6e67 2061  ed for testing a
-000205b0: 6e64 2069 6e20 616c 676f 202e 2e2e 2e2e  nd in algo .....
+0001f650: 2323 2323 2323 2323 2323 230a 0a64 6566  ###########..def
+0001f660: 2069 6e74 6567 7261 7465 3164 2879 2c20   integrate1d(y, 
+0001f670: 646f 7562 6c65 2064 782c 2074 3d4e 6f6e  double dx, t=Non
+0001f680: 652c 2073 7472 206d 6574 686f 643d 2773  e, str method='s
+0001f690: 756d 2729 3a0a 2020 2020 2222 2220 4765  um'):.    """ Ge
+0001f6a0: 6e65 7269 6320 696e 7465 6772 6174 696f  neric integratio
+0001f6b0: 6e20 6d65 7468 6f64 205b 2773 756d 272c  n method ['sum',
+0001f6c0: 2773 696d 7073 272c 2772 6f6d 6227 5d0a  'simps','romb'].
+0001f6d0: 0a20 2020 2020 2020 204e 6f74 2075 7365  .        Not use
+0001f6e0: 6420 696e 7465 726e 616c 6c79 0a20 2020  d internally.   
+0001f6f0: 2020 2020 2055 7365 6675 6c20 7768 656e       Useful when
+0001f700: 2074 6865 2073 616d 706c 696e 6720 706f   the sampling po
+0001f710: 696e 7473 206e 6565 6420 746f 2062 6520  ints need to be 
+0001f720: 696e 7465 7270 6f6c 6174 6564 2076 6961  interpolated via
+0001f730: 2065 7175 696c 6962 7269 756d 0a20 2020   equilibrium.   
+0001f740: 2022 2222 0a20 2020 2063 6465 6620 756e   """.    cdef un
+0001f750: 7369 676e 6564 2069 6e74 206e 742c 2061  signed int nt, a
+0001f760: 786d 0a20 2020 2069 6620 7420 6973 204e  xm.    if t is N
+0001f770: 6f6e 6520 6f72 206e 6f74 2068 6173 6174  one or not hasat
+0001f780: 7472 2874 2c27 5f5f 6974 6572 5f5f 2729  tr(t,'__iter__')
+0001f790: 3a0a 2020 2020 2020 2020 6e74 203d 2031  :.        nt = 1
+0001f7a0: 0a20 2020 2020 2020 2061 786d 203d 2030  .        axm = 0
+0001f7b0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+0001f7c0: 2020 206e 7420 3d20 6c65 6e28 7429 0a20     nt = len(t). 
+0001f7d0: 2020 2020 2020 2061 786d 203d 2031 0a20         axm = 1. 
+0001f7e0: 2020 2069 6e64 203d 206e 702e 6973 6e61     ind = np.isna
+0001f7f0: 6e28 7929 0a20 2020 2069 6620 6e70 2e61  n(y).    if np.a
+0001f800: 6e79 2869 6e64 293a 0a20 2020 2020 2020  ny(ind):.       
+0001f810: 2079 203d 2079 2e63 6f70 7928 290a 2020   y = y.copy().  
+0001f820: 2020 2020 2020 795b 696e 645d 203d 2030        y[ind] = 0
+0001f830: 2e0a 0a20 2020 2063 6465 6620 6e70 2e6e  ...    cdef np.n
+0001f840: 6461 7272 6179 5b64 6f75 626c 652c 6e64  darray[double,nd
+0001f850: 696d 3d31 5d20 7320 3d20 6e70 2e65 6d70  im=1] s = np.emp
+0001f860: 7479 2828 6e74 2c29 2c64 7479 7065 3d66  ty((nt,),dtype=f
+0001f870: 6c6f 6174 290a 0a20 2020 2069 6620 6d65  loat)..    if me
+0001f880: 7468 6f64 3d3d 2773 756d 273a 0a20 2020  thod=='sum':.   
+0001f890: 2020 2020 2073 203d 206e 702e 7375 6d28       s = np.sum(
+0001f8a0: 792c 2061 7869 733d 6178 6d29 2a64 780a  y, axis=axm)*dx.
+0001f8b0: 2020 2020 656c 6966 206d 6574 686f 643d      elif method=
+0001f8c0: 3d27 7369 6d70 7327 3a0a 2020 2020 2020  ='simps':.      
+0001f8d0: 2020 7320 3d20 7363 7069 6e74 672e 7369    s = scpintg.si
+0001f8e0: 6d70 7328 792c 2078 3d4e 6f6e 652c 2064  mps(y, x=None, d
+0001f8f0: 783d 6478 2c20 6178 6973 3d61 786d 290a  x=dx, axis=axm).
+0001f900: 2020 2020 656c 6966 206d 6574 686f 643d      elif method=
+0001f910: 3d27 726f 6d62 273a 0a20 2020 2020 2020  ='romb':.       
+0001f920: 2073 203d 2073 6370 696e 7467 2e72 6f6d   s = scpintg.rom
+0001f930: 6228 792c 2064 783d 6478 2c20 6178 6973  b(y, dx=dx, axis
+0001f940: 3d61 786d 2c20 7368 6f77 3d46 616c 7365  =axm, show=False
+0001f950: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+0001f960: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
+0001f970: 696f 6e28 2241 7267 206d 6574 686f 6420  ion("Arg method 
+0001f980: 6d75 7374 2062 6520 696e 205b 2773 756d  must be in ['sum
+0001f990: 272c 2773 696d 7073 272c 2772 6f6d 6227  ','simps','romb'
+0001f9a0: 5d22 290a 2020 2020 7265 7475 726e 2073  ]").    return s
+0001f9b0: 0a0a 0a64 6566 204c 4f53 5f63 616c 635f  ...def LOS_calc_
+0001f9c0: 7369 676e 616c 2866 756e 632c 2064 6f75  signal(func, dou
+0001f9d0: 626c 655b 3a2c 3a3a 315d 2072 6179 5f6f  ble[:,::1] ray_o
+0001f9e0: 7269 672c 2064 6f75 626c 655b 3a2c 3a3a  rig, double[:,::
+0001f9f0: 315d 2072 6179 5f76 6469 722c 2072 6573  1] ray_vdir, res
+0001fa00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001fa10: 2020 2020 2020 646f 7562 6c65 5b3a 2c3a        double[:,:
+0001fa20: 3a31 5d20 6c69 6d73 2c20 7374 7220 646d  :1] lims, str dm
+0001fa30: 6574 686f 643d 2761 6273 272c 0a20 2020  ethod='abs',.   
+0001fa40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fa50: 2073 7472 206d 6574 686f 643d 2773 756d   str method='sum
+0001fa60: 272c 2062 696e 7420 616e 693d 4661 6c73  ', bint ani=Fals
+0001fa70: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0001fa80: 2020 2020 2020 2074 3d4e 6f6e 652c 2066         t=None, f
+0001fa90: 6b77 6461 7267 733d 7b7d 2c20 7374 7220  kwdargs={}, str 
+0001faa0: 6d69 6e69 6d69 7a65 3d27 6361 6c6c 7327  minimize='calls'
+0001fab0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001fac0: 2020 2020 2020 6269 6e74 2054 6573 743d        bint Test=
+0001fad0: 5472 7565 2c20 696e 7420 6e75 6d5f 7468  True, int num_th
+0001fae0: 7265 6164 733d 3136 293a 0a20 2020 2022  reads=16):.    "
+0001faf0: 2222 2043 6f6d 7075 7465 2074 6865 2073  "" Compute the s
+0001fb00: 796e 7468 6574 6963 2073 6967 6e61 6c2c  ynthetic signal,
+0001fb10: 206d 696e 696d 697a 696e 6720 6569 7468   minimizing eith
+0001fb20: 6572 2066 756e 6374 696f 6e20 6361 6c6c  er function call
+0001fb30: 7320 6f72 206d 656d 6f72 790a 2020 2020  s or memory.    
+0001fb40: 5061 7261 6d73 0a20 2020 203d 3d3d 3d3d  Params.    =====
+0001fb50: 0a20 2020 2066 756e 6320 3a20 7079 7468  .    func : pyth
+0001fb60: 6f6e 2066 756e 6374 696f 6e20 7374 2e20  on function st. 
+0001fb70: 6675 6e63 2870 7473 2c20 743d 4e6f 6e65  func(pts, t=None
+0001fb80: 2c20 7665 6374 3d4e 6f6e 6529 203d 3e20  , vect=None) => 
+0001fb90: 6461 7461 0a20 2020 2020 2020 2020 2020  data.           
+0001fba0: 7769 7468 2070 7473 203a 206e 6461 7272  with pts : ndarr
+0001fbb0: 6179 2028 332c 206e 7074 7329 202d 2070  ay (3, npts) - p
+0001fbc0: 6f69 6e74 7320 7768 6572 6520 6675 6e63  oints where func
+0001fbd0: 7469 6f6e 2069 7320 6576 616c 7561 7465  tion is evaluate
+0001fbe0: 640a 2020 2020 2020 2020 2020 2020 2020  d.              
+0001fbf0: 2020 7665 6374 203a 206e 6461 7272 6179    vect : ndarray
+0001fc00: 2833 2c20 6e70 7473 2920 2d20 6966 2061  (3, npts) - if a
+0001fc10: 6e69 736f 7472 6f70 6963 2073 6967 6e61  nisotropic signa
+0001fc20: 6c20 7665 6374 6f72 206f 6620 656d 6973  l vector of emis
+0001fc30: 732e 0a20 2020 2020 2020 2020 2020 2020  s..             
+0001fc40: 2020 2074 3a20 6e64 6172 7261 7928 6d29     t: ndarray(m)
+0001fc50: 202d 2074 696d 6573 2077 6865 7265 2074   - times where t
+0001fc60: 6f20 636f 6d70 7574 6520 7468 6520 6675  o compute the fu
+0001fc70: 6e63 7469 6f6e 0a20 2020 2020 2020 2020  nction.         
+0001fc80: 2020 7265 7475 726e 733a 2064 6174 6120    returns: data 
+0001fc90: 3a20 6e64 6172 7261 7928 6e74 2c6e 7261  : ndarray(nt,nra
+0001fca0: 6629 2069 6620 6e74 203d 2031 2c20 7468  f) if nt = 1, th
+0001fcb0: 6520 6172 7261 7920 6d75 7374 2062 6520  e array must be 
+0001fcc0: 3244 0a20 2020 2020 2020 2020 2020 2020  2D.             
+0001fcd0: 2020 2020 2020 2020 2020 2020 2020 7661                va
+0001fce0: 6c75 6573 206f 6620 6675 6e63 2061 7420  lues of func at 
+0001fcf0: 7074 732c 2061 7420 6769 7665 6e20 7469  pts, at given ti
+0001fd00: 6d65 0a20 2020 2020 2020 2020 2020 6675  me.           fu
+0001fd10: 6e63 2069 7320 7468 6520 6675 6e63 7469  nc is the functi
+0001fd20: 6f6e 2074 6f20 6265 2069 6e74 6567 7261  on to be integra
+0001fd30: 7465 6420 616c 6f6e 6720 7468 6520 4c4f  ted along the LO
+0001fd40: 530a 2020 2020 7261 795f 6f72 6967 3a20  S.    ray_orig: 
+0001fd50: 6e64 6172 7261 7920 2833 2c20 6e6c 6f73  ndarray (3, nlos
+0001fd60: 2920 4c4f 5320 6f72 6967 696e 730a 2020  ) LOS origins.  
+0001fd70: 2020 7261 795f 7664 6972 3a20 6e64 6172    ray_vdir: ndar
+0001fd80: 7261 7920 2833 2c20 6e6c 6f73 2920 4c4f  ray (3, nlos) LO
+0001fd90: 5320 6469 7265 6374 696f 6e61 6c20 7665  S directional ve
+0001fda0: 6374 6f72 0a20 2020 2072 6573 3a20 646f  ctor.    res: do
+0001fdb0: 7562 6c65 206f 7220 6c69 7374 206f 6620  uble or list of 
+0001fdc0: 646f 7562 6c65 730a 2020 2020 2020 2020  doubles.        
+0001fdd0: 4966 2072 6573 2069 7320 6120 7369 6e67  If res is a sing
+0001fde0: 6c65 2064 6f75 626c 653a 2064 6973 6372  le double: discr
+0001fdf0: 6574 697a 6174 696f 6e20 7374 6570 2066  etization step f
+0001fe00: 6f72 2061 6c6c 204c 4f53 2e0a 2020 2020  or all LOS..    
+0001fe10: 2020 2020 456c 7365 2072 6573 2073 686f      Else res sho
+0001fe20: 756c 6420 6265 2061 206c 6973 7420 6f66  uld be a list of
+0001fe30: 2073 697a 6520 6e6c 6f73 2077 6974 6820   size nlos with 
+0001fe40: 7468 6520 6469 7363 7265 7469 7a61 7469  the discretizati
+0001fe50: 6f6e 0a20 2020 2020 2020 2073 7465 7020  on.        step 
+0001fe60: 666f 7220 6561 6368 206e 6c6f 732e 0a20  for each nlos.. 
+0001fe70: 2020 206c 696d 733a 2028 322c 206e 6c6f     lims: (2, nlo
+0001fe80: 7329 2064 6f75 626c 6520 6172 7261 790a  s) double array.
+0001fe90: 2020 2020 2020 2020 466f 7220 6561 6368          For each
+0001fea0: 206e 6c6f 732c 2069 7420 6769 7665 6e20   nlos, it given 
+0001feb0: 7468 6520 6d61 7869 6d75 6d20 616e 6420  the maximum and 
+0001fec0: 6d69 6e69 6d75 6d20 6c69 6d69 7473 206f  minimum limits o
+0001fed0: 6620 7468 6520 7261 790a 2020 2020 646d  f the ray.    dm
+0001fee0: 6574 686f 643a 2073 7472 696e 670a 2020  ethod: string.  
+0001fef0: 2020 2020 2020 7479 7065 206f 6620 6469        type of di
+0001ff00: 7363 7265 7469 7a61 7469 6f6e 2073 7465  scretization ste
+0001ff10: 703a 2027 6162 7327 2066 6f72 2061 6273  p: 'abs' for abs
+0001ff20: 6f6c 7574 6520 6f72 2027 7265 6c27 2066  olute or 'rel' f
+0001ff30: 6f72 2072 656c 6174 6976 650a 2020 2020  or relative.    
+0001ff40: 6d65 7468 6f64 3a20 7374 7269 6e67 0a20  method: string. 
+0001ff50: 2020 2020 2020 206d 6574 686f 6420 6f66         method of
+0001ff60: 2071 7561 6472 6174 7572 6520 6f6e 2074   quadrature on t
+0001ff70: 6865 204c 4f53 0a20 2020 2061 6e69 203a  he LOS.    ani :
+0001ff80: 2062 6f6f 6c0a 2020 2020 2020 2020 746f   bool.        to
+0001ff90: 2069 6e64 6963 6174 6520 6966 2065 6d69   indicate if emi
+0001ffa0: 7373 696f 6e20 6973 2061 6e69 736f 7472  ssion is anisotr
+0001ffb0: 6f70 6963 206f 7220 6e6f 740a 2020 2020  opic or not.    
+0001ffc0: 7420 3a20 4e6f 6e65 206f 7220 6172 7261  t : None or arra
+0001ffd0: 792d 6c69 6b65 0a20 2020 2020 2020 2074  y-like.        t
+0001ffe0: 696d 6573 2077 6865 7265 2074 6f20 696e  imes where to in
+0001fff0: 7465 6772 6174 650a 2020 2020 6d69 6e69  tegrate.    mini
+00020000: 6d69 7a65 3a20 7374 7269 6e67 0a20 2020  mize: string.   
+00020010: 2020 2020 2022 6361 6c6c 7322 203a 2077       "calls" : w
+00020020: 6520 7573 6520 616c 676f 7269 7468 6d20  e use algorithm 
+00020030: 746f 206d 696e 696d 697a 6520 7468 6520  to minimize the 
+00020040: 6361 6c6c 7320 746f 2027 6675 6e63 2720  calls to 'func' 
+00020050: 2864 6566 6175 6c74 290a 2020 2020 2020  (default).      
+00020060: 2020 226d 656d 6f72 7922 3a20 7765 2075    "memory": we u
+00020070: 7365 2061 6c67 6f72 6974 686d 2074 6f20  se algorithm to 
+00020080: 6d69 6e69 6d69 7a65 206d 656d 6f72 7920  minimize memory 
+00020090: 7573 6564 0a20 2020 2020 2020 2022 6879  used.        "hy
+000200a0: 6272 6964 223a 2061 206d 6978 206f 6620  brid": a mix of 
+000200b0: 626f 7468 206d 6574 686f 6473 0a20 2020  both methods.   
+000200c0: 2054 6573 7420 3a20 626f 6f6c 0a20 2020   Test : bool.   
+000200d0: 2020 2020 2077 6520 7465 7374 2069 6620       we test if 
+000200e0: 7468 6520 696e 7075 7473 2061 7265 2067  the inputs are g
+000200f0: 6976 696e 6720 696e 2061 2070 726f 7065  iving in a prope
+00020100: 7220 7761 792e 0a20 2020 206e 756d 5f74  r way..    num_t
+00020110: 6872 6561 6473 3a20 696e 740a 2020 2020  hreads: int.    
+00020120: 2020 2020 6e75 6d62 6572 206f 6620 7468      number of th
+00020130: 7265 6164 7320 6966 2077 6520 7761 6e74  reads if we want
+00020140: 2074 6f20 7061 7261 6c6c 656c 697a 6520   to parallelize 
+00020150: 7468 6520 636f 6465 2e0a 2020 2020 2222  the code..    ""
+00020160: 220a 2020 2020 6364 6566 2073 7472 2065  ".    cdef str e
+00020170: 7272 6f72 5f6d 6573 7361 6765 0a20 2020  rror_message.   
+00020180: 2063 6465 6620 7374 7220 646d 6f64 6520   cdef str dmode 
+00020190: 3d20 646d 6574 686f 642e 6c6f 7765 7228  = dmethod.lower(
+000201a0: 290a 2020 2020 6364 6566 2073 7472 2069  ).    cdef str i
+000201b0: 6d6f 6465 203d 206d 6574 686f 642e 6c6f  mode = method.lo
+000201c0: 7765 7228 290a 2020 2020 6364 6566 2073  wer().    cdef s
+000201d0: 7472 206d 696e 696d 203d 206d 696e 696d  tr minim = minim
+000201e0: 697a 652e 6c6f 7765 7228 290a 2020 2020  ize.lower().    
+000201f0: 6364 6566 2069 6e74 206a 6a70 310a 2020  cdef int jjp1.  
+00020200: 2020 6364 6566 2069 6e74 2073 7a31 5f64    cdef int sz1_d
+00020210: 730a 2020 2020 6364 6566 2069 6e74 2073  s.    cdef int s
+00020220: 7a31 5f75 732c 2073 7a32 5f75 730a 2020  z1_us, sz2_us.  
+00020230: 2020 6364 6566 2069 6e74 2073 7a31 5f64    cdef int sz1_d
+00020240: 6c73 2c20 737a 325f 646c 730a 2020 2020  ls, sz2_dls.    
+00020250: 6364 6566 2069 6e74 206e 5f69 6d6f 6465  cdef int n_imode
+00020260: 2c20 6e5f 646d 6f64 650a 2020 2020 6364  , n_dmode.    cd
+00020270: 6566 2069 6e74 206e 6c6f 730a 2020 2020  ef int nlos.    
+00020280: 6364 6566 2069 6e74 206e 743d 302c 2069  cdef int nt=0, i
+00020290: 692c 206a 6a0a 2020 2020 6364 6566 2062  i, jj.    cdef b
+000202a0: 696e 7420 7265 735f 6973 5f6c 6973 740a  int res_is_list.
+000202b0: 2020 2020 6364 6566 2062 696e 7420 4330      cdef bint C0
+000202c0: 2c20 4331 0a20 2020 2063 6465 6620 6c69  , C1.    cdef li
+000202d0: 7374 206c 7469 6d65 0a20 2020 2063 6465  st ltime.    cde
+000202e0: 6620 646f 7562 6c65 206c 6f63 5f72 0a20  f double loc_r. 
+000202f0: 2020 2063 6465 6620 6c6f 6e67 5b31 5d20     cdef long[1] 
+00020300: 6e62 5f72 6f77 730a 2020 2020 6364 6566  nb_rows.    cdef
+00020310: 206c 6f6e 675b 3a3a 315d 2069 6e64 6269   long[::1] indbi
+00020320: 730a 2020 2020 6364 6566 2064 6f75 626c  s.    cdef doubl
+00020330: 655b 315d 206c 6f63 5f65 6666 5f72 6573  e[1] loc_eff_res
+00020340: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00020350: 5b3a 3a31 5d20 7265 7365 6666 5f6d 760a  [::1] reseff_mv.
+00020360: 2020 2020 6364 6566 2064 6f75 626c 655b      cdef double[
+00020370: 3a3a 315d 2072 6573 5f6d 760a 2020 2020  ::1] res_mv.    
+00020380: 6364 6566 2064 6f75 626c 655b 3a2c 3a3a  cdef double[:,::
+00020390: 315d 2076 616c 5f6d 760a 2020 2020 6364  1] val_mv.    cd
+000203a0: 6566 2064 6f75 626c 655b 3a2c 3a3a 315d  ef double[:,::1]
+000203b0: 2070 7473 5f6d 760a 2020 2020 6364 6566   pts_mv.    cdef
+000203c0: 2064 6f75 626c 655b 3a2c 3a3a 315d 2075   double[:,::1] u
+000203d0: 7362 6973 5f6d 760a 2020 2020 6364 6566  sbis_mv.    cdef
+000203e0: 2064 6f75 626c 655b 3a2c 3a3a 315d 2076   double[:,::1] v
+000203f0: 616c 5f32 640a 2020 2020 6364 6566 206e  al_2d.    cdef n
+00020400: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+00020410: 2c6e 6469 6d3d 325d 2075 7362 6973 0a20  ,ndim=2] usbis. 
+00020420: 2020 2063 6465 6620 6e70 2e6e 6461 7272     cdef np.ndarr
+00020430: 6179 5b64 6f75 626c 652c 6e64 696d 3d32  ay[double,ndim=2
+00020440: 5d20 7074 730a 2020 2020 6364 6566 206e  ] pts.    cdef n
+00020450: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+00020460: 2c6e 6469 6d3d 322c 206d 6f64 653d 2766  ,ndim=2, mode='f
+00020470: 6f72 7472 616e 275d 2073 6967 0a20 2020  ortran'] sig.   
+00020480: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
+00020490: 5b64 6f75 626c 652c 6e64 696d 3d31 5d20  [double,ndim=1] 
+000204a0: 7265 7365 6666 0a20 2020 2063 6465 6620  reseff.    cdef 
+000204b0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+000204c0: 652c 6e64 696d 3d31 5d20 6b0a 2020 2020  e,ndim=1] k.    
+000204d0: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+000204e0: 646f 7562 6c65 2c6e 6469 6d3d 315d 2072  double,ndim=1] r
+000204f0: 6573 5f61 7272 0a20 2020 2063 6465 6620  es_arr.    cdef 
+00020500: 6e70 2e6e 6461 7272 6179 5b6c 6f6e 672c  np.ndarray[long,
+00020510: 6e64 696d 3d31 5d20 696e 640a 2020 2020  ndim=1] ind.    
+00020520: 6364 6566 206c 6f6e 672a 2069 6e64 5f61  cdef long* ind_a
+00020530: 7272 203d 204e 554c 4c0a 2020 2020 6364  rr = NULL.    cd
+00020540: 6566 2064 6f75 626c 652a 2072 6573 6566  ef double* resef
+00020550: 665f 6172 7220 3d20 4e55 4c4c 0a20 2020  f_arr = NULL.   
+00020560: 2063 6465 6620 646f 7562 6c65 2a2a 2063   cdef double** c
+00020570: 6f65 6666 5f70 7472 203d 204e 554c 4c0a  oeff_ptr = NULL.
+00020580: 2020 2020 2320 2e2e 2072 6179 5f6f 7269      # .. ray_ori
+00020590: 6720 7368 6170 6520 6e65 6564 6564 2066  g shape needed f
+000205a0: 6f72 2074 6573 7469 6e67 2061 6e64 2069  or testing and i
+000205b0: 6e20 616c 676f 202e 2e2e 2e2e 2e2e 2e2e  n algo .........
 000205c0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-000205d0: 2e2e 2e2e 0a20 2020 2073 7a31 5f64 7320  .....    sz1_ds 
-000205e0: 3d20 7261 795f 6f72 6967 2e73 6861 7065  = ray_orig.shape
-000205f0: 5b30 5d0a 2020 2020 6e6c 6f73 203d 2072  [0].    nlos = r
-00020600: 6179 5f6f 7269 672e 7368 6170 655b 315d  ay_orig.shape[1]
-00020610: 0a20 2020 2072 6573 5f69 735f 6c69 7374  .    res_is_list
-00020620: 203d 2068 6173 6174 7472 2872 6573 2c20   = hasattr(res, 
-00020630: 275f 5f69 7465 725f 5f27 290a 2020 2020  '__iter__').    
-00020640: 2320 2e2e 2076 6572 6966 7969 6e67 2061  # .. verifying a
-00020650: 7267 756d 656e 7473 202e 2e2e 2e2e 2e2e  rguments .......
+000205d0: 0a20 2020 2073 7a31 5f64 7320 3d20 7261  .    sz1_ds = ra
+000205e0: 795f 6f72 6967 2e73 6861 7065 5b30 5d0a  y_orig.shape[0].
+000205f0: 2020 2020 6e6c 6f73 203d 2072 6179 5f6f      nlos = ray_o
+00020600: 7269 672e 7368 6170 655b 315d 0a20 2020  rig.shape[1].   
+00020610: 2072 6573 5f69 735f 6c69 7374 203d 2068   res_is_list = h
+00020620: 6173 6174 7472 2872 6573 2c20 275f 5f69  asattr(res, '__i
+00020630: 7465 725f 5f27 290a 2020 2020 2320 2e2e  ter__').    # ..
+00020640: 2076 6572 6966 7969 6e67 2061 7267 756d   verifying argum
+00020650: 656e 7473 202e 2e2e 2e2e 2e2e 2e2e 2e2e  ents ...........
 00020660: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00020670: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00020680: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020  .............   
-00020690: 2069 6620 5465 7374 3a0a 2020 2020 2020   if Test:.      
-000206a0: 2020 737a 315f 7573 203d 2072 6179 5f76    sz1_us = ray_v
-000206b0: 6469 722e 7368 6170 655b 305d 0a20 2020  dir.shape[0].   
-000206c0: 2020 2020 2073 7a32 5f75 7320 3d20 7261       sz2_us = ra
-000206d0: 795f 7664 6972 2e73 6861 7065 5b31 5d0a  y_vdir.shape[1].
-000206e0: 2020 2020 2020 2020 737a 315f 646c 7320          sz1_dls 
-000206f0: 3d20 6c69 6d73 2e73 6861 7065 5b30 5d0a  = lims.shape[0].
-00020700: 2020 2020 2020 2020 737a 325f 646c 7320          sz2_dls 
-00020710: 3d20 6c69 6d73 2e73 6861 7065 5b31 5d0a  = lims.shape[1].
-00020720: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
-00020730: 7a31 5f64 7320 3d3d 2033 2c20 2244 696d  z1_ds == 3, "Dim
-00020740: 2030 206f 6620 6172 6720 7261 795f 6f72   0 of arg ray_or
-00020750: 6967 2073 686f 756c 6420 6265 2033 220a  ig should be 3".
-00020760: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
-00020770: 7a31 5f75 7320 3d3d 2033 2c20 2244 696d  z1_us == 3, "Dim
-00020780: 2030 206f 6620 6172 6720 7261 795f 7664   0 of arg ray_vd
-00020790: 6972 2073 686f 756c 6420 6265 2033 220a  ir should be 3".
-000207a0: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
-000207b0: 7a31 5f64 6c73 203d 3d20 322c 2022 4469  z1_dls == 2, "Di
-000207c0: 6d20 3020 6f66 2061 7267 206c 696d 7320  m 0 of arg lims 
-000207d0: 7368 6f75 6c64 2062 6520 3222 0a20 2020  should be 2".   
-000207e0: 2020 2020 2065 7272 6f72 5f6d 6573 7361       error_messa
-000207f0: 6765 203d 2028 2241 7267 7320 7261 795f  ge = ("Args ray_
-00020800: 6f72 6967 2c20 7261 795f 7664 6972 2c20  orig, ray_vdir, 
-00020810: 616e 6420 6c69 6d73 2022 0a20 2020 2020  and lims ".     
+00020680: 2e2e 2e2e 2e2e 2e2e 0a20 2020 2069 6620  .........    if 
+00020690: 5465 7374 3a0a 2020 2020 2020 2020 737a  Test:.        sz
+000206a0: 315f 7573 203d 2072 6179 5f76 6469 722e  1_us = ray_vdir.
+000206b0: 7368 6170 655b 305d 0a20 2020 2020 2020  shape[0].       
+000206c0: 2073 7a32 5f75 7320 3d20 7261 795f 7664   sz2_us = ray_vd
+000206d0: 6972 2e73 6861 7065 5b31 5d0a 2020 2020  ir.shape[1].    
+000206e0: 2020 2020 737a 315f 646c 7320 3d20 6c69      sz1_dls = li
+000206f0: 6d73 2e73 6861 7065 5b30 5d0a 2020 2020  ms.shape[0].    
+00020700: 2020 2020 737a 325f 646c 7320 3d20 6c69      sz2_dls = li
+00020710: 6d73 2e73 6861 7065 5b31 5d0a 2020 2020  ms.shape[1].    
+00020720: 2020 2020 6173 7365 7274 2073 7a31 5f64      assert sz1_d
+00020730: 7320 3d3d 2033 2c20 2244 696d 2030 206f  s == 3, "Dim 0 o
+00020740: 6620 6172 6720 7261 795f 6f72 6967 2073  f arg ray_orig s
+00020750: 686f 756c 6420 6265 2033 220a 2020 2020  hould be 3".    
+00020760: 2020 2020 6173 7365 7274 2073 7a31 5f75      assert sz1_u
+00020770: 7320 3d3d 2033 2c20 2244 696d 2030 206f  s == 3, "Dim 0 o
+00020780: 6620 6172 6720 7261 795f 7664 6972 2073  f arg ray_vdir s
+00020790: 686f 756c 6420 6265 2033 220a 2020 2020  hould be 3".    
+000207a0: 2020 2020 6173 7365 7274 2073 7a31 5f64      assert sz1_d
+000207b0: 6c73 203d 3d20 322c 2022 4469 6d20 3020  ls == 2, "Dim 0 
+000207c0: 6f66 2061 7267 206c 696d 7320 7368 6f75  of arg lims shou
+000207d0: 6c64 2062 6520 3222 0a20 2020 2020 2020  ld be 2".       
+000207e0: 2065 7272 6f72 5f6d 6573 7361 6765 203d   error_message =
+000207f0: 2028 2241 7267 7320 7261 795f 6f72 6967   ("Args ray_orig
+00020800: 2c20 7261 795f 7664 6972 2c20 616e 6420  , ray_vdir, and 
+00020810: 6c69 6d73 2022 0a20 2020 2020 2020 2020  lims ".         
 00020820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020830: 2020 2020 2b20 2273 686f 756c 6420 6861      + "should ha
-00020840: 7665 2073 616d 6520 6469 6d65 6e73 696f  ve same dimensio
-00020850: 6e20 3122 290a 2020 2020 2020 2020 6173  n 1").        as
-00020860: 7365 7274 206e 6c6f 7320 3d3d 2073 7a32  sert nlos == sz2
-00020870: 5f75 7320 3d3d 2073 7a32 5f64 6c73 2c20  _us == sz2_dls, 
-00020880: 6572 726f 725f 6d65 7373 6167 650a 2020  error_message.  
-00020890: 2020 2020 2020 4330 203d 206e 6f74 2072        C0 = not r
-000208a0: 6573 5f69 735f 6c69 7374 2061 6e64 2072  es_is_list and r
-000208b0: 6573 203e 2030 2e0a 2020 2020 2020 2020  es > 0..        
-000208c0: 4331 203d 2072 6573 5f69 735f 6c69 7374  C1 = res_is_list
-000208d0: 2061 6e64 206c 656e 2872 6573 293d 3d6e   and len(res)==n
-000208e0: 6c6f 7320 616e 6420 6e70 2e61 6c6c 2872  los and np.all(r
-000208f0: 6573 3e30 2e29 0a20 2020 2020 2020 2061  es>0.).        a
-00020900: 7373 6572 7420 4330 206f 7220 4331 2c20  ssert C0 or C1, 
-00020910: 2241 7267 2072 6573 206d 7573 7420 6265  "Arg res must be
-00020920: 2061 2064 6f75 626c 6520 6f72 2061 204c   a double or a L
-00020930: 6973 742c 2061 6e64 2061 6c6c 2072 6573  ist, and all res
-00020940: 203e 302e 2122 0a20 2020 2020 2020 2065   >0.!".        e
-00020950: 7272 6f72 5f6d 6573 7361 6765 203d 2022  rror_message = "
-00020960: 4172 6775 6d65 6e74 2064 6d65 7468 6f64  Argument dmethod
-00020970: 2028 6469 7363 7265 7469 7a61 7469 6f6e   (discretization
-00020980: 206d 6574 686f 6429 2073 686f 756c 6420   method) should 
-00020990: 6265 2069 6e22 5c0a 2020 2020 2020 2020  be in"\.        
-000209a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000209b0: 2b22 205b 2761 6273 272c 2772 656c 275d  +" ['abs','rel']
-000209c0: 2c20 666f 7220 6162 736f 6c75 7465 206f  , for absolute o
-000209d0: 7220 7265 6c61 7469 7665 2e22 0a20 2020  r relative.".   
-000209e0: 2020 2020 2061 7373 6572 7420 646d 6f64       assert dmod
-000209f0: 6520 696e 205b 2761 6273 272c 2772 656c  e in ['abs','rel
-00020a00: 275d 2c20 6572 726f 725f 6d65 7373 6167  '], error_messag
-00020a10: 650a 2020 2020 2020 2020 6572 726f 725f  e.        error_
-00020a20: 6d65 7373 6167 6520 3d20 2257 726f 6e67  message = "Wrong
-00020a30: 206d 6574 686f 6420 6f66 2069 6e74 6567   method of integ
-00020a40: 7261 7469 6f6e 2e22 205c 0a20 2020 2020  ration." \.     
-00020a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020a60: 2020 202b 2022 204f 7074 696f 6e73 2061     + " Options a
-00020a70: 7265 3a20 5b27 7375 6d27 2c27 7369 6d70  re: ['sum','simp
-00020a80: 7327 2c27 726f 6d62 275d 220a 2020 2020  s','romb']".    
-00020a90: 2020 2020 6173 7365 7274 2069 6d6f 6465      assert imode
-00020aa0: 2069 6e20 5b27 7375 6d27 2c27 7369 6d70   in ['sum','simp
-00020ab0: 7327 2c27 726f 6d62 275d 2c20 6572 726f  s','romb'], erro
-00020ac0: 725f 6d65 7373 6167 650a 2020 2020 2020  r_message.      
-00020ad0: 2020 6572 726f 725f 6d65 7373 6167 6520    error_message 
-00020ae0: 3d20 2257 726f 6e67 206d 696e 696d 697a  = "Wrong minimiz
-00020af0: 6520 6f70 7469 6d69 7a61 7469 6f6e 2e22  e optimization."
-00020b00: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-00020b10: 2020 2020 2020 2020 2020 2b20 2220 4f70            + " Op
-00020b20: 7469 6f6e 7320 6172 653a 205b 2763 616c  tions are: ['cal
-00020b30: 6c73 272c 276d 656d 6f72 7927 2c27 6879  ls','memory','hy
-00020b40: 6272 6964 275d 220a 2020 2020 2020 2020  brid']".        
-00020b50: 6173 7365 7274 206d 696e 696d 2069 6e20  assert minim in 
-00020b60: 5b27 6361 6c6c 7327 2c27 6d65 6d6f 7279  ['calls','memory
-00020b70: 272c 2768 7962 7269 6427 5d2c 2065 7272  ','hybrid'], err
-00020b80: 6f72 5f6d 6573 7361 6765 0a20 2020 2023  or_message.    #
-00020b90: 202d 2d20 5072 6566 6f72 6d61 7420 6f75   -- Preformat ou
-00020ba0: 7470 7574 2073 6967 6e61 6c20 2d2d 2d2d  tput signal ----
+00020830: 2b20 2273 686f 756c 6420 6861 7665 2073  + "should have s
+00020840: 616d 6520 6469 6d65 6e73 696f 6e20 3122  ame dimension 1"
+00020850: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
+00020860: 206e 6c6f 7320 3d3d 2073 7a32 5f75 7320   nlos == sz2_us 
+00020870: 3d3d 2073 7a32 5f64 6c73 2c20 6572 726f  == sz2_dls, erro
+00020880: 725f 6d65 7373 6167 650a 2020 2020 2020  r_message.      
+00020890: 2020 4330 203d 206e 6f74 2072 6573 5f69    C0 = not res_i
+000208a0: 735f 6c69 7374 2061 6e64 2072 6573 203e  s_list and res >
+000208b0: 2030 2e0a 2020 2020 2020 2020 4331 203d   0..        C1 =
+000208c0: 2072 6573 5f69 735f 6c69 7374 2061 6e64   res_is_list and
+000208d0: 206c 656e 2872 6573 293d 3d6e 6c6f 7320   len(res)==nlos 
+000208e0: 616e 6420 6e70 2e61 6c6c 2872 6573 3e30  and np.all(res>0
+000208f0: 2e29 0a20 2020 2020 2020 2061 7373 6572  .).        asser
+00020900: 7420 4330 206f 7220 4331 2c20 2241 7267  t C0 or C1, "Arg
+00020910: 2072 6573 206d 7573 7420 6265 2061 2064   res must be a d
+00020920: 6f75 626c 6520 6f72 2061 204c 6973 742c  ouble or a List,
+00020930: 2061 6e64 2061 6c6c 2072 6573 203e 302e   and all res >0.
+00020940: 2122 0a20 2020 2020 2020 2065 7272 6f72  !".        error
+00020950: 5f6d 6573 7361 6765 203d 2022 4172 6775  _message = "Argu
+00020960: 6d65 6e74 2064 6d65 7468 6f64 2028 6469  ment dmethod (di
+00020970: 7363 7265 7469 7a61 7469 6f6e 206d 6574  scretization met
+00020980: 686f 6429 2073 686f 756c 6420 6265 2069  hod) should be i
+00020990: 6e22 5c0a 2020 2020 2020 2020 2020 2020  n"\.            
+000209a0: 2020 2020 2020 2020 2020 2020 2b22 205b              +" [
+000209b0: 2761 6273 272c 2772 656c 275d 2c20 666f  'abs','rel'], fo
+000209c0: 7220 6162 736f 6c75 7465 206f 7220 7265  r absolute or re
+000209d0: 6c61 7469 7665 2e22 0a20 2020 2020 2020  lative.".       
+000209e0: 2061 7373 6572 7420 646d 6f64 6520 696e   assert dmode in
+000209f0: 205b 2761 6273 272c 2772 656c 275d 2c20   ['abs','rel'], 
+00020a00: 6572 726f 725f 6d65 7373 6167 650a 2020  error_message.  
+00020a10: 2020 2020 2020 6572 726f 725f 6d65 7373        error_mess
+00020a20: 6167 6520 3d20 2257 726f 6e67 206d 6574  age = "Wrong met
+00020a30: 686f 6420 6f66 2069 6e74 6567 7261 7469  hod of integrati
+00020a40: 6f6e 2e22 205c 0a20 2020 2020 2020 2020  on." \.         
+00020a50: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+00020a60: 2022 204f 7074 696f 6e73 2061 7265 3a20   " Options are: 
+00020a70: 5b27 7375 6d27 2c27 7369 6d70 7327 2c27  ['sum','simps','
+00020a80: 726f 6d62 275d 220a 2020 2020 2020 2020  romb']".        
+00020a90: 6173 7365 7274 2069 6d6f 6465 2069 6e20  assert imode in 
+00020aa0: 5b27 7375 6d27 2c27 7369 6d70 7327 2c27  ['sum','simps','
+00020ab0: 726f 6d62 275d 2c20 6572 726f 725f 6d65  romb'], error_me
+00020ac0: 7373 6167 650a 2020 2020 2020 2020 6572  ssage.        er
+00020ad0: 726f 725f 6d65 7373 6167 6520 3d20 2257  ror_message = "W
+00020ae0: 726f 6e67 206d 696e 696d 697a 6520 6f70  rong minimize op
+00020af0: 7469 6d69 7a61 7469 6f6e 2e22 5c0a 2020  timization."\.  
+00020b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020b10: 2020 2020 2020 2b20 2220 4f70 7469 6f6e        + " Option
+00020b20: 7320 6172 653a 205b 2763 616c 6c73 272c  s are: ['calls',
+00020b30: 276d 656d 6f72 7927 2c27 6879 6272 6964  'memory','hybrid
+00020b40: 275d 220a 2020 2020 2020 2020 6173 7365  ']".        asse
+00020b50: 7274 206d 696e 696d 2069 6e20 5b27 6361  rt minim in ['ca
+00020b60: 6c6c 7327 2c27 6d65 6d6f 7279 272c 2768  lls','memory','h
+00020b70: 7962 7269 6427 5d2c 2065 7272 6f72 5f6d  ybrid'], error_m
+00020b80: 6573 7361 6765 0a20 2020 2023 202d 2d20  essage.    # -- 
+00020b90: 5072 6566 6f72 6d61 7420 6f75 7470 7574  Preformat output
+00020ba0: 2073 6967 6e61 6c20 2d2d 2d2d 2d2d 2d2d   signal --------
 00020bb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00020bc0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00020bd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
-00020be0: 6966 2074 2069 7320 4e6f 6e65 3a0a 2020  if t is None:.  
-00020bf0: 2020 2020 2020 6966 206d 696e 696d 203d        if minim =
-00020c00: 3d20 276d 656d 6f72 7927 3a0a 2020 2020  = 'memory':.    
-00020c10: 2020 2020 2020 2020 6d69 6e69 6d20 3d20          minim = 
-00020c20: 2763 616c 6c73 270a 2020 2020 2020 2020  'calls'.        
-00020c30: 2020 2020 6572 726f 725f 6d65 7373 6167      error_messag
-00020c40: 6520 3d20 2249 6620 7420 6973 204e 6f6e  e = "If t is Non
-00020c50: 6520 2122 0a20 2020 2020 2020 2020 2020  e !".           
-00020c60: 2065 7272 6f72 5f6d 6573 7361 6765 202b   error_message +
-00020c70: 3d20 2220 203d 3e20 7468 6572 6520 6973  = "  => there is
-00020c80: 206e 6f20 706f 696e 7420 696e 2075 7369   no point in usi
-00020c90: 6e67 206d 696e 696d 697a 653d 276d 656d  ng minimize='mem
-00020ca0: 6f72 7927 220a 2020 2020 2020 2020 2020  ory'".          
-00020cb0: 2020 6572 726f 725f 6d65 7373 6167 6520    error_message 
-00020cc0: 2b3d 2022 2020 3d3e 2073 7769 7463 6869  += "  => switchi
-00020cd0: 6e67 2074 6f20 6d69 6e69 6d69 7a65 203d  ng to minimize =
-00020ce0: 2027 2573 2722 256d 696e 696d 0a20 2020   '%s'"%minim.   
-00020cf0: 2020 2020 2020 2020 2077 6172 6e28 6572           warn(er
-00020d00: 726f 725f 6d65 7373 6167 6529 0a20 2020  ror_message).   
-00020d10: 2020 2020 206e 7420 3d20 310a 2020 2020       nt = 1.    
-00020d20: 2020 2020 6c74 696d 6520 3d20 5b4e 6f6e      ltime = [Non
-00020d30: 655d 0a20 2020 2065 6c69 6620 6e6f 7420  e].    elif not 
-00020d40: 6861 7361 7474 7228 742c 275f 5f69 7465  hasattr(t,'__ite
-00020d50: 725f 5f27 293a 0a20 2020 2020 2020 206e  r__'):.        n
-00020d60: 7420 3d20 310a 2020 2020 2020 2020 6c74  t = 1.        lt
-00020d70: 696d 6520 3d20 5b74 5d0a 2020 2020 656c  ime = [t].    el
-00020d80: 7365 3a0a 2020 2020 2020 2020 6e74 203d  se:.        nt =
-00020d90: 206c 656e 2874 290a 2020 2020 2020 2020   len(t).        
-00020da0: 6966 2069 7369 6e73 7461 6e63 6528 742c  if isinstance(t,
-00020db0: 206c 6973 7429 3a0a 2020 2020 2020 2020   list):.        
-00020dc0: 2020 2020 6c74 696d 6520 3d20 740a 2020      ltime = t.  
-00020dd0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00020de0: 2020 2020 2020 2020 6c74 696d 6520 3d20          ltime = 
-00020df0: 742e 746f 6c69 7374 2829 0a20 2020 2023  t.tolist().    #
-00020e00: 202d 2d20 496e 697a 6961 6c69 7a61 7469   -- Inizializati
-00020e10: 6f6e 7320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ons ------------
+00020bd0: 2d2d 2d2d 2d2d 2d0a 2020 2020 6966 2074  -------.    if t
+00020be0: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00020bf0: 2020 6966 206d 696e 696d 203d 3d20 276d    if minim == 'm
+00020c00: 656d 6f72 7927 3a0a 2020 2020 2020 2020  emory':.        
+00020c10: 2020 2020 6d69 6e69 6d20 3d20 2763 616c      minim = 'cal
+00020c20: 6c73 270a 2020 2020 2020 2020 2020 2020  ls'.            
+00020c30: 6572 726f 725f 6d65 7373 6167 6520 3d20  error_message = 
+00020c40: 2249 6620 7420 6973 204e 6f6e 6520 2122  "If t is None !"
+00020c50: 0a20 2020 2020 2020 2020 2020 2065 7272  .            err
+00020c60: 6f72 5f6d 6573 7361 6765 202b 3d20 2220  or_message += " 
+00020c70: 203d 3e20 7468 6572 6520 6973 206e 6f20   => there is no 
+00020c80: 706f 696e 7420 696e 2075 7369 6e67 206d  point in using m
+00020c90: 696e 696d 697a 653d 276d 656d 6f72 7927  inimize='memory'
+00020ca0: 220a 2020 2020 2020 2020 2020 2020 6572  ".            er
+00020cb0: 726f 725f 6d65 7373 6167 6520 2b3d 2022  ror_message += "
+00020cc0: 2020 3d3e 2073 7769 7463 6869 6e67 2074    => switching t
+00020cd0: 6f20 6d69 6e69 6d69 7a65 203d 2027 2573  o minimize = '%s
+00020ce0: 2722 256d 696e 696d 0a20 2020 2020 2020  '"%minim.       
+00020cf0: 2020 2020 2077 6172 6e28 6572 726f 725f       warn(error_
+00020d00: 6d65 7373 6167 6529 0a20 2020 2020 2020  message).       
+00020d10: 206e 7420 3d20 310a 2020 2020 2020 2020   nt = 1.        
+00020d20: 6c74 696d 6520 3d20 5b4e 6f6e 655d 0a20  ltime = [None]. 
+00020d30: 2020 2065 6c69 6620 6e6f 7420 6861 7361     elif not hasa
+00020d40: 7474 7228 742c 275f 5f69 7465 725f 5f27  ttr(t,'__iter__'
+00020d50: 293a 0a20 2020 2020 2020 206e 7420 3d20  ):.        nt = 
+00020d60: 310a 2020 2020 2020 2020 6c74 696d 6520  1.        ltime 
+00020d70: 3d20 5b74 5d0a 2020 2020 656c 7365 3a0a  = [t].    else:.
+00020d80: 2020 2020 2020 2020 6e74 203d 206c 656e          nt = len
+00020d90: 2874 290a 2020 2020 2020 2020 6966 2069  (t).        if i
+00020da0: 7369 6e73 7461 6e63 6528 742c 206c 6973  sinstance(t, lis
+00020db0: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
+00020dc0: 6c74 696d 6520 3d20 740a 2020 2020 2020  ltime = t.      
+00020dd0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00020de0: 2020 2020 6c74 696d 6520 3d20 742e 746f      ltime = t.to
+00020df0: 6c69 7374 2829 0a20 2020 2023 202d 2d20  list().    # -- 
+00020e00: 496e 697a 6961 6c69 7a61 7469 6f6e 7320  Inizializations 
+00020e10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00020e20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00020e30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00020e40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
-00020e50: 2320 4765 7474 696e 6720 6e75 6d62 6572  # Getting number
-00020e60: 206f 6620 6d6f 6465 733a 0a20 2020 206e   of modes:.    n
-00020e70: 5f64 6d6f 6465 203d 205f 7374 2e67 6574  _dmode = _st.get
-00020e80: 5f6e 625f 646d 6f64 6528 646d 6f64 6529  _nb_dmode(dmode)
-00020e90: 0a20 2020 206e 5f69 6d6f 6465 203d 205f  .    n_imode = _
-00020ea0: 7374 2e67 6574 5f6e 625f 696d 6f64 6528  st.get_nb_imode(
-00020eb0: 696d 6f64 6529 0a20 2020 2023 2049 6e69  imode).    # Ini
-00020ec0: 7469 616c 697a 6174 696f 6e20 7265 7375  tialization resu
-00020ed0: 6c74 0a20 2020 2073 6967 203d 206e 702e  lt.    sig = np.
-00020ee0: 656d 7074 7928 286e 742c 206e 6c6f 7329  empty((nt, nlos)
-00020ef0: 2c20 6474 7970 653d 666c 6f61 742c 206f  , dtype=float, o
-00020f00: 7264 6572 3d27 4627 290a 2020 2020 2320  rder='F').    # 
-00020f10: 4966 2074 6865 2072 6573 6f6c 7574 696f  If the resolutio
-00020f20: 6e20 6973 2074 6865 2073 616d 6520 666f  n is the same fo
-00020f30: 7220 6576 6572 7920 4c4f 532c 2077 6520  r every LOS, we 
-00020f40: 6372 6561 7465 2061 2074 6162 0a20 2020  create a tab.   
-00020f50: 2069 6620 7265 735f 6973 5f6c 6973 7420   if res_is_list 
-00020f60: 3a0a 2020 2020 2020 2020 7265 735f 6172  :.        res_ar
-00020f70: 7220 3d20 6e70 2e61 7361 7272 6179 2872  r = np.asarray(r
-00020f80: 6573 290a 2020 2020 656c 7365 3a0a 2020  es).    else:.  
-00020f90: 2020 2020 2020 7265 735f 6172 7220 3d20        res_arr = 
-00020fa0: 6e70 2e6f 6e65 7328 286e 6c6f 732c 292c  np.ones((nlos,),
-00020fb0: 2064 7479 7065 3d66 6c6f 6174 2920 2a20   dtype=float) * 
-00020fc0: 7265 730a 2020 2020 7265 735f 6d76 203d  res.    res_mv =
-00020fd0: 2072 6573 5f61 7272 0a20 2020 2023 202d   res_arr.    # -
+00020e40: 2d2d 2d2d 2d2d 2d0a 2020 2020 2320 4765  -------.    # Ge
+00020e50: 7474 696e 6720 6e75 6d62 6572 206f 6620  tting number of 
+00020e60: 6d6f 6465 733a 0a20 2020 206e 5f64 6d6f  modes:.    n_dmo
+00020e70: 6465 203d 205f 7374 2e67 6574 5f6e 625f  de = _st.get_nb_
+00020e80: 646d 6f64 6528 646d 6f64 6529 0a20 2020  dmode(dmode).   
+00020e90: 206e 5f69 6d6f 6465 203d 205f 7374 2e67   n_imode = _st.g
+00020ea0: 6574 5f6e 625f 696d 6f64 6528 696d 6f64  et_nb_imode(imod
+00020eb0: 6529 0a20 2020 2023 2049 6e69 7469 616c  e).    # Initial
+00020ec0: 697a 6174 696f 6e20 7265 7375 6c74 0a20  ization result. 
+00020ed0: 2020 2073 6967 203d 206e 702e 656d 7074     sig = np.empt
+00020ee0: 7928 286e 742c 206e 6c6f 7329 2c20 6474  y((nt, nlos), dt
+00020ef0: 7970 653d 666c 6f61 742c 206f 7264 6572  ype=float, order
+00020f00: 3d27 4627 290a 2020 2020 2320 4966 2074  ='F').    # If t
+00020f10: 6865 2072 6573 6f6c 7574 696f 6e20 6973  he resolution is
+00020f20: 2074 6865 2073 616d 6520 666f 7220 6576   the same for ev
+00020f30: 6572 7920 4c4f 532c 2077 6520 6372 6561  ery LOS, we crea
+00020f40: 7465 2061 2074 6162 0a20 2020 2069 6620  te a tab.    if 
+00020f50: 7265 735f 6973 5f6c 6973 7420 3a0a 2020  res_is_list :.  
+00020f60: 2020 2020 2020 7265 735f 6172 7220 3d20        res_arr = 
+00020f70: 6e70 2e61 7361 7272 6179 2872 6573 290a  np.asarray(res).
+00020f80: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00020f90: 2020 7265 735f 6172 7220 3d20 6e70 2e6f    res_arr = np.o
+00020fa0: 6e65 7328 286e 6c6f 732c 292c 2064 7479  nes((nlos,), dty
+00020fb0: 7065 3d66 6c6f 6174 2920 2a20 7265 730a  pe=float) * res.
+00020fc0: 2020 2020 7265 735f 6d76 203d 2072 6573      res_mv = res
+00020fd0: 5f61 7272 0a20 2020 2023 202d 2d2d 2d2d  _arr.    # -----
 00020fe0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00020ff0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00021000: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00021010: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00021020: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2320  ---------.    # 
-00021030: 4d69 6e69 6d69 7a65 2066 756e 6374 696f  Minimize functio
-00021040: 6e20 6361 6c6c 733a 2073 616d 706c 6520  n calls: sample 
-00021050: 2876 6563 7429 2c20 6361 6c6c 2028 6f6e  (vect), call (on
-00021060: 6365 2920 616e 6420 696e 7465 6772 6174  ce) and integrat
-00021070: 650a 2020 2020 6966 206d 696e 696d 203d  e.    if minim =
-00021080: 3d20 2763 616c 6c73 273a 0a20 2020 2020  = 'calls':.     
-00021090: 2020 2069 6620 6e5f 696d 6f64 6520 213d     if n_imode !=
-000210a0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-000210b0: 2320 496e 7465 6772 6174 696f 6e20 6d6f  # Integration mo
-000210c0: 6465 2069 7320 5369 6d70 736f 6e20 6f72  de is Simpson or
-000210d0: 2052 6f6d 6265 7267 0a20 2020 2020 2020   Romberg.       
-000210e0: 2020 2020 2023 2044 6973 6372 6574 697a       # Discretiz
-000210f0: 6520 616c 6c20 4c4f 530a 2020 2020 2020  e all LOS.      
-00021100: 2020 2020 2020 6b2c 2072 6573 6566 662c        k, reseff,
-00021110: 2069 6e64 203d 204c 4f53 5f67 6574 5f73   ind = LOS_get_s
-00021120: 616d 706c 6528 6e6c 6f73 2c20 7265 735f  ample(nlos, res_
-00021130: 6172 722c 206c 696d 732c 0a20 2020 2020  arr, lims,.     
+00021020: 2d2d 2d2d 2d0a 2020 2020 2320 4d69 6e69  -----.    # Mini
+00021030: 6d69 7a65 2066 756e 6374 696f 6e20 6361  mize function ca
+00021040: 6c6c 733a 2073 616d 706c 6520 2876 6563  lls: sample (vec
+00021050: 7429 2c20 6361 6c6c 2028 6f6e 6365 2920  t), call (once) 
+00021060: 616e 6420 696e 7465 6772 6174 650a 2020  and integrate.  
+00021070: 2020 6966 206d 696e 696d 203d 3d20 2763    if minim == 'c
+00021080: 616c 6c73 273a 0a20 2020 2020 2020 2069  alls':.        i
+00021090: 6620 6e5f 696d 6f64 6520 213d 2030 3a0a  f n_imode != 0:.
+000210a0: 2020 2020 2020 2020 2020 2020 2320 496e              # In
+000210b0: 7465 6772 6174 696f 6e20 6d6f 6465 2069  tegration mode i
+000210c0: 7320 5369 6d70 736f 6e20 6f72 2052 6f6d  s Simpson or Rom
+000210d0: 6265 7267 0a20 2020 2020 2020 2020 2020  berg.           
+000210e0: 2023 2044 6973 6372 6574 697a 6520 616c   # Discretize al
+000210f0: 6c20 4c4f 530a 2020 2020 2020 2020 2020  l LOS.          
+00021100: 2020 6b2c 2072 6573 6566 662c 2069 6e64    k, reseff, ind
+00021110: 203d 204c 4f53 5f67 6574 5f73 616d 706c   = LOS_get_sampl
+00021120: 6528 6e6c 6f73 2c20 7265 735f 6172 722c  e(nlos, res_arr,
+00021130: 206c 696d 732c 0a20 2020 2020 2020 2020   lims,.         
 00021140: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021160: 2020 2020 2020 2064 6d65 7468 6f64 3d64         dmethod=d
-00021170: 6d6f 6465 2c20 6d65 7468 6f64 3d69 6d6f  mode, method=imo
-00021180: 6465 2c0a 2020 2020 2020 2020 2020 2020  de,.            
+00021160: 2020 2064 6d65 7468 6f64 3d64 6d6f 6465     dmethod=dmode
+00021170: 2c20 6d65 7468 6f64 3d69 6d6f 6465 2c0a  , method=imode,.
+00021180: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000211a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000211b0: 6e75 6d5f 7468 7265 6164 733d 6e75 6d5f  num_threads=num_
-000211c0: 7468 7265 6164 732c 2054 6573 743d 5465  threads, Test=Te
-000211d0: 7374 290a 2020 2020 2020 2020 2020 2020  st).            
-000211e0: 6e62 7265 7020 3d20 6e70 2e72 5f5b 696e  nbrep = np.r_[in
-000211f0: 645b 305d 2c20 6e70 2e64 6966 6628 696e  d[0], np.diff(in
-00021200: 6429 2c20 6b2e 7369 7a65 202d 2069 6e64  d), k.size - ind
-00021210: 5b6e 6c6f 732d 325d 5d0a 2020 2020 2020  [nlos-2]].      
-00021220: 2020 2020 2020 2320 6765 7420 7074 7320        # get pts 
-00021230: 616e 6420 7661 6c75 6573 0a20 2020 2020  and values.     
-00021240: 2020 2020 2020 2075 7362 6973 203d 206e         usbis = n
-00021250: 702e 7265 7065 6174 2872 6179 5f76 6469  p.repeat(ray_vdi
-00021260: 722c 206e 6272 6570 2c20 6178 6973 3d31  r, nbrep, axis=1
-00021270: 290a 2020 2020 2020 2020 2020 2020 7074  ).            pt
-00021280: 7320 3d20 6e70 2e72 6570 6561 7428 7261  s = np.repeat(ra
-00021290: 795f 6f72 6967 2c20 6e62 7265 702c 2061  y_orig, nbrep, a
-000212a0: 7869 733d 3129 202b 206b 5b4e 6f6e 652c  xis=1) + k[None,
-000212b0: 203a 5d2a 7573 6269 730a 2020 2020 2020   :]*usbis.      
-000212c0: 2020 2020 2020 2320 6d65 6d6f 7279 2076        # memory v
-000212d0: 6965 773a 0a20 2020 2020 2020 2020 2020  iew:.           
-000212e0: 2072 6573 6566 665f 6d76 203d 2072 6573   reseff_mv = res
-000212f0: 6566 660a 2020 2020 2020 2020 2020 2020  eff.            
-00021300: 696e 6462 6973 203d 206e 702e 636f 6e63  indbis = np.conc
-00021310: 6174 656e 6174 6528 285b 305d 2c69 6e64  atenate(([0],ind
-00021320: 2c5b 6b2e 7369 7a65 5d29 290a 2020 2020  ,[k.size])).    
-00021330: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00021340: 2020 2020 2020 636f 6566 665f 7074 7220        coeff_ptr 
-00021350: 3d20 3c64 6f75 626c 652a 2a3e 6d61 6c6c  = <double**>mall
-00021360: 6f63 2873 697a 656f 6628 646f 7562 6c65  oc(sizeof(double
-00021370: 2a29 290a 2020 2020 2020 2020 2020 2020  *)).            
-00021380: 636f 6566 665f 7074 725b 305d 203d 204e  coeff_ptr[0] = N
-00021390: 554c 4c0a 2020 2020 2020 2020 2020 2020  ULL.            
-000213a0: 7265 7365 6666 5f61 7272 203d 203c 646f  reseff_arr = <do
-000213b0: 7562 6c65 2a3e 6d61 6c6c 6f63 286e 6c6f  uble*>malloc(nlo
-000213c0: 732a 7369 7a65 6f66 2864 6f75 626c 6529  s*sizeof(double)
-000213d0: 290a 2020 2020 2020 2020 2020 2020 696e  ).            in
-000213e0: 645f 6172 7220 3d20 3c6c 6f6e 672a 3e6d  d_arr = <long*>m
-000213f0: 616c 6c6f 6328 6e6c 6f73 2a73 697a 656f  alloc(nlos*sizeo
-00021400: 6628 6c6f 6e67 2929 0a20 2020 2020 2020  f(long)).       
-00021410: 2020 2020 2023 202e 2e20 7765 2073 616d       # .. we sam
-00021420: 706c 6520 6c69 6e65 7320 6f66 2073 6967  ple lines of sig
-00021430: 6874 202e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ht .............
+000211a0: 2020 2020 2020 2020 2020 2020 6e75 6d5f              num_
+000211b0: 7468 7265 6164 733d 6e75 6d5f 7468 7265  threads=num_thre
+000211c0: 6164 732c 2054 6573 743d 5465 7374 290a  ads, Test=Test).
+000211d0: 2020 2020 2020 2020 2020 2020 6e62 7265              nbre
+000211e0: 7020 3d20 6e70 2e72 5f5b 696e 645b 305d  p = np.r_[ind[0]
+000211f0: 2c20 6e70 2e64 6966 6628 696e 6429 2c20  , np.diff(ind), 
+00021200: 6b2e 7369 7a65 202d 2069 6e64 5b6e 6c6f  k.size - ind[nlo
+00021210: 732d 325d 5d0a 2020 2020 2020 2020 2020  s-2]].          
+00021220: 2020 2320 6765 7420 7074 7320 616e 6420    # get pts and 
+00021230: 7661 6c75 6573 0a20 2020 2020 2020 2020  values.         
+00021240: 2020 2075 7362 6973 203d 206e 702e 7265     usbis = np.re
+00021250: 7065 6174 2872 6179 5f76 6469 722c 206e  peat(ray_vdir, n
+00021260: 6272 6570 2c20 6178 6973 3d31 290a 2020  brep, axis=1).  
+00021270: 2020 2020 2020 2020 2020 7074 7320 3d20            pts = 
+00021280: 6e70 2e72 6570 6561 7428 7261 795f 6f72  np.repeat(ray_or
+00021290: 6967 2c20 6e62 7265 702c 2061 7869 733d  ig, nbrep, axis=
+000212a0: 3129 202b 206b 5b4e 6f6e 652c 203a 5d2a  1) + k[None, :]*
+000212b0: 7573 6269 730a 2020 2020 2020 2020 2020  usbis.          
+000212c0: 2020 2320 6d65 6d6f 7279 2076 6965 773a    # memory view:
+000212d0: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+000212e0: 6566 665f 6d76 203d 2072 6573 6566 660a  eff_mv = reseff.
+000212f0: 2020 2020 2020 2020 2020 2020 696e 6462              indb
+00021300: 6973 203d 206e 702e 636f 6e63 6174 656e  is = np.concaten
+00021310: 6174 6528 285b 305d 2c69 6e64 2c5b 6b2e  ate(([0],ind,[k.
+00021320: 7369 7a65 5d29 290a 2020 2020 2020 2020  size])).        
+00021330: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00021340: 2020 636f 6566 665f 7074 7220 3d20 3c64    coeff_ptr = <d
+00021350: 6f75 626c 652a 2a3e 6d61 6c6c 6f63 2873  ouble**>malloc(s
+00021360: 697a 656f 6628 646f 7562 6c65 2a29 290a  izeof(double*)).
+00021370: 2020 2020 2020 2020 2020 2020 636f 6566              coef
+00021380: 665f 7074 725b 305d 203d 204e 554c 4c0a  f_ptr[0] = NULL.
+00021390: 2020 2020 2020 2020 2020 2020 7265 7365              rese
+000213a0: 6666 5f61 7272 203d 203c 646f 7562 6c65  ff_arr = <double
+000213b0: 2a3e 6d61 6c6c 6f63 286e 6c6f 732a 7369  *>malloc(nlos*si
+000213c0: 7a65 6f66 2864 6f75 626c 6529 290a 2020  zeof(double)).  
+000213d0: 2020 2020 2020 2020 2020 696e 645f 6172            ind_ar
+000213e0: 7220 3d20 3c6c 6f6e 672a 3e6d 616c 6c6f  r = <long*>mallo
+000213f0: 6328 6e6c 6f73 2a73 697a 656f 6628 6c6f  c(nlos*sizeof(lo
+00021400: 6e67 2929 0a20 2020 2020 2020 2020 2020  ng)).           
+00021410: 2023 202e 2e20 7765 2073 616d 706c 6520   # .. we sample 
+00021420: 6c69 6e65 7320 6f66 2073 6967 6874 202e  lines of sight .
+00021430: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00021440: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00021450: 2e2e 2e2e 2e2e 2e2e 2e0a 2020 2020 2020  ..........      
-00021460: 2020 2020 2020 5f73 742e 6c6f 735f 6765        _st.los_ge
-00021470: 745f 7361 6d70 6c65 5f63 6f72 655f 7661  t_sample_core_va
-00021480: 725f 7265 7328 6e6c 6f73 2c0a 2020 2020  r_res(nlos,.    
+00021450: 2e2e 2e2e 2e0a 2020 2020 2020 2020 2020  ......          
+00021460: 2020 5f73 742e 6c6f 735f 6765 745f 7361    _st.los_get_sa
+00021470: 6d70 6c65 5f63 6f72 655f 7661 725f 7265  mple_core_var_re
+00021480: 7328 6e6c 6f73 2c0a 2020 2020 2020 2020  s(nlos,.        
 00021490: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000214a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000214b0: 2020 2020 2020 2020 266c 696d 735b 302c          &lims[0,
-000214c0: 2030 5d2c 0a20 2020 2020 2020 2020 2020   0],.           
+000214b0: 2020 2020 266c 696d 735b 302c 2030 5d2c      &lims[0, 0],
+000214c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 000214d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000214e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000214f0: 2026 6c69 6d73 5b31 2c20 305d 2c0a 2020   &lims[1, 0],.  
+000214e0: 2020 2020 2020 2020 2020 2020 2026 6c69               &li
+000214f0: 6d73 5b31 2c20 305d 2c0a 2020 2020 2020  ms[1, 0],.      
 00021500: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021520: 2020 2020 2020 2020 2020 6e5f 646d 6f64            n_dmod
-00021530: 652c 206e 5f69 6d6f 6465 2c0a 2020 2020  e, n_imode,.    
+00021520: 2020 2020 2020 6e5f 646d 6f64 652c 206e        n_dmode, n
+00021530: 5f69 6d6f 6465 2c0a 2020 2020 2020 2020  _imode,.        
 00021540: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021560: 2020 2020 2020 2020 2672 6573 5f61 7272          &res_arr
-00021570: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
+00021560: 2020 2020 2672 6573 5f61 7272 5b30 5d2c      &res_arr[0],
+00021570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00021580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000215a0: 2026 636f 6566 665f 7074 725b 305d 2c0a   &coeff_ptr[0],.
+00021590: 2020 2020 2020 2020 2020 2020 2026 636f               &co
+000215a0: 6566 665f 7074 725b 305d 2c0a 2020 2020  eff_ptr[0],.    
 000215b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000215c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000215d0: 2020 2020 2020 2020 2020 2020 2672 6573              &res
-000215e0: 6566 665f 6172 725b 305d 2c0a 2020 2020  eff_arr[0],.    
+000215d0: 2020 2020 2020 2020 2672 6573 6566 665f          &reseff_
+000215e0: 6172 725b 305d 2c0a 2020 2020 2020 2020  arr[0],.        
 000215f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021610: 2020 2020 2020 2020 2669 6e64 5f61 7272          &ind_arr
-00021620: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
+00021610: 2020 2020 2669 6e64 5f61 7272 5b30 5d2c      &ind_arr[0],
+00021620: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00021630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021650: 206e 756d 5f74 6872 6561 6473 290a 2020   num_threads).  
-00021660: 2020 2020 2020 2020 2020 737a 5f63 6f65            sz_coe
-00021670: 6666 203d 2069 6e64 5f61 7272 5b6e 6c6f  ff = ind_arr[nlo
-00021680: 732d 315d 0a20 2020 2020 2020 2020 2020  s-1].           
-00021690: 2070 7473 203d 206e 702e 656d 7074 7928   pts = np.empty(
-000216a0: 2833 2c73 7a5f 636f 6566 6629 290a 2020  (3,sz_coeff)).  
-000216b0: 2020 2020 2020 2020 2020 7573 6269 7320            usbis 
-000216c0: 3d20 6e70 2e65 6d70 7479 2828 332c 737a  = np.empty((3,sz
-000216d0: 5f63 6f65 6666 2929 0a20 2020 2020 2020  _coeff)).       
-000216e0: 2020 2020 2075 7362 6973 5f6d 7620 3d20       usbis_mv = 
-000216f0: 7573 6269 730a 2020 2020 2020 2020 2020  usbis.          
-00021700: 2020 7074 735f 6d76 203d 2070 7473 0a20    pts_mv = pts. 
-00021710: 2020 2020 2020 2020 2020 205f 7374 2e6c             _st.l
-00021720: 6f73 5f67 6574 5f73 616d 706c 655f 7074  os_get_sample_pt
-00021730: 7328 6e6c 6f73 2c0a 2020 2020 2020 2020  s(nlos,.        
+00021640: 2020 2020 2020 2020 2020 2020 206e 756d               num
+00021650: 5f74 6872 6561 6473 290a 2020 2020 2020  _threads).      
+00021660: 2020 2020 2020 737a 5f63 6f65 6666 203d        sz_coeff =
+00021670: 2069 6e64 5f61 7272 5b6e 6c6f 732d 315d   ind_arr[nlos-1]
+00021680: 0a20 2020 2020 2020 2020 2020 2070 7473  .            pts
+00021690: 203d 206e 702e 656d 7074 7928 2833 2c73   = np.empty((3,s
+000216a0: 7a5f 636f 6566 6629 290a 2020 2020 2020  z_coeff)).      
+000216b0: 2020 2020 2020 7573 6269 7320 3d20 6e70        usbis = np
+000216c0: 2e65 6d70 7479 2828 332c 737a 5f63 6f65  .empty((3,sz_coe
+000216d0: 6666 2929 0a20 2020 2020 2020 2020 2020  ff)).           
+000216e0: 2075 7362 6973 5f6d 7620 3d20 7573 6269   usbis_mv = usbi
+000216f0: 730a 2020 2020 2020 2020 2020 2020 7074  s.            pt
+00021700: 735f 6d76 203d 2070 7473 0a20 2020 2020  s_mv = pts.     
+00021710: 2020 2020 2020 205f 7374 2e6c 6f73 5f67         _st.los_g
+00021720: 6574 5f73 616d 706c 655f 7074 7328 6e6c  et_sample_pts(nl
+00021730: 6f73 2c0a 2020 2020 2020 2020 2020 2020  os,.            
 00021740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021750: 2020 2020 2020 2020 2020 2026 7074 735f             &pts_
-00021760: 6d76 5b30 2c30 5d2c 0a20 2020 2020 2020  mv[0,0],.       
+00021750: 2020 2020 2020 2026 7074 735f 6d76 5b30         &pts_mv[0
+00021760: 2c30 5d2c 0a20 2020 2020 2020 2020 2020  ,0],.           
 00021770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021780: 2020 2020 2020 2020 2020 2020 2670 7473              &pts
-00021790: 5f6d 765b 312c 305d 2c0a 2020 2020 2020  _mv[1,0],.      
+00021780: 2020 2020 2020 2020 2670 7473 5f6d 765b          &pts_mv[
+00021790: 312c 305d 2c0a 2020 2020 2020 2020 2020  1,0],.          
 000217a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000217b0: 2020 2020 2020 2020 2020 2020 2026 7074               &pt
-000217c0: 735f 6d76 5b32 2c30 5d2c 0a20 2020 2020  s_mv[2,0],.     
+000217b0: 2020 2020 2020 2020 2026 7074 735f 6d76           &pts_mv
+000217c0: 5b32 2c30 5d2c 0a20 2020 2020 2020 2020  [2,0],.         
 000217d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000217e0: 2020 2020 2020 2020 2020 2020 2020 2675                &u
-000217f0: 7362 6973 5f6d 765b 302c 305d 2c0a 2020  sbis_mv[0,0],.  
+000217e0: 2020 2020 2020 2020 2020 2675 7362 6973            &usbis
+000217f0: 5f6d 765b 302c 305d 2c0a 2020 2020 2020  _mv[0,0],.      
 00021800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021820: 2026 7573 6269 735f 6d76 5b31 2c30 5d2c   &usbis_mv[1,0],
-00021830: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00021810: 2020 2020 2020 2020 2020 2020 2026 7573               &us
+00021820: 6269 735f 6d76 5b31 2c30 5d2c 0a20 2020  bis_mv[1,0],.   
+00021830: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021850: 2020 2020 2675 7362 6973 5f6d 765b 322c      &usbis_mv[2,
-00021860: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+00021850: 2675 7362 6973 5f6d 765b 322c 305d 2c0a  &usbis_mv[2,0],.
+00021860: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021880: 2020 2020 2020 2072 6179 5f6f 7269 672c         ray_orig,
-00021890: 2072 6179 5f76 6469 722c 0a20 2020 2020   ray_vdir,.     
+00021880: 2020 2072 6179 5f6f 7269 672c 2072 6179     ray_orig, ray
+00021890: 5f76 6469 722c 0a20 2020 2020 2020 2020  _vdir,.         
 000218a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000218b0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-000218c0: 6566 665f 7074 725b 305d 2c0a 2020 2020  eff_ptr[0],.    
+000218b0: 2020 2020 2020 2020 2020 636f 6566 665f            coeff_
+000218c0: 7074 725b 305d 2c0a 2020 2020 2020 2020  ptr[0],.        
 000218d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000218e0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000218f0: 6e64 5f61 7272 2c0a 2020 2020 2020 2020  nd_arr,.        
+000218e0: 2020 2020 2020 2020 2020 2069 6e64 5f61             ind_a
+000218f0: 7272 2c0a 2020 2020 2020 2020 2020 2020  rr,.            
 00021900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021910: 2020 2020 2020 2020 2020 206e 756d 5f74             num_t
-00021920: 6872 6561 6473 290a 2020 2020 2020 2020  hreads).        
-00021930: 2020 2020 2320 2e2e 2e2e 2e2e 2e2e 2e2e      # ..........
+00021910: 2020 2020 2020 206e 756d 5f74 6872 6561         num_threa
+00021920: 6473 290a 2020 2020 2020 2020 2020 2020  ds).            
+00021930: 2320 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  # ..............
 00021940: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00021950: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00021960: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00021970: 2e2e 2e2e 2e2e 2e2e 0a20 2020 2020 2020  .........       
-00021980: 2069 6620 616e 693a 0a20 2020 2020 2020   if ani:.       
-00021990: 2020 2020 2076 616c 5f32 6420 3d20 6675       val_2d = fu
-000219a0: 6e63 2870 7473 2c20 743d 742c 2076 6563  nc(pts, t=t, vec
-000219b0: 743d 2d75 7362 6973 2c20 2a2a 666b 7764  t=-usbis, **fkwd
-000219c0: 6172 6773 290a 2020 2020 2020 2020 656c  args).        el
-000219d0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000219e0: 7661 6c5f 3264 203d 2066 756e 6328 7074  val_2d = func(pt
-000219f0: 732c 2074 3d74 2c20 2a2a 666b 7764 6172  s, t=t, **fkwdar
-00021a00: 6773 290a 0a20 2020 2020 2020 2023 2049  gs)..        # I
-00021a10: 6e74 6567 7261 7465 0a20 2020 2020 2020  ntegrate.       
-00021a20: 2069 6620 6e5f 696d 6f64 6520 3d3d 2030   if n_imode == 0
-00021a30: 3a20 2023 2022 7375 6d22 2069 6e74 6567  :  # "sum" integ
-00021a40: 7261 7469 6f6e 206d 6f64 650a 2020 2020  ration mode.    
-00021a50: 2020 2020 2020 2020 2320 2e2e 2069 6e74          # .. int
-00021a60: 6567 7261 7469 6e67 2066 756e 6374 696f  egrating functio
-00021a70: 6e20 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  n ..............
+00021970: 2e2e 2e2e 0a20 2020 2020 2020 2069 6620  .....        if 
+00021980: 616e 693a 0a20 2020 2020 2020 2020 2020  ani:.           
+00021990: 2076 616c 5f32 6420 3d20 6675 6e63 2870   val_2d = func(p
+000219a0: 7473 2c20 743d 742c 2076 6563 743d 2d75  ts, t=t, vect=-u
+000219b0: 7362 6973 2c20 2a2a 666b 7764 6172 6773  sbis, **fkwdargs
+000219c0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+000219d0: 2020 2020 2020 2020 2020 2020 7661 6c5f              val_
+000219e0: 3264 203d 2066 756e 6328 7074 732c 2074  2d = func(pts, t
+000219f0: 3d74 2c20 2a2a 666b 7764 6172 6773 290a  =t, **fkwdargs).
+00021a00: 0a20 2020 2020 2020 2023 2049 6e74 6567  .        # Integ
+00021a10: 7261 7465 0a20 2020 2020 2020 2069 6620  rate.        if 
+00021a20: 6e5f 696d 6f64 6520 3d3d 2030 3a20 2023  n_imode == 0:  #
+00021a30: 2022 7375 6d22 2069 6e74 6567 7261 7469   "sum" integrati
+00021a40: 6f6e 206d 6f64 650a 2020 2020 2020 2020  on mode.        
+00021a50: 2020 2020 2320 2e2e 2069 6e74 6567 7261      # .. integra
+00021a60: 7469 6e67 2066 756e 6374 696f 6e20 2e2e  ting function ..
+00021a70: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00021a80: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00021a90: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020  .............   
-00021aa0: 2020 2020 2020 2020 2072 6573 6566 6673           reseffs
-00021ab0: 203d 206e 702e 636f 7079 286e 702e 6173   = np.copy(np.as
-00021ac0: 6172 7261 7928 3c64 6f75 626c 655b 3a6e  array(<double[:n
-00021ad0: 6c6f 735d 3e72 6573 6566 665f 6172 7229  los]>reseff_arr)
-00021ae0: 290a 2020 2020 2020 2020 2020 2020 696e  ).            in
-00021af0: 6469 6365 7320 3d20 6e70 2e63 6f70 7928  dices = np.copy(
-00021b00: 6e70 2e61 7361 7272 6179 283c 6c6f 6e67  np.asarray(<long
-00021b10: 5b3a 6e6c 6f73 2d31 5d3e 696e 645f 6172  [:nlos-1]>ind_ar
-00021b20: 7229 2e61 7374 7970 6528 696e 7429 290a  r).astype(int)).
-00021b30: 2020 2020 2020 2020 2020 2020 7369 6720              sig 
-00021b40: 3d20 6e70 2e61 7366 6f72 7472 616e 6172  = np.asfortranar
-00021b50: 7261 7928 6e70 2e61 6464 2e72 6564 7563  ray(np.add.reduc
-00021b60: 6561 7428 7661 6c5f 3264 2c0a 2020 2020  eat(val_2d,.    
+00021a90: 2e2e 2e2e 2e2e 2e2e 0a20 2020 2020 2020  .........       
+00021aa0: 2020 2020 2072 6573 6566 6673 203d 206e       reseffs = n
+00021ab0: 702e 636f 7079 286e 702e 6173 6172 7261  p.copy(np.asarra
+00021ac0: 7928 3c64 6f75 626c 655b 3a6e 6c6f 735d  y(<double[:nlos]
+00021ad0: 3e72 6573 6566 665f 6172 7229 290a 2020  >reseff_arr)).  
+00021ae0: 2020 2020 2020 2020 2020 696e 6469 6365            indice
+00021af0: 7320 3d20 6e70 2e63 6f70 7928 6e70 2e61  s = np.copy(np.a
+00021b00: 7361 7272 6179 283c 6c6f 6e67 5b3a 6e6c  sarray(<long[:nl
+00021b10: 6f73 2d31 5d3e 696e 645f 6172 7229 2e61  os-1]>ind_arr).a
+00021b20: 7374 7970 6528 696e 7429 290a 2020 2020  stype(int)).    
+00021b30: 2020 2020 2020 2020 7369 6720 3d20 6e70          sig = np
+00021b40: 2e61 7366 6f72 7472 616e 6172 7261 7928  .asfortranarray(
+00021b50: 6e70 2e61 6464 2e72 6564 7563 6561 7428  np.add.reduceat(
+00021b60: 7661 6c5f 3264 2c0a 2020 2020 2020 2020  val_2d,.        
 00021b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021ba0: 6e70 2e72 5f5b 302c 2069 6e64 6963 6573  np.r_[0, indices
-00021bb0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00021b90: 2020 2020 2020 2020 2020 2020 6e70 2e72              np.r
+00021ba0: 5f5b 302c 2069 6e64 6963 6573 5d2c 0a20  _[0, indices],. 
+00021bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021be0: 2020 2020 2020 2061 7869 733d 2d31 290a         axis=-1).
+00021be0: 2020 2061 7869 733d 2d31 290a 2020 2020     axis=-1).    
 00021bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021c10: 2020 2020 2a20 7265 7365 6666 735b 4e6f      * reseffs[No
-00021c20: 6e65 2c20 3a5d 290a 2020 2020 2020 2020  ne, :]).        
-00021c30: 2020 2020 2320 436c 6561 6e69 6e67 2075      # Cleaning u
-00021c40: 702e 2e2e 0a20 2020 2020 2020 2020 2020  p....           
-00021c50: 2066 7265 6528 636f 6566 665f 7074 725b   free(coeff_ptr[
-00021c60: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
-00021c70: 6672 6565 2863 6f65 6666 5f70 7472 290a  free(coeff_ptr).
-00021c80: 2020 2020 2020 2020 2020 2020 6672 6565              free
-00021c90: 2872 6573 6566 665f 6172 7229 0a20 2020  (reseff_arr).   
-00021ca0: 2020 2020 2020 2020 2066 7265 6528 696e           free(in
-00021cb0: 645f 6172 7229 0a20 2020 2020 2020 2065  d_arr).        e
-00021cc0: 6c69 6620 6e5f 696d 6f64 6520 3d3d 2031  lif n_imode == 1
-00021cd0: 3a20 2023 2022 7369 6d70 736f 6e22 2069  :  # "simpson" i
-00021ce0: 6e74 6567 7261 7469 6f6e 206d 6f64 650a  ntegration mode.
-00021cf0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00021d00: 6969 2069 6e20 7261 6e67 6528 6e6c 6f73  ii in range(nlos
-00021d10: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00021d20: 2020 206a 6a20 3d20 696e 6462 6973 5b69     jj = indbis[i
-00021d30: 695d 0a20 2020 2020 2020 2020 2020 2020  i].             
-00021d40: 2020 206a 6a70 3120 3d20 696e 6462 6973     jjp1 = indbis
-00021d50: 5b69 692b 315d 0a20 2020 2020 2020 2020  [ii+1].         
-00021d60: 2020 2020 2020 2076 616c 5f6d 7620 3d20         val_mv = 
-00021d70: 7661 6c5f 3264 5b3a 2c6a 6a3a 6a6a 7031  val_2d[:,jj:jjp1
-00021d80: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00021d90: 2020 6c6f 635f 7220 3d20 7265 7365 6666    loc_r = reseff
-00021da0: 5f6d 765b 6969 5d0a 2020 2020 2020 2020  _mv[ii].        
-00021db0: 2020 2020 2020 2020 7369 675b 3a2c 6969          sig[:,ii
-00021dc0: 5d20 3d20 7363 7069 6e74 672e 7369 6d70  ] = scpintg.simp
-00021dd0: 7328 7661 6c5f 6d76 2c0a 2020 2020 2020  s(val_mv,.      
+00021c10: 2a20 7265 7365 6666 735b 4e6f 6e65 2c20  * reseffs[None, 
+00021c20: 3a5d 290a 2020 2020 2020 2020 2020 2020  :]).            
+00021c30: 2320 436c 6561 6e69 6e67 2075 702e 2e2e  # Cleaning up...
+00021c40: 0a20 2020 2020 2020 2020 2020 2066 7265  .            fre
+00021c50: 6528 636f 6566 665f 7074 725b 305d 290a  e(coeff_ptr[0]).
+00021c60: 2020 2020 2020 2020 2020 2020 6672 6565              free
+00021c70: 2863 6f65 6666 5f70 7472 290a 2020 2020  (coeff_ptr).    
+00021c80: 2020 2020 2020 2020 6672 6565 2872 6573          free(res
+00021c90: 6566 665f 6172 7229 0a20 2020 2020 2020  eff_arr).       
+00021ca0: 2020 2020 2066 7265 6528 696e 645f 6172       free(ind_ar
+00021cb0: 7229 0a20 2020 2020 2020 2065 6c69 6620  r).        elif 
+00021cc0: 6e5f 696d 6f64 6520 3d3d 2031 3a20 2023  n_imode == 1:  #
+00021cd0: 2022 7369 6d70 736f 6e22 2069 6e74 6567   "simpson" integ
+00021ce0: 7261 7469 6f6e 206d 6f64 650a 2020 2020  ration mode.    
+00021cf0: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
+00021d00: 6e20 7261 6e67 6528 6e6c 6f73 293a 0a20  n range(nlos):. 
+00021d10: 2020 2020 2020 2020 2020 2020 2020 206a                 j
+00021d20: 6a20 3d20 696e 6462 6973 5b69 695d 0a20  j = indbis[ii]. 
+00021d30: 2020 2020 2020 2020 2020 2020 2020 206a                 j
+00021d40: 6a70 3120 3d20 696e 6462 6973 5b69 692b  jp1 = indbis[ii+
+00021d50: 315d 0a20 2020 2020 2020 2020 2020 2020  1].             
+00021d60: 2020 2076 616c 5f6d 7620 3d20 7661 6c5f     val_mv = val_
+00021d70: 3264 5b3a 2c6a 6a3a 6a6a 7031 5d0a 2020  2d[:,jj:jjp1].  
+00021d80: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
+00021d90: 635f 7220 3d20 7265 7365 6666 5f6d 765b  c_r = reseff_mv[
+00021da0: 6969 5d0a 2020 2020 2020 2020 2020 2020  ii].            
+00021db0: 2020 2020 7369 675b 3a2c 6969 5d20 3d20      sig[:,ii] = 
+00021dc0: 7363 7069 6e74 672e 7369 6d70 7328 7661  scpintg.simps(va
+00021dd0: 6c5f 6d76 2c0a 2020 2020 2020 2020 2020  l_mv,.          
 00021de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021e00: 2020 2020 2020 2078 3d4e 6f6e 652c 2064         x=None, d
-00021e10: 783d 6c6f 635f 722c 2061 7869 733d 2d31  x=loc_r, axis=-1
-00021e20: 290a 2020 2020 2020 2020 656c 7365 3a20  ).        else: 
-00021e30: 2023 2052 6f6d 6265 7267 2069 6e74 6567   # Romberg integ
-00021e40: 7261 7469 6f6e 206d 6f64 650a 2020 2020  ration mode.    
-00021e50: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
-00021e60: 6e20 7261 6e67 6528 6e6c 6f73 293a 0a20  n range(nlos):. 
-00021e70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00021e80: 6967 5b3a 2c69 695d 203d 2073 6370 696e  ig[:,ii] = scpin
-00021e90: 7467 2e72 6f6d 6228 7661 6c5f 3264 5b3a  tg.romb(val_2d[:
-00021ea0: 2c69 6e64 6269 735b 6969 5d3a 696e 6462  ,indbis[ii]:indb
-00021eb0: 6973 5b69 692b 315d 5d2c 0a20 2020 2020  is[ii+1]],.     
+00021e00: 2020 2078 3d4e 6f6e 652c 2064 783d 6c6f     x=None, dx=lo
+00021e10: 635f 722c 2061 7869 733d 2d31 290a 2020  c_r, axis=-1).  
+00021e20: 2020 2020 2020 656c 7365 3a20 2023 2052        else:  # R
+00021e30: 6f6d 6265 7267 2069 6e74 6567 7261 7469  omberg integrati
+00021e40: 6f6e 206d 6f64 650a 2020 2020 2020 2020  on mode.        
+00021e50: 2020 2020 666f 7220 6969 2069 6e20 7261      for ii in ra
+00021e60: 6e67 6528 6e6c 6f73 293a 0a20 2020 2020  nge(nlos):.     
+00021e70: 2020 2020 2020 2020 2020 2073 6967 5b3a             sig[:
+00021e80: 2c69 695d 203d 2073 6370 696e 7467 2e72  ,ii] = scpintg.r
+00021e90: 6f6d 6228 7661 6c5f 3264 5b3a 2c69 6e64  omb(val_2d[:,ind
+00021ea0: 6269 735b 6969 5d3a 696e 6462 6973 5b69  bis[ii]:indbis[i
+00021eb0: 692b 315d 5d2c 0a20 2020 2020 2020 2020  i+1]],.         
 00021ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00021ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021ee0: 2020 2020 6478 3d72 6573 6566 665f 6d76      dx=reseff_mv
-00021ef0: 5b69 695d 2c20 6178 6973 3d31 2c20 7368  [ii], axis=1, sh
-00021f00: 6f77 3d46 616c 7365 290a 2020 2020 2320  ow=False).    # 
+00021ee0: 6478 3d72 6573 6566 665f 6d76 5b69 695d  dx=reseff_mv[ii]
+00021ef0: 2c20 6178 6973 3d31 2c20 7368 6f77 3d46  , axis=1, show=F
+00021f00: 616c 7365 290a 2020 2020 2320 2d2d 2d2d  alse).    # ----
 00021f10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00021f20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00021f30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00021f40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00021f50: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2023  ----------.    #
-00021f60: 204d 696e 696d 697a 6520 6d65 6d6f 7279   Minimize memory
-00021f70: 2075 7365 3a20 6c6f 6f70 2065 7665 7279   use: loop every
-00021f80: 7468 696e 672c 2073 7461 7274 696e 6720  thing, starting 
-00021f90: 7769 7468 204c 4f53 0a20 2020 2023 2074  with LOS.    # t
-00021fa0: 6865 6e20 7074 7320 7468 656e 2074 696d  hen pts then tim
-00021fb0: 650a 2020 2020 656c 6966 206d 696e 696d  e.    elif minim
-00021fc0: 203d 3d20 276d 656d 6f72 7927 3a0a 2020   == 'memory':.  
-00021fd0: 2020 2020 2020 2320 6c6f 6f70 206f 7665        # loop ove
-00021fe0: 7220 4c4f 5320 616e 6420 7061 7261 6c6c  r LOS and parall
-00021ff0: 656c 697a 650a 2020 2020 2020 2020 6966  elize.        if
-00022000: 2061 6e69 3a0a 2020 2020 2020 2020 2020   ani:.          
-00022010: 2020 6966 206e 5f69 6d6f 6465 203d 3d20    if n_imode == 
-00022020: 303a 2020 2320 7375 6d20 696e 7465 6772  0:  # sum integr
-00022030: 6174 696f 6e20 6d6f 6465 0a20 2020 2020  ation mode.     
-00022040: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
-00022050: 6920 696e 2072 616e 6765 286e 6c6f 7329  i in range(nlos)
-00022060: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00022070: 2020 2020 2020 7074 732c 2075 7362 6973        pts, usbis
-00022080: 203d 205f 7374 2e63 616c 6c5f 6765 745f   = _st.call_get_
-00022090: 7361 6d70 6c65 5f73 696e 676c 655f 616e  sample_single_an
-000220a0: 6928 6c69 6d73 5b30 2c20 6969 5d2c 0a20  i(lims[0, ii],. 
+00021f50: 2d2d 2d2d 2d2d 0a20 2020 2023 204d 696e  ------.    # Min
+00021f60: 696d 697a 6520 6d65 6d6f 7279 2075 7365  imize memory use
+00021f70: 3a20 6c6f 6f70 2065 7665 7279 7468 696e  : loop everythin
+00021f80: 672c 2073 7461 7274 696e 6720 7769 7468  g, starting with
+00021f90: 204c 4f53 0a20 2020 2023 2074 6865 6e20   LOS.    # then 
+00021fa0: 7074 7320 7468 656e 2074 696d 650a 2020  pts then time.  
+00021fb0: 2020 656c 6966 206d 696e 696d 203d 3d20    elif minim == 
+00021fc0: 276d 656d 6f72 7927 3a0a 2020 2020 2020  'memory':.      
+00021fd0: 2020 2320 6c6f 6f70 206f 7665 7220 4c4f    # loop over LO
+00021fe0: 5320 616e 6420 7061 7261 6c6c 656c 697a  S and paralleliz
+00021ff0: 650a 2020 2020 2020 2020 6966 2061 6e69  e.        if ani
+00022000: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00022010: 206e 5f69 6d6f 6465 203d 3d20 303a 2020   n_imode == 0:  
+00022020: 2320 7375 6d20 696e 7465 6772 6174 696f  # sum integratio
+00022030: 6e20 6d6f 6465 0a20 2020 2020 2020 2020  n mode.         
+00022040: 2020 2020 2020 2066 6f72 2069 6920 696e         for ii in
+00022050: 2072 616e 6765 286e 6c6f 7329 3a0a 2020   range(nlos):.  
+00022060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022070: 2020 7074 732c 2075 7362 6973 203d 205f    pts, usbis = _
+00022080: 7374 2e63 616c 6c5f 6765 745f 7361 6d70  st.call_get_samp
+00022090: 6c65 5f73 696e 676c 655f 616e 6928 6c69  le_single_ani(li
+000220a0: 6d73 5b30 2c20 6969 5d2c 0a20 2020 2020  ms[0, ii],.     
 000220b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000220c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000220d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000220e0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-000220f0: 696d 735b 312c 2069 695d 2c0a 2020 2020  ims[1, ii],.    
+000220e0: 2020 2020 2020 2020 2020 206c 696d 735b             lims[
+000220f0: 312c 2069 695d 2c0a 2020 2020 2020 2020  1, ii],.        
 00022100: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022110: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022130: 2020 2020 2020 2020 2020 2020 7265 735f              res_
-00022140: 6d76 5b69 695d 2c0a 2020 2020 2020 2020  mv[ii],.        
+00022130: 2020 2020 2020 2020 7265 735f 6d76 5b69          res_mv[i
+00022140: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
 00022150: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022160: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022180: 2020 2020 2020 2020 6e5f 646d 6f64 652c          n_dmode,
-00022190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00022180: 2020 2020 6e5f 646d 6f64 652c 0a20 2020      n_dmode,.   
+00022190: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000221a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000221b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000221c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000221d0: 206e 5f69 6d6f 6465 2c0a 2020 2020 2020   n_imode,.      
+000221c0: 2020 2020 2020 2020 2020 2020 206e 5f69               n_i
+000221d0: 6d6f 6465 2c0a 2020 2020 2020 2020 2020  mode,.          
 000221e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000221f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022210: 2020 2020 2020 2020 2020 266c 6f63 5f65            &loc_e
-00022220: 6666 5f72 6573 5b30 5d2c 0a20 2020 2020  ff_res[0],.     
+00022210: 2020 2020 2020 266c 6f63 5f65 6666 5f72        &loc_eff_r
+00022220: 6573 5b30 5d2c 0a20 2020 2020 2020 2020  es[0],.         
 00022230: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022240: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022260: 2020 2020 2020 2020 2020 2026 6e62 5f72             &nb_r
-00022270: 6f77 735b 305d 2c0a 2020 2020 2020 2020  ows[0],.        
+00022260: 2020 2020 2020 2026 6e62 5f72 6f77 735b         &nb_rows[
+00022270: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
 00022280: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022290: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000222a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000222b0: 2020 2020 2020 2020 7261 795f 6f72 6967          ray_orig
-000222c0: 5b3a 2c20 6969 3a69 692b 315d 2c0a 2020  [:, ii:ii+1],.  
+000222b0: 2020 2020 7261 795f 6f72 6967 5b3a 2c20      ray_orig[:, 
+000222c0: 6969 3a69 692b 315d 2c0a 2020 2020 2020  ii:ii+1],.      
 000222d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000222e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000222f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022300: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-00022310: 795f 7664 6972 5b3a 2c20 6969 3a69 692b  y_vdir[:, ii:ii+
-00022320: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
-00022330: 2020 2020 2020 2020 2320 6c6f 6f70 206f          # loop o
-00022340: 7665 7220 7469 6d65 2066 6f72 2063 616c  ver time for cal
-00022350: 6c69 6e67 2061 6e64 2069 6e74 6567 7261  ling and integra
-00022360: 7469 6e67 0a20 2020 2020 2020 2020 2020  ting.           
-00022370: 2020 2020 2020 2020 2066 6f72 206a 6a20           for jj 
-00022380: 696e 2072 616e 6765 286e 7429 3a0a 2020  in range(nt):.  
+00022300: 2020 2020 2020 2020 2020 7261 795f 7664            ray_vd
+00022310: 6972 5b3a 2c20 6969 3a69 692b 315d 290a  ir[:, ii:ii+1]).
+00022320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022330: 2020 2020 2320 6c6f 6f70 206f 7665 7220      # loop over 
+00022340: 7469 6d65 2066 6f72 2063 616c 6c69 6e67  time for calling
+00022350: 2061 6e64 2069 6e74 6567 7261 7469 6e67   and integrating
+00022360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00022370: 2020 2020 2066 6f72 206a 6a20 696e 2072       for jj in r
+00022380: 616e 6765 286e 7429 3a0a 2020 2020 2020  ange(nt):.      
 00022390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000223a0: 2020 2020 2020 7661 6c20 3d20 6675 6e63        val = func
-000223b0: 2870 7473 2c20 743d 6c74 696d 655b 6a6a  (pts, t=ltime[jj
-000223c0: 5d2c 2076 6563 743d 2d75 7362 6973 2c20  ], vect=-usbis, 
-000223d0: 2a2a 666b 7764 6172 6773 290a 2020 2020  **fkwdargs).    
+000223a0: 2020 7661 6c20 3d20 6675 6e63 2870 7473    val = func(pts
+000223b0: 2c20 743d 6c74 696d 655b 6a6a 5d2c 2076  , t=ltime[jj], v
+000223c0: 6563 743d 2d75 7362 6973 2c20 2a2a 666b  ect=-usbis, **fk
+000223d0: 7764 6172 6773 290a 2020 2020 2020 2020  wdargs).        
 000223e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000223f0: 2020 2020 7369 675b 6a6a 2c20 6969 5d20      sig[jj, ii] 
-00022400: 3d20 6e70 2e73 756d 2876 616c 292a 6c6f  = np.sum(val)*lo
-00022410: 635f 6566 665f 7265 735b 305d 0a20 2020  c_eff_res[0].   
-00022420: 2020 2020 2020 2020 2065 6c69 6620 6e5f           elif n_
-00022430: 696d 6f64 6520 3d3d 2031 3a20 2023 2073  imode == 1:  # s
-00022440: 696d 7073 6f6e 2069 6e74 6567 7261 7469  impson integrati
-00022450: 6f6e 206d 6f64 650a 2020 2020 2020 2020  on mode.        
-00022460: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
-00022470: 6e20 7261 6e67 6528 6e6c 6f73 293a 0a20  n range(nlos):. 
-00022480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022490: 2020 2070 7473 2c20 7573 6269 7320 3d20     pts, usbis = 
-000224a0: 5f73 742e 6361 6c6c 5f67 6574 5f73 616d  _st.call_get_sam
-000224b0: 706c 655f 7369 6e67 6c65 5f61 6e69 286c  ple_single_ani(l
-000224c0: 696d 735b 302c 2069 695d 2c0a 2020 2020  ims[0, ii],.    
+000223f0: 7369 675b 6a6a 2c20 6969 5d20 3d20 6e70  sig[jj, ii] = np
+00022400: 2e73 756d 2876 616c 292a 6c6f 635f 6566  .sum(val)*loc_ef
+00022410: 665f 7265 735b 305d 0a20 2020 2020 2020  f_res[0].       
+00022420: 2020 2020 2065 6c69 6620 6e5f 696d 6f64       elif n_imod
+00022430: 6520 3d3d 2031 3a20 2023 2073 696d 7073  e == 1:  # simps
+00022440: 6f6e 2069 6e74 6567 7261 7469 6f6e 206d  on integration m
+00022450: 6f64 650a 2020 2020 2020 2020 2020 2020  ode.            
+00022460: 2020 2020 666f 7220 6969 2069 6e20 7261      for ii in ra
+00022470: 6e67 6528 6e6c 6f73 293a 0a20 2020 2020  nge(nlos):.     
+00022480: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00022490: 7473 2c20 7573 6269 7320 3d20 5f73 742e  ts, usbis = _st.
+000224a0: 6361 6c6c 5f67 6574 5f73 616d 706c 655f  call_get_sample_
+000224b0: 7369 6e67 6c65 5f61 6e69 286c 696d 735b  single_ani(lims[
+000224c0: 302c 2069 695d 2c0a 2020 2020 2020 2020  0, ii],.        
 000224d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000224e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000224f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022500: 2020 2020 2020 2020 2020 2020 6c69 6d73              lims
-00022510: 5b31 2c20 6969 5d2c 0a20 2020 2020 2020  [1, ii],.       
+00022500: 2020 2020 2020 2020 6c69 6d73 5b31 2c20          lims[1, 
+00022510: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
 00022520: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022530: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022550: 2020 2020 2020 2020 2072 6573 5f6d 765b           res_mv[
-00022560: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
+00022550: 2020 2020 2072 6573 5f6d 765b 6969 5d2c       res_mv[ii],
+00022560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00022570: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022580: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000225a0: 2020 2020 206e 5f64 6d6f 6465 2c20 6e5f       n_dmode, n_
-000225b0: 696d 6f64 652c 0a20 2020 2020 2020 2020  imode,.         
+000225a0: 206e 5f64 6d6f 6465 2c20 6e5f 696d 6f64   n_dmode, n_imod
+000225b0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
 000225c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000225d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000225e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000225f0: 2020 2020 2020 2026 6c6f 635f 6566 665f         &loc_eff_
-00022600: 7265 735b 305d 2c0a 2020 2020 2020 2020  res[0],.        
+000225f0: 2020 2026 6c6f 635f 6566 665f 7265 735b     &loc_eff_res[
+00022600: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
 00022610: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022620: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022640: 2020 2020 2020 2020 266e 625f 726f 7773          &nb_rows
-00022650: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
+00022640: 2020 2020 266e 625f 726f 7773 5b30 5d2c      &nb_rows[0],
+00022650: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00022660: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022670: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022690: 2020 2020 2072 6179 5f6f 7269 675b 3a2c       ray_orig[:,
-000226a0: 6969 3a69 692b 315d 2c0a 2020 2020 2020  ii:ii+1],.      
+00022690: 2072 6179 5f6f 7269 675b 3a2c 6969 3a69   ray_orig[:,ii:i
+000226a0: 692b 315d 2c0a 2020 2020 2020 2020 2020  i+1],.          
 000226b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000226c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000226d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000226e0: 2020 2020 2020 2020 2020 7261 795f 7664            ray_vd
-000226f0: 6972 5b3a 2c69 693a 6969 2b31 5d29 0a20  ir[:,ii:ii+1]). 
-00022700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022710: 2020 2023 206c 6f6f 7020 6f76 6572 2074     # loop over t
-00022720: 696d 6520 666f 7220 6361 6c6c 696e 6720  ime for calling 
-00022730: 616e 6420 696e 7465 6772 6174 696e 670a  and integrating.
+000226e0: 2020 2020 2020 7261 795f 7664 6972 5b3a        ray_vdir[:
+000226f0: 2c69 693a 6969 2b31 5d29 0a20 2020 2020  ,ii:ii+1]).     
+00022700: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00022710: 206c 6f6f 7020 6f76 6572 2074 696d 6520   loop over time 
+00022720: 666f 7220 6361 6c6c 696e 6720 616e 6420  for calling and 
+00022730: 696e 7465 6772 6174 696e 670a 2020 2020  integrating.    
 00022740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022750: 2020 2020 666f 7220 6a6a 2069 6e20 7261      for jj in ra
-00022760: 6e67 6528 6e74 293a 0a20 2020 2020 2020  nge(nt):.       
-00022770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022780: 2076 616c 203d 2066 756e 6328 7074 732c   val = func(pts,
-00022790: 2074 3d6c 7469 6d65 5b6a 6a5d 2c20 7665   t=ltime[jj], ve
-000227a0: 6374 3d2d 7573 6269 732c 202a 2a66 6b77  ct=-usbis, **fkw
-000227b0: 6461 7267 7329 0a20 2020 2020 2020 2020  dargs).         
-000227c0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000227d0: 6967 5b6a 6a2c 2069 695d 203d 2073 6370  ig[jj, ii] = scp
-000227e0: 696e 7467 2e73 696d 7073 2876 616c 2c20  intg.simps(val, 
-000227f0: 783d 4e6f 6e65 2c0a 2020 2020 2020 2020  x=None,.        
+00022750: 666f 7220 6a6a 2069 6e20 7261 6e67 6528  for jj in range(
+00022760: 6e74 293a 0a20 2020 2020 2020 2020 2020  nt):.           
+00022770: 2020 2020 2020 2020 2020 2020 2076 616c               val
+00022780: 203d 2066 756e 6328 7074 732c 2074 3d6c   = func(pts, t=l
+00022790: 7469 6d65 5b6a 6a5d 2c20 7665 6374 3d2d  time[jj], vect=-
+000227a0: 7573 6269 732c 202a 2a66 6b77 6461 7267  usbis, **fkwdarg
+000227b0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+000227c0: 2020 2020 2020 2020 2020 2073 6967 5b6a             sig[j
+000227d0: 6a2c 2069 695d 203d 2073 6370 696e 7467  j, ii] = scpintg
+000227e0: 2e73 696d 7073 2876 616c 2c20 783d 4e6f  .simps(val, x=No
+000227f0: 6e65 2c0a 2020 2020 2020 2020 2020 2020  ne,.            
 00022800: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022820: 2020 2020 2020 2020 2020 2020 6478 3d6c              dx=l
-00022830: 6f63 5f65 6666 5f72 6573 5b30 5d29 0a20  oc_eff_res[0]). 
-00022840: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-00022850: 6e5f 696d 6f64 6520 3d3d 2032 3a20 2023  n_imode == 2:  #
-00022860: 2072 6f6d 6265 7267 2069 6e74 6567 7261   romberg integra
-00022870: 7469 6f6e 206d 6f64 650a 2020 2020 2020  tion mode.      
-00022880: 2020 2020 2020 2020 2020 666f 7220 6969            for ii
-00022890: 2069 6e20 7261 6e67 6528 6e6c 6f73 293a   in range(nlos):
-000228a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000228b0: 2020 2020 2070 7473 2c20 7573 6269 7320       pts, usbis 
-000228c0: 3d20 5f73 742e 6361 6c6c 5f67 6574 5f73  = _st.call_get_s
-000228d0: 616d 706c 655f 7369 6e67 6c65 5f61 6e69  ample_single_ani
-000228e0: 286c 696d 735b 302c 2069 695d 2c0a 2020  (lims[0, ii],.  
+00022820: 2020 2020 2020 2020 6478 3d6c 6f63 5f65          dx=loc_e
+00022830: 6666 5f72 6573 5b30 5d29 0a20 2020 2020  ff_res[0]).     
+00022840: 2020 2020 2020 2065 6c69 6620 6e5f 696d         elif n_im
+00022850: 6f64 6520 3d3d 2032 3a20 2023 2072 6f6d  ode == 2:  # rom
+00022860: 6265 7267 2069 6e74 6567 7261 7469 6f6e  berg integration
+00022870: 206d 6f64 650a 2020 2020 2020 2020 2020   mode.          
+00022880: 2020 2020 2020 666f 7220 6969 2069 6e20        for ii in 
+00022890: 7261 6e67 6528 6e6c 6f73 293a 0a20 2020  range(nlos):.   
+000228a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000228b0: 2070 7473 2c20 7573 6269 7320 3d20 5f73   pts, usbis = _s
+000228c0: 742e 6361 6c6c 5f67 6574 5f73 616d 706c  t.call_get_sampl
+000228d0: 655f 7369 6e67 6c65 5f61 6e69 286c 696d  e_single_ani(lim
+000228e0: 735b 302c 2069 695d 2c0a 2020 2020 2020  s[0, ii],.      
 000228f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022900: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022920: 2020 2020 2020 2020 2020 2020 2020 6c69                li
-00022930: 6d73 5b31 2c20 6969 5d2c 0a20 2020 2020  ms[1, ii],.     
+00022920: 2020 2020 2020 2020 2020 6c69 6d73 5b31            lims[1
+00022930: 2c20 6969 5d2c 0a20 2020 2020 2020 2020  , ii],.         
 00022940: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022950: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022970: 2020 2020 2020 2020 2020 2072 6573 5f6d             res_m
-00022980: 765b 6969 5d2c 0a20 2020 2020 2020 2020  v[ii],.         
+00022970: 2020 2020 2020 2072 6573 5f6d 765b 6969         res_mv[ii
+00022980: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 00022990: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000229a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000229b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000229c0: 2020 2020 2020 206e 5f64 6d6f 6465 2c20         n_dmode, 
-000229d0: 6e5f 696d 6f64 652c 0a20 2020 2020 2020  n_imode,.       
+000229c0: 2020 206e 5f64 6d6f 6465 2c20 6e5f 696d     n_dmode, n_im
+000229d0: 6f64 652c 0a20 2020 2020 2020 2020 2020  ode,.           
 000229e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000229f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022a10: 2020 2020 2020 2020 2026 6c6f 635f 6566           &loc_ef
-00022a20: 665f 7265 735b 305d 2c0a 2020 2020 2020  f_res[0],.      
+00022a10: 2020 2020 2026 6c6f 635f 6566 665f 7265       &loc_eff_re
+00022a20: 735b 305d 2c0a 2020 2020 2020 2020 2020  s[0],.          
 00022a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022a60: 2020 2020 2020 2020 2020 266e 625f 726f            &nb_ro
-00022a70: 7773 5b30 5d2c 0a20 2020 2020 2020 2020  ws[0],.         
+00022a60: 2020 2020 2020 266e 625f 726f 7773 5b30        &nb_rows[0
+00022a70: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 00022a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022ab0: 2020 2020 2020 2072 6179 5f6f 7269 675b         ray_orig[
-00022ac0: 3a2c 6969 3a69 692b 315d 2c0a 2020 2020  :,ii:ii+1],.    
+00022ab0: 2020 2072 6179 5f6f 7269 675b 3a2c 6969     ray_orig[:,ii
+00022ac0: 3a69 692b 315d 2c0a 2020 2020 2020 2020  :ii+1],.        
 00022ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022b00: 2020 2020 2020 2020 2020 2020 7261 795f              ray_
-00022b10: 7664 6972 5b3a 2c69 693a 6969 2b31 5d29  vdir[:,ii:ii+1])
-00022b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00022b30: 2020 2020 2023 206c 6f6f 7020 6f76 6572       # loop over
-00022b40: 2074 696d 6520 666f 7220 6361 6c6c 696e   time for callin
-00022b50: 6720 616e 6420 696e 7465 6772 6174 696e  g and integratin
-00022b60: 670a 2020 2020 2020 2020 2020 2020 2020  g.              
-00022b70: 2020 2020 2020 666f 7220 6a6a 2069 6e20        for jj in 
-00022b80: 7261 6e67 6528 6e74 293a 0a20 2020 2020  range(nt):.     
-00022b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022ba0: 2020 2076 616c 203d 2066 756e 6328 7074     val = func(pt
-00022bb0: 732c 2074 3d6c 7469 6d65 5b6a 6a5d 2c20  s, t=ltime[jj], 
-00022bc0: 7665 6374 3d2d 7573 6269 732c 202a 2a66  vect=-usbis, **f
-00022bd0: 6b77 6461 7267 7329 0a20 2020 2020 2020  kwdargs).       
-00022be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022bf0: 2073 6967 5b6a 6a2c 2069 695d 203d 2073   sig[jj, ii] = s
-00022c00: 6370 696e 7467 2e72 6f6d 6228 7661 6c2c  cpintg.romb(val,
-00022c10: 2073 686f 773d 4661 6c73 652c 0a20 2020   show=False,.   
+00022b00: 2020 2020 2020 2020 7261 795f 7664 6972          ray_vdir
+00022b10: 5b3a 2c69 693a 6969 2b31 5d29 0a20 2020  [:,ii:ii+1]).   
+00022b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022b30: 2023 206c 6f6f 7020 6f76 6572 2074 696d   # loop over tim
+00022b40: 6520 666f 7220 6361 6c6c 696e 6720 616e  e for calling an
+00022b50: 6420 696e 7465 6772 6174 696e 670a 2020  d integrating.  
+00022b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022b70: 2020 666f 7220 6a6a 2069 6e20 7261 6e67    for jj in rang
+00022b80: 6528 6e74 293a 0a20 2020 2020 2020 2020  e(nt):.         
+00022b90: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00022ba0: 616c 203d 2066 756e 6328 7074 732c 2074  al = func(pts, t
+00022bb0: 3d6c 7469 6d65 5b6a 6a5d 2c20 7665 6374  =ltime[jj], vect
+00022bc0: 3d2d 7573 6269 732c 202a 2a66 6b77 6461  =-usbis, **fkwda
+00022bd0: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
+00022be0: 2020 2020 2020 2020 2020 2020 2073 6967               sig
+00022bf0: 5b6a 6a2c 2069 695d 203d 2073 6370 696e  [jj, ii] = scpin
+00022c00: 7467 2e72 6f6d 6228 7661 6c2c 2073 686f  tg.romb(val, sho
+00022c10: 773d 4661 6c73 652c 0a20 2020 2020 2020  w=False,.       
 00022c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022c50: 6478 3d6c 6f63 5f65 6666 5f72 6573 5b30  dx=loc_eff_res[0
-00022c60: 5d29 0a20 2020 2020 2020 2065 6c73 653a  ]).        else:
-00022c70: 0a20 2020 2020 2020 2020 2020 2023 202d  .            # -
-00022c80: 2d20 6e6f 7420 616e 6973 6f74 726f 7069  - not anisotropi
-00022c90: 6320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  c --------------
+00022c40: 2020 2020 2020 2020 2020 2020 6478 3d6c              dx=l
+00022c50: 6f63 5f65 6666 5f72 6573 5b30 5d29 0a20  oc_eff_res[0]). 
+00022c60: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00022c70: 2020 2020 2020 2020 2023 202d 2d20 6e6f           # -- no
+00022c80: 7420 616e 6973 6f74 726f 7069 6320 2d2d  t anisotropic --
+00022c90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00022ca0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00022cb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00022cc0: 2d0a 2020 2020 2020 2020 2020 2020 6966  -.            if
-00022cd0: 206e 5f69 6d6f 6465 203d 3d20 303a 2020   n_imode == 0:  
-00022ce0: 2320 2273 756d 2220 696e 7465 6772 6174  # "sum" integrat
-00022cf0: 696f 6e20 6d6f 6465 0a20 2020 2020 2020  ion mode.       
-00022d00: 2020 2020 2020 2020 2066 6f72 2069 6920           for ii 
-00022d10: 696e 2072 616e 6765 286e 6c6f 7329 3a0a  in range(nlos):.
+00022cb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  -------------.  
+00022cc0: 2020 2020 2020 2020 2020 6966 206e 5f69            if n_i
+00022cd0: 6d6f 6465 203d 3d20 303a 2020 2320 2273  mode == 0:  # "s
+00022ce0: 756d 2220 696e 7465 6772 6174 696f 6e20  um" integration 
+00022cf0: 6d6f 6465 0a20 2020 2020 2020 2020 2020  mode.           
+00022d00: 2020 2020 2066 6f72 2069 6920 696e 2072       for ii in r
+00022d10: 616e 6765 286e 6c6f 7329 3a0a 2020 2020  ange(nlos):.    
 00022d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022d30: 2020 2020 7074 7320 3d20 5f73 742e 6361      pts = _st.ca
-00022d40: 6c6c 5f67 6574 5f73 616d 706c 655f 7369  ll_get_sample_si
-00022d50: 6e67 6c65 286c 696d 735b 302c 2069 695d  ngle(lims[0, ii]
-00022d60: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00022d30: 7074 7320 3d20 5f73 742e 6361 6c6c 5f67  pts = _st.call_g
+00022d40: 6574 5f73 616d 706c 655f 7369 6e67 6c65  et_sample_single
+00022d50: 286c 696d 735b 302c 2069 695d 2c0a 2020  (lims[0, ii],.  
+00022d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022d90: 2020 2020 2020 206c 696d 735b 312c 2069         lims[1, i
-00022da0: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
+00022d90: 2020 206c 696d 735b 312c 2069 695d 2c0a     lims[1, ii],.
+00022da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022dd0: 2020 2020 2020 2020 2072 6573 5f6d 765b           res_mv[
-00022de0: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
+00022dd0: 2020 2020 2072 6573 5f6d 765b 6969 5d2c       res_mv[ii],
+00022de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00022df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022e10: 2020 2020 2020 2020 2020 6e5f 646d 6f64            n_dmod
-00022e20: 652c 206e 5f69 6d6f 6465 2c0a 2020 2020  e, n_imode,.    
+00022e10: 2020 2020 2020 6e5f 646d 6f64 652c 206e        n_dmode, n
+00022e20: 5f69 6d6f 6465 2c0a 2020 2020 2020 2020  _imode,.        
 00022e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022e60: 2026 6c6f 635f 6566 665f 7265 735b 305d   &loc_eff_res[0]
-00022e70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00022e50: 2020 2020 2020 2020 2020 2020 2026 6c6f               &lo
+00022e60: 635f 6566 665f 7265 735b 305d 2c0a 2020  c_eff_res[0],.  
+00022e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022ea0: 2020 2020 2020 2026 6e62 5f72 6f77 735b         &nb_rows[
-00022eb0: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+00022ea0: 2020 2026 6e62 5f72 6f77 735b 305d 2c0a     &nb_rows[0],.
+00022eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022ee0: 2020 2020 2020 2020 2072 6179 5f6f 7269           ray_ori
-00022ef0: 675b 3a2c 6969 3a69 692b 315d 2c0a 2020  g[:,ii:ii+1],.  
+00022ee0: 2020 2020 2072 6179 5f6f 7269 675b 3a2c       ray_orig[:,
+00022ef0: 6969 3a69 692b 315d 2c0a 2020 2020 2020  ii:ii+1],.      
 00022f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00022f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022f30: 2020 2072 6179 5f76 6469 725b 3a2c 6969     ray_vdir[:,ii
-00022f40: 3a69 692b 315d 290a 2020 2020 2020 2020  :ii+1]).        
-00022f50: 2020 2020 2020 2020 2020 2020 2320 6c6f              # lo
-00022f60: 6f70 206f 7665 7220 7469 6d65 2066 6f72  op over time for
-00022f70: 2063 616c 6c69 6e67 2061 6e64 2069 6e74   calling and int
-00022f80: 6567 7261 7469 6e67 0a20 2020 2020 2020  egrating.       
-00022f90: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00022fa0: 206a 6a20 696e 2072 616e 6765 286e 7429   jj in range(nt)
-00022fb0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00022fc0: 2020 2020 2020 2020 2020 7661 6c20 3d20            val = 
-00022fd0: 6675 6e63 2870 7473 2c20 743d 6c74 696d  func(pts, t=ltim
-00022fe0: 655b 6a6a 5d2c 202a 2a66 6b77 6461 7267  e[jj], **fkwdarg
-00022ff0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
-00023000: 2020 2020 2020 2020 2020 2073 6967 5b6a             sig[j
-00023010: 6a2c 2069 695d 203d 206e 702e 7375 6d28  j, ii] = np.sum(
-00023020: 7661 6c29 2a6c 6f63 5f65 6666 5f72 6573  val)*loc_eff_res
-00023030: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
-00023040: 656c 6966 206e 5f69 6d6f 6465 203d 3d20  elif n_imode == 
-00023050: 313a 2020 2320 2273 696d 7073 6f6e 2220  1:  # "simpson" 
-00023060: 696e 7465 6772 6174 696f 6e20 6d6f 6465  integration mode
-00023070: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023080: 2066 6f72 2069 6920 696e 2072 616e 6765   for ii in range
-00023090: 286e 6c6f 7329 3a0a 2020 2020 2020 2020  (nlos):.        
-000230a0: 2020 2020 2020 2020 2020 2020 7074 7320              pts 
-000230b0: 3d20 5f73 742e 6361 6c6c 5f67 6574 5f73  = _st.call_get_s
-000230c0: 616d 706c 655f 7369 6e67 6c65 286c 696d  ample_single(lim
-000230d0: 735b 302c 6969 5d2c 0a20 2020 2020 2020  s[0,ii],.       
+00022f20: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00022f30: 6179 5f76 6469 725b 3a2c 6969 3a69 692b  ay_vdir[:,ii:ii+
+00022f40: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
+00022f50: 2020 2020 2020 2020 2320 6c6f 6f70 206f          # loop o
+00022f60: 7665 7220 7469 6d65 2066 6f72 2063 616c  ver time for cal
+00022f70: 6c69 6e67 2061 6e64 2069 6e74 6567 7261  ling and integra
+00022f80: 7469 6e67 0a20 2020 2020 2020 2020 2020  ting.           
+00022f90: 2020 2020 2020 2020 2066 6f72 206a 6a20           for jj 
+00022fa0: 696e 2072 616e 6765 286e 7429 3a0a 2020  in range(nt):.  
+00022fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022fc0: 2020 2020 2020 7661 6c20 3d20 6675 6e63        val = func
+00022fd0: 2870 7473 2c20 743d 6c74 696d 655b 6a6a  (pts, t=ltime[jj
+00022fe0: 5d2c 202a 2a66 6b77 6461 7267 7329 0a20  ], **fkwdargs). 
+00022ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023000: 2020 2020 2020 2073 6967 5b6a 6a2c 2069         sig[jj, i
+00023010: 695d 203d 206e 702e 7375 6d28 7661 6c29  i] = np.sum(val)
+00023020: 2a6c 6f63 5f65 6666 5f72 6573 5b30 5d0a  *loc_eff_res[0].
+00023030: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+00023040: 206e 5f69 6d6f 6465 203d 3d20 313a 2020   n_imode == 1:  
+00023050: 2320 2273 696d 7073 6f6e 2220 696e 7465  # "simpson" inte
+00023060: 6772 6174 696f 6e20 6d6f 6465 0a20 2020  gration mode.   
+00023070: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00023080: 2069 6920 696e 2072 616e 6765 286e 6c6f   ii in range(nlo
+00023090: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+000230a0: 2020 2020 2020 2020 7074 7320 3d20 5f73          pts = _s
+000230b0: 742e 6361 6c6c 5f67 6574 5f73 616d 706c  t.call_get_sampl
+000230c0: 655f 7369 6e67 6c65 286c 696d 735b 302c  e_single(lims[0,
+000230d0: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
 000230e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000230f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023100: 2020 2020 2020 2020 2020 2020 2020 6c69                li
-00023110: 6d73 5b31 2c69 695d 2c0a 2020 2020 2020  ms[1,ii],.      
+00023100: 2020 2020 2020 2020 2020 6c69 6d73 5b31            lims[1
+00023110: 2c69 695d 2c0a 2020 2020 2020 2020 2020  ,ii],.          
 00023120: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023140: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00023150: 6573 5f6d 765b 6969 5d2c 0a20 2020 2020  es_mv[ii],.     
+00023140: 2020 2020 2020 2020 2020 2072 6573 5f6d             res_m
+00023150: 765b 6969 5d2c 0a20 2020 2020 2020 2020  v[ii],.         
 00023160: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023190: 6e5f 646d 6f64 652c 206e 5f69 6d6f 6465  n_dmode, n_imode
-000231a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00023180: 2020 2020 2020 2020 2020 2020 6e5f 646d              n_dm
+00023190: 6f64 652c 206e 5f69 6d6f 6465 2c0a 2020  ode, n_imode,.  
+000231a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000231b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000231c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000231d0: 2020 2020 2020 2026 6c6f 635f 6566 665f         &loc_eff_
-000231e0: 7265 735b 305d 2c0a 2020 2020 2020 2020  res[0],.        
+000231d0: 2020 2026 6c6f 635f 6566 665f 7265 735b     &loc_eff_res[
+000231e0: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
 000231f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023210: 2020 2020 2020 2020 2020 2020 2026 6e62               &nb
-00023220: 5f72 6f77 735b 305d 2c0a 2020 2020 2020  _rows[0],.      
+00023210: 2020 2020 2020 2020 2026 6e62 5f72 6f77           &nb_row
+00023220: 735b 305d 2c0a 2020 2020 2020 2020 2020  s[0],.          
 00023230: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023250: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00023260: 6179 5f6f 7269 675b 3a2c 6969 3a69 692b  ay_orig[:,ii:ii+
-00023270: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
+00023250: 2020 2020 2020 2020 2020 2072 6179 5f6f             ray_o
+00023260: 7269 675b 3a2c 6969 3a69 692b 315d 2c0a  rig[:,ii:ii+1],.
+00023270: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023280: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000232a0: 2020 2020 2020 2020 2072 6179 5f76 6469           ray_vdi
-000232b0: 725b 3a2c 6969 3a69 692b 315d 290a 2020  r[:,ii:ii+1]).  
-000232c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000232d0: 2020 2320 6c6f 6f70 206f 7665 7220 7469    # loop over ti
-000232e0: 6d65 2066 6f72 2063 616c 6c69 6e67 2061  me for calling a
-000232f0: 6e64 2069 6e74 6567 7261 7469 6e67 0a20  nd integrating. 
-00023300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023310: 2020 2066 6f72 206a 6a20 696e 2072 616e     for jj in ran
-00023320: 6765 286e 7429 3a0a 2020 2020 2020 2020  ge(nt):.        
-00023330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023340: 7661 6c20 3d20 6675 6e63 2870 7473 2c20  val = func(pts, 
-00023350: 743d 6c74 696d 655b 6a6a 5d2c 202a 2a66  t=ltime[jj], **f
-00023360: 6b77 6461 7267 7329 0a20 2020 2020 2020  kwdargs).       
-00023370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023380: 2073 6967 5b6a 6a2c 2069 695d 203d 2073   sig[jj, ii] = s
-00023390: 6370 696e 7467 2e73 696d 7073 2876 616c  cpintg.simps(val
-000233a0: 2c20 783d 4e6f 6e65 2c0a 2020 2020 2020  , x=None,.      
+000232a0: 2020 2020 2072 6179 5f76 6469 725b 3a2c       ray_vdir[:,
+000232b0: 6969 3a69 692b 315d 290a 2020 2020 2020  ii:ii+1]).      
+000232c0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+000232d0: 6c6f 6f70 206f 7665 7220 7469 6d65 2066  loop over time f
+000232e0: 6f72 2063 616c 6c69 6e67 2061 6e64 2069  or calling and i
+000232f0: 6e74 6567 7261 7469 6e67 0a20 2020 2020  ntegrating.     
+00023300: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00023310: 6f72 206a 6a20 696e 2072 616e 6765 286e  or jj in range(n
+00023320: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
+00023330: 2020 2020 2020 2020 2020 2020 7661 6c20              val 
+00023340: 3d20 6675 6e63 2870 7473 2c20 743d 6c74  = func(pts, t=lt
+00023350: 696d 655b 6a6a 5d2c 202a 2a66 6b77 6461  ime[jj], **fkwda
+00023360: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
+00023370: 2020 2020 2020 2020 2020 2020 2073 6967               sig
+00023380: 5b6a 6a2c 2069 695d 203d 2073 6370 696e  [jj, ii] = scpin
+00023390: 7467 2e73 696d 7073 2876 616c 2c20 783d  tg.simps(val, x=
+000233a0: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
 000233b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000233c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000233d0: 2020 2020 2020 2020 2020 2020 2020 6478                dx
-000233e0: 3d6c 6f63 5f65 6666 5f72 6573 5b30 5d29  =loc_eff_res[0])
-000233f0: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-00023400: 6620 6e5f 696d 6f64 6520 3d3d 2032 3a20  f n_imode == 2: 
-00023410: 2023 2022 726f 6d62 6572 6722 2069 6e74   # "romberg" int
-00023420: 6567 7261 7469 6f6e 206d 6f64 650a 2020  egration mode.  
-00023430: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00023440: 7220 6969 2069 6e20 7261 6e67 6528 6e6c  r ii in range(nl
-00023450: 6f73 293a 0a20 2020 2020 2020 2020 2020  os):.           
-00023460: 2020 2020 2020 2020 2070 7473 203d 205f           pts = _
-00023470: 7374 2e63 616c 6c5f 6765 745f 7361 6d70  st.call_get_samp
-00023480: 6c65 5f73 696e 676c 6528 6c69 6d73 5b30  le_single(lims[0
-00023490: 2c20 6969 5d2c 0a20 2020 2020 2020 2020  , ii],.         
+000233d0: 2020 2020 2020 2020 2020 6478 3d6c 6f63            dx=loc
+000233e0: 5f65 6666 5f72 6573 5b30 5d29 0a20 2020  _eff_res[0]).   
+000233f0: 2020 2020 2020 2020 2065 6c69 6620 6e5f           elif n_
+00023400: 696d 6f64 6520 3d3d 2032 3a20 2023 2022  imode == 2:  # "
+00023410: 726f 6d62 6572 6722 2069 6e74 6567 7261  romberg" integra
+00023420: 7469 6f6e 206d 6f64 650a 2020 2020 2020  tion mode.      
+00023430: 2020 2020 2020 2020 2020 666f 7220 6969            for ii
+00023440: 2069 6e20 7261 6e67 6528 6e6c 6f73 293a   in range(nlos):
+00023450: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023460: 2020 2020 2070 7473 203d 205f 7374 2e63       pts = _st.c
+00023470: 616c 6c5f 6765 745f 7361 6d70 6c65 5f73  all_get_sample_s
+00023480: 696e 676c 6528 6c69 6d73 5b30 2c20 6969  ingle(lims[0, ii
+00023490: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 000234a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000234b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000234c0: 2020 2020 2020 2020 2020 2020 6c69 6d73              lims
-000234d0: 5b31 2c20 6969 5d2c 0a20 2020 2020 2020  [1, ii],.       
+000234c0: 2020 2020 2020 2020 6c69 6d73 5b31 2c20          lims[1, 
+000234d0: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
 000234e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000234f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023500: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00023510: 735f 6d76 5b69 695d 2c0a 2020 2020 2020  s_mv[ii],.      
+00023500: 2020 2020 2020 2020 2020 7265 735f 6d76            res_mv
+00023510: 5b69 695d 2c0a 2020 2020 2020 2020 2020  [ii],.          
 00023520: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023540: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00023550: 5f64 6d6f 6465 2c20 6e5f 696d 6f64 652c  _dmode, n_imode,
-00023560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023540: 2020 2020 2020 2020 2020 206e 5f64 6d6f             n_dmo
+00023550: 6465 2c20 6e5f 696d 6f64 652c 0a20 2020  de, n_imode,.   
+00023560: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023570: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023590: 2020 2020 2020 266c 6f63 5f65 6666 5f72        &loc_eff_r
-000235a0: 6573 5b30 5d2c 0a20 2020 2020 2020 2020  es[0],.         
+00023590: 2020 266c 6f63 5f65 6666 5f72 6573 5b30    &loc_eff_res[0
+000235a0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 000235b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000235c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000235d0: 2020 2020 2020 2020 2020 2020 266e 625f              &nb_
-000235e0: 726f 7773 5b30 5d2c 0a20 2020 2020 2020  rows[0],.       
+000235d0: 2020 2020 2020 2020 266e 625f 726f 7773          &nb_rows
+000235e0: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
 000235f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023610: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-00023620: 795f 6f72 6967 5b3a 2c69 693a 6969 2b31  y_orig[:,ii:ii+1
-00023630: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00023610: 2020 2020 2020 2020 2020 7261 795f 6f72            ray_or
+00023620: 6967 5b3a 2c69 693a 6969 2b31 5d2c 0a20  ig[:,ii:ii+1],. 
+00023630: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023640: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023660: 2020 2020 2020 2020 7261 795f 7664 6972          ray_vdir
-00023670: 5b3a 2c69 693a 6969 2b31 5d29 0a20 2020  [:,ii:ii+1]).   
-00023680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023690: 2023 206c 6f6f 7020 6f76 6572 2074 696d   # loop over tim
-000236a0: 6520 666f 7220 6361 6c6c 696e 6720 616e  e for calling an
-000236b0: 6420 696e 7465 6772 6174 696e 670a 2020  d integrating.  
-000236c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000236d0: 2020 666f 7220 6a6a 2069 6e20 7261 6e67    for jj in rang
-000236e0: 6528 6e74 293a 0a20 2020 2020 2020 2020  e(nt):.         
-000236f0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-00023700: 616c 203d 2066 756e 6328 7074 732c 2074  al = func(pts, t
-00023710: 3d6c 7469 6d65 5b6a 6a5d 2c20 2a2a 666b  =ltime[jj], **fk
-00023720: 7764 6172 6773 290a 2020 2020 2020 2020  wdargs).        
-00023730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023740: 7369 675b 6a6a 2c20 6969 5d20 3d20 7363  sig[jj, ii] = sc
-00023750: 7069 6e74 672e 726f 6d62 2876 616c 2c20  pintg.romb(val, 
-00023760: 7368 6f77 3d46 616c 7365 2c0a 2020 2020  show=False,.    
+00023660: 2020 2020 7261 795f 7664 6972 5b3a 2c69      ray_vdir[:,i
+00023670: 693a 6969 2b31 5d29 0a20 2020 2020 2020  i:ii+1]).       
+00023680: 2020 2020 2020 2020 2020 2020 2023 206c               # l
+00023690: 6f6f 7020 6f76 6572 2074 696d 6520 666f  oop over time fo
+000236a0: 7220 6361 6c6c 696e 6720 616e 6420 696e  r calling and in
+000236b0: 7465 6772 6174 696e 670a 2020 2020 2020  tegrating.      
+000236c0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+000236d0: 7220 6a6a 2069 6e20 7261 6e67 6528 6e74  r jj in range(nt
+000236e0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000236f0: 2020 2020 2020 2020 2020 2076 616c 203d             val =
+00023700: 2066 756e 6328 7074 732c 2074 3d6c 7469   func(pts, t=lti
+00023710: 6d65 5b6a 6a5d 2c20 2a2a 666b 7764 6172  me[jj], **fkwdar
+00023720: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
+00023730: 2020 2020 2020 2020 2020 2020 7369 675b              sig[
+00023740: 6a6a 2c20 6969 5d20 3d20 7363 7069 6e74  jj, ii] = scpint
+00023750: 672e 726f 6d62 2876 616c 2c20 7368 6f77  g.romb(val, show
+00023760: 3d46 616c 7365 2c0a 2020 2020 2020 2020  =False,.        
 00023770: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023790: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000237a0: 783d 6c6f 635f 6566 665f 7265 735b 305d  x=loc_eff_res[0]
-000237b0: 290a 2020 2020 2320 2d2d 2d2d 2d2d 2d2d  ).    # --------
+00023790: 2020 2020 2020 2020 2020 2064 783d 6c6f             dx=lo
+000237a0: 635f 6566 665f 7265 735b 305d 290a 2020  c_eff_res[0]).  
+000237b0: 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    # ------------
 000237c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 000237d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 000237e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000237f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00023800: 2d2d 0a20 2020 2023 2048 5942 5249 4420  --.    # HYBRID 
-00023810: 6d65 7468 6f64 3a20 4d69 6e69 6d69 7a65  method: Minimize
-00023820: 206d 656d 6f72 7920 616e 6420 6361 6c6c   memory and call
-00023830: 7320 2863 6f6d 7072 6f6d 6973 6529 3a20  s (compromise): 
-00023840: 6c6f 6f70 2065 7665 7279 7468 696e 672c  loop everything,
-00023850: 0a20 2020 2023 2073 7461 7274 696e 6720  .    # starting 
-00023860: 7769 7468 204c 4f53 2c20 6361 6c6c 2066  with LOS, call f
-00023870: 756e 6320 6f6e 6c79 206f 6e63 6520 666f  unc only once fo
-00023880: 7220 6561 6368 206c 6f73 2028 7472 6561  r each los (trea
-00023890: 7420 616c 6c20 7469 6d65 7329 0a20 2020  t all times).   
-000238a0: 2023 206c 6f6f 7020 6f76 6572 2074 696d   # loop over tim
-000238b0: 6520 666f 7220 696e 7465 6772 616c 730a  e for integrals.
-000238c0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000238d0: 2020 2320 6c6f 6f70 206f 7665 7220 4c4f    # loop over LO
-000238e0: 530a 2020 2020 2020 2020 6966 2061 6e69  S.        if ani
-000238f0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-00023900: 206e 5f69 6d6f 6465 203d 3d20 303a 2020   n_imode == 0:  
-00023910: 2320 7375 6d20 696e 7465 6772 6174 696f  # sum integratio
-00023920: 6e20 6d6f 6465 0a20 2020 2020 2020 2020  n mode.         
-00023930: 2020 2020 2020 2066 6f72 2069 6920 696e         for ii in
-00023940: 2072 616e 6765 286e 6c6f 7329 3a0a 2020   range(nlos):.  
-00023950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023960: 2020 7074 732c 2075 7362 6973 203d 205f    pts, usbis = _
-00023970: 7374 2e63 616c 6c5f 6765 745f 7361 6d70  st.call_get_samp
-00023980: 6c65 5f73 696e 676c 655f 616e 6928 6c69  le_single_ani(li
-00023990: 6d73 5b30 2c20 6969 5d2c 0a20 2020 2020  ms[0, ii],.     
+000237f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
+00023800: 2020 2023 2048 5942 5249 4420 6d65 7468     # HYBRID meth
+00023810: 6f64 3a20 4d69 6e69 6d69 7a65 206d 656d  od: Minimize mem
+00023820: 6f72 7920 616e 6420 6361 6c6c 7320 2863  ory and calls (c
+00023830: 6f6d 7072 6f6d 6973 6529 3a20 6c6f 6f70  ompromise): loop
+00023840: 2065 7665 7279 7468 696e 672c 0a20 2020   everything,.   
+00023850: 2023 2073 7461 7274 696e 6720 7769 7468   # starting with
+00023860: 204c 4f53 2c20 6361 6c6c 2066 756e 6320   LOS, call func 
+00023870: 6f6e 6c79 206f 6e63 6520 666f 7220 6561  only once for ea
+00023880: 6368 206c 6f73 2028 7472 6561 7420 616c  ch los (treat al
+00023890: 6c20 7469 6d65 7329 0a20 2020 2023 206c  l times).    # l
+000238a0: 6f6f 7020 6f76 6572 2074 696d 6520 666f  oop over time fo
+000238b0: 7220 696e 7465 6772 616c 730a 2020 2020  r integrals.    
+000238c0: 656c 7365 3a0a 2020 2020 2020 2020 2320  else:.        # 
+000238d0: 6c6f 6f70 206f 7665 7220 4c4f 530a 2020  loop over LOS.  
+000238e0: 2020 2020 2020 6966 2061 6e69 3a0a 2020        if ani:.  
+000238f0: 2020 2020 2020 2020 2020 6966 206e 5f69            if n_i
+00023900: 6d6f 6465 203d 3d20 303a 2020 2320 7375  mode == 0:  # su
+00023910: 6d20 696e 7465 6772 6174 696f 6e20 6d6f  m integration mo
+00023920: 6465 0a20 2020 2020 2020 2020 2020 2020  de.             
+00023930: 2020 2066 6f72 2069 6920 696e 2072 616e     for ii in ran
+00023940: 6765 286e 6c6f 7329 3a0a 2020 2020 2020  ge(nlos):.      
+00023950: 2020 2020 2020 2020 2020 2020 2020 7074                pt
+00023960: 732c 2075 7362 6973 203d 205f 7374 2e63  s, usbis = _st.c
+00023970: 616c 6c5f 6765 745f 7361 6d70 6c65 5f73  all_get_sample_s
+00023980: 696e 676c 655f 616e 6928 6c69 6d73 5b30  ingle_ani(lims[0
+00023990: 2c20 6969 5d2c 0a20 2020 2020 2020 2020  , ii],.         
 000239a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000239b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000239c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000239d0: 2020 2020 2020 2020 2020 206c 696d 735b             lims[
-000239e0: 312c 2069 695d 2c0a 2020 2020 2020 2020  1, ii],.        
+000239d0: 2020 2020 2020 206c 696d 735b 312c 2069         lims[1, i
+000239e0: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
 000239f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023a20: 2020 2020 2020 2020 7265 735f 6d76 5b69          res_mv[i
-00023a30: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
+00023a20: 2020 2020 7265 735f 6d76 5b69 695d 2c0a      res_mv[ii],.
+00023a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023a70: 2020 2020 6e5f 646d 6f64 652c 0a20 2020      n_dmode,.   
+00023a70: 6e5f 646d 6f64 652c 0a20 2020 2020 2020  n_dmode,.       
 00023a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023ab0: 2020 2020 2020 2020 2020 2020 206e 5f69               n_i
-00023ac0: 6d6f 6465 2c0a 2020 2020 2020 2020 2020  mode,.          
+00023ab0: 2020 2020 2020 2020 206e 5f69 6d6f 6465           n_imode
+00023ac0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 00023ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023b00: 2020 2020 2020 266c 6f63 5f65 6666 5f72        &loc_eff_r
-00023b10: 6573 5b30 5d2c 0a20 2020 2020 2020 2020  es[0],.         
+00023b00: 2020 266c 6f63 5f65 6666 5f72 6573 5b30    &loc_eff_res[0
+00023b10: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 00023b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023b50: 2020 2020 2020 2026 6e62 5f72 6f77 735b         &nb_rows[
-00023b60: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+00023b50: 2020 2026 6e62 5f72 6f77 735b 305d 2c0a     &nb_rows[0],.
+00023b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023ba0: 2020 2020 7261 795f 6f72 6967 5b3a 2c20      ray_orig[:, 
-00023bb0: 6969 3a69 692b 315d 2c0a 2020 2020 2020  ii:ii+1],.      
+00023ba0: 7261 795f 6f72 6967 5b3a 2c20 6969 3a69  ray_orig[:, ii:i
+00023bb0: 692b 315d 2c0a 2020 2020 2020 2020 2020  i+1],.          
 00023bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023bf0: 2020 2020 2020 2020 2020 7261 795f 7664            ray_vd
-00023c00: 6972 5b3a 2c20 6969 3a69 692b 315d 290a  ir[:, ii:ii+1]).
+00023bf0: 2020 2020 2020 7261 795f 7664 6972 5b3a        ray_vdir[:
+00023c00: 2c20 6969 3a69 692b 315d 290a 2020 2020  , ii:ii+1]).    
 00023c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023c20: 2020 2020 7661 6c5f 3264 203d 2066 756e      val_2d = fun
-00023c30: 6328 7074 732c 2074 3d74 2c20 7665 6374  c(pts, t=t, vect
-00023c40: 3d2d 7573 6269 732c 202a 2a66 6b77 6461  =-usbis, **fkwda
-00023c50: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
-00023c60: 2020 2020 2020 2020 2073 6967 5b3a 2c20           sig[:, 
-00023c70: 6969 5d20 3d20 6e70 2e73 756d 2876 616c  ii] = np.sum(val
-00023c80: 5f32 642c 2061 7869 733d 2d31 292a 6c6f  _2d, axis=-1)*lo
-00023c90: 635f 6566 665f 7265 735b 305d 0a20 2020  c_eff_res[0].   
-00023ca0: 2020 2020 2020 2020 2065 6c69 6620 6e5f           elif n_
-00023cb0: 696d 6f64 6520 3d3d 2031 3a20 2023 2073  imode == 1:  # s
-00023cc0: 696d 7073 6f6e 2069 6e74 6567 7261 7469  impson integrati
-00023cd0: 6f6e 206d 6f64 650a 2020 2020 2020 2020  on mode.        
-00023ce0: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
-00023cf0: 6e20 7261 6e67 6528 6e6c 6f73 293a 0a20  n range(nlos):. 
-00023d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023d10: 2020 2070 7473 2c20 7573 6269 7320 3d20     pts, usbis = 
-00023d20: 5f73 742e 6361 6c6c 5f67 6574 5f73 616d  _st.call_get_sam
-00023d30: 706c 655f 7369 6e67 6c65 5f61 6e69 286c  ple_single_ani(l
-00023d40: 696d 735b 302c 2069 695d 2c0a 2020 2020  ims[0, ii],.    
+00023c20: 7661 6c5f 3264 203d 2066 756e 6328 7074  val_2d = func(pt
+00023c30: 732c 2074 3d74 2c20 7665 6374 3d2d 7573  s, t=t, vect=-us
+00023c40: 6269 732c 202a 2a66 6b77 6461 7267 7329  bis, **fkwdargs)
+00023c50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023c60: 2020 2020 2073 6967 5b3a 2c20 6969 5d20       sig[:, ii] 
+00023c70: 3d20 6e70 2e73 756d 2876 616c 5f32 642c  = np.sum(val_2d,
+00023c80: 2061 7869 733d 2d31 292a 6c6f 635f 6566   axis=-1)*loc_ef
+00023c90: 665f 7265 735b 305d 0a20 2020 2020 2020  f_res[0].       
+00023ca0: 2020 2020 2065 6c69 6620 6e5f 696d 6f64       elif n_imod
+00023cb0: 6520 3d3d 2031 3a20 2023 2073 696d 7073  e == 1:  # simps
+00023cc0: 6f6e 2069 6e74 6567 7261 7469 6f6e 206d  on integration m
+00023cd0: 6f64 650a 2020 2020 2020 2020 2020 2020  ode.            
+00023ce0: 2020 2020 666f 7220 6969 2069 6e20 7261      for ii in ra
+00023cf0: 6e67 6528 6e6c 6f73 293a 0a20 2020 2020  nge(nlos):.     
+00023d00: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00023d10: 7473 2c20 7573 6269 7320 3d20 5f73 742e  ts, usbis = _st.
+00023d20: 6361 6c6c 5f67 6574 5f73 616d 706c 655f  call_get_sample_
+00023d30: 7369 6e67 6c65 5f61 6e69 286c 696d 735b  single_ani(lims[
+00023d40: 302c 2069 695d 2c0a 2020 2020 2020 2020  0, ii],.        
 00023d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023d80: 2020 2020 2020 2020 2020 2020 6c69 6d73              lims
-00023d90: 5b31 2c20 6969 5d2c 0a20 2020 2020 2020  [1, ii],.       
+00023d80: 2020 2020 2020 2020 6c69 6d73 5b31 2c20          lims[1, 
+00023d90: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
 00023da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023dd0: 2020 2020 2020 2020 2072 6573 5f6d 765b           res_mv[
-00023de0: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
+00023dd0: 2020 2020 2072 6573 5f6d 765b 6969 5d2c       res_mv[ii],
+00023de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00023df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023e20: 2020 2020 206e 5f64 6d6f 6465 2c20 6e5f       n_dmode, n_
-00023e30: 696d 6f64 652c 0a20 2020 2020 2020 2020  imode,.         
+00023e20: 206e 5f64 6d6f 6465 2c20 6e5f 696d 6f64   n_dmode, n_imod
+00023e30: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
 00023e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023e70: 2020 2020 2020 2026 6c6f 635f 6566 665f         &loc_eff_
-00023e80: 7265 735b 305d 2c0a 2020 2020 2020 2020  res[0],.        
+00023e70: 2020 2026 6c6f 635f 6566 665f 7265 735b     &loc_eff_res[
+00023e80: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
 00023e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023ec0: 2020 2020 2020 2020 266e 625f 726f 7773          &nb_rows
-00023ed0: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
+00023ec0: 2020 2020 266e 625f 726f 7773 5b30 5d2c      &nb_rows[0],
+00023ed0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00023ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023f10: 2020 2020 2072 6179 5f6f 7269 675b 3a2c       ray_orig[:,
-00023f20: 2069 693a 6969 2b31 5d2c 0a20 2020 2020   ii:ii+1],.     
+00023f10: 2072 6179 5f6f 7269 675b 3a2c 2069 693a   ray_orig[:, ii:
+00023f20: 6969 2b31 5d2c 0a20 2020 2020 2020 2020  ii+1],.         
 00023f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00023f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023f60: 2020 2020 2020 2020 2020 2072 6179 5f76             ray_v
-00023f70: 6469 725b 3a2c 2069 693a 6969 2b31 5d29  dir[:, ii:ii+1])
-00023f80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023f90: 2020 2020 2076 616c 203d 2066 756e 6328       val = func(
-00023fa0: 7074 732c 2074 3d74 2c20 7665 6374 3d2d  pts, t=t, vect=-
-00023fb0: 7573 6269 732c 202a 2a66 6b77 6461 7267  usbis, **fkwdarg
-00023fc0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
-00023fd0: 2020 2020 2020 2023 2069 6e74 6567 7261         # integra
-00023fe0: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
-00023ff0: 2020 2020 2020 2020 2073 6967 5b3a 2c20           sig[:, 
-00024000: 6969 5d20 3d20 7363 7069 6e74 672e 7369  ii] = scpintg.si
-00024010: 6d70 7328 7661 6c2c 2078 3d4e 6f6e 652c  mps(val, x=None,
-00024020: 2061 7869 733d 2d31 2c0a 2020 2020 2020   axis=-1,.      
+00023f60: 2020 2020 2020 2072 6179 5f76 6469 725b         ray_vdir[
+00023f70: 3a2c 2069 693a 6969 2b31 5d29 0a20 2020  :, ii:ii+1]).   
+00023f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023f90: 2076 616c 203d 2066 756e 6328 7074 732c   val = func(pts,
+00023fa0: 2074 3d74 2c20 7665 6374 3d2d 7573 6269   t=t, vect=-usbi
+00023fb0: 732c 202a 2a66 6b77 6461 7267 7329 0a20  s, **fkwdargs). 
+00023fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023fd0: 2020 2023 2069 6e74 6567 7261 7469 6f6e     # integration
+00023fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023ff0: 2020 2020 2073 6967 5b3a 2c20 6969 5d20       sig[:, ii] 
+00024000: 3d20 7363 7069 6e74 672e 7369 6d70 7328  = scpintg.simps(
+00024010: 7661 6c2c 2078 3d4e 6f6e 652c 2061 7869  val, x=None, axi
+00024020: 733d 2d31 2c0a 2020 2020 2020 2020 2020  s=-1,.          
 00024030: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024050: 2020 2020 2020 2020 2064 783d 6c6f 635f           dx=loc_
-00024060: 6566 665f 7265 735b 305d 290a 2020 2020  eff_res[0]).    
-00024070: 2020 2020 2020 2020 656c 6966 206e 5f69          elif n_i
-00024080: 6d6f 6465 203d 3d20 323a 2020 2320 726f  mode == 2:  # ro
-00024090: 6d62 6572 6720 696e 7465 6772 6174 696f  mberg integratio
-000240a0: 6e20 6d6f 6465 0a20 2020 2020 2020 2020  n mode.         
-000240b0: 2020 2020 2020 2066 6f72 2069 6920 696e         for ii in
-000240c0: 2072 616e 6765 286e 6c6f 7329 3a0a 2020   range(nlos):.  
-000240d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000240e0: 2020 7074 732c 2075 7362 6973 203d 205f    pts, usbis = _
-000240f0: 7374 2e63 616c 6c5f 6765 745f 7361 6d70  st.call_get_samp
-00024100: 6c65 5f73 696e 676c 655f 616e 6928 6c69  le_single_ani(li
-00024110: 6d73 5b30 2c20 6969 5d2c 0a20 2020 2020  ms[0, ii],.     
+00024050: 2020 2020 2064 783d 6c6f 635f 6566 665f       dx=loc_eff_
+00024060: 7265 735b 305d 290a 2020 2020 2020 2020  res[0]).        
+00024070: 2020 2020 656c 6966 206e 5f69 6d6f 6465      elif n_imode
+00024080: 203d 3d20 323a 2020 2320 726f 6d62 6572   == 2:  # romber
+00024090: 6720 696e 7465 6772 6174 696f 6e20 6d6f  g integration mo
+000240a0: 6465 0a20 2020 2020 2020 2020 2020 2020  de.             
+000240b0: 2020 2066 6f72 2069 6920 696e 2072 616e     for ii in ran
+000240c0: 6765 286e 6c6f 7329 3a0a 2020 2020 2020  ge(nlos):.      
+000240d0: 2020 2020 2020 2020 2020 2020 2020 7074                pt
+000240e0: 732c 2075 7362 6973 203d 205f 7374 2e63  s, usbis = _st.c
+000240f0: 616c 6c5f 6765 745f 7361 6d70 6c65 5f73  all_get_sample_s
+00024100: 696e 676c 655f 616e 6928 6c69 6d73 5b30  ingle_ani(lims[0
+00024110: 2c20 6969 5d2c 0a20 2020 2020 2020 2020  , ii],.         
 00024120: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024130: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024150: 2020 2020 2020 2020 2020 206c 696d 735b             lims[
-00024160: 312c 2069 695d 2c0a 2020 2020 2020 2020  1, ii],.        
+00024150: 2020 2020 2020 206c 696d 735b 312c 2069         lims[1, i
+00024160: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
 00024170: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024180: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000241a0: 2020 2020 2020 2020 7265 735f 6d76 5b69          res_mv[i
-000241b0: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
+000241a0: 2020 2020 7265 735f 6d76 5b69 695d 2c0a      res_mv[ii],.
+000241b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000241c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000241d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000241e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000241f0: 2020 2020 6e5f 646d 6f64 652c 0a20 2020      n_dmode,.   
+000241f0: 6e5f 646d 6f64 652c 0a20 2020 2020 2020  n_dmode,.       
 00024200: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024210: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024230: 2020 2020 2020 2020 2020 2020 206e 5f69               n_i
-00024240: 6d6f 6465 2c0a 2020 2020 2020 2020 2020  mode,.          
+00024230: 2020 2020 2020 2020 206e 5f69 6d6f 6465           n_imode
+00024240: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 00024250: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024260: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024280: 2020 2020 2020 266c 6f63 5f65 6666 5f72        &loc_eff_r
-00024290: 6573 5b30 5d2c 0a20 2020 2020 2020 2020  es[0],.         
+00024280: 2020 266c 6f63 5f65 6666 5f72 6573 5b30    &loc_eff_res[0
+00024290: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 000242a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000242b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000242c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000242d0: 2020 2020 2020 2026 6e62 5f72 6f77 735b         &nb_rows[
-000242e0: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+000242d0: 2020 2026 6e62 5f72 6f77 735b 305d 2c0a     &nb_rows[0],.
+000242e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000242f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024300: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024320: 2020 2020 7261 795f 6f72 6967 5b3a 2c20      ray_orig[:, 
-00024330: 6969 3a69 692b 315d 2c0a 2020 2020 2020  ii:ii+1],.      
+00024320: 7261 795f 6f72 6967 5b3a 2c20 6969 3a69  ray_orig[:, ii:i
+00024330: 692b 315d 2c0a 2020 2020 2020 2020 2020  i+1],.          
 00024340: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024350: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024370: 2020 2020 2020 2020 2020 7261 795f 7664            ray_vd
-00024380: 6972 5b3a 2c20 6969 3a69 692b 315d 290a  ir[:, ii:ii+1]).
+00024370: 2020 2020 2020 7261 795f 7664 6972 5b3a        ray_vdir[:
+00024380: 2c20 6969 3a69 692b 315d 290a 2020 2020  , ii:ii+1]).    
 00024390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000243a0: 2020 2020 7661 6c20 3d20 6675 6e63 2870      val = func(p
-000243b0: 7473 2c20 743d 742c 2076 6563 743d 2d75  ts, t=t, vect=-u
-000243c0: 7362 6973 2c20 2a2a 666b 7764 6172 6773  sbis, **fkwdargs
-000243d0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000243e0: 2020 2020 2020 7369 675b 3a2c 2069 695d        sig[:, ii]
-000243f0: 203d 2073 6370 696e 7467 2e72 6f6d 6228   = scpintg.romb(
-00024400: 7661 6c2c 2073 686f 773d 4661 6c73 652c  val, show=False,
-00024410: 2061 7869 733d 312c 0a20 2020 2020 2020   axis=1,.       
+000243a0: 7661 6c20 3d20 6675 6e63 2870 7473 2c20  val = func(pts, 
+000243b0: 743d 742c 2076 6563 743d 2d75 7362 6973  t=t, vect=-usbis
+000243c0: 2c20 2a2a 666b 7764 6172 6773 290a 2020  , **fkwdargs).  
+000243d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000243e0: 2020 7369 675b 3a2c 2069 695d 203d 2073    sig[:, ii] = s
+000243f0: 6370 696e 7467 2e72 6f6d 6228 7661 6c2c  cpintg.romb(val,
+00024400: 2073 686f 773d 4661 6c73 652c 2061 7869   show=False, axi
+00024410: 733d 312c 0a20 2020 2020 2020 2020 2020  s=1,.           
 00024420: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024440: 2020 2020 2020 2020 6478 3d6c 6f63 5f65          dx=loc_e
-00024450: 6666 5f72 6573 5b30 5d29 0a20 2020 2020  ff_res[0]).     
-00024460: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00024470: 2020 2020 2023 202d 2d20 6e6f 7420 616e       # -- not an
-00024480: 6973 6f74 726f 7069 6320 2d2d 2d2d 2d2d  isotropic ------
+00024440: 2020 2020 6478 3d6c 6f63 5f65 6666 5f72      dx=loc_eff_r
+00024450: 6573 5b30 5d29 0a20 2020 2020 2020 2065  es[0]).        e
+00024460: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00024470: 2023 202d 2d20 6e6f 7420 616e 6973 6f74   # -- not anisot
+00024480: 726f 7069 6320 2d2d 2d2d 2d2d 2d2d 2d2d  ropic ----------
 00024490: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 000244a0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000244b0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
-000244c0: 2020 2020 2020 6966 206e 5f69 6d6f 6465        if n_imode
-000244d0: 203d 3d20 303a 2020 2320 2273 756d 2220   == 0:  # "sum" 
-000244e0: 696e 7465 6772 6174 696f 6e20 6d6f 6465  integration mode
-000244f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00024500: 2066 6f72 2069 6920 696e 2072 616e 6765   for ii in range
-00024510: 286e 6c6f 7329 3a0a 2020 2020 2020 2020  (nlos):.        
-00024520: 2020 2020 2020 2020 2020 2020 7074 7320              pts 
-00024530: 3d20 5f73 742e 6361 6c6c 5f67 6574 5f73  = _st.call_get_s
-00024540: 616d 706c 655f 7369 6e67 6c65 286c 696d  ample_single(lim
-00024550: 735b 302c 2069 695d 2c0a 2020 2020 2020  s[0, ii],.      
+000244b0: 2d2d 2d2d 2d0a 2020 2020 2020 2020 2020  -----.          
+000244c0: 2020 6966 206e 5f69 6d6f 6465 203d 3d20    if n_imode == 
+000244d0: 303a 2020 2320 2273 756d 2220 696e 7465  0:  # "sum" inte
+000244e0: 6772 6174 696f 6e20 6d6f 6465 0a20 2020  gration mode.   
+000244f0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00024500: 2069 6920 696e 2072 616e 6765 286e 6c6f   ii in range(nlo
+00024510: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+00024520: 2020 2020 2020 2020 7074 7320 3d20 5f73          pts = _s
+00024530: 742e 6361 6c6c 5f67 6574 5f73 616d 706c  t.call_get_sampl
+00024540: 655f 7369 6e67 6c65 286c 696d 735b 302c  e_single(lims[0,
+00024550: 2069 695d 2c0a 2020 2020 2020 2020 2020   ii],.          
 00024560: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024580: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00024590: 696d 735b 312c 2069 695d 2c0a 2020 2020  ims[1, ii],.    
+00024580: 2020 2020 2020 2020 2020 206c 696d 735b             lims[
+00024590: 312c 2069 695d 2c0a 2020 2020 2020 2020  1, ii],.        
 000245a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000245b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000245c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000245d0: 2072 6573 5f6d 765b 6969 5d2c 0a20 2020   res_mv[ii],.   
+000245c0: 2020 2020 2020 2020 2020 2020 2072 6573               res
+000245d0: 5f6d 765b 6969 5d2c 0a20 2020 2020 2020  _mv[ii],.       
 000245e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000245f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024610: 2020 6e5f 646d 6f64 652c 206e 5f69 6d6f    n_dmode, n_imo
-00024620: 6465 2c0a 2020 2020 2020 2020 2020 2020  de,.            
+00024600: 2020 2020 2020 2020 2020 2020 2020 6e5f                n_
+00024610: 646d 6f64 652c 206e 5f69 6d6f 6465 2c0a  dmode, n_imode,.
+00024620: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024630: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024650: 2020 2020 2020 2020 2026 6c6f 635f 6566           &loc_ef
-00024660: 665f 7265 735b 305d 2c0a 2020 2020 2020  f_res[0],.      
+00024650: 2020 2020 2026 6c6f 635f 6566 665f 7265       &loc_eff_re
+00024660: 735b 305d 2c0a 2020 2020 2020 2020 2020  s[0],.          
 00024670: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024690: 2020 2020 2020 2020 2020 2020 2020 2026                 &
-000246a0: 6e62 5f72 6f77 735b 305d 2c0a 2020 2020  nb_rows[0],.    
+00024690: 2020 2020 2020 2020 2020 2026 6e62 5f72             &nb_r
+000246a0: 6f77 735b 305d 2c0a 2020 2020 2020 2020  ows[0],.        
 000246b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000246c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000246d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000246e0: 2072 6179 5f6f 7269 675b 3a2c 2069 693a   ray_orig[:, ii:
-000246f0: 6969 2b31 5d2c 0a20 2020 2020 2020 2020  ii+1],.         
+000246d0: 2020 2020 2020 2020 2020 2020 2072 6179               ray
+000246e0: 5f6f 7269 675b 3a2c 2069 693a 6969 2b31  _orig[:, ii:ii+1
+000246f0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 00024700: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024720: 2020 2020 2020 2020 2020 2020 7261 795f              ray_
-00024730: 7664 6972 5b3a 2c20 6969 3a69 692b 315d  vdir[:, ii:ii+1]
-00024740: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00024750: 2020 2020 2020 7661 6c5f 3264 203d 2066        val_2d = f
-00024760: 756e 6328 7074 732c 2074 3d74 2c20 2a2a  unc(pts, t=t, **
-00024770: 666b 7764 6172 6773 290a 2020 2020 2020  fkwdargs).      
-00024780: 2020 2020 2020 2020 2020 2020 2020 7369                si
-00024790: 675b 3a2c 2069 695d 203d 206e 702e 7375  g[:, ii] = np.su
-000247a0: 6d28 7661 6c5f 3264 2c20 6178 6973 3d2d  m(val_2d, axis=-
-000247b0: 3129 2a6c 6f63 5f65 6666 5f72 6573 5b30  1)*loc_eff_res[0
-000247c0: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
-000247d0: 6966 206e 5f69 6d6f 6465 203d 3d20 313a  if n_imode == 1:
-000247e0: 2020 2320 2273 696d 7073 6f6e 2220 696e    # "simpson" in
-000247f0: 7465 6772 6174 696f 6e20 6d6f 6465 0a20  tegration mode. 
-00024800: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00024810: 6f72 2069 6920 696e 2072 616e 6765 286e  or ii in range(n
-00024820: 6c6f 7329 3a0a 2020 2020 2020 2020 2020  los):.          
-00024830: 2020 2020 2020 2020 2020 7074 7320 3d20            pts = 
-00024840: 5f73 742e 6361 6c6c 5f67 6574 5f73 616d  _st.call_get_sam
-00024850: 706c 655f 7369 6e67 6c65 286c 696d 735b  ple_single(lims[
-00024860: 302c 2069 695d 2c0a 2020 2020 2020 2020  0, ii],.        
+00024720: 2020 2020 2020 2020 7261 795f 7664 6972          ray_vdir
+00024730: 5b3a 2c20 6969 3a69 692b 315d 290a 2020  [:, ii:ii+1]).  
+00024740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024750: 2020 7661 6c5f 3264 203d 2066 756e 6328    val_2d = func(
+00024760: 7074 732c 2074 3d74 2c20 2a2a 666b 7764  pts, t=t, **fkwd
+00024770: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
+00024780: 2020 2020 2020 2020 2020 7369 675b 3a2c            sig[:,
+00024790: 2069 695d 203d 206e 702e 7375 6d28 7661   ii] = np.sum(va
+000247a0: 6c5f 3264 2c20 6178 6973 3d2d 3129 2a6c  l_2d, axis=-1)*l
+000247b0: 6f63 5f65 6666 5f72 6573 5b30 5d0a 2020  oc_eff_res[0].  
+000247c0: 2020 2020 2020 2020 2020 656c 6966 206e            elif n
+000247d0: 5f69 6d6f 6465 203d 3d20 313a 2020 2320  _imode == 1:  # 
+000247e0: 2273 696d 7073 6f6e 2220 696e 7465 6772  "simpson" integr
+000247f0: 6174 696f 6e20 6d6f 6465 0a20 2020 2020  ation mode.     
+00024800: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+00024810: 6920 696e 2072 616e 6765 286e 6c6f 7329  i in range(nlos)
+00024820: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00024830: 2020 2020 2020 7074 7320 3d20 5f73 742e        pts = _st.
+00024840: 6361 6c6c 5f67 6574 5f73 616d 706c 655f  call_get_sample_
+00024850: 7369 6e67 6c65 286c 696d 735b 302c 2069  single(lims[0, i
+00024860: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
 00024870: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024890: 2020 2020 2020 2020 2020 2020 206c 696d               lim
-000248a0: 735b 312c 2069 695d 2c0a 2020 2020 2020  s[1, ii],.      
+00024890: 2020 2020 2020 2020 206c 696d 735b 312c           lims[1,
+000248a0: 2069 695d 2c0a 2020 2020 2020 2020 2020   ii],.          
 000248b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000248c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000248d0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000248e0: 6573 5f6d 765b 6969 5d2c 0a20 2020 2020  es_mv[ii],.     
+000248d0: 2020 2020 2020 2020 2020 2072 6573 5f6d             res_m
+000248e0: 765b 6969 5d2c 0a20 2020 2020 2020 2020  v[ii],.         
 000248f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024920: 6e5f 646d 6f64 652c 206e 5f69 6d6f 6465  n_dmode, n_imode
-00024930: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00024910: 2020 2020 2020 2020 2020 2020 6e5f 646d              n_dm
+00024920: 6f64 652c 206e 5f69 6d6f 6465 2c0a 2020  ode, n_imode,.  
+00024930: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024940: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024960: 2020 2020 2020 2026 6c6f 635f 6566 665f         &loc_eff_
-00024970: 7265 735b 305d 2c0a 2020 2020 2020 2020  res[0],.        
+00024960: 2020 2026 6c6f 635f 6566 665f 7265 735b     &loc_eff_res[
+00024970: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
 00024980: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000249a0: 2020 2020 2020 2020 2020 2020 2026 6e62               &nb
-000249b0: 5f72 6f77 735b 305d 2c0a 2020 2020 2020  _rows[0],.      
+000249a0: 2020 2020 2020 2020 2026 6e62 5f72 6f77           &nb_row
+000249b0: 735b 305d 2c0a 2020 2020 2020 2020 2020  s[0],.          
 000249c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000249d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000249e0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000249f0: 6179 5f6f 7269 675b 3a2c 2069 693a 6969  ay_orig[:, ii:ii
-00024a00: 2b31 5d2c 0a20 2020 2020 2020 2020 2020  +1],.           
+000249e0: 2020 2020 2020 2020 2020 2072 6179 5f6f             ray_o
+000249f0: 7269 675b 3a2c 2069 693a 6969 2b31 5d2c  rig[:, ii:ii+1],
+00024a00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00024a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024a30: 2020 2020 2020 2020 2020 7261 795f 7664            ray_vd
-00024a40: 6972 5b3a 2c20 6969 3a69 692b 315d 290a  ir[:, ii:ii+1]).
+00024a30: 2020 2020 2020 7261 795f 7664 6972 5b3a        ray_vdir[:
+00024a40: 2c20 6969 3a69 692b 315d 290a 2020 2020  , ii:ii+1]).    
 00024a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024a60: 2020 2020 7661 6c20 3d20 6675 6e63 2870      val = func(p
-00024a70: 7473 2c20 743d 742c 202a 2a66 6b77 6461  ts, t=t, **fkwda
-00024a80: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
-00024a90: 2020 2020 2020 2020 2073 6967 5b3a 2c20           sig[:, 
-00024aa0: 6969 5d20 3d20 7363 7069 6e74 672e 7369  ii] = scpintg.si
-00024ab0: 6d70 7328 7661 6c2c 2078 3d4e 6f6e 652c  mps(val, x=None,
-00024ac0: 2061 7869 733d 2d31 2c0a 2020 2020 2020   axis=-1,.      
+00024a60: 7661 6c20 3d20 6675 6e63 2870 7473 2c20  val = func(pts, 
+00024a70: 743d 742c 202a 2a66 6b77 6461 7267 7329  t=t, **fkwdargs)
+00024a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00024a90: 2020 2020 2073 6967 5b3a 2c20 6969 5d20       sig[:, ii] 
+00024aa0: 3d20 7363 7069 6e74 672e 7369 6d70 7328  = scpintg.simps(
+00024ab0: 7661 6c2c 2078 3d4e 6f6e 652c 2061 7869  val, x=None, axi
+00024ac0: 733d 2d31 2c0a 2020 2020 2020 2020 2020  s=-1,.          
 00024ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024af0: 2020 2020 2020 2020 2020 6478 3d6c 6f63            dx=loc
-00024b00: 5f65 6666 5f72 6573 5b30 5d29 0a20 2020  _eff_res[0]).   
-00024b10: 2020 2020 2020 2020 2065 6c69 6620 6e5f           elif n_
-00024b20: 696d 6f64 6520 3d3d 2032 3a20 2023 2022  imode == 2:  # "
-00024b30: 726f 6d62 6572 6722 2069 6e74 6567 7261  romberg" integra
-00024b40: 7469 6f6e 206d 6f64 650a 2020 2020 2020  tion mode.      
-00024b50: 2020 2020 2020 2020 2020 666f 7220 6969            for ii
-00024b60: 2069 6e20 7261 6e67 6528 6e6c 6f73 293a   in range(nlos):
-00024b70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00024b80: 2020 2020 2070 7473 203d 205f 7374 2e63       pts = _st.c
-00024b90: 616c 6c5f 6765 745f 7361 6d70 6c65 5f73  all_get_sample_s
-00024ba0: 696e 676c 6528 6c69 6d73 5b30 2c20 6969  ingle(lims[0, ii
-00024bb0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00024af0: 2020 2020 2020 6478 3d6c 6f63 5f65 6666        dx=loc_eff
+00024b00: 5f72 6573 5b30 5d29 0a20 2020 2020 2020  _res[0]).       
+00024b10: 2020 2020 2065 6c69 6620 6e5f 696d 6f64       elif n_imod
+00024b20: 6520 3d3d 2032 3a20 2023 2022 726f 6d62  e == 2:  # "romb
+00024b30: 6572 6722 2069 6e74 6567 7261 7469 6f6e  erg" integration
+00024b40: 206d 6f64 650a 2020 2020 2020 2020 2020   mode.          
+00024b50: 2020 2020 2020 666f 7220 6969 2069 6e20        for ii in 
+00024b60: 7261 6e67 6528 6e6c 6f73 293a 0a20 2020  range(nlos):.   
+00024b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024b80: 2070 7473 203d 205f 7374 2e63 616c 6c5f   pts = _st.call_
+00024b90: 6765 745f 7361 6d70 6c65 5f73 696e 676c  get_sample_singl
+00024ba0: 6528 6c69 6d73 5b30 2c20 6969 5d2c 0a20  e(lims[0, ii],. 
+00024bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024be0: 2020 2020 2020 2020 6c69 6d73 5b31 2c20          lims[1, 
-00024bf0: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
+00024be0: 2020 2020 6c69 6d73 5b31 2c20 6969 5d2c      lims[1, ii],
+00024bf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00024c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024c20: 2020 2020 2020 2020 2020 7265 735f 6d76            res_mv
-00024c30: 5b69 695d 2c0a 2020 2020 2020 2020 2020  [ii],.          
+00024c20: 2020 2020 2020 7265 735f 6d76 5b69 695d        res_mv[ii]
+00024c30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 00024c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024c60: 2020 2020 2020 2020 2020 206e 5f64 6d6f             n_dmo
-00024c70: 6465 2c20 6e5f 696d 6f64 652c 0a20 2020  de, n_imode,.   
+00024c60: 2020 2020 2020 206e 5f64 6d6f 6465 2c20         n_dmode, 
+00024c70: 6e5f 696d 6f64 652c 0a20 2020 2020 2020  n_imode,.       
 00024c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024cb0: 2020 266c 6f63 5f65 6666 5f72 6573 5b30    &loc_eff_res[0
-00024cc0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00024ca0: 2020 2020 2020 2020 2020 2020 2020 266c                &l
+00024cb0: 6f63 5f65 6666 5f72 6573 5b30 5d2c 0a20  oc_eff_res[0],. 
+00024cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024cf0: 2020 2020 2020 2020 266e 625f 726f 7773          &nb_rows
-00024d00: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
+00024cf0: 2020 2020 266e 625f 726f 7773 5b30 5d2c      &nb_rows[0],
+00024d00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00024d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024d30: 2020 2020 2020 2020 2020 7261 795f 6f72            ray_or
-00024d40: 6967 5b3a 2c20 6969 3a69 692b 315d 2c0a  ig[:, ii:ii+1],.
+00024d30: 2020 2020 2020 7261 795f 6f72 6967 5b3a        ray_orig[:
+00024d40: 2c20 6969 3a69 692b 315d 2c0a 2020 2020  , ii:ii+1],.    
 00024d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024d80: 2020 2020 2072 6179 5f76 6469 725b 3a2c       ray_vdir[:,
-00024d90: 2069 693a 6969 2b31 5d29 0a20 2020 2020   ii:ii+1]).     
-00024da0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-00024db0: 616c 203d 2066 756e 6328 7074 732c 2074  al = func(pts, t
-00024dc0: 3d74 2c20 2a2a 666b 7764 6172 6773 290a  =t, **fkwdargs).
+00024d80: 2072 6179 5f76 6469 725b 3a2c 2069 693a   ray_vdir[:, ii:
+00024d90: 6969 2b31 5d29 0a20 2020 2020 2020 2020  ii+1]).         
+00024da0: 2020 2020 2020 2020 2020 2076 616c 203d             val =
+00024db0: 2066 756e 6328 7074 732c 2074 3d74 2c20   func(pts, t=t, 
+00024dc0: 2a2a 666b 7764 6172 6773 290a 2020 2020  **fkwdargs).    
 00024dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024de0: 2020 2020 7369 675b 3a2c 2069 695d 203d      sig[:, ii] =
-00024df0: 2073 6370 696e 7467 2e72 6f6d 6228 7661   scpintg.romb(va
-00024e00: 6c2c 2073 686f 773d 4661 6c73 652c 2061  l, show=False, a
-00024e10: 7869 733d 312c 0a20 2020 2020 2020 2020  xis=1,.         
+00024de0: 7369 675b 3a2c 2069 695d 203d 2073 6370  sig[:, ii] = scp
+00024df0: 696e 7467 2e72 6f6d 6228 7661 6c2c 2073  intg.romb(val, s
+00024e00: 686f 773d 4661 6c73 652c 2061 7869 733d  how=False, axis=
+00024e10: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
 00024e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00024e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024e40: 2020 2020 2064 783d 6c6f 635f 6566 665f       dx=loc_eff_
-00024e50: 7265 735b 305d 290a 2020 2020 7265 7475  res[0]).    retu
-00024e60: 726e 2073 6967 0a0a 0a23 2323 2323 2323  rn sig...#######
+00024e40: 2064 783d 6c6f 635f 6566 665f 7265 735b   dx=loc_eff_res[
+00024e50: 305d 290a 2020 2020 7265 7475 726e 2073  0]).    return s
+00024e60: 6967 0a0a 0a23 2323 2323 2323 2323 2323  ig...###########
 00024e70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00024e80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00024e90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024ea0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-00024eb0: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-00024ec0: 5369 6e6f 6772 616d 2d73 7065 6369 6669  Sinogram-specifi
-00024ed0: 630a 2323 2323 2323 2323 2323 2323 2323  c.##############
+00024ea0: 2323 2323 2323 2323 2323 230a 2320 2020  ###########.#   
+00024eb0: 2020 2020 2020 2020 2020 2020 5369 6e6f              Sino
+00024ec0: 6772 616d 2d73 7065 6369 6669 630a 2323  gram-specific.##
+00024ed0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00024ee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00024ef0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00024f00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024f10: 2323 2323 2323 2323 0a0a 0a64 6566 204c  ########...def L
-00024f20: 4f53 5f73 696e 6f5f 6669 6e64 526f 6f74  OS_sino_findRoot
-00024f30: 6b50 4d69 6e5f 546f 7228 646f 7562 6c65  kPMin_Tor(double
-00024f40: 2075 5061 724e 2c20 646f 7562 6c65 2075   uParN, double u
-00024f50: 4e2c 2064 6f75 626c 6520 5363 612c 2064  N, double Sca, d
-00024f60: 6f75 626c 6520 525a 302c 0a20 2020 2020  ouble RZ0,.     
+00024f10: 2323 2323 0a0a 0a64 6566 204c 4f53 5f73  ####...def LOS_s
+00024f20: 696e 6f5f 6669 6e64 526f 6f74 6b50 4d69  ino_findRootkPMi
+00024f30: 6e5f 546f 7228 646f 7562 6c65 2075 5061  n_Tor(double uPa
+00024f40: 724e 2c20 646f 7562 6c65 2075 4e2c 2064  rN, double uN, d
+00024f50: 6f75 626c 6520 5363 612c 2064 6f75 626c  ouble Sca, doubl
+00024f60: 6520 525a 302c 0a20 2020 2020 2020 2020  e RZ0,.         
 00024f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024f80: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-00024f90: 6520 525a 312c 2064 6f75 626c 6520 5363  e RZ1, double Sc
-00024fa0: 6150 2c20 646f 7562 6c65 2044 5061 724e  aP, double DParN
-00024fb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00024fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024fd0: 2020 646f 7562 6c65 206b 4f75 742c 2064    double kOut, d
-00024fe0: 6f75 626c 6520 4430 2c20 646f 7562 6c65  ouble D0, double
-00024ff0: 2044 312c 2064 6f75 626c 6520 4432 2c0a   D1, double D2,.
+00024f80: 2020 2020 2020 2064 6f75 626c 6520 525a         double RZ
+00024f90: 312c 2064 6f75 626c 6520 5363 6150 2c20  1, double ScaP, 
+00024fa0: 646f 7562 6c65 2044 5061 724e 2c0a 2020  double DParN,.  
+00024fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024fc0: 2020 2020 2020 2020 2020 2020 2020 646f                do
+00024fd0: 7562 6c65 206b 4f75 742c 2064 6f75 626c  uble kOut, doubl
+00024fe0: 6520 4430 2c20 646f 7562 6c65 2044 312c  e D0, double D1,
+00024ff0: 2064 6f75 626c 6520 4432 2c0a 2020 2020   double D2,.    
 00025000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025020: 646f 7562 6c65 2075 302c 2064 6f75 626c  double u0, doubl
-00025030: 6520 7531 2c20 646f 7562 6c65 2075 322c  e u1, double u2,
-00025040: 2073 7472 204d 6f64 653d 274c 4f53 2729   str Mode='LOS')
-00025050: 3a0a 2020 2020 2222 220a 2020 2020 5265  :.    """.    Re
-00025060: 6e64 7265 2022 7665 6374 6f72 6965 6c22  ndre "vectoriel"
-00025070: 2073 7572 204c 4f53 2065 7420 7375 7220   sur LOS et sur 
-00025080: 6c65 7320 6365 7263 6c65 7320 2864 6575  les cercles (deu
-00025090: 7820 626f 7563 6c65 7320 2266 6f72 2229  x boucles "for")
-000250a0: 0a20 2020 2069 6e74 6572 7365 6374 696f  .    intersectio
-000250b0: 6e20 6c69 676e 6520 6574 2063 6572 636c  n ligne et cercl
-000250c0: 650a 2020 2020 646f 7562 6c65 2075 5061  e.    double uPa
-000250d0: 724e 203a 2063 6f6d 706f 7361 6e74 6520  rN : composante 
-000250e0: 6465 2075 2070 6172 616c 6c65 6c20 6175  de u parallel au
-000250f0: 2070 6c61 6e20 2878 2c79 290a 2020 2020   plan (x,y).    
-00025100: 2020 2020 646f 7562 6c65 2075 4e20 3a20      double uN : 
-00025110: 757a 0a20 2020 2020 2020 2064 6f75 626c  uz.        doubl
-00025120: 6520 5363 6120 3a20 3f3f 3f20 7072 6f64  e Sca : ??? prod
-00025130: 7569 7420 7363 616c 6169 7265 202e 2e2e  uit scalaire ...
-00025140: 203f 0a20 2020 2020 2020 2064 6f75 626c   ?.        doubl
-00025150: 6520 525a 3020 3a20 4772 616e 6420 7261  e RZ0 : Grand ra
-00025160: 796f 6e20 6475 2063 6572 636c 650a 2020  yon du cercle.  
-00025170: 2020 2020 2020 646f 7562 6c65 2052 5a31        double RZ1
-00025180: 203a 205a 0a20 2020 2020 2020 203d 3e20   : Z.        => 
-00025190: 6365 7263 6c65 2065 7374 2063 656e 7472  cercle est centr
-000251a0: c3a9 2061 7520 706f 696e 7420 2830 2c20  .. au point (0, 
-000251b0: 302c 2052 5a31 2920 6574 2072 6179 6f6e  0, RZ1) et rayon
-000251c0: 2052 5a30 0a20 2020 2020 2020 2064 6f75   RZ0.        dou
-000251d0: 626c 6520 5363 6150 203a 202e 2e2e 2e20  ble ScaP : .... 
-000251e0: 3f0a 2020 2020 2020 2020 646f 7562 6c65  ?.        double
-000251f0: 2044 5061 724e 203a 2044 206f 7269 6769   DParN : D origi
-00025200: 6e65 2064 6520 4c4f 532e 2e2e 2e20 3f20  ne de LOS.... ? 
-00025210: 4e20 3d3e 206e 6f72 6d65 2064 6520 6c61  N => norme de la
-00025220: 2063 6f6d 706f 7361 6e74 6520 6475 2076   composante du v
-00025230: 6563 7465 7572 204f 440a 2020 2020 2020  ecteur OD.      
-00025240: 2020 646f 7562 6c65 206b 4f75 7420 3a20    double kOut : 
-00025250: 6b6d 6178 206f c3b9 206f 6e20 7065 7574  kmax o.. on peut
-00025260: 2074 726f 7576 6572 2075 6e20 72c3 a973   trouver un r..s
-00025270: 756c 7461 740a 2020 2020 2020 2020 646f  ultat.        do
-00025280: 7562 6c65 2044 302c 2064 6f75 626c 6520  uble D0, double 
-00025290: 4431 2c20 646f 7562 6c65 2044 3220 3a20  D1, double D2 : 
-000252a0: 636f 6d70 6f73 616e 7465 7320 6465 2044  composantes de D
-000252b0: 2028 6f72 6967 696e 6520 4c4f 5329 0a20   (origine LOS). 
-000252c0: 2020 2020 2020 2064 6f75 626c 6520 7530         double u0
-000252d0: 2c20 646f 7562 6c65 2075 312c 2064 6f75  , double u1, dou
-000252e0: 626c 6520 7532 203a 2063 6f6d 706f 7361  ble u2 : composa
-000252f0: 6e74 6573 2064 6520 5520 2864 6972 6563  ntes de U (direc
-00025300: 7469 6f6e 204c 4f53 290a 2020 2020 2020  tion LOS).      
-00025310: 2020 7374 7220 4d6f 6465 3d27 4c4f 5327    str Mode='LOS'
-00025320: 203a 2073 6920 4c4f 5320 7061 7320 6465   : si LOS pas de
-00025330: 2073 6f6c 2061 7072 c3a8 7320 6b6d 6178   sol apr..s kmax
-00025340: 290a 2020 2020 3a3a 3a20 4661 6972 6520  ).    ::: Faire 
-00025350: 756e 6520 666f 6e63 7469 6f6e 2064 6f75  une fonction dou
-00025360: 626c 6520 6d61 6973 2071 7569 2072 656e  ble mais qui ren
-00025370: 766f 6974 2051 5545 2075 6e20 7461 626c  voit QUE un tabl
-00025380: 6561 7520 6465 2062 6f6f 6c20 6176 6563  eau de bool avec
-00025390: 2074 7275 6520 7369 0a20 2020 206c 6120   true si.    la 
-000253a0: 6469 7374 616e 6365 2065 7374 2070 6c75  distance est plu
-000253b0: 7320 7065 7469 7465 2071 7527 756e 2063  s petite qu'un c
-000253c0: 6572 7461 696e 2065 7073 2c20 6661 6c73  ertain eps, fals
-000253d0: 6520 7369 6e6f 6e2e 0a20 2020 2054 4f44  e sinon..    TOD
-000253e0: 4f3a 202e 2e2e 2e2e 2e2e 2e2e 2e2e 2040  O: ........... @
-000253f0: 4c4d 0a20 2020 2022 2222 0a20 2020 2063  LM.    """.    c
-00025400: 6465 6620 646f 7562 6c65 2061 3420 3d20  def double a4 = 
-00025410: 2875 5061 724e 2a75 4e2a 754e 292a 2a32  (uParN*uN*uN)**2
-00025420: 2c20 6133 203d 2032 2a28 2028 5363 612d  , a3 = 2*( (Sca-
-00025430: 525a 312a 7532 292a 2875 5061 724e 2a75  RZ1*u2)*(uParN*u
-00025440: 4e29 2a2a 3220 2b20 5363 6150 2a75 4e2a  N)**2 + ScaP*uN*
-00025450: 2a34 2029 0a20 2020 2063 6465 6620 646f  *4 ).    cdef do
-00025460: 7562 6c65 2061 3220 3d20 2875 5061 724e  uble a2 = (uParN
-00025470: 2a28 5363 612d 525a 312a 7532 2929 2a2a  *(Sca-RZ1*u2))**
-00025480: 3220 2b20 342e 2a53 6361 502a 2853 6361  2 + 4.*ScaP*(Sca
-00025490: 2d52 5a31 2a75 3229 2a75 4e2a 2a32 202b  -RZ1*u2)*uN**2 +
-000254a0: 2028 4450 6172 4e2a 754e 2a75 4e29 2a2a   (DParN*uN*uN)**
-000254b0: 3220 2d20 2852 5a30 2a75 5061 724e 2a75  2 - (RZ0*uParN*u
-000254c0: 5061 724e 292a 2a32 0a20 2020 2063 6465  ParN)**2.    cde
-000254d0: 6620 646f 7562 6c65 2061 3120 3d20 322a  f double a1 = 2*
-000254e0: 2820 5363 6150 2a28 5363 612d 525a 312a  ( ScaP*(Sca-RZ1*
-000254f0: 7532 292a 2a32 202b 2028 5363 612d 525a  u2)**2 + (Sca-RZ
-00025500: 312a 7532 292a 2844 5061 724e 2a75 4e29  1*u2)*(DParN*uN)
-00025510: 2a2a 3220 2d20 5363 6150 2a28 525a 302a  **2 - ScaP*(RZ0*
-00025520: 7550 6172 4e29 2a2a 3220 290a 2020 2020  uParN)**2 ).    
-00025530: 6364 6566 2064 6f75 626c 6520 6130 203d  cdef double a0 =
-00025540: 2028 2853 6361 2d52 5a31 2a75 3229 2a44   ((Sca-RZ1*u2)*D
-00025550: 5061 724e 292a 2a32 202d 2028 525a 302a  ParN)**2 - (RZ0*
-00025560: 5363 6150 292a 2a32 0a20 2020 2063 6465  ScaP)**2.    cde
-00025570: 6620 6e70 2e6e 6461 7272 6179 2072 6f6f  f np.ndarray roo
-00025580: 203d 206e 702e 726f 6f74 7328 6e70 2e61   = np.roots(np.a
-00025590: 7272 6179 285b 6134 2c61 332c 6132 2c61  rray([a4,a3,a2,a
-000255a0: 312c 6130 5d29 290a 2020 2020 6364 6566  1,a0])).    cdef
-000255b0: 206c 6973 7420 4b4b 203d 206c 6973 7428   list KK = list(
-000255c0: 6e70 2e72 6561 6c28 726f 6f5b 6e70 2e69  np.real(roo[np.i
-000255d0: 7372 6561 6c28 726f 6f29 5d29 2920 2020  sreal(roo)]))   
-000255e0: 2320 5468 6572 6520 6d69 6768 7420 6265  # There might be
-000255f0: 2073 6576 6572 616c 2073 6f6c 7574 696f   several solutio
-00025600: 6e73 0a20 2020 2063 6465 6620 6c69 7374  ns.    cdef list
-00025610: 2050 6b2c 2050 6b32 442c 2072 6b0a 2020   Pk, Pk2D, rk.  
-00025620: 2020 6364 6566 2064 6f75 626c 6520 6b6b    cdef double kk
-00025630: 2c20 6b50 4d69 6e0a 2020 2020 6966 204d  , kPMin.    if M
-00025640: 6f64 653d 3d27 4c4f 5327 3a20 2020 2020  ode=='LOS':     
-00025650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025660: 2320 5461 6b65 2073 6f6c 7574 696f 6e20  # Take solution 
-00025670: 6f6e 2070 6879 7369 6361 6c20 4c4f 530a  on physical LOS.
-00025680: 2020 2020 2020 2020 6966 2061 6e79 285b          if any([
-00025690: 3020 3c3d 206b 6b20 3c3d 206b 4f75 7420  0 <= kk <= kOut 
-000256a0: 666f 7220 6b6b 2069 6e20 4b4b 5d29 3a0a  for kk in KK]):.
-000256b0: 2020 2020 2020 2020 2020 2020 4b4b 203d              KK =
-000256c0: 205b 6b6b 2066 6f72 206b 6b20 696e 204b   [kk for kk in K
-000256d0: 4b20 6966 2030 203c 3d20 6b6b 203c 3d20  K if 0 <= kk <= 
-000256e0: 6b4f 7574 5d0a 2020 2020 2020 2020 2020  kOut].          
-000256f0: 2020 506b 203d 205b 2844 302b 6b6b 2a75    Pk = [(D0+kk*u
-00025700: 302c 4431 2b6b 6b2a 7531 2c44 322b 6b6b  0,D1+kk*u1,D2+kk
-00025710: 2a75 3229 2066 6f72 206b 6b20 696e 204b  *u2) for kk in K
-00025720: 4b5d 0a20 2020 2020 2020 2020 2020 2050  K].            P
-00025730: 6b32 4420 3d20 5b28 635f 7371 7274 2870  k2D = [(c_sqrt(p
-00025740: 705b 305d 2a2a 322b 7070 5b31 5d2a 2a32  p[0]**2+pp[1]**2
-00025750: 292c 2070 705b 325d 2920 666f 7220 7070  ), pp[2]) for pp
-00025760: 2069 6e20 506b 5d0a 2020 2020 2020 2020   in Pk].        
-00025770: 2020 2020 726b 203d 205b 2870 705b 305d      rk = [(pp[0]
-00025780: 2d52 5a30 292a 2a32 2b28 7070 5b31 5d2d  -RZ0)**2+(pp[1]-
-00025790: 525a 3129 2a2a 3220 666f 7220 7070 2069  RZ1)**2 for pp i
-000257a0: 6e20 506b 3244 5d0a 2020 2020 2020 2020  n Pk2D].        
-000257b0: 2020 2020 6b50 4d69 6e20 3d20 4b4b 5b72      kPMin = KK[r
-000257c0: 6b2e 696e 6465 7828 6d69 6e28 726b 2929  k.index(min(rk))
-000257d0: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
-000257e0: 2020 2020 2020 2020 2020 2020 6b50 4d69              kPMi
-000257f0: 6e20 3d20 6d69 6e28 5b63 5f61 6273 286b  n = min([c_abs(k
-00025800: 6b29 2066 6f72 206b 6b20 696e 204b 4b5d  k) for kk in KK]
-00025810: 2920 2023 2045 6c73 652c 2074 616b 6520  )  # Else, take 
-00025820: 7468 6520 6f6e 6520 636c 6f73 6573 7420  the one closest 
-00025830: 746f 2044 0a20 2020 2065 6c73 653a 0a20  to D.    else:. 
-00025840: 2020 2020 2020 2050 6b20 3d20 5b28 4430         Pk = [(D0
-00025850: 2b6b 6b2a 7530 2c44 312b 6b6b 2a75 312c  +kk*u0,D1+kk*u1,
-00025860: 4432 2b6b 6b2a 7532 2920 666f 7220 6b6b  D2+kk*u2) for kk
-00025870: 2069 6e20 4b4b 5d0a 2020 2020 2020 2020   in KK].        
-00025880: 506b 3244 203d 205b 2863 5f73 7172 7428  Pk2D = [(c_sqrt(
-00025890: 7070 5b30 5d2a 2a32 2b70 705b 315d 2a2a  pp[0]**2+pp[1]**
-000258a0: 3229 2c20 7070 5b32 5d29 2066 6f72 2070  2), pp[2]) for p
-000258b0: 7020 696e 2050 6b5d 0a20 2020 2020 2020  p in Pk].       
-000258c0: 2072 6b20 3d20 5b28 7070 5b30 5d2d 525a   rk = [(pp[0]-RZ
-000258d0: 3029 2a2a 322b 2870 705b 315d 2d52 5a31  0)**2+(pp[1]-RZ1
-000258e0: 292a 2a32 2066 6f72 2070 7020 696e 2050  )**2 for pp in P
-000258f0: 6b32 445d 0a20 2020 2020 2020 206b 504d  k2D].        kPM
-00025900: 696e 203d 204b 4b5b 726b 2e69 6e64 6578  in = KK[rk.index
-00025910: 286d 696e 2872 6b29 295d 0a20 2020 2072  (min(rk))].    r
-00025920: 6574 7572 6e20 6b50 4d69 6e20 2320 2b20  eturn kPMin # + 
-00025930: 6469 7374 616e 6365 2061 7520 6365 7263  distance au cerc
-00025940: 6c65 0a0a 0a0a 6364 6566 204c 4f53 5f73  le....cdef LOS_s
-00025950: 696e 6f5f 546f 7228 646f 7562 6c65 2044  ino_Tor(double D
-00025960: 302c 2064 6f75 626c 6520 4431 2c20 646f  0, double D1, do
-00025970: 7562 6c65 2044 322c 2064 6f75 626c 6520  uble D2, double 
-00025980: 7530 2c20 646f 7562 6c65 2075 312c 0a20  u0, double u1,. 
-00025990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000259a0: 2064 6f75 626c 6520 7532 2c20 646f 7562   double u2, doub
-000259b0: 6c65 2052 5a30 2c20 646f 7562 6c65 2052  le RZ0, double R
-000259c0: 5a31 2c20 7374 7220 4d6f 6465 3d27 4c4f  Z1, str Mode='LO
-000259d0: 5327 2c20 646f 7562 6c65 0a20 2020 2020  S', double.     
-000259e0: 2020 2020 2020 2020 2020 2020 206b 4f75               kOu
-000259f0: 743d 435f 494e 4629 3a0a 0a20 2020 2063  t=C_INF):..    c
-00025a00: 6465 6620 646f 7562 6c65 2020 2020 754e  def double    uN
-00025a10: 203d 2063 5f73 7172 7428 7530 2a2a 322b   = c_sqrt(u0**2+
-00025a20: 7531 2a2a 322b 7532 2a2a 3229 2c20 7550  u1**2+u2**2), uP
-00025a30: 6172 4e20 3d20 635f 7371 7274 2875 302a  arN = c_sqrt(u0*
-00025a40: 2a32 2b75 312a 2a32 292c 2044 5061 724e  *2+u1**2), DParN
-00025a50: 203d 2063 5f73 7172 7428 4430 2a2a 322b   = c_sqrt(D0**2+
-00025a60: 4431 2a2a 3229 0a20 2020 2063 6465 6620  D1**2).    cdef 
-00025a70: 646f 7562 6c65 2020 2020 5363 6120 3d20  double    Sca = 
-00025a80: 7530 2a44 302b 7531 2a44 312b 7532 2a44  u0*D0+u1*D1+u2*D
-00025a90: 322c 2053 6361 5020 3d20 7530 2a44 302b  2, ScaP = u0*D0+
-00025aa0: 7531 2a44 310a 2020 2020 6364 6566 2064  u1*D1.    cdef d
-00025ab0: 6f75 626c 6520 2020 206b 504d 696e 0a20  ouble    kPMin. 
-00025ac0: 2020 2069 6620 7550 6172 4e20 3d3d 2030     if uParN == 0
-00025ad0: 2e3a 0a20 2020 2020 2020 206b 504d 696e  .:.        kPMin
-00025ae0: 203d 2028 525a 312d 4432 292f 7532 0a20   = (RZ1-D2)/u2. 
-00025af0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00025b00: 206b 504d 696e 203d 204c 4f53 5f73 696e   kPMin = LOS_sin
-00025b10: 6f5f 6669 6e64 526f 6f74 6b50 4d69 6e5f  o_findRootkPMin_
-00025b20: 546f 7228 7550 6172 4e2c 2075 4e2c 2053  Tor(uParN, uN, S
-00025b30: 6361 2c20 525a 302c 2052 5a31 2c20 5363  ca, RZ0, RZ1, Sc
-00025b40: 6150 2c20 4450 6172 4e2c 206b 4f75 742c  aP, DParN, kOut,
-00025b50: 2044 302c 2044 312c 2044 322c 2075 302c   D0, D1, D2, u0,
-00025b60: 2075 312c 2075 322c 204d 6f64 653d 4d6f   u1, u2, Mode=Mo
-00025b70: 6465 290a 2020 2020 6364 6566 2064 6f75  de).    cdef dou
-00025b80: 626c 6520 2020 2050 4d69 6e30 203d 2044  ble    PMin0 = D
-00025b90: 302b 6b50 4d69 6e2a 7530 2c20 504d 696e  0+kPMin*u0, PMin
-00025ba0: 3120 3d20 4431 2b6b 504d 696e 2a75 312c  1 = D1+kPMin*u1,
-00025bb0: 2050 4d69 6e32 203d 2044 322b 6b50 4d69   PMin2 = D2+kPMi
-00025bc0: 6e2a 7532 0a20 2020 2063 6465 6620 646f  n*u2.    cdef do
-00025bd0: 7562 6c65 2020 2020 504d 696e 326e 6f72  uble    PMin2nor
-00025be0: 6d20 3d20 635f 7371 7274 2850 4d69 6e30  m = c_sqrt(PMin0
-00025bf0: 2a2a 322b 504d 696e 312a 2a32 290a 2020  **2+PMin1**2).  
-00025c00: 2020 6364 6566 2064 6f75 626c 6520 2020    cdef double   
-00025c10: 2050 4d69 6e32 4430 203d 2050 4d69 6e32   PMin2D0 = PMin2
-00025c20: 6e6f 726d 2c20 504d 696e 3244 3120 3d20  norm, PMin2D1 = 
-00025c30: 504d 696e 320a 2020 2020 6364 6566 2064  PMin2.    cdef d
-00025c40: 6f75 626c 6520 2020 2052 4d69 6e20 3d20  ouble    RMin = 
-00025c50: 635f 7371 7274 2828 504d 696e 3244 302d  c_sqrt((PMin2D0-
-00025c60: 525a 3029 2a2a 322b 2850 4d69 6e32 4431  RZ0)**2+(PMin2D1
-00025c70: 2d52 5a31 292a 2a32 290a 2020 2020 6364  -RZ1)**2).    cd
-00025c80: 6566 2064 6f75 626c 6520 2020 2065 5468  ef double    eTh
-00025c90: 6574 6130 203d 202d 504d 696e 312f 504d  eta0 = -PMin1/PM
-00025ca0: 696e 326e 6f72 6d2c 2065 5468 6574 6131  in2norm, eTheta1
-00025cb0: 203d 2050 4d69 6e30 2f50 4d69 6e32 6e6f   = PMin0/PMin2no
-00025cc0: 726d 2c20 6554 6865 7461 3220 3d20 302e  rm, eTheta2 = 0.
-00025cd0: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-00025ce0: 2020 2020 7650 3020 3d20 504d 696e 3244      vP0 = PMin2D
-00025cf0: 302d 525a 302c 2076 5031 203d 2050 4d69  0-RZ0, vP1 = PMi
-00025d00: 6e32 4431 2d52 5a31 0a20 2020 2063 6465  n2D1-RZ1.    cde
-00025d10: 6620 646f 7562 6c65 2020 2020 5468 6574  f double    Thet
-00025d20: 6120 3d20 635f 6174 616e 3228 7650 312c  a = c_atan2(vP1,
-00025d30: 7650 3029 0a20 2020 2063 6465 6620 646f  vP0).    cdef do
-00025d40: 7562 6c65 2020 2020 496d 7054 6865 7461  uble    ImpTheta
-00025d50: 203d 2054 6865 7461 2069 6620 5468 6574   = Theta if Thet
-00025d60: 613e 3d30 2065 6c73 6520 5468 6574 6120  a>=0 else Theta 
-00025d70: 2b20 6e70 2e70 690a 2020 2020 6364 6566  + np.pi.    cdef
-00025d80: 2064 6f75 626c 6520 2020 2065 7232 4430   double    er2D0
-00025d90: 203d 2063 5f63 6f73 2849 6d70 5468 6574   = c_cos(ImpThet
-00025da0: 6129 2c20 6572 3244 3120 3d20 635f 7369  a), er2D1 = c_si
-00025db0: 6e28 496d 7054 6865 7461 290a 2020 2020  n(ImpTheta).    
-00025dc0: 6364 6566 2064 6f75 626c 6520 2020 2070  cdef double    p
-00025dd0: 203d 2076 5030 2a65 7232 4430 202b 2076   = vP0*er2D0 + v
-00025de0: 5031 2a65 7232 4431 0a20 2020 2063 6465  P1*er2D1.    cde
-00025df0: 6620 646f 7562 6c65 2020 2020 754e 3020  f double    uN0 
-00025e00: 3d20 7530 2f75 4e2c 2075 4e31 203d 2075  = u0/uN, uN1 = u
-00025e10: 312f 754e 2c20 754e 3220 3d20 7532 2f75  1/uN, uN2 = u2/u
-00025e20: 4e0a 2020 2020 6364 6566 2064 6f75 626c  N.    cdef doubl
-00025e30: 6520 2020 2070 6869 203d 2063 5f61 7369  e    phi = c_asi
-00025e40: 6e28 2d75 4e30 2a65 5468 6574 6130 202d  n(-uN0*eTheta0 -
-00025e50: 754e 312a 6554 6865 7461 3120 2d75 4e32  uN1*eTheta1 -uN2
-00025e60: 2a65 5468 6574 6132 290a 2020 2020 7265  *eTheta2).    re
-00025e70: 7475 726e 2028 504d 696e 302c 504d 696e  turn (PMin0,PMin
-00025e80: 312c 504d 696e 3229 2c20 6b50 4d69 6e2c  1,PMin2), kPMin,
-00025e90: 2052 4d69 6e2c 2054 6865 7461 2c20 702c   RMin, Theta, p,
-00025ea0: 2049 6d70 5468 6574 612c 2070 6869 0a0a   ImpTheta, phi..
-00025eb0: 0a0a 6364 6566 2069 6e6c 696e 6520 766f  ..cdef inline vo
-00025ec0: 6964 204e 4557 5f4c 4f53 5f73 696e 6f5f  id NEW_LOS_sino_
-00025ed0: 546f 7228 646f 7562 6c65 206f 7269 6730  Tor(double orig0
-00025ee0: 2c20 646f 7562 6c65 206f 7269 6731 2c20  , double orig1, 
-00025ef0: 646f 7562 6c65 206f 7269 6732 2c0a 2020  double orig2,.  
+00025010: 2020 2020 2020 2020 2020 2020 646f 7562              doub
+00025020: 6c65 2075 302c 2064 6f75 626c 6520 7531  le u0, double u1
+00025030: 2c20 646f 7562 6c65 2075 322c 2073 7472  , double u2, str
+00025040: 204d 6f64 653d 274c 4f53 2729 3a0a 2020   Mode='LOS'):.  
+00025050: 2020 2222 220a 2020 2020 5265 6e64 7265    """.    Rendre
+00025060: 2022 7665 6374 6f72 6965 6c22 2073 7572   "vectoriel" sur
+00025070: 204c 4f53 2065 7420 7375 7220 6c65 7320   LOS et sur les 
+00025080: 6365 7263 6c65 7320 2864 6575 7820 626f  cercles (deux bo
+00025090: 7563 6c65 7320 2266 6f72 2229 0a20 2020  ucles "for").   
+000250a0: 2069 6e74 6572 7365 6374 696f 6e20 6c69   intersection li
+000250b0: 676e 6520 6574 2063 6572 636c 650a 2020  gne et cercle.  
+000250c0: 2020 646f 7562 6c65 2075 5061 724e 203a    double uParN :
+000250d0: 2063 6f6d 706f 7361 6e74 6520 6465 2075   composante de u
+000250e0: 2070 6172 616c 6c65 6c20 6175 2070 6c61   parallel au pla
+000250f0: 6e20 2878 2c79 290a 2020 2020 2020 2020  n (x,y).        
+00025100: 646f 7562 6c65 2075 4e20 3a20 757a 0a20  double uN : uz. 
+00025110: 2020 2020 2020 2064 6f75 626c 6520 5363         double Sc
+00025120: 6120 3a20 3f3f 3f20 7072 6f64 7569 7420  a : ??? produit 
+00025130: 7363 616c 6169 7265 202e 2e2e 203f 0a20  scalaire ... ?. 
+00025140: 2020 2020 2020 2064 6f75 626c 6520 525a         double RZ
+00025150: 3020 3a20 4772 616e 6420 7261 796f 6e20  0 : Grand rayon 
+00025160: 6475 2063 6572 636c 650a 2020 2020 2020  du cercle.      
+00025170: 2020 646f 7562 6c65 2052 5a31 203a 205a    double RZ1 : Z
+00025180: 0a20 2020 2020 2020 203d 3e20 6365 7263  .        => cerc
+00025190: 6c65 2065 7374 2063 656e 7472 c3a9 2061  le est centr.. a
+000251a0: 7520 706f 696e 7420 2830 2c20 302c 2052  u point (0, 0, R
+000251b0: 5a31 2920 6574 2072 6179 6f6e 2052 5a30  Z1) et rayon RZ0
+000251c0: 0a20 2020 2020 2020 2064 6f75 626c 6520  .        double 
+000251d0: 5363 6150 203a 202e 2e2e 2e20 3f0a 2020  ScaP : .... ?.  
+000251e0: 2020 2020 2020 646f 7562 6c65 2044 5061        double DPa
+000251f0: 724e 203a 2044 206f 7269 6769 6e65 2064  rN : D origine d
+00025200: 6520 4c4f 532e 2e2e 2e20 3f20 4e20 3d3e  e LOS.... ? N =>
+00025210: 206e 6f72 6d65 2064 6520 6c61 2063 6f6d   norme de la com
+00025220: 706f 7361 6e74 6520 6475 2076 6563 7465  posante du vecte
+00025230: 7572 204f 440a 2020 2020 2020 2020 646f  ur OD.        do
+00025240: 7562 6c65 206b 4f75 7420 3a20 6b6d 6178  uble kOut : kmax
+00025250: 206f c3b9 206f 6e20 7065 7574 2074 726f   o.. on peut tro
+00025260: 7576 6572 2075 6e20 72c3 a973 756c 7461  uver un r..sulta
+00025270: 740a 2020 2020 2020 2020 646f 7562 6c65  t.        double
+00025280: 2044 302c 2064 6f75 626c 6520 4431 2c20   D0, double D1, 
+00025290: 646f 7562 6c65 2044 3220 3a20 636f 6d70  double D2 : comp
+000252a0: 6f73 616e 7465 7320 6465 2044 2028 6f72  osantes de D (or
+000252b0: 6967 696e 6520 4c4f 5329 0a20 2020 2020  igine LOS).     
+000252c0: 2020 2064 6f75 626c 6520 7530 2c20 646f     double u0, do
+000252d0: 7562 6c65 2075 312c 2064 6f75 626c 6520  uble u1, double 
+000252e0: 7532 203a 2063 6f6d 706f 7361 6e74 6573  u2 : composantes
+000252f0: 2064 6520 5520 2864 6972 6563 7469 6f6e   de U (direction
+00025300: 204c 4f53 290a 2020 2020 2020 2020 7374   LOS).        st
+00025310: 7220 4d6f 6465 3d27 4c4f 5327 203a 2073  r Mode='LOS' : s
+00025320: 6920 4c4f 5320 7061 7320 6465 2073 6f6c  i LOS pas de sol
+00025330: 2061 7072 c3a8 7320 6b6d 6178 290a 2020   apr..s kmax).  
+00025340: 2020 3a3a 3a20 4661 6972 6520 756e 6520    ::: Faire une 
+00025350: 666f 6e63 7469 6f6e 2064 6f75 626c 6520  fonction double 
+00025360: 6d61 6973 2071 7569 2072 656e 766f 6974  mais qui renvoit
+00025370: 2051 5545 2075 6e20 7461 626c 6561 7520   QUE un tableau 
+00025380: 6465 2062 6f6f 6c20 6176 6563 2074 7275  de bool avec tru
+00025390: 6520 7369 0a20 2020 206c 6120 6469 7374  e si.    la dist
+000253a0: 616e 6365 2065 7374 2070 6c75 7320 7065  ance est plus pe
+000253b0: 7469 7465 2071 7527 756e 2063 6572 7461  tite qu'un certa
+000253c0: 696e 2065 7073 2c20 6661 6c73 6520 7369  in eps, false si
+000253d0: 6e6f 6e2e 0a20 2020 2054 4f44 4f3a 202e  non..    TODO: .
+000253e0: 2e2e 2e2e 2e2e 2e2e 2e2e 2040 4c4d 0a20  .......... @LM. 
+000253f0: 2020 2022 2222 0a20 2020 2063 6465 6620     """.    cdef 
+00025400: 646f 7562 6c65 2061 3420 3d20 2875 5061  double a4 = (uPa
+00025410: 724e 2a75 4e2a 754e 292a 2a32 2c20 6133  rN*uN*uN)**2, a3
+00025420: 203d 2032 2a28 2028 5363 612d 525a 312a   = 2*( (Sca-RZ1*
+00025430: 7532 292a 2875 5061 724e 2a75 4e29 2a2a  u2)*(uParN*uN)**
+00025440: 3220 2b20 5363 6150 2a75 4e2a 2a34 2029  2 + ScaP*uN**4 )
+00025450: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00025460: 2061 3220 3d20 2875 5061 724e 2a28 5363   a2 = (uParN*(Sc
+00025470: 612d 525a 312a 7532 2929 2a2a 3220 2b20  a-RZ1*u2))**2 + 
+00025480: 342e 2a53 6361 502a 2853 6361 2d52 5a31  4.*ScaP*(Sca-RZ1
+00025490: 2a75 3229 2a75 4e2a 2a32 202b 2028 4450  *u2)*uN**2 + (DP
+000254a0: 6172 4e2a 754e 2a75 4e29 2a2a 3220 2d20  arN*uN*uN)**2 - 
+000254b0: 2852 5a30 2a75 5061 724e 2a75 5061 724e  (RZ0*uParN*uParN
+000254c0: 292a 2a32 0a20 2020 2063 6465 6620 646f  )**2.    cdef do
+000254d0: 7562 6c65 2061 3120 3d20 322a 2820 5363  uble a1 = 2*( Sc
+000254e0: 6150 2a28 5363 612d 525a 312a 7532 292a  aP*(Sca-RZ1*u2)*
+000254f0: 2a32 202b 2028 5363 612d 525a 312a 7532  *2 + (Sca-RZ1*u2
+00025500: 292a 2844 5061 724e 2a75 4e29 2a2a 3220  )*(DParN*uN)**2 
+00025510: 2d20 5363 6150 2a28 525a 302a 7550 6172  - ScaP*(RZ0*uPar
+00025520: 4e29 2a2a 3220 290a 2020 2020 6364 6566  N)**2 ).    cdef
+00025530: 2064 6f75 626c 6520 6130 203d 2028 2853   double a0 = ((S
+00025540: 6361 2d52 5a31 2a75 3229 2a44 5061 724e  ca-RZ1*u2)*DParN
+00025550: 292a 2a32 202d 2028 525a 302a 5363 6150  )**2 - (RZ0*ScaP
+00025560: 292a 2a32 0a20 2020 2063 6465 6620 6e70  )**2.    cdef np
+00025570: 2e6e 6461 7272 6179 2072 6f6f 203d 206e  .ndarray roo = n
+00025580: 702e 726f 6f74 7328 6e70 2e61 7272 6179  p.roots(np.array
+00025590: 285b 6134 2c61 332c 6132 2c61 312c 6130  ([a4,a3,a2,a1,a0
+000255a0: 5d29 290a 2020 2020 6364 6566 206c 6973  ])).    cdef lis
+000255b0: 7420 4b4b 203d 206c 6973 7428 6e70 2e72  t KK = list(np.r
+000255c0: 6561 6c28 726f 6f5b 6e70 2e69 7372 6561  eal(roo[np.isrea
+000255d0: 6c28 726f 6f29 5d29 2920 2020 2320 5468  l(roo)]))   # Th
+000255e0: 6572 6520 6d69 6768 7420 6265 2073 6576  ere might be sev
+000255f0: 6572 616c 2073 6f6c 7574 696f 6e73 0a20  eral solutions. 
+00025600: 2020 2063 6465 6620 6c69 7374 2050 6b2c     cdef list Pk,
+00025610: 2050 6b32 442c 2072 6b0a 2020 2020 6364   Pk2D, rk.    cd
+00025620: 6566 2064 6f75 626c 6520 6b6b 2c20 6b50  ef double kk, kP
+00025630: 4d69 6e0a 2020 2020 6966 204d 6f64 653d  Min.    if Mode=
+00025640: 3d27 4c4f 5327 3a20 2020 2020 2020 2020  ='LOS':         
+00025650: 2020 2020 2020 2020 2020 2020 2320 5461              # Ta
+00025660: 6b65 2073 6f6c 7574 696f 6e20 6f6e 2070  ke solution on p
+00025670: 6879 7369 6361 6c20 4c4f 530a 2020 2020  hysical LOS.    
+00025680: 2020 2020 6966 2061 6e79 285b 3020 3c3d      if any([0 <=
+00025690: 206b 6b20 3c3d 206b 4f75 7420 666f 7220   kk <= kOut for 
+000256a0: 6b6b 2069 6e20 4b4b 5d29 3a0a 2020 2020  kk in KK]):.    
+000256b0: 2020 2020 2020 2020 4b4b 203d 205b 6b6b          KK = [kk
+000256c0: 2066 6f72 206b 6b20 696e 204b 4b20 6966   for kk in KK if
+000256d0: 2030 203c 3d20 6b6b 203c 3d20 6b4f 7574   0 <= kk <= kOut
+000256e0: 5d0a 2020 2020 2020 2020 2020 2020 506b  ].            Pk
+000256f0: 203d 205b 2844 302b 6b6b 2a75 302c 4431   = [(D0+kk*u0,D1
+00025700: 2b6b 6b2a 7531 2c44 322b 6b6b 2a75 3229  +kk*u1,D2+kk*u2)
+00025710: 2066 6f72 206b 6b20 696e 204b 4b5d 0a20   for kk in KK]. 
+00025720: 2020 2020 2020 2020 2020 2050 6b32 4420             Pk2D 
+00025730: 3d20 5b28 635f 7371 7274 2870 705b 305d  = [(c_sqrt(pp[0]
+00025740: 2a2a 322b 7070 5b31 5d2a 2a32 292c 2070  **2+pp[1]**2), p
+00025750: 705b 325d 2920 666f 7220 7070 2069 6e20  p[2]) for pp in 
+00025760: 506b 5d0a 2020 2020 2020 2020 2020 2020  Pk].            
+00025770: 726b 203d 205b 2870 705b 305d 2d52 5a30  rk = [(pp[0]-RZ0
+00025780: 292a 2a32 2b28 7070 5b31 5d2d 525a 3129  )**2+(pp[1]-RZ1)
+00025790: 2a2a 3220 666f 7220 7070 2069 6e20 506b  **2 for pp in Pk
+000257a0: 3244 5d0a 2020 2020 2020 2020 2020 2020  2D].            
+000257b0: 6b50 4d69 6e20 3d20 4b4b 5b72 6b2e 696e  kPMin = KK[rk.in
+000257c0: 6465 7828 6d69 6e28 726b 2929 5d0a 2020  dex(min(rk))].  
+000257d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+000257e0: 2020 2020 2020 2020 6b50 4d69 6e20 3d20          kPMin = 
+000257f0: 6d69 6e28 5b63 5f61 6273 286b 6b29 2066  min([c_abs(kk) f
+00025800: 6f72 206b 6b20 696e 204b 4b5d 2920 2023  or kk in KK])  #
+00025810: 2045 6c73 652c 2074 616b 6520 7468 6520   Else, take the 
+00025820: 6f6e 6520 636c 6f73 6573 7420 746f 2044  one closest to D
+00025830: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00025840: 2020 2050 6b20 3d20 5b28 4430 2b6b 6b2a     Pk = [(D0+kk*
+00025850: 7530 2c44 312b 6b6b 2a75 312c 4432 2b6b  u0,D1+kk*u1,D2+k
+00025860: 6b2a 7532 2920 666f 7220 6b6b 2069 6e20  k*u2) for kk in 
+00025870: 4b4b 5d0a 2020 2020 2020 2020 506b 3244  KK].        Pk2D
+00025880: 203d 205b 2863 5f73 7172 7428 7070 5b30   = [(c_sqrt(pp[0
+00025890: 5d2a 2a32 2b70 705b 315d 2a2a 3229 2c20  ]**2+pp[1]**2), 
+000258a0: 7070 5b32 5d29 2066 6f72 2070 7020 696e  pp[2]) for pp in
+000258b0: 2050 6b5d 0a20 2020 2020 2020 2072 6b20   Pk].        rk 
+000258c0: 3d20 5b28 7070 5b30 5d2d 525a 3029 2a2a  = [(pp[0]-RZ0)**
+000258d0: 322b 2870 705b 315d 2d52 5a31 292a 2a32  2+(pp[1]-RZ1)**2
+000258e0: 2066 6f72 2070 7020 696e 2050 6b32 445d   for pp in Pk2D]
+000258f0: 0a20 2020 2020 2020 206b 504d 696e 203d  .        kPMin =
+00025900: 204b 4b5b 726b 2e69 6e64 6578 286d 696e   KK[rk.index(min
+00025910: 2872 6b29 295d 0a20 2020 2072 6574 7572  (rk))].    retur
+00025920: 6e20 6b50 4d69 6e20 2320 2b20 6469 7374  n kPMin # + dist
+00025930: 616e 6365 2061 7520 6365 7263 6c65 0a0a  ance au cercle..
+00025940: 0a0a 6364 6566 204c 4f53 5f73 696e 6f5f  ..cdef LOS_sino_
+00025950: 546f 7228 646f 7562 6c65 2044 302c 2064  Tor(double D0, d
+00025960: 6f75 626c 6520 4431 2c20 646f 7562 6c65  ouble D1, double
+00025970: 2044 322c 2064 6f75 626c 6520 7530 2c20   D2, double u0, 
+00025980: 646f 7562 6c65 2075 312c 0a20 2020 2020  double u1,.     
+00025990: 2020 2020 2020 2020 2020 2020 2064 6f75               dou
+000259a0: 626c 6520 7532 2c20 646f 7562 6c65 2052  ble u2, double R
+000259b0: 5a30 2c20 646f 7562 6c65 2052 5a31 2c20  Z0, double RZ1, 
+000259c0: 7374 7220 4d6f 6465 3d27 4c4f 5327 2c20  str Mode='LOS', 
+000259d0: 646f 7562 6c65 0a20 2020 2020 2020 2020  double.         
+000259e0: 2020 2020 2020 2020 206b 4f75 743d 435f           kOut=C_
+000259f0: 494e 4629 3a0a 0a20 2020 2063 6465 6620  INF):..    cdef 
+00025a00: 646f 7562 6c65 2020 2020 754e 203d 2063  double    uN = c
+00025a10: 5f73 7172 7428 7530 2a2a 322b 7531 2a2a  _sqrt(u0**2+u1**
+00025a20: 322b 7532 2a2a 3229 2c20 7550 6172 4e20  2+u2**2), uParN 
+00025a30: 3d20 635f 7371 7274 2875 302a 2a32 2b75  = c_sqrt(u0**2+u
+00025a40: 312a 2a32 292c 2044 5061 724e 203d 2063  1**2), DParN = c
+00025a50: 5f73 7172 7428 4430 2a2a 322b 4431 2a2a  _sqrt(D0**2+D1**
+00025a60: 3229 0a20 2020 2063 6465 6620 646f 7562  2).    cdef doub
+00025a70: 6c65 2020 2020 5363 6120 3d20 7530 2a44  le    Sca = u0*D
+00025a80: 302b 7531 2a44 312b 7532 2a44 322c 2053  0+u1*D1+u2*D2, S
+00025a90: 6361 5020 3d20 7530 2a44 302b 7531 2a44  caP = u0*D0+u1*D
+00025aa0: 310a 2020 2020 6364 6566 2064 6f75 626c  1.    cdef doubl
+00025ab0: 6520 2020 206b 504d 696e 0a20 2020 2069  e    kPMin.    i
+00025ac0: 6620 7550 6172 4e20 3d3d 2030 2e3a 0a20  f uParN == 0.:. 
+00025ad0: 2020 2020 2020 206b 504d 696e 203d 2028         kPMin = (
+00025ae0: 525a 312d 4432 292f 7532 0a20 2020 2065  RZ1-D2)/u2.    e
+00025af0: 6c73 653a 0a20 2020 2020 2020 206b 504d  lse:.        kPM
+00025b00: 696e 203d 204c 4f53 5f73 696e 6f5f 6669  in = LOS_sino_fi
+00025b10: 6e64 526f 6f74 6b50 4d69 6e5f 546f 7228  ndRootkPMin_Tor(
+00025b20: 7550 6172 4e2c 2075 4e2c 2053 6361 2c20  uParN, uN, Sca, 
+00025b30: 525a 302c 2052 5a31 2c20 5363 6150 2c20  RZ0, RZ1, ScaP, 
+00025b40: 4450 6172 4e2c 206b 4f75 742c 2044 302c  DParN, kOut, D0,
+00025b50: 2044 312c 2044 322c 2075 302c 2075 312c   D1, D2, u0, u1,
+00025b60: 2075 322c 204d 6f64 653d 4d6f 6465 290a   u2, Mode=Mode).
+00025b70: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
+00025b80: 2020 2050 4d69 6e30 203d 2044 302b 6b50     PMin0 = D0+kP
+00025b90: 4d69 6e2a 7530 2c20 504d 696e 3120 3d20  Min*u0, PMin1 = 
+00025ba0: 4431 2b6b 504d 696e 2a75 312c 2050 4d69  D1+kPMin*u1, PMi
+00025bb0: 6e32 203d 2044 322b 6b50 4d69 6e2a 7532  n2 = D2+kPMin*u2
+00025bc0: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00025bd0: 2020 2020 504d 696e 326e 6f72 6d20 3d20      PMin2norm = 
+00025be0: 635f 7371 7274 2850 4d69 6e30 2a2a 322b  c_sqrt(PMin0**2+
+00025bf0: 504d 696e 312a 2a32 290a 2020 2020 6364  PMin1**2).    cd
+00025c00: 6566 2064 6f75 626c 6520 2020 2050 4d69  ef double    PMi
+00025c10: 6e32 4430 203d 2050 4d69 6e32 6e6f 726d  n2D0 = PMin2norm
+00025c20: 2c20 504d 696e 3244 3120 3d20 504d 696e  , PMin2D1 = PMin
+00025c30: 320a 2020 2020 6364 6566 2064 6f75 626c  2.    cdef doubl
+00025c40: 6520 2020 2052 4d69 6e20 3d20 635f 7371  e    RMin = c_sq
+00025c50: 7274 2828 504d 696e 3244 302d 525a 3029  rt((PMin2D0-RZ0)
+00025c60: 2a2a 322b 2850 4d69 6e32 4431 2d52 5a31  **2+(PMin2D1-RZ1
+00025c70: 292a 2a32 290a 2020 2020 6364 6566 2064  )**2).    cdef d
+00025c80: 6f75 626c 6520 2020 2065 5468 6574 6130  ouble    eTheta0
+00025c90: 203d 202d 504d 696e 312f 504d 696e 326e   = -PMin1/PMin2n
+00025ca0: 6f72 6d2c 2065 5468 6574 6131 203d 2050  orm, eTheta1 = P
+00025cb0: 4d69 6e30 2f50 4d69 6e32 6e6f 726d 2c20  Min0/PMin2norm, 
+00025cc0: 6554 6865 7461 3220 3d20 302e 0a20 2020  eTheta2 = 0..   
+00025cd0: 2063 6465 6620 646f 7562 6c65 2020 2020   cdef double    
+00025ce0: 7650 3020 3d20 504d 696e 3244 302d 525a  vP0 = PMin2D0-RZ
+00025cf0: 302c 2076 5031 203d 2050 4d69 6e32 4431  0, vP1 = PMin2D1
+00025d00: 2d52 5a31 0a20 2020 2063 6465 6620 646f  -RZ1.    cdef do
+00025d10: 7562 6c65 2020 2020 5468 6574 6120 3d20  uble    Theta = 
+00025d20: 635f 6174 616e 3228 7650 312c 7650 3029  c_atan2(vP1,vP0)
+00025d30: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00025d40: 2020 2020 496d 7054 6865 7461 203d 2054      ImpTheta = T
+00025d50: 6865 7461 2069 6620 5468 6574 613e 3d30  heta if Theta>=0
+00025d60: 2065 6c73 6520 5468 6574 6120 2b20 6e70   else Theta + np
+00025d70: 2e70 690a 2020 2020 6364 6566 2064 6f75  .pi.    cdef dou
+00025d80: 626c 6520 2020 2065 7232 4430 203d 2063  ble    er2D0 = c
+00025d90: 5f63 6f73 2849 6d70 5468 6574 6129 2c20  _cos(ImpTheta), 
+00025da0: 6572 3244 3120 3d20 635f 7369 6e28 496d  er2D1 = c_sin(Im
+00025db0: 7054 6865 7461 290a 2020 2020 6364 6566  pTheta).    cdef
+00025dc0: 2064 6f75 626c 6520 2020 2070 203d 2076   double    p = v
+00025dd0: 5030 2a65 7232 4430 202b 2076 5031 2a65  P0*er2D0 + vP1*e
+00025de0: 7232 4431 0a20 2020 2063 6465 6620 646f  r2D1.    cdef do
+00025df0: 7562 6c65 2020 2020 754e 3020 3d20 7530  uble    uN0 = u0
+00025e00: 2f75 4e2c 2075 4e31 203d 2075 312f 754e  /uN, uN1 = u1/uN
+00025e10: 2c20 754e 3220 3d20 7532 2f75 4e0a 2020  , uN2 = u2/uN.  
+00025e20: 2020 6364 6566 2064 6f75 626c 6520 2020    cdef double   
+00025e30: 2070 6869 203d 2063 5f61 7369 6e28 2d75   phi = c_asin(-u
+00025e40: 4e30 2a65 5468 6574 6130 202d 754e 312a  N0*eTheta0 -uN1*
+00025e50: 6554 6865 7461 3120 2d75 4e32 2a65 5468  eTheta1 -uN2*eTh
+00025e60: 6574 6132 290a 2020 2020 7265 7475 726e  eta2).    return
+00025e70: 2028 504d 696e 302c 504d 696e 312c 504d   (PMin0,PMin1,PM
+00025e80: 696e 3229 2c20 6b50 4d69 6e2c 2052 4d69  in2), kPMin, RMi
+00025e90: 6e2c 2054 6865 7461 2c20 702c 2049 6d70  n, Theta, p, Imp
+00025ea0: 5468 6574 612c 2070 6869 0a0a 0a0a 6364  Theta, phi....cd
+00025eb0: 6566 2069 6e6c 696e 6520 766f 6964 204e  ef inline void N
+00025ec0: 4557 5f4c 4f53 5f73 696e 6f5f 546f 7228  EW_LOS_sino_Tor(
+00025ed0: 646f 7562 6c65 206f 7269 6730 2c20 646f  double orig0, do
+00025ee0: 7562 6c65 206f 7269 6731 2c20 646f 7562  uble orig1, doub
+00025ef0: 6c65 206f 7269 6732 2c0a 2020 2020 2020  le orig2,.      
 00025f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025f20: 646f 7562 6c65 2064 6972 7630 2c20 646f  double dirv0, do
-00025f30: 7562 6c65 2064 6972 7631 2c20 646f 7562  uble dirv1, doub
-00025f40: 6c65 2064 6972 7632 2c0a 2020 2020 2020  le dirv2,.      
+00025f10: 2020 2020 2020 2020 2020 2020 646f 7562              doub
+00025f20: 6c65 2064 6972 7630 2c20 646f 7562 6c65  le dirv0, double
+00025f30: 2064 6972 7631 2c20 646f 7562 6c65 2064   dirv1, double d
+00025f40: 6972 7632 2c0a 2020 2020 2020 2020 2020  irv2,.          
 00025f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025f60: 2020 2020 2020 2020 2020 2020 646f 7562              doub
-00025f70: 6c65 2063 6972 635f 7261 6469 7573 2c20  le circ_radius, 
-00025f80: 646f 7562 6c65 2063 6972 635f 6e6f 726d  double circ_norm
-00025f90: 7a2c 0a20 2020 2020 2020 2020 2020 2020  z,.             
+00025f60: 2020 2020 2020 2020 646f 7562 6c65 2063          double c
+00025f70: 6972 635f 7261 6469 7573 2c20 646f 7562  irc_radius, doub
+00025f80: 6c65 2063 6972 635f 6e6f 726d 7a2c 0a20  le circ_normz,. 
+00025f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00025fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025fb0: 2020 2020 2064 6f75 626c 655b 395d 2072       double[9] r
-00025fc0: 6573 756c 7473 2c0a 2020 2020 2020 2020  esults,.        
+00025fb0: 2064 6f75 626c 655b 395d 2072 6573 756c   double[9] resul
+00025fc0: 7473 2c0a 2020 2020 2020 2020 2020 2020  ts,.            
 00025fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025fe0: 2020 2020 2020 2020 2020 6269 6e74 2069            bint i
-00025ff0: 735f 4c4f 535f 4d6f 6465 3d46 616c 7365  s_LOS_Mode=False
-00026000: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00025fe0: 2020 2020 2020 6269 6e74 2069 735f 4c4f        bint is_LO
+00025ff0: 535f 4d6f 6465 3d46 616c 7365 2c0a 2020  S_Mode=False,.  
+00026000: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00026010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026020: 2020 2020 646f 7562 6c65 206b 4f75 743d      double kOut=
-00026030: 435f 494e 4629 206e 6f67 696c 3a0a 2020  C_INF) nogil:.  
-00026040: 2020 6364 6566 2064 6f75 626c 655b 335d    cdef double[3]
-00026050: 2064 6972 762c 206f 7269 670a 2020 2020   dirv, orig.    
-00026060: 6364 6566 2064 6f75 626c 655b 325d 2072  cdef double[2] r
-00026070: 6573 0a20 2020 2063 6465 6620 646f 7562  es.    cdef doub
-00026080: 6c65 206e 6f72 6d75 2c20 6e6f 726d 755f  le normu, normu_
-00026090: 7371 720a 2020 2020 6364 6566 2064 6f75  sqr.    cdef dou
-000260a0: 626c 6520 6b50 4d69 6e0a 0a20 2020 206e  ble kPMin..    n
-000260b0: 6f72 6d75 5f73 7172 203d 2064 6972 7630  ormu_sqr = dirv0
-000260c0: 202a 2064 6972 7630 202b 2064 6972 7631   * dirv0 + dirv1
-000260d0: 202a 2064 6972 7631 202b 2064 6972 7632   * dirv1 + dirv2
-000260e0: 202a 2064 6972 7632 0a20 2020 206e 6f72   * dirv2.    nor
-000260f0: 6d75 203d 2063 5f73 7172 7428 6e6f 726d  mu = c_sqrt(norm
-00026100: 755f 7371 7229 0a20 2020 2064 6972 765b  u_sqr).    dirv[
-00026110: 305d 203d 2064 6972 7630 0a20 2020 2064  0] = dirv0.    d
-00026120: 6972 765b 325d 203d 2064 6972 7632 0a20  irv[2] = dirv2. 
-00026130: 2020 2064 6972 765b 315d 203d 2064 6972     dirv[1] = dir
-00026140: 7631 0a20 2020 206f 7269 675b 305d 203d  v1.    orig[0] =
-00026150: 206f 7269 6730 0a20 2020 206f 7269 675b   orig0.    orig[
-00026160: 315d 203d 206f 7269 6731 0a20 2020 206f  1] = orig1.    o
-00026170: 7269 675b 325d 203d 206f 7269 6732 0a0a  rig[2] = orig2..
-00026180: 2020 2020 6966 2064 6972 7630 203d 3d20      if dirv0 == 
-00026190: 302e 2061 6e64 2064 6972 7631 203d 3d20  0. and dirv1 == 
-000261a0: 302e 3a0a 2020 2020 2020 2020 6b50 4d69  0.:.        kPMi
-000261b0: 6e20 3d20 2863 6972 635f 6e6f 726d 7a2d  n = (circ_normz-
-000261c0: 6f72 6967 3229 2f64 6972 7632 0a20 2020  orig2)/dirv2.   
-000261d0: 2065 6c73 653a 0a20 2020 2020 2020 205f   else:.        _
-000261e0: 6474 2e64 6973 745f 6c6f 735f 6369 7263  dt.dist_los_circ
-000261f0: 6c65 5f63 6f72 6528 6469 7276 2c20 6f72  le_core(dirv, or
-00026200: 6967 2c0a 2020 2020 2020 2020 2020 2020  ig,.            
+00026020: 646f 7562 6c65 206b 4f75 743d 435f 494e  double kOut=C_IN
+00026030: 4629 206e 6f67 696c 3a0a 2020 2020 6364  F) nogil:.    cd
+00026040: 6566 2064 6f75 626c 655b 335d 2064 6972  ef double[3] dir
+00026050: 762c 206f 7269 670a 2020 2020 6364 6566  v, orig.    cdef
+00026060: 2064 6f75 626c 655b 325d 2072 6573 0a20   double[2] res. 
+00026070: 2020 2063 6465 6620 646f 7562 6c65 206e     cdef double n
+00026080: 6f72 6d75 2c20 6e6f 726d 755f 7371 720a  ormu, normu_sqr.
+00026090: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
+000260a0: 6b50 4d69 6e0a 0a20 2020 206e 6f72 6d75  kPMin..    normu
+000260b0: 5f73 7172 203d 2064 6972 7630 202a 2064  _sqr = dirv0 * d
+000260c0: 6972 7630 202b 2064 6972 7631 202a 2064  irv0 + dirv1 * d
+000260d0: 6972 7631 202b 2064 6972 7632 202a 2064  irv1 + dirv2 * d
+000260e0: 6972 7632 0a20 2020 206e 6f72 6d75 203d  irv2.    normu =
+000260f0: 2063 5f73 7172 7428 6e6f 726d 755f 7371   c_sqrt(normu_sq
+00026100: 7229 0a20 2020 2064 6972 765b 305d 203d  r).    dirv[0] =
+00026110: 2064 6972 7630 0a20 2020 2064 6972 765b   dirv0.    dirv[
+00026120: 325d 203d 2064 6972 7632 0a20 2020 2064  2] = dirv2.    d
+00026130: 6972 765b 315d 203d 2064 6972 7631 0a20  irv[1] = dirv1. 
+00026140: 2020 206f 7269 675b 305d 203d 206f 7269     orig[0] = ori
+00026150: 6730 0a20 2020 206f 7269 675b 315d 203d  g0.    orig[1] =
+00026160: 206f 7269 6731 0a20 2020 206f 7269 675b   orig1.    orig[
+00026170: 325d 203d 206f 7269 6732 0a0a 2020 2020  2] = orig2..    
+00026180: 6966 2064 6972 7630 203d 3d20 302e 2061  if dirv0 == 0. a
+00026190: 6e64 2064 6972 7631 203d 3d20 302e 3a0a  nd dirv1 == 0.:.
+000261a0: 2020 2020 2020 2020 6b50 4d69 6e20 3d20          kPMin = 
+000261b0: 2863 6972 635f 6e6f 726d 7a2d 6f72 6967  (circ_normz-orig
+000261c0: 3229 2f64 6972 7632 0a20 2020 2065 6c73  2)/dirv2.    els
+000261d0: 653a 0a20 2020 2020 2020 205f 6474 2e64  e:.        _dt.d
+000261e0: 6973 745f 6c6f 735f 6369 7263 6c65 5f63  ist_los_circle_c
+000261f0: 6f72 6528 6469 7276 2c20 6f72 6967 2c0a  ore(dirv, orig,.
+00026200: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00026210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026220: 2020 2020 6369 7263 5f72 6164 6975 732c      circ_radius,
-00026230: 2063 6972 635f 6e6f 726d 7a2c 0a20 2020   circ_normz,.   
+00026220: 6369 7263 5f72 6164 6975 732c 2063 6972  circ_radius, cir
+00026230: 635f 6e6f 726d 7a2c 0a20 2020 2020 2020  c_normz,.       
 00026240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026250: 2020 2020 2020 2020 2020 2020 206e 6f72               nor
-00026260: 6d75 5f73 7172 2c20 7265 7329 0a20 2020  mu_sqr, res).   
-00026270: 2020 2020 206b 504d 696e 203d 2072 6573       kPMin = res
-00026280: 5b30 5d0a 2020 2020 2020 2020 6966 2069  [0].        if i
-00026290: 735f 4c4f 535f 4d6f 6465 2061 6e64 206b  s_LOS_Mode and k
-000262a0: 504d 696e 203e 206b 4f75 743a 0a20 2020  PMin > kOut:.   
-000262b0: 2020 2020 2020 2020 206b 504d 696e 203d           kPMin =
-000262c0: 206b 4f75 740a 0a20 2020 2023 2043 6f6d   kOut..    # Com
-000262d0: 7075 7469 6e67 2074 6865 2070 6f69 6e74  puting the point
-000262e0: 2773 2063 6f6f 7264 696e 6174 6573 2e2e  's coordinates..
+00026250: 2020 2020 2020 2020 206e 6f72 6d75 5f73           normu_s
+00026260: 7172 2c20 7265 7329 0a20 2020 2020 2020  qr, res).       
+00026270: 206b 504d 696e 203d 2072 6573 5b30 5d0a   kPMin = res[0].
+00026280: 2020 2020 2020 2020 6966 2069 735f 4c4f          if is_LO
+00026290: 535f 4d6f 6465 2061 6e64 206b 504d 696e  S_Mode and kPMin
+000262a0: 203e 206b 4f75 743a 0a20 2020 2020 2020   > kOut:.       
+000262b0: 2020 2020 206b 504d 696e 203d 206b 4f75       kPMin = kOu
+000262c0: 740a 0a20 2020 2023 2043 6f6d 7075 7469  t..    # Computi
+000262d0: 6e67 2074 6865 2070 6f69 6e74 2773 2063  ng the point's c
+000262e0: 6f6f 7264 696e 6174 6573 2e2e 2e2e 2e2e  oordinates......
 000262f0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00026300: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00026310: 2e2e 2e2e 2e2e 2e0a 2020 2020 6364 6566  ........    cdef
-00026320: 2064 6f75 626c 6520 504d 696e 3020 3d20   double PMin0 = 
-00026330: 6f72 6967 3020 2b20 6b50 4d69 6e20 2a20  orig0 + kPMin * 
-00026340: 6469 7276 300a 2020 2020 6364 6566 2064  dirv0.    cdef d
-00026350: 6f75 626c 6520 504d 696e 3120 3d20 6f72  ouble PMin1 = or
-00026360: 6967 3120 2b20 6b50 4d69 6e20 2a20 6469  ig1 + kPMin * di
-00026370: 7276 310a 2020 2020 6364 6566 2064 6f75  rv1.    cdef dou
-00026380: 626c 6520 504d 696e 3220 3d20 6f72 6967  ble PMin2 = orig
-00026390: 3220 2b20 6b50 4d69 6e20 2a20 6469 7276  2 + kPMin * dirv
-000263a0: 320a 2020 2020 6364 6566 2064 6f75 626c  2.    cdef doubl
-000263b0: 6520 504d 696e 326e 6f72 6d20 3d20 635f  e PMin2norm = c_
-000263c0: 7371 7274 2850 4d69 6e30 2a2a 322b 504d  sqrt(PMin0**2+PM
-000263d0: 696e 312a 2a32 290a 2020 2020 6364 6566  in1**2).    cdef
-000263e0: 2064 6f75 626c 6520 524d 696e 203d 2063   double RMin = c
-000263f0: 5f73 7172 7428 2850 4d69 6e32 6e6f 726d  _sqrt((PMin2norm
-00026400: 202d 2063 6972 635f 7261 6469 7573 292a   - circ_radius)*
-00026410: 2a32 0a20 2020 2020 2020 2020 2020 2020  *2.             
-00026420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026430: 2b20 2850 4d69 6e32 2020 202d 2063 6972  + (PMin2   - cir
-00026440: 635f 6e6f 726d 7a29 2a2a 3229 0a20 2020  c_normz)**2).   
-00026450: 2063 6465 6620 646f 7562 6c65 2076 5030   cdef double vP0
-00026460: 203d 2050 4d69 6e32 6e6f 726d 202d 2063   = PMin2norm - c
-00026470: 6972 635f 7261 6469 7573 0a20 2020 2063  irc_radius.    c
-00026480: 6465 6620 646f 7562 6c65 2076 5031 203d  def double vP1 =
-00026490: 2050 4d69 6e32 2020 2020 202d 2063 6972   PMin2     - cir
-000264a0: 635f 6e6f 726d 7a0a 2020 2020 6364 6566  c_normz.    cdef
-000264b0: 2064 6f75 626c 6520 5468 6574 6120 3d20   double Theta = 
-000264c0: 635f 6174 616e 3228 7650 312c 2076 5030  c_atan2(vP1, vP0
-000264d0: 290a 2020 2020 6364 6566 2064 6f75 626c  ).    cdef doubl
-000264e0: 6520 496d 7054 6865 7461 203d 2054 6865  e ImpTheta = The
-000264f0: 7461 2069 6620 5468 6574 613e 3d30 2065  ta if Theta>=0 e
-00026500: 6c73 6520 5468 6574 6120 2b20 635f 7069  lse Theta + c_pi
-00026510: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-00026520: 2065 7232 4430 203d 2063 5f63 6f73 2849   er2D0 = c_cos(I
-00026530: 6d70 5468 6574 6129 0a20 2020 2063 6465  mpTheta).    cde
-00026540: 6620 646f 7562 6c65 2065 7232 4431 203d  f double er2D1 =
-00026550: 2063 5f73 696e 2849 6d70 5468 6574 6129   c_sin(ImpTheta)
-00026560: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-00026570: 2070 3020 3d20 7650 302a 6572 3244 3020   p0 = vP0*er2D0 
-00026580: 2b20 7650 312a 6572 3244 310a 2020 2020  + vP1*er2D1.    
-00026590: 6364 6566 2064 6f75 626c 6520 6554 6865  cdef double eThe
-000265a0: 7461 3020 3d20 2d50 4d69 6e31 202f 2050  ta0 = -PMin1 / P
-000265b0: 4d69 6e32 6e6f 726d 0a20 2020 2063 6465  Min2norm.    cde
-000265c0: 6620 646f 7562 6c65 2065 5468 6574 6131  f double eTheta1
-000265d0: 203d 2020 504d 696e 3020 2f20 504d 696e   =  PMin0 / PMin
-000265e0: 326e 6f72 6d0a 2020 2020 6364 6566 2064  2norm.    cdef d
-000265f0: 6f75 626c 6520 6e6f 726d 7530 203d 2064  ouble normu0 = d
-00026600: 6972 7630 2f6e 6f72 6d75 0a20 2020 2063  irv0/normu.    c
-00026610: 6465 6620 646f 7562 6c65 206e 6f72 6d75  def double normu
-00026620: 3120 3d20 6469 7276 312f 6e6f 726d 750a  1 = dirv1/normu.
-00026630: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
-00026640: 7068 6920 3d20 635f 6173 696e 282d 6e6f  phi = c_asin(-no
-00026650: 726d 7530 202a 2065 5468 6574 6130 202d  rmu0 * eTheta0 -
-00026660: 206e 6f72 6d75 3120 2a20 6554 6865 7461   normu1 * eTheta
-00026670: 3129 0a20 2020 2023 2046 696c 6c69 6e67  1).    # Filling
-00026680: 2074 6865 2072 6573 756c 7473 202e 2e2e   the results ...
+00026310: 2e2e 2e0a 2020 2020 6364 6566 2064 6f75  ....    cdef dou
+00026320: 626c 6520 504d 696e 3020 3d20 6f72 6967  ble PMin0 = orig
+00026330: 3020 2b20 6b50 4d69 6e20 2a20 6469 7276  0 + kPMin * dirv
+00026340: 300a 2020 2020 6364 6566 2064 6f75 626c  0.    cdef doubl
+00026350: 6520 504d 696e 3120 3d20 6f72 6967 3120  e PMin1 = orig1 
+00026360: 2b20 6b50 4d69 6e20 2a20 6469 7276 310a  + kPMin * dirv1.
+00026370: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
+00026380: 504d 696e 3220 3d20 6f72 6967 3220 2b20  PMin2 = orig2 + 
+00026390: 6b50 4d69 6e20 2a20 6469 7276 320a 2020  kPMin * dirv2.  
+000263a0: 2020 6364 6566 2064 6f75 626c 6520 504d    cdef double PM
+000263b0: 696e 326e 6f72 6d20 3d20 635f 7371 7274  in2norm = c_sqrt
+000263c0: 2850 4d69 6e30 2a2a 322b 504d 696e 312a  (PMin0**2+PMin1*
+000263d0: 2a32 290a 2020 2020 6364 6566 2064 6f75  *2).    cdef dou
+000263e0: 626c 6520 524d 696e 203d 2063 5f73 7172  ble RMin = c_sqr
+000263f0: 7428 2850 4d69 6e32 6e6f 726d 202d 2063  t((PMin2norm - c
+00026400: 6972 635f 7261 6469 7573 292a 2a32 0a20  irc_radius)**2. 
+00026410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026420: 2020 2020 2020 2020 2020 2020 2b20 2850              + (P
+00026430: 4d69 6e32 2020 202d 2063 6972 635f 6e6f  Min2   - circ_no
+00026440: 726d 7a29 2a2a 3229 0a20 2020 2063 6465  rmz)**2).    cde
+00026450: 6620 646f 7562 6c65 2076 5030 203d 2050  f double vP0 = P
+00026460: 4d69 6e32 6e6f 726d 202d 2063 6972 635f  Min2norm - circ_
+00026470: 7261 6469 7573 0a20 2020 2063 6465 6620  radius.    cdef 
+00026480: 646f 7562 6c65 2076 5031 203d 2050 4d69  double vP1 = PMi
+00026490: 6e32 2020 2020 202d 2063 6972 635f 6e6f  n2     - circ_no
+000264a0: 726d 7a0a 2020 2020 6364 6566 2064 6f75  rmz.    cdef dou
+000264b0: 626c 6520 5468 6574 6120 3d20 635f 6174  ble Theta = c_at
+000264c0: 616e 3228 7650 312c 2076 5030 290a 2020  an2(vP1, vP0).  
+000264d0: 2020 6364 6566 2064 6f75 626c 6520 496d    cdef double Im
+000264e0: 7054 6865 7461 203d 2054 6865 7461 2069  pTheta = Theta i
+000264f0: 6620 5468 6574 613e 3d30 2065 6c73 6520  f Theta>=0 else 
+00026500: 5468 6574 6120 2b20 635f 7069 0a20 2020  Theta + c_pi.   
+00026510: 2063 6465 6620 646f 7562 6c65 2065 7232   cdef double er2
+00026520: 4430 203d 2063 5f63 6f73 2849 6d70 5468  D0 = c_cos(ImpTh
+00026530: 6574 6129 0a20 2020 2063 6465 6620 646f  eta).    cdef do
+00026540: 7562 6c65 2065 7232 4431 203d 2063 5f73  uble er2D1 = c_s
+00026550: 696e 2849 6d70 5468 6574 6129 0a20 2020  in(ImpTheta).   
+00026560: 2063 6465 6620 646f 7562 6c65 2070 3020   cdef double p0 
+00026570: 3d20 7650 302a 6572 3244 3020 2b20 7650  = vP0*er2D0 + vP
+00026580: 312a 6572 3244 310a 2020 2020 6364 6566  1*er2D1.    cdef
+00026590: 2064 6f75 626c 6520 6554 6865 7461 3020   double eTheta0 
+000265a0: 3d20 2d50 4d69 6e31 202f 2050 4d69 6e32  = -PMin1 / PMin2
+000265b0: 6e6f 726d 0a20 2020 2063 6465 6620 646f  norm.    cdef do
+000265c0: 7562 6c65 2065 5468 6574 6131 203d 2020  uble eTheta1 =  
+000265d0: 504d 696e 3020 2f20 504d 696e 326e 6f72  PMin0 / PMin2nor
+000265e0: 6d0a 2020 2020 6364 6566 2064 6f75 626c  m.    cdef doubl
+000265f0: 6520 6e6f 726d 7530 203d 2064 6972 7630  e normu0 = dirv0
+00026600: 2f6e 6f72 6d75 0a20 2020 2063 6465 6620  /normu.    cdef 
+00026610: 646f 7562 6c65 206e 6f72 6d75 3120 3d20  double normu1 = 
+00026620: 6469 7276 312f 6e6f 726d 750a 2020 2020  dirv1/normu.    
+00026630: 6364 6566 2064 6f75 626c 6520 7068 6920  cdef double phi 
+00026640: 3d20 635f 6173 696e 282d 6e6f 726d 7530  = c_asin(-normu0
+00026650: 202a 2065 5468 6574 6130 202d 206e 6f72   * eTheta0 - nor
+00026660: 6d75 3120 2a20 6554 6865 7461 3129 0a20  mu1 * eTheta1). 
+00026670: 2020 2023 2046 696c 6c69 6e67 2074 6865     # Filling the
+00026680: 2072 6573 756c 7473 202e 2e2e 2e2e 2e2e   results .......
 00026690: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 000266a0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-000266b0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-000266c0: 2e2e 2e0a 2020 2020 7265 7375 6c74 735b  ....    results[
-000266d0: 305d 203d 2050 4d69 6e30 0a20 2020 2072  0] = PMin0.    r
-000266e0: 6573 756c 7473 5b31 5d20 3d20 504d 696e  esults[1] = PMin
-000266f0: 310a 2020 2020 7265 7375 6c74 735b 325d  1.    results[2]
-00026700: 203d 2050 4d69 6e32 0a20 2020 2072 6573   = PMin2.    res
-00026710: 756c 7473 5b33 5d20 3d20 6b50 4d69 6e0a  ults[3] = kPMin.
-00026720: 2020 2020 7265 7375 6c74 735b 345d 203d      results[4] =
-00026730: 2052 4d69 6e0a 2020 2020 7265 7375 6c74   RMin.    result
-00026740: 735b 355d 203d 2054 6865 7461 0a20 2020  s[5] = Theta.   
-00026750: 2072 6573 756c 7473 5b36 5d20 3d20 7030   results[6] = p0
-00026760: 0a20 2020 2072 6573 756c 7473 5b37 5d20  .    results[7] 
-00026770: 3d20 496d 7054 6865 7461 0a20 2020 2072  = ImpTheta.    r
-00026780: 6573 756c 7473 5b38 5d20 3d20 7068 690a  esults[8] = phi.
-00026790: 2020 2020 7265 7475 726e 0a0a 6364 6566      return..cdef
-000267a0: 2069 6e6c 696e 6520 766f 6964 204e 4557   inline void NEW
-000267b0: 5f6c 6f73 5f73 696e 6f5f 746f 725f 7665  _los_sino_tor_ve
-000267c0: 6328 696e 7420 6e6c 6f73 2c0a 2020 2020  c(int nlos,.    
+000266b0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a  ................
+000266c0: 2020 2020 7265 7375 6c74 735b 305d 203d      results[0] =
+000266d0: 2050 4d69 6e30 0a20 2020 2072 6573 756c   PMin0.    resul
+000266e0: 7473 5b31 5d20 3d20 504d 696e 310a 2020  ts[1] = PMin1.  
+000266f0: 2020 7265 7375 6c74 735b 325d 203d 2050    results[2] = P
+00026700: 4d69 6e32 0a20 2020 2072 6573 756c 7473  Min2.    results
+00026710: 5b33 5d20 3d20 6b50 4d69 6e0a 2020 2020  [3] = kPMin.    
+00026720: 7265 7375 6c74 735b 345d 203d 2052 4d69  results[4] = RMi
+00026730: 6e0a 2020 2020 7265 7375 6c74 735b 355d  n.    results[5]
+00026740: 203d 2054 6865 7461 0a20 2020 2072 6573   = Theta.    res
+00026750: 756c 7473 5b36 5d20 3d20 7030 0a20 2020  ults[6] = p0.   
+00026760: 2072 6573 756c 7473 5b37 5d20 3d20 496d   results[7] = Im
+00026770: 7054 6865 7461 0a20 2020 2072 6573 756c  pTheta.    resul
+00026780: 7473 5b38 5d20 3d20 7068 690a 2020 2020  ts[8] = phi.    
+00026790: 7265 7475 726e 0a0a 6364 6566 2069 6e6c  return..cdef inl
+000267a0: 696e 6520 766f 6964 204e 4557 5f6c 6f73  ine void NEW_los
+000267b0: 5f73 696e 6f5f 746f 725f 7665 6328 696e  _sino_tor_vec(in
+000267c0: 7420 6e6c 6f73 2c0a 2020 2020 2020 2020  t nlos,.        
 000267d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000267e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000267f0: 2020 646f 7562 6c65 5b3a 2c3a 3a31 5d20    double[:,::1] 
-00026800: 6f72 6967 696e 732c 0a20 2020 2020 2020  origins,.       
+000267e0: 2020 2020 2020 2020 2020 2020 2020 646f                do
+000267f0: 7562 6c65 5b3a 2c3a 3a31 5d20 6f72 6967  uble[:,::1] orig
+00026800: 696e 732c 0a20 2020 2020 2020 2020 2020  ins,.           
 00026810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026820: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00026830: 6f75 626c 655b 3a2c 3a3a 315d 2064 6972  ouble[:,::1] dir
-00026840: 6563 7469 6f6e 732c 0a20 2020 2020 2020  ections,.       
+00026820: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+00026830: 655b 3a2c 3a3a 315d 2064 6972 6563 7469  e[:,::1] directi
+00026840: 6f6e 732c 0a20 2020 2020 2020 2020 2020  ons,.           
 00026850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026860: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00026870: 6f75 626c 6520 6369 7263 5f72 6164 6975  ouble circ_radiu
-00026880: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00026860: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+00026870: 6520 6369 7263 5f72 6164 6975 732c 0a20  e circ_radius,. 
+00026880: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00026890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000268a0: 2020 2020 2020 2020 2064 6f75 626c 6520           double 
-000268b0: 6369 7263 5f6e 6f72 6d7a 2c0a 2020 2020  circ_normz,.    
+000268a0: 2020 2020 2064 6f75 626c 6520 6369 7263       double circ
+000268b0: 5f6e 6f72 6d7a 2c0a 2020 2020 2020 2020  _normz,.        
 000268c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000268d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000268e0: 2020 646f 7562 6c65 5b3a 2c3a 3a31 5d20    double[:,::1] 
-000268f0: 6c6f 735f 636c 6f73 6573 745f 636f 6f72  los_closest_coor
-00026900: 6473 2c0a 2020 2020 2020 2020 2020 2020  ds,.            
+000268d0: 2020 2020 2020 2020 2020 2020 2020 646f                do
+000268e0: 7562 6c65 5b3a 2c3a 3a31 5d20 6c6f 735f  uble[:,::1] los_
+000268f0: 636c 6f73 6573 745f 636f 6f72 6473 2c0a  closest_coords,.
+00026900: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00026910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026920: 2020 2020 2020 2020 2020 646f 7562 6c65            double
-00026930: 5b3a 3a31 5d20 6c6f 735f 636c 6f73 6573  [::1] los_closes
-00026940: 745f 636f 6566 6673 2c0a 2020 2020 2020  t_coeffs,.      
+00026920: 2020 2020 2020 646f 7562 6c65 5b3a 3a31        double[::1
+00026930: 5d20 6c6f 735f 636c 6f73 6573 745f 636f  ] los_closest_co
+00026940: 6566 6673 2c0a 2020 2020 2020 2020 2020  effs,.          
 00026950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026970: 646f 7562 6c65 5b3a 3a31 5d20 6369 7263  double[::1] circ
-00026980: 6c65 5f63 6c6f 7365 7374 5f72 6d69 6e2c  le_closest_rmin,
-00026990: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00026960: 2020 2020 2020 2020 2020 2020 646f 7562              doub
+00026970: 6c65 5b3a 3a31 5d20 6369 7263 6c65 5f63  le[::1] circle_c
+00026980: 6c6f 7365 7374 5f72 6d69 6e2c 0a20 2020  losest_rmin,.   
+00026990: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000269a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000269b0: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
-000269c0: 315d 2063 6972 636c 655f 636c 6f73 6573  1] circle_closes
-000269d0: 745f 7468 6574 612c 0a20 2020 2020 2020  t_theta,.       
+000269b0: 2020 2064 6f75 626c 655b 3a3a 315d 2063     double[::1] c
+000269c0: 6972 636c 655f 636c 6f73 6573 745f 7468  ircle_closest_th
+000269d0: 6574 612c 0a20 2020 2020 2020 2020 2020  eta,.           
 000269e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000269f0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00026a00: 6f75 626c 655b 3a3a 315d 2063 6972 636c  ouble[::1] circl
-00026a10: 655f 636c 6f73 6573 745f 702c 0a20 2020  e_closest_p,.   
+000269f0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+00026a00: 655b 3a3a 315d 2063 6972 636c 655f 636c  e[::1] circle_cl
+00026a10: 6f73 6573 745f 702c 0a20 2020 2020 2020  osest_p,.       
 00026a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026a40: 2020 2064 6f75 626c 655b 3a3a 315d 2063     double[::1] c
-00026a50: 6972 636c 655f 636c 6f73 6573 745f 696d  ircle_closest_im
-00026a60: 7074 6865 7461 2c0a 2020 2020 2020 2020  ptheta,.        
+00026a30: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00026a40: 6f75 626c 655b 3a3a 315d 2063 6972 636c  ouble[::1] circl
+00026a50: 655f 636c 6f73 6573 745f 696d 7074 6865  e_closest_impthe
+00026a60: 7461 2c0a 2020 2020 2020 2020 2020 2020  ta,.            
 00026a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026a80: 2020 2020 2020 2020 2020 2020 2020 646f                do
-00026a90: 7562 6c65 5b3a 3a31 5d20 6369 7263 6c65  uble[::1] circle
-00026aa0: 5f63 6c6f 7365 7374 5f70 6869 2c0a 2020  _closest_phi,.  
+00026a80: 2020 2020 2020 2020 2020 646f 7562 6c65            double
+00026a90: 5b3a 3a31 5d20 6369 7263 6c65 5f63 6c6f  [::1] circle_clo
+00026aa0: 7365 7374 5f70 6869 2c0a 2020 2020 2020  sest_phi,.      
 00026ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00026ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026ad0: 2020 2020 6269 6e74 2069 735f 4c4f 535f      bint is_LOS_
-00026ae0: 4d6f 6465 3d46 616c 7365 2c0a 2020 2020  Mode=False,.    
+00026ad0: 6269 6e74 2069 735f 4c4f 535f 4d6f 6465  bint is_LOS_Mode
+00026ae0: 3d46 616c 7365 2c0a 2020 2020 2020 2020  =False,.        
 00026af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026b10: 2020 646f 7562 6c65 5b3a 3a31 5d20 6b4f    double[::1] kO
-00026b20: 7574 3d4e 6f6e 6529 206e 6f67 696c 3a0a  ut=None) nogil:.
-00026b30: 2020 2020 6364 6566 2069 6e74 2069 6e64      cdef int ind
-00026b40: 5f6c 6f73 0a20 2020 2063 6465 6620 646f  _los.    cdef do
-00026b50: 7562 6c65 2a20 6469 7276 0a20 2020 2063  uble* dirv.    c
-00026b60: 6465 6620 646f 7562 6c65 2a20 6f72 6967  def double* orig
-00026b70: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-00026b80: 2a20 7265 730a 2020 2020 6364 6566 2064  * res.    cdef d
-00026b90: 6f75 626c 6520 6e6f 726d 752c 206e 6f72  ouble normu, nor
-00026ba0: 6d75 5f73 710a 2020 2020 6364 6566 2064  mu_sq.    cdef d
-00026bb0: 6f75 626c 6520 6b50 4d69 6e2c 2050 4d69  ouble kPMin, PMi
-00026bc0: 6e32 6e6f 726d 2c20 5468 6574 610a 2020  n2norm, Theta.  
-00026bd0: 2020 6364 6566 2064 6f75 626c 6520 7650    cdef double vP
-00026be0: 3020 3d20 302e 300a 2020 2020 6364 6566  0 = 0.0.    cdef
-00026bf0: 2064 6f75 626c 6520 7650 3120 3d20 302e   double vP1 = 0.
-00026c00: 300a 2020 2020 6364 6566 2064 6f75 626c  0.    cdef doubl
-00026c10: 6520 6554 6865 7461 300a 2020 2020 6364  e eTheta0.    cd
-00026c20: 6566 2064 6f75 626c 6520 6554 6865 7461  ef double eTheta
-00026c30: 310a 2020 2020 6364 6566 2064 6f75 626c  1.    cdef doubl
-00026c40: 6520 6e6f 726d 7530 0a20 2020 2063 6465  e normu0.    cde
-00026c50: 6620 646f 7562 6c65 206e 6f72 6d75 310a  f double normu1.
-00026c60: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
-00026c70: 6469 7374 616e 6365 0a20 2020 2063 6465  distance.    cde
-00026c80: 6620 646f 7562 6c65 2050 4d69 6e30 2c20  f double PMin0, 
-00026c90: 504d 696e 312c 2050 4d69 6e32 0a0a 2020  PMin1, PMin2..  
-00026ca0: 2020 7769 7468 206e 6f67 696c 2c20 7061    with nogil, pa
-00026cb0: 7261 6c6c 656c 2829 3a0a 2020 2020 2020  rallel():.      
-00026cc0: 2020 6469 7276 203d 203c 646f 7562 6c65    dirv = <double
-00026cd0: 2a3e 6d61 6c6c 6f63 2833 2a73 697a 656f  *>malloc(3*sizeo
-00026ce0: 6628 646f 7562 6c65 2929 0a20 2020 2020  f(double)).     
-00026cf0: 2020 206f 7269 6720 3d20 3c64 6f75 626c     orig = <doubl
-00026d00: 652a 3e6d 616c 6c6f 6328 332a 7369 7a65  e*>malloc(3*size
-00026d10: 6f66 2864 6f75 626c 6529 290a 2020 2020  of(double)).    
-00026d20: 2020 2020 7265 7320 3d20 3c64 6f75 626c      res = <doubl
-00026d30: 652a 3e6d 616c 6c6f 6328 322a 7369 7a65  e*>malloc(2*size
-00026d40: 6f66 2864 6f75 626c 6529 290a 2020 2020  of(double)).    
-00026d50: 2020 2020 666f 7220 696e 645f 6c6f 7320      for ind_los 
-00026d60: 696e 2070 7261 6e67 6528 6e6c 6f73 293a  in prange(nlos):
-00026d70: 0a20 2020 2020 2020 2020 2020 2064 6972  .            dir
-00026d80: 765b 305d 203d 2064 6972 6563 7469 6f6e  v[0] = direction
-00026d90: 735b 302c 2069 6e64 5f6c 6f73 5d0a 2020  s[0, ind_los].  
-00026da0: 2020 2020 2020 2020 2020 6469 7276 5b31            dirv[1
-00026db0: 5d20 3d20 6469 7265 6374 696f 6e73 5b31  ] = directions[1
-00026dc0: 2c20 696e 645f 6c6f 735d 0a20 2020 2020  , ind_los].     
-00026dd0: 2020 2020 2020 2064 6972 765b 325d 203d         dirv[2] =
-00026de0: 2064 6972 6563 7469 6f6e 735b 322c 2069   directions[2, i
-00026df0: 6e64 5f6c 6f73 5d0a 2020 2020 2020 2020  nd_los].        
-00026e00: 2020 2020 6f72 6967 5b30 5d20 3d20 6f72      orig[0] = or
-00026e10: 6967 696e 735b 302c 2069 6e64 5f6c 6f73  igins[0, ind_los
-00026e20: 5d0a 2020 2020 2020 2020 2020 2020 6f72  ].            or
-00026e30: 6967 5b31 5d20 3d20 6f72 6967 696e 735b  ig[1] = origins[
-00026e40: 312c 2069 6e64 5f6c 6f73 5d0a 2020 2020  1, ind_los].    
-00026e50: 2020 2020 2020 2020 6f72 6967 5b32 5d20          orig[2] 
-00026e60: 3d20 6f72 6967 696e 735b 322c 2069 6e64  = origins[2, ind
-00026e70: 5f6c 6f73 5d0a 2020 2020 2020 2020 2020  _los].          
-00026e80: 2020 6e6f 726d 755f 7371 203d 2064 6972    normu_sq = dir
-00026e90: 765b 305d 202a 2064 6972 765b 305d 202b  v[0] * dirv[0] +
-00026ea0: 2064 6972 765b 315d 202a 2064 6972 765b   dirv[1] * dirv[
-00026eb0: 315d 202b 2064 6972 765b 325d 202a 2064  1] + dirv[2] * d
-00026ec0: 6972 765b 325d 0a20 2020 2020 2020 2020  irv[2].         
-00026ed0: 2020 206e 6f72 6d75 203d 2063 5f73 7172     normu = c_sqr
-00026ee0: 7428 6e6f 726d 755f 7371 290a 2020 2020  t(normu_sq).    
-00026ef0: 2020 2020 2020 2020 2320 436f 6d70 7574          # Comput
-00026f00: 696e 6720 636f 6566 6620 6f66 2063 6c6f  ing coeff of clo
-00026f10: 7365 7374 206f 6e20 6c69 6e65 2e2e 2e2e  sest on line....
+00026b00: 2020 2020 2020 2020 2020 2020 2020 646f                do
+00026b10: 7562 6c65 5b3a 3a31 5d20 6b4f 7574 3d4e  uble[::1] kOut=N
+00026b20: 6f6e 6529 206e 6f67 696c 3a0a 2020 2020  one) nogil:.    
+00026b30: 6364 6566 2069 6e74 2069 6e64 5f6c 6f73  cdef int ind_los
+00026b40: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00026b50: 2a20 6469 7276 0a20 2020 2063 6465 6620  * dirv.    cdef 
+00026b60: 646f 7562 6c65 2a20 6f72 6967 0a20 2020  double* orig.   
+00026b70: 2063 6465 6620 646f 7562 6c65 2a20 7265   cdef double* re
+00026b80: 730a 2020 2020 6364 6566 2064 6f75 626c  s.    cdef doubl
+00026b90: 6520 6e6f 726d 752c 206e 6f72 6d75 5f73  e normu, normu_s
+00026ba0: 710a 2020 2020 6364 6566 2064 6f75 626c  q.    cdef doubl
+00026bb0: 6520 6b50 4d69 6e2c 2050 4d69 6e32 6e6f  e kPMin, PMin2no
+00026bc0: 726d 2c20 5468 6574 610a 2020 2020 6364  rm, Theta.    cd
+00026bd0: 6566 2064 6f75 626c 6520 7650 3020 3d20  ef double vP0 = 
+00026be0: 302e 300a 2020 2020 6364 6566 2064 6f75  0.0.    cdef dou
+00026bf0: 626c 6520 7650 3120 3d20 302e 300a 2020  ble vP1 = 0.0.  
+00026c00: 2020 6364 6566 2064 6f75 626c 6520 6554    cdef double eT
+00026c10: 6865 7461 300a 2020 2020 6364 6566 2064  heta0.    cdef d
+00026c20: 6f75 626c 6520 6554 6865 7461 310a 2020  ouble eTheta1.  
+00026c30: 2020 6364 6566 2064 6f75 626c 6520 6e6f    cdef double no
+00026c40: 726d 7530 0a20 2020 2063 6465 6620 646f  rmu0.    cdef do
+00026c50: 7562 6c65 206e 6f72 6d75 310a 2020 2020  uble normu1.    
+00026c60: 6364 6566 2064 6f75 626c 6520 6469 7374  cdef double dist
+00026c70: 616e 6365 0a20 2020 2063 6465 6620 646f  ance.    cdef do
+00026c80: 7562 6c65 2050 4d69 6e30 2c20 504d 696e  uble PMin0, PMin
+00026c90: 312c 2050 4d69 6e32 0a0a 2020 2020 7769  1, PMin2..    wi
+00026ca0: 7468 206e 6f67 696c 2c20 7061 7261 6c6c  th nogil, parall
+00026cb0: 656c 2829 3a0a 2020 2020 2020 2020 6469  el():.        di
+00026cc0: 7276 203d 203c 646f 7562 6c65 2a3e 6d61  rv = <double*>ma
+00026cd0: 6c6c 6f63 2833 2a73 697a 656f 6628 646f  lloc(3*sizeof(do
+00026ce0: 7562 6c65 2929 0a20 2020 2020 2020 206f  uble)).        o
+00026cf0: 7269 6720 3d20 3c64 6f75 626c 652a 3e6d  rig = <double*>m
+00026d00: 616c 6c6f 6328 332a 7369 7a65 6f66 2864  alloc(3*sizeof(d
+00026d10: 6f75 626c 6529 290a 2020 2020 2020 2020  ouble)).        
+00026d20: 7265 7320 3d20 3c64 6f75 626c 652a 3e6d  res = <double*>m
+00026d30: 616c 6c6f 6328 322a 7369 7a65 6f66 2864  alloc(2*sizeof(d
+00026d40: 6f75 626c 6529 290a 2020 2020 2020 2020  ouble)).        
+00026d50: 666f 7220 696e 645f 6c6f 7320 696e 2070  for ind_los in p
+00026d60: 7261 6e67 6528 6e6c 6f73 293a 0a20 2020  range(nlos):.   
+00026d70: 2020 2020 2020 2020 2064 6972 765b 305d           dirv[0]
+00026d80: 203d 2064 6972 6563 7469 6f6e 735b 302c   = directions[0,
+00026d90: 2069 6e64 5f6c 6f73 5d0a 2020 2020 2020   ind_los].      
+00026da0: 2020 2020 2020 6469 7276 5b31 5d20 3d20        dirv[1] = 
+00026db0: 6469 7265 6374 696f 6e73 5b31 2c20 696e  directions[1, in
+00026dc0: 645f 6c6f 735d 0a20 2020 2020 2020 2020  d_los].         
+00026dd0: 2020 2064 6972 765b 325d 203d 2064 6972     dirv[2] = dir
+00026de0: 6563 7469 6f6e 735b 322c 2069 6e64 5f6c  ections[2, ind_l
+00026df0: 6f73 5d0a 2020 2020 2020 2020 2020 2020  os].            
+00026e00: 6f72 6967 5b30 5d20 3d20 6f72 6967 696e  orig[0] = origin
+00026e10: 735b 302c 2069 6e64 5f6c 6f73 5d0a 2020  s[0, ind_los].  
+00026e20: 2020 2020 2020 2020 2020 6f72 6967 5b31            orig[1
+00026e30: 5d20 3d20 6f72 6967 696e 735b 312c 2069  ] = origins[1, i
+00026e40: 6e64 5f6c 6f73 5d0a 2020 2020 2020 2020  nd_los].        
+00026e50: 2020 2020 6f72 6967 5b32 5d20 3d20 6f72      orig[2] = or
+00026e60: 6967 696e 735b 322c 2069 6e64 5f6c 6f73  igins[2, ind_los
+00026e70: 5d0a 2020 2020 2020 2020 2020 2020 6e6f  ].            no
+00026e80: 726d 755f 7371 203d 2064 6972 765b 305d  rmu_sq = dirv[0]
+00026e90: 202a 2064 6972 765b 305d 202b 2064 6972   * dirv[0] + dir
+00026ea0: 765b 315d 202a 2064 6972 765b 315d 202b  v[1] * dirv[1] +
+00026eb0: 2064 6972 765b 325d 202a 2064 6972 765b   dirv[2] * dirv[
+00026ec0: 325d 0a20 2020 2020 2020 2020 2020 206e  2].            n
+00026ed0: 6f72 6d75 203d 2063 5f73 7172 7428 6e6f  ormu = c_sqrt(no
+00026ee0: 726d 755f 7371 290a 2020 2020 2020 2020  rmu_sq).        
+00026ef0: 2020 2020 2320 436f 6d70 7574 696e 6720      # Computing 
+00026f00: 636f 6566 6620 6f66 2063 6c6f 7365 7374  coeff of closest
+00026f10: 206f 6e20 6c69 6e65 2e2e 2e2e 2e2e 2e2e   on line........
 00026f20: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00026f30: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020  .............   
-00026f40: 2020 2020 2020 2020 2069 6620 6469 7276           if dirv
-00026f50: 5b30 5d20 3d3d 2030 2e20 616e 6420 6469  [0] == 0. and di
-00026f60: 7276 5b31 5d20 3d3d 2030 2e3a 0a20 2020  rv[1] == 0.:.   
-00026f70: 2020 2020 2020 2020 2020 2020 206b 504d               kPM
-00026f80: 696e 203d 2028 6369 7263 5f6e 6f72 6d7a  in = (circ_normz
-00026f90: 2d6f 7269 675b 325d 292f 6469 7276 5b32  -orig[2])/dirv[2
-00026fa0: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
-00026fb0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00026fc0: 2020 2020 5f64 742e 6469 7374 5f6c 6f73      _dt.dist_los
-00026fd0: 5f63 6972 636c 655f 636f 7265 2864 6972  _circle_core(dir
-00026fe0: 762c 206f 7269 672c 2063 6972 635f 7261  v, orig, circ_ra
-00026ff0: 6469 7573 2c0a 2020 2020 2020 2020 2020  dius,.          
+00026f30: 2e2e 2e2e 2e2e 2e2e 0a20 2020 2020 2020  .........       
+00026f40: 2020 2020 2069 6620 6469 7276 5b30 5d20       if dirv[0] 
+00026f50: 3d3d 2030 2e20 616e 6420 6469 7276 5b31  == 0. and dirv[1
+00026f60: 5d20 3d3d 2030 2e3a 0a20 2020 2020 2020  ] == 0.:.       
+00026f70: 2020 2020 2020 2020 206b 504d 696e 203d           kPMin =
+00026f80: 2028 6369 7263 5f6e 6f72 6d7a 2d6f 7269   (circ_normz-ori
+00026f90: 675b 325d 292f 6469 7276 5b32 5d0a 2020  g[2])/dirv[2].  
+00026fa0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00026fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026fc0: 5f64 742e 6469 7374 5f6c 6f73 5f63 6972  _dt.dist_los_cir
+00026fd0: 636c 655f 636f 7265 2864 6972 762c 206f  cle_core(dirv, o
+00026fe0: 7269 672c 2063 6972 635f 7261 6469 7573  rig, circ_radius
+00026ff0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 00027000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027010: 2020 2020 2020 2020 2020 2020 2020 6369                ci
-00027020: 7263 5f6e 6f72 6d7a 2c20 6e6f 726d 755f  rc_normz, normu_
-00027030: 7371 2c20 7265 7329 0a20 2020 2020 2020  sq, res).       
-00027040: 2020 2020 2020 2020 206b 504d 696e 203d           kPMin =
-00027050: 2072 6573 5b30 5d0a 2020 2020 2020 2020   res[0].        
-00027060: 2020 2020 2020 2020 6469 7374 616e 6365          distance
-00027070: 203d 2072 6573 5b31 5d0a 2020 2020 2020   = res[1].      
-00027080: 2020 2020 2020 6966 2069 735f 4c4f 535f        if is_LOS_
-00027090: 4d6f 6465 2061 6e64 206b 4f75 7420 6973  Mode and kOut is
-000270a0: 206e 6f74 204e 6f6e 6520 616e 6420 6b50   not None and kP
-000270b0: 4d69 6e20 3e20 6b4f 7574 5b69 6e64 5f6c  Min > kOut[ind_l
-000270c0: 6f73 5d3a 0a20 2020 2020 2020 2020 2020  os]:.           
-000270d0: 2020 2020 206b 504d 696e 203d 206b 4f75       kPMin = kOu
-000270e0: 745b 696e 645f 6c6f 735d 0a20 2020 2020  t[ind_los].     
-000270f0: 2020 2020 2020 206c 6f73 5f63 6c6f 7365         los_close
-00027100: 7374 5f63 6f65 6666 735b 696e 645f 6c6f  st_coeffs[ind_lo
-00027110: 735d 203d 206b 504d 696e 0a0a 2020 2020  s] = kPMin..    
-00027120: 2020 2020 2020 2020 2320 436f 6d70 7574          # Comput
-00027130: 696e 6720 7468 6520 696e 666f 206f 6620  ing the info of 
-00027140: 7468 6520 636c 6f73 6573 7420 706f 696e  the closest poin
-00027150: 7420 6f6e 204c 4f53 2026 2043 6972 636c  t on LOS & Circl
-00027160: 652e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020  e............   
-00027170: 2020 2020 2020 2020 2050 4d69 6e30 203d           PMin0 =
-00027180: 206f 7269 675b 305d 202b 206b 504d 696e   orig[0] + kPMin
-00027190: 202a 2064 6972 765b 305d 0a20 2020 2020   * dirv[0].     
-000271a0: 2020 2020 2020 2050 4d69 6e31 203d 206f         PMin1 = o
-000271b0: 7269 675b 315d 202b 206b 504d 696e 202a  rig[1] + kPMin *
-000271c0: 2064 6972 765b 315d 0a20 2020 2020 2020   dirv[1].       
-000271d0: 2020 2020 2050 4d69 6e32 203d 206f 7269       PMin2 = ori
-000271e0: 675b 325d 202b 206b 504d 696e 202a 2064  g[2] + kPMin * d
-000271f0: 6972 765b 325d 0a20 2020 2020 2020 2020  irv[2].         
-00027200: 2020 206c 6f73 5f63 6c6f 7365 7374 5f63     los_closest_c
-00027210: 6f6f 7264 735b 302c 2069 6e64 5f6c 6f73  oords[0, ind_los
-00027220: 5d20 3d20 504d 696e 300a 2020 2020 2020  ] = PMin0.      
-00027230: 2020 2020 2020 6c6f 735f 636c 6f73 6573        los_closes
-00027240: 745f 636f 6f72 6473 5b31 2c20 696e 645f  t_coords[1, ind_
-00027250: 6c6f 735d 203d 2050 4d69 6e31 0a20 2020  los] = PMin1.   
-00027260: 2020 2020 2020 2020 206c 6f73 5f63 6c6f           los_clo
-00027270: 7365 7374 5f63 6f6f 7264 735b 322c 2069  sest_coords[2, i
-00027280: 6e64 5f6c 6f73 5d20 3d20 504d 696e 320a  nd_los] = PMin2.
-00027290: 2020 2020 2020 2020 2020 2020 2320 436f              # Co
-000272a0: 6d70 7574 696e 6720 524d 696e 3a0a 2020  mputing RMin:.  
-000272b0: 2020 2020 2020 2020 2020 504d 696e 326e            PMin2n
-000272c0: 6f72 6d20 3d20 635f 7371 7274 2850 4d69  orm = c_sqrt(PMi
-000272d0: 6e30 2a2a 322b 504d 696e 312a 2a32 290a  n0**2+PMin1**2).
-000272e0: 2020 2020 2020 2020 2020 2020 6369 7263              circ
-000272f0: 6c65 5f63 6c6f 7365 7374 5f72 6d69 6e5b  le_closest_rmin[
-00027300: 696e 645f 6c6f 735d 203d 2063 5f73 7172  ind_los] = c_sqr
-00027310: 7428 2850 4d69 6e32 6e6f 726d 202d 2063  t((PMin2norm - c
-00027320: 6972 635f 7261 6469 7573 292a 2a32 0a20  irc_radius)**2. 
+00027010: 2020 2020 2020 2020 2020 6369 7263 5f6e            circ_n
+00027020: 6f72 6d7a 2c20 6e6f 726d 755f 7371 2c20  ormz, normu_sq, 
+00027030: 7265 7329 0a20 2020 2020 2020 2020 2020  res).           
+00027040: 2020 2020 206b 504d 696e 203d 2072 6573       kPMin = res
+00027050: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
+00027060: 2020 2020 6469 7374 616e 6365 203d 2072      distance = r
+00027070: 6573 5b31 5d0a 2020 2020 2020 2020 2020  es[1].          
+00027080: 2020 6966 2069 735f 4c4f 535f 4d6f 6465    if is_LOS_Mode
+00027090: 2061 6e64 206b 4f75 7420 6973 206e 6f74   and kOut is not
+000270a0: 204e 6f6e 6520 616e 6420 6b50 4d69 6e20   None and kPMin 
+000270b0: 3e20 6b4f 7574 5b69 6e64 5f6c 6f73 5d3a  > kOut[ind_los]:
+000270c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000270d0: 206b 504d 696e 203d 206b 4f75 745b 696e   kPMin = kOut[in
+000270e0: 645f 6c6f 735d 0a20 2020 2020 2020 2020  d_los].         
+000270f0: 2020 206c 6f73 5f63 6c6f 7365 7374 5f63     los_closest_c
+00027100: 6f65 6666 735b 696e 645f 6c6f 735d 203d  oeffs[ind_los] =
+00027110: 206b 504d 696e 0a0a 2020 2020 2020 2020   kPMin..        
+00027120: 2020 2020 2320 436f 6d70 7574 696e 6720      # Computing 
+00027130: 7468 6520 696e 666f 206f 6620 7468 6520  the info of the 
+00027140: 636c 6f73 6573 7420 706f 696e 7420 6f6e  closest point on
+00027150: 204c 4f53 2026 2043 6972 636c 652e 2e2e   LOS & Circle...
+00027160: 2e2e 2e2e 2e2e 2e2e 0a20 2020 2020 2020  .........       
+00027170: 2020 2020 2050 4d69 6e30 203d 206f 7269       PMin0 = ori
+00027180: 675b 305d 202b 206b 504d 696e 202a 2064  g[0] + kPMin * d
+00027190: 6972 765b 305d 0a20 2020 2020 2020 2020  irv[0].         
+000271a0: 2020 2050 4d69 6e31 203d 206f 7269 675b     PMin1 = orig[
+000271b0: 315d 202b 206b 504d 696e 202a 2064 6972  1] + kPMin * dir
+000271c0: 765b 315d 0a20 2020 2020 2020 2020 2020  v[1].           
+000271d0: 2050 4d69 6e32 203d 206f 7269 675b 325d   PMin2 = orig[2]
+000271e0: 202b 206b 504d 696e 202a 2064 6972 765b   + kPMin * dirv[
+000271f0: 325d 0a20 2020 2020 2020 2020 2020 206c  2].            l
+00027200: 6f73 5f63 6c6f 7365 7374 5f63 6f6f 7264  os_closest_coord
+00027210: 735b 302c 2069 6e64 5f6c 6f73 5d20 3d20  s[0, ind_los] = 
+00027220: 504d 696e 300a 2020 2020 2020 2020 2020  PMin0.          
+00027230: 2020 6c6f 735f 636c 6f73 6573 745f 636f    los_closest_co
+00027240: 6f72 6473 5b31 2c20 696e 645f 6c6f 735d  ords[1, ind_los]
+00027250: 203d 2050 4d69 6e31 0a20 2020 2020 2020   = PMin1.       
+00027260: 2020 2020 206c 6f73 5f63 6c6f 7365 7374       los_closest
+00027270: 5f63 6f6f 7264 735b 322c 2069 6e64 5f6c  _coords[2, ind_l
+00027280: 6f73 5d20 3d20 504d 696e 320a 2020 2020  os] = PMin2.    
+00027290: 2020 2020 2020 2020 2320 436f 6d70 7574          # Comput
+000272a0: 696e 6720 524d 696e 3a0a 2020 2020 2020  ing RMin:.      
+000272b0: 2020 2020 2020 504d 696e 326e 6f72 6d20        PMin2norm 
+000272c0: 3d20 635f 7371 7274 2850 4d69 6e30 2a2a  = c_sqrt(PMin0**
+000272d0: 322b 504d 696e 312a 2a32 290a 2020 2020  2+PMin1**2).    
+000272e0: 2020 2020 2020 2020 6369 7263 6c65 5f63          circle_c
+000272f0: 6c6f 7365 7374 5f72 6d69 6e5b 696e 645f  losest_rmin[ind_
+00027300: 6c6f 735d 203d 2063 5f73 7172 7428 2850  los] = c_sqrt((P
+00027310: 4d69 6e32 6e6f 726d 202d 2063 6972 635f  Min2norm - circ_
+00027320: 7261 6469 7573 292a 2a32 0a20 2020 2020  radius)**2.     
 00027330: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00027340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027350: 2020 2020 2020 202b 2028 504d 696e 3220         + (PMin2 
-00027360: 2020 2d20 6369 7263 5f6e 6f72 6d7a 292a    - circ_normz)*
-00027370: 2a32 290a 2020 2020 2020 2020 2020 2020  *2).            
-00027380: 2320 5468 6574 6120 616e 6420 496d 7054  # Theta and ImpT
-00027390: 6865 7461 3a0a 2020 2020 2020 2020 2020  heta:.          
-000273a0: 2020 7650 3020 3d20 504d 696e 326e 6f72    vP0 = PMin2nor
-000273b0: 6d20 2d20 6369 7263 5f72 6164 6975 730a  m - circ_radius.
-000273c0: 2020 2020 2020 2020 2020 2020 7650 3120              vP1 
-000273d0: 3d20 504d 696e 3220 2020 2020 2d20 6369  = PMin2     - ci
-000273e0: 7263 5f6e 6f72 6d7a 0a20 2020 2020 2020  rc_normz.       
-000273f0: 2020 2020 2054 6865 7461 203d 2063 5f61       Theta = c_a
-00027400: 7461 6e32 2876 5031 2c20 7650 3029 0a20  tan2(vP1, vP0). 
-00027410: 2020 2020 2020 2020 2020 2063 6972 636c             circl
-00027420: 655f 636c 6f73 6573 745f 7468 6574 615b  e_closest_theta[
-00027430: 696e 645f 6c6f 735d 203d 2054 6865 7461  ind_los] = Theta
-00027440: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00027450: 5468 6574 6120 3c20 303a 0a20 2020 2020  Theta < 0:.     
-00027460: 2020 2020 2020 2020 2020 2054 6865 7461             Theta
-00027470: 203d 2054 6865 7461 202b 2063 5f70 690a   = Theta + c_pi.
-00027480: 2020 2020 2020 2020 2020 2020 6369 7263              circ
-00027490: 6c65 5f63 6c6f 7365 7374 5f69 6d70 7468  le_closest_impth
-000274a0: 6574 615b 696e 645f 6c6f 735d 203d 2054  eta[ind_los] = T
-000274b0: 6865 7461 0a20 2020 2020 2020 2020 2020  heta.           
-000274c0: 2063 6972 636c 655f 636c 6f73 6573 745f   circle_closest_
-000274d0: 705b 696e 645f 6c6f 735d 203d 2076 5030  p[ind_los] = vP0
-000274e0: 202a 2063 5f63 6f73 2854 6865 7461 2920   * c_cos(Theta) 
-000274f0: 2b20 7650 3120 2a20 635f 7369 6e28 5468  + vP1 * c_sin(Th
-00027500: 6574 6129 0a20 2020 2020 2020 2020 2020  eta).           
-00027510: 2023 2050 6869 3a0a 2020 2020 2020 2020   # Phi:.        
-00027520: 2020 2020 6554 6865 7461 3020 3d20 2d20      eTheta0 = - 
-00027530: 504d 696e 3120 2f20 504d 696e 326e 6f72  PMin1 / PMin2nor
-00027540: 6d0a 2020 2020 2020 2020 2020 2020 6554  m.            eT
-00027550: 6865 7461 3120 3d20 2020 504d 696e 3020  heta1 =   PMin0 
-00027560: 2f20 504d 696e 326e 6f72 6d0a 2020 2020  / PMin2norm.    
-00027570: 2020 2020 2020 2020 6e6f 726d 7530 203d          normu0 =
-00027580: 2064 6972 765b 305d 2f6e 6f72 6d75 0a20   dirv[0]/normu. 
-00027590: 2020 2020 2020 2020 2020 206e 6f72 6d75             normu
-000275a0: 3120 3d20 6469 7276 5b31 5d2f 6e6f 726d  1 = dirv[1]/norm
-000275b0: 750a 2020 2020 2020 2020 2020 2020 6369  u.            ci
-000275c0: 7263 6c65 5f63 6c6f 7365 7374 5f70 6869  rcle_closest_phi
-000275d0: 5b69 6e64 5f6c 6f73 5d20 3d20 635f 6173  [ind_los] = c_as
-000275e0: 696e 282d 6e6f 726d 7530 202a 2065 5468  in(-normu0 * eTh
-000275f0: 6574 6130 202d 206e 6f72 6d75 3120 2a20  eta0 - normu1 * 
-00027600: 6554 6865 7461 3129 0a20 2020 2020 2020  eTheta1).       
-00027610: 2066 7265 6528 6469 7276 290a 2020 2020   free(dirv).    
-00027620: 2020 2020 6672 6565 286f 7269 6729 0a20      free(orig). 
-00027630: 2020 2020 2020 2066 7265 6528 7265 7329         free(res)
-00027640: 0a20 2020 2072 6574 7572 6e0a 0a0a 0a63  .    return....c
-00027650: 6465 6620 4c4f 535f 7369 6e6f 5f4c 696e  def LOS_sino_Lin
-00027660: 2864 6f75 626c 6520 4430 2c20 646f 7562  (double D0, doub
-00027670: 6c65 2044 312c 2064 6f75 626c 6520 4432  le D1, double D2
-00027680: 2c20 646f 7562 6c65 2075 302c 2064 6f75  , double u0, dou
-00027690: 626c 6520 7531 2c20 646f 7562 6c65 0a20  ble u1, double. 
-000276a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000276b0: 2075 322c 2064 6f75 626c 6520 525a 302c   u2, double RZ0,
-000276c0: 2064 6f75 626c 6520 525a 312c 2073 7472   double RZ1, str
-000276d0: 204d 6f64 653d 274c 4f53 272c 0a20 2020   Mode='LOS',.   
-000276e0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000276f0: 6f75 626c 6520 6b4f 7574 3d43 5f49 4e46  ouble kOut=C_INF
-00027700: 293a 0a20 2020 2063 6465 6620 646f 7562  ):.    cdef doub
-00027710: 6c65 2020 2020 6b50 4d69 6e0a 2020 2020  le    kPMin.    
-00027720: 6966 2075 302a 2a32 3d3d 312e 3a0a 2020  if u0**2==1.:.  
-00027730: 2020 2020 2020 6b50 4d69 6e20 3d20 302e        kPMin = 0.
-00027740: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-00027750: 2020 206b 504d 696e 203d 2028 2028 525a     kPMin = ( (RZ
-00027760: 302d 4431 292a 7531 2b28 525a 312d 4432  0-D1)*u1+(RZ1-D2
-00027770: 292a 7532 2029 202f 2028 312d 7530 2a2a  )*u2 ) / (1-u0**
-00027780: 3229 0a20 2020 206b 504d 696e 203d 206b  2).    kPMin = k
-00027790: 4f75 7420 6966 204d 6f64 653d 3d27 4c4f  Out if Mode=='LO
-000277a0: 5327 2061 6e64 206b 504d 696e 203e 206b  S' and kPMin > k
-000277b0: 4f75 7420 656c 7365 206b 504d 696e 0a20  Out else kPMin. 
-000277c0: 2020 2063 6465 6620 646f 7562 6c65 2020     cdef double  
-000277d0: 2020 504d 696e 3020 3d20 4430 2b6b 504d    PMin0 = D0+kPM
-000277e0: 696e 2a75 302c 2050 4d69 6e31 203d 2044  in*u0, PMin1 = D
-000277f0: 312b 6b50 4d69 6e2a 7531 2c20 504d 696e  1+kPMin*u1, PMin
-00027800: 3220 3d20 4432 2b6b 504d 696e 2a75 320a  2 = D2+kPMin*u2.
-00027810: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
-00027820: 2020 2052 4d69 6e20 3d20 635f 7371 7274     RMin = c_sqrt
-00027830: 2828 504d 696e 312d 525a 3029 2a2a 322b  ((PMin1-RZ0)**2+
-00027840: 2850 4d69 6e32 2d52 5a31 292a 2a32 290a  (PMin2-RZ1)**2).
-00027850: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
-00027860: 2020 2076 5030 203d 2050 4d69 6e31 2d52     vP0 = PMin1-R
-00027870: 5a30 2c20 7650 3120 3d20 504d 696e 322d  Z0, vP1 = PMin2-
-00027880: 525a 310a 2020 2020 6364 6566 2064 6f75  RZ1.    cdef dou
-00027890: 626c 6520 2020 2054 6865 7461 203d 2063  ble    Theta = c
-000278a0: 5f61 7461 6e32 2876 5031 2c76 5030 290a  _atan2(vP1,vP0).
-000278b0: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
-000278c0: 2020 2049 6d70 5468 6574 6120 3d20 5468     ImpTheta = Th
-000278d0: 6574 6120 6966 2054 6865 7461 3e3d 3020  eta if Theta>=0 
-000278e0: 656c 7365 2054 6865 7461 202b 206e 702e  else Theta + np.
-000278f0: 7069 0a20 2020 2063 6465 6620 646f 7562  pi.    cdef doub
-00027900: 6c65 2020 2020 6572 3244 3020 3d20 635f  le    er2D0 = c_
-00027910: 636f 7328 496d 7054 6865 7461 292c 2065  cos(ImpTheta), e
-00027920: 7232 4431 203d 2063 5f73 696e 2849 6d70  r2D1 = c_sin(Imp
-00027930: 5468 6574 6129 0a20 2020 2063 6465 6620  Theta).    cdef 
-00027940: 646f 7562 6c65 2020 2020 7030 203d 2076  double    p0 = v
-00027950: 5030 2a65 7232 4430 202b 2076 5031 2a65  P0*er2D0 + vP1*e
-00027960: 7232 4431 0a20 2020 2063 6465 6620 646f  r2D1.    cdef do
-00027970: 7562 6c65 2020 2020 754e 203d 2063 5f73  uble    uN = c_s
-00027980: 7172 7428 7530 2a2a 322b 7531 2a2a 322b  qrt(u0**2+u1**2+
-00027990: 7532 2a2a 3229 0a20 2020 2063 6465 6620  u2**2).    cdef 
-000279a0: 646f 7562 6c65 2020 2020 754e 3020 3d20  double    uN0 = 
-000279b0: 7530 2f75 4e2c 2075 4e31 203d 2075 312f  u0/uN, uN1 = u1/
-000279c0: 754e 2c20 754e 3220 3d20 7532 2f75 4e0a  uN, uN2 = u2/uN.
-000279d0: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
-000279e0: 2020 2070 6869 203d 2063 5f61 7461 6e32     phi = c_atan2
-000279f0: 2875 4e30 2c20 635f 7371 7274 2875 4e31  (uN0, c_sqrt(uN1
-00027a00: 2a2a 322b 754e 322a 2a32 2929 0a20 2020  **2+uN2**2)).   
-00027a10: 2072 6574 7572 6e20 2850 4d69 6e30 2c50   return (PMin0,P
-00027a20: 4d69 6e31 2c50 4d69 6e32 292c 206b 504d  Min1,PMin2), kPM
-00027a30: 696e 2c20 524d 696e 2c20 5468 6574 612c  in, RMin, Theta,
-00027a40: 2070 302c 2049 6d70 5468 6574 612c 2070   p0, ImpTheta, p
-00027a50: 6869 0a0a 0a64 6566 204c 4f53 5f73 696e  hi...def LOS_sin
-00027a60: 6f28 646f 7562 6c65 5b3a 2c3a 3a31 5d20  o(double[:,::1] 
-00027a70: 442c 2064 6f75 626c 655b 3a2c 3a3a 315d  D, double[:,::1]
-00027a80: 2075 2c20 646f 7562 6c65 5b3a 3a31 5d20   u, double[::1] 
-00027a90: 525a 2c20 646f 7562 6c65 5b3a 3a31 5d20  RZ, double[::1] 
-00027aa0: 6b4f 7574 2c0a 2020 2020 2020 2020 2020  kOut,.          
-00027ab0: 2020 2073 7472 204d 6f64 653d 274c 4f53     str Mode='LOS
-00027ac0: 272c 2073 7472 2056 5479 7065 3d27 546f  ', str VType='To
-00027ad0: 7227 2c20 6269 6e74 2074 7279 5f6e 6577  r', bint try_new
-00027ae0: 5f61 6c67 6f3d 5472 7565 293a 0a20 2020  _algo=True):.   
-00027af0: 2063 6465 6620 756e 7369 676e 6564 2069   cdef unsigned i
-00027b00: 6e74 206e 4c20 3d20 442e 7368 6170 655b  nt nL = D.shape[
-00027b10: 315d 2c20 6969 0a20 2020 2063 6465 6620  1], ii.    cdef 
-00027b20: 7475 706c 6520 6f75 740a 2020 2020 6364  tuple out.    cd
-00027b30: 6566 206e 702e 6e64 6172 7261 795b 646f  ef np.ndarray[do
-00027b40: 7562 6c65 2c6e 6469 6d3d 325d 2050 4d69  uble,ndim=2] PMi
-00027b50: 6e20 3d20 6e70 2e65 6d70 7479 2828 332c  n = np.empty((3,
-00027b60: 6e4c 2929 0a20 2020 2063 6465 6620 6e70  nL)).    cdef np
-00027b70: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
-00027b80: 6e64 696d 3d31 5d20 6b50 4d69 6e3d 6e70  ndim=1] kPMin=np
-00027b90: 2e65 6d70 7479 2828 6e4c 2c29 292c 2052  .empty((nL,)), R
-00027ba0: 4d69 6e3d 6e70 2e65 6d70 7479 2828 6e4c  Min=np.empty((nL
-00027bb0: 2c29 290a 2020 2020 6364 6566 206e 702e  ,)).    cdef np.
-00027bc0: 6e64 6172 7261 795b 646f 7562 6c65 2c6e  ndarray[double,n
-00027bd0: 6469 6d3d 315d 2054 6865 7461 3d6e 702e  dim=1] Theta=np.
-00027be0: 656d 7074 7928 286e 4c2c 2929 2c20 703d  empty((nL,)), p=
-00027bf0: 6e70 2e65 6d70 7479 2828 6e4c 2c29 290a  np.empty((nL,)).
-00027c00: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-00027c10: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
-00027c20: 315d 2049 6d70 5468 6574 613d 6e70 2e65  1] ImpTheta=np.e
-00027c30: 6d70 7479 2828 6e4c 2c29 292c 2070 6869  mpty((nL,)), phi
-00027c40: 3d6e 702e 656d 7074 7928 286e 4c2c 2929  =np.empty((nL,))
-00027c50: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-00027c60: 5b39 5d20 7265 7375 6c74 730a 2020 2020  [9] results.    
-00027c70: 6364 6566 2062 696e 7420 6973 5f4c 4f53  cdef bint is_LOS
-00027c80: 5f4d 6f64 650a 2020 2020 6966 2056 5479  _Mode.    if VTy
-00027c90: 7065 2e6c 6f77 6572 2829 3d3d 2774 6f72  pe.lower()=='tor
-00027ca0: 273a 0a20 2020 2020 2020 2069 6620 6e6f  ':.        if no
-00027cb0: 7420 7472 795f 6e65 775f 616c 676f 3a0a  t try_new_algo:.
-00027cc0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00027cd0: 6969 2069 6e20 7261 6e67 6528 302c 6e4c  ii in range(0,nL
-00027ce0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00027cf0: 2020 206f 7574 203d 204c 4f53 5f73 696e     out = LOS_sin
-00027d00: 6f5f 546f 7228 445b 302c 6969 5d2c 445b  o_Tor(D[0,ii],D[
-00027d10: 312c 6969 5d2c 445b 322c 6969 5d2c 0a20  1,ii],D[2,ii],. 
+00027350: 2020 202b 2028 504d 696e 3220 2020 2d20     + (PMin2   - 
+00027360: 6369 7263 5f6e 6f72 6d7a 292a 2a32 290a  circ_normz)**2).
+00027370: 2020 2020 2020 2020 2020 2020 2320 5468              # Th
+00027380: 6574 6120 616e 6420 496d 7054 6865 7461  eta and ImpTheta
+00027390: 3a0a 2020 2020 2020 2020 2020 2020 7650  :.            vP
+000273a0: 3020 3d20 504d 696e 326e 6f72 6d20 2d20  0 = PMin2norm - 
+000273b0: 6369 7263 5f72 6164 6975 730a 2020 2020  circ_radius.    
+000273c0: 2020 2020 2020 2020 7650 3120 3d20 504d          vP1 = PM
+000273d0: 696e 3220 2020 2020 2d20 6369 7263 5f6e  in2     - circ_n
+000273e0: 6f72 6d7a 0a20 2020 2020 2020 2020 2020  ormz.           
+000273f0: 2054 6865 7461 203d 2063 5f61 7461 6e32   Theta = c_atan2
+00027400: 2876 5031 2c20 7650 3029 0a20 2020 2020  (vP1, vP0).     
+00027410: 2020 2020 2020 2063 6972 636c 655f 636c         circle_cl
+00027420: 6f73 6573 745f 7468 6574 615b 696e 645f  osest_theta[ind_
+00027430: 6c6f 735d 203d 2054 6865 7461 0a20 2020  los] = Theta.   
+00027440: 2020 2020 2020 2020 2069 6620 5468 6574           if Thet
+00027450: 6120 3c20 303a 0a20 2020 2020 2020 2020  a < 0:.         
+00027460: 2020 2020 2020 2054 6865 7461 203d 2054         Theta = T
+00027470: 6865 7461 202b 2063 5f70 690a 2020 2020  heta + c_pi.    
+00027480: 2020 2020 2020 2020 6369 7263 6c65 5f63          circle_c
+00027490: 6c6f 7365 7374 5f69 6d70 7468 6574 615b  losest_imptheta[
+000274a0: 696e 645f 6c6f 735d 203d 2054 6865 7461  ind_los] = Theta
+000274b0: 0a20 2020 2020 2020 2020 2020 2063 6972  .            cir
+000274c0: 636c 655f 636c 6f73 6573 745f 705b 696e  cle_closest_p[in
+000274d0: 645f 6c6f 735d 203d 2076 5030 202a 2063  d_los] = vP0 * c
+000274e0: 5f63 6f73 2854 6865 7461 2920 2b20 7650  _cos(Theta) + vP
+000274f0: 3120 2a20 635f 7369 6e28 5468 6574 6129  1 * c_sin(Theta)
+00027500: 0a20 2020 2020 2020 2020 2020 2023 2050  .            # P
+00027510: 6869 3a0a 2020 2020 2020 2020 2020 2020  hi:.            
+00027520: 6554 6865 7461 3020 3d20 2d20 504d 696e  eTheta0 = - PMin
+00027530: 3120 2f20 504d 696e 326e 6f72 6d0a 2020  1 / PMin2norm.  
+00027540: 2020 2020 2020 2020 2020 6554 6865 7461            eTheta
+00027550: 3120 3d20 2020 504d 696e 3020 2f20 504d  1 =   PMin0 / PM
+00027560: 696e 326e 6f72 6d0a 2020 2020 2020 2020  in2norm.        
+00027570: 2020 2020 6e6f 726d 7530 203d 2064 6972      normu0 = dir
+00027580: 765b 305d 2f6e 6f72 6d75 0a20 2020 2020  v[0]/normu.     
+00027590: 2020 2020 2020 206e 6f72 6d75 3120 3d20         normu1 = 
+000275a0: 6469 7276 5b31 5d2f 6e6f 726d 750a 2020  dirv[1]/normu.  
+000275b0: 2020 2020 2020 2020 2020 6369 7263 6c65            circle
+000275c0: 5f63 6c6f 7365 7374 5f70 6869 5b69 6e64  _closest_phi[ind
+000275d0: 5f6c 6f73 5d20 3d20 635f 6173 696e 282d  _los] = c_asin(-
+000275e0: 6e6f 726d 7530 202a 2065 5468 6574 6130  normu0 * eTheta0
+000275f0: 202d 206e 6f72 6d75 3120 2a20 6554 6865   - normu1 * eThe
+00027600: 7461 3129 0a20 2020 2020 2020 2066 7265  ta1).        fre
+00027610: 6528 6469 7276 290a 2020 2020 2020 2020  e(dirv).        
+00027620: 6672 6565 286f 7269 6729 0a20 2020 2020  free(orig).     
+00027630: 2020 2066 7265 6528 7265 7329 0a20 2020     free(res).   
+00027640: 2072 6574 7572 6e0a 0a0a 0a63 6465 6620   return....cdef 
+00027650: 4c4f 535f 7369 6e6f 5f4c 696e 2864 6f75  LOS_sino_Lin(dou
+00027660: 626c 6520 4430 2c20 646f 7562 6c65 2044  ble D0, double D
+00027670: 312c 2064 6f75 626c 6520 4432 2c20 646f  1, double D2, do
+00027680: 7562 6c65 2075 302c 2064 6f75 626c 6520  uble u0, double 
+00027690: 7531 2c20 646f 7562 6c65 0a20 2020 2020  u1, double.     
+000276a0: 2020 2020 2020 2020 2020 2020 2075 322c               u2,
+000276b0: 2064 6f75 626c 6520 525a 302c 2064 6f75   double RZ0, dou
+000276c0: 626c 6520 525a 312c 2073 7472 204d 6f64  ble RZ1, str Mod
+000276d0: 653d 274c 4f53 272c 0a20 2020 2020 2020  e='LOS',.       
+000276e0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+000276f0: 6520 6b4f 7574 3d43 5f49 4e46 293a 0a20  e kOut=C_INF):. 
+00027700: 2020 2063 6465 6620 646f 7562 6c65 2020     cdef double  
+00027710: 2020 6b50 4d69 6e0a 2020 2020 6966 2075    kPMin.    if u
+00027720: 302a 2a32 3d3d 312e 3a0a 2020 2020 2020  0**2==1.:.      
+00027730: 2020 6b50 4d69 6e20 3d20 302e 0a20 2020    kPMin = 0..   
+00027740: 2065 6c73 653a 0a20 2020 2020 2020 206b   else:.        k
+00027750: 504d 696e 203d 2028 2028 525a 302d 4431  PMin = ( (RZ0-D1
+00027760: 292a 7531 2b28 525a 312d 4432 292a 7532  )*u1+(RZ1-D2)*u2
+00027770: 2029 202f 2028 312d 7530 2a2a 3229 0a20   ) / (1-u0**2). 
+00027780: 2020 206b 504d 696e 203d 206b 4f75 7420     kPMin = kOut 
+00027790: 6966 204d 6f64 653d 3d27 4c4f 5327 2061  if Mode=='LOS' a
+000277a0: 6e64 206b 504d 696e 203e 206b 4f75 7420  nd kPMin > kOut 
+000277b0: 656c 7365 206b 504d 696e 0a20 2020 2063  else kPMin.    c
+000277c0: 6465 6620 646f 7562 6c65 2020 2020 504d  def double    PM
+000277d0: 696e 3020 3d20 4430 2b6b 504d 696e 2a75  in0 = D0+kPMin*u
+000277e0: 302c 2050 4d69 6e31 203d 2044 312b 6b50  0, PMin1 = D1+kP
+000277f0: 4d69 6e2a 7531 2c20 504d 696e 3220 3d20  Min*u1, PMin2 = 
+00027800: 4432 2b6b 504d 696e 2a75 320a 2020 2020  D2+kPMin*u2.    
+00027810: 6364 6566 2064 6f75 626c 6520 2020 2052  cdef double    R
+00027820: 4d69 6e20 3d20 635f 7371 7274 2828 504d  Min = c_sqrt((PM
+00027830: 696e 312d 525a 3029 2a2a 322b 2850 4d69  in1-RZ0)**2+(PMi
+00027840: 6e32 2d52 5a31 292a 2a32 290a 2020 2020  n2-RZ1)**2).    
+00027850: 6364 6566 2064 6f75 626c 6520 2020 2076  cdef double    v
+00027860: 5030 203d 2050 4d69 6e31 2d52 5a30 2c20  P0 = PMin1-RZ0, 
+00027870: 7650 3120 3d20 504d 696e 322d 525a 310a  vP1 = PMin2-RZ1.
+00027880: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
+00027890: 2020 2054 6865 7461 203d 2063 5f61 7461     Theta = c_ata
+000278a0: 6e32 2876 5031 2c76 5030 290a 2020 2020  n2(vP1,vP0).    
+000278b0: 6364 6566 2064 6f75 626c 6520 2020 2049  cdef double    I
+000278c0: 6d70 5468 6574 6120 3d20 5468 6574 6120  mpTheta = Theta 
+000278d0: 6966 2054 6865 7461 3e3d 3020 656c 7365  if Theta>=0 else
+000278e0: 2054 6865 7461 202b 206e 702e 7069 0a20   Theta + np.pi. 
+000278f0: 2020 2063 6465 6620 646f 7562 6c65 2020     cdef double  
+00027900: 2020 6572 3244 3020 3d20 635f 636f 7328    er2D0 = c_cos(
+00027910: 496d 7054 6865 7461 292c 2065 7232 4431  ImpTheta), er2D1
+00027920: 203d 2063 5f73 696e 2849 6d70 5468 6574   = c_sin(ImpThet
+00027930: 6129 0a20 2020 2063 6465 6620 646f 7562  a).    cdef doub
+00027940: 6c65 2020 2020 7030 203d 2076 5030 2a65  le    p0 = vP0*e
+00027950: 7232 4430 202b 2076 5031 2a65 7232 4431  r2D0 + vP1*er2D1
+00027960: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00027970: 2020 2020 754e 203d 2063 5f73 7172 7428      uN = c_sqrt(
+00027980: 7530 2a2a 322b 7531 2a2a 322b 7532 2a2a  u0**2+u1**2+u2**
+00027990: 3229 0a20 2020 2063 6465 6620 646f 7562  2).    cdef doub
+000279a0: 6c65 2020 2020 754e 3020 3d20 7530 2f75  le    uN0 = u0/u
+000279b0: 4e2c 2075 4e31 203d 2075 312f 754e 2c20  N, uN1 = u1/uN, 
+000279c0: 754e 3220 3d20 7532 2f75 4e0a 2020 2020  uN2 = u2/uN.    
+000279d0: 6364 6566 2064 6f75 626c 6520 2020 2070  cdef double    p
+000279e0: 6869 203d 2063 5f61 7461 6e32 2875 4e30  hi = c_atan2(uN0
+000279f0: 2c20 635f 7371 7274 2875 4e31 2a2a 322b  , c_sqrt(uN1**2+
+00027a00: 754e 322a 2a32 2929 0a20 2020 2072 6574  uN2**2)).    ret
+00027a10: 7572 6e20 2850 4d69 6e30 2c50 4d69 6e31  urn (PMin0,PMin1
+00027a20: 2c50 4d69 6e32 292c 206b 504d 696e 2c20  ,PMin2), kPMin, 
+00027a30: 524d 696e 2c20 5468 6574 612c 2070 302c  RMin, Theta, p0,
+00027a40: 2049 6d70 5468 6574 612c 2070 6869 0a0a   ImpTheta, phi..
+00027a50: 0a64 6566 204c 4f53 5f73 696e 6f28 646f  .def LOS_sino(do
+00027a60: 7562 6c65 5b3a 2c3a 3a31 5d20 442c 2064  uble[:,::1] D, d
+00027a70: 6f75 626c 655b 3a2c 3a3a 315d 2075 2c20  ouble[:,::1] u, 
+00027a80: 646f 7562 6c65 5b3a 3a31 5d20 525a 2c20  double[::1] RZ, 
+00027a90: 646f 7562 6c65 5b3a 3a31 5d20 6b4f 7574  double[::1] kOut
+00027aa0: 2c0a 2020 2020 2020 2020 2020 2020 2073  ,.             s
+00027ab0: 7472 204d 6f64 653d 274c 4f53 272c 2073  tr Mode='LOS', s
+00027ac0: 7472 2056 5479 7065 3d27 546f 7227 2c20  tr VType='Tor', 
+00027ad0: 6269 6e74 2074 7279 5f6e 6577 5f61 6c67  bint try_new_alg
+00027ae0: 6f3d 5472 7565 293a 0a20 2020 2063 6465  o=True):.    cde
+00027af0: 6620 756e 7369 676e 6564 2069 6e74 206e  f unsigned int n
+00027b00: 4c20 3d20 442e 7368 6170 655b 315d 2c20  L = D.shape[1], 
+00027b10: 6969 0a20 2020 2063 6465 6620 7475 706c  ii.    cdef tupl
+00027b20: 6520 6f75 740a 2020 2020 6364 6566 206e  e out.    cdef n
+00027b30: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+00027b40: 2c6e 6469 6d3d 325d 2050 4d69 6e20 3d20  ,ndim=2] PMin = 
+00027b50: 6e70 2e65 6d70 7479 2828 332c 6e4c 2929  np.empty((3,nL))
+00027b60: 0a20 2020 2063 6465 6620 6e70 2e6e 6461  .    cdef np.nda
+00027b70: 7272 6179 5b64 6f75 626c 652c 6e64 696d  rray[double,ndim
+00027b80: 3d31 5d20 6b50 4d69 6e3d 6e70 2e65 6d70  =1] kPMin=np.emp
+00027b90: 7479 2828 6e4c 2c29 292c 2052 4d69 6e3d  ty((nL,)), RMin=
+00027ba0: 6e70 2e65 6d70 7479 2828 6e4c 2c29 290a  np.empty((nL,)).
+00027bb0: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+00027bc0: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
+00027bd0: 315d 2054 6865 7461 3d6e 702e 656d 7074  1] Theta=np.empt
+00027be0: 7928 286e 4c2c 2929 2c20 703d 6e70 2e65  y((nL,)), p=np.e
+00027bf0: 6d70 7479 2828 6e4c 2c29 290a 2020 2020  mpty((nL,)).    
+00027c00: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+00027c10: 646f 7562 6c65 2c6e 6469 6d3d 315d 2049  double,ndim=1] I
+00027c20: 6d70 5468 6574 613d 6e70 2e65 6d70 7479  mpTheta=np.empty
+00027c30: 2828 6e4c 2c29 292c 2070 6869 3d6e 702e  ((nL,)), phi=np.
+00027c40: 656d 7074 7928 286e 4c2c 2929 0a20 2020  empty((nL,)).   
+00027c50: 2063 6465 6620 646f 7562 6c65 5b39 5d20   cdef double[9] 
+00027c60: 7265 7375 6c74 730a 2020 2020 6364 6566  results.    cdef
+00027c70: 2062 696e 7420 6973 5f4c 4f53 5f4d 6f64   bint is_LOS_Mod
+00027c80: 650a 2020 2020 6966 2056 5479 7065 2e6c  e.    if VType.l
+00027c90: 6f77 6572 2829 3d3d 2774 6f72 273a 0a20  ower()=='tor':. 
+00027ca0: 2020 2020 2020 2069 6620 6e6f 7420 7472         if not tr
+00027cb0: 795f 6e65 775f 616c 676f 3a0a 2020 2020  y_new_algo:.    
+00027cc0: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
+00027cd0: 6e20 7261 6e67 6528 302c 6e4c 293a 0a20  n range(0,nL):. 
+00027ce0: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+00027cf0: 7574 203d 204c 4f53 5f73 696e 6f5f 546f  ut = LOS_sino_To
+00027d00: 7228 445b 302c 6969 5d2c 445b 312c 6969  r(D[0,ii],D[1,ii
+00027d10: 5d2c 445b 322c 6969 5d2c 0a20 2020 2020  ],D[2,ii],.     
 00027d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027d40: 2020 755b 302c 6969 5d2c 755b 312c 6969    u[0,ii],u[1,ii
-00027d50: 5d2c 755b 322c 6969 5d2c 0a20 2020 2020  ],u[2,ii],.     
+00027d30: 2020 2020 2020 2020 2020 2020 2020 755b                u[
+00027d40: 302c 6969 5d2c 755b 312c 6969 5d2c 755b  0,ii],u[1,ii],u[
+00027d50: 322c 6969 5d2c 0a20 2020 2020 2020 2020  2,ii],.         
 00027d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027d70: 2020 2020 2020 2020 2020 2020 2020 525a                RZ
-00027d80: 5b30 5d2c 525a 5b31 5d2c 204d 6f64 653d  [0],RZ[1], Mode=
-00027d90: 4d6f 6465 2c20 6b4f 7574 3d6b 4f75 745b  Mode, kOut=kOut[
-00027da0: 6969 5d29 0a20 2020 2020 2020 2020 2020  ii]).           
-00027db0: 2020 2020 2028 2850 4d69 6e5b 302c 6969       ((PMin[0,ii
-00027dc0: 5d2c 504d 696e 5b31 2c69 695d 2c50 4d69  ],PMin[1,ii],PMi
-00027dd0: 6e5b 322c 6969 5d29 2c0a 2020 2020 2020  n[2,ii]),.      
-00027de0: 2020 2020 2020 2020 2020 206b 504d 696e             kPMin
-00027df0: 5b69 695d 2c20 524d 696e 5b69 695d 2c20  [ii], RMin[ii], 
-00027e00: 5468 6574 615b 6969 5d2c 0a20 2020 2020  Theta[ii],.     
-00027e10: 2020 2020 2020 2020 2020 2020 705b 6969              p[ii
-00027e20: 5d2c 2049 6d70 5468 6574 615b 6969 5d2c  ], ImpTheta[ii],
-00027e30: 2070 6869 5b69 695d 2920 3d20 6f75 740a   phi[ii]) = out.
-00027e40: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00027e50: 2020 2020 2020 2020 2020 6973 5f4c 4f53            is_LOS
-00027e60: 5f4d 6f64 6520 3d20 4d6f 6465 2e6c 6f77  _Mode = Mode.low
-00027e70: 6572 2829 203d 3d20 276c 6f73 270a 2020  er() == 'los'.  
-00027e80: 2020 2020 2020 2020 2020 4e45 575f 6c6f            NEW_lo
-00027e90: 735f 7369 6e6f 5f74 6f72 5f76 6563 286e  s_sino_tor_vec(n
-00027ea0: 4c2c 2044 2c20 752c 2052 5a5b 305d 2c20  L, D, u, RZ[0], 
-00027eb0: 525a 5b31 5d2c 0a20 2020 2020 2020 2020  RZ[1],.         
+00027d70: 2020 2020 2020 2020 2020 525a 5b30 5d2c            RZ[0],
+00027d80: 525a 5b31 5d2c 204d 6f64 653d 4d6f 6465  RZ[1], Mode=Mode
+00027d90: 2c20 6b4f 7574 3d6b 4f75 745b 6969 5d29  , kOut=kOut[ii])
+00027da0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00027db0: 2028 2850 4d69 6e5b 302c 6969 5d2c 504d   ((PMin[0,ii],PM
+00027dc0: 696e 5b31 2c69 695d 2c50 4d69 6e5b 322c  in[1,ii],PMin[2,
+00027dd0: 6969 5d29 2c0a 2020 2020 2020 2020 2020  ii]),.          
+00027de0: 2020 2020 2020 206b 504d 696e 5b69 695d         kPMin[ii]
+00027df0: 2c20 524d 696e 5b69 695d 2c20 5468 6574  , RMin[ii], Thet
+00027e00: 615b 6969 5d2c 0a20 2020 2020 2020 2020  a[ii],.         
+00027e10: 2020 2020 2020 2020 705b 6969 5d2c 2049          p[ii], I
+00027e20: 6d70 5468 6574 615b 6969 5d2c 2070 6869  mpTheta[ii], phi
+00027e30: 5b69 695d 2920 3d20 6f75 740a 2020 2020  [ii]) = out.    
+00027e40: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00027e50: 2020 2020 2020 6973 5f4c 4f53 5f4d 6f64        is_LOS_Mod
+00027e60: 6520 3d20 4d6f 6465 2e6c 6f77 6572 2829  e = Mode.lower()
+00027e70: 203d 3d20 276c 6f73 270a 2020 2020 2020   == 'los'.      
+00027e80: 2020 2020 2020 4e45 575f 6c6f 735f 7369        NEW_los_si
+00027e90: 6e6f 5f74 6f72 5f76 6563 286e 4c2c 2044  no_tor_vec(nL, D
+00027ea0: 2c20 752c 2052 5a5b 305d 2c20 525a 5b31  , u, RZ[0], RZ[1
+00027eb0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 00027ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027ed0: 2020 2020 2020 2020 504d 696e 2c20 6b50          PMin, kP
-00027ee0: 4d69 6e2c 2052 4d69 6e2c 2054 6865 7461  Min, RMin, Theta
-00027ef0: 2c20 702c 0a20 2020 2020 2020 2020 2020  , p,.           
+00027ed0: 2020 2020 504d 696e 2c20 6b50 4d69 6e2c      PMin, kPMin,
+00027ee0: 2052 4d69 6e2c 2054 6865 7461 2c20 702c   RMin, Theta, p,
+00027ef0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00027f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027f10: 2020 2020 2020 496d 7054 6865 7461 2c20        ImpTheta, 
-00027f20: 7068 692c 0a20 2020 2020 2020 2020 2020  phi,.           
+00027f10: 2020 496d 7054 6865 7461 2c20 7068 692c    ImpTheta, phi,
+00027f20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00027f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027f40: 2020 2020 2020 6973 5f4c 4f53 5f4d 6f64        is_LOS_Mod
-00027f50: 653d 6973 5f4c 4f53 5f4d 6f64 652c 0a20  e=is_LOS_Mode,. 
+00027f40: 2020 6973 5f4c 4f53 5f4d 6f64 653d 6973    is_LOS_Mode=is
+00027f50: 5f4c 4f53 5f4d 6f64 652c 0a20 2020 2020  _LOS_Mode,.     
 00027f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027f80: 6b4f 7574 3d6b 4f75 7429 0a20 2020 2065  kOut=kOut).    e
-00027f90: 6c73 653a 0a20 2020 2020 2020 2066 6f72  lse:.        for
-00027fa0: 2069 6920 696e 2072 616e 6765 2830 2c6e   ii in range(0,n
-00027fb0: 4c29 3a0a 2020 2020 2020 2020 2020 2020  L):.            
-00027fc0: 6f75 7420 3d20 4c4f 535f 7369 6e6f 5f4c  out = LOS_sino_L
-00027fd0: 696e 2844 5b30 2c69 695d 2c44 5b31 2c69  in(D[0,ii],D[1,i
-00027fe0: 695d 2c44 5b32 2c69 695d 2c75 5b30 2c69  i],D[2,ii],u[0,i
-00027ff0: 695d 2c75 5b31 2c69 695d 2c75 5b32 2c69  i],u[1,ii],u[2,i
-00028000: 695d 2c0a 2020 2020 2020 2020 2020 2020  i],.            
-00028010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028020: 2020 2052 5a5b 305d 2c52 5a5b 315d 2c20     RZ[0],RZ[1], 
-00028030: 4d6f 6465 3d4d 6f64 652c 206b 4f75 743d  Mode=Mode, kOut=
-00028040: 6b4f 7574 5b69 695d 290a 2020 2020 2020  kOut[ii]).      
-00028050: 2020 2020 2020 2828 504d 696e 5b30 2c69        ((PMin[0,i
-00028060: 695d 2c50 4d69 6e5b 312c 6969 5d2c 504d  i],PMin[1,ii],PM
-00028070: 696e 5b32 2c69 695d 292c 0a20 2020 2020  in[2,ii]),.     
-00028080: 2020 2020 2020 2020 6b50 4d69 6e5b 6969          kPMin[ii
-00028090: 5d2c 2052 4d69 6e5b 6969 5d2c 2054 6865  ], RMin[ii], The
-000280a0: 7461 5b69 695d 2c20 705b 6969 5d2c 2049  ta[ii], p[ii], I
-000280b0: 6d70 5468 6574 615b 6969 5d2c 2070 6869  mpTheta[ii], phi
-000280c0: 5b69 695d 2920 3d20 6f75 740a 2020 2020  [ii]) = out.    
-000280d0: 7265 7475 726e 2050 4d69 6e2c 206b 504d  return PMin, kPM
-000280e0: 696e 2c20 524d 696e 2c20 5468 6574 612c  in, RMin, Theta,
-000280f0: 2070 2c20 496d 7054 6865 7461 2c20 7068   p, ImpTheta, ph
-00028100: 690a 0a0a 0a0a 0a0a 0a0a 2323 2323 2323  i.........######
+00027f70: 2020 2020 2020 2020 2020 2020 6b4f 7574              kOut
+00027f80: 3d6b 4f75 7429 0a20 2020 2065 6c73 653a  =kOut).    else:
+00027f90: 0a20 2020 2020 2020 2066 6f72 2069 6920  .        for ii 
+00027fa0: 696e 2072 616e 6765 2830 2c6e 4c29 3a0a  in range(0,nL):.
+00027fb0: 2020 2020 2020 2020 2020 2020 6f75 7420              out 
+00027fc0: 3d20 4c4f 535f 7369 6e6f 5f4c 696e 2844  = LOS_sino_Lin(D
+00027fd0: 5b30 2c69 695d 2c44 5b31 2c69 695d 2c44  [0,ii],D[1,ii],D
+00027fe0: 5b32 2c69 695d 2c75 5b30 2c69 695d 2c75  [2,ii],u[0,ii],u
+00027ff0: 5b31 2c69 695d 2c75 5b32 2c69 695d 2c0a  [1,ii],u[2,ii],.
+00028000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028010: 2020 2020 2020 2020 2020 2020 2020 2052                 R
+00028020: 5a5b 305d 2c52 5a5b 315d 2c20 4d6f 6465  Z[0],RZ[1], Mode
+00028030: 3d4d 6f64 652c 206b 4f75 743d 6b4f 7574  =Mode, kOut=kOut
+00028040: 5b69 695d 290a 2020 2020 2020 2020 2020  [ii]).          
+00028050: 2020 2828 504d 696e 5b30 2c69 695d 2c50    ((PMin[0,ii],P
+00028060: 4d69 6e5b 312c 6969 5d2c 504d 696e 5b32  Min[1,ii],PMin[2
+00028070: 2c69 695d 292c 0a20 2020 2020 2020 2020  ,ii]),.         
+00028080: 2020 2020 6b50 4d69 6e5b 6969 5d2c 2052      kPMin[ii], R
+00028090: 4d69 6e5b 6969 5d2c 2054 6865 7461 5b69  Min[ii], Theta[i
+000280a0: 695d 2c20 705b 6969 5d2c 2049 6d70 5468  i], p[ii], ImpTh
+000280b0: 6574 615b 6969 5d2c 2070 6869 5b69 695d  eta[ii], phi[ii]
+000280c0: 2920 3d20 6f75 740a 2020 2020 7265 7475  ) = out.    retu
+000280d0: 726e 2050 4d69 6e2c 206b 504d 696e 2c20  rn PMin, kPMin, 
+000280e0: 524d 696e 2c20 5468 6574 612c 2070 2c20  RMin, Theta, p, 
+000280f0: 496d 7054 6865 7461 2c20 7068 690a 0a0a  ImpTheta, phi...
+00028100: 0a0a 0a0a 0a0a 2323 2323 2323 2323 2323  ......##########
 00028110: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028120: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028130: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028140: 2323 0a23 2323 2323 2323 2323 2323 2323  ##.#############
+00028130: 2323 2323 2323 2323 2323 2323 2323 0a23  ##############.#
+00028140: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028150: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028160: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028170: 2323 2323 2323 2323 2323 230a 2323 2323  ###########.####
+00028170: 2323 2323 2323 230a 2323 2323 2323 2323  #######.########
 00028180: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028190: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000281a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000281b0: 2323 2323 0a23 2020 2020 2020 2020 2020  ####.#          
-000281c0: 2020 2020 2020 2020 2053 6f6c 6964 2041           Solid A
-000281d0: 6e67 6c65 0a23 2323 2323 2323 2323 2323  ngle.###########
+000281b0: 0a23 2020 2020 2020 2020 2020 2020 2020  .#              
+000281c0: 2020 2020 2053 6f6c 6964 2041 6e67 6c65       Solid Angle
+000281d0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
 000281e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000281f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028200: 2323 2323 2323 2323 2323 2323 230a 2323  #############.##
+00028200: 2323 2323 2323 2323 230a 2323 2323 2323  #########.######
 00028210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028240: 2323 2323 2323 0a23 2323 2323 2323 2323  ######.#########
+00028240: 2323 0a23 2323 2323 2323 2323 2323 2323  ##.#############
 00028250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028270: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-00028280: 0a0a 2323 2323 2323 2323 2323 2323 2323  ..##############
+00028270: 2323 2323 2323 2323 2323 230a 0a0a 2323  ###########...##
+00028280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000282a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000282b0: 2323 2323 2323 2323 0a23 2323 2323 2323  ########.#######
+000282b0: 2323 2323 0a23 2323 2323 2323 2323 2323  ####.###########
 000282c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000282d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000282e0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-000282f0: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-00028300: 4475 7374 0a23 2323 2323 2323 2323 2323  Dust.###########
+000282e0: 2323 2323 2323 2323 2323 230a 2320 2020  ###########.#   
+000282f0: 2020 2020 2020 2020 2020 2020 4475 7374              Dust
+00028300: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
 00028310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028330: 2323 2323 2323 2323 2323 230a 2323 2323  ###########.####
+00028330: 2323 2323 2323 230a 2323 2323 2323 2323  #######.########
 00028340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00028350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028360: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028370: 2323 0a0a 6465 6620 4475 7374 5f63 616c  ##..def Dust_cal
-00028380: 635f 536f 6c69 6441 6e67 6c65 280a 2020  c_SolidAngle(.  
-00028390: 2020 706f 732c 2072 2c20 7074 732c 0a20    pos, r, pts,. 
-000283a0: 2020 2061 7070 726f 783d 5472 7565 2c0a     approx=True,.
-000283b0: 2020 2020 6f75 745f 636f 6566 6f6e 6c79      out_coefonly
-000283c0: 3d46 616c 7365 2c0a 2020 2020 5654 7970  =False,.    VTyp
-000283d0: 653d 2754 6f72 272c 0a20 2020 2056 506f  e='Tor',.    VPo
-000283e0: 6c79 3d4e 6f6e 652c 0a20 2020 2056 496e  ly=None,.    VIn
-000283f0: 3d4e 6f6e 652c 0a20 2020 2056 4c69 6d3d  =None,.    VLim=
-00028400: 4e6f 6e65 2c0a 2020 2020 4c53 506f 6c79  None,.    LSPoly
-00028410: 3d4e 6f6e 652c 0a20 2020 204c 534c 696d  =None,.    LSLim
-00028420: 3d4e 6f6e 652c 0a20 2020 204c 5356 496e  =None,.    LSVIn
-00028430: 3d4e 6f6e 652c 0a20 2020 2046 6f72 6269  =None,.    Forbi
-00028440: 643d 5472 7565 2c0a 2020 2020 5465 7374  d=True,.    Test
-00028450: 3d54 7275 652c 0a29 3a0a 2020 2020 2222  =True,.):.    ""
-00028460: 2220 436f 6d70 7574 6520 7468 6520 736f  " Compute the so
-00028470: 6c69 6420 616e 676c 6520 6f66 2061 206d  lid angle of a m
-00028480: 6f76 696e 6720 7061 7274 6963 6c65 206f  oving particle o
-00028490: 6620 7661 7279 696e 6720 7261 6469 7573  f varying radius
-000284a0: 2061 7320 7365 656e 0a20 2020 2066 726f   as seen.    fro
-000284b0: 6d20 616e 7920 6e75 6d62 6572 206f 6620  m any number of 
-000284c0: 7069 7865 6420 706f 696e 7473 0a0a 2020  pixed points..  
-000284d0: 2020 4361 6e20 6265 2064 6f6e 6520 772f    Can be done w/
-000284e0: 6f20 7468 6520 6170 7072 6f78 696d 6174  o the approximat
-000284f0: 696f 6e20 7468 6174 2072 3c3c 640a 2020  ion that r<<d.  
-00028500: 2020 4966 2056 6573 2028 616e 6420 6f70    If Ves (and op
-00028510: 7469 6f6e 616c 6c79 204c 5350 6f6c 7929  tionally LSPoly)
-00028520: 2061 7265 2070 726f 7669 6465 642c 2074   are provided, t
-00028530: 616b 6573 2069 6e74 6f20 6163 636f 756e  akes into accoun
-00028540: 7420 7669 676e 6574 7469 6e67 0a20 2020  t vignetting.   
-00028550: 2022 2222 0a20 2020 2063 6465 6620 626c   """.    cdef bl
-00028560: 6f63 6b20 3d20 5650 6f6c 7920 6973 206e  ock = VPoly is n
-00028570: 6f74 204e 6f6e 650a 2020 2020 6364 6566  ot None.    cdef
-00028580: 2066 6c6f 6174 2070 6972 320a 2020 2020   float pir2.    
-00028590: 6364 6566 2069 6e74 2069 692c 206a 6a2c  cdef int ii, jj,
-000285a0: 206e 7074 736f 6b2c 206e 743d 706f 732e   nptsok, nt=pos.
-000285b0: 7368 6170 655b 315d 2c20 6e70 7473 3d70  shape[1], npts=p
-000285c0: 7473 2e73 6861 7065 5b31 5d0a 2020 2020  ts.shape[1].    
-000285d0: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
-000285e0: 646f 7562 6c65 2c20 6e64 696d 3d32 2c20  double, ndim=2, 
-000285f0: 6d6f 6465 3d27 6327 5d20 7361 6e67 3d6e  mode='c'] sang=n
-00028600: 702e 7a65 726f 7328 286e 742c 6e70 7473  p.zeros((nt,npts
-00028610: 2929 0a20 2020 2063 6465 6620 6172 7261  )).    cdef arra
-00028620: 7920 6b0a 2020 2020 6364 6566 206e 702e  y k.    cdef np.
-00028630: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-00028640: 6e64 696d 3d31 2c20 6d6f 6465 3d27 6327  ndim=1, mode='c'
-00028650: 5d20 7669 730a 2020 2020 6364 6566 2064  ] vis.    cdef d
-00028660: 6f75 626c 655b 3a3a 315d 206b 5f76 6965  ouble[::1] k_vie
-00028670: 770a 2020 2020 6364 6566 2064 6f75 626c  w.    cdef doubl
-00028680: 655b 3a3a 315d 206c 7370 6f6c 7978 2c20  e[::1] lspolyx, 
-00028690: 6c73 706f 6c79 790a 2020 2020 6364 6566  lspolyy.    cdef
-000286a0: 2064 6f75 626c 655b 3a3a 315d 206c 736e   double[::1] lsn
-000286b0: 6f72 6d78 2c20 6c73 6e6f 726d 790a 2020  ormx, lsnormy.  
-000286c0: 2020 6966 2062 6c6f 636b 3a0a 2020 2020    if block:.    
-000286d0: 2020 2020 696e 6420 3d20 7e5f 5665 735f      ind = ~_Ves_
-000286e0: 6973 496e 7369 6465 2870 7473 2c20 5650  isInside(pts, VP
-000286f0: 6f6c 792c 2076 6573 5f6c 696d 733d 564c  oly, ves_lims=VL
-00028700: 696d 2c20 7665 735f 7479 7065 3d56 5479  im, ves_type=VTy
-00028710: 7065 2c0a 2020 2020 2020 2020 2020 2020  pe,.            
-00028720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028730: 2069 6e5f 666f 726d 6174 3d27 2858 2c59   in_format='(X,Y
-00028740: 2c5a 2927 2c20 7465 7374 3d54 6573 7429  ,Z)', test=Test)
-00028750: 0a20 2020 2020 2020 2069 6620 4c53 506f  .        if LSPo
-00028760: 6c79 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ly is not None:.
-00028770: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00028780: 6969 2069 6e20 7261 6e67 6528 6c65 6e28  ii in range(len(
-00028790: 4c53 506f 6c79 2929 3a0a 2020 2020 2020  LSPoly)):.      
-000287a0: 2020 2020 2020 2020 2020 696e 6420 3d20            ind = 
-000287b0: 696e 6420 2620 5f56 6573 5f69 7349 6e73  ind & _Ves_isIns
-000287c0: 6964 6528 7074 732c 204c 5350 6f6c 795b  ide(pts, LSPoly[
-000287d0: 6969 5d2c 2076 6573 5f6c 696d 733d 4c53  ii], ves_lims=LS
-000287e0: 4c69 6d5b 6969 5d2c 0a20 2020 2020 2020  Lim[ii],.       
+00028360: 2323 2323 2323 2323 2323 2323 2323 0a0a  ##############..
+00028370: 6465 6620 4475 7374 5f63 616c 635f 536f  def Dust_calc_So
+00028380: 6c69 6441 6e67 6c65 280a 2020 2020 706f  lidAngle(.    po
+00028390: 732c 2072 2c20 7074 732c 0a20 2020 2061  s, r, pts,.    a
+000283a0: 7070 726f 783d 5472 7565 2c0a 2020 2020  pprox=True,.    
+000283b0: 6f75 745f 636f 6566 6f6e 6c79 3d46 616c  out_coefonly=Fal
+000283c0: 7365 2c0a 2020 2020 5654 7970 653d 2754  se,.    VType='T
+000283d0: 6f72 272c 0a20 2020 2056 506f 6c79 3d4e  or',.    VPoly=N
+000283e0: 6f6e 652c 0a20 2020 2056 496e 3d4e 6f6e  one,.    VIn=Non
+000283f0: 652c 0a20 2020 2056 4c69 6d3d 4e6f 6e65  e,.    VLim=None
+00028400: 2c0a 2020 2020 4c53 506f 6c79 3d4e 6f6e  ,.    LSPoly=Non
+00028410: 652c 0a20 2020 204c 534c 696d 3d4e 6f6e  e,.    LSLim=Non
+00028420: 652c 0a20 2020 204c 5356 496e 3d4e 6f6e  e,.    LSVIn=Non
+00028430: 652c 0a20 2020 2046 6f72 6269 643d 5472  e,.    Forbid=Tr
+00028440: 7565 2c0a 2020 2020 5465 7374 3d54 7275  ue,.    Test=Tru
+00028450: 652c 0a29 3a0a 2020 2020 2222 2220 436f  e,.):.    """ Co
+00028460: 6d70 7574 6520 7468 6520 736f 6c69 6420  mpute the solid 
+00028470: 616e 676c 6520 6f66 2061 206d 6f76 696e  angle of a movin
+00028480: 6720 7061 7274 6963 6c65 206f 6620 7661  g particle of va
+00028490: 7279 696e 6720 7261 6469 7573 2061 7320  rying radius as 
+000284a0: 7365 656e 0a20 2020 2066 726f 6d20 616e  seen.    from an
+000284b0: 7920 6e75 6d62 6572 206f 6620 7069 7865  y number of pixe
+000284c0: 6420 706f 696e 7473 0a0a 2020 2020 4361  d points..    Ca
+000284d0: 6e20 6265 2064 6f6e 6520 772f 6f20 7468  n be done w/o th
+000284e0: 6520 6170 7072 6f78 696d 6174 696f 6e20  e approximation 
+000284f0: 7468 6174 2072 3c3c 640a 2020 2020 4966  that r<<d.    If
+00028500: 2056 6573 2028 616e 6420 6f70 7469 6f6e   Ves (and option
+00028510: 616c 6c79 204c 5350 6f6c 7929 2061 7265  ally LSPoly) are
+00028520: 2070 726f 7669 6465 642c 2074 616b 6573   provided, takes
+00028530: 2069 6e74 6f20 6163 636f 756e 7420 7669   into account vi
+00028540: 676e 6574 7469 6e67 0a20 2020 2022 2222  gnetting.    """
+00028550: 0a20 2020 2063 6465 6620 626c 6f63 6b20  .    cdef block 
+00028560: 3d20 5650 6f6c 7920 6973 206e 6f74 204e  = VPoly is not N
+00028570: 6f6e 650a 2020 2020 6364 6566 2066 6c6f  one.    cdef flo
+00028580: 6174 2070 6972 320a 2020 2020 6364 6566  at pir2.    cdef
+00028590: 2069 6e74 2069 692c 206a 6a2c 206e 7074   int ii, jj, npt
+000285a0: 736f 6b2c 206e 743d 706f 732e 7368 6170  sok, nt=pos.shap
+000285b0: 655b 315d 2c20 6e70 7473 3d70 7473 2e73  e[1], npts=pts.s
+000285c0: 6861 7065 5b31 5d0a 2020 2020 6364 6566  hape[1].    cdef
+000285d0: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
+000285e0: 6c65 2c20 6e64 696d 3d32 2c20 6d6f 6465  le, ndim=2, mode
+000285f0: 3d27 6327 5d20 7361 6e67 3d6e 702e 7a65  ='c'] sang=np.ze
+00028600: 726f 7328 286e 742c 6e70 7473 2929 0a20  ros((nt,npts)). 
+00028610: 2020 2063 6465 6620 6172 7261 7920 6b0a     cdef array k.
+00028620: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+00028630: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+00028640: 3d31 2c20 6d6f 6465 3d27 6327 5d20 7669  =1, mode='c'] vi
+00028650: 730a 2020 2020 6364 6566 2064 6f75 626c  s.    cdef doubl
+00028660: 655b 3a3a 315d 206b 5f76 6965 770a 2020  e[::1] k_view.  
+00028670: 2020 6364 6566 2064 6f75 626c 655b 3a3a    cdef double[::
+00028680: 315d 206c 7370 6f6c 7978 2c20 6c73 706f  1] lspolyx, lspo
+00028690: 6c79 790a 2020 2020 6364 6566 2064 6f75  lyy.    cdef dou
+000286a0: 626c 655b 3a3a 315d 206c 736e 6f72 6d78  ble[::1] lsnormx
+000286b0: 2c20 6c73 6e6f 726d 790a 2020 2020 6966  , lsnormy.    if
+000286c0: 2062 6c6f 636b 3a0a 2020 2020 2020 2020   block:.        
+000286d0: 696e 6420 3d20 7e5f 5665 735f 6973 496e  ind = ~_Ves_isIn
+000286e0: 7369 6465 2870 7473 2c20 5650 6f6c 792c  side(pts, VPoly,
+000286f0: 2076 6573 5f6c 696d 733d 564c 696d 2c20   ves_lims=VLim, 
+00028700: 7665 735f 7479 7065 3d56 5479 7065 2c0a  ves_type=VType,.
+00028710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028720: 2020 2020 2020 2020 2020 2020 2069 6e5f               in_
+00028730: 666f 726d 6174 3d27 2858 2c59 2c5a 2927  format='(X,Y,Z)'
+00028740: 2c20 7465 7374 3d54 6573 7429 0a20 2020  , test=Test).   
+00028750: 2020 2020 2069 6620 4c53 506f 6c79 2069       if LSPoly i
+00028760: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00028770: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
+00028780: 6e20 7261 6e67 6528 6c65 6e28 4c53 506f  n range(len(LSPo
+00028790: 6c79 2929 3a0a 2020 2020 2020 2020 2020  ly)):.          
+000287a0: 2020 2020 2020 696e 6420 3d20 696e 6420        ind = ind 
+000287b0: 2620 5f56 6573 5f69 7349 6e73 6964 6528  & _Ves_isInside(
+000287c0: 7074 732c 204c 5350 6f6c 795b 6969 5d2c  pts, LSPoly[ii],
+000287d0: 2076 6573 5f6c 696d 733d 4c53 4c69 6d5b   ves_lims=LSLim[
+000287e0: 6969 5d2c 0a20 2020 2020 2020 2020 2020  ii],.           
 000287f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028810: 2020 2076 6573 5f74 7970 653d 5654 7970     ves_type=VTyp
-00028820: 652c 2069 6e5f 666f 726d 6174 3d27 2858  e, in_format='(X
-00028830: 2c59 2c5a 2927 2c0a 2020 2020 2020 2020  ,Y,Z)',.        
+00028800: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00028810: 6573 5f74 7970 653d 5654 7970 652c 2069  es_type=VType, i
+00028820: 6e5f 666f 726d 6174 3d27 2858 2c59 2c5a  n_format='(X,Y,Z
+00028830: 2927 2c0a 2020 2020 2020 2020 2020 2020  )',.            
 00028840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028860: 2020 7465 7374 3d54 6573 7429 0a20 2020    test=Test).   
-00028870: 2020 2020 2020 2020 206c 7370 6f6c 7978           lspolyx
-00028880: 203d 204c 5350 6f6c 795b 302c 2e2e 2e5d   = LSPoly[0,...]
-00028890: 0a20 2020 2020 2020 2020 2020 206c 7370  .            lsp
-000288a0: 6f6c 7979 203d 204c 5350 6f6c 795b 312c  olyy = LSPoly[1,
-000288b0: 2e2e 2e5d 0a20 2020 2020 2020 2020 2020  ...].           
-000288c0: 206c 736e 6f72 6d78 203d 204c 5356 496e   lsnormx = LSVIn
-000288d0: 5b30 2c2e 2e2e 5d0a 2020 2020 2020 2020  [0,...].        
-000288e0: 2020 2020 6c73 6e6f 726d 7920 3d20 4c53      lsnormy = LS
-000288f0: 5649 6e5b 312c 2e2e 2e5d 0a20 2020 2020  VIn[1,...].     
-00028900: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00028910: 2020 2020 206c 7370 6f6c 7978 203d 204e       lspolyx = N
-00028920: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
-00028930: 6c73 706f 6c79 7920 3d20 4e6f 6e65 0a20  lspolyy = None. 
-00028940: 2020 2020 2020 2020 2020 206c 736e 6f72             lsnor
-00028950: 6d78 203d 204e 6f6e 650a 2020 2020 2020  mx = None.      
-00028960: 2020 2020 2020 6c73 6e6f 726d 7920 3d20        lsnormy = 
-00028970: 4e6f 6e65 0a20 2020 2020 2020 2069 6e64  None.        ind
-00028980: 203d 2028 7e69 6e64 292e 6e6f 6e7a 6572   = (~ind).nonzer
-00028990: 6f28 295b 305d 0a20 2020 2020 2020 2070  o()[0].        p
-000289a0: 7473 7465 6d70 203d 206e 702e 6173 636f  tstemp = np.asco
-000289b0: 6e74 6967 756f 7573 6172 7261 7928 7074  ntiguousarray(pt
-000289c0: 735b 3a2c 696e 645d 290a 2020 2020 2020  s[:,ind]).      
-000289d0: 2020 6e70 7473 6f6b 203d 2069 6e64 2e73    nptsok = ind.s
-000289e0: 697a 650a 2020 2020 2020 2020 6b20 3d20  ize.        k = 
-000289f0: 636c 6f6e 6528 6172 7261 7928 2764 2729  clone(array('d')
-00028a00: 2c20 6e70 7473 6f6b 2c20 5472 7565 290a  , nptsok, True).
-00028a10: 2020 2020 2020 2020 6b5f 7669 6577 203d          k_view =
-00028a20: 206b 0a20 2020 2020 2020 2069 6620 6170   k.        if ap
-00028a30: 7072 6f78 2061 6e64 206f 7574 5f63 6f65  prox and out_coe
-00028a40: 666f 6e6c 793a 0a20 2020 2020 2020 2020  fonly:.         
-00028a50: 2020 2066 6f72 2069 6920 696e 2072 616e     for ii in ran
-00028a60: 6765 286e 7429 3a0a 2020 2020 2020 2020  ge(nt):.        
-00028a70: 2020 2020 2020 2020 5f62 6774 2e63 6f6d          _bgt.com
-00028a80: 7075 7465 5f64 6973 745f 7074 5f76 6563  pute_dist_pt_vec
-00028a90: 2870 6f73 5b30 2c69 695d 2c20 706f 735b  (pos[0,ii], pos[
-00028aa0: 312c 6969 5d2c 0a20 2020 2020 2020 2020  1,ii],.         
+00028850: 2020 2020 2020 2020 2020 2020 2020 7465                te
+00028860: 7374 3d54 6573 7429 0a20 2020 2020 2020  st=Test).       
+00028870: 2020 2020 206c 7370 6f6c 7978 203d 204c       lspolyx = L
+00028880: 5350 6f6c 795b 302c 2e2e 2e5d 0a20 2020  SPoly[0,...].   
+00028890: 2020 2020 2020 2020 206c 7370 6f6c 7979           lspolyy
+000288a0: 203d 204c 5350 6f6c 795b 312c 2e2e 2e5d   = LSPoly[1,...]
+000288b0: 0a20 2020 2020 2020 2020 2020 206c 736e  .            lsn
+000288c0: 6f72 6d78 203d 204c 5356 496e 5b30 2c2e  ormx = LSVIn[0,.
+000288d0: 2e2e 5d0a 2020 2020 2020 2020 2020 2020  ..].            
+000288e0: 6c73 6e6f 726d 7920 3d20 4c53 5649 6e5b  lsnormy = LSVIn[
+000288f0: 312c 2e2e 2e5d 0a20 2020 2020 2020 2065  1,...].        e
+00028900: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00028910: 206c 7370 6f6c 7978 203d 204e 6f6e 650a   lspolyx = None.
+00028920: 2020 2020 2020 2020 2020 2020 6c73 706f              lspo
+00028930: 6c79 7920 3d20 4e6f 6e65 0a20 2020 2020  lyy = None.     
+00028940: 2020 2020 2020 206c 736e 6f72 6d78 203d         lsnormx =
+00028950: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
+00028960: 2020 6c73 6e6f 726d 7920 3d20 4e6f 6e65    lsnormy = None
+00028970: 0a20 2020 2020 2020 2069 6e64 203d 2028  .        ind = (
+00028980: 7e69 6e64 292e 6e6f 6e7a 6572 6f28 295b  ~ind).nonzero()[
+00028990: 305d 0a20 2020 2020 2020 2070 7473 7465  0].        ptste
+000289a0: 6d70 203d 206e 702e 6173 636f 6e74 6967  mp = np.ascontig
+000289b0: 756f 7573 6172 7261 7928 7074 735b 3a2c  uousarray(pts[:,
+000289c0: 696e 645d 290a 2020 2020 2020 2020 6e70  ind]).        np
+000289d0: 7473 6f6b 203d 2069 6e64 2e73 697a 650a  tsok = ind.size.
+000289e0: 2020 2020 2020 2020 6b20 3d20 636c 6f6e          k = clon
+000289f0: 6528 6172 7261 7928 2764 2729 2c20 6e70  e(array('d'), np
+00028a00: 7473 6f6b 2c20 5472 7565 290a 2020 2020  tsok, True).    
+00028a10: 2020 2020 6b5f 7669 6577 203d 206b 0a20      k_view = k. 
+00028a20: 2020 2020 2020 2069 6620 6170 7072 6f78         if approx
+00028a30: 2061 6e64 206f 7574 5f63 6f65 666f 6e6c   and out_coefonl
+00028a40: 793a 0a20 2020 2020 2020 2020 2020 2066  y:.            f
+00028a50: 6f72 2069 6920 696e 2072 616e 6765 286e  or ii in range(n
+00028a60: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
+00028a70: 2020 2020 5f62 6774 2e63 6f6d 7075 7465      _bgt.compute
+00028a80: 5f64 6973 745f 7074 5f76 6563 2870 6f73  _dist_pt_vec(pos
+00028a90: 5b30 2c69 695d 2c20 706f 735b 312c 6969  [0,ii], pos[1,ii
+00028aa0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 00028ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028ad0: 706f 735b 322c 6969 5d2c 206e 7074 736f  pos[2,ii], nptso
-00028ae0: 6b2c 0a20 2020 2020 2020 2020 2020 2020  k,.             
+00028ac0: 2020 2020 2020 2020 2020 2020 706f 735b              pos[
+00028ad0: 322c 6969 5d2c 206e 7074 736f 6b2c 0a20  2,ii], nptsok,. 
+00028ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00028af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028b00: 2020 2020 2020 2020 2020 2020 7074 7374              ptst
-00028b10: 656d 702c 2026 6b5f 7669 6577 5b30 5d29  emp, &k_view[0])
-00028b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00028b30: 2076 6973 203d 204c 4f53 5f69 7356 6973   vis = LOS_isVis
-00028b40: 5f50 7446 726f 6d50 7473 5f56 6573 5374  _PtFromPts_VesSt
-00028b50: 7275 6374 280a 2020 2020 2020 2020 2020  ruct(.          
-00028b60: 2020 2020 2020 2020 2020 706f 735b 302c            pos[0,
-00028b70: 6969 5d2c 2070 6f73 5b31 2c69 695d 2c0a  ii], pos[1,ii],.
+00028b00: 2020 2020 2020 2020 7074 7374 656d 702c          ptstemp,
+00028b10: 2026 6b5f 7669 6577 5b30 5d29 0a20 2020   &k_view[0]).   
+00028b20: 2020 2020 2020 2020 2020 2020 2076 6973               vis
+00028b30: 203d 204c 4f53 5f69 7356 6973 5f50 7446   = LOS_isVis_PtF
+00028b40: 726f 6d50 7473 5f56 6573 5374 7275 6374  romPts_VesStruct
+00028b50: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00028b60: 2020 2020 2020 706f 735b 302c 6969 5d2c        pos[0,ii],
+00028b70: 2070 6f73 5b31 2c69 695d 2c0a 2020 2020   pos[1,ii],.    
 00028b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028b90: 2020 2020 706f 735b 322c 6969 5d2c 2070      pos[2,ii], p
-00028ba0: 7473 7465 6d70 2c0a 2020 2020 2020 2020  tstemp,.        
-00028bb0: 2020 2020 2020 2020 2020 2020 6b3d 6b5f              k=k_
-00028bc0: 7669 6577 2c0a 2020 2020 2020 2020 2020  view,.          
-00028bd0: 2020 2020 2020 2020 2020 7665 735f 706f            ves_po
-00028be0: 6c79 3d56 506f 6c79 2c0a 2020 2020 2020  ly=VPoly,.      
-00028bf0: 2020 2020 2020 2020 2020 2020 2020 7665                ve
-00028c00: 735f 6e6f 726d 3d56 496e 2c20 7665 735f  s_norm=VIn, ves_
-00028c10: 6c69 6d73 3d56 4c69 6d2c 0a20 2020 2020  lims=VLim,.     
-00028c20: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00028c30: 7374 7275 6374 5f70 6f6c 7978 3d6c 7370  struct_polyx=lsp
-00028c40: 6f6c 7978 2c0a 2020 2020 2020 2020 2020  olyx,.          
-00028c50: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
-00028c60: 745f 706f 6c79 793d 6c73 706f 6c79 792c  t_polyy=lspolyy,
-00028c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00028c80: 2020 2020 206c 7374 7275 6374 5f6c 696d       lstruct_lim
-00028c90: 733d 4c53 4c69 6d2c 0a20 2020 2020 2020  s=LSLim,.       
-00028ca0: 2020 2020 2020 2020 2020 2020 206c 7374               lst
-00028cb0: 7275 6374 5f6e 6f72 6d78 3d6c 736e 6f72  ruct_normx=lsnor
-00028cc0: 6d78 2c0a 2020 2020 2020 2020 2020 2020  mx,.            
-00028cd0: 2020 2020 2020 2020 6c73 7472 7563 745f          lstruct_
-00028ce0: 6e6f 726d 793d 6c73 6e6f 726d 792c 0a20  normy=lsnormy,. 
-00028cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028d00: 2020 2066 6f72 6269 643d 466f 7262 6964     forbid=Forbid
-00028d10: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00028d20: 2020 2020 2020 7665 735f 7479 7065 3d56        ves_type=V
-00028d30: 5479 7065 2c0a 2020 2020 2020 2020 2020  Type,.          
-00028d40: 2020 2020 2020 2020 2020 7465 7374 3d54            test=T
-00028d50: 6573 742c 0a20 2020 2020 2020 2020 2020  est,.           
-00028d60: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00028d70: 2020 2020 2020 2066 6f72 206a 6a20 696e         for jj in
-00028d80: 2072 616e 6765 286e 7074 736f 6b29 3a0a   range(nptsok):.
+00028b90: 706f 735b 322c 6969 5d2c 2070 7473 7465  pos[2,ii], ptste
+00028ba0: 6d70 2c0a 2020 2020 2020 2020 2020 2020  mp,.            
+00028bb0: 2020 2020 2020 2020 6b3d 6b5f 7669 6577          k=k_view
+00028bc0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00028bd0: 2020 2020 2020 7665 735f 706f 6c79 3d56        ves_poly=V
+00028be0: 506f 6c79 2c0a 2020 2020 2020 2020 2020  Poly,.          
+00028bf0: 2020 2020 2020 2020 2020 7665 735f 6e6f            ves_no
+00028c00: 726d 3d56 496e 2c20 7665 735f 6c69 6d73  rm=VIn, ves_lims
+00028c10: 3d56 4c69 6d2c 0a20 2020 2020 2020 2020  =VLim,.         
+00028c20: 2020 2020 2020 2020 2020 206c 7374 7275             lstru
+00028c30: 6374 5f70 6f6c 7978 3d6c 7370 6f6c 7978  ct_polyx=lspolyx
+00028c40: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00028c50: 2020 2020 2020 6c73 7472 7563 745f 706f        lstruct_po
+00028c60: 6c79 793d 6c73 706f 6c79 792c 0a20 2020  lyy=lspolyy,.   
+00028c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028c80: 206c 7374 7275 6374 5f6c 696d 733d 4c53   lstruct_lims=LS
+00028c90: 4c69 6d2c 0a20 2020 2020 2020 2020 2020  Lim,.           
+00028ca0: 2020 2020 2020 2020 206c 7374 7275 6374           lstruct
+00028cb0: 5f6e 6f72 6d78 3d6c 736e 6f72 6d78 2c0a  _normx=lsnormx,.
+00028cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028cd0: 2020 2020 6c73 7472 7563 745f 6e6f 726d      lstruct_norm
+00028ce0: 793d 6c73 6e6f 726d 792c 0a20 2020 2020  y=lsnormy,.     
+00028cf0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00028d00: 6f72 6269 643d 466f 7262 6964 2c0a 2020  orbid=Forbid,.  
+00028d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028d20: 2020 7665 735f 7479 7065 3d56 5479 7065    ves_type=VType
+00028d30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00028d40: 2020 2020 2020 7465 7374 3d54 6573 742c        test=Test,
+00028d50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00028d60: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00028d70: 2020 2066 6f72 206a 6a20 696e 2072 616e     for jj in ran
+00028d80: 6765 286e 7074 736f 6b29 3a0a 2020 2020  ge(nptsok):.    
 00028d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028da0: 2020 2020 6966 2076 6973 5b6a 6a5d 3a0a      if vis[jj]:.
+00028da0: 6966 2076 6973 5b6a 6a5d 3a0a 2020 2020  if vis[jj]:.    
 00028db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028dc0: 2020 2020 2020 2020 7361 6e67 5b69 692c          sang[ii,
-00028dd0: 696e 645b 6a6a 5d5d 203d 2063 5f70 692f  ind[jj]] = c_pi/
-00028de0: 6b5f 7669 6577 5b6a 6a5d 2a2a 320a 2020  k_view[jj]**2.  
-00028df0: 2020 2020 2020 656c 6966 2061 7070 726f        elif appro
-00028e00: 783a 0a20 2020 2020 2020 2020 2020 2066  x:.            f
-00028e10: 6f72 2069 6920 696e 2072 616e 6765 286e  or ii in range(n
-00028e20: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-00028e30: 2020 2020 5f62 6774 2e63 6f6d 7075 7465      _bgt.compute
-00028e40: 5f64 6973 745f 7074 5f76 6563 2870 6f73  _dist_pt_vec(pos
-00028e50: 5b30 2c69 695d 2c20 706f 735b 312c 6969  [0,ii], pos[1,ii
-00028e60: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00028dc0: 2020 2020 7361 6e67 5b69 692c 696e 645b      sang[ii,ind[
+00028dd0: 6a6a 5d5d 203d 2063 5f70 692f 6b5f 7669  jj]] = c_pi/k_vi
+00028de0: 6577 5b6a 6a5d 2a2a 320a 2020 2020 2020  ew[jj]**2.      
+00028df0: 2020 656c 6966 2061 7070 726f 783a 0a20    elif approx:. 
+00028e00: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+00028e10: 6920 696e 2072 616e 6765 286e 7429 3a0a  i in range(nt):.
+00028e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028e30: 5f62 6774 2e63 6f6d 7075 7465 5f64 6973  _bgt.compute_dis
+00028e40: 745f 7074 5f76 6563 2870 6f73 5b30 2c69  t_pt_vec(pos[0,i
+00028e50: 695d 2c20 706f 735b 312c 6969 5d2c 0a20  i], pos[1,ii],. 
+00028e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00028e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028e80: 2020 2020 2020 2020 2020 2020 706f 735b              pos[
-00028e90: 322c 6969 5d2c 206e 7074 736f 6b2c 0a20  2,ii], nptsok,. 
+00028e80: 2020 2020 2020 2020 706f 735b 322c 6969          pos[2,ii
+00028e90: 5d2c 206e 7074 736f 6b2c 0a20 2020 2020  ], nptsok,.     
 00028ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00028eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028ec0: 2020 2020 2020 2020 7074 7374 656d 702c          ptstemp,
-00028ed0: 2026 6b5f 7669 6577 5b30 5d29 0a20 2020   &k_view[0]).   
-00028ee0: 2020 2020 2020 2020 2020 2020 2076 6973               vis
-00028ef0: 203d 204c 4f53 5f69 7356 6973 5f50 7446   = LOS_isVis_PtF
-00028f00: 726f 6d50 7473 5f56 6573 5374 7275 6374  romPts_VesStruct
-00028f10: 2870 6f73 5b30 2c69 695d 2c20 706f 735b  (pos[0,ii], pos[
-00028f20: 312c 6969 5d2c 0a20 2020 2020 2020 2020  1,ii],.         
+00028ec0: 2020 2020 7074 7374 656d 702c 2026 6b5f      ptstemp, &k_
+00028ed0: 7669 6577 5b30 5d29 0a20 2020 2020 2020  view[0]).       
+00028ee0: 2020 2020 2020 2020 2076 6973 203d 204c           vis = L
+00028ef0: 4f53 5f69 7356 6973 5f50 7446 726f 6d50  OS_isVis_PtFromP
+00028f00: 7473 5f56 6573 5374 7275 6374 2870 6f73  ts_VesStruct(pos
+00028f10: 5b30 2c69 695d 2c20 706f 735b 312c 6969  [0,ii], pos[1,ii
+00028f20: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 00028f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00028f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028f50: 2020 2020 2020 2020 2020 2070 6f73 5b32             pos[2
-00028f60: 2c69 695d 2c20 7074 7374 656d 702c 0a20  ,ii], ptstemp,. 
+00028f50: 2020 2020 2020 2070 6f73 5b32 2c69 695d         pos[2,ii]
+00028f60: 2c20 7074 7374 656d 702c 0a20 2020 2020  , ptstemp,.     
 00028f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00028f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028fa0: 2020 2076 6573 5f70 6f6c 793d 5650 6f6c     ves_poly=VPol
-00028fb0: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
+00028f90: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00028fa0: 6573 5f70 6f6c 793d 5650 6f6c 792c 0a20  es_poly=VPoly,. 
+00028fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00028fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00028fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028fe0: 2020 2020 2020 206b 3d6b 5f76 6965 772c         k=k_view,
-00028ff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00028fe0: 2020 206b 3d6b 5f76 6965 772c 0a20 2020     k=k_view,.   
+00028ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029000: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029020: 2020 2020 2076 6573 5f6e 6f72 6d3d 5649       ves_norm=VI
-00029030: 6e2c 2076 6573 5f6c 696d 733d 564c 696d  n, ves_lims=VLim
-00029040: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00029020: 2076 6573 5f6e 6f72 6d3d 5649 6e2c 2076   ves_norm=VIn, v
+00029030: 6573 5f6c 696d 733d 564c 696d 2c0a 2020  es_lims=VLim,.  
+00029040: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029050: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029070: 2020 2020 2020 6c73 7472 7563 745f 706f        lstruct_po
-00029080: 6c79 783d 6c73 706f 6c79 782c 0a20 2020  lyx=lspolyx,.   
+00029070: 2020 6c73 7472 7563 745f 706f 6c79 783d    lstruct_polyx=
+00029080: 6c73 706f 6c79 782c 0a20 2020 2020 2020  lspolyx,.       
 00029090: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000290a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000290b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000290c0: 206c 7374 7275 6374 5f70 6f6c 7979 3d6c   lstruct_polyy=l
-000290d0: 7370 6f6c 7979 2c0a 2020 2020 2020 2020  spolyy,.        
+000290b0: 2020 2020 2020 2020 2020 2020 206c 7374               lst
+000290c0: 7275 6374 5f70 6f6c 7979 3d6c 7370 6f6c  ruct_polyy=lspol
+000290d0: 7979 2c0a 2020 2020 2020 2020 2020 2020  yy,.            
 000290e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000290f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029100: 2020 2020 2020 2020 2020 2020 6c73 7472              lstr
-00029110: 7563 745f 6c69 6d73 3d4c 534c 696d 2c0a  uct_lims=LSLim,.
+00029100: 2020 2020 2020 2020 6c73 7472 7563 745f          lstruct_
+00029110: 6c69 6d73 3d4c 534c 696d 2c0a 2020 2020  lims=LSLim,.    
 00029120: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029130: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029150: 2020 2020 6c73 7472 7563 745f 6e6f 726d      lstruct_norm
-00029160: 783d 6c73 6e6f 726d 782c 0a20 2020 2020  x=lsnormx,.     
+00029150: 6c73 7472 7563 745f 6e6f 726d 783d 6c73  lstruct_normx=ls
+00029160: 6e6f 726d 782c 0a20 2020 2020 2020 2020  normx,.         
 00029170: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029190: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-000291a0: 7374 7275 6374 5f6e 6f72 6d79 3d6c 736e  struct_normy=lsn
-000291b0: 6f72 6d79 2c0a 2020 2020 2020 2020 2020  ormy,.          
+00029190: 2020 2020 2020 2020 2020 206c 7374 7275             lstru
+000291a0: 6374 5f6e 6f72 6d79 3d6c 736e 6f72 6d79  ct_normy=lsnormy
+000291b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 000291c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000291d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000291e0: 2020 2020 2020 2020 2020 666f 7262 6964            forbid
-000291f0: 3d46 6f72 6269 642c 0a20 2020 2020 2020  =Forbid,.       
+000291e0: 2020 2020 2020 666f 7262 6964 3d46 6f72        forbid=For
+000291f0: 6269 642c 0a20 2020 2020 2020 2020 2020  bid,.           
 00029200: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029220: 2020 2020 2020 2020 2020 2020 2076 6573               ves
-00029230: 5f74 7970 653d 5654 7970 652c 2074 6573  _type=VType, tes
-00029240: 743d 5465 7374 290a 2020 2020 2020 2020  t=Test).        
-00029250: 2020 2020 2020 2020 7069 7232 203d 2063          pir2 = c
-00029260: 5f70 692a 725b 6969 5d2a 2a32 0a20 2020  _pi*r[ii]**2.   
-00029270: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00029280: 206a 6a20 696e 2072 616e 6765 286e 7074   jj in range(npt
-00029290: 736f 6b29 3a0a 2020 2020 2020 2020 2020  sok):.          
-000292a0: 2020 2020 2020 2020 2020 6966 2076 6973            if vis
-000292b0: 5b6a 6a5d 3a0a 2020 2020 2020 2020 2020  [jj]:.          
-000292c0: 2020 2020 2020 2020 2020 2020 2020 7361                sa
-000292d0: 6e67 5b69 692c 696e 645b 6a6a 5d5d 203d  ng[ii,ind[jj]] =
-000292e0: 2070 6972 322f 6b5f 7669 6577 5b6a 6a5d   pir2/k_view[jj]
-000292f0: 2a2a 320a 2020 2020 2020 2020 656c 7365  **2.        else
-00029300: 3a0a 2020 2020 2020 2020 2020 2020 7069  :.            pi
-00029310: 7232 203d 205f 5457 4f50 490a 2020 2020  r2 = _TWOPI.    
-00029320: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
-00029330: 6e20 7261 6e67 6528 6e74 293a 0a20 2020  n range(nt):.   
-00029340: 2020 2020 2020 2020 2020 2020 205f 6267               _bg
-00029350: 742e 636f 6d70 7574 655f 6469 7374 5f70  t.compute_dist_p
-00029360: 745f 7665 6328 706f 735b 302c 6969 5d2c  t_vec(pos[0,ii],
-00029370: 2070 6f73 5b31 2c69 695d 2c0a 2020 2020   pos[1,ii],.    
+00029220: 2020 2020 2020 2020 2076 6573 5f74 7970           ves_typ
+00029230: 653d 5654 7970 652c 2074 6573 743d 5465  e=VType, test=Te
+00029240: 7374 290a 2020 2020 2020 2020 2020 2020  st).            
+00029250: 2020 2020 7069 7232 203d 2063 5f70 692a      pir2 = c_pi*
+00029260: 725b 6969 5d2a 2a32 0a20 2020 2020 2020  r[ii]**2.       
+00029270: 2020 2020 2020 2020 2066 6f72 206a 6a20           for jj 
+00029280: 696e 2072 616e 6765 286e 7074 736f 6b29  in range(nptsok)
+00029290: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000292a0: 2020 2020 2020 6966 2076 6973 5b6a 6a5d        if vis[jj]
+000292b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000292c0: 2020 2020 2020 2020 2020 7361 6e67 5b69            sang[i
+000292d0: 692c 696e 645b 6a6a 5d5d 203d 2070 6972  i,ind[jj]] = pir
+000292e0: 322f 6b5f 7669 6577 5b6a 6a5d 2a2a 320a  2/k_view[jj]**2.
+000292f0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00029300: 2020 2020 2020 2020 2020 7069 7232 203d            pir2 =
+00029310: 205f 5457 4f50 490a 2020 2020 2020 2020   _TWOPI.        
+00029320: 2020 2020 666f 7220 6969 2069 6e20 7261      for ii in ra
+00029330: 6e67 6528 6e74 293a 0a20 2020 2020 2020  nge(nt):.       
+00029340: 2020 2020 2020 2020 205f 6267 742e 636f           _bgt.co
+00029350: 6d70 7574 655f 6469 7374 5f70 745f 7665  mpute_dist_pt_ve
+00029360: 6328 706f 735b 302c 6969 5d2c 2070 6f73  c(pos[0,ii], pos
+00029370: 5b31 2c69 695d 2c0a 2020 2020 2020 2020  [1,ii],.        
 00029380: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000293a0: 2020 2020 2070 6f73 5b32 2c69 695d 2c20       pos[2,ii], 
-000293b0: 6e70 7473 6f6b 2c0a 2020 2020 2020 2020  nptsok,.        
+000293a0: 2070 6f73 5b32 2c69 695d 2c20 6e70 7473   pos[2,ii], npts
+000293b0: 6f6b 2c0a 2020 2020 2020 2020 2020 2020  ok,.            
 000293c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000293d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000293e0: 2070 7473 7465 6d70 2c20 266b 5f76 6965   ptstemp, &k_vie
-000293f0: 775b 305d 290a 2020 2020 2020 2020 2020  w[0]).          
-00029400: 2020 2020 2020 7669 7320 3d20 4c4f 535f        vis = LOS_
-00029410: 6973 5669 735f 5074 4672 6f6d 5074 735f  isVis_PtFromPts_
-00029420: 5665 7353 7472 7563 7428 706f 735b 302c  VesStruct(pos[0,
-00029430: 6969 5d2c 2070 6f73 5b31 2c69 695d 2c0a  ii], pos[1,ii],.
+000293d0: 2020 2020 2020 2020 2020 2020 2070 7473               pts
+000293e0: 7465 6d70 2c20 266b 5f76 6965 775b 305d  temp, &k_view[0]
+000293f0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00029400: 2020 7669 7320 3d20 4c4f 535f 6973 5669    vis = LOS_isVi
+00029410: 735f 5074 4672 6f6d 5074 735f 5665 7353  s_PtFromPts_VesS
+00029420: 7472 7563 7428 706f 735b 302c 6969 5d2c  truct(pos[0,ii],
+00029430: 2070 6f73 5b31 2c69 695d 2c0a 2020 2020   pos[1,ii],.    
 00029440: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029450: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029470: 2020 2020 706f 735b 322c 6969 5d2c 0a20      pos[2,ii],. 
+00029470: 706f 735b 322c 6969 5d2c 0a20 2020 2020  pos[2,ii],.     
 00029480: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000294a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000294b0: 2020 2070 7473 7465 6d70 2c0a 2020 2020     ptstemp,.    
+000294a0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+000294b0: 7473 7465 6d70 2c0a 2020 2020 2020 2020  tstemp,.        
 000294c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000294d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000294e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000294f0: 7665 735f 706f 6c79 3d56 506f 6c79 2c0a  ves_poly=VPoly,.
+000294e0: 2020 2020 2020 2020 2020 2020 7665 735f              ves_
+000294f0: 706f 6c79 3d56 506f 6c79 2c0a 2020 2020  poly=VPoly,.    
 00029500: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029510: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029530: 2020 2020 6b3d 6b5f 7669 6577 2c0a 2020      k=k_view,.  
+00029530: 6b3d 6b5f 7669 6577 2c0a 2020 2020 2020  k=k_view,.      
 00029540: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029570: 2020 7665 735f 6e6f 726d 3d56 496e 2c20    ves_norm=VIn, 
-00029580: 7665 735f 6c69 6d73 3d56 4c69 6d2c 0a20  ves_lims=VLim,. 
+00029560: 2020 2020 2020 2020 2020 2020 2020 7665                ve
+00029570: 735f 6e6f 726d 3d56 496e 2c20 7665 735f  s_norm=VIn, ves_
+00029580: 6c69 6d73 3d56 4c69 6d2c 0a20 2020 2020  lims=VLim,.     
 00029590: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000295a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000295b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000295c0: 2020 206c 7374 7275 6374 5f70 6f6c 7978     lstruct_polyx
-000295d0: 3d6c 7370 6f6c 7978 2c0a 2020 2020 2020  =lspolyx,.      
+000295b0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000295c0: 7374 7275 6374 5f70 6f6c 7978 3d6c 7370  struct_polyx=lsp
+000295d0: 6f6c 7978 2c0a 2020 2020 2020 2020 2020  olyx,.          
 000295e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000295f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029600: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
-00029610: 7472 7563 745f 706f 6c79 793d 6c73 706f  truct_polyy=lspo
-00029620: 6c79 792c 0a20 2020 2020 2020 2020 2020  lyy,.           
+00029600: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
+00029610: 745f 706f 6c79 793d 6c73 706f 6c79 792c  t_polyy=lspolyy,
+00029620: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00029630: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029650: 2020 2020 2020 2020 206c 7374 7275 6374           lstruct
-00029660: 5f6c 696d 733d 4c53 4c69 6d2c 0a20 2020  _lims=LSLim,.   
+00029650: 2020 2020 206c 7374 7275 6374 5f6c 696d       lstruct_lim
+00029660: 733d 4c53 4c69 6d2c 0a20 2020 2020 2020  s=LSLim,.       
 00029670: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000296a0: 206c 7374 7275 6374 5f6e 6f72 6d78 3d6c   lstruct_normx=l
-000296b0: 736e 6f72 6d78 2c0a 2020 2020 2020 2020  snormx,.        
+00029690: 2020 2020 2020 2020 2020 2020 206c 7374               lst
+000296a0: 7275 6374 5f6e 6f72 6d78 3d6c 736e 6f72  ruct_normx=lsnor
+000296b0: 6d78 2c0a 2020 2020 2020 2020 2020 2020  mx,.            
 000296c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000296d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000296e0: 2020 2020 2020 2020 2020 2020 6c73 7472              lstr
-000296f0: 7563 745f 6e6f 726d 793d 6c73 6e6f 726d  uct_normy=lsnorm
-00029700: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
+000296e0: 2020 2020 2020 2020 6c73 7472 7563 745f          lstruct_
+000296f0: 6e6f 726d 793d 6c73 6e6f 726d 792c 0a20  normy=lsnormy,. 
+00029700: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029710: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029730: 2020 2020 2020 2066 6f72 6269 643d 466f         forbid=Fo
-00029740: 7262 6964 2c0a 2020 2020 2020 2020 2020  rbid,.          
+00029730: 2020 2066 6f72 6269 643d 466f 7262 6964     forbid=Forbid
+00029740: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 00029750: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00029760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029770: 2020 2020 2020 2020 2020 7665 735f 7479            ves_ty
-00029780: 7065 3d56 5479 7065 2c20 7465 7374 3d54  pe=VType, test=T
-00029790: 6573 7429 0a20 2020 2020 2020 2020 2020  est).           
-000297a0: 2020 2020 2066 6f72 206a 6a20 696e 2072       for jj in r
-000297b0: 616e 6765 2830 2c6e 7074 736f 6b29 3a0a  ange(0,nptsok):.
+00029770: 2020 2020 2020 7665 735f 7479 7065 3d56        ves_type=V
+00029780: 5479 7065 2c20 7465 7374 3d54 6573 7429  Type, test=Test)
+00029790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000297a0: 2066 6f72 206a 6a20 696e 2072 616e 6765   for jj in range
+000297b0: 2830 2c6e 7074 736f 6b29 3a0a 2020 2020  (0,nptsok):.    
 000297c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000297d0: 2020 2020 6966 2076 6973 5b6a 6a5d 3a0a      if vis[jj]:.
+000297d0: 6966 2076 6973 5b6a 6a5d 3a0a 2020 2020  if vis[jj]:.    
 000297e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000297f0: 2020 2020 2020 2020 7361 6e67 5b69 692c          sang[ii,
-00029800: 696e 645b 6a6a 5d5d 203d 2070 6972 322a  ind[jj]] = pir2*
-00029810: 2831 2d63 5f73 7172 7428 312d 725b 6969  (1-c_sqrt(1-r[ii
-00029820: 5d2a 2a32 2f6b 5b6a 6a5d 2a2a 3229 290a  ]**2/k[jj]**2)).
-00029830: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-00029840: 2020 2069 6620 6170 7072 6f78 2061 6e64     if approx and
-00029850: 206f 7574 5f63 6f65 666f 6e6c 793a 0a20   out_coefonly:. 
-00029860: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
-00029870: 6920 696e 2072 616e 6765 286e 7429 3a0a  i in range(nt):.
-00029880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029890: 666f 7220 6a6a 2069 6e20 7261 6e67 6528  for jj in range(
-000298a0: 6e70 7473 293a 0a20 2020 2020 2020 2020  npts):.         
-000298b0: 2020 2020 2020 2020 2020 2064 696a 3220             dij2 
-000298c0: 3d20 2828 706f 735b 302c 6969 5d2d 7074  = ((pos[0,ii]-pt
-000298d0: 735b 302c 6a6a 5d29 2a2a 320a 2020 2020  s[0,jj])**2.    
+000297f0: 2020 2020 7361 6e67 5b69 692c 696e 645b      sang[ii,ind[
+00029800: 6a6a 5d5d 203d 2070 6972 322a 2831 2d63  jj]] = pir2*(1-c
+00029810: 5f73 7172 7428 312d 725b 6969 5d2a 2a32  _sqrt(1-r[ii]**2
+00029820: 2f6b 5b6a 6a5d 2a2a 3229 290a 0a20 2020  /k[jj]**2))..   
+00029830: 2065 6c73 653a 0a20 2020 2020 2020 2069   else:.        i
+00029840: 6620 6170 7072 6f78 2061 6e64 206f 7574  f approx and out
+00029850: 5f63 6f65 666f 6e6c 793a 0a20 2020 2020  _coefonly:.     
+00029860: 2020 2020 2020 2066 6f72 2069 6920 696e         for ii in
+00029870: 2072 616e 6765 286e 7429 3a0a 2020 2020   range(nt):.    
+00029880: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00029890: 6a6a 2069 6e20 7261 6e67 6528 6e70 7473  jj in range(npts
+000298a0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000298b0: 2020 2020 2020 2064 696a 3220 3d20 2828         dij2 = ((
+000298c0: 706f 735b 302c 6969 5d2d 7074 735b 302c  pos[0,ii]-pts[0,
+000298d0: 6a6a 5d29 2a2a 320a 2020 2020 2020 2020  jj])**2.        
 000298e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000298f0: 2020 2020 2020 2020 2b20 2870 6f73 5b31          + (pos[1
-00029900: 2c69 695d 2d70 7473 5b31 2c6a 6a5d 292a  ,ii]-pts[1,jj])*
-00029910: 2a32 0a20 2020 2020 2020 2020 2020 2020  *2.             
-00029920: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-00029930: 2028 706f 735b 322c 6969 5d2d 7074 735b   (pos[2,ii]-pts[
-00029940: 322c 6a6a 5d29 2a2a 3229 0a20 2020 2020  2,jj])**2).     
-00029950: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00029960: 616e 675b 6969 2c6a 6a5d 203d 2063 5f70  ang[ii,jj] = c_p
-00029970: 692f 6469 6a32 0a20 2020 2020 2020 2065  i/dij2.        e
-00029980: 6c69 6620 6170 7072 6f78 3a0a 2020 2020  lif approx:.    
-00029990: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
-000299a0: 6e20 7261 6e67 6528 6e74 293a 0a20 2020  n range(nt):.   
-000299b0: 2020 2020 2020 2020 2020 2020 2070 6972               pir
-000299c0: 3220 3d20 635f 7069 2a72 5b69 695d 2a2a  2 = c_pi*r[ii]**
-000299d0: 320a 2020 2020 2020 2020 2020 2020 2020  2.              
-000299e0: 2020 666f 7220 6a6a 2069 6e20 7261 6e67    for jj in rang
-000299f0: 6528 6e70 7473 293a 0a20 2020 2020 2020  e(npts):.       
-00029a00: 2020 2020 2020 2020 2020 2020 2064 696a               dij
-00029a10: 3220 3d20 2828 706f 735b 302c 6969 5d2d  2 = ((pos[0,ii]-
-00029a20: 7074 735b 302c 6a6a 5d29 2a2a 320a 2020  pts[0,jj])**2.  
+000298f0: 2020 2020 2b20 2870 6f73 5b31 2c69 695d      + (pos[1,ii]
+00029900: 2d70 7473 5b31 2c6a 6a5d 292a 2a32 0a20  -pts[1,jj])**2. 
+00029910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00029920: 2020 2020 2020 2020 2020 202b 2028 706f             + (po
+00029930: 735b 322c 6969 5d2d 7074 735b 322c 6a6a  s[2,ii]-pts[2,jj
+00029940: 5d29 2a2a 3229 0a20 2020 2020 2020 2020  ])**2).         
+00029950: 2020 2020 2020 2020 2020 2073 616e 675b             sang[
+00029960: 6969 2c6a 6a5d 203d 2063 5f70 692f 6469  ii,jj] = c_pi/di
+00029970: 6a32 0a20 2020 2020 2020 2065 6c69 6620  j2.        elif 
+00029980: 6170 7072 6f78 3a0a 2020 2020 2020 2020  approx:.        
+00029990: 2020 2020 666f 7220 6969 2069 6e20 7261      for ii in ra
+000299a0: 6e67 6528 6e74 293a 0a20 2020 2020 2020  nge(nt):.       
+000299b0: 2020 2020 2020 2020 2070 6972 3220 3d20           pir2 = 
+000299c0: 635f 7069 2a72 5b69 695d 2a2a 320a 2020  c_pi*r[ii]**2.  
+000299d0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+000299e0: 7220 6a6a 2069 6e20 7261 6e67 6528 6e70  r jj in range(np
+000299f0: 7473 293a 0a20 2020 2020 2020 2020 2020  ts):.           
+00029a00: 2020 2020 2020 2020 2064 696a 3220 3d20           dij2 = 
+00029a10: 2828 706f 735b 302c 6969 5d2d 7074 735b  ((pos[0,ii]-pts[
+00029a20: 302c 6a6a 5d29 2a2a 320a 2020 2020 2020  0,jj])**2.      
 00029a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029a40: 2020 2020 2020 2020 2020 2b20 2870 6f73            + (pos
-00029a50: 5b30 2c69 695d 2d70 7473 5b30 2c6a 6a5d  [0,ii]-pts[0,jj]
-00029a60: 292a 2a32 0a20 2020 2020 2020 2020 2020  )**2.           
-00029a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029a80: 202b 2028 706f 735b 302c 6969 5d2d 7074   + (pos[0,ii]-pt
-00029a90: 735b 302c 6a6a 5d29 2a2a 3229 0a20 2020  s[0,jj])**2).   
-00029aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029ab0: 2073 616e 675b 6969 2c6a 6a5d 203d 2070   sang[ii,jj] = p
-00029ac0: 6972 322f 6469 6a32 0a20 2020 2020 2020  ir2/dij2.       
-00029ad0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00029ae0: 2020 2070 6972 3220 3d20 5f54 574f 5049     pir2 = _TWOPI
-00029af0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00029b00: 2069 6920 696e 2072 616e 6765 286e 7429   ii in range(nt)
-00029b10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00029b20: 2020 666f 7220 6a6a 2069 6e20 7261 6e67    for jj in rang
-00029b30: 6528 6e70 7473 293a 0a20 2020 2020 2020  e(npts):.       
-00029b40: 2020 2020 2020 2020 2020 2020 2064 696a               dij
-00029b50: 3220 3d20 2828 706f 735b 302c 6969 5d2d  2 = ((pos[0,ii]-
-00029b60: 7074 735b 302c 6a6a 5d29 2a2a 320a 2020  pts[0,jj])**2.  
+00029a40: 2020 2020 2020 2b20 2870 6f73 5b30 2c69        + (pos[0,i
+00029a50: 695d 2d70 7473 5b30 2c6a 6a5d 292a 2a32  i]-pts[0,jj])**2
+00029a60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00029a70: 2020 2020 2020 2020 2020 2020 202b 2028               + (
+00029a80: 706f 735b 302c 6969 5d2d 7074 735b 302c  pos[0,ii]-pts[0,
+00029a90: 6a6a 5d29 2a2a 3229 0a20 2020 2020 2020  jj])**2).       
+00029aa0: 2020 2020 2020 2020 2020 2020 2073 616e               san
+00029ab0: 675b 6969 2c6a 6a5d 203d 2070 6972 322f  g[ii,jj] = pir2/
+00029ac0: 6469 6a32 0a20 2020 2020 2020 2065 6c73  dij2.        els
+00029ad0: 653a 0a20 2020 2020 2020 2020 2020 2070  e:.            p
+00029ae0: 6972 3220 3d20 5f54 574f 5049 0a20 2020  ir2 = _TWOPI.   
+00029af0: 2020 2020 2020 2020 2066 6f72 2069 6920           for ii 
+00029b00: 696e 2072 616e 6765 286e 7429 3a0a 2020  in range(nt):.  
+00029b10: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00029b20: 7220 6a6a 2069 6e20 7261 6e67 6528 6e70  r jj in range(np
+00029b30: 7473 293a 0a20 2020 2020 2020 2020 2020  ts):.           
+00029b40: 2020 2020 2020 2020 2064 696a 3220 3d20           dij2 = 
+00029b50: 2828 706f 735b 302c 6969 5d2d 7074 735b  ((pos[0,ii]-pts[
+00029b60: 302c 6a6a 5d29 2a2a 320a 2020 2020 2020  0,jj])**2.      
 00029b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029b80: 2020 2020 2020 2020 2020 2b20 2870 6f73            + (pos
-00029b90: 5b30 2c69 695d 2d70 7473 5b30 2c6a 6a5d  [0,ii]-pts[0,jj]
-00029ba0: 292a 2a32 0a20 2020 2020 2020 2020 2020  )**2.           
-00029bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029bc0: 202b 2028 706f 735b 302c 6969 5d2d 7074   + (pos[0,ii]-pt
-00029bd0: 735b 302c 6a6a 5d29 2a2a 3229 0a20 2020  s[0,jj])**2).   
-00029be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029bf0: 2073 616e 675b 6969 2c6a 6a5d 203d 2070   sang[ii,jj] = p
-00029c00: 6972 322a 2831 2d63 5f73 7172 7428 312d  ir2*(1-c_sqrt(1-
-00029c10: 725b 6969 5d2a 2a32 2f64 696a 3229 290a  r[ii]**2/dij2)).
-00029c20: 2020 2020 7265 7475 726e 2073 616e 670a      return sang.
-00029c30: 0a0a 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ..# ============
+00029b80: 2020 2020 2020 2b20 2870 6f73 5b30 2c69        + (pos[0,i
+00029b90: 695d 2d70 7473 5b30 2c6a 6a5d 292a 2a32  i]-pts[0,jj])**2
+00029ba0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00029bb0: 2020 2020 2020 2020 2020 2020 202b 2028               + (
+00029bc0: 706f 735b 302c 6969 5d2d 7074 735b 302c  pos[0,ii]-pts[0,
+00029bd0: 6a6a 5d29 2a2a 3229 0a20 2020 2020 2020  jj])**2).       
+00029be0: 2020 2020 2020 2020 2020 2020 2073 616e               san
+00029bf0: 675b 6969 2c6a 6a5d 203d 2070 6972 322a  g[ii,jj] = pir2*
+00029c00: 2831 2d63 5f73 7172 7428 312d 725b 6969  (1-c_sqrt(1-r[ii
+00029c10: 5d2a 2a32 2f64 696a 3229 290a 2020 2020  ]**2/dij2)).    
+00029c20: 7265 7475 726e 2073 616e 670a 0a0a 2320  return sang...# 
+00029c30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00029c40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00029c50: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00029c60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00029c70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00029c80: 3d3d 0a23 0a23 2020 2020 2020 2020 2020  ==.#.#          
-00029c90: 2020 2020 2020 2020 2020 2020 2044 4953               DIS
-00029ca0: 5441 4e43 4520 4349 5243 4c45 202d 204c  TANCE CIRCLE - L
-00029cb0: 4f53 0a23 0a23 203d 3d3d 3d3d 3d3d 3d3d  OS.#.# =========
+00029c70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a23  ==============.#
+00029c80: 0a23 2020 2020 2020 2020 2020 2020 2020  .#              
+00029c90: 2020 2020 2020 2020 2044 4953 5441 4e43           DISTANC
+00029ca0: 4520 4349 5243 4c45 202d 204c 4f53 0a23  E CIRCLE - LOS.#
+00029cb0: 0a23 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  .# =============
 00029cc0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00029cd0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00029ce0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00029cf0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00029d00: 3d3d 3d3d 3d0a 6465 6620 636f 6d70 5f64  =====.def comp_d
-00029d10: 6973 745f 6c6f 735f 6369 7263 6c65 286e  ist_los_circle(n
-00029d20: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-00029d30: 2c6e 6469 6d3d 312c 6d6f 6465 3d27 6327  ,ndim=1,mode='c'
-00029d40: 5d20 7261 795f 7664 6972 2c0a 2020 2020  ] ray_vdir,.    
+00029d00: 3d0a 6465 6620 636f 6d70 5f64 6973 745f  =.def comp_dist_
+00029d10: 6c6f 735f 6369 7263 6c65 286e 702e 6e64  los_circle(np.nd
+00029d20: 6172 7261 795b 646f 7562 6c65 2c6e 6469  array[double,ndi
+00029d30: 6d3d 312c 6d6f 6465 3d27 6327 5d20 7261  m=1,mode='c'] ra
+00029d40: 795f 7664 6972 2c0a 2020 2020 2020 2020  y_vdir,.        
 00029d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029d60: 2020 2020 206e 702e 6e64 6172 7261 795b       np.ndarray[
-00029d70: 646f 7562 6c65 2c6e 6469 6d3d 312c 6d6f  double,ndim=1,mo
-00029d80: 6465 3d27 6327 5d20 7261 795f 6f72 6967  de='c'] ray_orig
-00029d90: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00029da0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-00029db0: 6520 7261 6469 7573 2c20 646f 7562 6c65  e radius, double
-00029dc0: 2063 6972 635f 7a2c 2064 6f75 626c 6520   circ_z, double 
-00029dd0: 6e6f 726d 5f64 6972 3d2d 312e 3029 3a0a  norm_dir=-1.0):.
-00029de0: 2020 2020 2222 220a 2020 2020 5468 6973      """.    This
-00029df0: 2066 756e 6374 696f 6e20 636f 6d70 7574   function comput
-00029e00: 6573 2074 6865 2069 6e74 6572 7365 6374  es the intersect
-00029e10: 696f 6e20 6f66 2061 2052 6179 2028 6f72  ion of a Ray (or
-00029e20: 204c 696e 6520 4f66 2053 6967 6874 290a   Line Of Sight).
-00029e30: 2020 2020 616e 6420 6120 6369 7263 6c65      and a circle
-00029e40: 2069 6e20 3344 2e20 4974 2072 6574 7572   in 3D. It retur
-00029e50: 6e73 2060 6b6d 696e 6020 616e 6420 6064  ns `kmin` and `d
-00029e60: 6973 7460 2e20 5768 6572 6520 606b 6d69  ist`. Where `kmi
-00029e70: 6e60 2069 7320 7468 650a 2020 2020 636f  n` is the.    co
-00029e80: 6566 6669 6369 656e 7420 7375 6368 2074  efficient such t
-00029e90: 6861 7420 7468 6520 7261 7920 6f66 206f  hat the ray of o
-00029ea0: 7269 6769 6e20 4f20 3d20 5b6f 7269 312c  rigin O = [ori1,
-00029eb0: 206f 7269 322c 206f 7269 335d 0a20 2020   ori2, ori3].   
-00029ec0: 2061 6e64 206f 6620 6469 7265 6374 696f   and of directio
-00029ed0: 6e61 6c20 7665 6374 6f72 2044 203d 205b  nal vector D = [
-00029ee0: 6469 7231 2c20 6469 7232 2c20 6469 7233  dir1, dir2, dir3
-00029ef0: 5d20 6973 2063 6c6f 7365 7374 2074 6f20  ] is closest to 
-00029f00: 7468 6520 6369 7263 6c65 0a20 2020 2020  the circle.     
-00029f10: 6f66 2072 6164 6975 7320 6072 6164 6975  of radius `radiu
-00029f20: 7360 2061 6e64 2063 656e 7465 7265 6420  s` and centered 
-00029f30: 6028 302c 2030 2c20 6369 7263 5f7a 2960  `(0, 0, circ_z)`
-00029f40: 2061 7420 7468 6520 706f 696e 740a 2020   at the point.  
-00029f50: 2020 5020 3d20 4f20 2b20 6b6d 696e 202a    P = O + kmin *
-00029f60: 2044 2e0a 2020 2020 416e 6420 6064 6973   D..    And `dis
-00029f70: 7461 6e63 6560 2074 6865 2064 6973 7461  tance` the dista
-00029f80: 6e63 6520 6265 7477 6565 6e20 7468 6520  nce between the 
-00029f90: 7477 6f20 636c 6f73 6573 7420 706f 696e  two closest poin
-00029fa0: 7473 2028 6c69 6e65 2063 6c6f 7365 7374  ts (line closest
-00029fb0: 0a20 2020 2061 6e64 2063 6972 636c 6520  .    and circle 
-00029fc0: 636c 6f73 6573 7429 0a20 2020 2054 6865  closest).    The
-00029fd0: 2076 6172 6961 626c 6520 606e 6f72 6d5f   variable `norm_
-00029fe0: 6469 7260 2069 7320 7468 6520 7371 7561  dir` is the squa
-00029ff0: 7265 6420 6e6f 726d 206f 6620 7468 6520  red norm of the 
-0002a000: 6469 7265 6374 696f 6e20 6f66 2074 6865  direction of the
-0002a010: 2072 6179 2e0a 2020 2020 5061 7261 6d73   ray..    Params
-0002a020: 0a20 2020 203d 3d3d 3d3d 0a20 2020 2072  .    =====.    r
-0002a030: 6179 5f76 6469 723a 2028 3329 2064 6f75  ay_vdir: (3) dou
-0002a040: 626c 6520 6172 7261 790a 2020 2020 2020  ble array.      
-0002a050: 2020 7261 7927 7320 6469 7265 6374 6f72    ray's director
-0002a060: 2076 6563 746f 7220 5620 7375 6368 2074   vector V such t
-0002a070: 6861 7420 5020 5c69 6e20 5261 7920 6966  hat P \in Ray if
-0002a080: 6620 5028 7429 203d 204f 202b 2074 2a56  f P(t) = O + t*V
-0002a090: 0a20 2020 2072 6179 5f6f 7269 6720 3a20  .    ray_orig : 
-0002a0a0: 2833 2920 646f 7562 6c65 2061 7272 6179  (3) double array
-0002a0b0: 0a20 2020 2020 2020 2072 6179 2773 206f  .        ray's o
-0002a0c0: 7269 6769 6e20 636f 6f72 6469 6e61 7465  rigin coordinate
-0002a0d0: 7320 4f20 7375 6368 2074 6861 7420 5020  s O such that P 
-0002a0e0: 5c69 6e20 5261 7920 6966 6620 5028 7429  \in Ray iff P(t)
-0002a0f0: 203d 204f 202b 2074 2a56 0a20 2020 2072   = O + t*V.    r
-0002a100: 6164 6975 7320 3a20 646f 7562 6c65 0a20  adius : double. 
-0002a110: 2020 2020 2020 2072 6164 6975 7320 7220         radius r 
-0002a120: 6f66 2068 6f72 697a 6f6e 7461 6c20 6369  of horizontal ci
-0002a130: 7263 6c65 2063 656e 7465 7265 6420 696e  rcle centered in
-0002a140: 2028 302c 302c 6369 7263 5f7a 290a 2020   (0,0,circ_z).  
-0002a150: 2020 6369 7263 5f7a 203a 2064 6f75 626c    circ_z : doubl
-0002a160: 650a 2020 2020 2020 2020 3372 6420 636f  e.        3rd co
-0002a170: 6f72 6469 6e61 7465 206f 6620 686f 7269  ordinate of hori
-0002a180: 7a6f 6e74 616c 2063 6972 636c 6520 6365  zontal circle ce
-0002a190: 6e74 6572 6564 2069 6e20 2830 2c30 2c63  ntered in (0,0,c
-0002a1a0: 6972 635f 7a29 206f 6620 7261 6469 7573  irc_z) of radius
-0002a1b0: 2072 0a20 2020 206e 6f72 6d5f 6469 7220   r.    norm_dir 
-0002a1c0: 3a20 646f 7562 6c65 2028 6f70 7469 6f6e  : double (option
-0002a1d0: 616c 290a 2020 2020 2020 2020 4966 2066  al).        If f
-0002a1e0: 6f72 2063 6f6d 7075 7461 7469 6f6e 2072  or computation r
-0002a1f0: 6561 736f 6e73 2069 7420 6d61 6b65 7320  easons it makes 
-0002a200: 7365 6e73 652c 2079 6f75 2063 616e 2070  sense, you can p
-0002a210: 6173 7320 7468 6520 6e6f 726d 206f 6620  ass the norm of 
-0002a220: 7468 650a 2020 2020 2020 2020 6469 7265  the.        dire
-0002a230: 6374 6f72 2076 6563 746f 720a 2020 2020  ctor vector.    
-0002a240: 5265 7475 726e 730a 2020 2020 3d3d 3d3d  Returns.    ====
-0002a250: 3d3d 3d0a 2020 2020 7265 7375 6c74 203a  ===.    result :
-0002a260: 2064 6f75 626c 6520 2832 2920 6172 7261   double (2) arra
-0002a270: 790a 2020 2020 2020 202d 2072 6573 756c  y.       - resul
-0002a280: 745b 305d 2077 696c 6c20 636f 6e74 6169  t[0] will contai
-0002a290: 6e20 7468 6520 6b20 636f 6566 6669 6369  n the k coeffici
-0002a2a0: 656e 7420 746f 2066 696e 6420 7468 6520  ent to find the 
-0002a2b0: 6c69 6e65 2070 6f69 6e74 2063 6c6f 7365  line point close
-0002a2c0: 7374 0a20 2020 2020 2020 636c 6f73 6573  st.       closes
-0002a2d0: 7420 706f 696e 740a 2020 2020 2020 202d  t point.       -
-0002a2e0: 2072 6573 756c 745b 315d 2077 696c 6c20   result[1] will 
-0002a2f0: 636f 6e74 6169 6e20 7468 6520 4449 5354  contain the DIST
-0002a300: 414e 4345 2066 726f 6d20 6c69 6e65 2063  ANCE from line c
-0002a310: 6c6f 7365 7374 2070 6f69 6e74 2074 6f20  losest point to 
-0002a320: 6369 7263 6c65 0a20 2020 2020 2020 746f  circle.       to
-0002a330: 2074 6865 2063 6972 636c 650a 2020 2020   the circle.    
-0002a340: 2d2d 2d0a 2020 2020 5468 6973 2069 7320  ---.    This is 
-0002a350: 7468 6520 5059 5448 4f4e 2066 756e 6374  the PYTHON funct
-0002a360: 696f 6e2c 2075 7365 206f 6e6c 7920 6966  ion, use only if
-0002a370: 2079 6f75 206e 6565 6420 7468 6973 2063   you need this c
-0002a380: 6f6d 7075 7461 7469 6f6e 2066 726f 6d0a  omputation from.
-0002a390: 2020 2020 5079 7468 6f6e 2c20 6966 2079      Python, if y
-0002a3a0: 6f75 206e 6565 6420 6974 2066 726f 6d20  ou need it from 
-0002a3b0: 6379 7468 6f6e 2c20 7573 6520 6064 6973  cython, use `dis
-0002a3c0: 745f 6c6f 735f 6369 7263 6c65 5f63 6f72  t_los_circle_cor
-0002a3d0: 6560 0a20 2020 2022 2222 0a20 2020 2063  e`.    """.    c
-0002a3e0: 6465 6620 646f 7562 6c65 5b32 5d20 7265  def double[2] re
-0002a3f0: 730a 2020 2020 5f64 742e 6469 7374 5f6c  s.    _dt.dist_l
-0002a400: 6f73 5f63 6972 636c 655f 636f 7265 283c  os_circle_core(<
-0002a410: 646f 7562 6c65 2a3e 7261 795f 7664 6972  double*>ray_vdir
-0002a420: 2e64 6174 612c 0a20 2020 2020 2020 2020  .data,.         
-0002a430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002a440: 2020 203c 646f 7562 6c65 2a3e 7261 795f     <double*>ray_
-0002a450: 6f72 6967 2e64 6174 612c 0a20 2020 2020  orig.data,.     
+00029d60: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
+00029d70: 6c65 2c6e 6469 6d3d 312c 6d6f 6465 3d27  le,ndim=1,mode='
+00029d80: 6327 5d20 7261 795f 6f72 6967 2c0a 2020  c'] ray_orig,.  
+00029d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00029da0: 2020 2020 2020 2064 6f75 626c 6520 7261         double ra
+00029db0: 6469 7573 2c20 646f 7562 6c65 2063 6972  dius, double cir
+00029dc0: 635f 7a2c 2064 6f75 626c 6520 6e6f 726d  c_z, double norm
+00029dd0: 5f64 6972 3d2d 312e 3029 3a0a 2020 2020  _dir=-1.0):.    
+00029de0: 2222 220a 2020 2020 5468 6973 2066 756e  """.    This fun
+00029df0: 6374 696f 6e20 636f 6d70 7574 6573 2074  ction computes t
+00029e00: 6865 2069 6e74 6572 7365 6374 696f 6e20  he intersection 
+00029e10: 6f66 2061 2052 6179 2028 6f72 204c 696e  of a Ray (or Lin
+00029e20: 6520 4f66 2053 6967 6874 290a 2020 2020  e Of Sight).    
+00029e30: 616e 6420 6120 6369 7263 6c65 2069 6e20  and a circle in 
+00029e40: 3344 2e20 4974 2072 6574 7572 6e73 2060  3D. It returns `
+00029e50: 6b6d 696e 6020 616e 6420 6064 6973 7460  kmin` and `dist`
+00029e60: 2e20 5768 6572 6520 606b 6d69 6e60 2069  . Where `kmin` i
+00029e70: 7320 7468 650a 2020 2020 636f 6566 6669  s the.    coeffi
+00029e80: 6369 656e 7420 7375 6368 2074 6861 7420  cient such that 
+00029e90: 7468 6520 7261 7920 6f66 206f 7269 6769  the ray of origi
+00029ea0: 6e20 4f20 3d20 5b6f 7269 312c 206f 7269  n O = [ori1, ori
+00029eb0: 322c 206f 7269 335d 0a20 2020 2061 6e64  2, ori3].    and
+00029ec0: 206f 6620 6469 7265 6374 696f 6e61 6c20   of directional 
+00029ed0: 7665 6374 6f72 2044 203d 205b 6469 7231  vector D = [dir1
+00029ee0: 2c20 6469 7232 2c20 6469 7233 5d20 6973  , dir2, dir3] is
+00029ef0: 2063 6c6f 7365 7374 2074 6f20 7468 6520   closest to the 
+00029f00: 6369 7263 6c65 0a20 2020 2020 6f66 2072  circle.     of r
+00029f10: 6164 6975 7320 6072 6164 6975 7360 2061  adius `radius` a
+00029f20: 6e64 2063 656e 7465 7265 6420 6028 302c  nd centered `(0,
+00029f30: 2030 2c20 6369 7263 5f7a 2960 2061 7420   0, circ_z)` at 
+00029f40: 7468 6520 706f 696e 740a 2020 2020 5020  the point.    P 
+00029f50: 3d20 4f20 2b20 6b6d 696e 202a 2044 2e0a  = O + kmin * D..
+00029f60: 2020 2020 416e 6420 6064 6973 7461 6e63      And `distanc
+00029f70: 6560 2074 6865 2064 6973 7461 6e63 6520  e` the distance 
+00029f80: 6265 7477 6565 6e20 7468 6520 7477 6f20  between the two 
+00029f90: 636c 6f73 6573 7420 706f 696e 7473 2028  closest points (
+00029fa0: 6c69 6e65 2063 6c6f 7365 7374 0a20 2020  line closest.   
+00029fb0: 2061 6e64 2063 6972 636c 6520 636c 6f73   and circle clos
+00029fc0: 6573 7429 0a20 2020 2054 6865 2076 6172  est).    The var
+00029fd0: 6961 626c 6520 606e 6f72 6d5f 6469 7260  iable `norm_dir`
+00029fe0: 2069 7320 7468 6520 7371 7561 7265 6420   is the squared 
+00029ff0: 6e6f 726d 206f 6620 7468 6520 6469 7265  norm of the dire
+0002a000: 6374 696f 6e20 6f66 2074 6865 2072 6179  ction of the ray
+0002a010: 2e0a 2020 2020 5061 7261 6d73 0a20 2020  ..    Params.   
+0002a020: 203d 3d3d 3d3d 0a20 2020 2072 6179 5f76   =====.    ray_v
+0002a030: 6469 723a 2028 3329 2064 6f75 626c 6520  dir: (3) double 
+0002a040: 6172 7261 790a 2020 2020 2020 2020 7261  array.        ra
+0002a050: 7927 7320 6469 7265 6374 6f72 2076 6563  y's director vec
+0002a060: 746f 7220 5620 7375 6368 2074 6861 7420  tor V such that 
+0002a070: 5020 5c69 6e20 5261 7920 6966 6620 5028  P \in Ray iff P(
+0002a080: 7429 203d 204f 202b 2074 2a56 0a20 2020  t) = O + t*V.   
+0002a090: 2072 6179 5f6f 7269 6720 3a20 2833 2920   ray_orig : (3) 
+0002a0a0: 646f 7562 6c65 2061 7272 6179 0a20 2020  double array.   
+0002a0b0: 2020 2020 2072 6179 2773 206f 7269 6769       ray's origi
+0002a0c0: 6e20 636f 6f72 6469 6e61 7465 7320 4f20  n coordinates O 
+0002a0d0: 7375 6368 2074 6861 7420 5020 5c69 6e20  such that P \in 
+0002a0e0: 5261 7920 6966 6620 5028 7429 203d 204f  Ray iff P(t) = O
+0002a0f0: 202b 2074 2a56 0a20 2020 2072 6164 6975   + t*V.    radiu
+0002a100: 7320 3a20 646f 7562 6c65 0a20 2020 2020  s : double.     
+0002a110: 2020 2072 6164 6975 7320 7220 6f66 2068     radius r of h
+0002a120: 6f72 697a 6f6e 7461 6c20 6369 7263 6c65  orizontal circle
+0002a130: 2063 656e 7465 7265 6420 696e 2028 302c   centered in (0,
+0002a140: 302c 6369 7263 5f7a 290a 2020 2020 6369  0,circ_z).    ci
+0002a150: 7263 5f7a 203a 2064 6f75 626c 650a 2020  rc_z : double.  
+0002a160: 2020 2020 2020 3372 6420 636f 6f72 6469        3rd coordi
+0002a170: 6e61 7465 206f 6620 686f 7269 7a6f 6e74  nate of horizont
+0002a180: 616c 2063 6972 636c 6520 6365 6e74 6572  al circle center
+0002a190: 6564 2069 6e20 2830 2c30 2c63 6972 635f  ed in (0,0,circ_
+0002a1a0: 7a29 206f 6620 7261 6469 7573 2072 0a20  z) of radius r. 
+0002a1b0: 2020 206e 6f72 6d5f 6469 7220 3a20 646f     norm_dir : do
+0002a1c0: 7562 6c65 2028 6f70 7469 6f6e 616c 290a  uble (optional).
+0002a1d0: 2020 2020 2020 2020 4966 2066 6f72 2063          If for c
+0002a1e0: 6f6d 7075 7461 7469 6f6e 2072 6561 736f  omputation reaso
+0002a1f0: 6e73 2069 7420 6d61 6b65 7320 7365 6e73  ns it makes sens
+0002a200: 652c 2079 6f75 2063 616e 2070 6173 7320  e, you can pass 
+0002a210: 7468 6520 6e6f 726d 206f 6620 7468 650a  the norm of the.
+0002a220: 2020 2020 2020 2020 6469 7265 6374 6f72          director
+0002a230: 2076 6563 746f 720a 2020 2020 5265 7475   vector.    Retu
+0002a240: 726e 730a 2020 2020 3d3d 3d3d 3d3d 3d0a  rns.    =======.
+0002a250: 2020 2020 7265 7375 6c74 203a 2064 6f75      result : dou
+0002a260: 626c 6520 2832 2920 6172 7261 790a 2020  ble (2) array.  
+0002a270: 2020 2020 202d 2072 6573 756c 745b 305d       - result[0]
+0002a280: 2077 696c 6c20 636f 6e74 6169 6e20 7468   will contain th
+0002a290: 6520 6b20 636f 6566 6669 6369 656e 7420  e k coefficient 
+0002a2a0: 746f 2066 696e 6420 7468 6520 6c69 6e65  to find the line
+0002a2b0: 2070 6f69 6e74 2063 6c6f 7365 7374 0a20   point closest. 
+0002a2c0: 2020 2020 2020 636c 6f73 6573 7420 706f        closest po
+0002a2d0: 696e 740a 2020 2020 2020 202d 2072 6573  int.       - res
+0002a2e0: 756c 745b 315d 2077 696c 6c20 636f 6e74  ult[1] will cont
+0002a2f0: 6169 6e20 7468 6520 4449 5354 414e 4345  ain the DISTANCE
+0002a300: 2066 726f 6d20 6c69 6e65 2063 6c6f 7365   from line close
+0002a310: 7374 2070 6f69 6e74 2074 6f20 6369 7263  st point to circ
+0002a320: 6c65 0a20 2020 2020 2020 746f 2074 6865  le.       to the
+0002a330: 2063 6972 636c 650a 2020 2020 2d2d 2d0a   circle.    ---.
+0002a340: 2020 2020 5468 6973 2069 7320 7468 6520      This is the 
+0002a350: 5059 5448 4f4e 2066 756e 6374 696f 6e2c  PYTHON function,
+0002a360: 2075 7365 206f 6e6c 7920 6966 2079 6f75   use only if you
+0002a370: 206e 6565 6420 7468 6973 2063 6f6d 7075   need this compu
+0002a380: 7461 7469 6f6e 2066 726f 6d0a 2020 2020  tation from.    
+0002a390: 5079 7468 6f6e 2c20 6966 2079 6f75 206e  Python, if you n
+0002a3a0: 6565 6420 6974 2066 726f 6d20 6379 7468  eed it from cyth
+0002a3b0: 6f6e 2c20 7573 6520 6064 6973 745f 6c6f  on, use `dist_lo
+0002a3c0: 735f 6369 7263 6c65 5f63 6f72 6560 0a20  s_circle_core`. 
+0002a3d0: 2020 2022 2222 0a20 2020 2063 6465 6620     """.    cdef 
+0002a3e0: 646f 7562 6c65 5b32 5d20 7265 730a 2020  double[2] res.  
+0002a3f0: 2020 5f64 742e 6469 7374 5f6c 6f73 5f63    _dt.dist_los_c
+0002a400: 6972 636c 655f 636f 7265 283c 646f 7562  ircle_core(<doub
+0002a410: 6c65 2a3e 7261 795f 7664 6972 2e64 6174  le*>ray_vdir.dat
+0002a420: 612c 0a20 2020 2020 2020 2020 2020 2020  a,.             
+0002a430: 2020 2020 2020 2020 2020 2020 2020 203c                 <
+0002a440: 646f 7562 6c65 2a3e 7261 795f 6f72 6967  double*>ray_orig
+0002a450: 2e64 6174 612c 0a20 2020 2020 2020 2020  .data,.         
 0002a460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002a470: 2020 2020 2020 2072 6164 6975 732c 2063         radius, c
-0002a480: 6972 635f 7a2c 206e 6f72 6d5f 6469 722c  irc_z, norm_dir,
-0002a490: 2072 6573 290a 2020 2020 7265 7475 726e   res).    return
-0002a4a0: 206e 702e 6173 6172 7261 7928 7265 7329   np.asarray(res)
-0002a4b0: 0a0a 6465 6620 636f 6d70 5f64 6973 745f  ..def comp_dist_
-0002a4c0: 6c6f 735f 6369 7263 6c65 5f76 6563 2869  los_circle_vec(i
-0002a4d0: 6e74 206e 6c6f 732c 2069 6e74 206e 6369  nt nlos, int nci
-0002a4e0: 7263 6c65 732c 0a20 2020 2020 2020 2020  rcles,.         
+0002a470: 2020 2072 6164 6975 732c 2063 6972 635f     radius, circ_
+0002a480: 7a2c 206e 6f72 6d5f 6469 722c 2072 6573  z, norm_dir, res
+0002a490: 290a 2020 2020 7265 7475 726e 206e 702e  ).    return np.
+0002a4a0: 6173 6172 7261 7928 7265 7329 0a0a 6465  asarray(res)..de
+0002a4b0: 6620 636f 6d70 5f64 6973 745f 6c6f 735f  f comp_dist_los_
+0002a4c0: 6369 7263 6c65 5f76 6563 2869 6e74 206e  circle_vec(int n
+0002a4d0: 6c6f 732c 2069 6e74 206e 6369 7263 6c65  los, int ncircle
+0002a4e0: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
 0002a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002a500: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
-0002a510: 6f75 626c 652c 6e64 696d 3d32 2c6d 6f64  ouble,ndim=2,mod
-0002a520: 653d 2763 275d 2064 6972 732c 0a20 2020  e='c'] dirs,.   
+0002a500: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+0002a510: 652c 6e64 696d 3d32 2c6d 6f64 653d 2763  e,ndim=2,mode='c
+0002a520: 275d 2064 6972 732c 0a20 2020 2020 2020  '] dirs,.       
 0002a530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002a540: 2020 2020 2020 2020 2020 6e70 2e6e 6461            np.nda
-0002a550: 7272 6179 5b64 6f75 626c 652c 6e64 696d  rray[double,ndim
-0002a560: 3d32 2c6d 6f64 653d 2763 275d 206f 7269  =2,mode='c'] ori
-0002a570: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
-0002a580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002a590: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0002a5a0: 652c 6e64 696d 3d31 2c6d 6f64 653d 2763  e,ndim=1,mode='c
-0002a5b0: 275d 2063 6972 636c 655f 7261 6469 7573  '] circle_radius
-0002a5c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0002a5d0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0002a5e0: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-0002a5f0: 2c6e 6469 6d3d 312c 6d6f 6465 3d27 6327  ,ndim=1,mode='c'
-0002a600: 5d20 6369 7263 6c65 5f7a 2c0a 2020 2020  ] circle_z,.    
+0002a540: 2020 2020 2020 6e70 2e6e 6461 7272 6179        np.ndarray
+0002a550: 5b64 6f75 626c 652c 6e64 696d 3d32 2c6d  [double,ndim=2,m
+0002a560: 6f64 653d 2763 275d 206f 7269 732c 0a20  ode='c'] oris,. 
+0002a570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a580: 2020 2020 2020 2020 2020 2020 6e70 2e6e              np.n
+0002a590: 6461 7272 6179 5b64 6f75 626c 652c 6e64  darray[double,nd
+0002a5a0: 696d 3d31 2c6d 6f64 653d 2763 275d 2063  im=1,mode='c'] c
+0002a5b0: 6972 636c 655f 7261 6469 7573 2c0a 2020  ircle_radius,.  
+0002a5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a5d0: 2020 2020 2020 2020 2020 206e 702e 6e64             np.nd
+0002a5e0: 6172 7261 795b 646f 7562 6c65 2c6e 6469  array[double,ndi
+0002a5f0: 6d3d 312c 6d6f 6465 3d27 6327 5d20 6369  m=1,mode='c'] ci
+0002a600: 7263 6c65 5f7a 2c0a 2020 2020 2020 2020  rcle_z,.        
 0002a610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002a620: 2020 2020 2020 2020 206e 702e 6e64 6172           np.ndar
-0002a630: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
-0002a640: 312c 6d6f 6465 3d27 6327 5d20 6e6f 726d  1,mode='c'] norm
-0002a650: 5f64 6972 203d 204e 6f6e 652c 0a20 2020  _dir = None,.   
+0002a620: 2020 2020 206e 702e 6e64 6172 7261 795b       np.ndarray[
+0002a630: 646f 7562 6c65 2c6e 6469 6d3d 312c 6d6f  double,ndim=1,mo
+0002a640: 6465 3d27 6327 5d20 6e6f 726d 5f64 6972  de='c'] norm_dir
+0002a650: 203d 204e 6f6e 652c 0a20 2020 2020 2020   = None,.       
 0002a660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002a670: 2020 2020 2020 2020 2020 696e 7420 6e75            int nu
-0002a680: 6d5f 7468 7265 6164 733d 3438 293a 0a20  m_threads=48):. 
-0002a690: 2020 2022 2222 0a20 2020 2054 6869 7320     """.    This 
-0002a6a0: 6675 6e63 7469 6f6e 2063 6f6d 7075 7465  function compute
-0002a6b0: 7320 7468 6520 696e 7465 7273 6563 7469  s the intersecti
-0002a6c0: 6f6e 206f 6620 6120 5261 7920 286f 7220  on of a Ray (or 
-0002a6d0: 4c69 6e65 204f 6620 5369 6768 7429 0a20  Line Of Sight). 
-0002a6e0: 2020 2061 6e64 2061 2063 6972 636c 6520     and a circle 
-0002a6f0: 696e 2033 442e 2049 7420 7265 7475 726e  in 3D. It return
-0002a700: 7320 606b 6d69 6e60 2c20 7468 6520 636f  s `kmin`, the co
-0002a710: 6566 6669 6369 656e 7420 7375 6368 2074  efficient such t
-0002a720: 6861 7420 7468 650a 2020 2020 7261 7920  hat the.    ray 
-0002a730: 6f66 206f 7269 6769 6e20 4f20 3d20 5b6f  of origin O = [o
-0002a740: 7269 312c 206f 7269 322c 206f 7269 335d  ri1, ori2, ori3]
-0002a750: 2061 6e64 206f 6620 6469 7265 6374 696f   and of directio
-0002a760: 6e61 6c20 7665 6374 6f72 0a20 2020 2044  nal vector.    D
-0002a770: 203d 205b 6469 7231 2c20 6469 7232 2c20   = [dir1, dir2, 
-0002a780: 6469 7233 5d20 6973 2063 6c6f 7365 7374  dir3] is closest
-0002a790: 2074 6f20 7468 6520 6369 7263 6c65 206f   to the circle o
-0002a7a0: 6620 7261 6469 7573 2060 7261 6469 7573  f radius `radius
-0002a7b0: 600a 2020 2020 616e 6420 6365 6e74 6572  `.    and center
-0002a7c0: 6564 2060 2830 2c20 302c 2063 6972 635f  ed `(0, 0, circ_
-0002a7d0: 7a29 6020 6174 2074 6865 2070 6f69 6e74  z)` at the point
-0002a7e0: 2050 203d 204f 202b 206b 6d69 6e20 2a20   P = O + kmin * 
-0002a7f0: 442e 0a20 2020 2054 6865 2076 6172 6961  D..    The varia
-0002a800: 626c 6520 606e 6f72 6d5f 6469 7260 2069  ble `norm_dir` i
-0002a810: 7320 7468 6520 7371 7561 7265 6420 6e6f  s the squared no
-0002a820: 726d 206f 6620 7468 6520 6469 7265 6374  rm of the direct
-0002a830: 696f 6e20 6f66 2074 6865 2072 6179 2e0a  ion of the ray..
-0002a840: 2020 2020 5468 6973 2069 7320 7468 6520      This is the 
-0002a850: 7665 6374 6f72 6961 6c20 7665 7273 696f  vectorial versio
-0002a860: 6e2c 2077 6520 6578 7065 6374 2074 6865  n, we expect the
-0002a870: 2064 6972 6563 7469 6f6e 7320 616e 6420   directions and 
-0002a880: 6f72 6967 696e 7320 746f 2062 653a 0a20  origins to be:. 
-0002a890: 2020 2064 6972 7320 3d20 5b5b 6469 7231     dirs = [[dir1
-0002a8a0: 5f6c 6f73 312c 2064 6972 325f 6c6f 7331  _los1, dir2_los1
-0002a8b0: 2c20 6469 7233 5f6c 6f73 315d 2c20 5b64  , dir3_los1], [d
-0002a8c0: 6972 315f 6c6f 7332 2c2e 2e2e 5d0a 2020  ir1_los2,...].  
-0002a8d0: 2020 6f72 6973 203d 205b 5b6f 7269 315f    oris = [[ori1_
-0002a8e0: 6c6f 7331 2c20 6f72 6932 5f6c 6f73 312c  los1, ori2_los1,
-0002a8f0: 206f 7269 335f 6c6f 7331 5d2c 205b 6f72   ori3_los1], [or
-0002a900: 6931 5f6c 6f73 322c 2e2e 2e5d 0a20 2020  i1_los2,...].   
-0002a910: 2052 6574 7572 6e73 0a20 2020 203d 3d3d   Returns.    ===
-0002a920: 3d3d 3d3d 0a20 2020 2072 6573 203a 2028  ====.    res : (
-0002a930: 322c 206e 6c6f 732c 206e 6369 7263 6c65  2, nlos, ncircle
-0002a940: 7329 0a20 2020 2020 2020 2072 6573 203d  s).        res =
-0002a950: 205b 7265 735f 6b2c 2072 6573 5f64 5d20   [res_k, res_d] 
-0002a960: 7768 6572 6520 7265 735f 6b20 6973 2061  where res_k is a
-0002a970: 2028 6e6c 6f73 2c20 6e63 6972 636c 6573   (nlos, ncircles
-0002a980: 2920 6e75 6d70 7920 6172 7261 790a 2020  ) numpy array.  
-0002a990: 2020 2020 2020 7769 7468 2074 6865 206b        with the k
-0002a9a0: 2063 6f65 6666 6963 6965 6e74 7320 666f   coefficients fo
-0002a9b0: 7220 6561 6368 204c 4f53 2077 6865 7265  r each LOS where
-0002a9c0: 2074 6865 206d 696e 696d 756d 2064 6973   the minimum dis
-0002a9d0: 7461 6e63 650a 2020 2020 2020 2020 746f  tance.        to
-0002a9e0: 2065 6163 6820 6369 7263 6c65 2069 7320   each circle is 
-0002a9f0: 7265 6163 6865 640a 2020 2020 2020 2020  reached.        
-0002aa00: 6973 206d 6574 2066 6f72 2065 6163 6820  is met for each 
-0002aa10: 6369 7263 6c65 2c20 616e 6420 7265 735f  circle, and res_
-0002aa20: 6420 6973 2061 2028 6e6c 6f73 2c20 6e63  d is a (nlos, nc
-0002aa30: 6972 636c 6573 2920 6e75 6d70 7920 6172  ircles) numpy ar
-0002aa40: 7261 790a 2020 2020 2020 2020 7769 7468  ray.        with
-0002aa50: 2074 6865 2064 6973 7461 6e63 6520 6265   the distance be
-0002aa60: 7477 6565 6e20 6561 6368 204c 4f53 2074  tween each LOS t
-0002aa70: 6f20 6561 6368 2063 6972 636c 650a 2020  o each circle.  
-0002aa80: 2020 2d2d 2d0a 2020 2020 5468 6973 2069    ---.    This i
-0002aa90: 7320 7468 6520 5059 5448 4f4e 2066 756e  s the PYTHON fun
-0002aaa0: 6374 696f 6e2c 2075 7365 206f 6e6c 7920  ction, use only 
-0002aab0: 6966 2079 6f75 206e 6565 6420 7468 6973  if you need this
-0002aac0: 2063 6f6d 7075 7461 7469 6f6e 2066 726f   computation fro
-0002aad0: 6d0a 2020 2020 5079 7468 6f6e 2c20 6966  m.    Python, if
-0002aae0: 2079 6f75 206e 6565 6420 6974 2066 726f   you need it fro
-0002aaf0: 6d20 6379 7468 6f6e 2c20 7573 6520 6064  m cython, use `d
-0002ab00: 6973 745f 6c6f 735f 6369 7263 6c65 5f63  ist_los_circle_c
-0002ab10: 6f72 6560 0a20 2020 2022 2222 0a20 2020  ore`.    """.   
-0002ab20: 2063 6465 6620 6172 7261 7920 6b6d 696e   cdef array kmin
-0002ab30: 5f74 6162 203d 2063 6c6f 6e65 2861 7272  _tab = clone(arr
-0002ab40: 6179 2827 6427 292c 206e 6c6f 732a 6e63  ay('d'), nlos*nc
-0002ab50: 6972 636c 6573 2c20 5472 7565 290a 2020  ircles, True).  
-0002ab60: 2020 6364 6566 2061 7272 6179 2064 6973    cdef array dis
-0002ab70: 745f 7461 6220 3d20 636c 6f6e 6528 6172  t_tab = clone(ar
-0002ab80: 7261 7928 2764 2729 2c20 6e6c 6f73 2a6e  ray('d'), nlos*n
-0002ab90: 6369 7263 6c65 732c 2054 7275 6529 0a0a  circles, True)..
-0002aba0: 2020 2020 6966 206e 6f72 6d5f 6469 7220      if norm_dir 
-0002abb0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0002abc0: 206e 6f72 6d5f 6469 7220 3d20 2d6e 702e   norm_dir = -np.
-0002abd0: 6f6e 6573 286e 6c6f 7329 0a20 2020 205f  ones(nlos).    _
-0002abe0: 6474 2e63 6f6d 705f 6469 7374 5f6c 6f73  dt.comp_dist_los
-0002abf0: 5f63 6972 636c 655f 7665 635f 636f 7265  _circle_vec_core
-0002ac00: 286e 6c6f 732c 206e 6369 7263 6c65 732c  (nlos, ncircles,
-0002ac10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002a670: 2020 2020 2020 696e 7420 6e75 6d5f 7468        int num_th
+0002a680: 7265 6164 733d 3438 293a 0a20 2020 2022  reads=48):.    "
+0002a690: 2222 0a20 2020 2054 6869 7320 6675 6e63  "".    This func
+0002a6a0: 7469 6f6e 2063 6f6d 7075 7465 7320 7468  tion computes th
+0002a6b0: 6520 696e 7465 7273 6563 7469 6f6e 206f  e intersection o
+0002a6c0: 6620 6120 5261 7920 286f 7220 4c69 6e65  f a Ray (or Line
+0002a6d0: 204f 6620 5369 6768 7429 0a20 2020 2061   Of Sight).    a
+0002a6e0: 6e64 2061 2063 6972 636c 6520 696e 2033  nd a circle in 3
+0002a6f0: 442e 2049 7420 7265 7475 726e 7320 606b  D. It returns `k
+0002a700: 6d69 6e60 2c20 7468 6520 636f 6566 6669  min`, the coeffi
+0002a710: 6369 656e 7420 7375 6368 2074 6861 7420  cient such that 
+0002a720: 7468 650a 2020 2020 7261 7920 6f66 206f  the.    ray of o
+0002a730: 7269 6769 6e20 4f20 3d20 5b6f 7269 312c  rigin O = [ori1,
+0002a740: 206f 7269 322c 206f 7269 335d 2061 6e64   ori2, ori3] and
+0002a750: 206f 6620 6469 7265 6374 696f 6e61 6c20   of directional 
+0002a760: 7665 6374 6f72 0a20 2020 2044 203d 205b  vector.    D = [
+0002a770: 6469 7231 2c20 6469 7232 2c20 6469 7233  dir1, dir2, dir3
+0002a780: 5d20 6973 2063 6c6f 7365 7374 2074 6f20  ] is closest to 
+0002a790: 7468 6520 6369 7263 6c65 206f 6620 7261  the circle of ra
+0002a7a0: 6469 7573 2060 7261 6469 7573 600a 2020  dius `radius`.  
+0002a7b0: 2020 616e 6420 6365 6e74 6572 6564 2060    and centered `
+0002a7c0: 2830 2c20 302c 2063 6972 635f 7a29 6020  (0, 0, circ_z)` 
+0002a7d0: 6174 2074 6865 2070 6f69 6e74 2050 203d  at the point P =
+0002a7e0: 204f 202b 206b 6d69 6e20 2a20 442e 0a20   O + kmin * D.. 
+0002a7f0: 2020 2054 6865 2076 6172 6961 626c 6520     The variable 
+0002a800: 606e 6f72 6d5f 6469 7260 2069 7320 7468  `norm_dir` is th
+0002a810: 6520 7371 7561 7265 6420 6e6f 726d 206f  e squared norm o
+0002a820: 6620 7468 6520 6469 7265 6374 696f 6e20  f the direction 
+0002a830: 6f66 2074 6865 2072 6179 2e0a 2020 2020  of the ray..    
+0002a840: 5468 6973 2069 7320 7468 6520 7665 6374  This is the vect
+0002a850: 6f72 6961 6c20 7665 7273 696f 6e2c 2077  orial version, w
+0002a860: 6520 6578 7065 6374 2074 6865 2064 6972  e expect the dir
+0002a870: 6563 7469 6f6e 7320 616e 6420 6f72 6967  ections and orig
+0002a880: 696e 7320 746f 2062 653a 0a20 2020 2064  ins to be:.    d
+0002a890: 6972 7320 3d20 5b5b 6469 7231 5f6c 6f73  irs = [[dir1_los
+0002a8a0: 312c 2064 6972 325f 6c6f 7331 2c20 6469  1, dir2_los1, di
+0002a8b0: 7233 5f6c 6f73 315d 2c20 5b64 6972 315f  r3_los1], [dir1_
+0002a8c0: 6c6f 7332 2c2e 2e2e 5d0a 2020 2020 6f72  los2,...].    or
+0002a8d0: 6973 203d 205b 5b6f 7269 315f 6c6f 7331  is = [[ori1_los1
+0002a8e0: 2c20 6f72 6932 5f6c 6f73 312c 206f 7269  , ori2_los1, ori
+0002a8f0: 335f 6c6f 7331 5d2c 205b 6f72 6931 5f6c  3_los1], [ori1_l
+0002a900: 6f73 322c 2e2e 2e5d 0a20 2020 2052 6574  os2,...].    Ret
+0002a910: 7572 6e73 0a20 2020 203d 3d3d 3d3d 3d3d  urns.    =======
+0002a920: 0a20 2020 2072 6573 203a 2028 322c 206e  .    res : (2, n
+0002a930: 6c6f 732c 206e 6369 7263 6c65 7329 0a20  los, ncircles). 
+0002a940: 2020 2020 2020 2072 6573 203d 205b 7265         res = [re
+0002a950: 735f 6b2c 2072 6573 5f64 5d20 7768 6572  s_k, res_d] wher
+0002a960: 6520 7265 735f 6b20 6973 2061 2028 6e6c  e res_k is a (nl
+0002a970: 6f73 2c20 6e63 6972 636c 6573 2920 6e75  os, ncircles) nu
+0002a980: 6d70 7920 6172 7261 790a 2020 2020 2020  mpy array.      
+0002a990: 2020 7769 7468 2074 6865 206b 2063 6f65    with the k coe
+0002a9a0: 6666 6963 6965 6e74 7320 666f 7220 6561  fficients for ea
+0002a9b0: 6368 204c 4f53 2077 6865 7265 2074 6865  ch LOS where the
+0002a9c0: 206d 696e 696d 756d 2064 6973 7461 6e63   minimum distanc
+0002a9d0: 650a 2020 2020 2020 2020 746f 2065 6163  e.        to eac
+0002a9e0: 6820 6369 7263 6c65 2069 7320 7265 6163  h circle is reac
+0002a9f0: 6865 640a 2020 2020 2020 2020 6973 206d  hed.        is m
+0002aa00: 6574 2066 6f72 2065 6163 6820 6369 7263  et for each circ
+0002aa10: 6c65 2c20 616e 6420 7265 735f 6420 6973  le, and res_d is
+0002aa20: 2061 2028 6e6c 6f73 2c20 6e63 6972 636c   a (nlos, ncircl
+0002aa30: 6573 2920 6e75 6d70 7920 6172 7261 790a  es) numpy array.
+0002aa40: 2020 2020 2020 2020 7769 7468 2074 6865          with the
+0002aa50: 2064 6973 7461 6e63 6520 6265 7477 6565   distance betwee
+0002aa60: 6e20 6561 6368 204c 4f53 2074 6f20 6561  n each LOS to ea
+0002aa70: 6368 2063 6972 636c 650a 2020 2020 2d2d  ch circle.    --
+0002aa80: 2d0a 2020 2020 5468 6973 2069 7320 7468  -.    This is th
+0002aa90: 6520 5059 5448 4f4e 2066 756e 6374 696f  e PYTHON functio
+0002aaa0: 6e2c 2075 7365 206f 6e6c 7920 6966 2079  n, use only if y
+0002aab0: 6f75 206e 6565 6420 7468 6973 2063 6f6d  ou need this com
+0002aac0: 7075 7461 7469 6f6e 2066 726f 6d0a 2020  putation from.  
+0002aad0: 2020 5079 7468 6f6e 2c20 6966 2079 6f75    Python, if you
+0002aae0: 206e 6565 6420 6974 2066 726f 6d20 6379   need it from cy
+0002aaf0: 7468 6f6e 2c20 7573 6520 6064 6973 745f  thon, use `dist_
+0002ab00: 6c6f 735f 6369 7263 6c65 5f63 6f72 6560  los_circle_core`
+0002ab10: 0a20 2020 2022 2222 0a20 2020 2063 6465  .    """.    cde
+0002ab20: 6620 6172 7261 7920 6b6d 696e 5f74 6162  f array kmin_tab
+0002ab30: 203d 2063 6c6f 6e65 2861 7272 6179 2827   = clone(array('
+0002ab40: 6427 292c 206e 6c6f 732a 6e63 6972 636c  d'), nlos*ncircl
+0002ab50: 6573 2c20 5472 7565 290a 2020 2020 6364  es, True).    cd
+0002ab60: 6566 2061 7272 6179 2064 6973 745f 7461  ef array dist_ta
+0002ab70: 6220 3d20 636c 6f6e 6528 6172 7261 7928  b = clone(array(
+0002ab80: 2764 2729 2c20 6e6c 6f73 2a6e 6369 7263  'd'), nlos*ncirc
+0002ab90: 6c65 732c 2054 7275 6529 0a0a 2020 2020  les, True)..    
+0002aba0: 6966 206e 6f72 6d5f 6469 7220 6973 204e  if norm_dir is N
+0002abb0: 6f6e 653a 0a20 2020 2020 2020 206e 6f72  one:.        nor
+0002abc0: 6d5f 6469 7220 3d20 2d6e 702e 6f6e 6573  m_dir = -np.ones
+0002abd0: 286e 6c6f 7329 0a20 2020 205f 6474 2e63  (nlos).    _dt.c
+0002abe0: 6f6d 705f 6469 7374 5f6c 6f73 5f63 6972  omp_dist_los_cir
+0002abf0: 636c 655f 7665 635f 636f 7265 286e 6c6f  cle_vec_core(nlo
+0002ac00: 732c 206e 6369 7263 6c65 732c 0a20 2020  s, ncircles,.   
+0002ac10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002ac20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ac30: 2020 2020 2020 203c 646f 7562 6c65 2a3e         <double*>
-0002ac40: 6469 7273 2e64 6174 612c 0a20 2020 2020  dirs.data,.     
+0002ac30: 2020 203c 646f 7562 6c65 2a3e 6469 7273     <double*>dirs
+0002ac40: 2e64 6174 612c 0a20 2020 2020 2020 2020  .data,.         
 0002ac50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ac60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ac70: 203c 646f 7562 6c65 2a3e 6f72 6973 2e64   <double*>oris.d
-0002ac80: 6174 612c 0a20 2020 2020 2020 2020 2020  ata,.           
+0002ac60: 2020 2020 2020 2020 2020 2020 203c 646f               <do
+0002ac70: 7562 6c65 2a3e 6f72 6973 2e64 6174 612c  uble*>oris.data,
+0002ac80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0002ac90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002aca0: 2020 2020 2020 2020 2020 203c 646f 7562             <doub
-0002acb0: 6c65 2a3e 6369 7263 6c65 5f72 6164 6975  le*>circle_radiu
-0002acc0: 732e 6461 7461 2c0a 2020 2020 2020 2020  s.data,.        
+0002aca0: 2020 2020 2020 203c 646f 7562 6c65 2a3e         <double*>
+0002acb0: 6369 7263 6c65 5f72 6164 6975 732e 6461  circle_radius.da
+0002acc0: 7461 2c0a 2020 2020 2020 2020 2020 2020  ta,.            
 0002acd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ace0: 2020 2020 2020 2020 2020 2020 2020 3c64                <d
-0002acf0: 6f75 626c 652a 3e63 6972 636c 655f 7a2e  ouble*>circle_z.
-0002ad00: 6461 7461 2c0a 2020 2020 2020 2020 2020  data,.          
+0002ace0: 2020 2020 2020 2020 2020 3c64 6f75 626c            <doubl
+0002acf0: 652a 3e63 6972 636c 655f 7a2e 6461 7461  e*>circle_z.data
+0002ad00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 0002ad10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ad20: 2020 2020 2020 2020 2020 2020 3c64 6f75              <dou
-0002ad30: 626c 652a 3e6e 6f72 6d5f 6469 722e 6461  ble*>norm_dir.da
-0002ad40: 7461 2c0a 2020 2020 2020 2020 2020 2020  ta,.            
+0002ad20: 2020 2020 2020 2020 3c64 6f75 626c 652a          <double*
+0002ad30: 3e6e 6f72 6d5f 6469 722e 6461 7461 2c0a  >norm_dir.data,.
+0002ad40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002ad50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ad60: 2020 2020 2020 2020 2020 6b6d 696e 5f74            kmin_t
-0002ad70: 6162 2c20 6469 7374 5f74 6162 2c20 6e75  ab, dist_tab, nu
-0002ad80: 6d5f 7468 7265 6164 7329 0a20 2020 2072  m_threads).    r
-0002ad90: 6574 7572 6e20 6e70 2e61 7361 7272 6179  eturn np.asarray
-0002ada0: 286b 6d69 6e5f 7461 6229 2e72 6573 6861  (kmin_tab).resha
-0002adb0: 7065 286e 6c6f 732c 206e 6369 7263 6c65  pe(nlos, ncircle
-0002adc0: 7329 2c20 5c0a 2020 2020 2020 2020 6e70  s), \.        np
-0002add0: 2e61 7361 7272 6179 2864 6973 745f 7461  .asarray(dist_ta
-0002ade0: 6229 2e72 6573 6861 7065 286e 6c6f 732c  b).reshape(nlos,
-0002adf0: 206e 6369 7263 6c65 7329 0a0a 0a23 203d   ncircles)...# =
+0002ad60: 2020 2020 2020 6b6d 696e 5f74 6162 2c20        kmin_tab, 
+0002ad70: 6469 7374 5f74 6162 2c20 6e75 6d5f 7468  dist_tab, num_th
+0002ad80: 7265 6164 7329 0a20 2020 2072 6574 7572  reads).    retur
+0002ad90: 6e20 6e70 2e61 7361 7272 6179 286b 6d69  n np.asarray(kmi
+0002ada0: 6e5f 7461 6229 2e72 6573 6861 7065 286e  n_tab).reshape(n
+0002adb0: 6c6f 732c 206e 6369 7263 6c65 7329 2c20  los, ncircles), 
+0002adc0: 5c0a 2020 2020 2020 2020 6e70 2e61 7361  \.        np.asa
+0002add0: 7272 6179 2864 6973 745f 7461 6229 2e72  rray(dist_tab).r
+0002ade0: 6573 6861 7065 286e 6c6f 732c 206e 6369  eshape(nlos, nci
+0002adf0: 7263 6c65 7329 0a0a 0a23 203d 3d3d 3d3d  rcles)...# =====
 0002ae00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002ae10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002ae20: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002ae30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002ae40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 230a  =============.#.
-0002ae50: 2320 2020 2020 2020 2020 2020 2020 2020  #               
-0002ae60: 2020 2020 2020 2020 5445 5354 2043 4c4f          TEST CLO
-0002ae70: 5345 4e45 5353 2043 4952 434c 4520 2d20  SENESS CIRCLE - 
-0002ae80: 4c4f 530a 230a 2320 3d3d 3d3d 3d3d 3d3d  LOS.#.# ========
+0002ae40: 3d3d 3d3d 3d3d 3d3d 3d0a 230a 2320 2020  =========.#.#   
+0002ae50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002ae60: 2020 2020 5445 5354 2043 4c4f 5345 4e45      TEST CLOSENE
+0002ae70: 5353 2043 4952 434c 4520 2d20 4c4f 530a  SS CIRCLE - LOS.
+0002ae80: 230a 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  #.# ============
 0002ae90: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002aea0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002aeb0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002aec0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002aed0: 3d3d 3d3d 3d3d 0a0a 6465 6620 6973 5f63  ======..def is_c
-0002aee0: 6c6f 7365 5f6c 6f73 5f63 6972 636c 6528  lose_los_circle(
-0002aef0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0002af00: 652c 6e64 696d 3d31 2c6d 6f64 653d 2763  e,ndim=1,mode='c
-0002af10: 275d 2072 6179 5f76 6469 722c 0a20 2020  '] ray_vdir,.   
+0002aed0: 3d3d 0a0a 6465 6620 6973 5f63 6c6f 7365  ==..def is_close
+0002aee0: 5f6c 6f73 5f63 6972 636c 6528 6e70 2e6e  _los_circle(np.n
+0002aef0: 6461 7272 6179 5b64 6f75 626c 652c 6e64  darray[double,nd
+0002af00: 696d 3d31 2c6d 6f64 653d 2763 275d 2072  im=1,mode='c'] r
+0002af10: 6179 5f76 6469 722c 0a20 2020 2020 2020  ay_vdir,.       
 0002af20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002af30: 2020 2020 206e 702e 6e64 6172 7261 795b       np.ndarray[
-0002af40: 646f 7562 6c65 2c6e 6469 6d3d 312c 6d6f  double,ndim=1,mo
-0002af50: 6465 3d27 6327 5d20 7261 795f 6f72 6967  de='c'] ray_orig
-0002af60: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0002af70: 2020 2020 2020 2020 2020 646f 7562 6c65            double
-0002af80: 2072 6164 6975 732c 2064 6f75 626c 6520   radius, double 
-0002af90: 6369 7263 5f7a 2c20 646f 7562 6c65 2065  circ_z, double e
-0002afa0: 7073 2c0a 2020 2020 2020 2020 2020 2020  ps,.            
-0002afb0: 2020 2020 2020 2020 2020 2020 646f 7562              doub
-0002afc0: 6c65 206e 6f72 6d5f 6469 723d 2d31 2e30  le norm_dir=-1.0
-0002afd0: 293a 0a20 2020 2022 2222 0a20 2020 2054  ):.    """.    T
-0002afe0: 6869 7320 6675 6e63 7469 6f6e 2063 6865  his function che
-0002aff0: 636b 7320 6966 2061 7420 6d61 7869 6d75  cks if at maximu
-0002b000: 6d20 6120 4c4f 5320 6973 2061 7420 6120  m a LOS is at a 
-0002b010: 6469 7374 616e 6365 2065 7073 696c 6f6e  distance epsilon
-0002b020: 0a20 2020 2066 6f72 6d20 6120 6369 726c  .    form a cirl
-0002b030: 6365 0a20 2020 2054 6865 2072 6573 756c  ce.    The resul
-0002b040: 7420 6973 2054 7275 6520 7768 656e 2064  t is True when d
-0002b050: 6973 7461 6e63 6520 3c20 6570 7369 6c6f  istance < epsilo
-0002b060: 6e0a 2020 2020 2d2d 2d0a 2020 2020 5468  n.    ---.    Th
-0002b070: 6973 2069 7320 7468 6520 5059 5448 4f4e  is is the PYTHON
-0002b080: 2066 756e 6374 696f 6e2c 2075 7365 206f   function, use o
-0002b090: 6e6c 7920 6966 2079 6f75 206e 6565 6420  nly if you need 
-0002b0a0: 7468 6973 2063 6f6d 7075 7461 7469 6f6e  this computation
-0002b0b0: 2066 726f 6d0a 2020 2020 5079 7468 6f6e   from.    Python
-0002b0c0: 2c20 6966 2079 6f75 206e 6565 6420 6974  , if you need it
-0002b0d0: 2066 726f 6d20 6379 7468 6f6e 2c20 7573   from cython, us
-0002b0e0: 6520 6069 735f 6c6f 735f 636c 6f73 655f  e `is_los_close_
-0002b0f0: 6369 7263 6c65 5f63 6f72 6560 0a20 2020  circle_core`.   
-0002b100: 2022 2222 0a20 2020 2072 6574 7572 6e20   """.    return 
-0002b110: 5f64 742e 6973 5f63 6c6f 7365 5f6c 6f73  _dt.is_close_los
-0002b120: 5f63 6972 636c 655f 636f 7265 283c 646f  _circle_core(<do
-0002b130: 7562 6c65 2a3e 7261 795f 7664 6972 2e64  uble*>ray_vdir.d
-0002b140: 6174 612c 0a20 2020 2020 2020 2020 2020  ata,.           
+0002af30: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
+0002af40: 6c65 2c6e 6469 6d3d 312c 6d6f 6465 3d27  le,ndim=1,mode='
+0002af50: 6327 5d20 7261 795f 6f72 6967 2c0a 2020  c'] ray_orig,.  
+0002af60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002af70: 2020 2020 2020 646f 7562 6c65 2072 6164        double rad
+0002af80: 6975 732c 2064 6f75 626c 6520 6369 7263  ius, double circ
+0002af90: 5f7a 2c20 646f 7562 6c65 2065 7073 2c0a  _z, double eps,.
+0002afa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002afb0: 2020 2020 2020 2020 646f 7562 6c65 206e          double n
+0002afc0: 6f72 6d5f 6469 723d 2d31 2e30 293a 0a20  orm_dir=-1.0):. 
+0002afd0: 2020 2022 2222 0a20 2020 2054 6869 7320     """.    This 
+0002afe0: 6675 6e63 7469 6f6e 2063 6865 636b 7320  function checks 
+0002aff0: 6966 2061 7420 6d61 7869 6d75 6d20 6120  if at maximum a 
+0002b000: 4c4f 5320 6973 2061 7420 6120 6469 7374  LOS is at a dist
+0002b010: 616e 6365 2065 7073 696c 6f6e 0a20 2020  ance epsilon.   
+0002b020: 2066 6f72 6d20 6120 6369 726c 6365 0a20   form a cirlce. 
+0002b030: 2020 2054 6865 2072 6573 756c 7420 6973     The result is
+0002b040: 2054 7275 6520 7768 656e 2064 6973 7461   True when dista
+0002b050: 6e63 6520 3c20 6570 7369 6c6f 6e0a 2020  nce < epsilon.  
+0002b060: 2020 2d2d 2d0a 2020 2020 5468 6973 2069    ---.    This i
+0002b070: 7320 7468 6520 5059 5448 4f4e 2066 756e  s the PYTHON fun
+0002b080: 6374 696f 6e2c 2075 7365 206f 6e6c 7920  ction, use only 
+0002b090: 6966 2079 6f75 206e 6565 6420 7468 6973  if you need this
+0002b0a0: 2063 6f6d 7075 7461 7469 6f6e 2066 726f   computation fro
+0002b0b0: 6d0a 2020 2020 5079 7468 6f6e 2c20 6966  m.    Python, if
+0002b0c0: 2079 6f75 206e 6565 6420 6974 2066 726f   you need it fro
+0002b0d0: 6d20 6379 7468 6f6e 2c20 7573 6520 6069  m cython, use `i
+0002b0e0: 735f 6c6f 735f 636c 6f73 655f 6369 7263  s_los_close_circ
+0002b0f0: 6c65 5f63 6f72 6560 0a20 2020 2022 2222  le_core`.    """
+0002b100: 0a20 2020 2072 6574 7572 6e20 5f64 742e  .    return _dt.
+0002b110: 6973 5f63 6c6f 7365 5f6c 6f73 5f63 6972  is_close_los_cir
+0002b120: 636c 655f 636f 7265 283c 646f 7562 6c65  cle_core(<double
+0002b130: 2a3e 7261 795f 7664 6972 2e64 6174 612c  *>ray_vdir.data,
+0002b140: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0002b150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b160: 2020 2020 2020 2020 2020 2020 203c 646f               <do
-0002b170: 7562 6c65 2a3e 7261 795f 6f72 6967 2e64  uble*>ray_orig.d
-0002b180: 6174 612c 0a20 2020 2020 2020 2020 2020  ata,.           
+0002b160: 2020 2020 2020 2020 203c 646f 7562 6c65           <double
+0002b170: 2a3e 7261 795f 6f72 6967 2e64 6174 612c  *>ray_orig.data,
+0002b180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0002b190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b1a0: 2020 2020 2020 2020 2020 2020 2072 6164               rad
-0002b1b0: 6975 732c 2063 6972 635f 7a2c 206e 6f72  ius, circ_z, nor
-0002b1c0: 6d5f 6469 722c 2065 7073 290a 0a64 6566  m_dir, eps)..def
-0002b1d0: 2069 735f 636c 6f73 655f 6c6f 735f 6369   is_close_los_ci
-0002b1e0: 7263 6c65 5f76 6563 2869 6e74 206e 6c6f  rcle_vec(int nlo
-0002b1f0: 732c 2069 6e74 206e 6369 7263 6c65 732c  s, int ncircles,
-0002b200: 2064 6f75 626c 6520 6570 7369 6c6f 6e2c   double epsilon,
-0002b210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0002b220: 2020 2020 2020 2020 2020 2020 2020 6e70                np
-0002b230: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
-0002b240: 6e64 696d 3d32 2c6d 6f64 653d 2763 275d  ndim=2,mode='c']
-0002b250: 2064 6972 732c 0a20 2020 2020 2020 2020   dirs,.         
+0002b1a0: 2020 2020 2020 2020 2072 6164 6975 732c           radius,
+0002b1b0: 2063 6972 635f 7a2c 206e 6f72 6d5f 6469   circ_z, norm_di
+0002b1c0: 722c 2065 7073 290a 0a64 6566 2069 735f  r, eps)..def is_
+0002b1d0: 636c 6f73 655f 6c6f 735f 6369 7263 6c65  close_los_circle
+0002b1e0: 5f76 6563 2869 6e74 206e 6c6f 732c 2069  _vec(int nlos, i
+0002b1f0: 6e74 206e 6369 7263 6c65 732c 2064 6f75  nt ncircles, dou
+0002b200: 626c 6520 6570 7369 6c6f 6e2c 0a20 2020  ble epsilon,.   
+0002b210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002b220: 2020 2020 2020 2020 2020 6e70 2e6e 6461            np.nda
+0002b230: 7272 6179 5b64 6f75 626c 652c 6e64 696d  rray[double,ndim
+0002b240: 3d32 2c6d 6f64 653d 2763 275d 2064 6972  =2,mode='c'] dir
+0002b250: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
 0002b260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b270: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
-0002b280: 6f75 626c 652c 6e64 696d 3d32 2c6d 6f64  ouble,ndim=2,mod
-0002b290: 653d 2763 275d 206f 7269 732c 0a20 2020  e='c'] oris,.   
+0002b270: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+0002b280: 652c 6e64 696d 3d32 2c6d 6f64 653d 2763  e,ndim=2,mode='c
+0002b290: 275d 206f 7269 732c 0a20 2020 2020 2020  '] oris,.       
 0002b2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b2b0: 2020 2020 2020 2020 2020 6e70 2e6e 6461            np.nda
-0002b2c0: 7272 6179 5b64 6f75 626c 652c 6e64 696d  rray[double,ndim
-0002b2d0: 3d31 2c6d 6f64 653d 2763 275d 2063 6972  =1,mode='c'] cir
-0002b2e0: 636c 655f 7261 6469 7573 2c0a 2020 2020  cle_radius,.    
+0002b2b0: 2020 2020 2020 6e70 2e6e 6461 7272 6179        np.ndarray
+0002b2c0: 5b64 6f75 626c 652c 6e64 696d 3d31 2c6d  [double,ndim=1,m
+0002b2d0: 6f64 653d 2763 275d 2063 6972 636c 655f  ode='c'] circle_
+0002b2e0: 7261 6469 7573 2c0a 2020 2020 2020 2020  radius,.        
 0002b2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b300: 2020 2020 2020 2020 206e 702e 6e64 6172           np.ndar
-0002b310: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
-0002b320: 312c 6d6f 6465 3d27 6327 5d20 6369 7263  1,mode='c'] circ
-0002b330: 6c65 5f7a 2c0a 2020 2020 2020 2020 2020  le_z,.          
-0002b340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b350: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
-0002b360: 7562 6c65 2c6e 6469 6d3d 312c 6d6f 6465  uble,ndim=1,mode
-0002b370: 3d27 6327 5d20 6e6f 726d 5f64 6972 3d4e  ='c'] norm_dir=N
-0002b380: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
-0002b390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b3a0: 2020 696e 7420 6e75 6d5f 7468 7265 6164    int num_thread
-0002b3b0: 733d 3438 293a 0a20 2020 2022 2222 0a20  s=48):.    """. 
-0002b3c0: 2020 2054 6869 7320 6675 6e63 7469 6f6e     This function
-0002b3d0: 2063 6865 636b 7320 6966 2061 7420 6d61   checks if at ma
-0002b3e0: 7869 6d75 6d20 6120 4c4f 5320 6973 2061  ximum a LOS is a
-0002b3f0: 7420 6120 6469 7374 616e 6365 2065 7073  t a distance eps
-0002b400: 696c 6f6e 0a20 2020 2066 6f72 6d20 6120  ilon.    form a 
-0002b410: 6369 726c 6365 2e20 5665 6374 6f72 6961  cirlce. Vectoria
-0002b420: 6c20 7665 7273 696f 6e0a 2020 2020 5468  l version.    Th
-0002b430: 6520 7265 7375 6c74 2069 7320 5472 7565  e result is True
-0002b440: 2077 6865 6e20 6469 7374 616e 6365 203c   when distance <
-0002b450: 2065 7073 696c 6f6e 0a20 2020 202d 2d2d   epsilon.    ---
-0002b460: 0a20 2020 2054 6869 7320 6973 2074 6865  .    This is the
-0002b470: 2050 5954 484f 4e20 6675 6e63 7469 6f6e   PYTHON function
-0002b480: 2c20 7573 6520 6f6e 6c79 2069 6620 796f  , use only if yo
-0002b490: 7520 6e65 6564 2074 6869 7320 636f 6d70  u need this comp
-0002b4a0: 7574 6174 696f 6e20 6672 6f6d 0a20 2020  utation from.   
-0002b4b0: 2050 7974 686f 6e2c 2069 6620 796f 7520   Python, if you 
-0002b4c0: 6e65 6564 2069 7420 6672 6f6d 2063 7974  need it from cyt
-0002b4d0: 686f 6e2c 2075 7365 2060 6973 5f6c 6f73  hon, use `is_los
-0002b4e0: 5f63 6c6f 7365 5f63 6972 636c 655f 636f  _close_circle_co
-0002b4f0: 7265 600a 2020 2020 2222 220a 2020 2020  re`.    """.    
-0002b500: 6364 6566 2061 7272 6179 2072 6573 203d  cdef array res =
-0002b510: 2063 6c6f 6e65 2861 7272 6179 2827 6927   clone(array('i'
-0002b520: 292c 206e 6c6f 732c 2054 7275 6529 0a0a  ), nlos, True)..
-0002b530: 2020 2020 6966 206e 6f72 6d5f 6469 7220      if norm_dir 
-0002b540: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0002b550: 206e 6f72 6d5f 6469 7220 3d20 2d6e 702e   norm_dir = -np.
-0002b560: 6f6e 6573 286e 6c6f 7329 0a20 2020 205f  ones(nlos).    _
-0002b570: 6474 2e69 735f 636c 6f73 655f 6c6f 735f  dt.is_close_los_
-0002b580: 6369 7263 6c65 5f76 6563 5f63 6f72 6528  circle_vec_core(
-0002b590: 6e6c 6f73 2c20 6e63 6972 636c 6573 2c0a  nlos, ncircles,.
+0002b300: 2020 2020 206e 702e 6e64 6172 7261 795b       np.ndarray[
+0002b310: 646f 7562 6c65 2c6e 6469 6d3d 312c 6d6f  double,ndim=1,mo
+0002b320: 6465 3d27 6327 5d20 6369 7263 6c65 5f7a  de='c'] circle_z
+0002b330: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0002b340: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0002b350: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+0002b360: 2c6e 6469 6d3d 312c 6d6f 6465 3d27 6327  ,ndim=1,mode='c'
+0002b370: 5d20 6e6f 726d 5f64 6972 3d4e 6f6e 652c  ] norm_dir=None,
+0002b380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002b390: 2020 2020 2020 2020 2020 2020 2020 696e                in
+0002b3a0: 7420 6e75 6d5f 7468 7265 6164 733d 3438  t num_threads=48
+0002b3b0: 293a 0a20 2020 2022 2222 0a20 2020 2054  ):.    """.    T
+0002b3c0: 6869 7320 6675 6e63 7469 6f6e 2063 6865  his function che
+0002b3d0: 636b 7320 6966 2061 7420 6d61 7869 6d75  cks if at maximu
+0002b3e0: 6d20 6120 4c4f 5320 6973 2061 7420 6120  m a LOS is at a 
+0002b3f0: 6469 7374 616e 6365 2065 7073 696c 6f6e  distance epsilon
+0002b400: 0a20 2020 2066 6f72 6d20 6120 6369 726c  .    form a cirl
+0002b410: 6365 2e20 5665 6374 6f72 6961 6c20 7665  ce. Vectorial ve
+0002b420: 7273 696f 6e0a 2020 2020 5468 6520 7265  rsion.    The re
+0002b430: 7375 6c74 2069 7320 5472 7565 2077 6865  sult is True whe
+0002b440: 6e20 6469 7374 616e 6365 203c 2065 7073  n distance < eps
+0002b450: 696c 6f6e 0a20 2020 202d 2d2d 0a20 2020  ilon.    ---.   
+0002b460: 2054 6869 7320 6973 2074 6865 2050 5954   This is the PYT
+0002b470: 484f 4e20 6675 6e63 7469 6f6e 2c20 7573  HON function, us
+0002b480: 6520 6f6e 6c79 2069 6620 796f 7520 6e65  e only if you ne
+0002b490: 6564 2074 6869 7320 636f 6d70 7574 6174  ed this computat
+0002b4a0: 696f 6e20 6672 6f6d 0a20 2020 2050 7974  ion from.    Pyt
+0002b4b0: 686f 6e2c 2069 6620 796f 7520 6e65 6564  hon, if you need
+0002b4c0: 2069 7420 6672 6f6d 2063 7974 686f 6e2c   it from cython,
+0002b4d0: 2075 7365 2060 6973 5f6c 6f73 5f63 6c6f   use `is_los_clo
+0002b4e0: 7365 5f63 6972 636c 655f 636f 7265 600a  se_circle_core`.
+0002b4f0: 2020 2020 2222 220a 2020 2020 6364 6566      """.    cdef
+0002b500: 2061 7272 6179 2072 6573 203d 2063 6c6f   array res = clo
+0002b510: 6e65 2861 7272 6179 2827 6927 292c 206e  ne(array('i'), n
+0002b520: 6c6f 732c 2054 7275 6529 0a0a 2020 2020  los, True)..    
+0002b530: 6966 206e 6f72 6d5f 6469 7220 6973 204e  if norm_dir is N
+0002b540: 6f6e 653a 0a20 2020 2020 2020 206e 6f72  one:.        nor
+0002b550: 6d5f 6469 7220 3d20 2d6e 702e 6f6e 6573  m_dir = -np.ones
+0002b560: 286e 6c6f 7329 0a20 2020 205f 6474 2e69  (nlos).    _dt.i
+0002b570: 735f 636c 6f73 655f 6c6f 735f 6369 7263  s_close_los_circ
+0002b580: 6c65 5f76 6563 5f63 6f72 6528 6e6c 6f73  le_vec_core(nlos
+0002b590: 2c20 6e63 6972 636c 6573 2c0a 2020 2020  , ncircles,.    
 0002b5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002b5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b5c0: 2020 2020 2065 7073 696c 6f6e 2c0a 2020       epsilon,.  
+0002b5c0: 2065 7073 696c 6f6e 2c0a 2020 2020 2020   epsilon,.      
 0002b5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b5f0: 2020 203c 646f 7562 6c65 2a3e 6469 7273     <double*>dirs
-0002b600: 2e64 6174 612c 0a20 2020 2020 2020 2020  .data,.         
+0002b5e0: 2020 2020 2020 2020 2020 2020 2020 203c                 <
+0002b5f0: 646f 7562 6c65 2a3e 6469 7273 2e64 6174  double*>dirs.dat
+0002b600: 612c 0a20 2020 2020 2020 2020 2020 2020  a,.             
 0002b610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b620: 2020 2020 2020 2020 2020 2020 3c64 6f75              <dou
-0002b630: 626c 652a 3e6f 7269 732e 6461 7461 2c0a  ble*>oris.data,.
+0002b620: 2020 2020 2020 2020 3c64 6f75 626c 652a          <double*
+0002b630: 3e6f 7269 732e 6461 7461 2c0a 2020 2020  >oris.data,.    
 0002b640: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002b650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b660: 2020 2020 203c 646f 7562 6c65 2a3e 6369       <double*>ci
-0002b670: 7263 6c65 5f72 6164 6975 732e 6461 7461  rcle_radius.data
-0002b680: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0002b660: 203c 646f 7562 6c65 2a3e 6369 7263 6c65   <double*>circle
+0002b670: 5f72 6164 6975 732e 6461 7461 2c0a 2020  _radius.data,.  
+0002b680: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002b690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b6a0: 2020 2020 2020 203c 646f 7562 6c65 2a3e         <double*>
-0002b6b0: 6369 7263 6c65 5f7a 2e64 6174 612c 0a20  circle_z.data,. 
+0002b6a0: 2020 203c 646f 7562 6c65 2a3e 6369 7263     <double*>circ
+0002b6b0: 6c65 5f7a 2e64 6174 612c 0a20 2020 2020  le_z.data,.     
 0002b6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002b6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b6e0: 2020 2020 3c64 6f75 626c 652a 3e6e 6f72      <double*>nor
-0002b6f0: 6d5f 6469 722e 6461 7461 2c0a 2020 2020  m_dir.data,.    
+0002b6e0: 3c64 6f75 626c 652a 3e6e 6f72 6d5f 6469  <double*>norm_di
+0002b6f0: 722e 6461 7461 2c0a 2020 2020 2020 2020  r.data,.        
 0002b700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b720: 2072 6573 2c20 6e75 6d5f 7468 7265 6164   res, num_thread
-0002b730: 7329 0a20 2020 2072 6574 7572 6e20 6e70  s).    return np
-0002b740: 2e61 7361 7272 6179 2872 6573 2c20 6474  .asarray(res, dt
-0002b750: 7970 653d 626f 6f6c 292e 7265 7368 6170  ype=bool).reshap
-0002b760: 6528 6e6c 6f73 2c20 6e63 6972 636c 6573  e(nlos, ncircles
-0002b770: 290a 0a23 203d 3d3d 3d3d 3d3d 3d3d 3d3d  )..# ===========
+0002b710: 2020 2020 2020 2020 2020 2020 2072 6573               res
+0002b720: 2c20 6e75 6d5f 7468 7265 6164 7329 0a20  , num_threads). 
+0002b730: 2020 2072 6574 7572 6e20 6e70 2e61 7361     return np.asa
+0002b740: 7272 6179 2872 6573 2c20 6474 7970 653d  rray(res, dtype=
+0002b750: 626f 6f6c 292e 7265 7368 6170 6528 6e6c  bool).reshape(nl
+0002b760: 6f73 2c20 6e63 6972 636c 6573 290a 0a23  os, ncircles)..#
+0002b770: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
 0002b780: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002b790: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002b7a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002b7b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002b7c0: 3d3d 3d0a 230a 2320 2020 2020 2020 2020  ===.#.#         
-0002b7d0: 2020 2020 2020 2020 2020 2020 2020 4449                DI
-0002b7e0: 5354 414e 4345 2042 4554 5745 454e 204c  STANCE BETWEEN L
-0002b7f0: 4f53 2041 4e44 2045 5854 2d50 4f4c 590a  OS AND EXT-POLY.
-0002b800: 230a 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  #.# ============
+0002b7b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
+0002b7c0: 230a 2320 2020 2020 2020 2020 2020 2020  #.#             
+0002b7d0: 2020 2020 2020 2020 2020 4449 5354 414e            DISTAN
+0002b7e0: 4345 2042 4554 5745 454e 204c 4f53 2041  CE BETWEEN LOS A
+0002b7f0: 4e44 2045 5854 2d50 4f4c 590a 230a 2320  ND EXT-POLY.#.# 
+0002b800: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002b810: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002b820: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002b830: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002b840: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002b850: 3d3d 0a64 6566 2063 6f6d 705f 6469 7374  ==.def comp_dist
-0002b860: 5f6c 6f73 5f76 706f 6c79 2864 6f75 626c  _los_vpoly(doubl
-0002b870: 655b 3a2c 203a 3a31 5d20 7261 795f 6f72  e[:, ::1] ray_or
-0002b880: 6967 2c0a 2020 2020 2020 2020 2020 2020  ig,.            
-0002b890: 2020 2020 2020 2020 2020 2020 646f 7562              doub
-0002b8a0: 6c65 5b3a 2c20 3a3a 315d 2072 6179 5f76  le[:, ::1] ray_v
-0002b8b0: 6469 722c 0a20 2020 2020 2020 2020 2020  dir,.           
-0002b8c0: 2020 2020 2020 2020 2020 2020 2064 6f75               dou
-0002b8d0: 626c 655b 3a2c 203a 3a31 5d20 7665 735f  ble[:, ::1] ves_
-0002b8e0: 706f 6c79 2c0a 2020 2020 2020 2020 2020  poly,.          
-0002b8f0: 2020 2020 2020 2020 2020 2020 2020 646f                do
-0002b900: 7562 6c65 2064 6973 635f 7374 6570 3d30  uble disc_step=0
-0002b910: 2e31 2c0a 2020 2020 2020 2020 2020 2020  .1,.            
-0002b920: 2020 2020 2020 2020 2020 2020 646f 7562              doub
-0002b930: 6c65 2065 7073 5f75 7a3d 5f53 4d41 4c4c  le eps_uz=_SMALL
-0002b940: 2c20 646f 7562 6c65 2065 7073 5f61 3d5f  , double eps_a=_
-0002b950: 5653 4d41 4c4c 2c0a 2020 2020 2020 2020  VSMALL,.        
-0002b960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b970: 646f 7562 6c65 2065 7073 5f76 7a3d 5f56  double eps_vz=_V
-0002b980: 534d 414c 4c2c 2064 6f75 626c 6520 6570  SMALL, double ep
-0002b990: 735f 623d 5f56 534d 414c 4c2c 0a20 2020  s_b=_VSMALL,.   
+0002b840: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a64  ==============.d
+0002b850: 6566 2063 6f6d 705f 6469 7374 5f6c 6f73  ef comp_dist_los
+0002b860: 5f76 706f 6c79 2864 6f75 626c 655b 3a2c  _vpoly(double[:,
+0002b870: 203a 3a31 5d20 7261 795f 6f72 6967 2c0a   ::1] ray_orig,.
+0002b880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002b890: 2020 2020 2020 2020 646f 7562 6c65 5b3a          double[:
+0002b8a0: 2c20 3a3a 315d 2072 6179 5f76 6469 722c  , ::1] ray_vdir,
+0002b8b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002b8c0: 2020 2020 2020 2020 2064 6f75 626c 655b           double[
+0002b8d0: 3a2c 203a 3a31 5d20 7665 735f 706f 6c79  :, ::1] ves_poly
+0002b8e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0002b8f0: 2020 2020 2020 2020 2020 646f 7562 6c65            double
+0002b900: 2064 6973 635f 7374 6570 3d30 2e31 2c0a   disc_step=0.1,.
+0002b910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002b920: 2020 2020 2020 2020 646f 7562 6c65 2065          double e
+0002b930: 7073 5f75 7a3d 5f53 4d41 4c4c 2c20 646f  ps_uz=_SMALL, do
+0002b940: 7562 6c65 2065 7073 5f61 3d5f 5653 4d41  uble eps_a=_VSMA
+0002b950: 4c4c 2c0a 2020 2020 2020 2020 2020 2020  LL,.            
+0002b960: 2020 2020 2020 2020 2020 2020 646f 7562              doub
+0002b970: 6c65 2065 7073 5f76 7a3d 5f56 534d 414c  le eps_vz=_VSMAL
+0002b980: 4c2c 2064 6f75 626c 6520 6570 735f 623d  L, double eps_b=
+0002b990: 5f56 534d 414c 4c2c 0a20 2020 2020 2020  _VSMALL,.       
 0002b9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b9b0: 2020 2020 2064 6f75 626c 6520 6570 735f       double eps_
-0002b9c0: 706c 616e 653d 5f56 534d 414c 4c2c 2073  plane=_VSMALL, s
-0002b9d0: 7472 2076 6573 5f74 7970 653d 2754 6f72  tr ves_type='Tor
-0002b9e0: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
-0002b9f0: 2020 2020 2020 2020 2020 2069 6e74 206e             int n
-0002ba00: 756d 5f74 6872 6561 6473 3d31 362c 2062  um_threads=16, b
-0002ba10: 696e 7420 6465 6275 673d 4661 6c73 652c  int debug=False,
-0002ba20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0002ba30: 2020 2020 2020 2020 2069 6e74 2064 6562           int deb
-0002ba40: 7567 5f6e 6c6f 733d 2d31 293a 0a20 2020  ug_nlos=-1):.   
-0002ba50: 2022 2222 0a20 2020 2054 6869 7320 6675   """.    This fu
-0002ba60: 6e63 7469 6f6e 2063 6f6d 7075 7465 7320  nction computes 
-0002ba70: 7468 6520 6469 7374 616e 6365 2028 616e  the distance (an
-0002ba80: 6420 7468 6520 6173 736f 6369 6174 6564  d the associated
-0002ba90: 206b 2920 6265 7477 6565 6e20 6e6c 6f73   k) between nlos
-0002baa0: 0a20 2020 2052 6179 7320 286f 7220 4c4f  .    Rays (or LO
-0002bab0: 5329 2061 6e64 2061 6e20 6049 4e60 2073  S) and an `IN` s
-0002bac0: 7472 7563 7475 7265 2028 6120 706f 6c79  tructure (a poly
-0002bad0: 676f 6e20 6578 7472 7564 6564 2061 726f  gon extruded aro
-0002bae0: 756e 6420 7468 6520 6178 6973 0a20 2020  und the axis.   
-0002baf0: 2028 302c 302c 3129 2c20 6567 2e20 6120   (0,0,1), eg. a 
-0002bb00: 666c 7578 2073 7572 6661 6365 292e 0a20  flux surface).. 
-0002bb10: 2020 2046 6f72 206d 6f72 6520 6465 7461     For more deta
-0002bb20: 696c 7320 6f6e 2074 6865 2061 6c67 6f72  ils on the algor
-0002bb30: 6974 686d 2070 6c65 6173 6520 7365 6520  ithm please see 
-0002bb40: 5044 463a 203c 6e61 6d65 5f6f 665f 7064  PDF: <name_of_pd
-0002bb50: 663e 2e70 6466 2023 544f 444f 0a0a 2020  f>.pdf #TODO..  
-0002bb60: 2020 5061 7261 6d73 0a20 2020 203d 3d3d    Params.    ===
-0002bb70: 3d3d 3d0a 2020 2020 2020 2020 7261 795f  ===.        ray_
-0002bb80: 6f72 6967 203a 2028 332c 206e 6c6f 7329  orig : (3, nlos)
-0002bb90: 2064 6f75 626c 6520 6172 7261 790a 2020   double array.  
-0002bba0: 2020 2020 2020 2020 204c 4f53 206f 7269           LOS ori
-0002bbb0: 6769 6e20 706f 696e 7473 2063 6f6f 7264  gin points coord
-0002bbc0: 696e 6174 6573 0a20 2020 2020 2020 2072  inates.        r
-0002bbd0: 6179 5f76 6469 7220 3a20 2833 2c20 6e6c  ay_vdir : (3, nl
-0002bbe0: 6f73 2920 646f 7562 6c65 2061 7272 6179  os) double array
-0002bbf0: 0a20 2020 2020 2020 2020 2020 4c4f 5320  .           LOS 
-0002bc00: 6e6f 726d 616c 697a 6564 2064 6972 6563  normalized direc
-0002bc10: 7469 6f6e 2076 6563 746f 720a 2020 2020  tion vector.    
-0002bc20: 2020 2020 7665 735f 706f 6c79 203a 2028      ves_poly : (
-0002bc30: 322c 206e 756d 5f76 6572 7465 7829 2064  2, num_vertex) d
-0002bc40: 6f75 626c 6520 6172 7261 790a 2020 2020  ouble array.    
-0002bc50: 2020 2020 2020 2043 6f6f 7264 696e 6174         Coordinat
-0002bc60: 6573 206f 6620 7468 6520 7665 7274 6963  es of the vertic
-0002bc70: 6573 206f 6620 7468 6520 506f 6c79 676f  es of the Polygo
-0002bc80: 6e20 6465 6669 6e69 6e67 2074 6865 2032  n defining the 2
-0002bc90: 4420 706f 6c6f 6964 616c 0a20 2020 2020  D poloidal.     
-0002bca0: 2020 2020 2020 6375 7420 6f66 2074 6865        cut of the
-0002bcb0: 2056 6573 7365 6c0a 2020 2020 2020 2020   Vessel.        
-0002bcc0: 6570 735f 3c76 616c 3e20 3a20 646f 7562  eps_<val> : doub
-0002bcd0: 6c65 0a20 2020 2020 2020 2020 2020 536d  le.           Sm
-0002bce0: 616c 6c20 7661 6c75 652c 2061 6363 6570  all value, accep
-0002bcf0: 7461 6e63 6520 6f66 2065 7272 6f72 0a20  tance of error. 
-0002bd00: 2020 2052 6574 7572 6e73 0a20 2020 203d     Returns.    =
-0002bd10: 3d3d 3d3d 3d3d 0a20 2020 2020 2020 206b  ======.        k
-0002bd20: 6d69 6e5f 7670 6f6c 7920 3a20 286e 6c6f  min_vpoly : (nlo
-0002bd30: 7329 2064 6f75 626c 6520 6172 7261 790a  s) double array.
-0002bd40: 2020 2020 2020 2020 2020 2020 4f66 2074              Of t
-0002bd50: 6865 2066 6f72 6d20 5b6b 5f30 2c20 6b5f  he form [k_0, k_
-0002bd60: 312c 202e 2e2e 2c20 6b5f 6e5d 2c20 7768  1, ..., k_n], wh
-0002bd70: 6572 6520 6b5f 6920 6973 2074 6865 2063  ere k_i is the c
-0002bd80: 6f65 6666 6963 6965 6e74 0a20 2020 2020  oefficient.     
-0002bd90: 2020 2020 2020 2073 7563 6820 7468 6174         such that
-0002bda0: 2074 6865 2069 2d74 6820 7261 7920 284c   the i-th ray (L
-0002bdb0: 4f53 2920 6973 2063 6c6f 7365 7374 2074  OS) is closest t
-0002bdc0: 6f20 7468 6520 6578 7472 7564 6564 2070  o the extruded p
-0002bdd0: 6f6c 7967 6f6e 0a20 2020 2020 2020 2020  olygon.         
-0002bde0: 2020 2061 7420 7468 6520 706f 696e 7420     at the point 
-0002bdf0: 505f 6920 3d20 6f72 6967 5b69 5d20 2b20  P_i = orig[i] + 
-0002be00: 6b6d 696e 5b69 5d20 2a20 7664 6972 5b69  kmin[i] * vdir[i
-0002be10: 5d0a 2020 2020 2020 2020 6469 7374 5f76  ].        dist_v
-0002be20: 706f 6c79 203a 2028 6e6c 6f73 2920 646f  poly : (nlos) do
-0002be30: 7562 6c65 2061 7272 6179 0a20 2020 2020  uble array.     
-0002be40: 2020 2020 2020 2060 6469 7374 616e 6365         `distance
-0002be50: 5b69 5d60 2069 7320 7468 6520 6469 7374  [i]` is the dist
-0002be60: 616e 6365 2066 726f 6d20 505f 6920 746f  ance from P_i to
-0002be70: 2074 6865 2065 7874 7275 6465 6420 706f   the extruded po
-0002be80: 6c79 676f 6e2e 0a20 2020 202d 2d2d 0a20  lygon..    ---. 
-0002be90: 2020 2054 6869 7320 6973 2074 6865 2050     This is the P
-0002bea0: 5954 484f 4e20 6675 6e63 7469 6f6e 2c20  YTHON function, 
-0002beb0: 7573 6520 6f6e 6c79 2069 6620 796f 7520  use only if you 
-0002bec0: 6e65 6564 2074 6869 7320 636f 6d70 7574  need this comput
-0002bed0: 6174 696f 6e20 6672 6f6d 0a20 2020 2050  ation from.    P
-0002bee0: 7974 686f 6e2c 2069 6620 796f 7520 6e65  ython, if you ne
-0002bef0: 6564 2069 7420 6672 6f6d 2063 7974 686f  ed it from cytho
-0002bf00: 6e2c 2075 7365 2060 7369 6d70 6c65 5f64  n, use `simple_d
-0002bf10: 6973 745f 6c6f 735f 7670 6f6c 795f 636f  ist_los_vpoly_co
-0002bf20: 7265 600a 2020 2020 2222 220a 2020 2020  re`.    """.    
-0002bf30: 6364 6566 2069 6e74 206e 7074 735f 706f  cdef int npts_po
-0002bf40: 6c79 203d 2076 6573 5f70 6f6c 792e 7368  ly = ves_poly.sh
-0002bf50: 6170 655b 315d 0a20 2020 2063 6465 6620  ape[1].    cdef 
-0002bf60: 696e 7420 6e6c 6f73 203d 2072 6179 5f6f  int nlos = ray_o
-0002bf70: 7269 672e 7368 6170 655b 315d 0a20 2020  rig.shape[1].   
-0002bf80: 2063 6465 6620 696e 7420 6969 2c20 696e   cdef int ii, in
-0002bf90: 645f 7665 7274 2c20 696e 645f 6c6f 730a  d_vert, ind_los.
-0002bfa0: 2020 2020 6364 6566 2064 6f75 626c 652a      cdef double*
-0002bfb0: 2072 6573 5f6c 6f63 203d 204e 554c 4c0a   res_loc = NULL.
-0002bfc0: 2020 2020 6364 6566 2064 6f75 626c 652a      cdef double*
-0002bfd0: 206c 6f63 5f6f 7267 203d 204e 554c 4c0a   loc_org = NULL.
-0002bfe0: 2020 2020 6364 6566 2064 6f75 626c 652a      cdef double*
-0002bff0: 206c 6f63 5f64 6972 203d 204e 554c 4c0a   loc_dir = NULL.
-0002c000: 2020 2020 6364 6566 2064 6f75 626c 6520      cdef double 
-0002c010: 6372 6974 322c 2069 6e76 757a 2c20 2064  crit2, invuz,  d
-0002c020: 7061 7232 2c20 7570 6172 322c 2075 7073  par2, upar2, ups
-0002c030: 6361 4470 0a20 2020 2063 6465 6620 646f  caDp.    cdef do
-0002c040: 7562 6c65 2063 7269 7432 5f62 6173 6520  uble crit2_base 
-0002c050: 3d20 6570 735f 757a 202a 2065 7073 5f75  = eps_uz * eps_u
-0002c060: 7a20 2f34 3030 2e0a 2020 2020 6364 6566  z /400..    cdef
-0002c070: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
-0002c080: 6c65 2c6e 6469 6d3d 315d 2064 6973 7420  le,ndim=1] dist 
-0002c090: 3d20 6e70 2e65 6d70 7479 2828 6e6c 6f73  = np.empty((nlos
-0002c0a0: 2c29 2c64 7479 7065 3d66 6c6f 6174 290a  ,),dtype=float).
-0002c0b0: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-0002c0c0: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
-0002c0d0: 315d 206b 6d69 6e20 3d20 6e70 2e65 6d70  1] kmin = np.emp
-0002c0e0: 7479 2828 6e6c 6f73 2c29 2c64 7479 7065  ty((nlos,),dtype
-0002c0f0: 3d66 6c6f 6174 290a 2020 2020 6364 6566  =float).    cdef
-0002c100: 2064 6f75 626c 652a 206c 6973 745f 7670   double* list_vp
-0002c110: 6f6c 795f 7820 3d20 4e55 4c4c 0a20 2020  oly_x = NULL.   
-0002c120: 2063 6465 6620 646f 7562 6c65 2a20 6c69   cdef double* li
-0002c130: 7374 5f76 706f 6c79 5f79 203d 204e 554c  st_vpoly_y = NUL
-0002c140: 4c0a 2020 2020 6364 6566 2069 6e74 206e  L.    cdef int n
-0002c150: 6577 5f6e 7074 735f 706f 6c79 0a20 2020  ew_npts_poly.   
-0002c160: 2023 203d 3d20 4469 7363 7265 7469 7a69   # == Discretizi
-0002c170: 6e67 2076 706f 6c79 7320 3d3d 3d3d 3d3d  ng vpolys ======
+0002b9b0: 2064 6f75 626c 6520 6570 735f 706c 616e   double eps_plan
+0002b9c0: 653d 5f56 534d 414c 4c2c 2073 7472 2076  e=_VSMALL, str v
+0002b9d0: 6573 5f74 7970 653d 2754 6f72 272c 0a20  es_type='Tor',. 
+0002b9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002b9f0: 2020 2020 2020 2069 6e74 206e 756d 5f74         int num_t
+0002ba00: 6872 6561 6473 3d31 362c 2062 696e 7420  hreads=16, bint 
+0002ba10: 6465 6275 673d 4661 6c73 652c 0a20 2020  debug=False,.   
+0002ba20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002ba30: 2020 2020 2069 6e74 2064 6562 7567 5f6e       int debug_n
+0002ba40: 6c6f 733d 2d31 293a 0a20 2020 2022 2222  los=-1):.    """
+0002ba50: 0a20 2020 2054 6869 7320 6675 6e63 7469  .    This functi
+0002ba60: 6f6e 2063 6f6d 7075 7465 7320 7468 6520  on computes the 
+0002ba70: 6469 7374 616e 6365 2028 616e 6420 7468  distance (and th
+0002ba80: 6520 6173 736f 6369 6174 6564 206b 2920  e associated k) 
+0002ba90: 6265 7477 6565 6e20 6e6c 6f73 0a20 2020  between nlos.   
+0002baa0: 2052 6179 7320 286f 7220 4c4f 5329 2061   Rays (or LOS) a
+0002bab0: 6e64 2061 6e20 6049 4e60 2073 7472 7563  nd an `IN` struc
+0002bac0: 7475 7265 2028 6120 706f 6c79 676f 6e20  ture (a polygon 
+0002bad0: 6578 7472 7564 6564 2061 726f 756e 6420  extruded around 
+0002bae0: 7468 6520 6178 6973 0a20 2020 2028 302c  the axis.    (0,
+0002baf0: 302c 3129 2c20 6567 2e20 6120 666c 7578  0,1), eg. a flux
+0002bb00: 2073 7572 6661 6365 292e 0a20 2020 2046   surface)..    F
+0002bb10: 6f72 206d 6f72 6520 6465 7461 696c 7320  or more details 
+0002bb20: 6f6e 2074 6865 2061 6c67 6f72 6974 686d  on the algorithm
+0002bb30: 2070 6c65 6173 6520 7365 6520 5044 463a   please see PDF:
+0002bb40: 203c 6e61 6d65 5f6f 665f 7064 663e 2e70   <name_of_pdf>.p
+0002bb50: 6466 2023 544f 444f 0a0a 2020 2020 5061  df #TODO..    Pa
+0002bb60: 7261 6d73 0a20 2020 203d 3d3d 3d3d 3d0a  rams.    ======.
+0002bb70: 2020 2020 2020 2020 7261 795f 6f72 6967          ray_orig
+0002bb80: 203a 2028 332c 206e 6c6f 7329 2064 6f75   : (3, nlos) dou
+0002bb90: 626c 6520 6172 7261 790a 2020 2020 2020  ble array.      
+0002bba0: 2020 2020 204c 4f53 206f 7269 6769 6e20       LOS origin 
+0002bbb0: 706f 696e 7473 2063 6f6f 7264 696e 6174  points coordinat
+0002bbc0: 6573 0a20 2020 2020 2020 2072 6179 5f76  es.        ray_v
+0002bbd0: 6469 7220 3a20 2833 2c20 6e6c 6f73 2920  dir : (3, nlos) 
+0002bbe0: 646f 7562 6c65 2061 7272 6179 0a20 2020  double array.   
+0002bbf0: 2020 2020 2020 2020 4c4f 5320 6e6f 726d          LOS norm
+0002bc00: 616c 697a 6564 2064 6972 6563 7469 6f6e  alized direction
+0002bc10: 2076 6563 746f 720a 2020 2020 2020 2020   vector.        
+0002bc20: 7665 735f 706f 6c79 203a 2028 322c 206e  ves_poly : (2, n
+0002bc30: 756d 5f76 6572 7465 7829 2064 6f75 626c  um_vertex) doubl
+0002bc40: 6520 6172 7261 790a 2020 2020 2020 2020  e array.        
+0002bc50: 2020 2043 6f6f 7264 696e 6174 6573 206f     Coordinates o
+0002bc60: 6620 7468 6520 7665 7274 6963 6573 206f  f the vertices o
+0002bc70: 6620 7468 6520 506f 6c79 676f 6e20 6465  f the Polygon de
+0002bc80: 6669 6e69 6e67 2074 6865 2032 4420 706f  fining the 2D po
+0002bc90: 6c6f 6964 616c 0a20 2020 2020 2020 2020  loidal.         
+0002bca0: 2020 6375 7420 6f66 2074 6865 2056 6573    cut of the Ves
+0002bcb0: 7365 6c0a 2020 2020 2020 2020 6570 735f  sel.        eps_
+0002bcc0: 3c76 616c 3e20 3a20 646f 7562 6c65 0a20  <val> : double. 
+0002bcd0: 2020 2020 2020 2020 2020 536d 616c 6c20            Small 
+0002bce0: 7661 6c75 652c 2061 6363 6570 7461 6e63  value, acceptanc
+0002bcf0: 6520 6f66 2065 7272 6f72 0a20 2020 2052  e of error.    R
+0002bd00: 6574 7572 6e73 0a20 2020 203d 3d3d 3d3d  eturns.    =====
+0002bd10: 3d3d 0a20 2020 2020 2020 206b 6d69 6e5f  ==.        kmin_
+0002bd20: 7670 6f6c 7920 3a20 286e 6c6f 7329 2064  vpoly : (nlos) d
+0002bd30: 6f75 626c 6520 6172 7261 790a 2020 2020  ouble array.    
+0002bd40: 2020 2020 2020 2020 4f66 2074 6865 2066          Of the f
+0002bd50: 6f72 6d20 5b6b 5f30 2c20 6b5f 312c 202e  orm [k_0, k_1, .
+0002bd60: 2e2e 2c20 6b5f 6e5d 2c20 7768 6572 6520  .., k_n], where 
+0002bd70: 6b5f 6920 6973 2074 6865 2063 6f65 6666  k_i is the coeff
+0002bd80: 6963 6965 6e74 0a20 2020 2020 2020 2020  icient.         
+0002bd90: 2020 2073 7563 6820 7468 6174 2074 6865     such that the
+0002bda0: 2069 2d74 6820 7261 7920 284c 4f53 2920   i-th ray (LOS) 
+0002bdb0: 6973 2063 6c6f 7365 7374 2074 6f20 7468  is closest to th
+0002bdc0: 6520 6578 7472 7564 6564 2070 6f6c 7967  e extruded polyg
+0002bdd0: 6f6e 0a20 2020 2020 2020 2020 2020 2061  on.            a
+0002bde0: 7420 7468 6520 706f 696e 7420 505f 6920  t the point P_i 
+0002bdf0: 3d20 6f72 6967 5b69 5d20 2b20 6b6d 696e  = orig[i] + kmin
+0002be00: 5b69 5d20 2a20 7664 6972 5b69 5d0a 2020  [i] * vdir[i].  
+0002be10: 2020 2020 2020 6469 7374 5f76 706f 6c79        dist_vpoly
+0002be20: 203a 2028 6e6c 6f73 2920 646f 7562 6c65   : (nlos) double
+0002be30: 2061 7272 6179 0a20 2020 2020 2020 2020   array.         
+0002be40: 2020 2060 6469 7374 616e 6365 5b69 5d60     `distance[i]`
+0002be50: 2069 7320 7468 6520 6469 7374 616e 6365   is the distance
+0002be60: 2066 726f 6d20 505f 6920 746f 2074 6865   from P_i to the
+0002be70: 2065 7874 7275 6465 6420 706f 6c79 676f   extruded polygo
+0002be80: 6e2e 0a20 2020 202d 2d2d 0a20 2020 2054  n..    ---.    T
+0002be90: 6869 7320 6973 2074 6865 2050 5954 484f  his is the PYTHO
+0002bea0: 4e20 6675 6e63 7469 6f6e 2c20 7573 6520  N function, use 
+0002beb0: 6f6e 6c79 2069 6620 796f 7520 6e65 6564  only if you need
+0002bec0: 2074 6869 7320 636f 6d70 7574 6174 696f   this computatio
+0002bed0: 6e20 6672 6f6d 0a20 2020 2050 7974 686f  n from.    Pytho
+0002bee0: 6e2c 2069 6620 796f 7520 6e65 6564 2069  n, if you need i
+0002bef0: 7420 6672 6f6d 2063 7974 686f 6e2c 2075  t from cython, u
+0002bf00: 7365 2060 7369 6d70 6c65 5f64 6973 745f  se `simple_dist_
+0002bf10: 6c6f 735f 7670 6f6c 795f 636f 7265 600a  los_vpoly_core`.
+0002bf20: 2020 2020 2222 220a 2020 2020 6364 6566      """.    cdef
+0002bf30: 2069 6e74 206e 7074 735f 706f 6c79 203d   int npts_poly =
+0002bf40: 2076 6573 5f70 6f6c 792e 7368 6170 655b   ves_poly.shape[
+0002bf50: 315d 0a20 2020 2063 6465 6620 696e 7420  1].    cdef int 
+0002bf60: 6e6c 6f73 203d 2072 6179 5f6f 7269 672e  nlos = ray_orig.
+0002bf70: 7368 6170 655b 315d 0a20 2020 2063 6465  shape[1].    cde
+0002bf80: 6620 696e 7420 6969 2c20 696e 645f 7665  f int ii, ind_ve
+0002bf90: 7274 2c20 696e 645f 6c6f 730a 2020 2020  rt, ind_los.    
+0002bfa0: 6364 6566 2064 6f75 626c 652a 2072 6573  cdef double* res
+0002bfb0: 5f6c 6f63 203d 204e 554c 4c0a 2020 2020  _loc = NULL.    
+0002bfc0: 6364 6566 2064 6f75 626c 652a 206c 6f63  cdef double* loc
+0002bfd0: 5f6f 7267 203d 204e 554c 4c0a 2020 2020  _org = NULL.    
+0002bfe0: 6364 6566 2064 6f75 626c 652a 206c 6f63  cdef double* loc
+0002bff0: 5f64 6972 203d 204e 554c 4c0a 2020 2020  _dir = NULL.    
+0002c000: 6364 6566 2064 6f75 626c 6520 6372 6974  cdef double crit
+0002c010: 322c 2069 6e76 757a 2c20 2064 7061 7232  2, invuz,  dpar2
+0002c020: 2c20 7570 6172 322c 2075 7073 6361 4470  , upar2, upscaDp
+0002c030: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+0002c040: 2063 7269 7432 5f62 6173 6520 3d20 6570   crit2_base = ep
+0002c050: 735f 757a 202a 2065 7073 5f75 7a20 2f34  s_uz * eps_uz /4
+0002c060: 3030 2e0a 2020 2020 6364 6566 206e 702e  00..    cdef np.
+0002c070: 6e64 6172 7261 795b 646f 7562 6c65 2c6e  ndarray[double,n
+0002c080: 6469 6d3d 315d 2064 6973 7420 3d20 6e70  dim=1] dist = np
+0002c090: 2e65 6d70 7479 2828 6e6c 6f73 2c29 2c64  .empty((nlos,),d
+0002c0a0: 7479 7065 3d66 6c6f 6174 290a 2020 2020  type=float).    
+0002c0b0: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+0002c0c0: 646f 7562 6c65 2c6e 6469 6d3d 315d 206b  double,ndim=1] k
+0002c0d0: 6d69 6e20 3d20 6e70 2e65 6d70 7479 2828  min = np.empty((
+0002c0e0: 6e6c 6f73 2c29 2c64 7479 7065 3d66 6c6f  nlos,),dtype=flo
+0002c0f0: 6174 290a 2020 2020 6364 6566 2064 6f75  at).    cdef dou
+0002c100: 626c 652a 206c 6973 745f 7670 6f6c 795f  ble* list_vpoly_
+0002c110: 7820 3d20 4e55 4c4c 0a20 2020 2063 6465  x = NULL.    cde
+0002c120: 6620 646f 7562 6c65 2a20 6c69 7374 5f76  f double* list_v
+0002c130: 706f 6c79 5f79 203d 204e 554c 4c0a 2020  poly_y = NULL.  
+0002c140: 2020 6364 6566 2069 6e74 206e 6577 5f6e    cdef int new_n
+0002c150: 7074 735f 706f 6c79 0a20 2020 2023 203d  pts_poly.    # =
+0002c160: 3d20 4469 7363 7265 7469 7a69 6e67 2076  = Discretizing v
+0002c170: 706f 6c79 7320 3d3d 3d3d 3d3d 3d3d 3d3d  polys ==========
 0002c180: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002c190: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002c1a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020  =============.  
-0002c1b0: 2020 5f73 742e 7369 6d70 6c65 5f64 6973    _st.simple_dis
-0002c1c0: 6372 6574 697a 655f 7670 6f6c 795f 636f  cretize_vpoly_co
-0002c1d0: 7265 2876 6573 5f70 6f6c 792c 0a20 2020  re(ves_poly,.   
+0002c1a0: 3d3d 3d3d 3d3d 3d3d 3d0a 2020 2020 5f73  =========.    _s
+0002c1b0: 742e 7369 6d70 6c65 5f64 6973 6372 6574  t.simple_discret
+0002c1c0: 697a 655f 7670 6f6c 795f 636f 7265 2876  ize_vpoly_core(v
+0002c1d0: 6573 5f70 6f6c 792c 0a20 2020 2020 2020  es_poly,.       
 0002c1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c200: 206e 7074 735f 706f 6c79 2c0a 2020 2020   npts_poly,.    
+0002c1f0: 2020 2020 2020 2020 2020 2020 206e 7074               npt
+0002c200: 735f 706f 6c79 2c0a 2020 2020 2020 2020  s_poly,.        
 0002c210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c230: 6469 7363 5f73 7465 702c 2023 2064 6973  disc_step, # dis
-0002c240: 6372 6574 697a 6174 696f 6e20 7374 6570  cretization step
-0002c250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002c220: 2020 2020 2020 2020 2020 2020 6469 7363              disc
+0002c230: 5f73 7465 702c 2023 2064 6973 6372 6574  _step, # discret
+0002c240: 697a 6174 696f 6e20 7374 6570 0a20 2020  ization step.   
+0002c250: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c270: 2020 2020 2026 6c69 7374 5f76 706f 6c79       &list_vpoly
-0002c280: 5f78 2c0a 2020 2020 2020 2020 2020 2020  _x,.            
+0002c270: 2026 6c69 7374 5f76 706f 6c79 5f78 2c0a   &list_vpoly_x,.
+0002c280: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c2a0: 2020 2020 2020 2020 266c 6973 745f 7670          &list_vp
-0002c2b0: 6f6c 795f 792c 0a20 2020 2020 2020 2020  oly_y,.         
+0002c2a0: 2020 2020 266c 6973 745f 7670 6f6c 795f      &list_vpoly_
+0002c2b0: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
 0002c2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c2d0: 2020 2020 2020 2020 2020 2026 6e65 775f             &new_
-0002c2e0: 6e70 7473 5f70 6f6c 792c 0a20 2020 2020  npts_poly,.     
+0002c2d0: 2020 2020 2020 2026 6e65 775f 6e70 7473         &new_npts
+0002c2e0: 5f70 6f6c 792c 0a20 2020 2020 2020 2020  _poly,.         
 0002c2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c300: 2020 2020 2020 2020 2020 2020 2020 2030                 0
-0002c310: 2c20 2320 6d6f 6465 203d 2061 6273 6f6c  , # mode = absol
-0002c320: 7574 650a 2020 2020 2020 2020 2020 2020  ute.            
+0002c300: 2020 2020 2020 2020 2020 2030 2c20 2320             0, # 
+0002c310: 6d6f 6465 203d 2061 6273 6f6c 7574 650a  mode = absolute.
+0002c320: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c340: 2020 2020 2020 2020 5f56 534d 414c 4c29          _VSMALL)
-0002c350: 0a20 2020 2023 203d 3d20 4465 6669 6e69  .    # == Defini
-0002c360: 6e67 2070 6172 616c 6c65 6c20 7061 7274  ng parallel part
-0002c370: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+0002c340: 2020 2020 5f56 534d 414c 4c29 0a20 2020      _VSMALL).   
+0002c350: 2023 203d 3d20 4465 6669 6e69 6e67 2070   # == Defining p
+0002c360: 6172 616c 6c65 6c20 7061 7274 203d 3d3d  arallel part ===
+0002c370: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002c380: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002c390: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002c3a0: 3d0a 2020 2020 7769 7468 206e 6f67 696c  =.    with nogil
-0002c3b0: 2c20 7061 7261 6c6c 656c 286e 756d 5f74  , parallel(num_t
-0002c3c0: 6872 6561 6473 3d6e 756d 5f74 6872 6561  hreads=num_threa
-0002c3d0: 6473 293a 0a20 2020 2020 2020 2023 2057  ds):.        # W
-0002c3e0: 6520 7573 6520 6c6f 6361 6c20 6172 7261  e use local arra
-0002c3f0: 7973 2066 6f72 2065 6163 6820 7468 7265  ys for each thre
-0002c400: 6164 2073 6f2e 2e2e 0a20 2020 2020 2020  ad so....       
-0002c410: 206c 6f63 5f6f 7267 2020 203d 203c 646f   loc_org   = <do
-0002c420: 7562 6c65 202a 3e20 6d61 6c6c 6f63 2873  uble *> malloc(s
-0002c430: 697a 656f 6628 646f 7562 6c65 2920 2a20  izeof(double) * 
-0002c440: 3329 0a20 2020 2020 2020 206c 6f63 5f64  3).        loc_d
-0002c450: 6972 2020 203d 203c 646f 7562 6c65 202a  ir   = <double *
-0002c460: 3e20 6d61 6c6c 6f63 2873 697a 656f 6628  > malloc(sizeof(
-0002c470: 646f 7562 6c65 2920 2a20 3329 0a20 2020  double) * 3).   
-0002c480: 2020 2020 2072 6573 5f6c 6f63 203d 203c       res_loc = <
-0002c490: 646f 7562 6c65 202a 3e20 6d61 6c6c 6f63  double *> malloc
-0002c4a0: 2832 2a73 697a 656f 6628 646f 7562 6c65  (2*sizeof(double
-0002c4b0: 2929 0a20 2020 2020 2020 2023 203d 3d20  )).        # == 
-0002c4c0: 5468 6520 7061 7261 6c6c 656c 697a 6174  The parallelizat
-0002c4d0: 696f 6e20 6f76 6572 2074 6865 204c 4f53  ion over the LOS
-0002c4e0: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
-0002c4f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002c500: 3d3d 3d0a 2020 2020 2020 2020 666f 7220  ===.        for 
-0002c510: 696e 645f 6c6f 7320 696e 2070 7261 6e67  ind_los in prang
-0002c520: 6528 6e6c 6f73 2c20 7363 6865 6475 6c65  e(nlos, schedule
-0002c530: 3d27 6479 6e61 6d69 6327 293a 0a20 2020  ='dynamic'):.   
-0002c540: 2020 2020 2020 2020 206c 6f63 5f6f 7267           loc_org
-0002c550: 5b30 5d20 3d20 7261 795f 6f72 6967 5b30  [0] = ray_orig[0
-0002c560: 2c20 696e 645f 6c6f 735d 0a20 2020 2020  , ind_los].     
-0002c570: 2020 2020 2020 206c 6f63 5f6f 7267 5b31         loc_org[1
-0002c580: 5d20 3d20 7261 795f 6f72 6967 5b31 2c20  ] = ray_orig[1, 
-0002c590: 696e 645f 6c6f 735d 0a20 2020 2020 2020  ind_los].       
-0002c5a0: 2020 2020 206c 6f63 5f6f 7267 5b32 5d20       loc_org[2] 
-0002c5b0: 3d20 7261 795f 6f72 6967 5b32 2c20 696e  = ray_orig[2, in
-0002c5c0: 645f 6c6f 735d 0a20 2020 2020 2020 2020  d_los].         
-0002c5d0: 2020 206c 6f63 5f64 6972 5b30 5d20 3d20     loc_dir[0] = 
-0002c5e0: 7261 795f 7664 6972 5b30 2c20 696e 645f  ray_vdir[0, ind_
-0002c5f0: 6c6f 735d 0a20 2020 2020 2020 2020 2020  los].           
-0002c600: 206c 6f63 5f64 6972 5b31 5d20 3d20 7261   loc_dir[1] = ra
-0002c610: 795f 7664 6972 5b31 2c20 696e 645f 6c6f  y_vdir[1, ind_lo
-0002c620: 735d 0a20 2020 2020 2020 2020 2020 206c  s].            l
-0002c630: 6f63 5f64 6972 5b32 5d20 3d20 7261 795f  oc_dir[2] = ray_
-0002c640: 7664 6972 5b32 2c20 696e 645f 6c6f 735d  vdir[2, ind_los]
-0002c650: 0a20 2020 2020 2020 2020 2020 2023 202d  .            # -
-0002c660: 2d20 436f 6d70 7574 696e 6720 7661 6c75  - Computing valu
-0002c670: 6573 2074 6861 7420 6465 7065 6e64 206f  es that depend o
-0002c680: 6e20 7468 6520 4c4f 532f 7261 7920 2d2d  n the LOS/ray --
-0002c690: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0002c6a0: 2d0a 2020 2020 2020 2020 2020 2020 7570  -.            up
-0002c6b0: 7363 6144 7020 3d20 6c6f 635f 6469 725b  scaDp = loc_dir[
-0002c6c0: 305d 2a6c 6f63 5f6f 7267 5b30 5d20 2b20  0]*loc_org[0] + 
-0002c6d0: 6c6f 635f 6469 725b 315d 2a6c 6f63 5f6f  loc_dir[1]*loc_o
-0002c6e0: 7267 5b31 5d0a 2020 2020 2020 2020 2020  rg[1].          
-0002c6f0: 2020 7570 6172 3220 2020 3d20 6c6f 635f    upar2   = loc_
-0002c700: 6469 725b 305d 2a6c 6f63 5f64 6972 5b30  dir[0]*loc_dir[0
-0002c710: 5d20 2b20 6c6f 635f 6469 725b 315d 2a6c  ] + loc_dir[1]*l
-0002c720: 6f63 5f64 6972 5b31 5d0a 2020 2020 2020  oc_dir[1].      
-0002c730: 2020 2020 2020 6470 6172 3220 2020 3d20        dpar2   = 
-0002c740: 6c6f 635f 6f72 675b 305d 2a6c 6f63 5f6f  loc_org[0]*loc_o
-0002c750: 7267 5b30 5d20 2b20 6c6f 635f 6f72 675b  rg[0] + loc_org[
-0002c760: 315d 2a6c 6f63 5f6f 7267 5b31 5d0a 2020  1]*loc_org[1].  
-0002c770: 2020 2020 2020 2020 2020 696e 7675 7a20            invuz 
-0002c780: 3d20 312e 2f6c 6f63 5f64 6972 5b32 5d0a  = 1./loc_dir[2].
-0002c790: 2020 2020 2020 2020 2020 2020 6372 6974              crit
-0002c7a0: 3220 3d20 7570 6172 322a 6372 6974 325f  2 = upar2*crit2_
-0002c7b0: 6261 7365 0a20 2020 2020 2020 2020 2020  base.           
-0002c7c0: 205f 6474 2e73 696d 706c 655f 6469 7374   _dt.simple_dist
-0002c7d0: 5f6c 6f73 5f76 706f 6c79 5f63 6f72 6528  _los_vpoly_core(
-0002c7e0: 6c6f 635f 6f72 672c 206c 6f63 5f64 6972  loc_org, loc_dir
-0002c7f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0002c390: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020  =============.  
+0002c3a0: 2020 7769 7468 206e 6f67 696c 2c20 7061    with nogil, pa
+0002c3b0: 7261 6c6c 656c 286e 756d 5f74 6872 6561  rallel(num_threa
+0002c3c0: 6473 3d6e 756d 5f74 6872 6561 6473 293a  ds=num_threads):
+0002c3d0: 0a20 2020 2020 2020 2023 2057 6520 7573  .        # We us
+0002c3e0: 6520 6c6f 6361 6c20 6172 7261 7973 2066  e local arrays f
+0002c3f0: 6f72 2065 6163 6820 7468 7265 6164 2073  or each thread s
+0002c400: 6f2e 2e2e 0a20 2020 2020 2020 206c 6f63  o....        loc
+0002c410: 5f6f 7267 2020 203d 203c 646f 7562 6c65  _org   = <double
+0002c420: 202a 3e20 6d61 6c6c 6f63 2873 697a 656f   *> malloc(sizeo
+0002c430: 6628 646f 7562 6c65 2920 2a20 3329 0a20  f(double) * 3). 
+0002c440: 2020 2020 2020 206c 6f63 5f64 6972 2020         loc_dir  
+0002c450: 203d 203c 646f 7562 6c65 202a 3e20 6d61   = <double *> ma
+0002c460: 6c6c 6f63 2873 697a 656f 6628 646f 7562  lloc(sizeof(doub
+0002c470: 6c65 2920 2a20 3329 0a20 2020 2020 2020  le) * 3).       
+0002c480: 2072 6573 5f6c 6f63 203d 203c 646f 7562   res_loc = <doub
+0002c490: 6c65 202a 3e20 6d61 6c6c 6f63 2832 2a73  le *> malloc(2*s
+0002c4a0: 697a 656f 6628 646f 7562 6c65 2929 0a20  izeof(double)). 
+0002c4b0: 2020 2020 2020 2023 203d 3d20 5468 6520         # == The 
+0002c4c0: 7061 7261 6c6c 656c 697a 6174 696f 6e20  parallelization 
+0002c4d0: 6f76 6572 2074 6865 204c 4f53 203d 3d3d  over the LOS ===
+0002c4e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0002c4f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
+0002c500: 2020 2020 2020 2020 666f 7220 696e 645f          for ind_
+0002c510: 6c6f 7320 696e 2070 7261 6e67 6528 6e6c  los in prange(nl
+0002c520: 6f73 2c20 7363 6865 6475 6c65 3d27 6479  os, schedule='dy
+0002c530: 6e61 6d69 6327 293a 0a20 2020 2020 2020  namic'):.       
+0002c540: 2020 2020 206c 6f63 5f6f 7267 5b30 5d20       loc_org[0] 
+0002c550: 3d20 7261 795f 6f72 6967 5b30 2c20 696e  = ray_orig[0, in
+0002c560: 645f 6c6f 735d 0a20 2020 2020 2020 2020  d_los].         
+0002c570: 2020 206c 6f63 5f6f 7267 5b31 5d20 3d20     loc_org[1] = 
+0002c580: 7261 795f 6f72 6967 5b31 2c20 696e 645f  ray_orig[1, ind_
+0002c590: 6c6f 735d 0a20 2020 2020 2020 2020 2020  los].           
+0002c5a0: 206c 6f63 5f6f 7267 5b32 5d20 3d20 7261   loc_org[2] = ra
+0002c5b0: 795f 6f72 6967 5b32 2c20 696e 645f 6c6f  y_orig[2, ind_lo
+0002c5c0: 735d 0a20 2020 2020 2020 2020 2020 206c  s].            l
+0002c5d0: 6f63 5f64 6972 5b30 5d20 3d20 7261 795f  oc_dir[0] = ray_
+0002c5e0: 7664 6972 5b30 2c20 696e 645f 6c6f 735d  vdir[0, ind_los]
+0002c5f0: 0a20 2020 2020 2020 2020 2020 206c 6f63  .            loc
+0002c600: 5f64 6972 5b31 5d20 3d20 7261 795f 7664  _dir[1] = ray_vd
+0002c610: 6972 5b31 2c20 696e 645f 6c6f 735d 0a20  ir[1, ind_los]. 
+0002c620: 2020 2020 2020 2020 2020 206c 6f63 5f64             loc_d
+0002c630: 6972 5b32 5d20 3d20 7261 795f 7664 6972  ir[2] = ray_vdir
+0002c640: 5b32 2c20 696e 645f 6c6f 735d 0a20 2020  [2, ind_los].   
+0002c650: 2020 2020 2020 2020 2023 202d 2d20 436f           # -- Co
+0002c660: 6d70 7574 696e 6720 7661 6c75 6573 2074  mputing values t
+0002c670: 6861 7420 6465 7065 6e64 206f 6e20 7468  hat depend on th
+0002c680: 6520 4c4f 532f 7261 7920 2d2d 2d2d 2d2d  e LOS/ray ------
+0002c690: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  -------------.  
+0002c6a0: 2020 2020 2020 2020 2020 7570 7363 6144            upscaD
+0002c6b0: 7020 3d20 6c6f 635f 6469 725b 305d 2a6c  p = loc_dir[0]*l
+0002c6c0: 6f63 5f6f 7267 5b30 5d20 2b20 6c6f 635f  oc_org[0] + loc_
+0002c6d0: 6469 725b 315d 2a6c 6f63 5f6f 7267 5b31  dir[1]*loc_org[1
+0002c6e0: 5d0a 2020 2020 2020 2020 2020 2020 7570  ].            up
+0002c6f0: 6172 3220 2020 3d20 6c6f 635f 6469 725b  ar2   = loc_dir[
+0002c700: 305d 2a6c 6f63 5f64 6972 5b30 5d20 2b20  0]*loc_dir[0] + 
+0002c710: 6c6f 635f 6469 725b 315d 2a6c 6f63 5f64  loc_dir[1]*loc_d
+0002c720: 6972 5b31 5d0a 2020 2020 2020 2020 2020  ir[1].          
+0002c730: 2020 6470 6172 3220 2020 3d20 6c6f 635f    dpar2   = loc_
+0002c740: 6f72 675b 305d 2a6c 6f63 5f6f 7267 5b30  org[0]*loc_org[0
+0002c750: 5d20 2b20 6c6f 635f 6f72 675b 315d 2a6c  ] + loc_org[1]*l
+0002c760: 6f63 5f6f 7267 5b31 5d0a 2020 2020 2020  oc_org[1].      
+0002c770: 2020 2020 2020 696e 7675 7a20 3d20 312e        invuz = 1.
+0002c780: 2f6c 6f63 5f64 6972 5b32 5d0a 2020 2020  /loc_dir[2].    
+0002c790: 2020 2020 2020 2020 6372 6974 3220 3d20          crit2 = 
+0002c7a0: 7570 6172 322a 6372 6974 325f 6261 7365  upar2*crit2_base
+0002c7b0: 0a20 2020 2020 2020 2020 2020 205f 6474  .            _dt
+0002c7c0: 2e73 696d 706c 655f 6469 7374 5f6c 6f73  .simple_dist_los
+0002c7d0: 5f76 706f 6c79 5f63 6f72 6528 6c6f 635f  _vpoly_core(loc_
+0002c7e0: 6f72 672c 206c 6f63 5f64 6972 2c0a 2020  org, loc_dir,.  
+0002c7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c810: 2020 2020 2020 2020 2020 2020 206c 6973               lis
-0002c820: 745f 7670 6f6c 795f 782c 0a20 2020 2020  t_vpoly_x,.     
+0002c810: 2020 2020 2020 2020 206c 6973 745f 7670           list_vp
+0002c820: 6f6c 795f 782c 0a20 2020 2020 2020 2020  oly_x,.         
 0002c830: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c850: 2020 2020 2020 6c69 7374 5f76 706f 6c79        list_vpoly
-0002c860: 5f79 2c0a 2020 2020 2020 2020 2020 2020  _y,.            
+0002c850: 2020 6c69 7374 5f76 706f 6c79 5f79 2c0a    list_vpoly_y,.
+0002c860: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c880: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0002c890: 6577 5f6e 7074 735f 706f 6c79 2c20 7570  ew_npts_poly, up
-0002c8a0: 7363 6144 702c 0a20 2020 2020 2020 2020  scaDp,.         
+0002c880: 2020 2020 2020 2020 2020 206e 6577 5f6e             new_n
+0002c890: 7074 735f 706f 6c79 2c20 7570 7363 6144  pts_poly, upscaD
+0002c8a0: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
 0002c8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c8d0: 2020 7570 6172 322c 2064 7061 7232 2c0a    upar2, dpar2,.
+0002c8c0: 2020 2020 2020 2020 2020 2020 2020 7570                up
+0002c8d0: 6172 322c 2064 7061 7232 2c0a 2020 2020  ar2, dpar2,.    
 0002c8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c900: 2020 2020 2020 2020 2020 2069 6e76 757a             invuz
-0002c910: 2c20 6372 6974 322c 0a20 2020 2020 2020  , crit2,.       
+0002c900: 2020 2020 2020 2069 6e76 757a 2c20 6372         invuz, cr
+0002c910: 6974 322c 0a20 2020 2020 2020 2020 2020  it2,.           
 0002c920: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c940: 2020 2020 6570 735f 757a 2c20 6570 735f      eps_uz, eps_
-0002c950: 767a 2c0a 2020 2020 2020 2020 2020 2020  vz,.            
+0002c940: 6570 735f 757a 2c20 6570 735f 767a 2c0a  eps_uz, eps_vz,.
+0002c950: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c970: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0002c980: 7073 5f61 2c20 6570 735f 622c 0a20 2020  ps_a, eps_b,.   
+0002c970: 2020 2020 2020 2020 2020 2065 7073 5f61             eps_a
+0002c980: 2c20 6570 735f 622c 0a20 2020 2020 2020  , eps_b,.       
 0002c990: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002c9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c9b0: 2020 2020 2020 2020 7265 735f 6c6f 6329          res_loc)
-0002c9c0: 0a20 2020 2020 2020 2020 2020 206b 6d69  .            kmi
-0002c9d0: 6e5b 696e 645f 6c6f 735d 203d 2072 6573  n[ind_los] = res
-0002c9e0: 5f6c 6f63 5b30 5d0a 2020 2020 2020 2020  _loc[0].        
-0002c9f0: 2020 2020 6469 7374 5b69 6e64 5f6c 6f73      dist[ind_los
-0002ca00: 5d20 3d20 7265 735f 6c6f 635b 315d 0a20  ] = res_loc[1]. 
-0002ca10: 2020 2020 2020 2066 7265 6528 6c6f 635f         free(loc_
-0002ca20: 6f72 6729 0a20 2020 2020 2020 2066 7265  org).        fre
-0002ca30: 6528 6c6f 635f 6469 7229 0a20 2020 2020  e(loc_dir).     
-0002ca40: 2020 2066 7265 6528 7265 735f 6c6f 6329     free(res_loc)
-0002ca50: 0a20 2020 2066 7265 6528 6c69 7374 5f76  .    free(list_v
-0002ca60: 706f 6c79 5f78 290a 2020 2020 6672 6565  poly_x).    free
-0002ca70: 286c 6973 745f 7670 6f6c 795f 7929 0a20  (list_vpoly_y). 
-0002ca80: 2020 2072 6574 7572 6e20 6b6d 696e 2c20     return kmin, 
-0002ca90: 6469 7374 0a0a 6465 6620 636f 6d70 5f64  dist..def comp_d
-0002caa0: 6973 745f 6c6f 735f 7670 6f6c 795f 7665  ist_los_vpoly_ve
-0002cab0: 6328 696e 7420 6e76 706f 6c79 2c20 696e  c(int nvpoly, in
-0002cac0: 7420 6e6c 6f73 2c0a 2020 2020 2020 2020  t nlos,.        
+0002c9b0: 2020 2020 7265 735f 6c6f 6329 0a20 2020      res_loc).   
+0002c9c0: 2020 2020 2020 2020 206b 6d69 6e5b 696e           kmin[in
+0002c9d0: 645f 6c6f 735d 203d 2072 6573 5f6c 6f63  d_los] = res_loc
+0002c9e0: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
+0002c9f0: 6469 7374 5b69 6e64 5f6c 6f73 5d20 3d20  dist[ind_los] = 
+0002ca00: 7265 735f 6c6f 635b 315d 0a20 2020 2020  res_loc[1].     
+0002ca10: 2020 2066 7265 6528 6c6f 635f 6f72 6729     free(loc_org)
+0002ca20: 0a20 2020 2020 2020 2066 7265 6528 6c6f  .        free(lo
+0002ca30: 635f 6469 7229 0a20 2020 2020 2020 2066  c_dir).        f
+0002ca40: 7265 6528 7265 735f 6c6f 6329 0a20 2020  ree(res_loc).   
+0002ca50: 2066 7265 6528 6c69 7374 5f76 706f 6c79   free(list_vpoly
+0002ca60: 5f78 290a 2020 2020 6672 6565 286c 6973  _x).    free(lis
+0002ca70: 745f 7670 6f6c 795f 7929 0a20 2020 2072  t_vpoly_y).    r
+0002ca80: 6574 7572 6e20 6b6d 696e 2c20 6469 7374  eturn kmin, dist
+0002ca90: 0a0a 6465 6620 636f 6d70 5f64 6973 745f  ..def comp_dist_
+0002caa0: 6c6f 735f 7670 6f6c 795f 7665 6328 696e  los_vpoly_vec(in
+0002cab0: 7420 6e76 706f 6c79 2c20 696e 7420 6e6c  t nvpoly, int nl
+0002cac0: 6f73 2c0a 2020 2020 2020 2020 2020 2020  os,.            
 0002cad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002cae0: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
-0002caf0: 6f75 626c 652c 6e64 696d 3d32 2c6d 6f64  ouble,ndim=2,mod
-0002cb00: 653d 2763 275d 2072 6179 5f6f 7269 672c  e='c'] ray_orig,
-0002cb10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0002cb20: 2020 2020 2020 2020 2020 2020 206e 702e               np.
-0002cb30: 6e64 6172 7261 795b 646f 7562 6c65 2c6e  ndarray[double,n
-0002cb40: 6469 6d3d 322c 6d6f 6465 3d27 6327 5d20  dim=2,mode='c'] 
-0002cb50: 7261 795f 7664 6972 2c0a 2020 2020 2020  ray_vdir,.      
+0002cae0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+0002caf0: 652c 6e64 696d 3d32 2c6d 6f64 653d 2763  e,ndim=2,mode='c
+0002cb00: 275d 2072 6179 5f6f 7269 672c 0a20 2020  '] ray_orig,.   
+0002cb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cb20: 2020 2020 2020 2020 206e 702e 6e64 6172           np.ndar
+0002cb30: 7261 795b 646f 7562 6c65 2c6e 6469 6d3d  ray[double,ndim=
+0002cb40: 322c 6d6f 6465 3d27 6327 5d20 7261 795f  2,mode='c'] ray_
+0002cb50: 7664 6972 2c0a 2020 2020 2020 2020 2020  vdir,.          
 0002cb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002cb70: 2020 2020 2020 6e70 2e6e 6461 7272 6179        np.ndarray
-0002cb80: 5b64 6f75 626c 652c 6e64 696d 3d33 2c6d  [double,ndim=3,m
-0002cb90: 6f64 653d 2763 275d 2076 6573 5f70 6f6c  ode='c'] ves_pol
-0002cba0: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
-0002cbb0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0002cbc0: 6f75 626c 6520 6570 735f 757a 3d5f 534d  ouble eps_uz=_SM
-0002cbd0: 414c 4c2c 2064 6f75 626c 6520 6570 735f  ALL, double eps_
-0002cbe0: 613d 5f56 534d 414c 4c2c 0a20 2020 2020  a=_VSMALL,.     
+0002cb70: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
+0002cb80: 626c 652c 6e64 696d 3d33 2c6d 6f64 653d  ble,ndim=3,mode=
+0002cb90: 2763 275d 2076 6573 5f70 6f6c 792c 0a20  'c'] ves_poly,. 
+0002cba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cbb0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+0002cbc0: 6520 6570 735f 757a 3d5f 534d 414c 4c2c  e eps_uz=_SMALL,
+0002cbd0: 2064 6f75 626c 6520 6570 735f 613d 5f56   double eps_a=_V
+0002cbe0: 534d 414c 4c2c 0a20 2020 2020 2020 2020  SMALL,.         
 0002cbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002cc00: 2020 2020 2020 2064 6f75 626c 6520 6570         double ep
-0002cc10: 735f 767a 3d5f 5653 4d41 4c4c 2c20 646f  s_vz=_VSMALL, do
-0002cc20: 7562 6c65 2065 7073 5f62 3d5f 5653 4d41  uble eps_b=_VSMA
-0002cc30: 4c4c 2c0a 2020 2020 2020 2020 2020 2020  LL,.            
-0002cc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002cc50: 646f 7562 6c65 2065 7073 5f70 6c61 6e65  double eps_plane
-0002cc60: 3d5f 5653 4d41 4c4c 2c20 7374 7220 7665  =_VSMALL, str ve
-0002cc70: 735f 7479 7065 3d27 546f 7227 2c0a 2020  s_type='Tor',.  
+0002cc00: 2020 2064 6f75 626c 6520 6570 735f 767a     double eps_vz
+0002cc10: 3d5f 5653 4d41 4c4c 2c20 646f 7562 6c65  =_VSMALL, double
+0002cc20: 2065 7073 5f62 3d5f 5653 4d41 4c4c 2c0a   eps_b=_VSMALL,.
+0002cc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cc40: 2020 2020 2020 2020 2020 2020 646f 7562              doub
+0002cc50: 6c65 2065 7073 5f70 6c61 6e65 3d5f 5653  le eps_plane=_VS
+0002cc60: 4d41 4c4c 2c20 7374 7220 7665 735f 7479  MALL, str ves_ty
+0002cc70: 7065 3d27 546f 7227 2c0a 2020 2020 2020  pe='Tor',.      
 0002cc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002cc90: 2020 2020 2020 2020 2020 7374 7220 616c            str al
-0002cca0: 676f 5f74 7970 653d 2773 696d 706c 6527  go_type='simple'
-0002ccb0: 2c20 696e 7420 6e75 6d5f 7468 7265 6164  , int num_thread
-0002ccc0: 733d 3136 293a 0a20 2020 2022 2222 0a20  s=16):.    """. 
-0002ccd0: 2020 2054 6869 7320 6675 6e63 7469 6f6e     This function
-0002cce0: 2063 6f6d 7075 7465 7320 7468 6520 6469   computes the di
-0002ccf0: 7374 616e 6365 2028 616e 6420 7468 6520  stance (and the 
-0002cd00: 6173 736f 6369 6174 6564 206b 2920 6265  associated k) be
-0002cd10: 7477 6565 6e20 6e6c 6f73 0a20 2020 2052  tween nlos.    R
-0002cd20: 6179 7320 286f 7220 4c4f 5329 2061 6e64  ays (or LOS) and
-0002cd30: 2073 6576 6572 616c 2060 494e 6020 7374   several `IN` st
-0002cd40: 7275 6374 7572 6573 2028 706f 6c79 676f  ructures (polygo
-0002cd50: 6e73 2065 7874 7275 6465 6420 6172 6f75  ns extruded arou
-0002cd60: 6e64 2074 6865 2061 7869 730a 2020 2020  nd the axis.    
-0002cd70: 2830 2c30 2c31 292c 2065 672e 2066 6c75  (0,0,1), eg. flu
-0002cd80: 7820 7375 7266 6163 6573 292e 0a20 2020  x surfaces)..   
-0002cd90: 2046 6f72 206d 6f72 6520 6465 7461 696c   For more detail
-0002cda0: 7320 6f6e 2074 6865 2061 6c67 6f72 6974  s on the algorit
-0002cdb0: 686d 2070 6c65 6173 6520 7365 6520 5044  hm please see PD
-0002cdc0: 463a 203c 6e61 6d65 5f6f 665f 7064 663e  F: <name_of_pdf>
-0002cdd0: 2e70 6466 2023 544f 444f 0a0a 2020 2020  .pdf #TODO..    
-0002cde0: 5061 7261 6d73 0a20 2020 203d 3d3d 3d3d  Params.    =====
-0002cdf0: 3d0a 2020 2020 2020 2020 6e76 706f 6c79  =.        nvpoly
-0002ce00: 203a 2069 6e74 0a20 2020 2020 2020 2020   : int.         
-0002ce10: 2020 4e75 6d62 6572 206f 6620 666c 7578    Number of flux
-0002ce20: 2073 7572 6661 6365 730a 2020 2020 2020   surfaces.      
-0002ce30: 2020 6e6c 6f73 203a 2069 6e74 0a20 2020    nlos : int.   
-0002ce40: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
-0002ce50: 6620 4c4f 530a 2020 2020 2020 2020 7261  f LOS.        ra
-0002ce60: 795f 6f72 6967 203a 2028 332c 206e 6c6f  y_orig : (3, nlo
-0002ce70: 7329 2064 6f75 626c 6520 6172 7261 790a  s) double array.
-0002ce80: 2020 2020 2020 2020 2020 204c 4f53 206f             LOS o
-0002ce90: 7269 6769 6e20 706f 696e 7473 2063 6f6f  rigin points coo
-0002cea0: 7264 696e 6174 6573 0a20 2020 2020 2020  rdinates.       
-0002ceb0: 2072 6179 5f76 6469 7220 3a20 2833 2c20   ray_vdir : (3, 
-0002cec0: 6e6c 6f73 2920 646f 7562 6c65 2061 7272  nlos) double arr
-0002ced0: 6179 0a20 2020 2020 2020 2020 2020 4c4f  ay.           LO
-0002cee0: 5320 6e6f 726d 616c 697a 6564 2064 6972  S normalized dir
-0002cef0: 6563 7469 6f6e 2076 6563 746f 720a 2020  ection vector.  
-0002cf00: 2020 2020 2020 7665 735f 706f 6c79 203a        ves_poly :
-0002cf10: 2028 6e75 6d5f 706f 6c2c 2032 2c20 6e75   (num_pol, 2, nu
-0002cf20: 6d5f 7665 7274 6578 2920 646f 7562 6c65  m_vertex) double
-0002cf30: 2061 7272 6179 0a20 2020 2020 2020 2020   array.         
-0002cf40: 2020 436f 6f72 6469 6e61 7465 7320 6f66    Coordinates of
-0002cf50: 2074 6865 2076 6572 7469 6365 7320 6f66   the vertices of
-0002cf60: 2074 6865 2050 6f6c 7967 6f6e 2064 6566   the Polygon def
-0002cf70: 696e 696e 6720 7468 6520 3244 2070 6f6c  ining the 2D pol
-0002cf80: 6f69 6461 6c0a 2020 2020 2020 2020 2020  oidal.          
-0002cf90: 2063 7574 206f 6620 7468 6520 6469 6666   cut of the diff
-0002cfa0: 6572 656e 7420 494e 2073 7572 6661 6365  erent IN surface
-0002cfb0: 730a 2020 2020 2020 2020 2020 2057 4152  s.           WAR
-0002cfc0: 4e49 4e47 203a 2077 6520 7375 7070 6f73  NING : we suppos
-0002cfd0: 6520 616c 6c20 706f 6c79 2061 7265 206e  e all poly are n
-0002cfe0: 6573 7465 6420 696e 2065 6163 6820 6f74  ested in each ot
-0002cff0: 6865 722c 0a20 2020 2020 2020 2020 2020  her,.           
-0002d000: 2020 2020 2020 2020 2020 6672 6f6d 2069            from i
-0002d010: 6e6e 6572 2074 6f20 6f75 7465 720a 2020  nner to outer.  
-0002d020: 2020 2020 2020 6570 735f 3c76 616c 3e20        eps_<val> 
-0002d030: 3a20 646f 7562 6c65 0a20 2020 2020 2020  : double.       
-0002d040: 2020 2020 536d 616c 6c20 7661 6c75 652c      Small value,
-0002d050: 2061 6363 6570 7461 6e63 6520 6f66 2065   acceptance of e
-0002d060: 7272 6f72 0a20 2020 2052 6574 7572 6e73  rror.    Returns
-0002d070: 0a20 2020 203d 3d3d 3d3d 3d3d 0a20 2020  .    =======.   
-0002d080: 2020 2020 206b 6d69 6e5f 7670 6f6c 7920       kmin_vpoly 
-0002d090: 3a20 286e 706f 6c79 2c20 6e6c 6f73 2920  : (npoly, nlos) 
-0002d0a0: 646f 7562 6c65 2061 7272 6179 0a20 2020  double array.   
-0002d0b0: 2020 2020 2020 2020 204f 6620 7468 6520           Of the 
-0002d0c0: 666f 726d 205b 6b5f 3030 2c20 6b5f 3031  form [k_00, k_01
-0002d0d0: 2c20 2e2e 2e2c 206b 5f30 6e2c 206b 5f31  , ..., k_0n, k_1
-0002d0e0: 302c 206b 5f31 312c 202e 2e2e 2c20 6b5f  0, k_11, ..., k_
-0002d0f0: 316e 2c20 2e2e 2e5d 0a20 2020 2020 2020  1n, ...].       
-0002d100: 2020 2020 2077 6865 7265 206b 5f69 6a20       where k_ij 
-0002d110: 6973 2074 6865 2063 6f65 6666 6963 6965  is the coefficie
-0002d120: 6e74 2066 6f72 2074 6865 206a 2d74 6820  nt for the j-th 
-0002d130: 666c 7578 2073 7572 6661 6365 0a20 2020  flux surface.   
-0002d140: 2020 2020 2020 2020 2073 7563 6820 7468           such th
-0002d150: 6174 2074 6865 2069 2d74 6820 7261 7920  at the i-th ray 
-0002d160: 284c 4f53 2920 6973 2063 6c6f 7365 7374  (LOS) is closest
-0002d170: 2074 6f20 7468 6520 6578 7472 7564 6564   to the extruded
-0002d180: 2070 6f6c 7967 6f6e 0a20 2020 2020 2020   polygon.       
-0002d190: 2020 2020 2061 7420 7468 6520 706f 696e       at the poin
-0002d1a0: 7420 505f 6920 3d20 6f72 6967 5b69 5d20  t P_i = orig[i] 
-0002d1b0: 2b20 6b6d 696e 5b69 5d20 2a20 7664 6972  + kmin[i] * vdir
-0002d1c0: 5b69 5d0a 2020 2020 2020 2020 6469 7374  [i].        dist
-0002d1d0: 5f76 706f 6c79 203a 2028 6e70 6f6c 792c  _vpoly : (npoly,
-0002d1e0: 206e 6c6f 7329 2064 6f75 626c 6520 6172   nlos) double ar
-0002d1f0: 7261 790a 2020 2020 2020 2020 2020 2020  ray.            
-0002d200: 6064 6973 7461 6e63 655b 6920 2a20 6e75  `distance[i * nu
-0002d210: 6d5f 706f 6c79 202b 206a 5d60 2069 7320  m_poly + j]` is 
-0002d220: 7468 6520 6469 7374 616e 6365 2066 726f  the distance fro
-0002d230: 6d20 505f 6920 746f 2074 6865 2069 2d74  m P_i to the i-t
-0002d240: 680a 2020 2020 2020 2020 2020 2020 6578  h.            ex
-0002d250: 7472 7564 6564 2070 6f6c 792e 0a20 2020  truded poly..   
-0002d260: 202d 2d2d 0a20 2020 2054 6869 7320 6973   ---.    This is
-0002d270: 2074 6865 2050 5954 484f 4e20 6675 6e63   the PYTHON func
-0002d280: 7469 6f6e 2c20 7573 6520 6f6e 6c79 2069  tion, use only i
-0002d290: 6620 796f 7520 6e65 6564 2074 6869 7320  f you need this 
-0002d2a0: 636f 6d70 7574 6174 696f 6e20 6672 6f6d  computation from
-0002d2b0: 0a20 2020 2050 7974 686f 6e2c 2069 6620  .    Python, if 
-0002d2c0: 796f 7520 6e65 6564 2069 7420 6672 6f6d  you need it from
-0002d2d0: 2063 7974 686f 6e2c 2075 7365 2060 636f   cython, use `co
-0002d2e0: 6d70 5f64 6973 745f 6c6f 735f 7670 6f6c  mp_dist_los_vpol
-0002d2f0: 795f 7665 635f 636f 7265 600a 2020 2020  y_vec_core`.    
-0002d300: 2222 220a 2020 2020 6966 206e 6f74 2061  """.    if not a
-0002d310: 6c67 6f5f 7479 7065 2e6c 6f77 6572 2829  lgo_type.lower()
-0002d320: 203d 3d20 2273 696d 706c 6522 206f 7220   == "simple" or 
-0002d330: 6e6f 7420 7665 735f 7479 7065 2e6c 6f77  not ves_type.low
-0002d340: 6572 2829 203d 3d20 2274 6f72 223a 0a20  er() == "tor":. 
-0002d350: 2020 2020 2020 2061 7373 6572 7420 4661         assert Fa
-0002d360: 6c73 652c 2022 5468 6520 6675 6e63 7469  lse, "The functi
-0002d370: 6f6e 2069 7320 6f6e 6c79 2069 6d70 6c65  on is only imple
-0002d380: 6d65 6e74 6564 2077 6974 6820 7468 6520  mented with the 
-0002d390: 7369 6d70 6c65 225c 0a20 2020 2020 2020  simple"\.       
-0002d3a0: 2020 2020 202b 2022 2061 6c67 6f72 6974       + " algorit
-0002d3b0: 686d 2061 6e64 2066 6f72 2074 6f72 6f69  hm and for toroi
-0002d3c0: 6461 6c20 7665 7373 656c 732e 2e2e 2053  dal vessels... S
-0002d3d0: 6f72 7279 2122 0a20 2020 2077 6172 6e28  orry!".    warn(
-0002d3e0: 2254 6869 7320 6675 6e63 7469 6f6e 2073  "This function s
-0002d3f0: 7570 706f 7365 7320 7468 6174 2074 6865  upposes that the
-0002d400: 2070 6f6c 7973 2061 7265 206e 6573 7465   polys are neste
-0002d410: 6420 6672 6f6d 2069 6e6e 6572 2074 6f20  d from inner to 
-0002d420: 6f75 7465 7222 2c0a 2020 2020 2020 2020  outer",.        
-0002d430: 2057 6172 6e69 6e67 290a 0a20 2020 2063   Warning)..    c
-0002d440: 6465 6620 6e70 2e6e 6461 7272 6179 5b64  def np.ndarray[d
-0002d450: 6f75 626c 652c 206e 6469 6d3d 315d 206b  ouble, ndim=1] k
-0002d460: 6d69 6e20 3d20 6e70 2e65 6d70 7479 2828  min = np.empty((
-0002d470: 6e76 706f 6c79 2a6e 6c6f 732c 292c 2064  nvpoly*nlos,), d
-0002d480: 7479 7065 3d66 6c6f 6174 290a 2020 2020  type=float).    
-0002d490: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
-0002d4a0: 646f 7562 6c65 2c20 6e64 696d 3d31 5d20  double, ndim=1] 
-0002d4b0: 6469 7374 203d 206e 702e 656d 7074 7928  dist = np.empty(
-0002d4c0: 286e 7670 6f6c 792a 6e6c 6f73 2c29 2c20  (nvpoly*nlos,), 
-0002d4d0: 6474 7970 653d 666c 6f61 7429 0a20 2020  dtype=float).   
-0002d4e0: 2063 6465 6620 696e 7420 616c 676f 5f6e   cdef int algo_n
-0002d4f0: 756d 203d 2030 0a20 2020 2063 6465 6620  um = 0.    cdef 
-0002d500: 696e 7420 7665 735f 6e75 6d20 3d20 310a  int ves_num = 1.
-0002d510: 2020 2020 5f64 742e 636f 6d70 5f64 6973      _dt.comp_dis
-0002d520: 745f 6c6f 735f 7670 6f6c 795f 7665 635f  t_los_vpoly_vec_
-0002d530: 636f 7265 286e 7670 6f6c 792c 206e 6c6f  core(nvpoly, nlo
-0002d540: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+0002cc90: 2020 2020 2020 7374 7220 616c 676f 5f74        str algo_t
+0002cca0: 7970 653d 2773 696d 706c 6527 2c20 696e  ype='simple', in
+0002ccb0: 7420 6e75 6d5f 7468 7265 6164 733d 3136  t num_threads=16
+0002ccc0: 293a 0a20 2020 2022 2222 0a20 2020 2054  ):.    """.    T
+0002ccd0: 6869 7320 6675 6e63 7469 6f6e 2063 6f6d  his function com
+0002cce0: 7075 7465 7320 7468 6520 6469 7374 616e  putes the distan
+0002ccf0: 6365 2028 616e 6420 7468 6520 6173 736f  ce (and the asso
+0002cd00: 6369 6174 6564 206b 2920 6265 7477 6565  ciated k) betwee
+0002cd10: 6e20 6e6c 6f73 0a20 2020 2052 6179 7320  n nlos.    Rays 
+0002cd20: 286f 7220 4c4f 5329 2061 6e64 2073 6576  (or LOS) and sev
+0002cd30: 6572 616c 2060 494e 6020 7374 7275 6374  eral `IN` struct
+0002cd40: 7572 6573 2028 706f 6c79 676f 6e73 2065  ures (polygons e
+0002cd50: 7874 7275 6465 6420 6172 6f75 6e64 2074  xtruded around t
+0002cd60: 6865 2061 7869 730a 2020 2020 2830 2c30  he axis.    (0,0
+0002cd70: 2c31 292c 2065 672e 2066 6c75 7820 7375  ,1), eg. flux su
+0002cd80: 7266 6163 6573 292e 0a20 2020 2046 6f72  rfaces)..    For
+0002cd90: 206d 6f72 6520 6465 7461 696c 7320 6f6e   more details on
+0002cda0: 2074 6865 2061 6c67 6f72 6974 686d 2070   the algorithm p
+0002cdb0: 6c65 6173 6520 7365 6520 5044 463a 203c  lease see PDF: <
+0002cdc0: 6e61 6d65 5f6f 665f 7064 663e 2e70 6466  name_of_pdf>.pdf
+0002cdd0: 2023 544f 444f 0a0a 2020 2020 5061 7261   #TODO..    Para
+0002cde0: 6d73 0a20 2020 203d 3d3d 3d3d 3d0a 2020  ms.    ======.  
+0002cdf0: 2020 2020 2020 6e76 706f 6c79 203a 2069        nvpoly : i
+0002ce00: 6e74 0a20 2020 2020 2020 2020 2020 4e75  nt.           Nu
+0002ce10: 6d62 6572 206f 6620 666c 7578 2073 7572  mber of flux sur
+0002ce20: 6661 6365 730a 2020 2020 2020 2020 6e6c  faces.        nl
+0002ce30: 6f73 203a 2069 6e74 0a20 2020 2020 2020  os : int.       
+0002ce40: 2020 2020 4e75 6d62 6572 206f 6620 4c4f      Number of LO
+0002ce50: 530a 2020 2020 2020 2020 7261 795f 6f72  S.        ray_or
+0002ce60: 6967 203a 2028 332c 206e 6c6f 7329 2064  ig : (3, nlos) d
+0002ce70: 6f75 626c 6520 6172 7261 790a 2020 2020  ouble array.    
+0002ce80: 2020 2020 2020 204c 4f53 206f 7269 6769         LOS origi
+0002ce90: 6e20 706f 696e 7473 2063 6f6f 7264 696e  n points coordin
+0002cea0: 6174 6573 0a20 2020 2020 2020 2072 6179  ates.        ray
+0002ceb0: 5f76 6469 7220 3a20 2833 2c20 6e6c 6f73  _vdir : (3, nlos
+0002cec0: 2920 646f 7562 6c65 2061 7272 6179 0a20  ) double array. 
+0002ced0: 2020 2020 2020 2020 2020 4c4f 5320 6e6f            LOS no
+0002cee0: 726d 616c 697a 6564 2064 6972 6563 7469  rmalized directi
+0002cef0: 6f6e 2076 6563 746f 720a 2020 2020 2020  on vector.      
+0002cf00: 2020 7665 735f 706f 6c79 203a 2028 6e75    ves_poly : (nu
+0002cf10: 6d5f 706f 6c2c 2032 2c20 6e75 6d5f 7665  m_pol, 2, num_ve
+0002cf20: 7274 6578 2920 646f 7562 6c65 2061 7272  rtex) double arr
+0002cf30: 6179 0a20 2020 2020 2020 2020 2020 436f  ay.           Co
+0002cf40: 6f72 6469 6e61 7465 7320 6f66 2074 6865  ordinates of the
+0002cf50: 2076 6572 7469 6365 7320 6f66 2074 6865   vertices of the
+0002cf60: 2050 6f6c 7967 6f6e 2064 6566 696e 696e   Polygon definin
+0002cf70: 6720 7468 6520 3244 2070 6f6c 6f69 6461  g the 2D poloida
+0002cf80: 6c0a 2020 2020 2020 2020 2020 2063 7574  l.           cut
+0002cf90: 206f 6620 7468 6520 6469 6666 6572 656e   of the differen
+0002cfa0: 7420 494e 2073 7572 6661 6365 730a 2020  t IN surfaces.  
+0002cfb0: 2020 2020 2020 2020 2057 4152 4e49 4e47           WARNING
+0002cfc0: 203a 2077 6520 7375 7070 6f73 6520 616c   : we suppose al
+0002cfd0: 6c20 706f 6c79 2061 7265 206e 6573 7465  l poly are neste
+0002cfe0: 6420 696e 2065 6163 6820 6f74 6865 722c  d in each other,
+0002cff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002d000: 2020 2020 2020 6672 6f6d 2069 6e6e 6572        from inner
+0002d010: 2074 6f20 6f75 7465 720a 2020 2020 2020   to outer.      
+0002d020: 2020 6570 735f 3c76 616c 3e20 3a20 646f    eps_<val> : do
+0002d030: 7562 6c65 0a20 2020 2020 2020 2020 2020  uble.           
+0002d040: 536d 616c 6c20 7661 6c75 652c 2061 6363  Small value, acc
+0002d050: 6570 7461 6e63 6520 6f66 2065 7272 6f72  eptance of error
+0002d060: 0a20 2020 2052 6574 7572 6e73 0a20 2020  .    Returns.   
+0002d070: 203d 3d3d 3d3d 3d3d 0a20 2020 2020 2020   =======.       
+0002d080: 206b 6d69 6e5f 7670 6f6c 7920 3a20 286e   kmin_vpoly : (n
+0002d090: 706f 6c79 2c20 6e6c 6f73 2920 646f 7562  poly, nlos) doub
+0002d0a0: 6c65 2061 7272 6179 0a20 2020 2020 2020  le array.       
+0002d0b0: 2020 2020 204f 6620 7468 6520 666f 726d       Of the form
+0002d0c0: 205b 6b5f 3030 2c20 6b5f 3031 2c20 2e2e   [k_00, k_01, ..
+0002d0d0: 2e2c 206b 5f30 6e2c 206b 5f31 302c 206b  ., k_0n, k_10, k
+0002d0e0: 5f31 312c 202e 2e2e 2c20 6b5f 316e 2c20  _11, ..., k_1n, 
+0002d0f0: 2e2e 2e5d 0a20 2020 2020 2020 2020 2020  ...].           
+0002d100: 2077 6865 7265 206b 5f69 6a20 6973 2074   where k_ij is t
+0002d110: 6865 2063 6f65 6666 6963 6965 6e74 2066  he coefficient f
+0002d120: 6f72 2074 6865 206a 2d74 6820 666c 7578  or the j-th flux
+0002d130: 2073 7572 6661 6365 0a20 2020 2020 2020   surface.       
+0002d140: 2020 2020 2073 7563 6820 7468 6174 2074       such that t
+0002d150: 6865 2069 2d74 6820 7261 7920 284c 4f53  he i-th ray (LOS
+0002d160: 2920 6973 2063 6c6f 7365 7374 2074 6f20  ) is closest to 
+0002d170: 7468 6520 6578 7472 7564 6564 2070 6f6c  the extruded pol
+0002d180: 7967 6f6e 0a20 2020 2020 2020 2020 2020  ygon.           
+0002d190: 2061 7420 7468 6520 706f 696e 7420 505f   at the point P_
+0002d1a0: 6920 3d20 6f72 6967 5b69 5d20 2b20 6b6d  i = orig[i] + km
+0002d1b0: 696e 5b69 5d20 2a20 7664 6972 5b69 5d0a  in[i] * vdir[i].
+0002d1c0: 2020 2020 2020 2020 6469 7374 5f76 706f          dist_vpo
+0002d1d0: 6c79 203a 2028 6e70 6f6c 792c 206e 6c6f  ly : (npoly, nlo
+0002d1e0: 7329 2064 6f75 626c 6520 6172 7261 790a  s) double array.
+0002d1f0: 2020 2020 2020 2020 2020 2020 6064 6973              `dis
+0002d200: 7461 6e63 655b 6920 2a20 6e75 6d5f 706f  tance[i * num_po
+0002d210: 6c79 202b 206a 5d60 2069 7320 7468 6520  ly + j]` is the 
+0002d220: 6469 7374 616e 6365 2066 726f 6d20 505f  distance from P_
+0002d230: 6920 746f 2074 6865 2069 2d74 680a 2020  i to the i-th.  
+0002d240: 2020 2020 2020 2020 2020 6578 7472 7564            extrud
+0002d250: 6564 2070 6f6c 792e 0a20 2020 202d 2d2d  ed poly..    ---
+0002d260: 0a20 2020 2054 6869 7320 6973 2074 6865  .    This is the
+0002d270: 2050 5954 484f 4e20 6675 6e63 7469 6f6e   PYTHON function
+0002d280: 2c20 7573 6520 6f6e 6c79 2069 6620 796f  , use only if yo
+0002d290: 7520 6e65 6564 2074 6869 7320 636f 6d70  u need this comp
+0002d2a0: 7574 6174 696f 6e20 6672 6f6d 0a20 2020  utation from.   
+0002d2b0: 2050 7974 686f 6e2c 2069 6620 796f 7520   Python, if you 
+0002d2c0: 6e65 6564 2069 7420 6672 6f6d 2063 7974  need it from cyt
+0002d2d0: 686f 6e2c 2075 7365 2060 636f 6d70 5f64  hon, use `comp_d
+0002d2e0: 6973 745f 6c6f 735f 7670 6f6c 795f 7665  ist_los_vpoly_ve
+0002d2f0: 635f 636f 7265 600a 2020 2020 2222 220a  c_core`.    """.
+0002d300: 2020 2020 6966 206e 6f74 2061 6c67 6f5f      if not algo_
+0002d310: 7479 7065 2e6c 6f77 6572 2829 203d 3d20  type.lower() == 
+0002d320: 2273 696d 706c 6522 206f 7220 6e6f 7420  "simple" or not 
+0002d330: 7665 735f 7479 7065 2e6c 6f77 6572 2829  ves_type.lower()
+0002d340: 203d 3d20 2274 6f72 223a 0a20 2020 2020   == "tor":.     
+0002d350: 2020 2061 7373 6572 7420 4661 6c73 652c     assert False,
+0002d360: 2022 5468 6520 6675 6e63 7469 6f6e 2069   "The function i
+0002d370: 7320 6f6e 6c79 2069 6d70 6c65 6d65 6e74  s only implement
+0002d380: 6564 2077 6974 6820 7468 6520 7369 6d70  ed with the simp
+0002d390: 6c65 225c 0a20 2020 2020 2020 2020 2020  le"\.           
+0002d3a0: 202b 2022 2061 6c67 6f72 6974 686d 2061   + " algorithm a
+0002d3b0: 6e64 2066 6f72 2074 6f72 6f69 6461 6c20  nd for toroidal 
+0002d3c0: 7665 7373 656c 732e 2e2e 2053 6f72 7279  vessels... Sorry
+0002d3d0: 2122 0a20 2020 2077 6172 6e28 2254 6869  !".    warn("Thi
+0002d3e0: 7320 6675 6e63 7469 6f6e 2073 7570 706f  s function suppo
+0002d3f0: 7365 7320 7468 6174 2074 6865 2070 6f6c  ses that the pol
+0002d400: 7973 2061 7265 206e 6573 7465 6420 6672  ys are nested fr
+0002d410: 6f6d 2069 6e6e 6572 2074 6f20 6f75 7465  om inner to oute
+0002d420: 7222 2c0a 2020 2020 2020 2020 2057 6172  r",.         War
+0002d430: 6e69 6e67 290a 0a20 2020 2063 6465 6620  ning)..    cdef 
+0002d440: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+0002d450: 652c 206e 6469 6d3d 315d 206b 6d69 6e20  e, ndim=1] kmin 
+0002d460: 3d20 6e70 2e65 6d70 7479 2828 6e76 706f  = np.empty((nvpo
+0002d470: 6c79 2a6e 6c6f 732c 292c 2064 7479 7065  ly*nlos,), dtype
+0002d480: 3d66 6c6f 6174 290a 2020 2020 6364 6566  =float).    cdef
+0002d490: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
+0002d4a0: 6c65 2c20 6e64 696d 3d31 5d20 6469 7374  le, ndim=1] dist
+0002d4b0: 203d 206e 702e 656d 7074 7928 286e 7670   = np.empty((nvp
+0002d4c0: 6f6c 792a 6e6c 6f73 2c29 2c20 6474 7970  oly*nlos,), dtyp
+0002d4d0: 653d 666c 6f61 7429 0a20 2020 2063 6465  e=float).    cde
+0002d4e0: 6620 696e 7420 616c 676f 5f6e 756d 203d  f int algo_num =
+0002d4f0: 2030 0a20 2020 2063 6465 6620 696e 7420   0.    cdef int 
+0002d500: 7665 735f 6e75 6d20 3d20 310a 2020 2020  ves_num = 1.    
+0002d510: 5f64 742e 636f 6d70 5f64 6973 745f 6c6f  _dt.comp_dist_lo
+0002d520: 735f 7670 6f6c 795f 7665 635f 636f 7265  s_vpoly_vec_core
+0002d530: 286e 7670 6f6c 792c 206e 6c6f 732c 0a20  (nvpoly, nlos,. 
+0002d540: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002d550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d560: 2020 2020 2020 203c 646f 7562 6c65 2a3e         <double*>
-0002d570: 7261 795f 6f72 6967 2e64 6174 612c 0a20  ray_orig.data,. 
+0002d560: 2020 203c 646f 7562 6c65 2a3e 7261 795f     <double*>ray_
+0002d570: 6f72 6967 2e64 6174 612c 0a20 2020 2020  orig.data,.     
 0002d580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d5a0: 2020 203c 646f 7562 6c65 2a3e 7261 795f     <double*>ray_
-0002d5b0: 7664 6972 2e64 6174 612c 0a20 2020 2020  vdir.data,.     
+0002d590: 2020 2020 2020 2020 2020 2020 2020 203c                 <
+0002d5a0: 646f 7562 6c65 2a3e 7261 795f 7664 6972  double*>ray_vdir
+0002d5b0: 2e64 6174 612c 0a20 2020 2020 2020 2020  .data,.         
 0002d5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d5d0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-0002d5e0: 6573 5f70 6f6c 792c 0a20 2020 2020 2020  es_poly,.       
+0002d5d0: 2020 2020 2020 2020 2020 2076 6573 5f70             ves_p
+0002d5e0: 6f6c 792c 0a20 2020 2020 2020 2020 2020  oly,.           
 0002d5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d600: 2020 2020 2020 2020 2020 2020 2065 7073               eps
-0002d610: 5f75 7a2c 2065 7073 5f61 2c0a 2020 2020  _uz, eps_a,.    
+0002d600: 2020 2020 2020 2020 2065 7073 5f75 7a2c           eps_uz,
+0002d610: 2065 7073 5f61 2c0a 2020 2020 2020 2020   eps_a,.        
 0002d620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d640: 6570 735f 767a 2c20 6570 735f 622c 0a20  eps_vz, eps_b,. 
+0002d630: 2020 2020 2020 2020 2020 2020 6570 735f              eps_
+0002d640: 767a 2c20 6570 735f 622c 0a20 2020 2020  vz, eps_b,.     
 0002d650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d670: 2020 2065 7073 5f70 6c61 6e65 2c0a 2020     eps_plane,.  
+0002d660: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0002d670: 7073 5f70 6c61 6e65 2c0a 2020 2020 2020  ps_plane,.      
 0002d680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d6a0: 2020 7665 735f 6e75 6d2c 0a20 2020 2020    ves_num,.     
+0002d690: 2020 2020 2020 2020 2020 2020 2020 7665                ve
+0002d6a0: 735f 6e75 6d2c 0a20 2020 2020 2020 2020  s_num,.         
 0002d6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d6c0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0002d6d0: 6c67 6f5f 6e75 6d2c 0a20 2020 2020 2020  lgo_num,.       
+0002d6c0: 2020 2020 2020 2020 2020 2061 6c67 6f5f             algo_
+0002d6d0: 6e75 6d2c 0a20 2020 2020 2020 2020 2020  num,.           
 0002d6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d6f0: 2020 2020 2020 2020 2020 2020 2026 6b6d               &km
-0002d700: 696e 5b30 5d2c 2026 6469 7374 5b30 5d2c  in[0], &dist[0],
-0002d710: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002d6f0: 2020 2020 2020 2020 2026 6b6d 696e 5b30           &kmin[0
+0002d700: 5d2c 2026 6469 7374 5b30 5d2c 0a20 2020  ], &dist[0],.   
+0002d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002d720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d730: 2020 2020 2030 2e30 352c 0a20 2020 2020       0.05,.     
+0002d730: 2030 2e30 352c 0a20 2020 2020 2020 2020   0.05,.         
 0002d740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d750: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0002d760: 756d 5f74 6872 6561 6473 290a 2020 2020  um_threads).    
-0002d770: 7265 7475 726e 206b 6d69 6e2e 7265 7368  return kmin.resh
-0002d780: 6170 6528 6e6c 6f73 2c20 6e76 706f 6c79  ape(nlos, nvpoly
-0002d790: 292c 5c0a 2020 2020 2020 2020 6469 7374  ),\.        dist
-0002d7a0: 2e72 6573 6861 7065 286e 6c6f 732c 206e  .reshape(nlos, n
-0002d7b0: 7670 6f6c 7929 0a0a 2320 3d3d 3d3d 3d3d  vpoly)..# ======
+0002d750: 2020 2020 2020 2020 2020 206e 756d 5f74             num_t
+0002d760: 6872 6561 6473 290a 2020 2020 7265 7475  hreads).    retu
+0002d770: 726e 206b 6d69 6e2e 7265 7368 6170 6528  rn kmin.reshape(
+0002d780: 6e6c 6f73 2c20 6e76 706f 6c79 292c 5c0a  nlos, nvpoly),\.
+0002d790: 2020 2020 2020 2020 6469 7374 2e72 6573          dist.res
+0002d7a0: 6861 7065 286e 6c6f 732c 206e 7670 6f6c  hape(nlos, nvpol
+0002d7b0: 7929 0a0a 2320 3d3d 3d3d 3d3d 3d3d 3d3d  y)..# ==========
 0002d7c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002d7d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002d7e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002d7f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002d800: 3d3d 3d3d 3d3d 3d3d 0a23 0a23 2020 2020  ========.#.#    
+0002d800: 3d3d 3d3d 0a23 0a23 2020 2020 2020 2020  ====.#.#        
 0002d810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d820: 2020 2020 2041 5245 204c 4f53 2041 4e44       ARE LOS AND
-0002d830: 2045 5854 2d50 4f4c 5920 434c 4f53 450a   EXT-POLY CLOSE.
-0002d840: 230a 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  #.# ============
+0002d820: 2041 5245 204c 4f53 2041 4e44 2045 5854   ARE LOS AND EXT
+0002d830: 2d50 4f4c 5920 434c 4f53 450a 230a 2320  -POLY CLOSE.#.# 
+0002d840: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002d850: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002d860: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002d870: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002d880: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002d890: 3d3d 0a0a 6465 6620 6973 5f63 6c6f 7365  ==..def is_close
-0002d8a0: 5f6c 6f73 5f76 706f 6c79 5f76 6563 2869  _los_vpoly_vec(i
-0002d8b0: 6e74 206e 7670 6f6c 792c 2069 6e74 206e  nt nvpoly, int n
-0002d8c0: 6c6f 732c 0a20 2020 2020 2020 2020 2020  los,.           
-0002d8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d8e0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0002d8f0: 652c 6e64 696d 3d32 2c6d 6f64 653d 2763  e,ndim=2,mode='c
-0002d900: 275d 2072 6179 5f6f 7269 672c 0a20 2020  '] ray_orig,.   
+0002d880: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a  ==============..
+0002d890: 6465 6620 6973 5f63 6c6f 7365 5f6c 6f73  def is_close_los
+0002d8a0: 5f76 706f 6c79 5f76 6563 2869 6e74 206e  _vpoly_vec(int n
+0002d8b0: 7670 6f6c 792c 2069 6e74 206e 6c6f 732c  vpoly, int nlos,
+0002d8c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002d8d0: 2020 2020 2020 2020 2020 2020 6e70 2e6e              np.n
+0002d8e0: 6461 7272 6179 5b64 6f75 626c 652c 6e64  darray[double,nd
+0002d8f0: 696d 3d32 2c6d 6f64 653d 2763 275d 2072  im=2,mode='c'] r
+0002d900: 6179 5f6f 7269 672c 0a20 2020 2020 2020  ay_orig,.       
 0002d910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d920: 2020 2020 2020 2020 6e70 2e6e 6461 7272          np.ndarr
-0002d930: 6179 5b64 6f75 626c 652c 6e64 696d 3d32  ay[double,ndim=2
-0002d940: 2c6d 6f64 653d 2763 275d 2072 6179 5f76  ,mode='c'] ray_v
-0002d950: 6469 722c 0a20 2020 2020 2020 2020 2020  dir,.           
-0002d960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d970: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0002d980: 652c 6e64 696d 3d33 2c6d 6f64 653d 2763  e,ndim=3,mode='c
-0002d990: 275d 2076 6573 5f70 6f6c 792c 0a20 2020  '] ves_poly,.   
+0002d920: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
+0002d930: 6f75 626c 652c 6e64 696d 3d32 2c6d 6f64  ouble,ndim=2,mod
+0002d940: 653d 2763 275d 2072 6179 5f76 6469 722c  e='c'] ray_vdir,
+0002d950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002d960: 2020 2020 2020 2020 2020 2020 6e70 2e6e              np.n
+0002d970: 6461 7272 6179 5b64 6f75 626c 652c 6e64  darray[double,nd
+0002d980: 696d 3d33 2c6d 6f64 653d 2763 275d 2076  im=3,mode='c'] v
+0002d990: 6573 5f70 6f6c 792c 0a20 2020 2020 2020  es_poly,.       
 0002d9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d9b0: 2020 2020 2020 2020 646f 7562 6c65 2065          double e
-0002d9c0: 7073 696c 6f6e 2c0a 2020 2020 2020 2020  psilon,.        
-0002d9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002d9e0: 2020 2064 6f75 626c 6520 6570 735f 757a     double eps_uz
-0002d9f0: 3d5f 534d 414c 4c2c 2064 6f75 626c 6520  =_SMALL, double 
-0002da00: 6570 735f 613d 5f56 534d 414c 4c2c 0a20  eps_a=_VSMALL,. 
+0002d9b0: 2020 2020 646f 7562 6c65 2065 7073 696c      double epsil
+0002d9c0: 6f6e 2c0a 2020 2020 2020 2020 2020 2020  on,.            
+0002d9d0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0002d9e0: 6f75 626c 6520 6570 735f 757a 3d5f 534d  ouble eps_uz=_SM
+0002d9f0: 414c 4c2c 2064 6f75 626c 6520 6570 735f  ALL, double eps_
+0002da00: 613d 5f56 534d 414c 4c2c 0a20 2020 2020  a=_VSMALL,.     
 0002da10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002da20: 2020 2020 2020 2020 2020 646f 7562 6c65            double
-0002da30: 2065 7073 5f76 7a3d 5f56 534d 414c 4c2c   eps_vz=_VSMALL,
-0002da40: 2064 6f75 626c 6520 6570 735f 623d 5f56   double eps_b=_V
-0002da50: 534d 414c 4c2c 0a20 2020 2020 2020 2020  SMALL,.         
-0002da60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002da70: 2020 646f 7562 6c65 2065 7073 5f70 6c61    double eps_pla
-0002da80: 6e65 3d5f 5653 4d41 4c4c 2c20 7374 7220  ne=_VSMALL, str 
-0002da90: 7665 735f 7479 7065 3d27 546f 7227 2c0a  ves_type='Tor',.
+0002da20: 2020 2020 2020 646f 7562 6c65 2065 7073        double eps
+0002da30: 5f76 7a3d 5f56 534d 414c 4c2c 2064 6f75  _vz=_VSMALL, dou
+0002da40: 626c 6520 6570 735f 623d 5f56 534d 414c  ble eps_b=_VSMAL
+0002da50: 4c2c 0a20 2020 2020 2020 2020 2020 2020  L,.             
+0002da60: 2020 2020 2020 2020 2020 2020 2020 646f                do
+0002da70: 7562 6c65 2065 7073 5f70 6c61 6e65 3d5f  uble eps_plane=_
+0002da80: 5653 4d41 4c4c 2c20 7374 7220 7665 735f  VSMALL, str ves_
+0002da90: 7479 7065 3d27 546f 7227 2c0a 2020 2020  type='Tor',.    
 0002daa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002dab0: 2020 2020 2020 2020 2020 2073 7472 2061             str a
-0002dac0: 6c67 6f5f 7479 7065 3d27 7369 6d70 6c65  lgo_type='simple
-0002dad0: 272c 2069 6e74 206e 756d 5f74 6872 6561  ', int num_threa
-0002dae0: 6473 3d31 3629 3a0a 2020 2020 2222 220a  ds=16):.    """.
-0002daf0: 2020 2020 5468 6973 2066 756e 6374 696f      This functio
-0002db00: 6e20 7465 7374 7320 6966 2074 6865 2064  n tests if the d
-0002db10: 6973 7461 6e63 6520 6265 7477 6565 6e20  istance between 
-0002db20: 6e6c 6f73 2052 6179 7320 286f 7220 4c4f  nlos Rays (or LO
-0002db30: 5329 2061 6e64 0a20 2020 2073 6576 6572  S) and.    sever
-0002db40: 616c 2060 494e 6020 7374 7275 6374 7572  al `IN` structur
-0002db50: 6573 2028 706f 6c79 676f 6e73 2065 7874  es (polygons ext
-0002db60: 7275 6465 6420 6172 6f75 6e64 2074 6865  ruded around the
-0002db70: 2061 7869 7320 2830 2c30 2c31 292c 0a20   axis (0,0,1),. 
-0002db80: 2020 2065 672e 2066 6c75 7820 7375 7266     eg. flux surf
-0002db90: 6163 6573 2920 6973 2073 6d61 6c6c 6572  aces) is smaller
-0002dba0: 2074 6861 6e20 6065 7073 696c 6f6e 602e   than `epsilon`.
-0002dbb0: 0a20 2020 2046 6f72 206d 6f72 6520 6465  .    For more de
-0002dbc0: 7461 696c 7320 6f6e 2074 6865 2061 6c67  tails on the alg
-0002dbd0: 6f72 6974 686d 2070 6c65 6173 6520 7365  orithm please se
-0002dbe0: 6520 5044 463a 203c 6e61 6d65 5f6f 665f  e PDF: <name_of_
-0002dbf0: 7064 663e 2e70 6466 2023 544f 444f 0a0a  pdf>.pdf #TODO..
-0002dc00: 2020 2020 5061 7261 6d73 0a20 2020 203d      Params.    =
-0002dc10: 3d3d 3d3d 3d0a 2020 2020 2020 2020 6e76  =====.        nv
-0002dc20: 706f 6c79 203a 2069 6e74 0a20 2020 2020  poly : int.     
-0002dc30: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
-0002dc40: 666c 7578 2073 7572 6661 6365 730a 2020  flux surfaces.  
-0002dc50: 2020 2020 2020 6e6c 6f73 203a 2069 6e74        nlos : int
-0002dc60: 0a20 2020 2020 2020 2020 2020 4e75 6d62  .           Numb
-0002dc70: 6572 206f 6620 4c4f 530a 2020 2020 2020  er of LOS.      
-0002dc80: 2020 7261 795f 6f72 6967 203a 2028 332c    ray_orig : (3,
-0002dc90: 206e 6c6f 7329 2064 6f75 626c 6520 6172   nlos) double ar
-0002dca0: 7261 790a 2020 2020 2020 2020 2020 204c  ray.           L
-0002dcb0: 4f53 206f 7269 6769 6e20 706f 696e 7473  OS origin points
-0002dcc0: 2063 6f6f 7264 696e 6174 6573 0a20 2020   coordinates.   
-0002dcd0: 2020 2020 2072 6179 5f76 6469 7220 3a20       ray_vdir : 
-0002dce0: 2833 2c20 6e6c 6f73 2920 646f 7562 6c65  (3, nlos) double
-0002dcf0: 2061 7272 6179 0a20 2020 2020 2020 2020   array.         
-0002dd00: 2020 4c4f 5320 6e6f 726d 616c 697a 6564    LOS normalized
-0002dd10: 2064 6972 6563 7469 6f6e 2076 6563 746f   direction vecto
-0002dd20: 720a 2020 2020 2020 2020 7665 735f 706f  r.        ves_po
-0002dd30: 6c79 203a 2028 6e75 6d5f 706f 6c2c 2032  ly : (num_pol, 2
-0002dd40: 2c20 6e75 6d5f 7665 7274 6578 2920 646f  , num_vertex) do
-0002dd50: 7562 6c65 2061 7272 6179 0a20 2020 2020  uble array.     
-0002dd60: 2020 2020 2020 436f 6f72 6469 6e61 7465        Coordinate
-0002dd70: 7320 6f66 2074 6865 2076 6572 7469 6365  s of the vertice
-0002dd80: 7320 6f66 2074 6865 2050 6f6c 7967 6f6e  s of the Polygon
-0002dd90: 2064 6566 696e 696e 6720 7468 6520 3244   defining the 2D
-0002dda0: 2070 6f6c 6f69 6461 6c0a 2020 2020 2020   poloidal.      
-0002ddb0: 2020 2020 2063 7574 206f 6620 7468 6520       cut of the 
-0002ddc0: 6469 6666 6572 656e 7420 494e 2073 7572  different IN sur
-0002ddd0: 6661 6365 730a 2020 2020 2020 2020 2020  faces.          
-0002dde0: 2057 4152 4e49 4e47 203a 2077 6520 7375   WARNING : we su
-0002ddf0: 7070 6f73 6520 616c 6c20 706f 6c79 2061  ppose all poly a
-0002de00: 7265 206e 6573 7465 6420 696e 2065 6163  re nested in eac
-0002de10: 6820 6f74 6865 722c 0a20 2020 2020 2020  h other,.       
-0002de20: 2020 2020 2020 2020 2020 2020 2020 616e                an
-0002de30: 6420 7468 6520 6669 7273 7420 6f6e 6520  d the first one 
-0002de40: 6973 2074 6865 2073 6d61 6c6c 6573 7420  is the smallest 
-0002de50: 6f6e 650a 2020 2020 2020 2020 6570 7369  one.        epsi
-0002de60: 6c6f 6e20 3a20 646f 7562 6c65 0a20 2020  lon : double.   
-0002de70: 2020 2020 2020 2020 5661 6c75 6520 666f          Value fo
-0002de80: 7220 7465 7374 696e 6720 6966 2064 6973  r testing if dis
-0002de90: 7461 6e63 6520 3c20 6570 7369 6c6f 6e0a  tance < epsilon.
-0002dea0: 2020 2020 2020 2020 6570 735f 3c76 616c          eps_<val
-0002deb0: 3e20 3a20 646f 7562 6c65 0a20 2020 2020  > : double.     
-0002dec0: 2020 2020 2020 536d 616c 6c20 7661 6c75        Small valu
-0002ded0: 652c 2061 6363 6570 7461 6e63 6520 6f66  e, acceptance of
-0002dee0: 2065 7272 6f72 0a20 2020 2052 6574 7572   error.    Retur
-0002def0: 6e73 0a20 2020 203d 3d3d 3d3d 3d3d 0a20  ns.    =======. 
-0002df00: 2020 2020 2020 2061 7265 5f63 6c6f 7365         are_close
-0002df10: 203a 2028 6e70 6f6c 7920 2a20 6e6c 6f73   : (npoly * nlos
-0002df20: 2920 626f 6f6c 2061 7272 6179 0a20 2020  ) bool array.   
-0002df30: 2020 2020 2020 2020 2060 6172 655f 636c           `are_cl
-0002df40: 6f73 655b 6920 2a20 6e75 6d5f 706f 6c79  ose[i * num_poly
-0002df50: 202b 206a 5d60 2069 6e64 6963 6174 6573   + j]` indicates
-0002df60: 2069 6620 6469 7374 616e 6365 2062 6574   if distance bet
-0002df70: 7765 656e 2069 2d74 6820 4c4f 530a 2020  ween i-th LOS.  
-0002df80: 2020 2020 2020 2020 2020 616e 6420 6a2d            and j-
-0002df90: 7468 2070 6f6c 7920 6172 6520 636c 6f73  th poly are clos
-0002dfa0: 6572 2074 6861 6e20 6570 7369 6c6f 6e2e  er than epsilon.
-0002dfb0: 2028 5472 7565 2069 6620 6469 7374 616e   (True if distan
-0002dfc0: 6365 3c65 7073 696c 6f6e 290a 2020 2020  ce<epsilon).    
-0002dfd0: 2d2d 2d0a 2020 2020 5468 6973 2069 7320  ---.    This is 
-0002dfe0: 7468 6520 5059 5448 4f4e 2066 756e 6374  the PYTHON funct
-0002dff0: 696f 6e2c 2075 7365 206f 6e6c 7920 6966  ion, use only if
-0002e000: 2079 6f75 206e 6565 6420 7468 6973 2063   you need this c
-0002e010: 6f6d 7075 7461 7469 6f6e 2066 726f 6d0a  omputation from.
-0002e020: 2020 2020 5079 7468 6f6e 2c20 6966 2079      Python, if y
-0002e030: 6f75 206e 6565 6420 6974 2066 726f 6d20  ou need it from 
-0002e040: 6379 7468 6f6e 2c20 7573 6520 6069 735f  cython, use `is_
-0002e050: 636c 6f73 655f 6c6f 735f 7670 6f6c 795f  close_los_vpoly_
-0002e060: 7665 635f 636f 7265 600a 2020 2020 2222  vec_core`.    ""
-0002e070: 220a 2020 2020 7761 726e 2822 5468 6973  ".    warn("This
-0002e080: 2066 756e 6374 696f 6e20 7375 7070 6f73   function suppos
-0002e090: 6573 2074 6861 7420 7468 6520 706f 6c79  es that the poly
-0002e0a0: 7320 6172 6520 6e65 7374 6564 2066 726f  s are nested fro
-0002e0b0: 6d20 696e 6e65 7220 746f 206f 7574 6572  m inner to outer
-0002e0c0: 222c 0a20 2020 2020 2020 2020 5761 726e  ",.         Warn
-0002e0d0: 696e 6729 0a20 2020 2023 203d 3d3d 3d3d  ing).    # =====
+0002dab0: 2020 2020 2020 2073 7472 2061 6c67 6f5f         str algo_
+0002dac0: 7479 7065 3d27 7369 6d70 6c65 272c 2069  type='simple', i
+0002dad0: 6e74 206e 756d 5f74 6872 6561 6473 3d31  nt num_threads=1
+0002dae0: 3629 3a0a 2020 2020 2222 220a 2020 2020  6):.    """.    
+0002daf0: 5468 6973 2066 756e 6374 696f 6e20 7465  This function te
+0002db00: 7374 7320 6966 2074 6865 2064 6973 7461  sts if the dista
+0002db10: 6e63 6520 6265 7477 6565 6e20 6e6c 6f73  nce between nlos
+0002db20: 2052 6179 7320 286f 7220 4c4f 5329 2061   Rays (or LOS) a
+0002db30: 6e64 0a20 2020 2073 6576 6572 616c 2060  nd.    several `
+0002db40: 494e 6020 7374 7275 6374 7572 6573 2028  IN` structures (
+0002db50: 706f 6c79 676f 6e73 2065 7874 7275 6465  polygons extrude
+0002db60: 6420 6172 6f75 6e64 2074 6865 2061 7869  d around the axi
+0002db70: 7320 2830 2c30 2c31 292c 0a20 2020 2065  s (0,0,1),.    e
+0002db80: 672e 2066 6c75 7820 7375 7266 6163 6573  g. flux surfaces
+0002db90: 2920 6973 2073 6d61 6c6c 6572 2074 6861  ) is smaller tha
+0002dba0: 6e20 6065 7073 696c 6f6e 602e 0a20 2020  n `epsilon`..   
+0002dbb0: 2046 6f72 206d 6f72 6520 6465 7461 696c   For more detail
+0002dbc0: 7320 6f6e 2074 6865 2061 6c67 6f72 6974  s on the algorit
+0002dbd0: 686d 2070 6c65 6173 6520 7365 6520 5044  hm please see PD
+0002dbe0: 463a 203c 6e61 6d65 5f6f 665f 7064 663e  F: <name_of_pdf>
+0002dbf0: 2e70 6466 2023 544f 444f 0a0a 2020 2020  .pdf #TODO..    
+0002dc00: 5061 7261 6d73 0a20 2020 203d 3d3d 3d3d  Params.    =====
+0002dc10: 3d0a 2020 2020 2020 2020 6e76 706f 6c79  =.        nvpoly
+0002dc20: 203a 2069 6e74 0a20 2020 2020 2020 2020   : int.         
+0002dc30: 2020 4e75 6d62 6572 206f 6620 666c 7578    Number of flux
+0002dc40: 2073 7572 6661 6365 730a 2020 2020 2020   surfaces.      
+0002dc50: 2020 6e6c 6f73 203a 2069 6e74 0a20 2020    nlos : int.   
+0002dc60: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
+0002dc70: 6620 4c4f 530a 2020 2020 2020 2020 7261  f LOS.        ra
+0002dc80: 795f 6f72 6967 203a 2028 332c 206e 6c6f  y_orig : (3, nlo
+0002dc90: 7329 2064 6f75 626c 6520 6172 7261 790a  s) double array.
+0002dca0: 2020 2020 2020 2020 2020 204c 4f53 206f             LOS o
+0002dcb0: 7269 6769 6e20 706f 696e 7473 2063 6f6f  rigin points coo
+0002dcc0: 7264 696e 6174 6573 0a20 2020 2020 2020  rdinates.       
+0002dcd0: 2072 6179 5f76 6469 7220 3a20 2833 2c20   ray_vdir : (3, 
+0002dce0: 6e6c 6f73 2920 646f 7562 6c65 2061 7272  nlos) double arr
+0002dcf0: 6179 0a20 2020 2020 2020 2020 2020 4c4f  ay.           LO
+0002dd00: 5320 6e6f 726d 616c 697a 6564 2064 6972  S normalized dir
+0002dd10: 6563 7469 6f6e 2076 6563 746f 720a 2020  ection vector.  
+0002dd20: 2020 2020 2020 7665 735f 706f 6c79 203a        ves_poly :
+0002dd30: 2028 6e75 6d5f 706f 6c2c 2032 2c20 6e75   (num_pol, 2, nu
+0002dd40: 6d5f 7665 7274 6578 2920 646f 7562 6c65  m_vertex) double
+0002dd50: 2061 7272 6179 0a20 2020 2020 2020 2020   array.         
+0002dd60: 2020 436f 6f72 6469 6e61 7465 7320 6f66    Coordinates of
+0002dd70: 2074 6865 2076 6572 7469 6365 7320 6f66   the vertices of
+0002dd80: 2074 6865 2050 6f6c 7967 6f6e 2064 6566   the Polygon def
+0002dd90: 696e 696e 6720 7468 6520 3244 2070 6f6c  ining the 2D pol
+0002dda0: 6f69 6461 6c0a 2020 2020 2020 2020 2020  oidal.          
+0002ddb0: 2063 7574 206f 6620 7468 6520 6469 6666   cut of the diff
+0002ddc0: 6572 656e 7420 494e 2073 7572 6661 6365  erent IN surface
+0002ddd0: 730a 2020 2020 2020 2020 2020 2057 4152  s.           WAR
+0002dde0: 4e49 4e47 203a 2077 6520 7375 7070 6f73  NING : we suppos
+0002ddf0: 6520 616c 6c20 706f 6c79 2061 7265 206e  e all poly are n
+0002de00: 6573 7465 6420 696e 2065 6163 6820 6f74  ested in each ot
+0002de10: 6865 722c 0a20 2020 2020 2020 2020 2020  her,.           
+0002de20: 2020 2020 2020 2020 2020 616e 6420 7468            and th
+0002de30: 6520 6669 7273 7420 6f6e 6520 6973 2074  e first one is t
+0002de40: 6865 2073 6d61 6c6c 6573 7420 6f6e 650a  he smallest one.
+0002de50: 2020 2020 2020 2020 6570 7369 6c6f 6e20          epsilon 
+0002de60: 3a20 646f 7562 6c65 0a20 2020 2020 2020  : double.       
+0002de70: 2020 2020 5661 6c75 6520 666f 7220 7465      Value for te
+0002de80: 7374 696e 6720 6966 2064 6973 7461 6e63  sting if distanc
+0002de90: 6520 3c20 6570 7369 6c6f 6e0a 2020 2020  e < epsilon.    
+0002dea0: 2020 2020 6570 735f 3c76 616c 3e20 3a20      eps_<val> : 
+0002deb0: 646f 7562 6c65 0a20 2020 2020 2020 2020  double.         
+0002dec0: 2020 536d 616c 6c20 7661 6c75 652c 2061    Small value, a
+0002ded0: 6363 6570 7461 6e63 6520 6f66 2065 7272  cceptance of err
+0002dee0: 6f72 0a20 2020 2052 6574 7572 6e73 0a20  or.    Returns. 
+0002def0: 2020 203d 3d3d 3d3d 3d3d 0a20 2020 2020     =======.     
+0002df00: 2020 2061 7265 5f63 6c6f 7365 203a 2028     are_close : (
+0002df10: 6e70 6f6c 7920 2a20 6e6c 6f73 2920 626f  npoly * nlos) bo
+0002df20: 6f6c 2061 7272 6179 0a20 2020 2020 2020  ol array.       
+0002df30: 2020 2020 2060 6172 655f 636c 6f73 655b       `are_close[
+0002df40: 6920 2a20 6e75 6d5f 706f 6c79 202b 206a  i * num_poly + j
+0002df50: 5d60 2069 6e64 6963 6174 6573 2069 6620  ]` indicates if 
+0002df60: 6469 7374 616e 6365 2062 6574 7765 656e  distance between
+0002df70: 2069 2d74 6820 4c4f 530a 2020 2020 2020   i-th LOS.      
+0002df80: 2020 2020 2020 616e 6420 6a2d 7468 2070        and j-th p
+0002df90: 6f6c 7920 6172 6520 636c 6f73 6572 2074  oly are closer t
+0002dfa0: 6861 6e20 6570 7369 6c6f 6e2e 2028 5472  han epsilon. (Tr
+0002dfb0: 7565 2069 6620 6469 7374 616e 6365 3c65  ue if distance<e
+0002dfc0: 7073 696c 6f6e 290a 2020 2020 2d2d 2d0a  psilon).    ---.
+0002dfd0: 2020 2020 5468 6973 2069 7320 7468 6520      This is the 
+0002dfe0: 5059 5448 4f4e 2066 756e 6374 696f 6e2c  PYTHON function,
+0002dff0: 2075 7365 206f 6e6c 7920 6966 2079 6f75   use only if you
+0002e000: 206e 6565 6420 7468 6973 2063 6f6d 7075   need this compu
+0002e010: 7461 7469 6f6e 2066 726f 6d0a 2020 2020  tation from.    
+0002e020: 5079 7468 6f6e 2c20 6966 2079 6f75 206e  Python, if you n
+0002e030: 6565 6420 6974 2066 726f 6d20 6379 7468  eed it from cyth
+0002e040: 6f6e 2c20 7573 6520 6069 735f 636c 6f73  on, use `is_clos
+0002e050: 655f 6c6f 735f 7670 6f6c 795f 7665 635f  e_los_vpoly_vec_
+0002e060: 636f 7265 600a 2020 2020 2222 220a 2020  core`.    """.  
+0002e070: 2020 7761 726e 2822 5468 6973 2066 756e    warn("This fun
+0002e080: 6374 696f 6e20 7375 7070 6f73 6573 2074  ction supposes t
+0002e090: 6861 7420 7468 6520 706f 6c79 7320 6172  hat the polys ar
+0002e0a0: 6520 6e65 7374 6564 2066 726f 6d20 696e  e nested from in
+0002e0b0: 6e65 7220 746f 206f 7574 6572 222c 0a20  ner to outer",. 
+0002e0c0: 2020 2020 2020 2020 5761 726e 696e 6729          Warning)
+0002e0d0: 0a20 2020 2023 203d 3d3d 3d3d 3d3d 3d3d  .    # =========
 0002e0e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e0f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e100: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e110: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002e120: 3d3d 3d3d 3d0a 2020 2020 6966 206e 6f74  =====.    if not
-0002e130: 2061 6c67 6f5f 7479 7065 2e6c 6f77 6572   algo_type.lower
-0002e140: 2829 203d 3d20 2273 696d 706c 6522 206f  () == "simple" o
-0002e150: 7220 6e6f 7420 7665 735f 7479 7065 2e6c  r not ves_type.l
-0002e160: 6f77 6572 2829 203d 3d20 2274 6f72 223a  ower() == "tor":
-0002e170: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
-0002e180: 4661 6c73 652c 2022 5468 6520 6675 6e63  False, "The func
-0002e190: 7469 6f6e 2069 7320 6f6e 6c79 2069 6d70  tion is only imp
-0002e1a0: 6c65 6d65 6e74 6564 2077 6974 6820 7468  lemented with th
-0002e1b0: 6520 7369 6d70 6c65 225c 0a20 2020 2020  e simple"\.     
-0002e1c0: 2020 2020 2020 202b 2022 2061 6c67 6f72         + " algor
-0002e1d0: 6974 686d 2061 6e64 2066 6f72 2074 6f72  ithm and for tor
-0002e1e0: 6f69 6461 6c20 7665 7373 656c 732e 2e2e  oidal vessels...
-0002e1f0: 2053 6f72 7279 2122 0a20 2020 2077 6172   Sorry!".    war
-0002e200: 6e28 2254 6869 7320 6675 6e63 7469 6f6e  n("This function
-0002e210: 2073 7570 706f 7365 7320 7468 6174 2074   supposes that t
-0002e220: 6865 2070 6f6c 7973 2061 7265 206e 6573  he polys are nes
-0002e230: 7465 6420 6672 6f6d 2069 6e6e 6572 2074  ted from inner t
-0002e240: 6f20 6f75 7465 7222 2c0a 2020 2020 2020  o outer",.      
-0002e250: 2020 2057 6172 6e69 6e67 290a 2020 2020     Warning).    
-0002e260: 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  # ==============
+0002e120: 3d0a 2020 2020 6966 206e 6f74 2061 6c67  =.    if not alg
+0002e130: 6f5f 7479 7065 2e6c 6f77 6572 2829 203d  o_type.lower() =
+0002e140: 3d20 2273 696d 706c 6522 206f 7220 6e6f  = "simple" or no
+0002e150: 7420 7665 735f 7479 7065 2e6c 6f77 6572  t ves_type.lower
+0002e160: 2829 203d 3d20 2274 6f72 223a 0a20 2020  () == "tor":.   
+0002e170: 2020 2020 2061 7373 6572 7420 4661 6c73       assert Fals
+0002e180: 652c 2022 5468 6520 6675 6e63 7469 6f6e  e, "The function
+0002e190: 2069 7320 6f6e 6c79 2069 6d70 6c65 6d65   is only impleme
+0002e1a0: 6e74 6564 2077 6974 6820 7468 6520 7369  nted with the si
+0002e1b0: 6d70 6c65 225c 0a20 2020 2020 2020 2020  mple"\.         
+0002e1c0: 2020 202b 2022 2061 6c67 6f72 6974 686d     + " algorithm
+0002e1d0: 2061 6e64 2066 6f72 2074 6f72 6f69 6461   and for toroida
+0002e1e0: 6c20 7665 7373 656c 732e 2e2e 2053 6f72  l vessels... Sor
+0002e1f0: 7279 2122 0a20 2020 2077 6172 6e28 2254  ry!".    warn("T
+0002e200: 6869 7320 6675 6e63 7469 6f6e 2073 7570  his function sup
+0002e210: 706f 7365 7320 7468 6174 2074 6865 2070  poses that the p
+0002e220: 6f6c 7973 2061 7265 206e 6573 7465 6420  olys are nested 
+0002e230: 6672 6f6d 2069 6e6e 6572 2074 6f20 6f75  from inner to ou
+0002e240: 7465 7222 2c0a 2020 2020 2020 2020 2057  ter",.         W
+0002e250: 6172 6e69 6e67 290a 2020 2020 2320 3d3d  arning).    # ==
+0002e260: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e270: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e280: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e290: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002e2a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a 2020  ============..  
-0002e2b0: 2020 6364 6566 2061 7272 6179 2061 7265    cdef array are
-0002e2c0: 5f63 6c6f 7365 203d 2063 6c6f 6e65 2861  _close = clone(a
-0002e2d0: 7272 6179 2827 6927 292c 206e 7670 6f6c  rray('i'), nvpol
-0002e2e0: 792a 6e6c 6f73 2c20 5472 7565 290a 2020  y*nlos, True).  
-0002e2f0: 2020 5f64 742e 6973 5f63 6c6f 7365 5f6c    _dt.is_close_l
-0002e300: 6f73 5f76 706f 6c79 5f76 6563 5f63 6f72  os_vpoly_vec_cor
-0002e310: 6528 6e76 706f 6c79 2c20 6e6c 6f73 2c0a  e(nvpoly, nlos,.
+0002e2a0: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 6364  ========..    cd
+0002e2b0: 6566 2061 7272 6179 2061 7265 5f63 6c6f  ef array are_clo
+0002e2c0: 7365 203d 2063 6c6f 6e65 2861 7272 6179  se = clone(array
+0002e2d0: 2827 6927 292c 206e 7670 6f6c 792a 6e6c  ('i'), nvpoly*nl
+0002e2e0: 6f73 2c20 5472 7565 290a 2020 2020 5f64  os, True).    _d
+0002e2f0: 742e 6973 5f63 6c6f 7365 5f6c 6f73 5f76  t.is_close_los_v
+0002e300: 706f 6c79 5f76 6563 5f63 6f72 6528 6e76  poly_vec_core(nv
+0002e310: 706f 6c79 2c20 6e6c 6f73 2c0a 2020 2020  poly, nlos,.    
 0002e320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e340: 3c64 6f75 626c 652a 3e72 6179 5f6f 7269  <double*>ray_ori
-0002e350: 672e 6461 7461 2c0a 2020 2020 2020 2020  g.data,.        
+0002e330: 2020 2020 2020 2020 2020 2020 3c64 6f75              <dou
+0002e340: 626c 652a 3e72 6179 5f6f 7269 672e 6461  ble*>ray_orig.da
+0002e350: 7461 2c0a 2020 2020 2020 2020 2020 2020  ta,.            
 0002e360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e370: 2020 2020 2020 2020 3c64 6f75 626c 652a          <double*
-0002e380: 3e72 6179 5f76 6469 722e 6461 7461 2c0a  >ray_vdir.data,.
+0002e370: 2020 2020 3c64 6f75 626c 652a 3e72 6179      <double*>ray
+0002e380: 5f76 6469 722e 6461 7461 2c0a 2020 2020  _vdir.data,.    
 0002e390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e3b0: 7665 735f 706f 6c79 2c0a 2020 2020 2020  ves_poly,.      
+0002e3a0: 2020 2020 2020 2020 2020 2020 7665 735f              ves_
+0002e3b0: 706f 6c79 2c0a 2020 2020 2020 2020 2020  poly,.          
 0002e3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e3d0: 2020 2020 2020 2020 2020 6570 735f 757a            eps_uz
-0002e3e0: 2c20 6570 735f 612c 0a20 2020 2020 2020  , eps_a,.       
+0002e3d0: 2020 2020 2020 6570 735f 757a 2c20 6570        eps_uz, ep
+0002e3e0: 735f 612c 0a20 2020 2020 2020 2020 2020  s_a,.           
 0002e3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e400: 2020 2020 2020 2020 2065 7073 5f76 7a2c           eps_vz,
-0002e410: 2065 7073 5f62 2c0a 2020 2020 2020 2020   eps_b,.        
+0002e400: 2020 2020 2065 7073 5f76 7a2c 2065 7073       eps_vz, eps
+0002e410: 5f62 2c0a 2020 2020 2020 2020 2020 2020  _b,.            
 0002e420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e430: 2020 2020 2020 2020 6570 735f 706c 616e          eps_plan
-0002e440: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-0002e450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e460: 2020 2065 7073 696c 6f6e 2c0a 2020 2020     epsilon,.    
+0002e430: 2020 2020 6570 735f 706c 616e 652c 0a20      eps_plane,. 
+0002e440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002e450: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0002e460: 7073 696c 6f6e 2c0a 2020 2020 2020 2020  psilon,.        
 0002e470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e480: 2020 2020 2020 2020 2020 2020 6172 655f              are_
-0002e490: 636c 6f73 652c 0a20 2020 2020 2020 2020  close,.         
+0002e480: 2020 2020 2020 2020 6172 655f 636c 6f73          are_clos
+0002e490: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
 0002e4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e4b0: 2020 2020 2020 206e 756d 5f74 6872 6561         num_threa
-0002e4c0: 6473 290a 2020 2020 7265 7475 726e 206e  ds).    return n
-0002e4d0: 702e 6173 6172 7261 7928 6172 655f 636c  p.asarray(are_cl
-0002e4e0: 6f73 652c 2064 7479 7065 3d62 6f6f 6c29  ose, dtype=bool)
-0002e4f0: 2e72 6573 6861 7065 286e 6c6f 732c 206e  .reshape(nlos, n
-0002e500: 7670 6f6c 7929 0a0a 2320 3d3d 3d3d 3d3d  vpoly)..# ======
+0002e4b0: 2020 206e 756d 5f74 6872 6561 6473 290a     num_threads).
+0002e4c0: 2020 2020 7265 7475 726e 206e 702e 6173      return np.as
+0002e4d0: 6172 7261 7928 6172 655f 636c 6f73 652c  array(are_close,
+0002e4e0: 2064 7479 7065 3d62 6f6f 6c29 2e72 6573   dtype=bool).res
+0002e4f0: 6861 7065 286e 6c6f 732c 206e 7670 6f6c  hape(nlos, nvpol
+0002e500: 7929 0a0a 2320 3d3d 3d3d 3d3d 3d3d 3d3d  y)..# ==========
 0002e510: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e520: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e530: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e540: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002e550: 3d3d 3d3d 3d3d 3d3d 0a23 0a23 2020 2020  ========.#.#    
+0002e550: 3d3d 3d3d 0a23 0a23 2020 2020 2020 2020  ====.#.#        
 0002e560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e570: 2020 2020 2057 4849 4348 204c 4f53 2f56       WHICH LOS/V
-0002e580: 504f 4c59 2049 5320 434c 4f53 4552 0a23  POLY IS CLOSER.#
-0002e590: 0a23 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  .# =============
+0002e570: 2057 4849 4348 204c 4f53 2f56 504f 4c59   WHICH LOS/VPOLY
+0002e580: 2049 5320 434c 4f53 4552 0a23 0a23 203d   IS CLOSER.#.# =
+0002e590: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e5a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e5b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002e5c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002e5d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002e5e0: 3d0a 0a64 6566 2077 6869 6368 5f6c 6f73  =..def which_los
-0002e5f0: 5f63 6c6f 7365 725f 7670 6f6c 795f 7665  _closer_vpoly_ve
-0002e600: 6328 696e 7420 6e76 706f 6c79 2c20 696e  c(int nvpoly, in
-0002e610: 7420 6e6c 6f73 2c0a 2020 2020 2020 2020  t nlos,.        
+0002e5d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 0a64  =============..d
+0002e5e0: 6566 2077 6869 6368 5f6c 6f73 5f63 6c6f  ef which_los_clo
+0002e5f0: 7365 725f 7670 6f6c 795f 7665 6328 696e  ser_vpoly_vec(in
+0002e600: 7420 6e76 706f 6c79 2c20 696e 7420 6e6c  t nvpoly, int nl
+0002e610: 6f73 2c0a 2020 2020 2020 2020 2020 2020  os,.            
 0002e620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e630: 2020 2020 2020 206e 702e 6e64 6172 7261         np.ndarra
-0002e640: 795b 646f 7562 6c65 2c6e 6469 6d3d 322c  y[double,ndim=2,
-0002e650: 6d6f 6465 3d27 6327 5d20 7261 795f 6f72  mode='c'] ray_or
-0002e660: 6967 2c0a 2020 2020 2020 2020 2020 2020  ig,.            
-0002e670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e680: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
-0002e690: 7562 6c65 2c6e 6469 6d3d 322c 6d6f 6465  uble,ndim=2,mode
-0002e6a0: 3d27 6327 5d20 7261 795f 7664 6972 2c0a  ='c'] ray_vdir,.
+0002e630: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
+0002e640: 7562 6c65 2c6e 6469 6d3d 322c 6d6f 6465  uble,ndim=2,mode
+0002e650: 3d27 6327 5d20 7261 795f 6f72 6967 2c0a  ='c'] ray_orig,.
+0002e660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002e670: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0002e680: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+0002e690: 2c6e 6469 6d3d 322c 6d6f 6465 3d27 6327  ,ndim=2,mode='c'
+0002e6a0: 5d20 7261 795f 7664 6972 2c0a 2020 2020  ] ray_vdir,.    
 0002e6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e6c0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0002e6d0: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-0002e6e0: 2c6e 6469 6d3d 332c 6d6f 6465 3d27 6327  ,ndim=3,mode='c'
-0002e6f0: 5d20 7665 735f 706f 6c79 2c0a 2020 2020  ] ves_poly,.    
+0002e6c0: 2020 2020 2020 2020 2020 206e 702e 6e64             np.nd
+0002e6d0: 6172 7261 795b 646f 7562 6c65 2c6e 6469  array[double,ndi
+0002e6e0: 6d3d 332c 6d6f 6465 3d27 6327 5d20 7665  m=3,mode='c'] ve
+0002e6f0: 735f 706f 6c79 2c0a 2020 2020 2020 2020  s_poly,.        
 0002e700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e710: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-0002e720: 6520 6570 735f 757a 3d5f 534d 414c 4c2c  e eps_uz=_SMALL,
-0002e730: 2064 6f75 626c 6520 6570 735f 613d 5f56   double eps_a=_V
-0002e740: 534d 414c 4c2c 0a20 2020 2020 2020 2020  SMALL,.         
+0002e710: 2020 2020 2020 2064 6f75 626c 6520 6570         double ep
+0002e720: 735f 757a 3d5f 534d 414c 4c2c 2064 6f75  s_uz=_SMALL, dou
+0002e730: 626c 6520 6570 735f 613d 5f56 534d 414c  ble eps_a=_VSMAL
+0002e740: 4c2c 0a20 2020 2020 2020 2020 2020 2020  L,.             
 0002e750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e760: 2020 2020 2020 646f 7562 6c65 2065 7073        double eps
-0002e770: 5f76 7a3d 5f56 534d 414c 4c2c 2064 6f75  _vz=_VSMALL, dou
-0002e780: 626c 6520 6570 735f 623d 5f56 534d 414c  ble eps_b=_VSMAL
-0002e790: 4c2c 0a20 2020 2020 2020 2020 2020 2020  L,.             
-0002e7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e7b0: 2020 646f 7562 6c65 2065 7073 5f70 6c61    double eps_pla
-0002e7c0: 6e65 3d5f 5653 4d41 4c4c 2c20 7374 7220  ne=_VSMALL, str 
-0002e7d0: 7665 735f 7479 7065 3d27 546f 7227 2c0a  ves_type='Tor',.
+0002e760: 2020 646f 7562 6c65 2065 7073 5f76 7a3d    double eps_vz=
+0002e770: 5f56 534d 414c 4c2c 2064 6f75 626c 6520  _VSMALL, double 
+0002e780: 6570 735f 623d 5f56 534d 414c 4c2c 0a20  eps_b=_VSMALL,. 
+0002e790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002e7a0: 2020 2020 2020 2020 2020 2020 2020 646f                do
+0002e7b0: 7562 6c65 2065 7073 5f70 6c61 6e65 3d5f  uble eps_plane=_
+0002e7c0: 5653 4d41 4c4c 2c20 7374 7220 7665 735f  VSMALL, str ves_
+0002e7d0: 7479 7065 3d27 546f 7227 2c0a 2020 2020  type='Tor',.    
 0002e7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e7f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0002e800: 7472 2061 6c67 6f5f 7479 7065 3d27 7369  tr algo_type='si
-0002e810: 6d70 6c65 272c 2069 6e74 206e 756d 5f74  mple', int num_t
-0002e820: 6872 6561 6473 3d31 3629 3a0a 2020 2020  hreads=16):.    
-0002e830: 2222 220a 2020 2020 5061 7261 6d73 0a20  """.    Params. 
-0002e840: 2020 203d 3d3d 3d3d 3d0a 2020 2020 2020     ======.      
-0002e850: 2020 6e76 706f 6c79 203a 2069 6e74 0a20    nvpoly : int. 
-0002e860: 2020 2020 2020 2020 2020 4e75 6d62 6572            Number
-0002e870: 206f 6620 666c 7578 2073 7572 6661 6365   of flux surface
-0002e880: 730a 2020 2020 2020 2020 6e6c 6f73 203a  s.        nlos :
-0002e890: 2069 6e74 0a20 2020 2020 2020 2020 2020   int.           
-0002e8a0: 4e75 6d62 6572 206f 6620 4c4f 530a 2020  Number of LOS.  
-0002e8b0: 2020 2020 2020 7261 795f 6f72 6967 203a        ray_orig :
-0002e8c0: 2028 332c 206e 6c6f 7329 2064 6f75 626c   (3, nlos) doubl
-0002e8d0: 6520 6172 7261 790a 2020 2020 2020 2020  e array.        
-0002e8e0: 2020 204c 4f53 206f 7269 6769 6e20 706f     LOS origin po
-0002e8f0: 696e 7473 2063 6f6f 7264 696e 6174 6573  ints coordinates
-0002e900: 0a20 2020 2020 2020 2072 6179 5f76 6469  .        ray_vdi
-0002e910: 7220 3a20 2833 2c20 6e6c 6f73 2920 646f  r : (3, nlos) do
-0002e920: 7562 6c65 2061 7272 6179 0a20 2020 2020  uble array.     
-0002e930: 2020 2020 2020 4c4f 5320 6469 7265 6374        LOS direct
-0002e940: 696f 6e20 7665 6374 6f72 0a20 2020 2020  ion vector.     
-0002e950: 2020 2076 6573 5f70 6f6c 7920 3a20 286e     ves_poly : (n
-0002e960: 756d 5f70 6f6c 2c20 322c 206e 756d 5f76  um_pol, 2, num_v
-0002e970: 6572 7465 7829 2064 6f75 626c 6520 6172  ertex) double ar
-0002e980: 7261 790a 2020 2020 2020 2020 2020 2043  ray.           C
-0002e990: 6f6f 7264 696e 6174 6573 206f 6620 7468  oordinates of th
-0002e9a0: 6520 7665 7274 6963 6573 206f 6620 7468  e vertices of th
-0002e9b0: 6520 506f 6c79 676f 6e20 6465 6669 6e69  e Polygon defini
-0002e9c0: 6e67 2074 6865 2032 4420 706f 6c6f 6964  ng the 2D poloid
-0002e9d0: 616c 0a20 2020 2020 2020 2020 2020 6375  al.           cu
-0002e9e0: 7420 6f66 2074 6865 2064 6966 6665 7265  t of the differe
-0002e9f0: 6e74 2049 4e20 7375 7266 6163 6573 0a20  nt IN surfaces. 
-0002ea00: 2020 2020 2020 2020 2020 5741 524e 494e            WARNIN
-0002ea10: 4720 3a20 7765 2073 7570 706f 7365 2061  G : we suppose a
-0002ea20: 6c6c 2070 6f6c 7920 6172 6520 6e65 7374  ll poly are nest
-0002ea30: 6564 2069 6e20 6561 6368 206f 7468 6572  ed in each other
-0002ea40: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0002ea50: 2020 2020 2020 2061 6e64 2074 6865 2066         and the f
-0002ea60: 6972 7374 206f 6e65 2069 7320 7468 6520  irst one is the 
-0002ea70: 736d 616c 6c65 7374 206f 6e65 0a20 2020  smallest one.   
-0002ea80: 2020 2020 2065 7073 5f3c 7661 6c3e 203a       eps_<val> :
-0002ea90: 2064 6f75 626c 650a 2020 2020 2020 2020   double.        
-0002eaa0: 2020 2053 6d61 6c6c 2076 616c 7565 2c20     Small value, 
-0002eab0: 6163 6365 7074 616e 6365 206f 6620 6572  acceptance of er
-0002eac0: 726f 720a 2020 2020 5265 7475 726e 730a  ror.    Returns.
-0002ead0: 2020 2020 3d3d 3d3d 3d3d 3d0a 2020 2020      =======.    
-0002eae0: 2020 2020 696e 645f 636c 6f73 655f 6c6f      ind_close_lo
-0002eaf0: 7320 3a20 286e 706f 6c79 2920 696e 7420  s : (npoly) int 
-0002eb00: 6172 7261 790a 2020 2020 2020 2020 2020  array.          
-0002eb10: 2020 4f66 2074 6865 2066 6f72 6d20 5b69    Of the form [i
-0002eb20: 6e64 5f30 2c20 696e 645f 312c 202e 2e2e  nd_0, ind_1, ...
-0002eb30: 2c20 696e 645f 286e 706f 6c79 2d31 295d  , ind_(npoly-1)]
-0002eb40: 0a20 2020 2020 2020 2020 2020 2077 6865  .            whe
-0002eb50: 7265 2069 6e64 5f69 2069 7320 7468 6520  re ind_i is the 
-0002eb60: 636f 6566 6669 6369 656e 7420 666f 7220  coefficient for 
-0002eb70: 7468 6520 692d 7468 2066 6c75 7820 7375  the i-th flux su
-0002eb80: 7266 6163 650a 2020 2020 2020 2020 2020  rface.          
-0002eb90: 2020 7375 6368 2074 6861 7420 7468 6520    such that the 
-0002eba0: 696e 645f 692d 7468 2072 6179 2028 4c4f  ind_i-th ray (LO
-0002ebb0: 5329 2069 7320 636c 6f73 6573 7420 746f  S) is closest to
-0002ebc0: 2074 6865 2065 7874 7275 6465 6420 706f   the extruded po
-0002ebd0: 6c79 676f 6e0a 2020 2020 2020 2020 2020  lygon.          
-0002ebe0: 2020 616d 6f6e 6720 616c 6c20 6f74 6865    among all othe
-0002ebf0: 7220 4c4f 5320 7769 7468 6f75 7420 676f  r LOS without go
-0002ec00: 696e 6720 6f76 6572 2069 742e 0a20 2020  ing over it..   
-0002ec10: 202d 2d2d 0a20 2020 2054 6869 7320 6973   ---.    This is
-0002ec20: 2074 6865 2050 5954 484f 4e20 6675 6e63   the PYTHON func
-0002ec30: 7469 6f6e 2c20 7573 6520 6f6e 6c79 2069  tion, use only i
-0002ec40: 6620 796f 7520 6e65 6564 2074 6869 7320  f you need this 
-0002ec50: 636f 6d70 7574 6174 696f 6e20 6672 6f6d  computation from
-0002ec60: 0a20 2020 2050 7974 686f 6e2c 2069 6620  .    Python, if 
-0002ec70: 796f 7520 6e65 6564 2069 7420 6672 6f6d  you need it from
-0002ec80: 2063 7974 686f 6e2c 2075 7365 2060 7768   cython, use `wh
-0002ec90: 6963 685f 6c6f 735f 636c 6f73 6572 5f76  ich_los_closer_v
-0002eca0: 706f 6c79 5f76 6563 5f63 6f72 6560 0a20  poly_vec_core`. 
-0002ecb0: 2020 2022 2222 0a20 2020 2077 6172 6e28     """.    warn(
-0002ecc0: 2254 6869 7320 6675 6e63 7469 6f6e 2073  "This function s
-0002ecd0: 7570 706f 7365 7320 7468 6174 2074 6865  upposes that the
-0002ece0: 2070 6f6c 7973 2061 7265 206e 6573 7465   polys are neste
-0002ecf0: 6420 6672 6f6d 2069 6e6e 6572 2074 6f20  d from inner to 
-0002ed00: 6f75 7465 7222 2c0a 2020 2020 2020 2020  outer",.        
-0002ed10: 2057 6172 6e69 6e67 290a 0a20 2020 2023   Warning)..    #
-0002ed20: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+0002e7f0: 2020 2020 2020 2020 2020 2073 7472 2061             str a
+0002e800: 6c67 6f5f 7479 7065 3d27 7369 6d70 6c65  lgo_type='simple
+0002e810: 272c 2069 6e74 206e 756d 5f74 6872 6561  ', int num_threa
+0002e820: 6473 3d31 3629 3a0a 2020 2020 2222 220a  ds=16):.    """.
+0002e830: 2020 2020 5061 7261 6d73 0a20 2020 203d      Params.    =
+0002e840: 3d3d 3d3d 3d0a 2020 2020 2020 2020 6e76  =====.        nv
+0002e850: 706f 6c79 203a 2069 6e74 0a20 2020 2020  poly : int.     
+0002e860: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
+0002e870: 666c 7578 2073 7572 6661 6365 730a 2020  flux surfaces.  
+0002e880: 2020 2020 2020 6e6c 6f73 203a 2069 6e74        nlos : int
+0002e890: 0a20 2020 2020 2020 2020 2020 4e75 6d62  .           Numb
+0002e8a0: 6572 206f 6620 4c4f 530a 2020 2020 2020  er of LOS.      
+0002e8b0: 2020 7261 795f 6f72 6967 203a 2028 332c    ray_orig : (3,
+0002e8c0: 206e 6c6f 7329 2064 6f75 626c 6520 6172   nlos) double ar
+0002e8d0: 7261 790a 2020 2020 2020 2020 2020 204c  ray.           L
+0002e8e0: 4f53 206f 7269 6769 6e20 706f 696e 7473  OS origin points
+0002e8f0: 2063 6f6f 7264 696e 6174 6573 0a20 2020   coordinates.   
+0002e900: 2020 2020 2072 6179 5f76 6469 7220 3a20       ray_vdir : 
+0002e910: 2833 2c20 6e6c 6f73 2920 646f 7562 6c65  (3, nlos) double
+0002e920: 2061 7272 6179 0a20 2020 2020 2020 2020   array.         
+0002e930: 2020 4c4f 5320 6469 7265 6374 696f 6e20    LOS direction 
+0002e940: 7665 6374 6f72 0a20 2020 2020 2020 2076  vector.        v
+0002e950: 6573 5f70 6f6c 7920 3a20 286e 756d 5f70  es_poly : (num_p
+0002e960: 6f6c 2c20 322c 206e 756d 5f76 6572 7465  ol, 2, num_verte
+0002e970: 7829 2064 6f75 626c 6520 6172 7261 790a  x) double array.
+0002e980: 2020 2020 2020 2020 2020 2043 6f6f 7264             Coord
+0002e990: 696e 6174 6573 206f 6620 7468 6520 7665  inates of the ve
+0002e9a0: 7274 6963 6573 206f 6620 7468 6520 506f  rtices of the Po
+0002e9b0: 6c79 676f 6e20 6465 6669 6e69 6e67 2074  lygon defining t
+0002e9c0: 6865 2032 4420 706f 6c6f 6964 616c 0a20  he 2D poloidal. 
+0002e9d0: 2020 2020 2020 2020 2020 6375 7420 6f66            cut of
+0002e9e0: 2074 6865 2064 6966 6665 7265 6e74 2049   the different I
+0002e9f0: 4e20 7375 7266 6163 6573 0a20 2020 2020  N surfaces.     
+0002ea00: 2020 2020 2020 5741 524e 494e 4720 3a20        WARNING : 
+0002ea10: 7765 2073 7570 706f 7365 2061 6c6c 2070  we suppose all p
+0002ea20: 6f6c 7920 6172 6520 6e65 7374 6564 2069  oly are nested i
+0002ea30: 6e20 6561 6368 206f 7468 6572 2c0a 2020  n each other,.  
+0002ea40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002ea50: 2020 2061 6e64 2074 6865 2066 6972 7374     and the first
+0002ea60: 206f 6e65 2069 7320 7468 6520 736d 616c   one is the smal
+0002ea70: 6c65 7374 206f 6e65 0a20 2020 2020 2020  lest one.       
+0002ea80: 2065 7073 5f3c 7661 6c3e 203a 2064 6f75   eps_<val> : dou
+0002ea90: 626c 650a 2020 2020 2020 2020 2020 2053  ble.           S
+0002eaa0: 6d61 6c6c 2076 616c 7565 2c20 6163 6365  mall value, acce
+0002eab0: 7074 616e 6365 206f 6620 6572 726f 720a  ptance of error.
+0002eac0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
+0002ead0: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
+0002eae0: 696e 645f 636c 6f73 655f 6c6f 7320 3a20  ind_close_los : 
+0002eaf0: 286e 706f 6c79 2920 696e 7420 6172 7261  (npoly) int arra
+0002eb00: 790a 2020 2020 2020 2020 2020 2020 4f66  y.            Of
+0002eb10: 2074 6865 2066 6f72 6d20 5b69 6e64 5f30   the form [ind_0
+0002eb20: 2c20 696e 645f 312c 202e 2e2e 2c20 696e  , ind_1, ..., in
+0002eb30: 645f 286e 706f 6c79 2d31 295d 0a20 2020  d_(npoly-1)].   
+0002eb40: 2020 2020 2020 2020 2077 6865 7265 2069           where i
+0002eb50: 6e64 5f69 2069 7320 7468 6520 636f 6566  nd_i is the coef
+0002eb60: 6669 6369 656e 7420 666f 7220 7468 6520  ficient for the 
+0002eb70: 692d 7468 2066 6c75 7820 7375 7266 6163  i-th flux surfac
+0002eb80: 650a 2020 2020 2020 2020 2020 2020 7375  e.            su
+0002eb90: 6368 2074 6861 7420 7468 6520 696e 645f  ch that the ind_
+0002eba0: 692d 7468 2072 6179 2028 4c4f 5329 2069  i-th ray (LOS) i
+0002ebb0: 7320 636c 6f73 6573 7420 746f 2074 6865  s closest to the
+0002ebc0: 2065 7874 7275 6465 6420 706f 6c79 676f   extruded polygo
+0002ebd0: 6e0a 2020 2020 2020 2020 2020 2020 616d  n.            am
+0002ebe0: 6f6e 6720 616c 6c20 6f74 6865 7220 4c4f  ong all other LO
+0002ebf0: 5320 7769 7468 6f75 7420 676f 696e 6720  S without going 
+0002ec00: 6f76 6572 2069 742e 0a20 2020 202d 2d2d  over it..    ---
+0002ec10: 0a20 2020 2054 6869 7320 6973 2074 6865  .    This is the
+0002ec20: 2050 5954 484f 4e20 6675 6e63 7469 6f6e   PYTHON function
+0002ec30: 2c20 7573 6520 6f6e 6c79 2069 6620 796f  , use only if yo
+0002ec40: 7520 6e65 6564 2074 6869 7320 636f 6d70  u need this comp
+0002ec50: 7574 6174 696f 6e20 6672 6f6d 0a20 2020  utation from.   
+0002ec60: 2050 7974 686f 6e2c 2069 6620 796f 7520   Python, if you 
+0002ec70: 6e65 6564 2069 7420 6672 6f6d 2063 7974  need it from cyt
+0002ec80: 686f 6e2c 2075 7365 2060 7768 6963 685f  hon, use `which_
+0002ec90: 6c6f 735f 636c 6f73 6572 5f76 706f 6c79  los_closer_vpoly
+0002eca0: 5f76 6563 5f63 6f72 6560 0a20 2020 2022  _vec_core`.    "
+0002ecb0: 2222 0a20 2020 2077 6172 6e28 2254 6869  "".    warn("Thi
+0002ecc0: 7320 6675 6e63 7469 6f6e 2073 7570 706f  s function suppo
+0002ecd0: 7365 7320 7468 6174 2074 6865 2070 6f6c  ses that the pol
+0002ece0: 7973 2061 7265 206e 6573 7465 6420 6672  ys are nested fr
+0002ecf0: 6f6d 2069 6e6e 6572 2074 6f20 6f75 7465  om inner to oute
+0002ed00: 7222 2c0a 2020 2020 2020 2020 2057 6172  r",.         War
+0002ed10: 6e69 6e67 290a 0a20 2020 2023 203d 3d3d  ning)..    # ===
+0002ed20: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002ed30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002ed40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002ed50: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002ed60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020 2020  ===========.    
-0002ed70: 6966 206e 6f74 2061 6c67 6f5f 7479 7065  if not algo_type
-0002ed80: 2e6c 6f77 6572 2829 203d 3d20 2273 696d  .lower() == "sim
-0002ed90: 706c 6522 206f 7220 6e6f 7420 7665 735f  ple" or not ves_
-0002eda0: 7479 7065 2e6c 6f77 6572 2829 203d 3d20  type.lower() == 
-0002edb0: 2274 6f72 223a 0a20 2020 2020 2020 2061  "tor":.        a
-0002edc0: 7373 6572 7420 4661 6c73 652c 2022 5468  ssert False, "Th
-0002edd0: 6520 6675 6e63 7469 6f6e 2069 7320 6f6e  e function is on
-0002ede0: 6c79 2069 6d70 6c65 6d65 6e74 6564 2077  ly implemented w
-0002edf0: 6974 6820 7468 6520 7369 6d70 6c65 225c  ith the simple"\
-0002ee00: 0a20 2020 2020 2020 2020 2020 202b 2022  .            + "
-0002ee10: 2061 6c67 6f72 6974 686d 2061 6e64 2066   algorithm and f
-0002ee20: 6f72 2074 6f72 6f69 6461 6c20 7665 7373  or toroidal vess
-0002ee30: 656c 732e 2e2e 2053 6f72 7279 2122 0a20  els... Sorry!". 
-0002ee40: 2020 2077 6172 6e28 2254 6869 7320 6675     warn("This fu
-0002ee50: 6e63 7469 6f6e 2073 7570 706f 7365 7320  nction supposes 
-0002ee60: 7468 6174 2074 6865 2070 6f6c 7973 2061  that the polys a
-0002ee70: 7265 206e 6573 7465 6420 6672 6f6d 2069  re nested from i
-0002ee80: 6e6e 6572 2074 6f20 6f75 7465 7222 2c0a  nner to outer",.
-0002ee90: 2020 2020 2020 2020 2057 6172 6e69 6e67           Warning
-0002eea0: 290a 2020 2020 2320 3d3d 3d3d 3d3d 3d3d  ).    # ========
+0002ed60: 3d3d 3d3d 3d3d 3d0a 2020 2020 6966 206e  =======.    if n
+0002ed70: 6f74 2061 6c67 6f5f 7479 7065 2e6c 6f77  ot algo_type.low
+0002ed80: 6572 2829 203d 3d20 2273 696d 706c 6522  er() == "simple"
+0002ed90: 206f 7220 6e6f 7420 7665 735f 7479 7065   or not ves_type
+0002eda0: 2e6c 6f77 6572 2829 203d 3d20 2274 6f72  .lower() == "tor
+0002edb0: 223a 0a20 2020 2020 2020 2061 7373 6572  ":.        asser
+0002edc0: 7420 4661 6c73 652c 2022 5468 6520 6675  t False, "The fu
+0002edd0: 6e63 7469 6f6e 2069 7320 6f6e 6c79 2069  nction is only i
+0002ede0: 6d70 6c65 6d65 6e74 6564 2077 6974 6820  mplemented with 
+0002edf0: 7468 6520 7369 6d70 6c65 225c 0a20 2020  the simple"\.   
+0002ee00: 2020 2020 2020 2020 202b 2022 2061 6c67           + " alg
+0002ee10: 6f72 6974 686d 2061 6e64 2066 6f72 2074  orithm and for t
+0002ee20: 6f72 6f69 6461 6c20 7665 7373 656c 732e  oroidal vessels.
+0002ee30: 2e2e 2053 6f72 7279 2122 0a20 2020 2077  .. Sorry!".    w
+0002ee40: 6172 6e28 2254 6869 7320 6675 6e63 7469  arn("This functi
+0002ee50: 6f6e 2073 7570 706f 7365 7320 7468 6174  on supposes that
+0002ee60: 2074 6865 2070 6f6c 7973 2061 7265 206e   the polys are n
+0002ee70: 6573 7465 6420 6672 6f6d 2069 6e6e 6572  ested from inner
+0002ee80: 2074 6f20 6f75 7465 7222 2c0a 2020 2020   to outer",.    
+0002ee90: 2020 2020 2057 6172 6e69 6e67 290a 2020       Warning).  
+0002eea0: 2020 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d    # ============
 0002eeb0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002eec0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002eed0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002eee0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002eef0: 3d3d 0a0a 2020 2020 6364 6566 2061 7272  ==..    cdef arr
-0002ef00: 6179 2069 6e64 5f63 6c6f 7365 5f74 6162  ay ind_close_tab
-0002ef10: 203d 2063 6c6f 6e65 2861 7272 6179 2827   = clone(array('
-0002ef20: 6927 292c 206e 7670 6f6c 792c 2054 7275  i'), nvpoly, Tru
-0002ef30: 6529 0a20 2020 205f 6474 2e77 6869 6368  e).    _dt.which
-0002ef40: 5f6c 6f73 5f63 6c6f 7365 725f 7670 6f6c  _los_closer_vpol
-0002ef50: 795f 7665 635f 636f 7265 286e 7670 6f6c  y_vec_core(nvpol
-0002ef60: 792c 206e 6c6f 732c 0a20 2020 2020 2020  y, nlos,.       
+0002eee0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a  ==============..
+0002eef0: 2020 2020 6364 6566 2061 7272 6179 2069      cdef array i
+0002ef00: 6e64 5f63 6c6f 7365 5f74 6162 203d 2063  nd_close_tab = c
+0002ef10: 6c6f 6e65 2861 7272 6179 2827 6927 292c  lone(array('i'),
+0002ef20: 206e 7670 6f6c 792c 2054 7275 6529 0a20   nvpoly, True). 
+0002ef30: 2020 205f 6474 2e77 6869 6368 5f6c 6f73     _dt.which_los
+0002ef40: 5f63 6c6f 7365 725f 7670 6f6c 795f 7665  _closer_vpoly_ve
+0002ef50: 635f 636f 7265 286e 7670 6f6c 792c 206e  c_core(nvpoly, n
+0002ef60: 6c6f 732c 0a20 2020 2020 2020 2020 2020  los,.           
 0002ef70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ef80: 2020 2020 2020 2020 2020 2020 203c 646f               <do
-0002ef90: 7562 6c65 2a3e 7261 795f 6f72 6967 2e64  uble*>ray_orig.d
-0002efa0: 6174 612c 0a20 2020 2020 2020 2020 2020  ata,.           
+0002ef80: 2020 2020 2020 2020 203c 646f 7562 6c65           <double
+0002ef90: 2a3e 7261 795f 6f72 6967 2e64 6174 612c  *>ray_orig.data,
+0002efa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0002efb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002efc0: 2020 2020 2020 2020 203c 646f 7562 6c65           <double
-0002efd0: 2a3e 7261 795f 7664 6972 2e64 6174 612c  *>ray_vdir.data,
-0002efe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002efc0: 2020 2020 203c 646f 7562 6c65 2a3e 7261       <double*>ra
+0002efd0: 795f 7664 6972 2e64 6174 612c 0a20 2020  y_vdir.data,.   
+0002efe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002eff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f000: 2020 2020 2076 6573 5f70 6f6c 792c 0a20       ves_poly,. 
+0002f000: 2076 6573 5f70 6f6c 792c 0a20 2020 2020   ves_poly,.     
 0002f010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f030: 2020 2065 7073 5f75 7a2c 2065 7073 5f61     eps_uz, eps_a
-0002f040: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0002f020: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0002f030: 7073 5f75 7a2c 2065 7073 5f61 2c0a 2020  ps_uz, eps_a,.  
+0002f040: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002f050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f060: 2020 2020 2020 6570 735f 767a 2c20 6570        eps_vz, ep
-0002f070: 735f 622c 0a20 2020 2020 2020 2020 2020  s_b,.           
+0002f060: 2020 6570 735f 767a 2c20 6570 735f 622c    eps_vz, eps_b,
+0002f070: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0002f080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f090: 2020 2020 2020 2020 2065 7073 5f70 6c61           eps_pla
-0002f0a0: 6e65 2c0a 2020 2020 2020 2020 2020 2020  ne,.            
+0002f090: 2020 2020 2065 7073 5f70 6c61 6e65 2c0a       eps_plane,.
+0002f0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002f0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f0c0: 2020 2020 2020 2020 696e 645f 636c 6f73          ind_clos
-0002f0d0: 655f 7461 622c 0a20 2020 2020 2020 2020  e_tab,.         
+0002f0c0: 2020 2020 696e 645f 636c 6f73 655f 7461      ind_close_ta
+0002f0d0: 622c 0a20 2020 2020 2020 2020 2020 2020  b,.             
 0002f0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f0f0: 2020 2020 2020 2020 2020 206e 756d 5f74             num_t
-0002f100: 6872 6561 6473 290a 2020 2020 7265 7475  hreads).    retu
-0002f110: 726e 206e 702e 6173 6172 7261 7928 696e  rn np.asarray(in
-0002f120: 645f 636c 6f73 655f 7461 6229 0a0a 0a64  d_close_tab)...d
-0002f130: 6566 2077 6869 6368 5f76 706f 6c79 5f63  ef which_vpoly_c
-0002f140: 6c6f 7365 725f 6c6f 735f 7665 6328 696e  loser_los_vec(in
-0002f150: 7420 6e76 706f 6c79 2c20 696e 7420 6e6c  t nvpoly, int nl
-0002f160: 6f73 2c0a 2020 2020 2020 2020 2020 2020  os,.            
-0002f170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f180: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
-0002f190: 7562 6c65 2c6e 6469 6d3d 322c 6d6f 6465  uble,ndim=2,mode
-0002f1a0: 3d27 6327 5d20 7261 795f 6f72 6967 2c0a  ='c'] ray_orig,.
+0002f0f0: 2020 2020 2020 206e 756d 5f74 6872 6561         num_threa
+0002f100: 6473 290a 2020 2020 7265 7475 726e 206e  ds).    return n
+0002f110: 702e 6173 6172 7261 7928 696e 645f 636c  p.asarray(ind_cl
+0002f120: 6f73 655f 7461 6229 0a0a 0a64 6566 2077  ose_tab)...def w
+0002f130: 6869 6368 5f76 706f 6c79 5f63 6c6f 7365  hich_vpoly_close
+0002f140: 725f 6c6f 735f 7665 6328 696e 7420 6e76  r_los_vec(int nv
+0002f150: 706f 6c79 2c20 696e 7420 6e6c 6f73 2c0a  poly, int nlos,.
+0002f160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002f170: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0002f180: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+0002f190: 2c6e 6469 6d3d 322c 6d6f 6465 3d27 6327  ,ndim=2,mode='c'
+0002f1a0: 5d20 7261 795f 6f72 6967 2c0a 2020 2020  ] ray_orig,.    
 0002f1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f1c0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0002f1d0: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-0002f1e0: 2c6e 6469 6d3d 322c 6d6f 6465 3d27 6327  ,ndim=2,mode='c'
-0002f1f0: 5d20 7261 795f 7664 6972 2c0a 2020 2020  ] ray_vdir,.    
+0002f1c0: 2020 2020 2020 2020 2020 206e 702e 6e64             np.nd
+0002f1d0: 6172 7261 795b 646f 7562 6c65 2c6e 6469  array[double,ndi
+0002f1e0: 6d3d 322c 6d6f 6465 3d27 6327 5d20 7261  m=2,mode='c'] ra
+0002f1f0: 795f 7664 6972 2c0a 2020 2020 2020 2020  y_vdir,.        
 0002f200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f210: 2020 2020 2020 2020 2020 206e 702e 6e64             np.nd
-0002f220: 6172 7261 795b 646f 7562 6c65 2c6e 6469  array[double,ndi
-0002f230: 6d3d 332c 6d6f 6465 3d27 6327 5d20 7665  m=3,mode='c'] ve
-0002f240: 735f 706f 6c79 2c0a 2020 2020 2020 2020  s_poly,.        
+0002f210: 2020 2020 2020 206e 702e 6e64 6172 7261         np.ndarra
+0002f220: 795b 646f 7562 6c65 2c6e 6469 6d3d 332c  y[double,ndim=3,
+0002f230: 6d6f 6465 3d27 6327 5d20 7665 735f 706f  mode='c'] ves_po
+0002f240: 6c79 2c0a 2020 2020 2020 2020 2020 2020  ly,.            
 0002f250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f260: 2020 2020 2020 2064 6f75 626c 6520 6570         double ep
-0002f270: 735f 757a 3d5f 534d 414c 4c2c 2064 6f75  s_uz=_SMALL, dou
-0002f280: 626c 6520 6570 735f 613d 5f56 534d 414c  ble eps_a=_VSMAL
-0002f290: 4c2c 0a20 2020 2020 2020 2020 2020 2020  L,.             
-0002f2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f2b0: 2020 646f 7562 6c65 2065 7073 5f76 7a3d    double eps_vz=
-0002f2c0: 5f56 534d 414c 4c2c 2064 6f75 626c 6520  _VSMALL, double 
-0002f2d0: 6570 735f 623d 5f56 534d 414c 4c2c 0a20  eps_b=_VSMALL,. 
+0002f260: 2020 2064 6f75 626c 6520 6570 735f 757a     double eps_uz
+0002f270: 3d5f 534d 414c 4c2c 2064 6f75 626c 6520  =_SMALL, double 
+0002f280: 6570 735f 613d 5f56 534d 414c 4c2c 0a20  eps_a=_VSMALL,. 
+0002f290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002f2a0: 2020 2020 2020 2020 2020 2020 2020 646f                do
+0002f2b0: 7562 6c65 2065 7073 5f76 7a3d 5f56 534d  uble eps_vz=_VSM
+0002f2c0: 414c 4c2c 2064 6f75 626c 6520 6570 735f  ALL, double eps_
+0002f2d0: 623d 5f56 534d 414c 4c2c 0a20 2020 2020  b=_VSMALL,.     
 0002f2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f2f0: 2020 2020 2020 2020 2020 2020 2020 646f                do
-0002f300: 7562 6c65 2065 7073 5f70 6c61 6e65 3d5f  uble eps_plane=_
-0002f310: 5653 4d41 4c4c 2c20 7374 7220 7665 735f  VSMALL, str ves_
-0002f320: 7479 7065 3d27 546f 7227 2c0a 2020 2020  type='Tor',.    
+0002f2f0: 2020 2020 2020 2020 2020 646f 7562 6c65            double
+0002f300: 2065 7073 5f70 6c61 6e65 3d5f 5653 4d41   eps_plane=_VSMA
+0002f310: 4c4c 2c20 7374 7220 7665 735f 7479 7065  LL, str ves_type
+0002f320: 3d27 546f 7227 2c0a 2020 2020 2020 2020  ='Tor',.        
 0002f330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f340: 2020 2020 2020 2020 2020 2073 7472 2061             str a
-0002f350: 6c67 6f5f 7479 7065 3d27 7369 6d70 6c65  lgo_type='simple
-0002f360: 272c 2069 6e74 206e 756d 5f74 6872 6561  ', int num_threa
-0002f370: 6473 3d31 3629 3a0a 2020 2020 2222 220a  ds=16):.    """.
-0002f380: 2020 2020 5061 7261 6d73 0a20 2020 203d      Params.    =
-0002f390: 3d3d 3d3d 3d0a 2020 2020 2020 2020 6e76  =====.        nv
-0002f3a0: 706f 6c79 203a 2069 6e74 0a20 2020 2020  poly : int.     
-0002f3b0: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
-0002f3c0: 666c 7578 2073 7572 6661 6365 730a 2020  flux surfaces.  
-0002f3d0: 2020 2020 2020 6e6c 6f73 203a 2069 6e74        nlos : int
-0002f3e0: 0a20 2020 2020 2020 2020 2020 4e75 6d62  .           Numb
-0002f3f0: 6572 206f 6620 4c4f 530a 2020 2020 2020  er of LOS.      
-0002f400: 2020 7261 795f 6f72 6967 203a 2028 332c    ray_orig : (3,
-0002f410: 206e 6c6f 7329 2064 6f75 626c 6520 6172   nlos) double ar
-0002f420: 7261 790a 2020 2020 2020 2020 2020 204c  ray.           L
-0002f430: 4f53 206f 7269 6769 6e20 706f 696e 7473  OS origin points
-0002f440: 2063 6f6f 7264 696e 6174 6573 0a20 2020   coordinates.   
-0002f450: 2020 2020 2072 6179 5f76 6469 7220 3a20       ray_vdir : 
-0002f460: 2833 2c20 6e6c 6f73 2920 646f 7562 6c65  (3, nlos) double
-0002f470: 2061 7272 6179 0a20 2020 2020 2020 2020   array.         
-0002f480: 2020 4c4f 5320 6469 7265 6374 696f 6e20    LOS direction 
-0002f490: 7665 6374 6f72 0a20 2020 2020 2020 2076  vector.        v
-0002f4a0: 6573 5f70 6f6c 7920 3a20 286e 756d 5f70  es_poly : (num_p
-0002f4b0: 6f6c 2c20 322c 206e 756d 5f76 6572 7465  ol, 2, num_verte
-0002f4c0: 7829 2064 6f75 626c 6520 6172 7261 790a  x) double array.
-0002f4d0: 2020 2020 2020 2020 2020 2043 6f6f 7264             Coord
-0002f4e0: 696e 6174 6573 206f 6620 7468 6520 7665  inates of the ve
-0002f4f0: 7274 6963 6573 206f 6620 7468 6520 506f  rtices of the Po
-0002f500: 6c79 676f 6e20 6465 6669 6e69 6e67 2074  lygon defining t
-0002f510: 6865 2032 4420 706f 6c6f 6964 616c 0a20  he 2D poloidal. 
-0002f520: 2020 2020 2020 2020 2020 6375 7420 6f66            cut of
-0002f530: 2074 6865 2064 6966 6665 7265 6e74 2049   the different I
-0002f540: 4e20 7375 7266 6163 6573 0a20 2020 2020  N surfaces.     
-0002f550: 2020 2020 2020 5741 524e 494e 4720 3a20        WARNING : 
-0002f560: 7765 2073 7570 706f 7365 2061 6c6c 2070  we suppose all p
-0002f570: 6f6c 7920 6172 6520 6e65 7374 6564 2069  oly are nested i
-0002f580: 6e20 6561 6368 206f 7468 6572 2c0a 2020  n each other,.  
-0002f590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f5a0: 2020 2061 6e64 2074 6865 2066 6972 7374     and the first
-0002f5b0: 206f 6e65 2069 7320 7468 6520 736d 616c   one is the smal
-0002f5c0: 6c65 7374 206f 6e65 0a20 2020 2020 2020  lest one.       
-0002f5d0: 2065 7073 5f3c 7661 6c3e 203a 2064 6f75   eps_<val> : dou
-0002f5e0: 626c 650a 2020 2020 2020 2020 2020 2053  ble.           S
-0002f5f0: 6d61 6c6c 2076 616c 7565 2c20 6163 6365  mall value, acce
-0002f600: 7074 616e 6365 206f 6620 6572 726f 720a  ptance of error.
-0002f610: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-0002f620: 3d3d 3d3d 3d3d 3d0a 2020 2020 2020 2020  =======.        
-0002f630: 696e 645f 636c 6f73 655f 6c6f 7320 3a20  ind_close_los : 
-0002f640: 286e 6c6f 7329 2069 6e74 2061 7272 6179  (nlos) int array
-0002f650: 0a20 2020 2020 2020 2020 2020 204f 6620  .            Of 
-0002f660: 7468 6520 666f 726d 205b 696e 645f 302c  the form [ind_0,
-0002f670: 2069 6e64 5f31 2c20 2e2e 2e2c 2069 6e64   ind_1, ..., ind
-0002f680: 5f28 6e6c 6f73 2d31 295d 0a20 2020 2020  _(nlos-1)].     
-0002f690: 2020 2020 2020 2077 6865 7265 2069 6e64         where ind
-0002f6a0: 5f69 2069 7320 7468 6520 636f 6566 6669  _i is the coeffi
-0002f6b0: 6369 656e 7420 666f 7220 7468 6520 692d  cient for the i-
-0002f6c0: 7468 204c 4f53 2028 7261 7929 0a20 2020  th LOS (ray).   
-0002f6d0: 2020 2020 2020 2020 2073 7563 6820 7468           such th
-0002f6e0: 6174 2074 6865 2069 6e64 5f69 2d74 6820  at the ind_i-th 
-0002f6f0: 706f 6c79 2028 666c 7578 2073 7572 6661  poly (flux surfa
-0002f700: 6365 2920 6973 2063 6c6f 7365 7374 2074  ce) is closest t
-0002f710: 6f20 7468 6520 4c4f 530a 2020 2020 2020  o the LOS.      
-0002f720: 2020 2020 2020 616d 6f6e 6720 616c 6c20        among all 
-0002f730: 6f74 6865 7220 706f 6c79 2077 6974 686f  other poly witho
-0002f740: 7574 2067 6f69 6e67 206f 7665 7220 6974  ut going over it
-0002f750: 2e0a 2020 2020 2d2d 2d0a 2020 2020 5468  ..    ---.    Th
-0002f760: 6973 2069 7320 7468 6520 5059 5448 4f4e  is is the PYTHON
-0002f770: 2066 756e 6374 696f 6e2c 2075 7365 206f   function, use o
-0002f780: 6e6c 7920 6966 2079 6f75 206e 6565 6420  nly if you need 
-0002f790: 7468 6973 2063 6f6d 7075 7461 7469 6f6e  this computation
-0002f7a0: 2066 726f 6d0a 2020 2020 5079 7468 6f6e   from.    Python
-0002f7b0: 2c20 6966 2079 6f75 206e 6565 6420 6974  , if you need it
-0002f7c0: 2066 726f 6d20 6379 7468 6f6e 2c20 7573   from cython, us
-0002f7d0: 6520 6077 6869 6368 5f76 706f 6c79 5f63  e `which_vpoly_c
-0002f7e0: 6c6f 7365 725f 6c6f 735f 7665 635f 636f  loser_los_vec_co
-0002f7f0: 7265 600a 2020 2020 2222 220a 2020 2020  re`.    """.    
-0002f800: 7761 726e 2822 5468 6973 2066 756e 6374  warn("This funct
-0002f810: 696f 6e20 7375 7070 6f73 6573 2074 6861  ion supposes tha
-0002f820: 7420 7468 6520 706f 6c79 7320 6172 6520  t the polys are 
-0002f830: 6e65 7374 6564 2066 726f 6d20 696e 6e65  nested from inne
-0002f840: 7220 746f 206f 7574 6572 222c 0a20 2020  r to outer",.   
-0002f850: 2020 2020 2020 5761 726e 696e 6729 0a20        Warning). 
-0002f860: 2020 2023 203d 3d3d 3d3d 3d3d 3d3d 3d3d     # ===========
+0002f340: 2020 2020 2020 2073 7472 2061 6c67 6f5f         str algo_
+0002f350: 7479 7065 3d27 7369 6d70 6c65 272c 2069  type='simple', i
+0002f360: 6e74 206e 756d 5f74 6872 6561 6473 3d31  nt num_threads=1
+0002f370: 3629 3a0a 2020 2020 2222 220a 2020 2020  6):.    """.    
+0002f380: 5061 7261 6d73 0a20 2020 203d 3d3d 3d3d  Params.    =====
+0002f390: 3d0a 2020 2020 2020 2020 6e76 706f 6c79  =.        nvpoly
+0002f3a0: 203a 2069 6e74 0a20 2020 2020 2020 2020   : int.         
+0002f3b0: 2020 4e75 6d62 6572 206f 6620 666c 7578    Number of flux
+0002f3c0: 2073 7572 6661 6365 730a 2020 2020 2020   surfaces.      
+0002f3d0: 2020 6e6c 6f73 203a 2069 6e74 0a20 2020    nlos : int.   
+0002f3e0: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
+0002f3f0: 6620 4c4f 530a 2020 2020 2020 2020 7261  f LOS.        ra
+0002f400: 795f 6f72 6967 203a 2028 332c 206e 6c6f  y_orig : (3, nlo
+0002f410: 7329 2064 6f75 626c 6520 6172 7261 790a  s) double array.
+0002f420: 2020 2020 2020 2020 2020 204c 4f53 206f             LOS o
+0002f430: 7269 6769 6e20 706f 696e 7473 2063 6f6f  rigin points coo
+0002f440: 7264 696e 6174 6573 0a20 2020 2020 2020  rdinates.       
+0002f450: 2072 6179 5f76 6469 7220 3a20 2833 2c20   ray_vdir : (3, 
+0002f460: 6e6c 6f73 2920 646f 7562 6c65 2061 7272  nlos) double arr
+0002f470: 6179 0a20 2020 2020 2020 2020 2020 4c4f  ay.           LO
+0002f480: 5320 6469 7265 6374 696f 6e20 7665 6374  S direction vect
+0002f490: 6f72 0a20 2020 2020 2020 2076 6573 5f70  or.        ves_p
+0002f4a0: 6f6c 7920 3a20 286e 756d 5f70 6f6c 2c20  oly : (num_pol, 
+0002f4b0: 322c 206e 756d 5f76 6572 7465 7829 2064  2, num_vertex) d
+0002f4c0: 6f75 626c 6520 6172 7261 790a 2020 2020  ouble array.    
+0002f4d0: 2020 2020 2020 2043 6f6f 7264 696e 6174         Coordinat
+0002f4e0: 6573 206f 6620 7468 6520 7665 7274 6963  es of the vertic
+0002f4f0: 6573 206f 6620 7468 6520 506f 6c79 676f  es of the Polygo
+0002f500: 6e20 6465 6669 6e69 6e67 2074 6865 2032  n defining the 2
+0002f510: 4420 706f 6c6f 6964 616c 0a20 2020 2020  D poloidal.     
+0002f520: 2020 2020 2020 6375 7420 6f66 2074 6865        cut of the
+0002f530: 2064 6966 6665 7265 6e74 2049 4e20 7375   different IN su
+0002f540: 7266 6163 6573 0a20 2020 2020 2020 2020  rfaces.         
+0002f550: 2020 5741 524e 494e 4720 3a20 7765 2073    WARNING : we s
+0002f560: 7570 706f 7365 2061 6c6c 2070 6f6c 7920  uppose all poly 
+0002f570: 6172 6520 6e65 7374 6564 2069 6e20 6561  are nested in ea
+0002f580: 6368 206f 7468 6572 2c0a 2020 2020 2020  ch other,.      
+0002f590: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0002f5a0: 6e64 2074 6865 2066 6972 7374 206f 6e65  nd the first one
+0002f5b0: 2069 7320 7468 6520 736d 616c 6c65 7374   is the smallest
+0002f5c0: 206f 6e65 0a20 2020 2020 2020 2065 7073   one.        eps
+0002f5d0: 5f3c 7661 6c3e 203a 2064 6f75 626c 650a  _<val> : double.
+0002f5e0: 2020 2020 2020 2020 2020 2053 6d61 6c6c             Small
+0002f5f0: 2076 616c 7565 2c20 6163 6365 7074 616e   value, acceptan
+0002f600: 6365 206f 6620 6572 726f 720a 2020 2020  ce of error.    
+0002f610: 5265 7475 726e 730a 2020 2020 3d3d 3d3d  Returns.    ====
+0002f620: 3d3d 3d0a 2020 2020 2020 2020 696e 645f  ===.        ind_
+0002f630: 636c 6f73 655f 6c6f 7320 3a20 286e 6c6f  close_los : (nlo
+0002f640: 7329 2069 6e74 2061 7272 6179 0a20 2020  s) int array.   
+0002f650: 2020 2020 2020 2020 204f 6620 7468 6520           Of the 
+0002f660: 666f 726d 205b 696e 645f 302c 2069 6e64  form [ind_0, ind
+0002f670: 5f31 2c20 2e2e 2e2c 2069 6e64 5f28 6e6c  _1, ..., ind_(nl
+0002f680: 6f73 2d31 295d 0a20 2020 2020 2020 2020  os-1)].         
+0002f690: 2020 2077 6865 7265 2069 6e64 5f69 2069     where ind_i i
+0002f6a0: 7320 7468 6520 636f 6566 6669 6369 656e  s the coefficien
+0002f6b0: 7420 666f 7220 7468 6520 692d 7468 204c  t for the i-th L
+0002f6c0: 4f53 2028 7261 7929 0a20 2020 2020 2020  OS (ray).       
+0002f6d0: 2020 2020 2073 7563 6820 7468 6174 2074       such that t
+0002f6e0: 6865 2069 6e64 5f69 2d74 6820 706f 6c79  he ind_i-th poly
+0002f6f0: 2028 666c 7578 2073 7572 6661 6365 2920   (flux surface) 
+0002f700: 6973 2063 6c6f 7365 7374 2074 6f20 7468  is closest to th
+0002f710: 6520 4c4f 530a 2020 2020 2020 2020 2020  e LOS.          
+0002f720: 2020 616d 6f6e 6720 616c 6c20 6f74 6865    among all othe
+0002f730: 7220 706f 6c79 2077 6974 686f 7574 2067  r poly without g
+0002f740: 6f69 6e67 206f 7665 7220 6974 2e0a 2020  oing over it..  
+0002f750: 2020 2d2d 2d0a 2020 2020 5468 6973 2069    ---.    This i
+0002f760: 7320 7468 6520 5059 5448 4f4e 2066 756e  s the PYTHON fun
+0002f770: 6374 696f 6e2c 2075 7365 206f 6e6c 7920  ction, use only 
+0002f780: 6966 2079 6f75 206e 6565 6420 7468 6973  if you need this
+0002f790: 2063 6f6d 7075 7461 7469 6f6e 2066 726f   computation fro
+0002f7a0: 6d0a 2020 2020 5079 7468 6f6e 2c20 6966  m.    Python, if
+0002f7b0: 2079 6f75 206e 6565 6420 6974 2066 726f   you need it fro
+0002f7c0: 6d20 6379 7468 6f6e 2c20 7573 6520 6077  m cython, use `w
+0002f7d0: 6869 6368 5f76 706f 6c79 5f63 6c6f 7365  hich_vpoly_close
+0002f7e0: 725f 6c6f 735f 7665 635f 636f 7265 600a  r_los_vec_core`.
+0002f7f0: 2020 2020 2222 220a 2020 2020 7761 726e      """.    warn
+0002f800: 2822 5468 6973 2066 756e 6374 696f 6e20  ("This function 
+0002f810: 7375 7070 6f73 6573 2074 6861 7420 7468  supposes that th
+0002f820: 6520 706f 6c79 7320 6172 6520 6e65 7374  e polys are nest
+0002f830: 6564 2066 726f 6d20 696e 6e65 7220 746f  ed from inner to
+0002f840: 206f 7574 6572 222c 0a20 2020 2020 2020   outer",.       
+0002f850: 2020 5761 726e 696e 6729 0a20 2020 2023    Warning).    #
+0002f860: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
 0002f870: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002f880: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002f890: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002f8a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
-0002f8b0: 2020 2020 6966 206e 6f74 2061 6c67 6f5f      if not algo_
-0002f8c0: 7479 7065 2e6c 6f77 6572 2829 203d 3d20  type.lower() == 
-0002f8d0: 2273 696d 706c 6522 206f 7220 6e6f 7420  "simple" or not 
-0002f8e0: 7665 735f 7479 7065 2e6c 6f77 6572 2829  ves_type.lower()
-0002f8f0: 203d 3d20 2274 6f72 223a 0a20 2020 2020   == "tor":.     
-0002f900: 2020 2061 7373 6572 7420 4661 6c73 652c     assert False,
-0002f910: 2022 5468 6520 6675 6e63 7469 6f6e 2069   "The function i
-0002f920: 7320 6f6e 6c79 2069 6d70 6c65 6d65 6e74  s only implement
-0002f930: 6564 2077 6974 6820 7468 6520 7369 6d70  ed with the simp
-0002f940: 6c65 225c 0a20 2020 2020 2020 2020 2020  le"\.           
-0002f950: 202b 2022 2061 6c67 6f72 6974 686d 2061   + " algorithm a
-0002f960: 6e64 2066 6f72 2074 6f72 6f69 6461 6c20  nd for toroidal 
-0002f970: 7665 7373 656c 732e 2e2e 2053 6f72 7279  vessels... Sorry
-0002f980: 2122 0a20 2020 2077 6172 6e28 2254 6869  !".    warn("Thi
-0002f990: 7320 6675 6e63 7469 6f6e 2073 7570 706f  s function suppo
-0002f9a0: 7365 7320 7468 6174 2074 6865 2070 6f6c  ses that the pol
-0002f9b0: 7973 2061 7265 206e 6573 7465 6420 6672  ys are nested fr
-0002f9c0: 6f6d 2069 6e6e 6572 2074 6f20 6f75 7465  om inner to oute
-0002f9d0: 7222 2c0a 2020 2020 2020 2020 2057 6172  r",.         War
-0002f9e0: 6e69 6e67 290a 2020 2020 2320 3d3d 3d3d  ning).    # ====
+0002f8a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020 2020  ===========.    
+0002f8b0: 6966 206e 6f74 2061 6c67 6f5f 7479 7065  if not algo_type
+0002f8c0: 2e6c 6f77 6572 2829 203d 3d20 2273 696d  .lower() == "sim
+0002f8d0: 706c 6522 206f 7220 6e6f 7420 7665 735f  ple" or not ves_
+0002f8e0: 7479 7065 2e6c 6f77 6572 2829 203d 3d20  type.lower() == 
+0002f8f0: 2274 6f72 223a 0a20 2020 2020 2020 2061  "tor":.        a
+0002f900: 7373 6572 7420 4661 6c73 652c 2022 5468  ssert False, "Th
+0002f910: 6520 6675 6e63 7469 6f6e 2069 7320 6f6e  e function is on
+0002f920: 6c79 2069 6d70 6c65 6d65 6e74 6564 2077  ly implemented w
+0002f930: 6974 6820 7468 6520 7369 6d70 6c65 225c  ith the simple"\
+0002f940: 0a20 2020 2020 2020 2020 2020 202b 2022  .            + "
+0002f950: 2061 6c67 6f72 6974 686d 2061 6e64 2066   algorithm and f
+0002f960: 6f72 2074 6f72 6f69 6461 6c20 7665 7373  or toroidal vess
+0002f970: 656c 732e 2e2e 2053 6f72 7279 2122 0a20  els... Sorry!". 
+0002f980: 2020 2077 6172 6e28 2254 6869 7320 6675     warn("This fu
+0002f990: 6e63 7469 6f6e 2073 7570 706f 7365 7320  nction supposes 
+0002f9a0: 7468 6174 2074 6865 2070 6f6c 7973 2061  that the polys a
+0002f9b0: 7265 206e 6573 7465 6420 6672 6f6d 2069  re nested from i
+0002f9c0: 6e6e 6572 2074 6f20 6f75 7465 7222 2c0a  nner to outer",.
+0002f9d0: 2020 2020 2020 2020 2057 6172 6e69 6e67           Warning
+0002f9e0: 290a 2020 2020 2320 3d3d 3d3d 3d3d 3d3d  ).    # ========
 0002f9f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002fa00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002fa10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0002fa20: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0002fa30: 3d3d 3d3d 3d3d 0a0a 2020 2020 6364 6566  ======..    cdef
-0002fa40: 2061 7272 6179 2069 6e64 5f63 6c6f 7365   array ind_close
-0002fa50: 5f74 6162 203d 2063 6c6f 6e65 2861 7272  _tab = clone(arr
-0002fa60: 6179 2827 6927 292c 206e 6c6f 732c 2054  ay('i'), nlos, T
-0002fa70: 7275 6529 0a20 2020 205f 6474 2e77 6869  rue).    _dt.whi
-0002fa80: 6368 5f76 706f 6c79 5f63 6c6f 7365 725f  ch_vpoly_closer_
-0002fa90: 6c6f 735f 7665 635f 636f 7265 286e 7670  los_vec_core(nvp
-0002faa0: 6f6c 792c 206e 6c6f 732c 0a20 2020 2020  oly, nlos,.     
+0002fa30: 3d3d 0a0a 2020 2020 6364 6566 2061 7272  ==..    cdef arr
+0002fa40: 6179 2069 6e64 5f63 6c6f 7365 5f74 6162  ay ind_close_tab
+0002fa50: 203d 2063 6c6f 6e65 2861 7272 6179 2827   = clone(array('
+0002fa60: 6927 292c 206e 6c6f 732c 2054 7275 6529  i'), nlos, True)
+0002fa70: 0a20 2020 205f 6474 2e77 6869 6368 5f76  .    _dt.which_v
+0002fa80: 706f 6c79 5f63 6c6f 7365 725f 6c6f 735f  poly_closer_los_
+0002fa90: 7665 635f 636f 7265 286e 7670 6f6c 792c  vec_core(nvpoly,
+0002faa0: 206e 6c6f 732c 0a20 2020 2020 2020 2020   nlos,.         
 0002fab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fac0: 2020 2020 2020 2020 2020 2020 2020 203c                 <
-0002fad0: 646f 7562 6c65 2a3e 7261 795f 6f72 6967  double*>ray_orig
-0002fae0: 2e64 6174 612c 0a20 2020 2020 2020 2020  .data,.         
+0002fac0: 2020 2020 2020 2020 2020 203c 646f 7562             <doub
+0002fad0: 6c65 2a3e 7261 795f 6f72 6967 2e64 6174  le*>ray_orig.dat
+0002fae0: 612c 0a20 2020 2020 2020 2020 2020 2020  a,.             
 0002faf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fb00: 2020 2020 2020 2020 2020 203c 646f 7562             <doub
-0002fb10: 6c65 2a3e 7261 795f 7664 6972 2e64 6174  le*>ray_vdir.dat
-0002fb20: 612c 0a20 2020 2020 2020 2020 2020 2020  a,.             
+0002fb00: 2020 2020 2020 203c 646f 7562 6c65 2a3e         <double*>
+0002fb10: 7261 795f 7664 6972 2e64 6174 612c 0a20  ray_vdir.data,. 
+0002fb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002fb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fb40: 2020 2020 2020 2076 6573 5f70 6f6c 792c         ves_poly,
-0002fb50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002fb40: 2020 2076 6573 5f70 6f6c 792c 0a20 2020     ves_poly,.   
+0002fb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002fb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fb70: 2020 2020 2065 7073 5f75 7a2c 2065 7073       eps_uz, eps
-0002fb80: 5f61 2c0a 2020 2020 2020 2020 2020 2020  _a,.            
+0002fb70: 2065 7073 5f75 7a2c 2065 7073 5f61 2c0a   eps_uz, eps_a,.
+0002fb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002fb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fba0: 2020 2020 2020 2020 6570 735f 767a 2c20          eps_vz, 
-0002fbb0: 6570 735f 622c 0a20 2020 2020 2020 2020  eps_b,.         
+0002fba0: 2020 2020 6570 735f 767a 2c20 6570 735f      eps_vz, eps_
+0002fbb0: 622c 0a20 2020 2020 2020 2020 2020 2020  b,.             
 0002fbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fbd0: 2020 2020 2020 2020 2020 2065 7073 5f70             eps_p
-0002fbe0: 6c61 6e65 2c0a 2020 2020 2020 2020 2020  lane,.          
+0002fbd0: 2020 2020 2020 2065 7073 5f70 6c61 6e65         eps_plane
+0002fbe0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 0002fbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fc00: 2020 2020 2020 2020 2020 696e 645f 636c            ind_cl
-0002fc10: 6f73 655f 7461 622c 0a20 2020 2020 2020  ose_tab,.       
+0002fc00: 2020 2020 2020 696e 645f 636c 6f73 655f        ind_close_
+0002fc10: 7461 622c 0a20 2020 2020 2020 2020 2020  tab,.           
 0002fc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fc30: 2020 2020 2020 2020 2020 2020 206e 756d               num
-0002fc40: 5f74 6872 6561 6473 290a 2020 2020 7265  _threads).    re
-0002fc50: 7475 726e 206e 702e 6173 6172 7261 7928  turn np.asarray(
-0002fc60: 696e 645f 636c 6f73 655f 7461 6229 0a0a  ind_close_tab)..
-0002fc70: 0a0a 6465 6620 5f56 6573 5f56 6d65 7368  ..def _Ves_Vmesh
-0002fc80: 5f54 6f72 5f53 7562 4672 6f6d 445f 6379  _Tor_SubFromD_cy
-0002fc90: 7468 6f6e 5f6f 6c64 2864 6f75 626c 6520  thon_old(double 
-0002fca0: 6452 2c20 646f 7562 6c65 2064 5a2c 2064  dR, double dZ, d
-0002fcb0: 6f75 626c 6520 6452 5068 692c 0a20 2020  ouble dRPhi,.   
+0002fc30: 2020 2020 2020 2020 206e 756d 5f74 6872           num_thr
+0002fc40: 6561 6473 290a 2020 2020 7265 7475 726e  eads).    return
+0002fc50: 206e 702e 6173 6172 7261 7928 696e 645f   np.asarray(ind_
+0002fc60: 636c 6f73 655f 7461 6229 0a0a 0a0a 6465  close_tab)....de
+0002fc70: 6620 5f56 6573 5f56 6d65 7368 5f54 6f72  f _Ves_Vmesh_Tor
+0002fc80: 5f53 7562 4672 6f6d 445f 6379 7468 6f6e  _SubFromD_cython
+0002fc90: 5f6f 6c64 2864 6f75 626c 6520 6452 2c20  _old(double dR, 
+0002fca0: 646f 7562 6c65 2064 5a2c 2064 6f75 626c  double dZ, doubl
+0002fcb0: 6520 6452 5068 692c 0a20 2020 2020 2020  e dRPhi,.       
 0002fcc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002fcd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fce0: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
-0002fcf0: 524d 696e 4d61 782c 2064 6f75 626c 655b  RMinMax, double[
-0002fd00: 3a3a 315d 205a 4d69 6e4d 6178 2c0a 2020  ::1] ZMinMax,.  
+0002fce0: 646f 7562 6c65 5b3a 3a31 5d20 524d 696e  double[::1] RMin
+0002fcf0: 4d61 782c 2064 6f75 626c 655b 3a3a 315d  Max, double[::1]
+0002fd00: 205a 4d69 6e4d 6178 2c0a 2020 2020 2020   ZMinMax,.      
 0002fd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002fd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fd30: 2020 2020 206c 6973 7420 4452 3d4e 6f6e       list DR=Non
-0002fd40: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0002fd30: 206c 6973 7420 4452 3d4e 6f6e 652c 0a20   list DR=None,. 
+0002fd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0002fd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fd60: 2020 2020 2020 2020 2020 6c69 7374 2044            list D
-0002fd70: 5a3d 4e6f 6e65 2c0a 2020 2020 2020 2020  Z=None,.        
+0002fd60: 2020 2020 2020 6c69 7374 2044 5a3d 4e6f        list DZ=No
+0002fd70: 6e65 2c0a 2020 2020 2020 2020 2020 2020  ne,.            
 0002fd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fd90: 2020 2020 2020 2020 2020 2020 2020 2044                 D
-0002fda0: 5068 693d 4e6f 6e65 2c20 5650 6f6c 793d  Phi=None, VPoly=
-0002fdb0: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
+0002fd90: 2020 2020 2020 2020 2020 2044 5068 693d             DPhi=
+0002fda0: 4e6f 6e65 2c20 5650 6f6c 793d 4e6f 6e65  None, VPoly=None
+0002fdb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 0002fdc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002fdd0: 2020 2020 2020 2020 2020 2020 2073 7472               str
-0002fde0: 204f 7574 3d27 2858 2c59 2c5a 2927 2c20   Out='(X,Y,Z)', 
-0002fdf0: 646f 7562 6c65 206d 6172 6769 6e3d 5f56  double margin=_V
-0002fe00: 534d 414c 4c29 3a0a 2020 2020 2222 220a  SMALL):.    """.
-0002fe10: 2020 2020 5265 7475 726e 2074 6865 2064      Return the d
-0002fe20: 6573 6972 6564 2073 7562 6d65 7368 2069  esired submesh i
-0002fe30: 6e64 6963 6174 6564 2062 7920 7468 6520  ndicated by the 
-0002fe40: 6c69 6d69 7473 2028 4452 2c44 5a2c 4450  limits (DR,DZ,DP
-0002fe50: 6869 292c 0a20 2020 2066 6f72 2074 6865  hi),.    for the
-0002fe60: 2064 6573 6972 6564 2072 6573 6f6c 7574   desired resolut
-0002fe70: 696f 6e20 2864 522c 645a 2c64 5270 6869  ion (dR,dZ,dRphi
-0002fe80: 290a 2020 2020 2222 220a 2020 2020 6364  ).    """.    cd
-0002fe90: 6566 2064 6f75 626c 655b 3a3a 315d 2052  ef double[::1] R
-0002fea0: 302c 2052 2c20 5a2c 2064 5250 6869 722c  0, R, Z, dRPhir,
-0002feb0: 2064 5068 6972 2c20 4e52 5068 692c 2068   dPhir, NRPhi, h
-0002fec0: 7970 6f74 0a20 2020 2063 6465 6620 646f  ypot.    cdef do
-0002fed0: 7562 6c65 2072 6573 6f5f 7230 2c20 7265  uble reso_r0, re
-0002fee0: 736f 5f72 2c20 7265 736f 5f7a 2c20 4450  so_r, reso_z, DP
-0002fef0: 6869 302c 2044 5068 6931 0a20 2020 2063  hi0, DPhi1.    c
-0002ff00: 6465 6620 646f 7562 6c65 2061 6273 302c  def double abs0,
-0002ff10: 2061 6273 312c 2070 6869 2c20 696e 6469   abs1, phi, indi
-0002ff20: 696a 6a0a 2020 2020 6364 6566 206c 6f6e  ijj.    cdef lon
-0002ff30: 675b 3a3a 315d 2069 6e64 5230 2c20 696e  g[::1] indR0, in
-0002ff40: 6452 2c20 696e 645a 2c20 5068 696e 2c20  dR, indZ, Phin, 
-0002ff50: 4e52 5068 6930 0a20 2020 2063 6465 6620  NRPhi0.    cdef 
-0002ff60: 696e 7420 4e52 302c 204e 522c 204e 5a2c  int NR0, NR, NZ,
-0002ff70: 2052 6e2c 205a 6e2c 206e 5250 6869 302c   Rn, Zn, nRPhi0,
-0002ff80: 2069 6e64 5230 6969 2c20 6969 2c20 6a6a   indR0ii, ii, jj
-0002ff90: 2c20 6e50 6869 302c 206e 5068 6931 2c20  , nPhi0, nPhi1, 
-0002ffa0: 7a7a 0a20 2020 2063 6465 6620 696e 7420  zz.    cdef int 
-0002ffb0: 4e50 2c20 4e52 5068 695f 696e 742c 2072  NP, NRPhi_int, r
-0002ffc0: 6164 6975 735f 7261 7469 6f0a 2020 2020  adius_ratio.    
-0002ffd0: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
-0002ffe0: 646f 7562 6c65 2c6e 6469 6d3d 325d 2050  double,ndim=2] P
-0002fff0: 7473 2c20 696e 6449 0a20 2020 2063 6465  ts, indI.    cde
-00030000: 6620 6e70 2e6e 6461 7272 6179 5b64 6f75  f np.ndarray[dou
-00030010: 626c 652c 6e64 696d 3d31 5d20 6969 692c  ble,ndim=1] iii,
-00030020: 2064 562c 2069 6e64 0a0a 0a20 2020 2077   dV, ind...    w
-00030030: 6172 6e28 2259 6f75 2061 7265 2075 7369  arn("You are usi
-00030040: 6e67 2074 6865 206f 6c64 2061 6c67 6f72  ng the old algor
-00030050: 6974 686d 2066 6f72 206d 6573 6869 6e67  ithm for meshing
-00030060: 2061 2076 6f6c 756d 652e 220a 2020 2020   a volume.".    
-00030070: 2020 2020 202b 2022 2054 6869 7320 616c       + " This al
-00030080: 676f 7269 7468 6d20 6973 2073 6c6f 7765  gorithm is slowe
-00030090: 7220 7468 616e 2074 6865 206e 6577 206f  r than the new o
-000300a0: 6e65 2e22 2c20 5761 726e 696e 6729 0a0a  ne.", Warning)..
-000300b0: 2020 2020 2320 4765 7420 7468 6520 6163      # Get the ac
-000300c0: 7475 616c 2052 2061 6e64 205a 2072 6573  tual R and Z res
-000300d0: 6f6c 7574 696f 6e73 2061 6e64 206d 6573  olutions and mes
-000300e0: 6820 656c 656d 656e 7473 0a20 2020 2052  h elements.    R
-000300f0: 302c 2072 6573 6f5f 7230 2c20 696e 6452  0, reso_r0, indR
-00030100: 302c 204e 5230 203d 2064 6973 6372 6574  0, NR0 = discret
-00030110: 697a 655f 6c69 6e65 3164 2852 4d69 6e4d  ize_line1d(RMinM
-00030120: 6178 2c20 6452 2c20 4e6f 6e65 2c0a 2020  ax, dR, None,.  
+0002fdd0: 2020 2020 2020 2020 2073 7472 204f 7574           str Out
+0002fde0: 3d27 2858 2c59 2c5a 2927 2c20 646f 7562  ='(X,Y,Z)', doub
+0002fdf0: 6c65 206d 6172 6769 6e3d 5f56 534d 414c  le margin=_VSMAL
+0002fe00: 4c29 3a0a 2020 2020 2222 220a 2020 2020  L):.    """.    
+0002fe10: 5265 7475 726e 2074 6865 2064 6573 6972  Return the desir
+0002fe20: 6564 2073 7562 6d65 7368 2069 6e64 6963  ed submesh indic
+0002fe30: 6174 6564 2062 7920 7468 6520 6c69 6d69  ated by the limi
+0002fe40: 7473 2028 4452 2c44 5a2c 4450 6869 292c  ts (DR,DZ,DPhi),
+0002fe50: 0a20 2020 2066 6f72 2074 6865 2064 6573  .    for the des
+0002fe60: 6972 6564 2072 6573 6f6c 7574 696f 6e20  ired resolution 
+0002fe70: 2864 522c 645a 2c64 5270 6869 290a 2020  (dR,dZ,dRphi).  
+0002fe80: 2020 2222 220a 2020 2020 6364 6566 2064    """.    cdef d
+0002fe90: 6f75 626c 655b 3a3a 315d 2052 302c 2052  ouble[::1] R0, R
+0002fea0: 2c20 5a2c 2064 5250 6869 722c 2064 5068  , Z, dRPhir, dPh
+0002feb0: 6972 2c20 4e52 5068 692c 2068 7970 6f74  ir, NRPhi, hypot
+0002fec0: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+0002fed0: 2072 6573 6f5f 7230 2c20 7265 736f 5f72   reso_r0, reso_r
+0002fee0: 2c20 7265 736f 5f7a 2c20 4450 6869 302c  , reso_z, DPhi0,
+0002fef0: 2044 5068 6931 0a20 2020 2063 6465 6620   DPhi1.    cdef 
+0002ff00: 646f 7562 6c65 2061 6273 302c 2061 6273  double abs0, abs
+0002ff10: 312c 2070 6869 2c20 696e 6469 696a 6a0a  1, phi, indiijj.
+0002ff20: 2020 2020 6364 6566 206c 6f6e 675b 3a3a      cdef long[::
+0002ff30: 315d 2069 6e64 5230 2c20 696e 6452 2c20  1] indR0, indR, 
+0002ff40: 696e 645a 2c20 5068 696e 2c20 4e52 5068  indZ, Phin, NRPh
+0002ff50: 6930 0a20 2020 2063 6465 6620 696e 7420  i0.    cdef int 
+0002ff60: 4e52 302c 204e 522c 204e 5a2c 2052 6e2c  NR0, NR, NZ, Rn,
+0002ff70: 205a 6e2c 206e 5250 6869 302c 2069 6e64   Zn, nRPhi0, ind
+0002ff80: 5230 6969 2c20 6969 2c20 6a6a 2c20 6e50  R0ii, ii, jj, nP
+0002ff90: 6869 302c 206e 5068 6931 2c20 7a7a 0a20  hi0, nPhi1, zz. 
+0002ffa0: 2020 2063 6465 6620 696e 7420 4e50 2c20     cdef int NP, 
+0002ffb0: 4e52 5068 695f 696e 742c 2072 6164 6975  NRPhi_int, radiu
+0002ffc0: 735f 7261 7469 6f0a 2020 2020 6364 6566  s_ratio.    cdef
+0002ffd0: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
+0002ffe0: 6c65 2c6e 6469 6d3d 325d 2050 7473 2c20  le,ndim=2] Pts, 
+0002fff0: 696e 6449 0a20 2020 2063 6465 6620 6e70  indI.    cdef np
+00030000: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
+00030010: 6e64 696d 3d31 5d20 6969 692c 2064 562c  ndim=1] iii, dV,
+00030020: 2069 6e64 0a0a 0a20 2020 2077 6172 6e28   ind...    warn(
+00030030: 2259 6f75 2061 7265 2075 7369 6e67 2074  "You are using t
+00030040: 6865 206f 6c64 2061 6c67 6f72 6974 686d  he old algorithm
+00030050: 2066 6f72 206d 6573 6869 6e67 2061 2076   for meshing a v
+00030060: 6f6c 756d 652e 220a 2020 2020 2020 2020  olume.".        
+00030070: 202b 2022 2054 6869 7320 616c 676f 7269   + " This algori
+00030080: 7468 6d20 6973 2073 6c6f 7765 7220 7468  thm is slower th
+00030090: 616e 2074 6865 206e 6577 206f 6e65 2e22  an the new one."
+000300a0: 2c20 5761 726e 696e 6729 0a0a 2020 2020  , Warning)..    
+000300b0: 2320 4765 7420 7468 6520 6163 7475 616c  # Get the actual
+000300c0: 2052 2061 6e64 205a 2072 6573 6f6c 7574   R and Z resolut
+000300d0: 696f 6e73 2061 6e64 206d 6573 6820 656c  ions and mesh el
+000300e0: 656d 656e 7473 0a20 2020 2052 302c 2072  ements.    R0, r
+000300f0: 6573 6f5f 7230 2c20 696e 6452 302c 204e  eso_r0, indR0, N
+00030100: 5230 203d 2064 6973 6372 6574 697a 655f  R0 = discretize_
+00030110: 6c69 6e65 3164 2852 4d69 6e4d 6178 2c20  line1d(RMinMax, 
+00030120: 6452 2c20 4e6f 6e65 2c0a 2020 2020 2020  dR, None,.      
 00030130: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00030140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030150: 2020 2020 2020 2020 2020 204c 696d 3d54             Lim=T
-00030160: 7275 652c 206d 6172 6769 6e3d 6d61 7267  rue, margin=marg
-00030170: 696e 290a 2020 2020 522c 2072 6573 6f5f  in).    R, reso_
-00030180: 722c 2069 6e64 522c 204e 5220 3d20 6469  r, indR, NR = di
-00030190: 7363 7265 7469 7a65 5f6c 696e 6531 6428  scretize_line1d(
-000301a0: 524d 696e 4d61 782c 2064 522c 2044 522c  RMinMax, dR, DR,
-000301b0: 204c 696d 3d54 7275 652c 0a20 2020 2020   Lim=True,.     
+00030150: 2020 2020 2020 204c 696d 3d54 7275 652c         Lim=True,
+00030160: 206d 6172 6769 6e3d 6d61 7267 696e 290a   margin=margin).
+00030170: 2020 2020 522c 2072 6573 6f5f 722c 2069      R, reso_r, i
+00030180: 6e64 522c 204e 5220 3d20 6469 7363 7265  ndR, NR = discre
+00030190: 7469 7a65 5f6c 696e 6531 6428 524d 696e  tize_line1d(RMin
+000301a0: 4d61 782c 2064 522c 2044 522c 204c 696d  Max, dR, DR, Lim
+000301b0: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
 000301c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000301d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000301e0: 2020 2020 206d 6172 6769 6e3d 6d61 7267       margin=marg
-000301f0: 696e 290a 2020 2020 5a2c 2072 6573 6f5f  in).    Z, reso_
-00030200: 7a2c 2069 6e64 5a2c 204e 5a20 3d20 6469  z, indZ, NZ = di
-00030210: 7363 7265 7469 7a65 5f6c 696e 6531 6428  scretize_line1d(
-00030220: 5a4d 696e 4d61 782c 2064 5a2c 2044 5a2c  ZMinMax, dZ, DZ,
-00030230: 204c 696d 3d54 7275 652c 0a20 2020 2020   Lim=True,.     
+000301e0: 206d 6172 6769 6e3d 6d61 7267 696e 290a   margin=margin).
+000301f0: 2020 2020 5a2c 2072 6573 6f5f 7a2c 2069      Z, reso_z, i
+00030200: 6e64 5a2c 204e 5a20 3d20 6469 7363 7265  ndZ, NZ = discre
+00030210: 7469 7a65 5f6c 696e 6531 6428 5a4d 696e  tize_line1d(ZMin
+00030220: 4d61 782c 2064 5a2c 2044 5a2c 204c 696d  Max, dZ, DZ, Lim
+00030230: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
 00030240: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00030250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030260: 2020 2020 206d 6172 6769 6e3d 6d61 7267       margin=marg
-00030270: 696e 290a 2020 2020 526e 203d 206c 656e  in).    Rn = len
-00030280: 2852 290a 2020 2020 5a6e 203d 206c 656e  (R).    Zn = len
-00030290: 285a 290a 2020 2020 2320 4765 7420 7468  (Z).    # Get th
-000302a0: 6520 6c69 6d69 7473 2069 6620 616e 7920  e limits if any 
-000302b0: 2861 6e64 206d 616b 6520 7375 7265 2074  (and make sure t
-000302c0: 6f20 7265 706c 6163 6520 7468 656d 2069  o replace them i
-000302d0: 6e20 7468 6520 7072 6f70 6572 0a20 2020  n the proper.   
-000302e0: 2023 2071 7561 6472 616e 7473 290a 2020   # quadrants).  
-000302f0: 2020 6966 2044 5068 6920 6973 204e 6f6e    if DPhi is Non
-00030300: 653a 0a20 2020 2020 2020 2044 5068 6930  e:.        DPhi0
-00030310: 2c20 4450 6869 3120 3d20 2d63 5f70 692c  , DPhi1 = -c_pi,
-00030320: 2063 5f70 690a 2020 2020 656c 7365 3a0a   c_pi.    else:.
-00030330: 2020 2020 2020 2020 4450 6869 3020 3d20          DPhi0 = 
-00030340: 635f 6174 616e 3228 635f 7369 6e28 4450  c_atan2(c_sin(DP
-00030350: 6869 5b30 5d29 2c20 635f 636f 7328 4450  hi[0]), c_cos(DP
-00030360: 6869 5b30 5d29 290a 2020 2020 2020 2020  hi[0])).        
-00030370: 4450 6869 3120 3d20 635f 6174 616e 3228  DPhi1 = c_atan2(
-00030380: 635f 7369 6e28 4450 6869 5b31 5d29 2c20  c_sin(DPhi[1]), 
-00030390: 635f 636f 7328 4450 6869 5b31 5d29 290a  c_cos(DPhi[1])).
-000303a0: 2020 2020 6452 5068 6972 2c20 6450 6869      dRPhir, dPhi
-000303b0: 7220 3d20 6e70 2e65 6d70 7479 2828 526e  r = np.empty((Rn
-000303c0: 2c29 292c 206e 702e 656d 7074 7928 2852  ,)), np.empty((R
-000303d0: 6e2c 2929 0a20 2020 2050 6869 6e20 3d20  n,)).    Phin = 
-000303e0: 6e70 2e65 6d70 7479 2828 526e 2c29 2c64  np.empty((Rn,),d
-000303f0: 7479 7065 3d69 6e74 290a 2020 2020 4e52  type=int).    NR
-00030400: 5068 6920 3d20 6e70 2e65 6d70 7479 2828  Phi = np.empty((
-00030410: 526e 2c29 290a 2020 2020 4e52 5068 6930  Rn,)).    NRPhi0
-00030420: 203d 206e 702e 7a65 726f 7328 2852 6e2c   = np.zeros((Rn,
-00030430: 292c 6474 7970 653d 696e 7429 0a20 2020  ),dtype=int).   
-00030440: 206e 5250 6869 302c 2069 6e64 5230 6969   nRPhi0, indR0ii
-00030450: 203d 2030 2c20 300a 2020 2020 4e50 2c20   = 0, 0.    NP, 
-00030460: 4e50 6869 6d61 7820 3d20 302c 2030 0a20  NPhimax = 0, 0. 
-00030470: 2020 2072 6164 6975 735f 7261 7469 6f20     radius_ratio 
-00030480: 3d20 696e 7428 635f 6365 696c 2852 5b52  = int(c_ceil(R[R
-00030490: 6e2d 315d 2f52 5b30 5d29 290a 2020 2020  n-1]/R[0])).    
-000304a0: 666f 7220 6969 2069 6e20 7261 6e67 6528  for ii in range(
-000304b0: 302c 526e 293a 0a20 2020 2020 2020 2023  0,Rn):.        #
-000304c0: 2047 6574 2074 6865 2061 6374 7561 6c20   Get the actual 
-000304d0: 5250 6869 2072 6573 6f6c 7574 696f 6e20  RPhi resolution 
-000304e0: 616e 6420 5068 6920 6d65 7368 2065 6c65  and Phi mesh ele
-000304f0: 6d65 6e74 7320 2821 2064 6570 656e 6473  ments (! depends
-00030500: 206f 6e20 5221 290a 2020 2020 2020 2020   on R!).        
-00030510: 4e52 5068 695b 6969 5d20 3d20 635f 6365  NRPhi[ii] = c_ce
-00030520: 696c 2832 2e2a 635f 7069 2a52 5b69 695d  il(2.*c_pi*R[ii]
-00030530: 2f64 5250 6869 290a 2020 2020 2020 2020  /dRPhi).        
-00030540: 4e52 5068 695f 696e 7420 3d20 696e 7428  NRPhi_int = int(
-00030550: 4e52 5068 695b 6969 5d29 0a20 2020 2020  NRPhi[ii]).     
-00030560: 2020 2064 5068 6972 5b69 695d 203d 2032     dPhir[ii] = 2
-00030570: 2e2a 635f 7069 2f4e 5250 6869 5b69 695d  .*c_pi/NRPhi[ii]
-00030580: 0a20 2020 2020 2020 2064 5250 6869 725b  .        dRPhir[
-00030590: 6969 5d20 3d20 6450 6869 725b 6969 5d2a  ii] = dPhir[ii]*
-000305a0: 525b 6969 5d0a 2020 2020 2020 2020 2320  R[ii].        # 
-000305b0: 4765 7420 696e 6465 7820 616e 6420 6375  Get index and cu
-000305c0: 6d75 6c61 7465 6420 696e 6469 6365 7320  mulated indices 
-000305d0: 6672 6f6d 2062 6163 6b67 726f 756e 640a  from background.
-000305e0: 2020 2020 2020 2020 666f 7220 6a6a 2069          for jj i
-000305f0: 6e20 7261 6e67 6528 696e 6452 3069 692c  n range(indR0ii,
-00030600: 4e52 3029 3a0a 2020 2020 2020 2020 2020  NR0):.          
-00030610: 2020 6966 2052 305b 6a6a 5d3d 3d52 5b69    if R0[jj]==R[i
-00030620: 695d 3a0a 2020 2020 2020 2020 2020 2020  i]:.            
-00030630: 2020 2020 696e 6452 3069 6920 3d20 6a6a      indR0ii = jj
-00030640: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00030650: 2062 7265 616b 0a20 2020 2020 2020 2020   break.         
-00030660: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00030670: 2020 2020 2020 2020 206e 5250 6869 3020           nRPhi0 
-00030680: 2b3d 203c 6c6f 6e67 3e63 5f63 6569 6c28  += <long>c_ceil(
-00030690: 322e 2a63 5f70 692a 5230 5b6a 6a5d 2f64  2.*c_pi*R0[jj]/d
-000306a0: 5250 6869 290a 2020 2020 2020 2020 2020  RPhi).          
-000306b0: 2020 2020 2020 4e52 5068 6930 5b69 695d        NRPhi0[ii]
-000306c0: 203d 206e 5250 6869 302a 4e5a 0a20 2020   = nRPhi0*NZ.   
-000306d0: 2020 2020 2023 2047 6574 2069 6e64 6963       # Get indic
-000306e0: 6573 206f 6620 7068 690a 2020 2020 2020  es of phi.      
-000306f0: 2020 2320 4765 7420 7468 6520 6578 7472    # Get the extr
-00030700: 656d 6520 696e 6469 6365 7320 6f66 2074  eme indices of t
-00030710: 6865 206d 6573 6820 656c 656d 656e 7473  he mesh elements
-00030720: 2074 6861 7420 7265 616c 6c79 206e 6565   that really nee
-00030730: 6420 746f 0a20 2020 2020 2020 2023 2062  d to.        # b
-00030740: 6520 6372 6561 7465 6420 7769 7468 696e  e created within
-00030750: 2074 686f 7365 206c 696d 6974 730a 2020   those limits.  
-00030760: 2020 2020 2020 6162 7330 203d 2063 5f61        abs0 = c_a
-00030770: 6273 2844 5068 6930 2b63 5f70 6929 0a20  bs(DPhi0+c_pi). 
-00030780: 2020 2020 2020 2069 6620 6162 7330 2d64         if abs0-d
-00030790: 5068 6972 5b69 695d 2a63 5f66 6c6f 6f72  Phir[ii]*c_floor
-000307a0: 2861 6273 302f 6450 6869 725b 6969 5d29  (abs0/dPhir[ii])
-000307b0: 203c 206d 6172 6769 6e2a 6450 6869 725b   < margin*dPhir[
-000307c0: 6969 5d3a 0a20 2020 2020 2020 2020 2020  ii]:.           
-000307d0: 206e 5068 6930 203d 2069 6e74 2863 5f72   nPhi0 = int(c_r
-000307e0: 6f75 6e64 2828 4450 6869 302b 635f 7069  ound((DPhi0+c_pi
-000307f0: 292f 6450 6869 725b 6969 5d29 290a 2020  )/dPhir[ii])).  
-00030800: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00030810: 2020 2020 2020 2020 6e50 6869 3020 3d20          nPhi0 = 
-00030820: 696e 7428 635f 666c 6f6f 7228 2844 5068  int(c_floor((DPh
-00030830: 6930 2b63 5f70 6929 2f64 5068 6972 5b69  i0+c_pi)/dPhir[i
-00030840: 695d 2929 0a20 2020 2020 2020 2061 6273  i])).        abs
-00030850: 3120 3d20 635f 6162 7328 4450 6869 312b  1 = c_abs(DPhi1+
-00030860: 635f 7069 290a 2020 2020 2020 2020 6966  c_pi).        if
-00030870: 2061 6273 312d 6450 6869 725b 6969 5d2a   abs1-dPhir[ii]*
-00030880: 635f 666c 6f6f 7228 6162 7331 2f64 5068  c_floor(abs1/dPh
-00030890: 6972 5b69 695d 2920 3c20 6d61 7267 696e  ir[ii]) < margin
-000308a0: 2a64 5068 6972 5b69 695d 3a0a 2020 2020  *dPhir[ii]:.    
-000308b0: 2020 2020 2020 2020 6e50 6869 3120 3d20          nPhi1 = 
-000308c0: 696e 7428 635f 726f 756e 6428 2844 5068  int(c_round((DPh
-000308d0: 6931 2b63 5f70 6929 2f64 5068 6972 5b69  i1+c_pi)/dPhir[i
-000308e0: 695d 292d 3129 0a20 2020 2020 2020 2065  i])-1).        e
-000308f0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00030900: 206e 5068 6931 203d 2069 6e74 2863 5f66   nPhi1 = int(c_f
-00030910: 6c6f 6f72 2828 4450 6869 312b 635f 7069  loor((DPhi1+c_pi
-00030920: 292f 6450 6869 725b 6969 5d29 290a 0a20  )/dPhir[ii])).. 
-00030930: 2020 2020 2020 2069 6620 4450 6869 303c         if DPhi0<
-00030940: 4450 6869 313a 0a20 2020 2020 2020 2020  DPhi1:.         
-00030950: 2020 2023 696e 6449 2e61 7070 656e 6428     #indI.append(
-00030960: 6c69 7374 2872 616e 6765 286e 5068 6930  list(range(nPhi0
-00030970: 2c6e 5068 6931 2b31 2929 290a 2020 2020  ,nPhi1+1))).    
-00030980: 2020 2020 2020 2020 5068 696e 5b69 695d          Phin[ii]
-00030990: 203d 206e 5068 6931 2b31 2d6e 5068 6930   = nPhi1+1-nPhi0
-000309a0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-000309b0: 6969 3d3d 303a 0a20 2020 2020 2020 2020  ii==0:.         
-000309c0: 2020 2020 2020 2069 6e64 4920 3d20 6e70         indI = np
-000309d0: 2e6e 616e 2a6e 702e 6f6e 6573 2828 526e  .nan*np.ones((Rn
-000309e0: 2c50 6869 6e5b 6969 5d2a 7261 6469 7573  ,Phin[ii]*radius
-000309f0: 5f72 6174 696f 2b31 2929 0a20 2020 2020  _ratio+1)).     
-00030a00: 2020 2020 2020 2066 6f72 206a 6a20 696e         for jj in
-00030a10: 2072 616e 6765 2830 2c50 6869 6e5b 6969   range(0,Phin[ii
-00030a20: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00030a30: 2020 2020 696e 6449 5b69 692c 6a6a 5d20      indI[ii,jj] 
-00030a40: 3d20 3c64 6f75 626c 653e 2820 6e50 6869  = <double>( nPhi
-00030a50: 302b 6a6a 2029 0a20 2020 2020 2020 2065  0+jj ).        e
-00030a60: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00030a70: 2023 696e 6449 2e61 7070 656e 6428 6c69   #indI.append(li
-00030a80: 7374 2872 616e 6765 286e 5068 6930 2c4e  st(range(nPhi0,N
-00030a90: 5250 6869 5f69 6e74 292b 6c69 7374 2872  RPhi_int)+list(r
-00030aa0: 616e 6765 2830 2c6e 5068 6931 2b31 2929  ange(0,nPhi1+1))
-00030ab0: 2929 0a20 2020 2020 2020 2020 2020 2050  )).            P
-00030ac0: 6869 6e5b 6969 5d20 3d20 6e50 6869 312b  hin[ii] = nPhi1+
-00030ad0: 312b 4e52 5068 695f 696e 742d 6e50 6869  1+NRPhi_int-nPhi
-00030ae0: 300a 2020 2020 2020 2020 2020 2020 6966  0.            if
-00030af0: 2069 693d 3d30 3a0a 2020 2020 2020 2020   ii==0:.        
-00030b00: 2020 2020 2020 2020 696e 6449 203d 206e          indI = n
-00030b10: 702e 6e61 6e2a 6e70 2e6f 6e65 7328 2852  p.nan*np.ones((R
-00030b20: 6e2c 5068 696e 5b69 695d 2a72 6164 6975  n,Phin[ii]*radiu
-00030b30: 735f 7261 7469 6f2b 3129 290a 2020 2020  s_ratio+1)).    
-00030b40: 2020 2020 2020 2020 666f 7220 6a6a 2069          for jj i
-00030b50: 6e20 7261 6e67 6528 302c 4e52 5068 695f  n range(0,NRPhi_
-00030b60: 696e 742d 6e50 6869 3029 3a0a 2020 2020  int-nPhi0):.    
-00030b70: 2020 2020 2020 2020 2020 2020 696e 6449              indI
-00030b80: 5b69 692c 6a6a 5d20 3d20 3c64 6f75 626c  [ii,jj] = <doubl
-00030b90: 653e 2820 6e50 6869 302b 6a6a 2029 0a20  e>( nPhi0+jj ). 
-00030ba0: 2020 2020 2020 2020 2020 2066 6f72 206a             for j
-00030bb0: 6a20 696e 2072 616e 6765 284e 5250 6869  j in range(NRPhi
-00030bc0: 5f69 6e74 2d6e 5068 6930 2c50 6869 6e5b  _int-nPhi0,Phin[
-00030bd0: 6969 5d29 3a0a 2020 2020 2020 2020 2020  ii]):.          
-00030be0: 2020 2020 2020 696e 6449 5b69 692c 6a6a        indI[ii,jj
-00030bf0: 5d20 3d20 3c64 6f75 626c 653e 2820 6a6a  ] = <double>( jj
-00030c00: 2d20 284e 5250 6869 5f69 6e74 2d6e 5068  - (NRPhi_int-nPh
-00030c10: 6930 2920 290a 2020 2020 2020 2020 4e50  i0) ).        NP
-00030c20: 202b 3d20 5a6e 2a50 6869 6e5b 6969 5d0a   += Zn*Phin[ii].
-00030c30: 2020 2020 5074 7320 3d20 6e70 2e65 6d70      Pts = np.emp
-00030c40: 7479 2828 332c 4e50 2929 0a20 2020 2069  ty((3,NP)).    i
-00030c50: 6e64 203d 206e 702e 656d 7074 7928 284e  nd = np.empty((N
-00030c60: 502c 2929 0a20 2020 2064 5620 3d20 6e70  P,)).    dV = np
-00030c70: 2e65 6d70 7479 2828 4e50 2c29 290a 2020  .empty((NP,)).  
-00030c80: 2020 2320 436f 6d70 7574 6520 5074 732c    # Compute Pts,
-00030c90: 2064 5620 616e 6420 696e 640a 2020 2020   dV and ind.    
-00030ca0: 2320 5468 6973 2074 7269 706c 6520 6c6f  # This triple lo
-00030cb0: 6f70 2069 7320 7468 6520 6c6f 6e67 6573  op is the longes
-00030cc0: 7420 7061 7274 2c20 6974 2074 616b 6573  t part, it takes
-00030cd0: 207e 3930 2520 6f66 2074 6865 2043 5055   ~90% of the CPU
-00030ce0: 2074 696d 650a 2020 2020 4e50 203d 2030   time.    NP = 0
-00030cf0: 0a20 2020 2069 6620 4f75 742e 6c6f 7765  .    if Out.lowe
-00030d00: 7228 293d 3d27 2878 2c79 2c7a 2927 3a0a  r()=='(x,y,z)':.
-00030d10: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
-00030d20: 6e20 7261 6e67 6528 302c 526e 293a 0a20  n range(0,Rn):. 
-00030d30: 2020 2020 2020 2020 2020 2023 2054 6f20             # To 
-00030d40: 6d61 6b65 2073 7572 6520 7468 6520 696e  make sure the in
-00030d50: 6469 6365 7320 6172 6520 696e 2069 6e63  dices are in inc
-00030d60: 7265 6173 696e 6720 6f72 6465 720a 2020  reasing order.  
-00030d70: 2020 2020 2020 2020 2020 6969 6920 3d20            iii = 
-00030d80: 6e70 2e73 6f72 7428 696e 6449 5b69 692c  np.sort(indI[ii,
-00030d90: 7e6e 702e 6973 6e61 6e28 696e 6449 5b69  ~np.isnan(indI[i
-00030da0: 692c 3a5d 295d 290a 2020 2020 2020 2020  i,:])]).        
-00030db0: 2020 2020 666f 7220 7a7a 2069 6e20 7261      for zz in ra
-00030dc0: 6e67 6528 302c 5a6e 293a 0a20 2020 2020  nge(0,Zn):.     
-00030dd0: 2020 2020 2020 2020 2020 2066 6f72 206a             for j
-00030de0: 6a20 696e 2072 616e 6765 2830 2c50 6869  j in range(0,Phi
-00030df0: 6e5b 6969 5d29 3a0a 2020 2020 2020 2020  n[ii]):.        
-00030e00: 2020 2020 2020 2020 2020 2020 696e 6469              indi
-00030e10: 696a 6a20 3d20 6969 695b 6a6a 5d0a 2020  ijj = iii[jj].  
-00030e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030e30: 2020 7068 6920 3d20 2d63 5f70 6920 2b20    phi = -c_pi + 
-00030e40: 2830 2e35 2b69 6e64 6969 6a6a 292a 6450  (0.5+indiijj)*dP
-00030e50: 6869 725b 6969 5d0a 2020 2020 2020 2020  hir[ii].        
-00030e60: 2020 2020 2020 2020 2020 2020 5074 735b              Pts[
-00030e70: 302c 4e50 5d20 3d20 525b 6969 5d2a 635f  0,NP] = R[ii]*c_
-00030e80: 636f 7328 7068 6929 0a20 2020 2020 2020  cos(phi).       
-00030e90: 2020 2020 2020 2020 2020 2020 2050 7473               Pts
-00030ea0: 5b31 2c4e 505d 203d 2052 5b69 695d 2a63  [1,NP] = R[ii]*c
-00030eb0: 5f73 696e 2870 6869 290a 2020 2020 2020  _sin(phi).      
-00030ec0: 2020 2020 2020 2020 2020 2020 2020 5074                Pt
-00030ed0: 735b 322c 4e50 5d20 3d20 5a5b 7a7a 5d0a  s[2,NP] = Z[zz].
+00030260: 206d 6172 6769 6e3d 6d61 7267 696e 290a   margin=margin).
+00030270: 2020 2020 526e 203d 206c 656e 2852 290a      Rn = len(R).
+00030280: 2020 2020 5a6e 203d 206c 656e 285a 290a      Zn = len(Z).
+00030290: 2020 2020 2320 4765 7420 7468 6520 6c69      # Get the li
+000302a0: 6d69 7473 2069 6620 616e 7920 2861 6e64  mits if any (and
+000302b0: 206d 616b 6520 7375 7265 2074 6f20 7265   make sure to re
+000302c0: 706c 6163 6520 7468 656d 2069 6e20 7468  place them in th
+000302d0: 6520 7072 6f70 6572 0a20 2020 2023 2071  e proper.    # q
+000302e0: 7561 6472 616e 7473 290a 2020 2020 6966  uadrants).    if
+000302f0: 2044 5068 6920 6973 204e 6f6e 653a 0a20   DPhi is None:. 
+00030300: 2020 2020 2020 2044 5068 6930 2c20 4450         DPhi0, DP
+00030310: 6869 3120 3d20 2d63 5f70 692c 2063 5f70  hi1 = -c_pi, c_p
+00030320: 690a 2020 2020 656c 7365 3a0a 2020 2020  i.    else:.    
+00030330: 2020 2020 4450 6869 3020 3d20 635f 6174      DPhi0 = c_at
+00030340: 616e 3228 635f 7369 6e28 4450 6869 5b30  an2(c_sin(DPhi[0
+00030350: 5d29 2c20 635f 636f 7328 4450 6869 5b30  ]), c_cos(DPhi[0
+00030360: 5d29 290a 2020 2020 2020 2020 4450 6869  ])).        DPhi
+00030370: 3120 3d20 635f 6174 616e 3228 635f 7369  1 = c_atan2(c_si
+00030380: 6e28 4450 6869 5b31 5d29 2c20 635f 636f  n(DPhi[1]), c_co
+00030390: 7328 4450 6869 5b31 5d29 290a 2020 2020  s(DPhi[1])).    
+000303a0: 6452 5068 6972 2c20 6450 6869 7220 3d20  dRPhir, dPhir = 
+000303b0: 6e70 2e65 6d70 7479 2828 526e 2c29 292c  np.empty((Rn,)),
+000303c0: 206e 702e 656d 7074 7928 2852 6e2c 2929   np.empty((Rn,))
+000303d0: 0a20 2020 2050 6869 6e20 3d20 6e70 2e65  .    Phin = np.e
+000303e0: 6d70 7479 2828 526e 2c29 2c64 7479 7065  mpty((Rn,),dtype
+000303f0: 3d69 6e74 290a 2020 2020 4e52 5068 6920  =int).    NRPhi 
+00030400: 3d20 6e70 2e65 6d70 7479 2828 526e 2c29  = np.empty((Rn,)
+00030410: 290a 2020 2020 4e52 5068 6930 203d 206e  ).    NRPhi0 = n
+00030420: 702e 7a65 726f 7328 2852 6e2c 292c 6474  p.zeros((Rn,),dt
+00030430: 7970 653d 696e 7429 0a20 2020 206e 5250  ype=int).    nRP
+00030440: 6869 302c 2069 6e64 5230 6969 203d 2030  hi0, indR0ii = 0
+00030450: 2c20 300a 2020 2020 4e50 2c20 4e50 6869  , 0.    NP, NPhi
+00030460: 6d61 7820 3d20 302c 2030 0a20 2020 2072  max = 0, 0.    r
+00030470: 6164 6975 735f 7261 7469 6f20 3d20 696e  adius_ratio = in
+00030480: 7428 635f 6365 696c 2852 5b52 6e2d 315d  t(c_ceil(R[Rn-1]
+00030490: 2f52 5b30 5d29 290a 2020 2020 666f 7220  /R[0])).    for 
+000304a0: 6969 2069 6e20 7261 6e67 6528 302c 526e  ii in range(0,Rn
+000304b0: 293a 0a20 2020 2020 2020 2023 2047 6574  ):.        # Get
+000304c0: 2074 6865 2061 6374 7561 6c20 5250 6869   the actual RPhi
+000304d0: 2072 6573 6f6c 7574 696f 6e20 616e 6420   resolution and 
+000304e0: 5068 6920 6d65 7368 2065 6c65 6d65 6e74  Phi mesh element
+000304f0: 7320 2821 2064 6570 656e 6473 206f 6e20  s (! depends on 
+00030500: 5221 290a 2020 2020 2020 2020 4e52 5068  R!).        NRPh
+00030510: 695b 6969 5d20 3d20 635f 6365 696c 2832  i[ii] = c_ceil(2
+00030520: 2e2a 635f 7069 2a52 5b69 695d 2f64 5250  .*c_pi*R[ii]/dRP
+00030530: 6869 290a 2020 2020 2020 2020 4e52 5068  hi).        NRPh
+00030540: 695f 696e 7420 3d20 696e 7428 4e52 5068  i_int = int(NRPh
+00030550: 695b 6969 5d29 0a20 2020 2020 2020 2064  i[ii]).        d
+00030560: 5068 6972 5b69 695d 203d 2032 2e2a 635f  Phir[ii] = 2.*c_
+00030570: 7069 2f4e 5250 6869 5b69 695d 0a20 2020  pi/NRPhi[ii].   
+00030580: 2020 2020 2064 5250 6869 725b 6969 5d20       dRPhir[ii] 
+00030590: 3d20 6450 6869 725b 6969 5d2a 525b 6969  = dPhir[ii]*R[ii
+000305a0: 5d0a 2020 2020 2020 2020 2320 4765 7420  ].        # Get 
+000305b0: 696e 6465 7820 616e 6420 6375 6d75 6c61  index and cumula
+000305c0: 7465 6420 696e 6469 6365 7320 6672 6f6d  ted indices from
+000305d0: 2062 6163 6b67 726f 756e 640a 2020 2020   background.    
+000305e0: 2020 2020 666f 7220 6a6a 2069 6e20 7261      for jj in ra
+000305f0: 6e67 6528 696e 6452 3069 692c 4e52 3029  nge(indR0ii,NR0)
+00030600: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00030610: 2052 305b 6a6a 5d3d 3d52 5b69 695d 3a0a   R0[jj]==R[ii]:.
+00030620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00030630: 696e 6452 3069 6920 3d20 6a6a 0a20 2020  indR0ii = jj.   
+00030640: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+00030650: 616b 0a20 2020 2020 2020 2020 2020 2065  ak.            e
+00030660: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00030670: 2020 2020 206e 5250 6869 3020 2b3d 203c       nRPhi0 += <
+00030680: 6c6f 6e67 3e63 5f63 6569 6c28 322e 2a63  long>c_ceil(2.*c
+00030690: 5f70 692a 5230 5b6a 6a5d 2f64 5250 6869  _pi*R0[jj]/dRPhi
+000306a0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000306b0: 2020 4e52 5068 6930 5b69 695d 203d 206e    NRPhi0[ii] = n
+000306c0: 5250 6869 302a 4e5a 0a20 2020 2020 2020  RPhi0*NZ.       
+000306d0: 2023 2047 6574 2069 6e64 6963 6573 206f   # Get indices o
+000306e0: 6620 7068 690a 2020 2020 2020 2020 2320  f phi.        # 
+000306f0: 4765 7420 7468 6520 6578 7472 656d 6520  Get the extreme 
+00030700: 696e 6469 6365 7320 6f66 2074 6865 206d  indices of the m
+00030710: 6573 6820 656c 656d 656e 7473 2074 6861  esh elements tha
+00030720: 7420 7265 616c 6c79 206e 6565 6420 746f  t really need to
+00030730: 0a20 2020 2020 2020 2023 2062 6520 6372  .        # be cr
+00030740: 6561 7465 6420 7769 7468 696e 2074 686f  eated within tho
+00030750: 7365 206c 696d 6974 730a 2020 2020 2020  se limits.      
+00030760: 2020 6162 7330 203d 2063 5f61 6273 2844    abs0 = c_abs(D
+00030770: 5068 6930 2b63 5f70 6929 0a20 2020 2020  Phi0+c_pi).     
+00030780: 2020 2069 6620 6162 7330 2d64 5068 6972     if abs0-dPhir
+00030790: 5b69 695d 2a63 5f66 6c6f 6f72 2861 6273  [ii]*c_floor(abs
+000307a0: 302f 6450 6869 725b 6969 5d29 203c 206d  0/dPhir[ii]) < m
+000307b0: 6172 6769 6e2a 6450 6869 725b 6969 5d3a  argin*dPhir[ii]:
+000307c0: 0a20 2020 2020 2020 2020 2020 206e 5068  .            nPh
+000307d0: 6930 203d 2069 6e74 2863 5f72 6f75 6e64  i0 = int(c_round
+000307e0: 2828 4450 6869 302b 635f 7069 292f 6450  ((DPhi0+c_pi)/dP
+000307f0: 6869 725b 6969 5d29 290a 2020 2020 2020  hir[ii])).      
+00030800: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00030810: 2020 2020 6e50 6869 3020 3d20 696e 7428      nPhi0 = int(
+00030820: 635f 666c 6f6f 7228 2844 5068 6930 2b63  c_floor((DPhi0+c
+00030830: 5f70 6929 2f64 5068 6972 5b69 695d 2929  _pi)/dPhir[ii]))
+00030840: 0a20 2020 2020 2020 2061 6273 3120 3d20  .        abs1 = 
+00030850: 635f 6162 7328 4450 6869 312b 635f 7069  c_abs(DPhi1+c_pi
+00030860: 290a 2020 2020 2020 2020 6966 2061 6273  ).        if abs
+00030870: 312d 6450 6869 725b 6969 5d2a 635f 666c  1-dPhir[ii]*c_fl
+00030880: 6f6f 7228 6162 7331 2f64 5068 6972 5b69  oor(abs1/dPhir[i
+00030890: 695d 2920 3c20 6d61 7267 696e 2a64 5068  i]) < margin*dPh
+000308a0: 6972 5b69 695d 3a0a 2020 2020 2020 2020  ir[ii]:.        
+000308b0: 2020 2020 6e50 6869 3120 3d20 696e 7428      nPhi1 = int(
+000308c0: 635f 726f 756e 6428 2844 5068 6931 2b63  c_round((DPhi1+c
+000308d0: 5f70 6929 2f64 5068 6972 5b69 695d 292d  _pi)/dPhir[ii])-
+000308e0: 3129 0a20 2020 2020 2020 2065 6c73 653a  1).        else:
+000308f0: 0a20 2020 2020 2020 2020 2020 206e 5068  .            nPh
+00030900: 6931 203d 2069 6e74 2863 5f66 6c6f 6f72  i1 = int(c_floor
+00030910: 2828 4450 6869 312b 635f 7069 292f 6450  ((DPhi1+c_pi)/dP
+00030920: 6869 725b 6969 5d29 290a 0a20 2020 2020  hir[ii]))..     
+00030930: 2020 2069 6620 4450 6869 303c 4450 6869     if DPhi0<DPhi
+00030940: 313a 0a20 2020 2020 2020 2020 2020 2023  1:.            #
+00030950: 696e 6449 2e61 7070 656e 6428 6c69 7374  indI.append(list
+00030960: 2872 616e 6765 286e 5068 6930 2c6e 5068  (range(nPhi0,nPh
+00030970: 6931 2b31 2929 290a 2020 2020 2020 2020  i1+1))).        
+00030980: 2020 2020 5068 696e 5b69 695d 203d 206e      Phin[ii] = n
+00030990: 5068 6931 2b31 2d6e 5068 6930 0a20 2020  Phi1+1-nPhi0.   
+000309a0: 2020 2020 2020 2020 2069 6620 6969 3d3d           if ii==
+000309b0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
+000309c0: 2020 2069 6e64 4920 3d20 6e70 2e6e 616e     indI = np.nan
+000309d0: 2a6e 702e 6f6e 6573 2828 526e 2c50 6869  *np.ones((Rn,Phi
+000309e0: 6e5b 6969 5d2a 7261 6469 7573 5f72 6174  n[ii]*radius_rat
+000309f0: 696f 2b31 2929 0a20 2020 2020 2020 2020  io+1)).         
+00030a00: 2020 2066 6f72 206a 6a20 696e 2072 616e     for jj in ran
+00030a10: 6765 2830 2c50 6869 6e5b 6969 5d29 3a0a  ge(0,Phin[ii]):.
+00030a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00030a30: 696e 6449 5b69 692c 6a6a 5d20 3d20 3c64  indI[ii,jj] = <d
+00030a40: 6f75 626c 653e 2820 6e50 6869 302b 6a6a  ouble>( nPhi0+jj
+00030a50: 2029 0a20 2020 2020 2020 2065 6c73 653a   ).        else:
+00030a60: 0a20 2020 2020 2020 2020 2020 2023 696e  .            #in
+00030a70: 6449 2e61 7070 656e 6428 6c69 7374 2872  dI.append(list(r
+00030a80: 616e 6765 286e 5068 6930 2c4e 5250 6869  ange(nPhi0,NRPhi
+00030a90: 5f69 6e74 292b 6c69 7374 2872 616e 6765  _int)+list(range
+00030aa0: 2830 2c6e 5068 6931 2b31 2929 2929 0a20  (0,nPhi1+1)))). 
+00030ab0: 2020 2020 2020 2020 2020 2050 6869 6e5b             Phin[
+00030ac0: 6969 5d20 3d20 6e50 6869 312b 312b 4e52  ii] = nPhi1+1+NR
+00030ad0: 5068 695f 696e 742d 6e50 6869 300a 2020  Phi_int-nPhi0.  
+00030ae0: 2020 2020 2020 2020 2020 6966 2069 693d            if ii=
+00030af0: 3d30 3a0a 2020 2020 2020 2020 2020 2020  =0:.            
+00030b00: 2020 2020 696e 6449 203d 206e 702e 6e61      indI = np.na
+00030b10: 6e2a 6e70 2e6f 6e65 7328 2852 6e2c 5068  n*np.ones((Rn,Ph
+00030b20: 696e 5b69 695d 2a72 6164 6975 735f 7261  in[ii]*radius_ra
+00030b30: 7469 6f2b 3129 290a 2020 2020 2020 2020  tio+1)).        
+00030b40: 2020 2020 666f 7220 6a6a 2069 6e20 7261      for jj in ra
+00030b50: 6e67 6528 302c 4e52 5068 695f 696e 742d  nge(0,NRPhi_int-
+00030b60: 6e50 6869 3029 3a0a 2020 2020 2020 2020  nPhi0):.        
+00030b70: 2020 2020 2020 2020 696e 6449 5b69 692c          indI[ii,
+00030b80: 6a6a 5d20 3d20 3c64 6f75 626c 653e 2820  jj] = <double>( 
+00030b90: 6e50 6869 302b 6a6a 2029 0a20 2020 2020  nPhi0+jj ).     
+00030ba0: 2020 2020 2020 2066 6f72 206a 6a20 696e         for jj in
+00030bb0: 2072 616e 6765 284e 5250 6869 5f69 6e74   range(NRPhi_int
+00030bc0: 2d6e 5068 6930 2c50 6869 6e5b 6969 5d29  -nPhi0,Phin[ii])
+00030bd0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00030be0: 2020 696e 6449 5b69 692c 6a6a 5d20 3d20    indI[ii,jj] = 
+00030bf0: 3c64 6f75 626c 653e 2820 6a6a 2d20 284e  <double>( jj- (N
+00030c00: 5250 6869 5f69 6e74 2d6e 5068 6930 2920  RPhi_int-nPhi0) 
+00030c10: 290a 2020 2020 2020 2020 4e50 202b 3d20  ).        NP += 
+00030c20: 5a6e 2a50 6869 6e5b 6969 5d0a 2020 2020  Zn*Phin[ii].    
+00030c30: 5074 7320 3d20 6e70 2e65 6d70 7479 2828  Pts = np.empty((
+00030c40: 332c 4e50 2929 0a20 2020 2069 6e64 203d  3,NP)).    ind =
+00030c50: 206e 702e 656d 7074 7928 284e 502c 2929   np.empty((NP,))
+00030c60: 0a20 2020 2064 5620 3d20 6e70 2e65 6d70  .    dV = np.emp
+00030c70: 7479 2828 4e50 2c29 290a 2020 2020 2320  ty((NP,)).    # 
+00030c80: 436f 6d70 7574 6520 5074 732c 2064 5620  Compute Pts, dV 
+00030c90: 616e 6420 696e 640a 2020 2020 2320 5468  and ind.    # Th
+00030ca0: 6973 2074 7269 706c 6520 6c6f 6f70 2069  is triple loop i
+00030cb0: 7320 7468 6520 6c6f 6e67 6573 7420 7061  s the longest pa
+00030cc0: 7274 2c20 6974 2074 616b 6573 207e 3930  rt, it takes ~90
+00030cd0: 2520 6f66 2074 6865 2043 5055 2074 696d  % of the CPU tim
+00030ce0: 650a 2020 2020 4e50 203d 2030 0a20 2020  e.    NP = 0.   
+00030cf0: 2069 6620 4f75 742e 6c6f 7765 7228 293d   if Out.lower()=
+00030d00: 3d27 2878 2c79 2c7a 2927 3a0a 2020 2020  ='(x,y,z)':.    
+00030d10: 2020 2020 666f 7220 6969 2069 6e20 7261      for ii in ra
+00030d20: 6e67 6528 302c 526e 293a 0a20 2020 2020  nge(0,Rn):.     
+00030d30: 2020 2020 2020 2023 2054 6f20 6d61 6b65         # To make
+00030d40: 2073 7572 6520 7468 6520 696e 6469 6365   sure the indice
+00030d50: 7320 6172 6520 696e 2069 6e63 7265 6173  s are in increas
+00030d60: 696e 6720 6f72 6465 720a 2020 2020 2020  ing order.      
+00030d70: 2020 2020 2020 6969 6920 3d20 6e70 2e73        iii = np.s
+00030d80: 6f72 7428 696e 6449 5b69 692c 7e6e 702e  ort(indI[ii,~np.
+00030d90: 6973 6e61 6e28 696e 6449 5b69 692c 3a5d  isnan(indI[ii,:]
+00030da0: 295d 290a 2020 2020 2020 2020 2020 2020  )]).            
+00030db0: 666f 7220 7a7a 2069 6e20 7261 6e67 6528  for zz in range(
+00030dc0: 302c 5a6e 293a 0a20 2020 2020 2020 2020  0,Zn):.         
+00030dd0: 2020 2020 2020 2066 6f72 206a 6a20 696e         for jj in
+00030de0: 2072 616e 6765 2830 2c50 6869 6e5b 6969   range(0,Phin[ii
+00030df0: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+00030e00: 2020 2020 2020 2020 696e 6469 696a 6a20          indiijj 
+00030e10: 3d20 6969 695b 6a6a 5d0a 2020 2020 2020  = iii[jj].      
+00030e20: 2020 2020 2020 2020 2020 2020 2020 7068                ph
+00030e30: 6920 3d20 2d63 5f70 6920 2b20 2830 2e35  i = -c_pi + (0.5
+00030e40: 2b69 6e64 6969 6a6a 292a 6450 6869 725b  +indiijj)*dPhir[
+00030e50: 6969 5d0a 2020 2020 2020 2020 2020 2020  ii].            
+00030e60: 2020 2020 2020 2020 5074 735b 302c 4e50          Pts[0,NP
+00030e70: 5d20 3d20 525b 6969 5d2a 635f 636f 7328  ] = R[ii]*c_cos(
+00030e80: 7068 6929 0a20 2020 2020 2020 2020 2020  phi).           
+00030e90: 2020 2020 2020 2020 2050 7473 5b31 2c4e           Pts[1,N
+00030ea0: 505d 203d 2052 5b69 695d 2a63 5f73 696e  P] = R[ii]*c_sin
+00030eb0: 2870 6869 290a 2020 2020 2020 2020 2020  (phi).          
+00030ec0: 2020 2020 2020 2020 2020 5074 735b 322c            Pts[2,
+00030ed0: 4e50 5d20 3d20 5a5b 7a7a 5d0a 2020 2020  NP] = Z[zz].    
 00030ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030ef0: 2020 2020 696e 645b 4e50 5d20 3d20 4e52      ind[NP] = NR
-00030f00: 5068 6930 5b69 695d 202b 2069 6e64 5a5b  Phi0[ii] + indZ[
-00030f10: 7a7a 5d2a 4e52 5068 695b 6969 5d20 2b20  zz]*NRPhi[ii] + 
-00030f20: 696e 6469 696a 6a0a 2020 2020 2020 2020  indiijj.        
-00030f30: 2020 2020 2020 2020 2020 2020 6456 5b4e              dV[N
-00030f40: 505d 203d 2072 6573 6f5f 722a 7265 736f  P] = reso_r*reso
-00030f50: 5f7a 2a64 5250 6869 725b 6969 5d0a 2020  _z*dRPhir[ii].  
-00030f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030f70: 2020 4e50 202b 3d20 310a 2020 2020 656c    NP += 1.    el
-00030f80: 7365 3a0a 2020 2020 2020 2020 666f 7220  se:.        for 
-00030f90: 6969 2069 6e20 7261 6e67 6528 302c 526e  ii in range(0,Rn
-00030fa0: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
-00030fb0: 6969 203d 206e 702e 736f 7274 2869 6e64  ii = np.sort(ind
-00030fc0: 495b 6969 2c7e 6e70 2e69 736e 616e 2869  I[ii,~np.isnan(i
-00030fd0: 6e64 495b 6969 2c3a 5d29 5d29 0a20 2020  ndI[ii,:])]).   
-00030fe0: 2020 2020 2020 2020 2023 6173 7365 7274           #assert
-00030ff0: 2069 6969 2e73 697a 653d 3d50 6869 6e5b   iii.size==Phin[
-00031000: 6969 5d20 616e 6420 6e70 2e61 6c6c 286e  ii] and np.all(n
-00031010: 702e 756e 6971 7565 2869 6969 293d 3d69  p.unique(iii)==i
-00031020: 6969 290a 2020 2020 2020 2020 2020 2020  ii).            
-00031030: 666f 7220 7a7a 2069 6e20 7261 6e67 6528  for zz in range(
-00031040: 302c 5a6e 293a 0a20 2020 2020 2020 2020  0,Zn):.         
-00031050: 2020 2020 2020 2066 6f72 206a 6a20 696e         for jj in
-00031060: 2072 616e 6765 2830 2c50 6869 6e5b 6969   range(0,Phin[ii
-00031070: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00031080: 2020 2020 2020 2020 696e 6469 696a 6a20          indiijj 
-00031090: 3d20 6969 695b 6a6a 5d20 2369 6e64 495b  = iii[jj] #indI[
-000310a0: 6969 2c69 6969 5b6a 6a5d 5d0a 2020 2020  ii,iii[jj]].    
-000310b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000310c0: 5074 735b 302c 4e50 5d20 3d20 525b 6969  Pts[0,NP] = R[ii
-000310d0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-000310e0: 2020 2020 2020 5074 735b 312c 4e50 5d20        Pts[1,NP] 
-000310f0: 3d20 5a5b 7a7a 5d0a 2020 2020 2020 2020  = Z[zz].        
-00031100: 2020 2020 2020 2020 2020 2020 5074 735b              Pts[
-00031110: 322c 4e50 5d20 3d20 2d63 5f70 6920 2b20  2,NP] = -c_pi + 
-00031120: 2830 2e35 2b69 6e64 6969 6a6a 292a 6450  (0.5+indiijj)*dP
-00031130: 6869 725b 6969 5d0a 2020 2020 2020 2020  hir[ii].        
-00031140: 2020 2020 2020 2020 2020 2020 696e 645b              ind[
-00031150: 4e50 5d20 3d20 4e52 5068 6930 5b69 695d  NP] = NRPhi0[ii]
-00031160: 202b 2069 6e64 5a5b 7a7a 5d2a 4e52 5068   + indZ[zz]*NRPh
-00031170: 695b 6969 5d20 2b20 696e 6469 696a 6a0a  i[ii] + indiijj.
+00030ef0: 696e 645b 4e50 5d20 3d20 4e52 5068 6930  ind[NP] = NRPhi0
+00030f00: 5b69 695d 202b 2069 6e64 5a5b 7a7a 5d2a  [ii] + indZ[zz]*
+00030f10: 4e52 5068 695b 6969 5d20 2b20 696e 6469  NRPhi[ii] + indi
+00030f20: 696a 6a0a 2020 2020 2020 2020 2020 2020  ijj.            
+00030f30: 2020 2020 2020 2020 6456 5b4e 505d 203d          dV[NP] =
+00030f40: 2072 6573 6f5f 722a 7265 736f 5f7a 2a64   reso_r*reso_z*d
+00030f50: 5250 6869 725b 6969 5d0a 2020 2020 2020  RPhir[ii].      
+00030f60: 2020 2020 2020 2020 2020 2020 2020 4e50                NP
+00030f70: 202b 3d20 310a 2020 2020 656c 7365 3a0a   += 1.    else:.
+00030f80: 2020 2020 2020 2020 666f 7220 6969 2069          for ii i
+00030f90: 6e20 7261 6e67 6528 302c 526e 293a 0a20  n range(0,Rn):. 
+00030fa0: 2020 2020 2020 2020 2020 2069 6969 203d             iii =
+00030fb0: 206e 702e 736f 7274 2869 6e64 495b 6969   np.sort(indI[ii
+00030fc0: 2c7e 6e70 2e69 736e 616e 2869 6e64 495b  ,~np.isnan(indI[
+00030fd0: 6969 2c3a 5d29 5d29 0a20 2020 2020 2020  ii,:])]).       
+00030fe0: 2020 2020 2023 6173 7365 7274 2069 6969       #assert iii
+00030ff0: 2e73 697a 653d 3d50 6869 6e5b 6969 5d20  .size==Phin[ii] 
+00031000: 616e 6420 6e70 2e61 6c6c 286e 702e 756e  and np.all(np.un
+00031010: 6971 7565 2869 6969 293d 3d69 6969 290a  ique(iii)==iii).
+00031020: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00031030: 7a7a 2069 6e20 7261 6e67 6528 302c 5a6e  zz in range(0,Zn
+00031040: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00031050: 2020 2066 6f72 206a 6a20 696e 2072 616e     for jj in ran
+00031060: 6765 2830 2c50 6869 6e5b 6969 5d29 3a0a  ge(0,Phin[ii]):.
+00031070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00031080: 2020 2020 696e 6469 696a 6a20 3d20 6969      indiijj = ii
+00031090: 695b 6a6a 5d20 2369 6e64 495b 6969 2c69  i[jj] #indI[ii,i
+000310a0: 6969 5b6a 6a5d 5d0a 2020 2020 2020 2020  ii[jj]].        
+000310b0: 2020 2020 2020 2020 2020 2020 5074 735b              Pts[
+000310c0: 302c 4e50 5d20 3d20 525b 6969 5d0a 2020  0,NP] = R[ii].  
+000310d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000310e0: 2020 5074 735b 312c 4e50 5d20 3d20 5a5b    Pts[1,NP] = Z[
+000310f0: 7a7a 5d0a 2020 2020 2020 2020 2020 2020  zz].            
+00031100: 2020 2020 2020 2020 5074 735b 322c 4e50          Pts[2,NP
+00031110: 5d20 3d20 2d63 5f70 6920 2b20 2830 2e35  ] = -c_pi + (0.5
+00031120: 2b69 6e64 6969 6a6a 292a 6450 6869 725b  +indiijj)*dPhir[
+00031130: 6969 5d0a 2020 2020 2020 2020 2020 2020  ii].            
+00031140: 2020 2020 2020 2020 696e 645b 4e50 5d20          ind[NP] 
+00031150: 3d20 4e52 5068 6930 5b69 695d 202b 2069  = NRPhi0[ii] + i
+00031160: 6e64 5a5b 7a7a 5d2a 4e52 5068 695b 6969  ndZ[zz]*NRPhi[ii
+00031170: 5d20 2b20 696e 6469 696a 6a0a 2020 2020  ] + indiijj.    
 00031180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00031190: 2020 2020 6456 5b4e 505d 203d 2072 6573      dV[NP] = res
-000311a0: 6f5f 722a 7265 736f 5f7a 2a64 5250 6869  o_r*reso_z*dRPhi
-000311b0: 725b 6969 5d0a 2020 2020 2020 2020 2020  r[ii].          
-000311c0: 2020 2020 2020 2020 2020 4e50 202b 3d20            NP += 
-000311d0: 310a 2020 2020 6966 2056 506f 6c79 2069  1.    if VPoly i
-000311e0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-000311f0: 2020 2020 6966 204f 7574 2e6c 6f77 6572      if Out.lower
-00031200: 2829 3d3d 2728 782c 792c 7a29 273a 0a20  ()=='(x,y,z)':. 
-00031210: 2020 2020 2020 2020 2020 2068 7970 6f74             hypot
-00031220: 203d 205f 6267 742e 636f 6d70 7574 655f   = _bgt.compute_
-00031230: 6879 706f 7428 5074 735b 302c 3a5d 2c50  hypot(Pts[0,:],P
-00031240: 7473 5b31 2c3a 5d29 0a20 2020 2020 2020  ts[1,:]).       
-00031250: 2020 2020 2069 6e64 696e 203d 2050 6174       indin = Pat
-00031260: 6828 5650 6f6c 792e 5429 2e63 6f6e 7461  h(VPoly.T).conta
-00031270: 696e 735f 706f 696e 7473 286e 702e 6172  ins_points(np.ar
-00031280: 7261 7928 5b68 7970 6f74 2c50 7473 5b32  ray([hypot,Pts[2
-00031290: 2c3a 5d5d 292e 542c 0a20 2020 2020 2020  ,:]]).T,.       
+00031190: 6456 5b4e 505d 203d 2072 6573 6f5f 722a  dV[NP] = reso_r*
+000311a0: 7265 736f 5f7a 2a64 5250 6869 725b 6969  reso_z*dRPhir[ii
+000311b0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000311c0: 2020 2020 2020 4e50 202b 3d20 310a 2020        NP += 1.  
+000311d0: 2020 6966 2056 506f 6c79 2069 7320 6e6f    if VPoly is no
+000311e0: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+000311f0: 6966 204f 7574 2e6c 6f77 6572 2829 3d3d  if Out.lower()==
+00031200: 2728 782c 792c 7a29 273a 0a20 2020 2020  '(x,y,z)':.     
+00031210: 2020 2020 2020 2068 7970 6f74 203d 205f         hypot = _
+00031220: 6267 742e 636f 6d70 7574 655f 6879 706f  bgt.compute_hypo
+00031230: 7428 5074 735b 302c 3a5d 2c50 7473 5b31  t(Pts[0,:],Pts[1
+00031240: 2c3a 5d29 0a20 2020 2020 2020 2020 2020  ,:]).           
+00031250: 2069 6e64 696e 203d 2050 6174 6828 5650   indin = Path(VP
+00031260: 6f6c 792e 5429 2e63 6f6e 7461 696e 735f  oly.T).contains_
+00031270: 706f 696e 7473 286e 702e 6172 7261 7928  points(np.array(
+00031280: 5b68 7970 6f74 2c50 7473 5b32 2c3a 5d5d  [hypot,Pts[2,:]]
+00031290: 292e 542c 0a20 2020 2020 2020 2020 2020  ).T,.           
 000312a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000312b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000312c0: 2020 2020 2020 2020 2020 2074 7261 6e73             trans
-000312d0: 666f 726d 3d4e 6f6e 652c 2072 6164 6975  form=None, radiu
-000312e0: 733d 302e 3029 0a20 2020 2020 2020 2020  s=0.0).         
-000312f0: 2020 2050 7473 2c20 6456 2c20 696e 6420     Pts, dV, ind 
-00031300: 3d20 5074 735b 3a2c 696e 6469 6e5d 2c20  = Pts[:,indin], 
-00031310: 6456 5b69 6e64 696e 5d2c 2069 6e64 5b69  dV[indin], ind[i
-00031320: 6e64 696e 5d0a 2020 2020 2020 2020 2020  ndin].          
-00031330: 2020 5275 203d 206e 702e 756e 6971 7565    Ru = np.unique
-00031340: 2868 7970 6f74 290a 2020 2020 2020 2020  (hypot).        
-00031350: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00031360: 2020 696e 6469 6e20 3d20 5061 7468 2856    indin = Path(V
-00031370: 506f 6c79 2e54 292e 636f 6e74 6169 6e73  Poly.T).contains
-00031380: 5f70 6f69 6e74 7328 5074 735b 3a2d 312c  _points(Pts[:-1,
-00031390: 3a5d 2e54 2c20 7472 616e 7366 6f72 6d3d  :].T, transform=
-000313a0: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
+000312c0: 2020 2020 2020 2074 7261 6e73 666f 726d         transform
+000312d0: 3d4e 6f6e 652c 2072 6164 6975 733d 302e  =None, radius=0.
+000312e0: 3029 0a20 2020 2020 2020 2020 2020 2050  0).            P
+000312f0: 7473 2c20 6456 2c20 696e 6420 3d20 5074  ts, dV, ind = Pt
+00031300: 735b 3a2c 696e 6469 6e5d 2c20 6456 5b69  s[:,indin], dV[i
+00031310: 6e64 696e 5d2c 2069 6e64 5b69 6e64 696e  ndin], ind[indin
+00031320: 5d0a 2020 2020 2020 2020 2020 2020 5275  ].            Ru
+00031330: 203d 206e 702e 756e 6971 7565 2868 7970   = np.unique(hyp
+00031340: 6f74 290a 2020 2020 2020 2020 656c 7365  ot).        else
+00031350: 3a0a 2020 2020 2020 2020 2020 2020 696e  :.            in
+00031360: 6469 6e20 3d20 5061 7468 2856 506f 6c79  din = Path(VPoly
+00031370: 2e54 292e 636f 6e74 6169 6e73 5f70 6f69  .T).contains_poi
+00031380: 6e74 7328 5074 735b 3a2d 312c 3a5d 2e54  nts(Pts[:-1,:].T
+00031390: 2c20 7472 616e 7366 6f72 6d3d 4e6f 6e65  , transform=None
+000313a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 000313b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000313c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000313d0: 2020 2020 2020 2020 7261 6469 7573 3d30          radius=0
-000313e0: 2e30 290a 2020 2020 2020 2020 2020 2020  .0).            
-000313f0: 5074 732c 2064 562c 2069 6e64 203d 2050  Pts, dV, ind = P
-00031400: 7473 5b3a 2c69 6e64 696e 5d2c 2064 565b  ts[:,indin], dV[
-00031410: 696e 6469 6e5d 2c20 696e 645b 696e 6469  indin], ind[indi
-00031420: 6e5d 0a20 2020 2020 2020 2020 2020 2052  n].            R
-00031430: 7520 3d20 6e70 2e75 6e69 7175 6528 5074  u = np.unique(Pt
-00031440: 735b 302c 3a5d 290a 2020 2020 2020 2020  s[0,:]).        
-00031450: 2320 544f 444f 203a 2057 6172 6e69 6e67  # TODO : Warning
-00031460: 203a 2064 6f20 7765 206e 6565 6420 7468   : do we need th
-00031470: 6520 666f 6c6c 6f77 696e 6720 6c69 6e65  e following line
-00031480: 7320 3f3f 3f3f 0a20 2020 2020 2020 2023  s ????.        #
-00031490: 2069 6620 6e6f 7420 6e70 2e61 6c6c 2852   if not np.all(R
-000314a0: 753d 3d52 293a 0a20 2020 2020 2020 2023  u==R):.        #
-000314b0: 2020 2020 2064 5250 6869 7220 3d20 6e70       dRPhir = np
-000314c0: 2e61 7272 6179 285b 6452 5068 6972 5b69  .array([dRPhir[i
-000314d0: 695d 2066 6f72 2069 6920 696e 2072 616e  i] for ii in ran
-000314e0: 6765 2830 2c6c 656e 2852 2929 205c 0a20  ge(0,len(R)) \. 
-000314f0: 2020 2020 2020 2023 2020 2020 2020 2020         #        
-00031500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00031510: 6966 2052 5b69 695d 2069 6e20 5275 5d29  if R[ii] in Ru])
-00031520: 0a20 2020 2072 6574 7572 6e20 5074 732c  .    return Pts,
-00031530: 2064 562c 2069 6e64 2e61 7374 7970 6528   dV, ind.astype(
-00031540: 696e 7429 2c20 7265 736f 5f72 2c20 7265  int), reso_r, re
-00031550: 736f 5f7a 2c20 6e70 2e61 7361 7272 6179  so_z, np.asarray
-00031560: 2864 5250 6869 7229 0a0a 0a64 6566 205f  (dRPhir)...def _
-00031570: 5665 735f 566d 6573 685f 546f 725f 5375  Ves_Vmesh_Tor_Su
-00031580: 6246 726f 6d49 6e64 5f63 7974 686f 6e5f  bFromInd_cython_
-00031590: 6f6c 6428 646f 7562 6c65 2064 522c 2064  old(double dR, d
-000315a0: 6f75 626c 6520 645a 2c20 646f 7562 6c65  ouble dZ, double
-000315b0: 2064 5250 6869 2c0a 2020 2020 2020 2020   dRPhi,.        
+000313d0: 2020 2020 7261 6469 7573 3d30 2e30 290a      radius=0.0).
+000313e0: 2020 2020 2020 2020 2020 2020 5074 732c              Pts,
+000313f0: 2064 562c 2069 6e64 203d 2050 7473 5b3a   dV, ind = Pts[:
+00031400: 2c69 6e64 696e 5d2c 2064 565b 696e 6469  ,indin], dV[indi
+00031410: 6e5d 2c20 696e 645b 696e 6469 6e5d 0a20  n], ind[indin]. 
+00031420: 2020 2020 2020 2020 2020 2052 7520 3d20             Ru = 
+00031430: 6e70 2e75 6e69 7175 6528 5074 735b 302c  np.unique(Pts[0,
+00031440: 3a5d 290a 2020 2020 2020 2020 2320 544f  :]).        # TO
+00031450: 444f 203a 2057 6172 6e69 6e67 203a 2064  DO : Warning : d
+00031460: 6f20 7765 206e 6565 6420 7468 6520 666f  o we need the fo
+00031470: 6c6c 6f77 696e 6720 6c69 6e65 7320 3f3f  llowing lines ??
+00031480: 3f3f 0a20 2020 2020 2020 2023 2069 6620  ??.        # if 
+00031490: 6e6f 7420 6e70 2e61 6c6c 2852 753d 3d52  not np.all(Ru==R
+000314a0: 293a 0a20 2020 2020 2020 2023 2020 2020  ):.        #    
+000314b0: 2064 5250 6869 7220 3d20 6e70 2e61 7272   dRPhir = np.arr
+000314c0: 6179 285b 6452 5068 6972 5b69 695d 2066  ay([dRPhir[ii] f
+000314d0: 6f72 2069 6920 696e 2072 616e 6765 2830  or ii in range(0
+000314e0: 2c6c 656e 2852 2929 205c 0a20 2020 2020  ,len(R)) \.     
+000314f0: 2020 2023 2020 2020 2020 2020 2020 2020     #            
+00031500: 2020 2020 2020 2020 2020 2020 6966 2052              if R
+00031510: 5b69 695d 2069 6e20 5275 5d29 0a20 2020  [ii] in Ru]).   
+00031520: 2072 6574 7572 6e20 5074 732c 2064 562c   return Pts, dV,
+00031530: 2069 6e64 2e61 7374 7970 6528 696e 7429   ind.astype(int)
+00031540: 2c20 7265 736f 5f72 2c20 7265 736f 5f7a  , reso_r, reso_z
+00031550: 2c20 6e70 2e61 7361 7272 6179 2864 5250  , np.asarray(dRP
+00031560: 6869 7229 0a0a 0a64 6566 205f 5665 735f  hir)...def _Ves_
+00031570: 566d 6573 685f 546f 725f 5375 6246 726f  Vmesh_Tor_SubFro
+00031580: 6d49 6e64 5f63 7974 686f 6e5f 6f6c 6428  mInd_cython_old(
+00031590: 646f 7562 6c65 2064 522c 2064 6f75 626c  double dR, doubl
+000315a0: 6520 645a 2c20 646f 7562 6c65 2064 5250  e dZ, double dRP
+000315b0: 6869 2c0a 2020 2020 2020 2020 2020 2020  hi,.            
 000315c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000315d0: 2020 2020 2020 2020 2020 2020 2064 6f75               dou
-000315e0: 626c 655b 3a3a 315d 2052 4d69 6e4d 6178  ble[::1] RMinMax
-000315f0: 2c20 646f 7562 6c65 5b3a 3a31 5d20 5a4d  , double[::1] ZM
-00031600: 696e 4d61 782c 0a20 2020 2020 2020 2020  inMax,.         
+000315d0: 2020 2020 2020 2020 2064 6f75 626c 655b           double[
+000315e0: 3a3a 315d 2052 4d69 6e4d 6178 2c20 646f  ::1] RMinMax, do
+000315f0: 7562 6c65 5b3a 3a31 5d20 5a4d 696e 4d61  uble[::1] ZMinMa
+00031600: 782c 0a20 2020 2020 2020 2020 2020 2020  x,.             
 00031610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00031620: 2020 2020 2020 2020 2020 2020 6c6f 6e67              long
-00031630: 5b3a 3a31 5d20 696e 642c 2073 7472 204f  [::1] ind, str O
-00031640: 7574 3d27 2858 2c59 2c5a 2927 2c0a 2020  ut='(X,Y,Z)',.  
+00031620: 2020 2020 2020 2020 6c6f 6e67 5b3a 3a31          long[::1
+00031630: 5d20 696e 642c 2073 7472 204f 7574 3d27  ] ind, str Out='
+00031640: 2858 2c59 2c5a 2927 2c0a 2020 2020 2020  (X,Y,Z)',.      
 00031650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00031660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00031670: 2020 2064 6f75 626c 6520 6d61 7267 696e     double margin
-00031680: 3d5f 5653 4d41 4c4c 293a 0a20 2020 2022  =_VSMALL):.    "
-00031690: 2222 2052 6574 7572 6e20 7468 6520 6465  "" Return the de
-000316a0: 7369 7265 6420 7375 626d 6573 6820 696e  sired submesh in
-000316b0: 6469 6361 7465 6420 6279 2074 6865 2028  dicated by the (
-000316c0: 6e75 6d65 7269 6361 6c29 2069 6e64 6963  numerical) indic
-000316d0: 6573 2c0a 2020 2020 666f 7220 7468 6520  es,.    for the 
-000316e0: 6465 7369 7265 6420 7265 736f 6c75 7469  desired resoluti
-000316f0: 6f6e 2028 6452 2c64 5a2c 6452 7068 6929  on (dR,dZ,dRphi)
-00031700: 0a20 2020 2022 2222 0a20 2020 2063 6465  .    """.    cde
-00031710: 6620 646f 7562 6c65 5b3a 3a31 5d20 522c  f double[::1] R,
-00031720: 205a 2c20 6452 5068 6972 5265 662c 2064   Z, dRPhirRef, d
-00031730: 5068 6972 2c20 5275 2c20 6452 5068 6972  Phir, Ru, dRPhir
-00031740: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-00031750: 2072 6573 6f5f 722c 2072 6573 6f5f 7a2c   reso_r, reso_z,
-00031760: 2070 6869 0a20 2020 2063 6465 6620 6c6f   phi.    cdef lo
-00031770: 6e67 5b3a 3a31 5d20 696e 6452 2c20 696e  ng[::1] indR, in
-00031780: 645a 2c20 4e52 5068 6930 2c20 4e52 5068  dZ, NRPhi0, NRPh
-00031790: 690a 2020 2020 6364 6566 206c 6f6e 6720  i.    cdef long 
-000317a0: 4e52 2c20 4e5a 2c20 526e 2c20 5a6e 2c20  NR, NZ, Rn, Zn, 
-000317b0: 4e50 3d6c 656e 2869 6e64 292c 2072 6164  NP=len(ind), rad
-000317c0: 6975 735f 7261 7469 6f0a 2020 2020 6364  ius_ratio.    cd
-000317d0: 6566 2069 6e74 2069 693d 302c 206a 6a3d  ef int ii=0, jj=
-000317e0: 302c 2069 6952 2c20 6969 5a2c 2069 6970  0, iiR, iiZ, iip
-000317f0: 6869 0a20 2020 2063 6465 6620 646f 7562  hi.    cdef doub
-00031800: 6c65 5b3a 2c3a 3a31 5d20 5068 690a 2020  le[:,::1] Phi.  
-00031810: 2020 6364 6566 206e 702e 6e64 6172 7261    cdef np.ndarra
-00031820: 795b 646f 7562 6c65 2c6e 6469 6d3d 325d  y[double,ndim=2]
-00031830: 2050 7473 3d6e 702e 656d 7074 7928 2833   Pts=np.empty((3
-00031840: 2c4e 5029 290a 2020 2020 6364 6566 206e  ,NP)).    cdef n
-00031850: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-00031860: 2c6e 6469 6d3d 315d 2064 563d 6e70 2e65  ,ndim=1] dV=np.e
-00031870: 6d70 7479 2828 4e50 2c29 290a 0a20 2020  mpty((NP,))..   
-00031880: 2077 6172 6e28 2259 6f75 2061 7265 2075   warn("You are u
-00031890: 7369 6e67 2074 6865 206f 6c64 2061 6c67  sing the old alg
-000318a0: 6f72 6974 686d 2066 6f72 206d 6573 6869  orithm for meshi
-000318b0: 6e67 2061 2076 6f6c 756d 652e 220a 2020  ng a volume.".  
-000318c0: 2020 2020 2020 202b 2022 2054 6869 7320         + " This 
-000318d0: 616c 676f 7269 7468 6d20 6973 2073 6c6f  algorithm is slo
-000318e0: 7765 7220 7468 616e 2074 6865 206e 6577  wer than the new
-000318f0: 206f 6e65 2e22 2c20 5761 726e 696e 6729   one.", Warning)
-00031900: 0a0a 2020 2020 2320 4765 7420 7468 6520  ..    # Get the 
-00031910: 6163 7475 616c 2052 2061 6e64 205a 2072  actual R and Z r
-00031920: 6573 6f6c 7574 696f 6e73 2061 6e64 206d  esolutions and m
-00031930: 6573 6820 656c 656d 656e 7473 0a20 2020  esh elements.   
-00031940: 2052 2c20 7265 736f 5f72 2c20 696e 6452   R, reso_r, indR
-00031950: 2c20 4e52 203d 2064 6973 6372 6574 697a  , NR = discretiz
-00031960: 655f 6c69 6e65 3164 2852 4d69 6e4d 6178  e_line1d(RMinMax
-00031970: 2c20 6452 2c20 4e6f 6e65 2c20 4c69 6d3d  , dR, None, Lim=
-00031980: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+00031660: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00031670: 6f75 626c 6520 6d61 7267 696e 3d5f 5653  ouble margin=_VS
+00031680: 4d41 4c4c 293a 0a20 2020 2022 2222 2052  MALL):.    """ R
+00031690: 6574 7572 6e20 7468 6520 6465 7369 7265  eturn the desire
+000316a0: 6420 7375 626d 6573 6820 696e 6469 6361  d submesh indica
+000316b0: 7465 6420 6279 2074 6865 2028 6e75 6d65  ted by the (nume
+000316c0: 7269 6361 6c29 2069 6e64 6963 6573 2c0a  rical) indices,.
+000316d0: 2020 2020 666f 7220 7468 6520 6465 7369      for the desi
+000316e0: 7265 6420 7265 736f 6c75 7469 6f6e 2028  red resolution (
+000316f0: 6452 2c64 5a2c 6452 7068 6929 0a20 2020  dR,dZ,dRphi).   
+00031700: 2022 2222 0a20 2020 2063 6465 6620 646f   """.    cdef do
+00031710: 7562 6c65 5b3a 3a31 5d20 522c 205a 2c20  uble[::1] R, Z, 
+00031720: 6452 5068 6972 5265 662c 2064 5068 6972  dRPhirRef, dPhir
+00031730: 2c20 5275 2c20 6452 5068 6972 0a20 2020  , Ru, dRPhir.   
+00031740: 2063 6465 6620 646f 7562 6c65 2072 6573   cdef double res
+00031750: 6f5f 722c 2072 6573 6f5f 7a2c 2070 6869  o_r, reso_z, phi
+00031760: 0a20 2020 2063 6465 6620 6c6f 6e67 5b3a  .    cdef long[:
+00031770: 3a31 5d20 696e 6452 2c20 696e 645a 2c20  :1] indR, indZ, 
+00031780: 4e52 5068 6930 2c20 4e52 5068 690a 2020  NRPhi0, NRPhi.  
+00031790: 2020 6364 6566 206c 6f6e 6720 4e52 2c20    cdef long NR, 
+000317a0: 4e5a 2c20 526e 2c20 5a6e 2c20 4e50 3d6c  NZ, Rn, Zn, NP=l
+000317b0: 656e 2869 6e64 292c 2072 6164 6975 735f  en(ind), radius_
+000317c0: 7261 7469 6f0a 2020 2020 6364 6566 2069  ratio.    cdef i
+000317d0: 6e74 2069 693d 302c 206a 6a3d 302c 2069  nt ii=0, jj=0, i
+000317e0: 6952 2c20 6969 5a2c 2069 6970 6869 0a20  iR, iiZ, iiphi. 
+000317f0: 2020 2063 6465 6620 646f 7562 6c65 5b3a     cdef double[:
+00031800: 2c3a 3a31 5d20 5068 690a 2020 2020 6364  ,::1] Phi.    cd
+00031810: 6566 206e 702e 6e64 6172 7261 795b 646f  ef np.ndarray[do
+00031820: 7562 6c65 2c6e 6469 6d3d 325d 2050 7473  uble,ndim=2] Pts
+00031830: 3d6e 702e 656d 7074 7928 2833 2c4e 5029  =np.empty((3,NP)
+00031840: 290a 2020 2020 6364 6566 206e 702e 6e64  ).    cdef np.nd
+00031850: 6172 7261 795b 646f 7562 6c65 2c6e 6469  array[double,ndi
+00031860: 6d3d 315d 2064 563d 6e70 2e65 6d70 7479  m=1] dV=np.empty
+00031870: 2828 4e50 2c29 290a 0a20 2020 2077 6172  ((NP,))..    war
+00031880: 6e28 2259 6f75 2061 7265 2075 7369 6e67  n("You are using
+00031890: 2074 6865 206f 6c64 2061 6c67 6f72 6974   the old algorit
+000318a0: 686d 2066 6f72 206d 6573 6869 6e67 2061  hm for meshing a
+000318b0: 2076 6f6c 756d 652e 220a 2020 2020 2020   volume.".      
+000318c0: 2020 202b 2022 2054 6869 7320 616c 676f     + " This algo
+000318d0: 7269 7468 6d20 6973 2073 6c6f 7765 7220  rithm is slower 
+000318e0: 7468 616e 2074 6865 206e 6577 206f 6e65  than the new one
+000318f0: 2e22 2c20 5761 726e 696e 6729 0a0a 2020  .", Warning)..  
+00031900: 2020 2320 4765 7420 7468 6520 6163 7475    # Get the actu
+00031910: 616c 2052 2061 6e64 205a 2072 6573 6f6c  al R and Z resol
+00031920: 7574 696f 6e73 2061 6e64 206d 6573 6820  utions and mesh 
+00031930: 656c 656d 656e 7473 0a20 2020 2052 2c20  elements.    R, 
+00031940: 7265 736f 5f72 2c20 696e 6452 2c20 4e52  reso_r, indR, NR
+00031950: 203d 2064 6973 6372 6574 697a 655f 6c69   = discretize_li
+00031960: 6e65 3164 2852 4d69 6e4d 6178 2c20 6452  ne1d(RMinMax, dR
+00031970: 2c20 4e6f 6e65 2c20 4c69 6d3d 5472 7565  , None, Lim=True
+00031980: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 00031990: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000319a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000319b0: 2020 2020 2020 6d61 7267 696e 3d6d 6172        margin=mar
-000319c0: 6769 6e29 0a20 2020 205a 2c20 7265 736f  gin).    Z, reso
-000319d0: 5f7a 2c20 696e 645a 2c20 4e5a 203d 2064  _z, indZ, NZ = d
-000319e0: 6973 6372 6574 697a 655f 6c69 6e65 3164  iscretize_line1d
-000319f0: 285a 4d69 6e4d 6178 2c20 645a 2c20 4e6f  (ZMinMax, dZ, No
-00031a00: 6e65 2c20 4c69 6d3d 5472 7565 2c0a 2020  ne, Lim=True,.  
+000319b0: 2020 6d61 7267 696e 3d6d 6172 6769 6e29    margin=margin)
+000319c0: 0a20 2020 205a 2c20 7265 736f 5f7a 2c20  .    Z, reso_z, 
+000319d0: 696e 645a 2c20 4e5a 203d 2064 6973 6372  indZ, NZ = discr
+000319e0: 6574 697a 655f 6c69 6e65 3164 285a 4d69  etize_line1d(ZMi
+000319f0: 6e4d 6178 2c20 645a 2c20 4e6f 6e65 2c20  nMax, dZ, None, 
+00031a00: 4c69 6d3d 5472 7565 2c0a 2020 2020 2020  Lim=True,.      
 00031a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00031a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00031a30: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
-00031a40: 7267 696e 3d6d 6172 6769 6e29 0a20 2020  rgin=margin).   
-00031a50: 2052 6e2c 205a 6e20 3d20 6c65 6e28 5229   Rn, Zn = len(R)
-00031a60: 2c20 6c65 6e28 5a29 0a0a 2020 2020 2320  , len(Z)..    # 
-00031a70: 4e75 6d62 6572 206f 6620 5068 6920 7065  Number of Phi pe
-00031a80: 7220 520a 2020 2020 6452 5068 6972 5265  r R.    dRPhirRe
-00031a90: 662c 2064 5068 6972 203d 206e 702e 656d  f, dPhir = np.em
-00031aa0: 7074 7928 284e 522c 2929 2c20 6e70 2e65  pty((NR,)), np.e
-00031ab0: 6d70 7479 2828 4e52 2c29 290a 2020 2020  mpty((NR,)).    
-00031ac0: 5275 2c20 6452 5068 6972 203d 206e 702e  Ru, dRPhir = np.
-00031ad0: 7a65 726f 7328 284e 522c 2929 2c20 6e70  zeros((NR,)), np
-00031ae0: 2e6e 616e 2a6e 702e 6f6e 6573 2828 4e52  .nan*np.ones((NR
-00031af0: 2c29 290a 2020 2020 4e52 5068 692c 204e  ,)).    NRPhi, N
-00031b00: 5250 6869 3020 3d20 6e70 2e65 6d70 7479  RPhi0 = np.empty
-00031b10: 2828 4e52 2c29 2c64 7479 7065 3d69 6e74  ((NR,),dtype=int
-00031b20: 292c 206e 702e 656d 7074 7928 284e 522b  ), np.empty((NR+
-00031b30: 312c 292c 6474 7970 653d 696e 7429 0a20  1,),dtype=int). 
-00031b40: 2020 2072 6164 6975 735f 7261 7469 6f20     radius_ratio 
-00031b50: 3d20 696e 7428 635f 6365 696c 2852 5b4e  = int(c_ceil(R[N
-00031b60: 522d 315d 2f52 5b30 5d29 290a 2020 2020  R-1]/R[0])).    
-00031b70: 666f 7220 6969 2069 6e20 7261 6e67 6528  for ii in range(
-00031b80: 302c 4e52 293a 0a20 2020 2020 2020 204e  0,NR):.        N
-00031b90: 5250 6869 5b69 695d 203d 203c 6c6f 6e67  RPhi[ii] = <long
-00031ba0: 3e28 635f 6365 696c 2832 2e2a 635f 7069  >(c_ceil(2.*c_pi
-00031bb0: 2a52 5b69 695d 2f64 5250 6869 2929 0a20  *R[ii]/dRPhi)). 
-00031bc0: 2020 2020 2020 2064 5250 6869 7252 6566         dRPhirRef
-00031bd0: 5b69 695d 203d 2032 2e2a 635f 7069 2a52  [ii] = 2.*c_pi*R
-00031be0: 5b69 695d 2f3c 646f 7562 6c65 3e28 4e52  [ii]/<double>(NR
-00031bf0: 5068 695b 6969 5d29 0a20 2020 2020 2020  Phi[ii]).       
-00031c00: 2064 5068 6972 5b69 695d 203d 2032 2e2a   dPhir[ii] = 2.*
-00031c10: 635f 7069 2f3c 646f 7562 6c65 3e28 4e52  c_pi/<double>(NR
-00031c20: 5068 695b 6969 5d29 0a20 2020 2020 2020  Phi[ii]).       
-00031c30: 2069 6620 6969 3d3d 303a 0a20 2020 2020   if ii==0:.     
-00031c40: 2020 2020 2020 204e 5250 6869 305b 6969         NRPhi0[ii
-00031c50: 5d20 3d20 300a 2020 2020 2020 2020 2020  ] = 0.          
-00031c60: 2020 5068 6920 3d20 6e70 2e65 6d70 7479    Phi = np.empty
-00031c70: 2828 4e52 2c4e 5250 6869 5b69 695d 2a72  ((NR,NRPhi[ii]*r
-00031c80: 6164 6975 735f 7261 7469 6f2b 3129 290a  adius_ratio+1)).
-00031c90: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00031ca0: 2020 2020 2020 2020 2020 4e52 5068 6930            NRPhi0
-00031cb0: 5b69 695d 203d 204e 5250 6869 305b 6969  [ii] = NRPhi0[ii
-00031cc0: 2d31 5d20 2b20 4e52 5068 695b 6969 2d31  -1] + NRPhi[ii-1
-00031cd0: 5d2a 4e5a 0a20 2020 2020 2020 2066 6f72  ]*NZ.        for
-00031ce0: 206a 6a20 696e 2072 616e 6765 2830 2c4e   jj in range(0,N
-00031cf0: 5250 6869 5b69 695d 293a 0a20 2020 2020  RPhi[ii]):.     
-00031d00: 2020 2020 2020 2050 6869 5b69 692c 6a6a         Phi[ii,jj
-00031d10: 5d20 3d20 2d63 5f70 6920 2b20 2830 2e35  ] = -c_pi + (0.5
-00031d20: 2b3c 646f 7562 6c65 3e6a 6a29 2a64 5068  +<double>jj)*dPh
-00031d30: 6972 5b69 695d 0a0a 2020 2020 6966 204f  ir[ii]..    if O
-00031d40: 7574 2e6c 6f77 6572 2829 3d3d 2728 782c  ut.lower()=='(x,
-00031d50: 792c 7a29 273a 0a20 2020 2020 2020 2066  y,z)':.        f
-00031d60: 6f72 2069 6920 696e 2072 616e 6765 2830  or ii in range(0
-00031d70: 2c4e 5029 3a0a 2020 2020 2020 2020 2020  ,NP):.          
-00031d80: 2020 666f 7220 6a6a 2069 6e20 7261 6e67    for jj in rang
-00031d90: 6528 302c 4e52 2b31 293a 0a20 2020 2020  e(0,NR+1):.     
-00031da0: 2020 2020 2020 2020 2020 2069 6620 696e             if in
-00031db0: 645b 6969 5d2d 4e52 5068 6930 5b6a 6a5d  d[ii]-NRPhi0[jj]
-00031dc0: 3c30 2e3a 0a20 2020 2020 2020 2020 2020  <0.:.           
-00031dd0: 2020 2020 2020 2020 2062 7265 616b 0a20           break. 
-00031de0: 2020 2020 2020 2020 2020 2069 6952 203d             iiR =
-00031df0: 206a 6a2d 310a 2020 2020 2020 2020 2020   jj-1.          
-00031e00: 2020 6969 5a20 3d20 2869 6e64 5b69 695d    iiZ = (ind[ii]
-00031e10: 202d 204e 5250 6869 305b 6969 525d 292f   - NRPhi0[iiR])/
-00031e20: 2f4e 5250 6869 5b69 6952 5d0a 2020 2020  /NRPhi[iiR].    
-00031e30: 2020 2020 2020 2020 6969 7068 6920 3d20          iiphi = 
-00031e40: 696e 645b 6969 5d20 2d20 4e52 5068 6930  ind[ii] - NRPhi0
-00031e50: 5b69 6952 5d20 2d20 6969 5a2a 4e52 5068  [iiR] - iiZ*NRPh
-00031e60: 695b 6969 525d 0a20 2020 2020 2020 2020  i[iiR].         
-00031e70: 2020 2070 6869 203d 2050 6869 5b69 6952     phi = Phi[iiR
-00031e80: 2c69 6970 6869 5d0a 2020 2020 2020 2020  ,iiphi].        
-00031e90: 2020 2020 5074 735b 302c 6969 5d20 3d20      Pts[0,ii] = 
-00031ea0: 525b 6969 525d 2a63 5f63 6f73 2870 6869  R[iiR]*c_cos(phi
-00031eb0: 290a 2020 2020 2020 2020 2020 2020 5074  ).            Pt
-00031ec0: 735b 312c 6969 5d20 3d20 525b 6969 525d  s[1,ii] = R[iiR]
-00031ed0: 2a63 5f73 696e 2870 6869 290a 2020 2020  *c_sin(phi).    
-00031ee0: 2020 2020 2020 2020 5074 735b 322c 6969          Pts[2,ii
-00031ef0: 5d20 3d20 5a5b 6969 5a5d 0a20 2020 2020  ] = Z[iiZ].     
-00031f00: 2020 2020 2020 2064 565b 6969 5d20 3d20         dV[ii] = 
-00031f10: 7265 736f 5f72 2a72 6573 6f5f 7a2a 6452  reso_r*reso_z*dR
-00031f20: 5068 6972 5265 665b 6969 525d 0a20 2020  PhirRef[iiR].   
-00031f30: 2020 2020 2020 2020 2069 6620 5275 5b69           if Ru[i
-00031f40: 6952 5d3d 3d30 2e3a 0a20 2020 2020 2020  iR]==0.:.       
-00031f50: 2020 2020 2020 2020 2064 5250 6869 725b           dRPhir[
-00031f60: 6969 525d 203d 2064 5250 6869 7252 6566  iiR] = dRPhirRef
-00031f70: 5b69 6952 5d0a 2020 2020 2020 2020 2020  [iiR].          
-00031f80: 2020 2020 2020 5275 5b69 6952 5d20 3d20        Ru[iiR] = 
-00031f90: 312e 0a20 2020 2065 6c73 653a 0a20 2020  1..    else:.   
-00031fa0: 2020 2020 2066 6f72 2069 6920 696e 2072       for ii in r
-00031fb0: 616e 6765 2830 2c4e 5029 3a0a 2020 2020  ange(0,NP):.    
-00031fc0: 2020 2020 2020 2020 666f 7220 6a6a 2069          for jj i
-00031fd0: 6e20 7261 6e67 6528 302c 4e52 2b31 293a  n range(0,NR+1):
-00031fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00031ff0: 2069 6620 696e 645b 6969 5d2d 4e52 5068   if ind[ii]-NRPh
-00032000: 6930 5b6a 6a5d 3c30 2e3a 0a20 2020 2020  i0[jj]<0.:.     
-00032010: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-00032020: 7265 616b 0a20 2020 2020 2020 2020 2020  reak.           
-00032030: 2069 6952 203d 206a 6a2d 310a 2020 2020   iiR = jj-1.    
-00032040: 2020 2020 2020 2020 6969 5a20 3d20 2869          iiZ = (i
-00032050: 6e64 5b69 695d 202d 204e 5250 6869 305b  nd[ii] - NRPhi0[
-00032060: 6969 525d 292f 2f4e 5250 6869 5b69 6952  iiR])//NRPhi[iiR
-00032070: 5d0a 2020 2020 2020 2020 2020 2020 6969  ].            ii
-00032080: 7068 6920 3d20 696e 645b 6969 5d20 2d20  phi = ind[ii] - 
-00032090: 4e52 5068 6930 5b69 6952 5d20 2d20 6969  NRPhi0[iiR] - ii
-000320a0: 5a2a 4e52 5068 695b 6969 525d 0a20 2020  Z*NRPhi[iiR].   
-000320b0: 2020 2020 2020 2020 2050 7473 5b30 2c69           Pts[0,i
-000320c0: 695d 203d 2052 5b69 6952 5d0a 2020 2020  i] = R[iiR].    
-000320d0: 2020 2020 2020 2020 5074 735b 312c 6969          Pts[1,ii
-000320e0: 5d20 3d20 5a5b 6969 5a5d 0a20 2020 2020  ] = Z[iiZ].     
-000320f0: 2020 2020 2020 2050 7473 5b32 2c69 695d         Pts[2,ii]
-00032100: 203d 2050 6869 5b69 6952 2c69 6970 6869   = Phi[iiR,iiphi
-00032110: 5d0a 2020 2020 2020 2020 2020 2020 6456  ].            dV
-00032120: 5b69 695d 203d 2072 6573 6f5f 722a 7265  [ii] = reso_r*re
-00032130: 736f 5f7a 2a64 5250 6869 7252 6566 5b69  so_z*dRPhirRef[i
-00032140: 6952 5d0a 2020 2020 2020 2020 2020 2020  iR].            
-00032150: 6966 2052 755b 6969 525d 3d3d 302e 3a0a  if Ru[iiR]==0.:.
-00032160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032170: 6452 5068 6972 5b69 6952 5d20 3d20 6452  dRPhir[iiR] = dR
-00032180: 5068 6972 5265 665b 6969 525d 0a20 2020  PhirRef[iiR].   
-00032190: 2020 2020 2020 2020 2020 2020 2052 755b               Ru[
-000321a0: 6969 525d 203d 2031 2e0a 2020 2020 7265  iiR] = 1..    re
-000321b0: 7475 726e 2050 7473 2c20 6456 2c20 7265  turn Pts, dV, re
-000321c0: 736f 5f72 2c20 7265 736f 5f7a 2c20 6e70  so_r, reso_z, np
-000321d0: 2e61 7361 7272 6179 2864 5250 6869 7229  .asarray(dRPhir)
-000321e0: 5b7e 6e70 2e69 736e 616e 2864 5250 6869  [~np.isnan(dRPhi
-000321f0: 7229 5d0a 0a0a 2320 3d3d 3d3d 3d3d 3d3d  r)]...# ========
+00031a30: 2020 2020 2020 2020 2020 6d61 7267 696e            margin
+00031a40: 3d6d 6172 6769 6e29 0a20 2020 2052 6e2c  =margin).    Rn,
+00031a50: 205a 6e20 3d20 6c65 6e28 5229 2c20 6c65   Zn = len(R), le
+00031a60: 6e28 5a29 0a0a 2020 2020 2320 4e75 6d62  n(Z)..    # Numb
+00031a70: 6572 206f 6620 5068 6920 7065 7220 520a  er of Phi per R.
+00031a80: 2020 2020 6452 5068 6972 5265 662c 2064      dRPhirRef, d
+00031a90: 5068 6972 203d 206e 702e 656d 7074 7928  Phir = np.empty(
+00031aa0: 284e 522c 2929 2c20 6e70 2e65 6d70 7479  (NR,)), np.empty
+00031ab0: 2828 4e52 2c29 290a 2020 2020 5275 2c20  ((NR,)).    Ru, 
+00031ac0: 6452 5068 6972 203d 206e 702e 7a65 726f  dRPhir = np.zero
+00031ad0: 7328 284e 522c 2929 2c20 6e70 2e6e 616e  s((NR,)), np.nan
+00031ae0: 2a6e 702e 6f6e 6573 2828 4e52 2c29 290a  *np.ones((NR,)).
+00031af0: 2020 2020 4e52 5068 692c 204e 5250 6869      NRPhi, NRPhi
+00031b00: 3020 3d20 6e70 2e65 6d70 7479 2828 4e52  0 = np.empty((NR
+00031b10: 2c29 2c64 7479 7065 3d69 6e74 292c 206e  ,),dtype=int), n
+00031b20: 702e 656d 7074 7928 284e 522b 312c 292c  p.empty((NR+1,),
+00031b30: 6474 7970 653d 696e 7429 0a20 2020 2072  dtype=int).    r
+00031b40: 6164 6975 735f 7261 7469 6f20 3d20 696e  adius_ratio = in
+00031b50: 7428 635f 6365 696c 2852 5b4e 522d 315d  t(c_ceil(R[NR-1]
+00031b60: 2f52 5b30 5d29 290a 2020 2020 666f 7220  /R[0])).    for 
+00031b70: 6969 2069 6e20 7261 6e67 6528 302c 4e52  ii in range(0,NR
+00031b80: 293a 0a20 2020 2020 2020 204e 5250 6869  ):.        NRPhi
+00031b90: 5b69 695d 203d 203c 6c6f 6e67 3e28 635f  [ii] = <long>(c_
+00031ba0: 6365 696c 2832 2e2a 635f 7069 2a52 5b69  ceil(2.*c_pi*R[i
+00031bb0: 695d 2f64 5250 6869 2929 0a20 2020 2020  i]/dRPhi)).     
+00031bc0: 2020 2064 5250 6869 7252 6566 5b69 695d     dRPhirRef[ii]
+00031bd0: 203d 2032 2e2a 635f 7069 2a52 5b69 695d   = 2.*c_pi*R[ii]
+00031be0: 2f3c 646f 7562 6c65 3e28 4e52 5068 695b  /<double>(NRPhi[
+00031bf0: 6969 5d29 0a20 2020 2020 2020 2064 5068  ii]).        dPh
+00031c00: 6972 5b69 695d 203d 2032 2e2a 635f 7069  ir[ii] = 2.*c_pi
+00031c10: 2f3c 646f 7562 6c65 3e28 4e52 5068 695b  /<double>(NRPhi[
+00031c20: 6969 5d29 0a20 2020 2020 2020 2069 6620  ii]).        if 
+00031c30: 6969 3d3d 303a 0a20 2020 2020 2020 2020  ii==0:.         
+00031c40: 2020 204e 5250 6869 305b 6969 5d20 3d20     NRPhi0[ii] = 
+00031c50: 300a 2020 2020 2020 2020 2020 2020 5068  0.            Ph
+00031c60: 6920 3d20 6e70 2e65 6d70 7479 2828 4e52  i = np.empty((NR
+00031c70: 2c4e 5250 6869 5b69 695d 2a72 6164 6975  ,NRPhi[ii]*radiu
+00031c80: 735f 7261 7469 6f2b 3129 290a 2020 2020  s_ratio+1)).    
+00031c90: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00031ca0: 2020 2020 2020 4e52 5068 6930 5b69 695d        NRPhi0[ii]
+00031cb0: 203d 204e 5250 6869 305b 6969 2d31 5d20   = NRPhi0[ii-1] 
+00031cc0: 2b20 4e52 5068 695b 6969 2d31 5d2a 4e5a  + NRPhi[ii-1]*NZ
+00031cd0: 0a20 2020 2020 2020 2066 6f72 206a 6a20  .        for jj 
+00031ce0: 696e 2072 616e 6765 2830 2c4e 5250 6869  in range(0,NRPhi
+00031cf0: 5b69 695d 293a 0a20 2020 2020 2020 2020  [ii]):.         
+00031d00: 2020 2050 6869 5b69 692c 6a6a 5d20 3d20     Phi[ii,jj] = 
+00031d10: 2d63 5f70 6920 2b20 2830 2e35 2b3c 646f  -c_pi + (0.5+<do
+00031d20: 7562 6c65 3e6a 6a29 2a64 5068 6972 5b69  uble>jj)*dPhir[i
+00031d30: 695d 0a0a 2020 2020 6966 204f 7574 2e6c  i]..    if Out.l
+00031d40: 6f77 6572 2829 3d3d 2728 782c 792c 7a29  ower()=='(x,y,z)
+00031d50: 273a 0a20 2020 2020 2020 2066 6f72 2069  ':.        for i
+00031d60: 6920 696e 2072 616e 6765 2830 2c4e 5029  i in range(0,NP)
+00031d70: 3a0a 2020 2020 2020 2020 2020 2020 666f  :.            fo
+00031d80: 7220 6a6a 2069 6e20 7261 6e67 6528 302c  r jj in range(0,
+00031d90: 4e52 2b31 293a 0a20 2020 2020 2020 2020  NR+1):.         
+00031da0: 2020 2020 2020 2069 6620 696e 645b 6969         if ind[ii
+00031db0: 5d2d 4e52 5068 6930 5b6a 6a5d 3c30 2e3a  ]-NRPhi0[jj]<0.:
+00031dc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00031dd0: 2020 2020 2062 7265 616b 0a20 2020 2020       break.     
+00031de0: 2020 2020 2020 2069 6952 203d 206a 6a2d         iiR = jj-
+00031df0: 310a 2020 2020 2020 2020 2020 2020 6969  1.            ii
+00031e00: 5a20 3d20 2869 6e64 5b69 695d 202d 204e  Z = (ind[ii] - N
+00031e10: 5250 6869 305b 6969 525d 292f 2f4e 5250  RPhi0[iiR])//NRP
+00031e20: 6869 5b69 6952 5d0a 2020 2020 2020 2020  hi[iiR].        
+00031e30: 2020 2020 6969 7068 6920 3d20 696e 645b      iiphi = ind[
+00031e40: 6969 5d20 2d20 4e52 5068 6930 5b69 6952  ii] - NRPhi0[iiR
+00031e50: 5d20 2d20 6969 5a2a 4e52 5068 695b 6969  ] - iiZ*NRPhi[ii
+00031e60: 525d 0a20 2020 2020 2020 2020 2020 2070  R].            p
+00031e70: 6869 203d 2050 6869 5b69 6952 2c69 6970  hi = Phi[iiR,iip
+00031e80: 6869 5d0a 2020 2020 2020 2020 2020 2020  hi].            
+00031e90: 5074 735b 302c 6969 5d20 3d20 525b 6969  Pts[0,ii] = R[ii
+00031ea0: 525d 2a63 5f63 6f73 2870 6869 290a 2020  R]*c_cos(phi).  
+00031eb0: 2020 2020 2020 2020 2020 5074 735b 312c            Pts[1,
+00031ec0: 6969 5d20 3d20 525b 6969 525d 2a63 5f73  ii] = R[iiR]*c_s
+00031ed0: 696e 2870 6869 290a 2020 2020 2020 2020  in(phi).        
+00031ee0: 2020 2020 5074 735b 322c 6969 5d20 3d20      Pts[2,ii] = 
+00031ef0: 5a5b 6969 5a5d 0a20 2020 2020 2020 2020  Z[iiZ].         
+00031f00: 2020 2064 565b 6969 5d20 3d20 7265 736f     dV[ii] = reso
+00031f10: 5f72 2a72 6573 6f5f 7a2a 6452 5068 6972  _r*reso_z*dRPhir
+00031f20: 5265 665b 6969 525d 0a20 2020 2020 2020  Ref[iiR].       
+00031f30: 2020 2020 2069 6620 5275 5b69 6952 5d3d       if Ru[iiR]=
+00031f40: 3d30 2e3a 0a20 2020 2020 2020 2020 2020  =0.:.           
+00031f50: 2020 2020 2064 5250 6869 725b 6969 525d       dRPhir[iiR]
+00031f60: 203d 2064 5250 6869 7252 6566 5b69 6952   = dRPhirRef[iiR
+00031f70: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00031f80: 2020 5275 5b69 6952 5d20 3d20 312e 0a20    Ru[iiR] = 1.. 
+00031f90: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00031fa0: 2066 6f72 2069 6920 696e 2072 616e 6765   for ii in range
+00031fb0: 2830 2c4e 5029 3a0a 2020 2020 2020 2020  (0,NP):.        
+00031fc0: 2020 2020 666f 7220 6a6a 2069 6e20 7261      for jj in ra
+00031fd0: 6e67 6528 302c 4e52 2b31 293a 0a20 2020  nge(0,NR+1):.   
+00031fe0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00031ff0: 696e 645b 6969 5d2d 4e52 5068 6930 5b6a  ind[ii]-NRPhi0[j
+00032000: 6a5d 3c30 2e3a 0a20 2020 2020 2020 2020  j]<0.:.         
+00032010: 2020 2020 2020 2020 2020 2062 7265 616b             break
+00032020: 0a20 2020 2020 2020 2020 2020 2069 6952  .            iiR
+00032030: 203d 206a 6a2d 310a 2020 2020 2020 2020   = jj-1.        
+00032040: 2020 2020 6969 5a20 3d20 2869 6e64 5b69      iiZ = (ind[i
+00032050: 695d 202d 204e 5250 6869 305b 6969 525d  i] - NRPhi0[iiR]
+00032060: 292f 2f4e 5250 6869 5b69 6952 5d0a 2020  )//NRPhi[iiR].  
+00032070: 2020 2020 2020 2020 2020 6969 7068 6920            iiphi 
+00032080: 3d20 696e 645b 6969 5d20 2d20 4e52 5068  = ind[ii] - NRPh
+00032090: 6930 5b69 6952 5d20 2d20 6969 5a2a 4e52  i0[iiR] - iiZ*NR
+000320a0: 5068 695b 6969 525d 0a20 2020 2020 2020  Phi[iiR].       
+000320b0: 2020 2020 2050 7473 5b30 2c69 695d 203d       Pts[0,ii] =
+000320c0: 2052 5b69 6952 5d0a 2020 2020 2020 2020   R[iiR].        
+000320d0: 2020 2020 5074 735b 312c 6969 5d20 3d20      Pts[1,ii] = 
+000320e0: 5a5b 6969 5a5d 0a20 2020 2020 2020 2020  Z[iiZ].         
+000320f0: 2020 2050 7473 5b32 2c69 695d 203d 2050     Pts[2,ii] = P
+00032100: 6869 5b69 6952 2c69 6970 6869 5d0a 2020  hi[iiR,iiphi].  
+00032110: 2020 2020 2020 2020 2020 6456 5b69 695d            dV[ii]
+00032120: 203d 2072 6573 6f5f 722a 7265 736f 5f7a   = reso_r*reso_z
+00032130: 2a64 5250 6869 7252 6566 5b69 6952 5d0a  *dRPhirRef[iiR].
+00032140: 2020 2020 2020 2020 2020 2020 6966 2052              if R
+00032150: 755b 6969 525d 3d3d 302e 3a0a 2020 2020  u[iiR]==0.:.    
+00032160: 2020 2020 2020 2020 2020 2020 6452 5068              dRPh
+00032170: 6972 5b69 6952 5d20 3d20 6452 5068 6972  ir[iiR] = dRPhir
+00032180: 5265 665b 6969 525d 0a20 2020 2020 2020  Ref[iiR].       
+00032190: 2020 2020 2020 2020 2052 755b 6969 525d           Ru[iiR]
+000321a0: 203d 2031 2e0a 2020 2020 7265 7475 726e   = 1..    return
+000321b0: 2050 7473 2c20 6456 2c20 7265 736f 5f72   Pts, dV, reso_r
+000321c0: 2c20 7265 736f 5f7a 2c20 6e70 2e61 7361  , reso_z, np.asa
+000321d0: 7272 6179 2864 5250 6869 7229 5b7e 6e70  rray(dRPhir)[~np
+000321e0: 2e69 736e 616e 2864 5250 6869 7229 5d0a  .isnan(dRPhir)].
+000321f0: 0a0a 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ..# ============
 00032200: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00032210: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00032220: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00032230: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00032240: 3d3d 3d3d 3d3d 0a23 0a23 2020 2020 2020  ======.#.#      
-00032250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032260: 2053 6f6c 6964 2041 6e67 6c65 2043 6f6d   Solid Angle Com
-00032270: 7075 7461 7469 6f6e 0a23 2020 2020 2020  putation.#      
-00032280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032290: 2020 7375 6274 656e 6465 6420 6279 2061    subtended by a
-000322a0: 2073 7068 6572 650a 230a 2320 3d3d 3d3d   sphere.#.# ====
+00032240: 3d3d 0a23 0a23 2020 2020 2020 2020 2020  ==.#.#          
+00032250: 2020 2020 2020 2020 2020 2020 2053 6f6c               Sol
+00032260: 6964 2041 6e67 6c65 2043 6f6d 7075 7461  id Angle Computa
+00032270: 7469 6f6e 0a23 2020 2020 2020 2020 2020  tion.#          
+00032280: 2020 2020 2020 2020 2020 2020 2020 7375                su
+00032290: 6274 656e 6465 6420 6279 2061 2073 7068  btended by a sph
+000322a0: 6572 650a 230a 2320 3d3d 3d3d 3d3d 3d3d  ere.#.# ========
 000322b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000322c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000322d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000322e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000322f0: 3d3d 3d3d 3d3d 3d3d 3d3d 0a64 6566 2063  ==========.def c
-00032300: 6f6d 7075 7465 5f73 6f6c 6964 5f61 6e67  ompute_solid_ang
-00032310: 6c65 5f6d 6170 2864 6f75 626c 655b 3a2c  le_map(double[:,
-00032320: 3a3a 315d 2070 6172 745f 636f 6f72 6473  ::1] part_coords
-00032330: 2c20 646f 7562 6c65 5b3a 3a31 5d20 7061  , double[::1] pa
-00032340: 7274 5f72 2c0a 2020 2020 2020 2020 2020  rt_r,.          
-00032350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032360: 2020 646f 7562 6c65 2072 7374 6570 2c20    double rstep, 
-00032370: 646f 7562 6c65 207a 7374 6570 2c20 646f  double zstep, do
-00032380: 7562 6c65 2070 6869 7374 6570 2c0a 2020  uble phistep,.  
+000322f0: 3d3d 3d3d 3d3d 0a64 6566 2063 6f6d 7075  ======.def compu
+00032300: 7465 5f73 6f6c 6964 5f61 6e67 6c65 5f6d  te_solid_angle_m
+00032310: 6170 2864 6f75 626c 655b 3a2c 3a3a 315d  ap(double[:,::1]
+00032320: 2070 6172 745f 636f 6f72 6473 2c20 646f   part_coords, do
+00032330: 7562 6c65 5b3a 3a31 5d20 7061 7274 5f72  uble[::1] part_r
+00032340: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00032350: 2020 2020 2020 2020 2020 2020 2020 646f                do
+00032360: 7562 6c65 2072 7374 6570 2c20 646f 7562  uble rstep, doub
+00032370: 6c65 207a 7374 6570 2c20 646f 7562 6c65  le zstep, double
+00032380: 2070 6869 7374 6570 2c0a 2020 2020 2020   phistep,.      
 00032390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000323a0: 2020 2020 2020 2020 2020 646f 7562 6c65            double
-000323b0: 5b3a 3a31 5d20 524d 696e 4d61 782c 2064  [::1] RMinMax, d
-000323c0: 6f75 626c 655b 3a3a 315d 205a 4d69 6e4d  ouble[::1] ZMinM
-000323d0: 6178 2c0a 2020 2020 2020 2020 2020 2020  ax,.            
-000323e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000323f0: 6269 6e74 2061 7070 726f 783d 5472 7565  bint approx=True
-00032400: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00032410: 2020 2020 2020 2020 2020 2020 2020 6c69                li
-00032420: 7374 2044 523d 4e6f 6e65 2c20 6c69 7374  st DR=None, list
-00032430: 2044 5a3d 4e6f 6e65 2c20 4450 6869 3d4e   DZ=None, DPhi=N
-00032440: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
-00032450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032460: 2064 6f75 626c 655b 3a2c 3a3a 315d 206c   double[:,::1] l
-00032470: 696d 6974 5f76 706f 6c79 3d4e 6f6e 652c  imit_vpoly=None,
-00032480: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00032490: 2020 2020 2020 2020 2020 2020 2062 696e               bin
-000324a0: 7420 626c 6f63 6b3d 4661 6c73 652c 0a20  t block=False,. 
+000323a0: 2020 2020 2020 646f 7562 6c65 5b3a 3a31        double[::1
+000323b0: 5d20 524d 696e 4d61 782c 2064 6f75 626c  ] RMinMax, doubl
+000323c0: 655b 3a3a 315d 205a 4d69 6e4d 6178 2c0a  e[::1] ZMinMax,.
+000323d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000323e0: 2020 2020 2020 2020 2020 2020 6269 6e74              bint
+000323f0: 2061 7070 726f 783d 5472 7565 2c0a 2020   approx=True,.  
+00032400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00032410: 2020 2020 2020 2020 2020 6c69 7374 2044            list D
+00032420: 523d 4e6f 6e65 2c20 6c69 7374 2044 5a3d  R=None, list DZ=
+00032430: 4e6f 6e65 2c20 4450 6869 3d4e 6f6e 652c  None, DPhi=None,
+00032440: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00032450: 2020 2020 2020 2020 2020 2020 2064 6f75               dou
+00032460: 626c 655b 3a2c 3a3a 315d 206c 696d 6974  ble[:,::1] limit
+00032470: 5f76 706f 6c79 3d4e 6f6e 652c 0a20 2020  _vpoly=None,.   
+00032480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00032490: 2020 2020 2020 2020 2062 696e 7420 626c           bint bl
+000324a0: 6f63 6b3d 4661 6c73 652c 0a20 2020 2020  ock=False,.     
 000324b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000324c0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-000324d0: 655b 3a2c 203a 3a31 5d20 7665 735f 706f  e[:, ::1] ves_po
-000324e0: 6c79 3d4e 6f6e 652c 0a20 2020 2020 2020  ly=None,.       
+000324c0: 2020 2020 2020 2064 6f75 626c 655b 3a2c         double[:,
+000324d0: 203a 3a31 5d20 7665 735f 706f 6c79 3d4e   ::1] ves_poly=N
+000324e0: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
 000324f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032500: 2020 2020 2064 6f75 626c 655b 3a2c 203a       double[:, :
-00032510: 3a31 5d20 7665 735f 6e6f 726d 3d4e 6f6e  :1] ves_norm=Non
-00032520: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00032530: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00032540: 6f75 626c 655b 3a3a 315d 2076 6573 5f6c  ouble[::1] ves_l
-00032550: 696d 733d 4e6f 6e65 2c0a 2020 2020 2020  ims=None,.      
+00032500: 2064 6f75 626c 655b 3a2c 203a 3a31 5d20   double[:, ::1] 
+00032510: 7665 735f 6e6f 726d 3d4e 6f6e 652c 0a20  ves_norm=None,. 
+00032520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00032530: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+00032540: 655b 3a3a 315d 2076 6573 5f6c 696d 733d  e[::1] ves_lims=
+00032550: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
 00032560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032570: 2020 2020 2020 6c6f 6e67 5b3a 3a31 5d20        long[::1] 
-00032580: 6c73 7472 7563 745f 6e6c 696d 3d4e 6f6e  lstruct_nlim=Non
-00032590: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-000325a0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000325b0: 6f75 626c 655b 3a3a 315d 206c 7374 7275  ouble[::1] lstru
-000325c0: 6374 5f70 6f6c 7978 3d4e 6f6e 652c 0a20  ct_polyx=None,. 
+00032570: 2020 6c6f 6e67 5b3a 3a31 5d20 6c73 7472    long[::1] lstr
+00032580: 7563 745f 6e6c 696d 3d4e 6f6e 652c 0a20  uct_nlim=None,. 
+00032590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000325a0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
+000325b0: 655b 3a3a 315d 206c 7374 7275 6374 5f70  e[::1] lstruct_p
+000325c0: 6f6c 7978 3d4e 6f6e 652c 0a20 2020 2020  olyx=None,.     
 000325d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000325e0: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-000325f0: 655b 3a3a 315d 206c 7374 7275 6374 5f70  e[::1] lstruct_p
-00032600: 6f6c 7979 3d4e 6f6e 652c 0a20 2020 2020  olyy=None,.     
+000325e0: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
+000325f0: 315d 206c 7374 7275 6374 5f70 6f6c 7979  1] lstruct_polyy
+00032600: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
 00032610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032620: 2020 2020 2020 206c 6973 7420 6c73 7472         list lstr
-00032630: 7563 745f 6c69 6d73 3d4e 6f6e 652c 0a20  uct_lims=None,. 
+00032620: 2020 206c 6973 7420 6c73 7472 7563 745f     list lstruct_
+00032630: 6c69 6d73 3d4e 6f6e 652c 0a20 2020 2020  lims=None,.     
 00032640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032650: 2020 2020 2020 2020 2020 2064 6f75 626c             doubl
-00032660: 655b 3a3a 315d 206c 7374 7275 6374 5f6e  e[::1] lstruct_n
-00032670: 6f72 6d78 3d4e 6f6e 652c 0a20 2020 2020  ormx=None,.     
+00032650: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
+00032660: 315d 206c 7374 7275 6374 5f6e 6f72 6d78  1] lstruct_normx
+00032670: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
 00032680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032690: 2020 2020 2020 2064 6f75 626c 655b 3a3a         double[::
-000326a0: 315d 206c 7374 7275 6374 5f6e 6f72 6d79  1] lstruct_normy
-000326b0: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
-000326c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000326d0: 2020 206c 6f6e 675b 3a3a 315d 206c 6e76     long[::1] lnv
-000326e0: 6572 743d 4e6f 6e65 2c0a 2020 2020 2020  ert=None,.      
+00032690: 2020 2064 6f75 626c 655b 3a3a 315d 206c     double[::1] l
+000326a0: 7374 7275 6374 5f6e 6f72 6d79 3d4e 6f6e  struct_normy=Non
+000326b0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+000326c0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000326d0: 6f6e 675b 3a3a 315d 206c 6e76 6572 743d  ong[::1] lnvert=
+000326e0: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
 000326f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032700: 2020 2020 2020 696e 7420 6e73 7472 7563        int nstruc
-00032710: 745f 746f 743d 302c 0a20 2020 2020 2020  t_tot=0,.       
+00032700: 2020 696e 7420 6e73 7472 7563 745f 746f    int nstruct_to
+00032710: 743d 302c 0a20 2020 2020 2020 2020 2020  t=0,.           
 00032720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032730: 2020 2020 2069 6e74 206e 7374 7275 6374       int nstruct
-00032740: 5f6c 696d 3d30 2c0a 2020 2020 2020 2020  _lim=0,.        
+00032730: 2069 6e74 206e 7374 7275 6374 5f6c 696d   int nstruct_lim
+00032740: 3d30 2c0a 2020 2020 2020 2020 2020 2020  =0,.            
 00032750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032760: 2020 2020 646f 7562 6c65 2072 6d69 6e3d      double rmin=
-00032770: 2d31 2c20 6269 6e74 2066 6f72 6269 643d  -1, bint forbid=
-00032780: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
-00032790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000327a0: 2020 646f 7562 6c65 2065 7073 5f75 7a3d    double eps_uz=
-000327b0: 5f53 4d41 4c4c 2c20 646f 7562 6c65 2065  _SMALL, double e
-000327c0: 7073 5f61 3d5f 5653 4d41 4c4c 2c0a 2020  ps_a=_VSMALL,.  
+00032760: 646f 7562 6c65 2072 6d69 6e3d 2d31 2c20  double rmin=-1, 
+00032770: 6269 6e74 2066 6f72 6269 643d 5472 7565  bint forbid=True
+00032780: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00032790: 2020 2020 2020 2020 2020 2020 2020 646f                do
+000327a0: 7562 6c65 2065 7073 5f75 7a3d 5f53 4d41  uble eps_uz=_SMA
+000327b0: 4c4c 2c20 646f 7562 6c65 2065 7073 5f61  LL, double eps_a
+000327c0: 3d5f 5653 4d41 4c4c 2c0a 2020 2020 2020  =_VSMALL,.      
 000327d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000327e0: 2020 2020 2020 2020 2020 646f 7562 6c65            double
-000327f0: 2065 7073 5f76 7a3d 5f56 534d 414c 4c2c   eps_vz=_VSMALL,
-00032800: 2064 6f75 626c 6520 6570 735f 623d 5f56   double eps_b=_V
-00032810: 534d 414c 4c2c 0a20 2020 2020 2020 2020  SMALL,.         
-00032820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00032830: 2020 2064 6f75 626c 6520 6570 735f 706c     double eps_pl
-00032840: 616e 653d 5f56 534d 414c 4c2c 2073 7472  ane=_VSMALL, str
-00032850: 2076 6573 5f74 7970 653d 2754 6f72 272c   ves_type='Tor',
-00032860: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00032870: 2020 2020 2020 2020 2020 2020 2064 6f75               dou
-00032880: 626c 6520 6d61 7267 696e 3d5f 5653 4d41  ble margin=_VSMA
-00032890: 4c4c 2c20 696e 7420 6e75 6d5f 7468 7265  LL, int num_thre
-000328a0: 6164 733d 3438 2c0a 2020 2020 2020 2020  ads=48,.        
+000327e0: 2020 2020 2020 646f 7562 6c65 2065 7073        double eps
+000327f0: 5f76 7a3d 5f56 534d 414c 4c2c 2064 6f75  _vz=_VSMALL, dou
+00032800: 626c 6520 6570 735f 623d 5f56 534d 414c  ble eps_b=_VSMAL
+00032810: 4c2c 0a20 2020 2020 2020 2020 2020 2020  L,.             
+00032820: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00032830: 6f75 626c 6520 6570 735f 706c 616e 653d  ouble eps_plane=
+00032840: 5f56 534d 414c 4c2c 2073 7472 2076 6573  _VSMALL, str ves
+00032850: 5f74 7970 653d 2754 6f72 272c 0a20 2020  _type='Tor',.   
+00032860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00032870: 2020 2020 2020 2020 2064 6f75 626c 6520           double 
+00032880: 6d61 7267 696e 3d5f 5653 4d41 4c4c 2c20  margin=_VSMALL, 
+00032890: 696e 7420 6e75 6d5f 7468 7265 6164 733d  int num_threads=
+000328a0: 3438 2c0a 2020 2020 2020 2020 2020 2020  48,.            
 000328b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000328c0: 2020 2020 6269 6e74 2074 6573 743d 5472      bint test=Tr
-000328d0: 7565 293a 0a20 2020 2022 2222 0a20 2020  ue):.    """.   
-000328e0: 2043 6f6d 7075 7465 7320 7468 6520 3244   Computes the 2D
-000328f0: 206d 6170 206f 6620 7468 6520 696e 7465   map of the inte
-00032900: 6772 6174 6564 2073 6f6c 6964 2061 6e67  grated solid ang
-00032910: 6c65 7320 7375 6274 656e 6465 6420 6279  les subtended by
-00032920: 2065 6163 6820 6f66 0a20 2020 2074 6865   each of.    the
-00032930: 2073 7a5f 7020 7061 7274 6963 6c65 7320   sz_p particles 
-00032940: 5020 6f66 2072 6164 6975 7320 7061 7274  P of radius part
-00032950: 5f72 2061 7420 7468 6520 706f 7369 7469  _r at the positi
-00032960: 6f6e 2070 6172 745f 636f 6f72 6473 0a20  on part_coords. 
-00032970: 2020 2069 6e20 7468 6520 7361 6d70 6c65     in the sample
-00032980: 6420 766f 6c75 6d65 2e0a 2020 2020 4966  d volume..    If
-00032990: 2061 7070 726f 782c 2061 2038 7468 2064   approx, a 8th d
-000329a0: 6567 7265 6520 6170 7072 6f78 696d 6174  egree approximat
-000329b0: 696f 6e20 7769 6c6c 2062 6520 7573 6564  ion will be used
-000329c0: 2066 6f72 2074 6865 2063 6f6d 7075 7461   for the computa
-000329d0: 7469 6f6e 0a20 2020 206f 6620 7468 6520  tion.    of the 
-000329e0: 736f 6c69 6420 616e 676c 650a 0a20 2020  solid angle..   
-000329f0: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
-00032a00: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2070  ----------.    p
-00032a10: 6172 745f 636f 6f72 6473 3a20 2833 2c20  art_coords: (3, 
-00032a20: 737a 5f70 2920 646f 7562 6c65 206d 656d  sz_p) double mem
-00032a30: 6f72 792d 7669 6577 0a09 2020 2020 6361  ory-view..    ca
-00032a40: 7274 6573 6961 6e20 636f 6f72 6469 6e61  rtesian coordina
-00032a50: 7465 7320 6f66 2050 2070 6172 7469 636c  tes of P particl
-00032a60: 6573 0a20 2020 2070 6172 745f 723a 2028  es.    part_r: (
-00032a70: 737a 5f70 2920 646f 7562 6c65 206d 656d  sz_p) double mem
-00032a80: 6f72 792d 7669 6577 0a20 2020 2020 2020  ory-view.       
-00032a90: 2074 6865 2072 6164 6969 206f 6620 7468   the radii of th
-00032aa0: 6520 5020 7061 7274 6963 6c65 730a 2020  e P particles.  
-00032ab0: 2020 7273 7465 703a 2064 6f75 626c 650a    rstep: double.
-00032ac0: 2020 2020 2020 2020 7265 6669 6e65 6d65          refineme
-00032ad0: 6e74 2061 6c6f 6e67 2072 6164 6975 7320  nt along radius 
-00032ae0: 6072 600a 2020 2020 7a73 7465 703a 2064  `r`.    zstep: d
-00032af0: 6f75 626c 650a 2020 2020 2020 2020 7265  ouble.        re
-00032b00: 6669 6e65 6d65 6e74 2061 6c6f 6e67 2068  finement along h
-00032b10: 6569 6768 7420 607a 600a 2020 2020 7068  eight `z`.    ph
-00032b20: 6973 7465 703a 2064 6f75 626c 650a 2020  istep: double.  
-00032b30: 2020 2020 2020 7265 6669 6e65 6d65 6e74        refinement
-00032b40: 2061 6c6f 6e67 2074 6f72 6f69 6461 6c20   along toroidal 
-00032b50: 6469 7265 6374 696f 6e20 6070 6869 600a  direction `phi`.
-00032b60: 2020 2020 6170 7072 6f78 3a20 626f 6f6c      approx: bool
-00032b70: 0a20 2020 2020 2020 2064 6f20 796f 7520  .        do you 
-00032b80: 7761 6e74 2074 6f20 7573 6520 6170 7072  want to use appr
-00032b90: 6f78 696d 6174 696f 6e20 2838 7468 206f  oximation (8th o
-00032ba0: 7264 6572 2920 6f72 2065 7861 6374 2066  rder) or exact f
-00032bb0: 6f72 6d75 6c61 203f 0a20 2020 2020 2020  ormula ?.       
-00032bc0: 2064 6566 6175 6c74 3a20 5472 7565 0a20   default: True. 
-00032bd0: 2020 2052 4d69 6e4d 6178 3a20 646f 7562     RMinMax: doub
-00032be0: 6c65 206d 656d 6f72 792d 7669 6577 0a20  le memory-view. 
-00032bf0: 2020 2020 2020 206c 696d 6974 7320 6d69         limits mi
-00032c00: 6e20 616e 6420 6d61 7820 696e 2060 7260  n and max in `r`
-00032c10: 0a20 2020 205a 4d69 6e4d 6178 3a20 646f  .    ZMinMax: do
-00032c20: 7562 6c65 206d 656d 6f72 792d 7669 6577  uble memory-view
-00032c30: 0a20 2020 2020 2020 206c 696d 6974 7320  .        limits 
-00032c40: 6d69 6e20 616e 6420 6d61 7820 696e 2060  min and max in `
-00032c50: 7a60 0a20 2020 2044 523a 2064 6f75 626c  z`.    DR: doubl
-00032c60: 6520 6d65 6d6f 7279 2d76 6965 772c 206f  e memory-view, o
-00032c70: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
-00032c80: 6163 7475 616c 2073 7562 2d76 6f6c 756d  actual sub-volum
-00032c90: 6520 6c69 6d69 7473 2074 6f20 6765 7420  e limits to get 
-00032ca0: 696e 2060 7260 0a20 2020 2044 5a3a 2064  in `r`.    DZ: d
-00032cb0: 6f75 626c 6520 6d65 6d6f 7279 2d76 6965  ouble memory-vie
-00032cc0: 772c 206f 7074 696f 6e61 6c0a 2020 2020  w, optional.    
-00032cd0: 2020 2020 6163 7475 616c 2073 7562 2d76      actual sub-v
-00032ce0: 6f6c 756d 6520 6c69 6d69 7473 2074 6f20  olume limits to 
-00032cf0: 6765 7420 696e 2060 7a60 0a20 2020 2044  get in `z`.    D
-00032d00: 5068 693a 2064 6f75 626c 6520 6d65 6d6f  Phi: double memo
-00032d10: 7279 2d76 6965 772c 206f 7074 696f 6e61  ry-view, optiona
-00032d20: 6c0a 2020 2020 2020 2020 6163 7475 616c  l.        actual
-00032d30: 2073 7562 2d76 6f6c 756d 6520 6c69 6d69   sub-volume limi
-00032d40: 7473 2074 6f20 6765 7420 696e 2060 7068  ts to get in `ph
-00032d50: 6960 0a20 2020 206c 696d 6974 5f76 706f  i`.    limit_vpo
-00032d60: 6c79 3a20 2833 2c20 6e70 7473 2920 646f  ly: (3, npts) do
-00032d70: 7562 6c65 206d 656d 6f72 792d 7669 6577  uble memory-view
-00032d80: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
-00032d90: 2020 2069 6620 7765 206f 6e6c 7920 7761     if we only wa
-00032da0: 6e74 2074 6f20 6469 7363 7265 7469 7a65  nt to discretize
-00032db0: 2074 6865 2076 6f6c 756d 6520 696e 7369   the volume insi
-00032dc0: 6465 2061 2063 6572 7461 696e 2066 6c75  de a certain flu
-00032dd0: 7820 7375 7266 6163 652e 0a20 2020 2020  x surface..     
-00032de0: 2020 2044 6566 696e 6573 2074 6865 2060     Defines the `
-00032df0: 2852 2c5a 2960 2063 6f6f 7264 7320 6f66  (R,Z)` coords of
-00032e00: 2074 6865 2070 6f6c 6f69 6461 6c20 6375   the poloidal cu
-00032e10: 7420 6f66 2074 6865 206c 696d 6974 696e  t of the limitin
-00032e20: 6720 666c 7578 0a20 2020 2020 2020 2073  g flux.        s
-00032e30: 7572 6661 6365 2e0a 2020 2020 626c 6f63  urface..    bloc
-00032e40: 6b3a 2062 6f6f 6c2c 206f 7074 696f 6e61  k: bool, optiona
-00032e50: 6c0a 2020 2020 2020 2020 6368 6563 6b20  l.        check 
-00032e60: 6966 2070 6172 7469 636c 6573 2061 7265  if particles are
-00032e70: 2076 6965 7761 626c 6520 6672 6f6d 2076   viewable from v
-00032e80: 6965 7769 6e67 2070 6f69 6e74 7320 6f72  iewing points or
-00032e90: 2069 6620 7468 6572 6520 6973 2061 0a20   if there is a. 
-00032ea0: 2020 2020 2020 2073 7472 7563 7475 7261         structura
-00032eb0: 6c20 656c 656d 656e 7420 626c 6f63 6b69  l element blocki
-00032ec0: 6e67 2076 6973 6962 696c 6974 7920 2846  ng visibility (F
-00032ed0: 616c 7365 290a 2020 2020 7665 735f 706f  alse).    ves_po
-00032ee0: 6c79 203a 2028 322c 206e 756d 5f76 6572  ly : (2, num_ver
-00032ef0: 7465 7829 2064 6f75 626c 6520 6172 7261  tex) double arra
-00032f00: 790a 2020 2020 2020 2043 6f6f 7264 696e  y.       Coordin
-00032f10: 6174 6573 206f 6620 7468 6520 7665 7274  ates of the vert
-00032f20: 6963 6573 206f 6620 7468 6520 506f 6c79  ices of the Poly
-00032f30: 676f 6e20 6465 6669 6e69 6e67 2074 6865  gon defining the
-00032f40: 2032 4420 706f 6c6f 6964 616c 0a20 2020   2D poloidal.   
-00032f50: 2020 2020 6375 7420 6f66 2074 6865 2056      cut of the V
-00032f60: 6573 7365 6c0a 2020 2020 7665 735f 6e6f  essel.    ves_no
-00032f70: 726d 203a 2028 322c 206e 756d 5f76 6572  rm : (2, num_ver
-00032f80: 7465 782d 3129 2064 6f75 626c 6520 6172  tex-1) double ar
-00032f90: 7261 790a 2020 2020 2020 204e 6f72 6d61  ray.       Norma
-00032fa0: 6c20 7665 6374 6f72 7320 676f 696e 6720  l vectors going 
-00032fb0: 2269 6e77 6172 6473 2220 6f66 2074 6865  "inwards" of the
-00032fc0: 2065 6467 6573 206f 6620 7468 6520 506f   edges of the Po
-00032fd0: 6c79 676f 6e20 6465 6669 6e65 640a 2020  lygon defined.  
-00032fe0: 2020 2020 2062 7920 7665 735f 706f 6c79       by ves_poly
-00032ff0: 0a20 2020 206e 7374 7275 6374 5f74 6f74  .    nstruct_tot
-00033000: 203a 2069 6e74 0a20 2020 2020 2020 546f   : int.       To
-00033010: 7461 6c20 6e75 6d62 6572 206f 6620 7374  tal number of st
-00033020: 7275 6374 7572 6573 2028 636f 756e 7469  ructures (counti
-00033030: 6e67 2065 6163 6820 6c69 6d69 7465 6420  ng each limited 
-00033040: 7374 7275 6374 7572 6520 6173 206f 6e65  structure as one
-00033050: 290a 2020 2020 7665 735f 6c69 6d73 203a  ).    ves_lims :
-00033060: 2061 7272 6179 0a20 2020 2020 2020 436f   array.       Co
-00033070: 6e74 6169 6e73 2074 6865 206c 696d 6974  ntains the limit
-00033080: 7320 6d69 6e20 616e 6420 6d61 7820 6f66  s min and max of
-00033090: 2076 6573 7365 6c0a 2020 2020 6c73 7472   vessel.    lstr
-000330a0: 7563 745f 706f 6c79 7820 3a20 6172 7261  uct_polyx : arra
-000330b0: 790a 2020 2020 2020 204c 6973 7420 6f66  y.       List of
-000330c0: 2078 2063 6f6f 7264 696e 6174 6573 206f   x coordinates o
-000330d0: 6620 7468 6520 7665 7274 6963 6573 206f  f the vertices o
-000330e0: 6620 616c 6c20 7374 7275 6374 7572 6573  f all structures
-000330f0: 206f 6e20 706f 6c6f 6964 616c 2070 6c61   on poloidal pla
-00033100: 6e65 0a20 2020 2020 2020 4966 206e 6f20  ne.       If no 
-00033110: 7374 7275 6374 7572 6573 203a 204e 6f6e  structures : Non
-00033120: 650a 2020 2020 6c73 7472 7563 745f 706f  e.    lstruct_po
-00033130: 6c79 7920 3a20 6172 7261 790a 2020 2020  lyy : array.    
-00033140: 2020 204c 6973 7420 6f66 2079 2063 6f6f     List of y coo
-00033150: 7264 696e 6174 6573 206f 6620 7468 6520  rdinates of the 
-00033160: 7665 7274 6963 6573 206f 6620 616c 6c20  vertices of all 
-00033170: 7374 7275 6374 7572 6573 206f 6e20 706f  structures on po
-00033180: 6c6f 6964 616c 2070 6c61 6e65 0a20 2020  loidal plane.   
-00033190: 2020 2020 4966 206e 6f20 7374 7275 6374      If no struct
-000331a0: 7572 6573 203a 204e 6f6e 650a 2020 2020  ures : None.    
-000331b0: 6c73 7472 7563 745f 6c69 6d73 203a 2061  lstruct_lims : a
-000331c0: 7272 6179 0a20 2020 2020 2020 4c69 7374  rray.       List
-000331d0: 206f 6620 6c69 6d69 7473 206f 6620 616c   of limits of al
-000331e0: 6c20 7374 7275 6374 7572 6573 0a20 2020  l structures.   
-000331f0: 2020 2020 4966 206e 6f20 7374 7275 6374      If no struct
-00033200: 7572 6573 203a 204e 6f6e 650a 2020 2020  ures : None.    
-00033210: 6c73 7472 7563 745f 6e6c 696d 203a 2061  lstruct_nlim : a
-00033220: 7272 6179 206f 6620 696e 7473 0a20 2020  rray of ints.   
-00033230: 2020 2020 4c69 7374 206f 6620 6e75 6d62      List of numb
-00033240: 6572 206f 6620 6c69 6d69 7473 2066 6f72  er of limits for
-00033250: 2061 6c6c 2073 7472 7563 7475 7265 730a   all structures.
-00033260: 2020 2020 2020 2049 6620 6e6f 2073 7472         If no str
-00033270: 7563 7475 7265 7320 3a20 4e6f 6e65 0a20  uctures : None. 
-00033280: 2020 206c 7374 7275 6374 5f6e 6f72 6d78     lstruct_normx
-00033290: 203a 2064 6f75 626c 6520 6d65 6d6f 7279   : double memory
-000332a0: 2d76 6965 772c 206f 7074 696f 6e61 6c0a  -view, optional.
-000332b0: 2020 2020 2020 204c 6973 7420 6f66 2078         List of x
-000332c0: 2d63 6f6f 7264 696e 6174 6573 206f 6620  -coordinates of 
-000332d0: 2269 6e77 6172 6473 2220 6e6f 726d 616c  "inwards" normal
-000332e0: 2076 6563 746f 7273 206f 6620 7468 6520   vectors of the 
-000332f0: 706f 6c79 676f 6e20 6f66 2061 6c6c 0a20  polygon of all. 
-00033300: 2020 2020 2020 7468 6520 7374 7275 6374        the struct
-00033310: 7572 6573 0a20 2020 2020 2020 4966 206e  ures.       If n
-00033320: 6f20 7374 7275 6374 7572 6573 203a 204e  o structures : N
-00033330: 6f6e 650a 2020 2020 6c73 7472 7563 745f  one.    lstruct_
-00033340: 6e6f 726d 7920 3a20 646f 7562 6c65 206d  normy : double m
-00033350: 656d 6f72 792d 7669 6577 2c20 6f70 7469  emory-view, opti
-00033360: 6f6e 616c 0a20 2020 2020 2020 4c69 7374  onal.       List
-00033370: 206f 6620 792d 636f 6f72 6469 6e61 7465   of y-coordinate
-00033380: 7320 6f66 2022 696e 7761 7264 7322 206e  s of "inwards" n
-00033390: 6f72 6d61 6c20 7665 6374 6f72 7320 6f66  ormal vectors of
-000333a0: 2074 6865 2070 6f6c 7967 6f6e 206f 6620   the polygon of 
-000333b0: 616c 6c0a 2020 2020 2020 2074 6865 2073  all.       the s
-000333c0: 7472 7563 7475 7265 730a 2020 2020 2020  tructures.      
-000333d0: 2049 6620 6e6f 2073 7472 7563 7475 7265   If no structure
-000333e0: 7320 3a20 4e6f 6e65 0a20 2020 2072 6d69  s : None.    rmi
-000333f0: 6e20 3a20 646f 7562 6c65 2c20 6f70 7469  n : double, opti
-00033400: 6f6e 616c 0a20 2020 2020 2020 4d69 6e69  onal.       Mini
-00033410: 6d61 6c20 7261 6469 7573 206f 6620 7665  mal radius of ve
-00033420: 7373 656c 2074 6f20 7461 6b65 2069 6e74  ssel to take int
-00033430: 6f20 636f 6e73 6964 6572 6174 696f 6e0a  o consideration.
-00033440: 2020 2020 666f 7262 6964 203a 2062 6f6f      forbid : boo
-00033450: 6c2c 206f 7074 696f 6e61 6c0a 2020 2020  l, optional.    
-00033460: 2020 2053 686f 756c 6420 7765 2066 6f72     Should we for
-00033470: 6269 6420 7661 6c75 6573 2062 6568 696e  bid values behin
-00033480: 6420 7669 7369 626c 6520 7261 6469 7573  d visible radius
-00033490: 203f 2028 7365 6520 726d 696e 290a 2020   ? (see rmin).  
-000334a0: 2020 6570 735f 3c76 616c 3e20 3a20 646f    eps_<val> : do
-000334b0: 7562 6c65 2c20 6f70 7469 6f6e 616c 0a20  uble, optional. 
-000334c0: 2020 2020 2020 536d 616c 6c20 7661 6c75        Small valu
-000334d0: 652c 2061 6363 6570 7461 6e63 6520 6f66  e, acceptance of
-000334e0: 2065 7272 6f72 0a20 2020 206d 6172 6769   error.    margi
-000334f0: 6e3a 2064 6f75 626c 652c 206f 7074 696f  n: double, optio
-00033500: 6e61 6c0a 2020 2020 2020 2020 746f 6c65  nal.        tole
-00033510: 7261 6e63 6520 6572 726f 722e 2044 6566  rance error. Def
-00033520: 6175 6c74 7320 746f 207c 5f56 534d 414c  aults to |_VSMAL
-00033530: 4c7c 0a20 2020 206e 756d 5f74 6872 6561  L|.    num_threa
-00033540: 6473 203a 2069 6e74 0a20 2020 2020 2020  ds : int.       
-00033550: 5468 6520 6e75 6d5f 7468 7265 6164 7320  The num_threads 
-00033560: 6172 6775 6d65 6e74 2069 6e64 6963 6174  argument indicat
-00033570: 6573 2068 6f77 206d 616e 7920 7468 7265  es how many thre
-00033580: 6164 7320 7468 6520 7465 616d 2073 686f  ads the team sho
-00033590: 756c 640a 2020 2020 2020 2063 6f6e 7369  uld.       consi
-000335a0: 7374 206f 662e 2049 6620 6e6f 7420 6769  st of. If not gi
-000335b0: 7665 6e2c 204f 7065 6e4d 5020 7769 6c6c  ven, OpenMP will
-000335c0: 2064 6563 6964 6520 686f 7720 6d61 6e79   decide how many
-000335d0: 2074 6872 6561 6473 2074 6f20 7573 652e   threads to use.
-000335e0: 0a20 2020 2020 2020 5479 7069 6361 6c6c  .       Typicall
-000335f0: 7920 7468 6973 2069 7320 7468 6520 6e75  y this is the nu
-00033600: 6d62 6572 206f 6620 636f 7265 7320 6176  mber of cores av
-00033610: 6169 6c61 626c 6520 6f6e 2074 6865 206d  ailable on the m
-00033620: 6163 6869 6e65 2e0a 2020 2020 7465 7374  achine..    test
-00033630: 203a 2062 6f6f 6c2c 206f 7074 696f 6e61   : bool, optiona
-00033640: 6c0a 2020 2020 2020 2053 686f 756c 6420  l.       Should 
-00033650: 7765 2072 756e 2074 6573 7473 3f20 4465  we run tests? De
-00033660: 6661 756c 7420 5472 7565 0a0a 2020 2020  fault True..    
-00033670: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
-00033680: 2d2d 2d0a 2020 2020 2020 2020 7074 733a  ---.        pts:
-00033690: 2020 2020 2832 2c20 6e70 7473 2920 6172      (2, npts) ar
-000336a0: 7261 7920 6f66 2028 522c 205a 2920 636f  ray of (R, Z) co
-000336b0: 6f72 6469 6e61 7465 7320 6f66 2076 6965  ordinates of vie
-000336c0: 7769 6e67 2070 6f69 6e74 7320 696e 0a20  wing points in. 
-000336d0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-000336e0: 6967 6e65 7474 6520 7768 6572 6520 736f  ignette where so
-000336f0: 6c69 6420 616e 676c 6520 6973 2069 6e74  lid angle is int
-00033700: 6567 7261 7465 640a 2020 2020 2020 2020  egrated.        
-00033710: 7361 5f6d 6170 3a20 286e 7074 732c 2073  sa_map: (npts, s
-00033720: 7a5f 7029 2061 7272 6179 2061 7070 726f  z_p) array appro
-00033730: 7820 736f 6c69 6420 616e 676c 6520 696e  x solid angle in
-00033740: 7465 6772 6174 6564 2061 6c6f 6e67 2070  tegrated along p
-00033750: 6869 0a20 2020 2020 2020 2020 2020 2020  hi.             
-00033760: 2020 2069 6e74 6567 7261 6c20 2873 6120     integral (sa 
-00033770: 2a20 6470 6869 202a 2072 290a 2020 2020  * dphi * r).    
-00033780: 2020 2020 696e 643a 2020 2020 286e 7074      ind:    (npt
-00033790: 7329 2069 6e64 6963 6573 2074 6f20 7265  s) indices to re
-000337a0: 636f 6e73 7472 7563 7420 2852 2c5a 2920  construct (R,Z) 
-000337b0: 6d61 7020 6672 6f6d 2073 615f 6d61 700a  map from sa_map.
-000337c0: 2020 2020 2020 2020 7264 7264 7a3a 2020          rdrdz:  
-000337d0: 286e 7074 7329 2076 6f6c 756d 6520 756e  (npts) volume un
-000337e0: 6974 3a20 6472 2a64 7a0a 2020 2020 2222  it: dr*dz.    ""
-000337f0: 220a 2020 2020 6364 6566 2069 6e74 206a  ".    cdef int j
-00033800: 6a0a 2020 2020 6364 6566 2069 6e74 2073  j.    cdef int s
-00033810: 7a5f 700a 2020 2020 6364 6566 2069 6e74  z_p.    cdef int
-00033820: 2073 7a5f 720a 2020 2020 6364 6566 2069   sz_r.    cdef i
-00033830: 6e74 2073 7a5f 7a0a 2020 2020 6364 6566  nt sz_z.    cdef
-00033840: 2069 6e74 206e 7074 735f 706f 6c0a 2020   int npts_pol.  
-00033850: 2020 6364 6566 2069 6e74 2072 5f72 6174    cdef int r_rat
-00033860: 696f 0a20 2020 2063 6465 6620 696e 7420  io.    cdef int 
-00033870: 696e 645f 6c6f 635f 7230 0a20 2020 2063  ind_loc_r0.    c
-00033880: 6465 6620 696e 7420 6e70 7473 5f64 6973  def int npts_dis
-00033890: 6320 3d20 300a 2020 2020 6364 6566 2069  c = 0.    cdef i
-000338a0: 6e74 5b31 5d20 6d61 785f 737a 5f70 6869  nt[1] max_sz_phi
-000338b0: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
-000338c0: 206d 696e 5f70 6869 2c20 6d61 785f 7068   min_phi, max_ph
-000338d0: 690a 2020 2020 6364 6566 2064 6f75 626c  i.    cdef doubl
-000338e0: 6520 6d69 6e5f 7068 695f 7069 0a20 2020  e min_phi_pi.   
-000338f0: 2063 6465 6620 646f 7562 6c65 206d 6178   cdef double max
-00033900: 5f70 6869 5f70 690a 2020 2020 6364 6566  _phi_pi.    cdef
-00033910: 2064 6f75 626c 6520 6162 7330 2c20 6162   double abs0, ab
-00033920: 7331 0a20 2020 2063 6465 6620 646f 7562  s1.    cdef doub
-00033930: 6c65 2072 6573 6f5f 725f 7a0a 2020 2020  le reso_r_z.    
-00033940: 6364 6566 2064 6f75 626c 6520 7477 6f70  cdef double twop
-00033950: 695f 6f76 6572 5f64 7068 690a 2020 2020  i_over_dphi.    
-00033960: 6364 6566 206c 6f6e 675b 315d 206e 6365  cdef long[1] nce
-00033970: 6c6c 735f 7230 2c20 6e63 656c 6c73 5f72  lls_r0, ncells_r
-00033980: 2c20 6e63 656c 6c73 5f7a 0a20 2020 2063  , ncells_z.    c
-00033990: 6465 6620 6c6f 6e67 5b3a 3a31 5d20 696e  def long[::1] in
-000339a0: 645f 6d76 0a20 2020 2063 6465 6620 6c6f  d_mv.    cdef lo
-000339b0: 6e67 5b3a 3a31 5d20 6669 7273 745f 696e  ng[::1] first_in
-000339c0: 645f 6d76 0a20 2020 2063 6465 6620 646f  d_mv.    cdef do
-000339d0: 7562 6c65 5b32 5d20 6c69 6d69 7473 5f64  uble[2] limits_d
-000339e0: 6c0a 2020 2020 6364 6566 2064 6f75 626c  l.    cdef doubl
-000339f0: 655b 315d 2072 6573 6f5f 7230 2c20 7265  e[1] reso_r0, re
-00033a00: 736f 5f72 2c20 7265 736f 5f7a 0a20 2020  so_r, reso_z.   
-00033a10: 2063 6465 6620 646f 7562 6c65 5b3a 3a31   cdef double[::1
-00033a20: 5d20 7265 736f 5f72 6472 647a 5f6d 760a  ] reso_rdrdz_mv.
-00033a30: 2020 2020 6364 6566 2064 6f75 626c 655b      cdef double[
-00033a40: 3a3a 315d 206c 7374 7275 6374 5f6c 696d  ::1] lstruct_lim
-00033a50: 735f 6e70 0a20 2020 2063 6465 6620 646f  s_np.    cdef do
-00033a60: 7562 6c65 5b3a 2c20 3a3a 315d 2070 6f6c  uble[:, ::1] pol
-00033a70: 795f 6d76 0a20 2020 2063 6465 6620 646f  y_mv.    cdef do
-00033a80: 7562 6c65 5b3a 2c20 3a3a 315d 2070 7473  uble[:, ::1] pts
-00033a90: 5f6d 760a 2020 2020 6364 6566 206c 6f6e  _mv.    cdef lon
-00033aa0: 675b 3a2c 203a 3a31 5d20 696e 6469 5f6d  g[:, ::1] indi_m
-00033ab0: 760a 2020 2020 6364 6566 206c 6f6e 675b  v.    cdef long[
-00033ac0: 3a2c 203a 3a31 5d20 696e 645f 727a 3270  :, ::1] ind_rz2p
-00033ad0: 6f6c 0a20 2020 2063 6465 6620 6c6f 6e67  ol.    cdef long
-00033ae0: 5b3a 2c20 3a3a 315d 2069 735f 696e 5f76  [:, ::1] is_in_v
-00033af0: 6967 6e65 7474 650a 2020 2020 6364 6566  ignette.    cdef
-00033b00: 206c 6f6e 672a 2020 6e63 656c 6c73 5f72   long*  ncells_r
-00033b10: 7068 6920 203d 204e 554c 4c0a 2020 2020  phi  = NULL.    
-00033b20: 6364 6566 206c 6f6e 672a 2020 6c69 6e64  cdef long*  lind
-00033b30: 6578 2020 203d 204e 554c 4c0a 2020 2020  ex   = NULL.    
-00033b40: 6364 6566 206c 6f6e 672a 2020 6c69 6e64  cdef long*  lind
-00033b50: 6578 5f7a 203d 204e 554c 4c0a 2020 2020  ex_z = NULL.    
-00033b60: 6364 6566 206c 6f6e 672a 2020 737a 5f70  cdef long*  sz_p
-00033b70: 6869 203d 204e 554c 4c0a 2020 2020 6364  hi = NULL.    cd
-00033b80: 6566 2064 6f75 626c 652a 2064 6973 635f  ef double* disc_
-00033b90: 7230 203d 204e 554c 4c0a 2020 2020 6364  r0 = NULL.    cd
-00033ba0: 6566 2064 6f75 626c 652a 2064 6973 635f  ef double* disc_
-00033bb0: 7220 203d 204e 554c 4c0a 2020 2020 6364  r  = NULL.    cd
-00033bc0: 6566 2064 6f75 626c 652a 2064 6973 635f  ef double* disc_
-00033bd0: 7a20 203d 204e 554c 4c0a 2020 2020 6364  z  = NULL.    cd
-00033be0: 6566 2064 6f75 626c 652a 2073 7465 705f  ef double* step_
-00033bf0: 7270 6869 203d 204e 554c 4c0a 2020 2020  rphi = NULL.    
-00033c00: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
-00033c10: 6c6f 6e67 2c20 6e64 696d 3d32 5d20 696e  long, ndim=2] in
-00033c20: 6449 0a20 2020 2063 6465 6620 6e70 2e6e  dI.    cdef np.n
-00033c30: 6461 7272 6179 5b6c 6f6e 672c 206e 6469  darray[long, ndi
-00033c40: 6d3d 315d 2069 6e64 0a20 2020 2063 6465  m=1] ind.    cde
-00033c50: 6620 6e70 2e6e 6461 7272 6179 5b64 6f75  f np.ndarray[dou
-00033c60: 626c 652c 206e 6469 6d3d 315d 2072 6573  ble, ndim=1] res
-00033c70: 6f5f 7264 7264 7a0a 2020 2020 6364 6566  o_rdrdz.    cdef
-00033c80: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
-00033c90: 6c65 2c20 6e64 696d 3d32 5d20 7074 730a  le, ndim=2] pts.
-00033ca0: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-00033cb0: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
-00033cc0: 3d32 5d20 7361 5f6d 6170 0a20 2020 2023  =2] sa_map.    #
-00033cd0: 0a20 2020 2023 203d 3d20 5465 7374 696e  .    # == Testin
-00033ce0: 6720 696e 7075 7473 203d 3d3d 3d3d 3d3d  g inputs =======
+000328c0: 6269 6e74 2074 6573 743d 5472 7565 293a  bint test=True):
+000328d0: 0a20 2020 2022 2222 0a20 2020 2043 6f6d  .    """.    Com
+000328e0: 7075 7465 7320 7468 6520 3244 206d 6170  putes the 2D map
+000328f0: 206f 6620 7468 6520 696e 7465 6772 6174   of the integrat
+00032900: 6564 2073 6f6c 6964 2061 6e67 6c65 7320  ed solid angles 
+00032910: 7375 6274 656e 6465 6420 6279 2065 6163  subtended by eac
+00032920: 6820 6f66 0a20 2020 2074 6865 2073 7a5f  h of.    the sz_
+00032930: 7020 7061 7274 6963 6c65 7320 5020 6f66  p particles P of
+00032940: 2072 6164 6975 7320 7061 7274 5f72 2061   radius part_r a
+00032950: 7420 7468 6520 706f 7369 7469 6f6e 2070  t the position p
+00032960: 6172 745f 636f 6f72 6473 0a20 2020 2069  art_coords.    i
+00032970: 6e20 7468 6520 7361 6d70 6c65 6420 766f  n the sampled vo
+00032980: 6c75 6d65 2e0a 2020 2020 4966 2061 7070  lume..    If app
+00032990: 726f 782c 2061 2038 7468 2064 6567 7265  rox, a 8th degre
+000329a0: 6520 6170 7072 6f78 696d 6174 696f 6e20  e approximation 
+000329b0: 7769 6c6c 2062 6520 7573 6564 2066 6f72  will be used for
+000329c0: 2074 6865 2063 6f6d 7075 7461 7469 6f6e   the computation
+000329d0: 0a20 2020 206f 6620 7468 6520 736f 6c69  .    of the soli
+000329e0: 6420 616e 676c 650a 0a20 2020 2050 6172  d angle..    Par
+000329f0: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
+00032a00: 2d2d 2d2d 2d2d 0a20 2020 2070 6172 745f  ------.    part_
+00032a10: 636f 6f72 6473 3a20 2833 2c20 737a 5f70  coords: (3, sz_p
+00032a20: 2920 646f 7562 6c65 206d 656d 6f72 792d  ) double memory-
+00032a30: 7669 6577 0a09 2020 2020 6361 7274 6573  view..    cartes
+00032a40: 6961 6e20 636f 6f72 6469 6e61 7465 7320  ian coordinates 
+00032a50: 6f66 2050 2070 6172 7469 636c 6573 0a20  of P particles. 
+00032a60: 2020 2070 6172 745f 723a 2028 737a 5f70     part_r: (sz_p
+00032a70: 2920 646f 7562 6c65 206d 656d 6f72 792d  ) double memory-
+00032a80: 7669 6577 0a20 2020 2020 2020 2074 6865  view.        the
+00032a90: 2072 6164 6969 206f 6620 7468 6520 5020   radii of the P 
+00032aa0: 7061 7274 6963 6c65 730a 2020 2020 7273  particles.    rs
+00032ab0: 7465 703a 2064 6f75 626c 650a 2020 2020  tep: double.    
+00032ac0: 2020 2020 7265 6669 6e65 6d65 6e74 2061      refinement a
+00032ad0: 6c6f 6e67 2072 6164 6975 7320 6072 600a  long radius `r`.
+00032ae0: 2020 2020 7a73 7465 703a 2064 6f75 626c      zstep: doubl
+00032af0: 650a 2020 2020 2020 2020 7265 6669 6e65  e.        refine
+00032b00: 6d65 6e74 2061 6c6f 6e67 2068 6569 6768  ment along heigh
+00032b10: 7420 607a 600a 2020 2020 7068 6973 7465  t `z`.    phiste
+00032b20: 703a 2064 6f75 626c 650a 2020 2020 2020  p: double.      
+00032b30: 2020 7265 6669 6e65 6d65 6e74 2061 6c6f    refinement alo
+00032b40: 6e67 2074 6f72 6f69 6461 6c20 6469 7265  ng toroidal dire
+00032b50: 6374 696f 6e20 6070 6869 600a 2020 2020  ction `phi`.    
+00032b60: 6170 7072 6f78 3a20 626f 6f6c 0a20 2020  approx: bool.   
+00032b70: 2020 2020 2064 6f20 796f 7520 7761 6e74       do you want
+00032b80: 2074 6f20 7573 6520 6170 7072 6f78 696d   to use approxim
+00032b90: 6174 696f 6e20 2838 7468 206f 7264 6572  ation (8th order
+00032ba0: 2920 6f72 2065 7861 6374 2066 6f72 6d75  ) or exact formu
+00032bb0: 6c61 203f 0a20 2020 2020 2020 2064 6566  la ?.        def
+00032bc0: 6175 6c74 3a20 5472 7565 0a20 2020 2052  ault: True.    R
+00032bd0: 4d69 6e4d 6178 3a20 646f 7562 6c65 206d  MinMax: double m
+00032be0: 656d 6f72 792d 7669 6577 0a20 2020 2020  emory-view.     
+00032bf0: 2020 206c 696d 6974 7320 6d69 6e20 616e     limits min an
+00032c00: 6420 6d61 7820 696e 2060 7260 0a20 2020  d max in `r`.   
+00032c10: 205a 4d69 6e4d 6178 3a20 646f 7562 6c65   ZMinMax: double
+00032c20: 206d 656d 6f72 792d 7669 6577 0a20 2020   memory-view.   
+00032c30: 2020 2020 206c 696d 6974 7320 6d69 6e20       limits min 
+00032c40: 616e 6420 6d61 7820 696e 2060 7a60 0a20  and max in `z`. 
+00032c50: 2020 2044 523a 2064 6f75 626c 6520 6d65     DR: double me
+00032c60: 6d6f 7279 2d76 6965 772c 206f 7074 696f  mory-view, optio
+00032c70: 6e61 6c0a 2020 2020 2020 2020 6163 7475  nal.        actu
+00032c80: 616c 2073 7562 2d76 6f6c 756d 6520 6c69  al sub-volume li
+00032c90: 6d69 7473 2074 6f20 6765 7420 696e 2060  mits to get in `
+00032ca0: 7260 0a20 2020 2044 5a3a 2064 6f75 626c  r`.    DZ: doubl
+00032cb0: 6520 6d65 6d6f 7279 2d76 6965 772c 206f  e memory-view, o
+00032cc0: 7074 696f 6e61 6c0a 2020 2020 2020 2020  ptional.        
+00032cd0: 6163 7475 616c 2073 7562 2d76 6f6c 756d  actual sub-volum
+00032ce0: 6520 6c69 6d69 7473 2074 6f20 6765 7420  e limits to get 
+00032cf0: 696e 2060 7a60 0a20 2020 2044 5068 693a  in `z`.    DPhi:
+00032d00: 2064 6f75 626c 6520 6d65 6d6f 7279 2d76   double memory-v
+00032d10: 6965 772c 206f 7074 696f 6e61 6c0a 2020  iew, optional.  
+00032d20: 2020 2020 2020 6163 7475 616c 2073 7562        actual sub
+00032d30: 2d76 6f6c 756d 6520 6c69 6d69 7473 2074  -volume limits t
+00032d40: 6f20 6765 7420 696e 2060 7068 6960 0a20  o get in `phi`. 
+00032d50: 2020 206c 696d 6974 5f76 706f 6c79 3a20     limit_vpoly: 
+00032d60: 2833 2c20 6e70 7473 2920 646f 7562 6c65  (3, npts) double
+00032d70: 206d 656d 6f72 792d 7669 6577 2c20 6f70   memory-view, op
+00032d80: 7469 6f6e 616c 0a20 2020 2020 2020 2069  tional.        i
+00032d90: 6620 7765 206f 6e6c 7920 7761 6e74 2074  f we only want t
+00032da0: 6f20 6469 7363 7265 7469 7a65 2074 6865  o discretize the
+00032db0: 2076 6f6c 756d 6520 696e 7369 6465 2061   volume inside a
+00032dc0: 2063 6572 7461 696e 2066 6c75 7820 7375   certain flux su
+00032dd0: 7266 6163 652e 0a20 2020 2020 2020 2044  rface..        D
+00032de0: 6566 696e 6573 2074 6865 2060 2852 2c5a  efines the `(R,Z
+00032df0: 2960 2063 6f6f 7264 7320 6f66 2074 6865  )` coords of the
+00032e00: 2070 6f6c 6f69 6461 6c20 6375 7420 6f66   poloidal cut of
+00032e10: 2074 6865 206c 696d 6974 696e 6720 666c   the limiting fl
+00032e20: 7578 0a20 2020 2020 2020 2073 7572 6661  ux.        surfa
+00032e30: 6365 2e0a 2020 2020 626c 6f63 6b3a 2062  ce..    block: b
+00032e40: 6f6f 6c2c 206f 7074 696f 6e61 6c0a 2020  ool, optional.  
+00032e50: 2020 2020 2020 6368 6563 6b20 6966 2070        check if p
+00032e60: 6172 7469 636c 6573 2061 7265 2076 6965  articles are vie
+00032e70: 7761 626c 6520 6672 6f6d 2076 6965 7769  wable from viewi
+00032e80: 6e67 2070 6f69 6e74 7320 6f72 2069 6620  ng points or if 
+00032e90: 7468 6572 6520 6973 2061 0a20 2020 2020  there is a.     
+00032ea0: 2020 2073 7472 7563 7475 7261 6c20 656c     structural el
+00032eb0: 656d 656e 7420 626c 6f63 6b69 6e67 2076  ement blocking v
+00032ec0: 6973 6962 696c 6974 7920 2846 616c 7365  isibility (False
+00032ed0: 290a 2020 2020 7665 735f 706f 6c79 203a  ).    ves_poly :
+00032ee0: 2028 322c 206e 756d 5f76 6572 7465 7829   (2, num_vertex)
+00032ef0: 2064 6f75 626c 6520 6172 7261 790a 2020   double array.  
+00032f00: 2020 2020 2043 6f6f 7264 696e 6174 6573       Coordinates
+00032f10: 206f 6620 7468 6520 7665 7274 6963 6573   of the vertices
+00032f20: 206f 6620 7468 6520 506f 6c79 676f 6e20   of the Polygon 
+00032f30: 6465 6669 6e69 6e67 2074 6865 2032 4420  defining the 2D 
+00032f40: 706f 6c6f 6964 616c 0a20 2020 2020 2020  poloidal.       
+00032f50: 6375 7420 6f66 2074 6865 2056 6573 7365  cut of the Vesse
+00032f60: 6c0a 2020 2020 7665 735f 6e6f 726d 203a  l.    ves_norm :
+00032f70: 2028 322c 206e 756d 5f76 6572 7465 782d   (2, num_vertex-
+00032f80: 3129 2064 6f75 626c 6520 6172 7261 790a  1) double array.
+00032f90: 2020 2020 2020 204e 6f72 6d61 6c20 7665         Normal ve
+00032fa0: 6374 6f72 7320 676f 696e 6720 2269 6e77  ctors going "inw
+00032fb0: 6172 6473 2220 6f66 2074 6865 2065 6467  ards" of the edg
+00032fc0: 6573 206f 6620 7468 6520 506f 6c79 676f  es of the Polygo
+00032fd0: 6e20 6465 6669 6e65 640a 2020 2020 2020  n defined.      
+00032fe0: 2062 7920 7665 735f 706f 6c79 0a20 2020   by ves_poly.   
+00032ff0: 206e 7374 7275 6374 5f74 6f74 203a 2069   nstruct_tot : i
+00033000: 6e74 0a20 2020 2020 2020 546f 7461 6c20  nt.       Total 
+00033010: 6e75 6d62 6572 206f 6620 7374 7275 6374  number of struct
+00033020: 7572 6573 2028 636f 756e 7469 6e67 2065  ures (counting e
+00033030: 6163 6820 6c69 6d69 7465 6420 7374 7275  ach limited stru
+00033040: 6374 7572 6520 6173 206f 6e65 290a 2020  cture as one).  
+00033050: 2020 7665 735f 6c69 6d73 203a 2061 7272    ves_lims : arr
+00033060: 6179 0a20 2020 2020 2020 436f 6e74 6169  ay.       Contai
+00033070: 6e73 2074 6865 206c 696d 6974 7320 6d69  ns the limits mi
+00033080: 6e20 616e 6420 6d61 7820 6f66 2076 6573  n and max of ves
+00033090: 7365 6c0a 2020 2020 6c73 7472 7563 745f  sel.    lstruct_
+000330a0: 706f 6c79 7820 3a20 6172 7261 790a 2020  polyx : array.  
+000330b0: 2020 2020 204c 6973 7420 6f66 2078 2063       List of x c
+000330c0: 6f6f 7264 696e 6174 6573 206f 6620 7468  oordinates of th
+000330d0: 6520 7665 7274 6963 6573 206f 6620 616c  e vertices of al
+000330e0: 6c20 7374 7275 6374 7572 6573 206f 6e20  l structures on 
+000330f0: 706f 6c6f 6964 616c 2070 6c61 6e65 0a20  poloidal plane. 
+00033100: 2020 2020 2020 4966 206e 6f20 7374 7275        If no stru
+00033110: 6374 7572 6573 203a 204e 6f6e 650a 2020  ctures : None.  
+00033120: 2020 6c73 7472 7563 745f 706f 6c79 7920    lstruct_polyy 
+00033130: 3a20 6172 7261 790a 2020 2020 2020 204c  : array.       L
+00033140: 6973 7420 6f66 2079 2063 6f6f 7264 696e  ist of y coordin
+00033150: 6174 6573 206f 6620 7468 6520 7665 7274  ates of the vert
+00033160: 6963 6573 206f 6620 616c 6c20 7374 7275  ices of all stru
+00033170: 6374 7572 6573 206f 6e20 706f 6c6f 6964  ctures on poloid
+00033180: 616c 2070 6c61 6e65 0a20 2020 2020 2020  al plane.       
+00033190: 4966 206e 6f20 7374 7275 6374 7572 6573  If no structures
+000331a0: 203a 204e 6f6e 650a 2020 2020 6c73 7472   : None.    lstr
+000331b0: 7563 745f 6c69 6d73 203a 2061 7272 6179  uct_lims : array
+000331c0: 0a20 2020 2020 2020 4c69 7374 206f 6620  .       List of 
+000331d0: 6c69 6d69 7473 206f 6620 616c 6c20 7374  limits of all st
+000331e0: 7275 6374 7572 6573 0a20 2020 2020 2020  ructures.       
+000331f0: 4966 206e 6f20 7374 7275 6374 7572 6573  If no structures
+00033200: 203a 204e 6f6e 650a 2020 2020 6c73 7472   : None.    lstr
+00033210: 7563 745f 6e6c 696d 203a 2061 7272 6179  uct_nlim : array
+00033220: 206f 6620 696e 7473 0a20 2020 2020 2020   of ints.       
+00033230: 4c69 7374 206f 6620 6e75 6d62 6572 206f  List of number o
+00033240: 6620 6c69 6d69 7473 2066 6f72 2061 6c6c  f limits for all
+00033250: 2073 7472 7563 7475 7265 730a 2020 2020   structures.    
+00033260: 2020 2049 6620 6e6f 2073 7472 7563 7475     If no structu
+00033270: 7265 7320 3a20 4e6f 6e65 0a20 2020 206c  res : None.    l
+00033280: 7374 7275 6374 5f6e 6f72 6d78 203a 2064  struct_normx : d
+00033290: 6f75 626c 6520 6d65 6d6f 7279 2d76 6965  ouble memory-vie
+000332a0: 772c 206f 7074 696f 6e61 6c0a 2020 2020  w, optional.    
+000332b0: 2020 204c 6973 7420 6f66 2078 2d63 6f6f     List of x-coo
+000332c0: 7264 696e 6174 6573 206f 6620 2269 6e77  rdinates of "inw
+000332d0: 6172 6473 2220 6e6f 726d 616c 2076 6563  ards" normal vec
+000332e0: 746f 7273 206f 6620 7468 6520 706f 6c79  tors of the poly
+000332f0: 676f 6e20 6f66 2061 6c6c 0a20 2020 2020  gon of all.     
+00033300: 2020 7468 6520 7374 7275 6374 7572 6573    the structures
+00033310: 0a20 2020 2020 2020 4966 206e 6f20 7374  .       If no st
+00033320: 7275 6374 7572 6573 203a 204e 6f6e 650a  ructures : None.
+00033330: 2020 2020 6c73 7472 7563 745f 6e6f 726d      lstruct_norm
+00033340: 7920 3a20 646f 7562 6c65 206d 656d 6f72  y : double memor
+00033350: 792d 7669 6577 2c20 6f70 7469 6f6e 616c  y-view, optional
+00033360: 0a20 2020 2020 2020 4c69 7374 206f 6620  .       List of 
+00033370: 792d 636f 6f72 6469 6e61 7465 7320 6f66  y-coordinates of
+00033380: 2022 696e 7761 7264 7322 206e 6f72 6d61   "inwards" norma
+00033390: 6c20 7665 6374 6f72 7320 6f66 2074 6865  l vectors of the
+000333a0: 2070 6f6c 7967 6f6e 206f 6620 616c 6c0a   polygon of all.
+000333b0: 2020 2020 2020 2074 6865 2073 7472 7563         the struc
+000333c0: 7475 7265 730a 2020 2020 2020 2049 6620  tures.       If 
+000333d0: 6e6f 2073 7472 7563 7475 7265 7320 3a20  no structures : 
+000333e0: 4e6f 6e65 0a20 2020 2072 6d69 6e20 3a20  None.    rmin : 
+000333f0: 646f 7562 6c65 2c20 6f70 7469 6f6e 616c  double, optional
+00033400: 0a20 2020 2020 2020 4d69 6e69 6d61 6c20  .       Minimal 
+00033410: 7261 6469 7573 206f 6620 7665 7373 656c  radius of vessel
+00033420: 2074 6f20 7461 6b65 2069 6e74 6f20 636f   to take into co
+00033430: 6e73 6964 6572 6174 696f 6e0a 2020 2020  nsideration.    
+00033440: 666f 7262 6964 203a 2062 6f6f 6c2c 206f  forbid : bool, o
+00033450: 7074 696f 6e61 6c0a 2020 2020 2020 2053  ptional.       S
+00033460: 686f 756c 6420 7765 2066 6f72 6269 6420  hould we forbid 
+00033470: 7661 6c75 6573 2062 6568 696e 6420 7669  values behind vi
+00033480: 7369 626c 6520 7261 6469 7573 203f 2028  sible radius ? (
+00033490: 7365 6520 726d 696e 290a 2020 2020 6570  see rmin).    ep
+000334a0: 735f 3c76 616c 3e20 3a20 646f 7562 6c65  s_<val> : double
+000334b0: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
+000334c0: 2020 536d 616c 6c20 7661 6c75 652c 2061    Small value, a
+000334d0: 6363 6570 7461 6e63 6520 6f66 2065 7272  cceptance of err
+000334e0: 6f72 0a20 2020 206d 6172 6769 6e3a 2064  or.    margin: d
+000334f0: 6f75 626c 652c 206f 7074 696f 6e61 6c0a  ouble, optional.
+00033500: 2020 2020 2020 2020 746f 6c65 7261 6e63          toleranc
+00033510: 6520 6572 726f 722e 2044 6566 6175 6c74  e error. Default
+00033520: 7320 746f 207c 5f56 534d 414c 4c7c 0a20  s to |_VSMALL|. 
+00033530: 2020 206e 756d 5f74 6872 6561 6473 203a     num_threads :
+00033540: 2069 6e74 0a20 2020 2020 2020 5468 6520   int.       The 
+00033550: 6e75 6d5f 7468 7265 6164 7320 6172 6775  num_threads argu
+00033560: 6d65 6e74 2069 6e64 6963 6174 6573 2068  ment indicates h
+00033570: 6f77 206d 616e 7920 7468 7265 6164 7320  ow many threads 
+00033580: 7468 6520 7465 616d 2073 686f 756c 640a  the team should.
+00033590: 2020 2020 2020 2063 6f6e 7369 7374 206f         consist o
+000335a0: 662e 2049 6620 6e6f 7420 6769 7665 6e2c  f. If not given,
+000335b0: 204f 7065 6e4d 5020 7769 6c6c 2064 6563   OpenMP will dec
+000335c0: 6964 6520 686f 7720 6d61 6e79 2074 6872  ide how many thr
+000335d0: 6561 6473 2074 6f20 7573 652e 0a20 2020  eads to use..   
+000335e0: 2020 2020 5479 7069 6361 6c6c 7920 7468      Typically th
+000335f0: 6973 2069 7320 7468 6520 6e75 6d62 6572  is is the number
+00033600: 206f 6620 636f 7265 7320 6176 6169 6c61   of cores availa
+00033610: 626c 6520 6f6e 2074 6865 206d 6163 6869  ble on the machi
+00033620: 6e65 2e0a 2020 2020 7465 7374 203a 2062  ne..    test : b
+00033630: 6f6f 6c2c 206f 7074 696f 6e61 6c0a 2020  ool, optional.  
+00033640: 2020 2020 2053 686f 756c 6420 7765 2072       Should we r
+00033650: 756e 2074 6573 7473 3f20 4465 6661 756c  un tests? Defaul
+00033660: 7420 5472 7565 0a0a 2020 2020 5265 7475  t True..    Retu
+00033670: 726e 730a 2020 2020 2d2d 2d2d 2d2d 2d0a  rns.    -------.
+00033680: 2020 2020 2020 2020 7074 733a 2020 2020          pts:    
+00033690: 2832 2c20 6e70 7473 2920 6172 7261 7920  (2, npts) array 
+000336a0: 6f66 2028 522c 205a 2920 636f 6f72 6469  of (R, Z) coordi
+000336b0: 6e61 7465 7320 6f66 2076 6965 7769 6e67  nates of viewing
+000336c0: 2070 6f69 6e74 7320 696e 0a20 2020 2020   points in.     
+000336d0: 2020 2020 2020 2020 2020 2076 6967 6e65             vigne
+000336e0: 7474 6520 7768 6572 6520 736f 6c69 6420  tte where solid 
+000336f0: 616e 676c 6520 6973 2069 6e74 6567 7261  angle is integra
+00033700: 7465 640a 2020 2020 2020 2020 7361 5f6d  ted.        sa_m
+00033710: 6170 3a20 286e 7074 732c 2073 7a5f 7029  ap: (npts, sz_p)
+00033720: 2061 7272 6179 2061 7070 726f 7820 736f   array approx so
+00033730: 6c69 6420 616e 676c 6520 696e 7465 6772  lid angle integr
+00033740: 6174 6564 2061 6c6f 6e67 2070 6869 0a20  ated along phi. 
+00033750: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00033760: 6e74 6567 7261 6c20 2873 6120 2a20 6470  ntegral (sa * dp
+00033770: 6869 202a 2072 290a 2020 2020 2020 2020  hi * r).        
+00033780: 696e 643a 2020 2020 286e 7074 7329 2069  ind:    (npts) i
+00033790: 6e64 6963 6573 2074 6f20 7265 636f 6e73  ndices to recons
+000337a0: 7472 7563 7420 2852 2c5a 2920 6d61 7020  truct (R,Z) map 
+000337b0: 6672 6f6d 2073 615f 6d61 700a 2020 2020  from sa_map.    
+000337c0: 2020 2020 7264 7264 7a3a 2020 286e 7074      rdrdz:  (npt
+000337d0: 7329 2076 6f6c 756d 6520 756e 6974 3a20  s) volume unit: 
+000337e0: 6472 2a64 7a0a 2020 2020 2222 220a 2020  dr*dz.    """.  
+000337f0: 2020 6364 6566 2069 6e74 206a 6a0a 2020    cdef int jj.  
+00033800: 2020 6364 6566 2069 6e74 2073 7a5f 700a    cdef int sz_p.
+00033810: 2020 2020 6364 6566 2069 6e74 2073 7a5f      cdef int sz_
+00033820: 720a 2020 2020 6364 6566 2069 6e74 2073  r.    cdef int s
+00033830: 7a5f 7a0a 2020 2020 6364 6566 2069 6e74  z_z.    cdef int
+00033840: 206e 7074 735f 706f 6c0a 2020 2020 6364   npts_pol.    cd
+00033850: 6566 2069 6e74 2072 5f72 6174 696f 0a20  ef int r_ratio. 
+00033860: 2020 2063 6465 6620 696e 7420 696e 645f     cdef int ind_
+00033870: 6c6f 635f 7230 0a20 2020 2063 6465 6620  loc_r0.    cdef 
+00033880: 696e 7420 6e70 7473 5f64 6973 6320 3d20  int npts_disc = 
+00033890: 300a 2020 2020 6364 6566 2069 6e74 5b31  0.    cdef int[1
+000338a0: 5d20 6d61 785f 737a 5f70 6869 0a20 2020  ] max_sz_phi.   
+000338b0: 2063 6465 6620 646f 7562 6c65 206d 696e   cdef double min
+000338c0: 5f70 6869 2c20 6d61 785f 7068 690a 2020  _phi, max_phi.  
+000338d0: 2020 6364 6566 2064 6f75 626c 6520 6d69    cdef double mi
+000338e0: 6e5f 7068 695f 7069 0a20 2020 2063 6465  n_phi_pi.    cde
+000338f0: 6620 646f 7562 6c65 206d 6178 5f70 6869  f double max_phi
+00033900: 5f70 690a 2020 2020 6364 6566 2064 6f75  _pi.    cdef dou
+00033910: 626c 6520 6162 7330 2c20 6162 7331 0a20  ble abs0, abs1. 
+00033920: 2020 2063 6465 6620 646f 7562 6c65 2072     cdef double r
+00033930: 6573 6f5f 725f 7a0a 2020 2020 6364 6566  eso_r_z.    cdef
+00033940: 2064 6f75 626c 6520 7477 6f70 695f 6f76   double twopi_ov
+00033950: 6572 5f64 7068 690a 2020 2020 6364 6566  er_dphi.    cdef
+00033960: 206c 6f6e 675b 315d 206e 6365 6c6c 735f   long[1] ncells_
+00033970: 7230 2c20 6e63 656c 6c73 5f72 2c20 6e63  r0, ncells_r, nc
+00033980: 656c 6c73 5f7a 0a20 2020 2063 6465 6620  ells_z.    cdef 
+00033990: 6c6f 6e67 5b3a 3a31 5d20 696e 645f 6d76  long[::1] ind_mv
+000339a0: 0a20 2020 2063 6465 6620 6c6f 6e67 5b3a  .    cdef long[:
+000339b0: 3a31 5d20 6669 7273 745f 696e 645f 6d76  :1] first_ind_mv
+000339c0: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+000339d0: 5b32 5d20 6c69 6d69 7473 5f64 6c0a 2020  [2] limits_dl.  
+000339e0: 2020 6364 6566 2064 6f75 626c 655b 315d    cdef double[1]
+000339f0: 2072 6573 6f5f 7230 2c20 7265 736f 5f72   reso_r0, reso_r
+00033a00: 2c20 7265 736f 5f7a 0a20 2020 2063 6465  , reso_z.    cde
+00033a10: 6620 646f 7562 6c65 5b3a 3a31 5d20 7265  f double[::1] re
+00033a20: 736f 5f72 6472 647a 5f6d 760a 2020 2020  so_rdrdz_mv.    
+00033a30: 6364 6566 2064 6f75 626c 655b 3a3a 315d  cdef double[::1]
+00033a40: 206c 7374 7275 6374 5f6c 696d 735f 6e70   lstruct_lims_np
+00033a50: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00033a60: 5b3a 2c20 3a3a 315d 2070 6f6c 795f 6d76  [:, ::1] poly_mv
+00033a70: 0a20 2020 2063 6465 6620 646f 7562 6c65  .    cdef double
+00033a80: 5b3a 2c20 3a3a 315d 2070 7473 5f6d 760a  [:, ::1] pts_mv.
+00033a90: 2020 2020 6364 6566 206c 6f6e 675b 3a2c      cdef long[:,
+00033aa0: 203a 3a31 5d20 696e 6469 5f6d 760a 2020   ::1] indi_mv.  
+00033ab0: 2020 6364 6566 206c 6f6e 675b 3a2c 203a    cdef long[:, :
+00033ac0: 3a31 5d20 696e 645f 727a 3270 6f6c 0a20  :1] ind_rz2pol. 
+00033ad0: 2020 2063 6465 6620 6c6f 6e67 5b3a 2c20     cdef long[:, 
+00033ae0: 3a3a 315d 2069 735f 696e 5f76 6967 6e65  ::1] is_in_vigne
+00033af0: 7474 650a 2020 2020 6364 6566 206c 6f6e  tte.    cdef lon
+00033b00: 672a 2020 6e63 656c 6c73 5f72 7068 6920  g*  ncells_rphi 
+00033b10: 203d 204e 554c 4c0a 2020 2020 6364 6566   = NULL.    cdef
+00033b20: 206c 6f6e 672a 2020 6c69 6e64 6578 2020   long*  lindex  
+00033b30: 203d 204e 554c 4c0a 2020 2020 6364 6566   = NULL.    cdef
+00033b40: 206c 6f6e 672a 2020 6c69 6e64 6578 5f7a   long*  lindex_z
+00033b50: 203d 204e 554c 4c0a 2020 2020 6364 6566   = NULL.    cdef
+00033b60: 206c 6f6e 672a 2020 737a 5f70 6869 203d   long*  sz_phi =
+00033b70: 204e 554c 4c0a 2020 2020 6364 6566 2064   NULL.    cdef d
+00033b80: 6f75 626c 652a 2064 6973 635f 7230 203d  ouble* disc_r0 =
+00033b90: 204e 554c 4c0a 2020 2020 6364 6566 2064   NULL.    cdef d
+00033ba0: 6f75 626c 652a 2064 6973 635f 7220 203d  ouble* disc_r  =
+00033bb0: 204e 554c 4c0a 2020 2020 6364 6566 2064   NULL.    cdef d
+00033bc0: 6f75 626c 652a 2064 6973 635f 7a20 203d  ouble* disc_z  =
+00033bd0: 204e 554c 4c0a 2020 2020 6364 6566 2064   NULL.    cdef d
+00033be0: 6f75 626c 652a 2073 7465 705f 7270 6869  ouble* step_rphi
+00033bf0: 203d 204e 554c 4c0a 2020 2020 6364 6566   = NULL.    cdef
+00033c00: 206e 702e 6e64 6172 7261 795b 6c6f 6e67   np.ndarray[long
+00033c10: 2c20 6e64 696d 3d32 5d20 696e 6449 0a20  , ndim=2] indI. 
+00033c20: 2020 2063 6465 6620 6e70 2e6e 6461 7272     cdef np.ndarr
+00033c30: 6179 5b6c 6f6e 672c 206e 6469 6d3d 315d  ay[long, ndim=1]
+00033c40: 2069 6e64 0a20 2020 2063 6465 6620 6e70   ind.    cdef np
+00033c50: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
+00033c60: 206e 6469 6d3d 315d 2072 6573 6f5f 7264   ndim=1] reso_rd
+00033c70: 7264 7a0a 2020 2020 6364 6566 206e 702e  rdz.    cdef np.
+00033c80: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
+00033c90: 6e64 696d 3d32 5d20 7074 730a 2020 2020  ndim=2] pts.    
+00033ca0: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+00033cb0: 646f 7562 6c65 2c20 6e64 696d 3d32 5d20  double, ndim=2] 
+00033cc0: 7361 5f6d 6170 0a20 2020 2023 0a20 2020  sa_map.    #.   
+00033cd0: 2023 203d 3d20 5465 7374 696e 6720 696e   # == Testing in
+00033ce0: 7075 7473 203d 3d3d 3d3d 3d3d 3d3d 3d3d  puts ===========
 00033cf0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00033d00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00033d10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00033d20: 3d0a 2020 2020 6966 2074 6573 743a 0a20  =.    if test:. 
-00033d30: 2020 2020 2020 2069 6620 626c 6f63 6b3a         if block:
-00033d40: 0a20 2020 2020 2020 2020 2020 206d 7367  .            msg
-00033d50: 203d 2022 7665 735f 706f 6c79 2061 6e64   = "ves_poly and
-00033d60: 2076 6573 5f6e 6f72 6d20 6172 6520 6e6f   ves_norm are no
-00033d70: 7420 6f70 7469 6f6e 616c 2061 7267 756d  t optional argum
-00033d80: 656e 7473 220a 2020 2020 2020 2020 2020  ents".          
-00033d90: 2020 6173 7365 7274 2076 6573 5f70 6f6c    assert ves_pol
-00033da0: 7920 6973 206e 6f74 204e 6f6e 6520 616e  y is not None an
-00033db0: 6420 7665 735f 6e6f 726d 2069 7320 6e6f  d ves_norm is no
-00033dc0: 7420 4e6f 6e65 2c20 6d73 670a 2020 2020  t None, msg.    
-00033dd0: 2020 2020 2020 2020 626f 6f6c 3120 3d20          bool1 = 
-00033de0: 2876 6573 5f70 6f6c 792e 7368 6170 655b  (ves_poly.shape[
-00033df0: 305d 3d3d 3220 616e 6420 7665 735f 6e6f  0]==2 and ves_no
-00033e00: 726d 2e73 6861 7065 5b30 5d3d 3d32 0a20  rm.shape[0]==2. 
+00033d10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020  =============.  
+00033d20: 2020 6966 2074 6573 743a 0a20 2020 2020    if test:.     
+00033d30: 2020 2069 6620 626c 6f63 6b3a 0a20 2020     if block:.   
+00033d40: 2020 2020 2020 2020 206d 7367 203d 2022           msg = "
+00033d50: 7665 735f 706f 6c79 2061 6e64 2076 6573  ves_poly and ves
+00033d60: 5f6e 6f72 6d20 6172 6520 6e6f 7420 6f70  _norm are not op
+00033d70: 7469 6f6e 616c 2061 7267 756d 656e 7473  tional arguments
+00033d80: 220a 2020 2020 2020 2020 2020 2020 6173  ".            as
+00033d90: 7365 7274 2076 6573 5f70 6f6c 7920 6973  sert ves_poly is
+00033da0: 206e 6f74 204e 6f6e 6520 616e 6420 7665   not None and ve
+00033db0: 735f 6e6f 726d 2069 7320 6e6f 7420 4e6f  s_norm is not No
+00033dc0: 6e65 2c20 6d73 670a 2020 2020 2020 2020  ne, msg.        
+00033dd0: 2020 2020 626f 6f6c 3120 3d20 2876 6573      bool1 = (ves
+00033de0: 5f70 6f6c 792e 7368 6170 655b 305d 3d3d  _poly.shape[0]==
+00033df0: 3220 616e 6420 7665 735f 6e6f 726d 2e73  2 and ves_norm.s
+00033e00: 6861 7065 5b30 5d3d 3d32 0a20 2020 2020  hape[0]==2.     
 00033e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00033e20: 2020 2020 616e 6420 7665 735f 6e6f 726d      and ves_norm
-00033e30: 2e73 6861 7065 5b31 5d3d 3d76 6573 5f70  .shape[1]==ves_p
-00033e40: 6f6c 792e 7368 6170 655b 315d 2d31 290a  oly.shape[1]-1).
-00033e50: 2020 2020 2020 2020 2020 2020 6d73 6720              msg 
-00033e60: 3d20 2241 7267 7320 7665 735f 706f 6c79  = "Args ves_poly
-00033e70: 2026 2076 6573 5f6e 6f72 6d20 6d75 7374   & ves_norm must
-00033e80: 2062 6520 6f66 2074 6865 2073 616d 6520   be of the same 
-00033e90: 7368 6170 6520 2832 2c20 4e53 2921 220a  shape (2, NS)!".
-00033ea0: 2020 2020 2020 2020 2020 2020 6173 7365              asse
-00033eb0: 7274 2062 6f6f 6c31 2c20 6d73 670a 2020  rt bool1, msg.  
-00033ec0: 2020 2020 2020 2020 2020 626f 6f6c 3120            bool1 
-00033ed0: 3d20 286c 7374 7275 6374 5f6c 696d 7320  = (lstruct_lims 
-00033ee0: 6973 204e 6f6e 650a 2020 2020 2020 2020  is None.        
-00033ef0: 2020 2020 2020 2020 2020 2020 206f 7220               or 
-00033f00: 6c65 6e28 6c73 7472 7563 745f 6e6f 726d  len(lstruct_norm
-00033f10: 7929 203d 3d20 6c65 6e28 6c73 7472 7563  y) == len(lstruc
-00033f20: 745f 6e6f 726d 7829 290a 2020 2020 2020  t_normx)).      
-00033f30: 2020 2020 2020 626f 6f6c 3220 3d20 286c        bool2 = (l
-00033f40: 7374 7275 6374 5f6e 6f72 6d78 2069 7320  struct_normx is 
-00033f50: 4e6f 6e65 0a20 2020 2020 2020 2020 2020  None.           
-00033f60: 2020 2020 2020 2020 2020 6f72 206c 656e            or len
-00033f70: 286c 7374 7275 6374 5f70 6f6c 7978 2920  (lstruct_polyx) 
-00033f80: 3d3d 206c 656e 286c 7374 7275 6374 5f70  == len(lstruct_p
-00033f90: 6f6c 7979 2929 0a20 2020 2020 2020 2020  olyy)).         
-00033fa0: 2020 206d 7367 203d 2022 4172 6773 206c     msg = "Args l
-00033fb0: 7374 7275 6374 5f70 6f6c 7978 2c20 6c73  struct_polyx, ls
-00033fc0: 7472 7563 745f 706f 6c79 792c 206c 7374  truct_polyy, lst
-00033fd0: 7275 6374 5f6c 696d 732c 225c 0a20 2020  ruct_lims,"\.   
-00033fe0: 2020 2020 2020 2020 2020 2020 202b 2022               + "
-00033ff0: 206c 7374 7275 6374 5f6e 6f72 6d78 2c20   lstruct_normx, 
-00034000: 6c73 7472 7563 745f 6e6f 726d 792c 206d  lstruct_normy, m
-00034010: 7573 7420 6265 204e 6f6e 6520 6f72 225c  ust be None or"\
-00034020: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00034030: 202b 2022 206c 6973 7473 206f 6620 7361   + " lists of sa
-00034040: 6d65 206c 656e 2829 2122 0a20 2020 2020  me len()!".     
-00034050: 2020 2020 2020 2061 7373 6572 7420 626f         assert bo
-00034060: 6f6c 3120 616e 6420 626f 6f6c 322c 206d  ol1 and bool2, m
-00034070: 7367 0a20 2020 2020 2020 206d 7367 203d  sg.        msg =
-00034080: 2022 5b65 7073 5f75 7a2c 6570 735f 767a   "[eps_uz,eps_vz
-00034090: 2c65 7073 5f61 2c65 7073 5f62 5d20 6d75  ,eps_a,eps_b] mu
-000340a0: 7374 2062 6520 666c 6f61 7473 203c 2031  st be floats < 1
-000340b0: 2e65 2d34 2122 0a20 2020 2020 2020 2061  .e-4!".        a
-000340c0: 7373 6572 7420 616c 6c28 5b65 6520 3c20  ssert all([ee < 
-000340d0: 312e 652d 3420 666f 7220 6565 2069 6e20  1.e-4 for ee in 
-000340e0: 5b65 7073 5f75 7a2c 2065 7073 5f61 2c0a  [eps_uz, eps_a,.
+00033e20: 616e 6420 7665 735f 6e6f 726d 2e73 6861  and ves_norm.sha
+00033e30: 7065 5b31 5d3d 3d76 6573 5f70 6f6c 792e  pe[1]==ves_poly.
+00033e40: 7368 6170 655b 315d 2d31 290a 2020 2020  shape[1]-1).    
+00033e50: 2020 2020 2020 2020 6d73 6720 3d20 2241          msg = "A
+00033e60: 7267 7320 7665 735f 706f 6c79 2026 2076  rgs ves_poly & v
+00033e70: 6573 5f6e 6f72 6d20 6d75 7374 2062 6520  es_norm must be 
+00033e80: 6f66 2074 6865 2073 616d 6520 7368 6170  of the same shap
+00033e90: 6520 2832 2c20 4e53 2921 220a 2020 2020  e (2, NS)!".    
+00033ea0: 2020 2020 2020 2020 6173 7365 7274 2062          assert b
+00033eb0: 6f6f 6c31 2c20 6d73 670a 2020 2020 2020  ool1, msg.      
+00033ec0: 2020 2020 2020 626f 6f6c 3120 3d20 286c        bool1 = (l
+00033ed0: 7374 7275 6374 5f6c 696d 7320 6973 204e  struct_lims is N
+00033ee0: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
+00033ef0: 2020 2020 2020 2020 206f 7220 6c65 6e28           or len(
+00033f00: 6c73 7472 7563 745f 6e6f 726d 7929 203d  lstruct_normy) =
+00033f10: 3d20 6c65 6e28 6c73 7472 7563 745f 6e6f  = len(lstruct_no
+00033f20: 726d 7829 290a 2020 2020 2020 2020 2020  rmx)).          
+00033f30: 2020 626f 6f6c 3220 3d20 286c 7374 7275    bool2 = (lstru
+00033f40: 6374 5f6e 6f72 6d78 2069 7320 4e6f 6e65  ct_normx is None
+00033f50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00033f60: 2020 2020 2020 6f72 206c 656e 286c 7374        or len(lst
+00033f70: 7275 6374 5f70 6f6c 7978 2920 3d3d 206c  ruct_polyx) == l
+00033f80: 656e 286c 7374 7275 6374 5f70 6f6c 7979  en(lstruct_polyy
+00033f90: 2929 0a20 2020 2020 2020 2020 2020 206d  )).            m
+00033fa0: 7367 203d 2022 4172 6773 206c 7374 7275  sg = "Args lstru
+00033fb0: 6374 5f70 6f6c 7978 2c20 6c73 7472 7563  ct_polyx, lstruc
+00033fc0: 745f 706f 6c79 792c 206c 7374 7275 6374  t_polyy, lstruct
+00033fd0: 5f6c 696d 732c 225c 0a20 2020 2020 2020  _lims,"\.       
+00033fe0: 2020 2020 2020 2020 202b 2022 206c 7374           + " lst
+00033ff0: 7275 6374 5f6e 6f72 6d78 2c20 6c73 7472  ruct_normx, lstr
+00034000: 7563 745f 6e6f 726d 792c 206d 7573 7420  uct_normy, must 
+00034010: 6265 204e 6f6e 6520 6f72 225c 0a20 2020  be None or"\.   
+00034020: 2020 2020 2020 2020 2020 2020 202b 2022               + "
+00034030: 206c 6973 7473 206f 6620 7361 6d65 206c   lists of same l
+00034040: 656e 2829 2122 0a20 2020 2020 2020 2020  en()!".         
+00034050: 2020 2061 7373 6572 7420 626f 6f6c 3120     assert bool1 
+00034060: 616e 6420 626f 6f6c 322c 206d 7367 0a20  and bool2, msg. 
+00034070: 2020 2020 2020 206d 7367 203d 2022 5b65         msg = "[e
+00034080: 7073 5f75 7a2c 6570 735f 767a 2c65 7073  ps_uz,eps_vz,eps
+00034090: 5f61 2c65 7073 5f62 5d20 6d75 7374 2062  _a,eps_b] must b
+000340a0: 6520 666c 6f61 7473 203c 2031 2e65 2d34  e floats < 1.e-4
+000340b0: 2122 0a20 2020 2020 2020 2061 7373 6572  !".        asser
+000340c0: 7420 616c 6c28 5b65 6520 3c20 312e 652d  t all([ee < 1.e-
+000340d0: 3420 666f 7220 6565 2069 6e20 5b65 7073  4 for ee in [eps
+000340e0: 5f75 7a2c 2065 7073 5f61 2c0a 2020 2020  _uz, eps_a,.    
 000340f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00034100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034110: 2020 2020 2020 2020 2020 6570 735f 767a            eps_vz
-00034120: 2c20 6570 735f 622c 0a20 2020 2020 2020  , eps_b,.       
+00034110: 2020 2020 2020 6570 735f 767a 2c20 6570        eps_vz, ep
+00034120: 735f 622c 0a20 2020 2020 2020 2020 2020  s_b,.           
 00034130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034150: 2020 2065 7073 5f70 6c61 6e65 5d5d 292c     eps_plane]]),
-00034160: 206d 7367 0a20 2020 2020 2020 206d 7367   msg.        msg
-00034170: 203d 2022 7665 735f 7479 7065 206d 7573   = "ves_type mus
-00034180: 7420 6265 2061 2073 7472 2069 6e20 5b27  t be a str in ['
-00034190: 546f 7227 2c27 4c69 6e27 5d21 220a 2020  Tor','Lin']!".  
-000341a0: 2020 2020 2020 6173 7365 7274 2076 6573        assert ves
-000341b0: 5f74 7970 652e 6c6f 7765 7228 2920 696e  _type.lower() in
-000341c0: 205b 2774 6f72 272c 2027 6c69 6e27 5d2c   ['tor', 'lin'],
-000341d0: 206d 7367 0a20 2020 2023 202e 2e2e 0a20   msg.    # .... 
-000341e0: 2020 2023 202e 2e20 4765 7474 696e 6720     # .. Getting 
-000341f0: 7369 7a65 206f 6620 6172 7261 7973 202e  size of arrays .
+00034140: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00034150: 7073 5f70 6c61 6e65 5d5d 292c 206d 7367  ps_plane]]), msg
+00034160: 0a20 2020 2020 2020 206d 7367 203d 2022  .        msg = "
+00034170: 7665 735f 7479 7065 206d 7573 7420 6265  ves_type must be
+00034180: 2061 2073 7472 2069 6e20 5b27 546f 7227   a str in ['Tor'
+00034190: 2c27 4c69 6e27 5d21 220a 2020 2020 2020  ,'Lin']!".      
+000341a0: 2020 6173 7365 7274 2076 6573 5f74 7970    assert ves_typ
+000341b0: 652e 6c6f 7765 7228 2920 696e 205b 2774  e.lower() in ['t
+000341c0: 6f72 272c 2027 6c69 6e27 5d2c 206d 7367  or', 'lin'], msg
+000341d0: 0a20 2020 2023 202e 2e2e 0a20 2020 2023  .    # ....    #
+000341e0: 202e 2e20 4765 7474 696e 6720 7369 7a65   .. Getting size
+000341f0: 206f 6620 6172 7261 7973 202e 2e2e 2e2e   of arrays .....
 00034200: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00034210: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034220: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a  ................
-00034230: 2020 2020 737a 5f70 203d 2070 6172 745f      sz_p = part_
-00034240: 636f 6f72 6473 2e73 6861 7065 5b31 5d0a  coords.shape[1].
-00034250: 2020 2020 2320 2320 2e2e 2043 6865 636b      # # .. Check
-00034260: 2069 6620 706f 696e 7473 2061 7265 2076   if points are v
-00034270: 6973 6962 6c65 202e 2e2e 2e2e 2e2e 2e2e  isible .........
+00034220: 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a 2020 2020  ............    
+00034230: 737a 5f70 203d 2070 6172 745f 636f 6f72  sz_p = part_coor
+00034240: 6473 2e73 6861 7065 5b31 5d0a 2020 2020  ds.shape[1].    
+00034250: 2320 2320 2e2e 2043 6865 636b 2069 6620  # # .. Check if 
+00034260: 706f 696e 7473 2061 7265 2076 6973 6962  points are visib
+00034270: 6c65 202e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  le .............
 00034280: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034290: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-000342a0: 2e2e 0a20 2020 2023 2047 6574 2074 6865  ...    # Get the
-000342b0: 2061 6374 7561 6c20 5220 616e 6420 5a20   actual R and Z 
-000342c0: 7265 736f 6c75 7469 6f6e 7320 616e 6420  resolutions and 
-000342d0: 6d65 7368 2065 6c65 6d65 6e74 730a 2020  mesh elements.  
-000342e0: 2020 2320 2e2e 2046 6972 7374 2077 6520    # .. First we 
-000342f0: 6469 7363 7265 7469 7a65 2052 2077 6974  discretize R wit
-00034300: 686f 7574 206c 696d 6974 7320 2e2e 2e2e  hout limits ....
+00034290: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20  ............... 
+000342a0: 2020 2023 2047 6574 2074 6865 2061 6374     # Get the act
+000342b0: 7561 6c20 5220 616e 6420 5a20 7265 736f  ual R and Z reso
+000342c0: 6c75 7469 6f6e 7320 616e 6420 6d65 7368  lutions and mesh
+000342d0: 2065 6c65 6d65 6e74 730a 2020 2020 2320   elements.    # 
+000342e0: 2e2e 2046 6972 7374 2077 6520 6469 7363  .. First we disc
+000342f0: 7265 7469 7a65 2052 2077 6974 686f 7574  retize R without
+00034300: 206c 696d 6974 7320 2e2e 2e2e 2e2e 2e2e   limits ........
 00034310: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034320: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20  ............... 
-00034330: 2020 205f 7374 2e63 7974 686f 6e69 7a65     _st.cythonize
-00034340: 5f73 7562 646f 6d61 696e 5f64 6c28 4e6f  _subdomain_dl(No
-00034350: 6e65 2c20 6c69 6d69 7473 5f64 6c29 2023  ne, limits_dl) #
-00034360: 206e 6f20 6c69 6d69 7473 0a20 2020 205f   no limits.    _
-00034370: 203d 205f 7374 2e64 6973 6372 6574 697a   = _st.discretiz
-00034380: 655f 6c69 6e65 3164 5f63 6f72 6528 2652  e_line1d_core(&R
-00034390: 4d69 6e4d 6178 5b30 5d2c 2072 7374 6570  MinMax[0], rstep
-000343a0: 2c20 6c69 6d69 7473 5f64 6c2c 0a20 2020  , limits_dl,.   
+00034320: 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020 205f  ...........    _
+00034330: 7374 2e63 7974 686f 6e69 7a65 5f73 7562  st.cythonize_sub
+00034340: 646f 6d61 696e 5f64 6c28 4e6f 6e65 2c20  domain_dl(None, 
+00034350: 6c69 6d69 7473 5f64 6c29 2023 206e 6f20  limits_dl) # no 
+00034360: 6c69 6d69 7473 0a20 2020 205f 203d 205f  limits.    _ = _
+00034370: 7374 2e64 6973 6372 6574 697a 655f 6c69  st.discretize_li
+00034380: 6e65 3164 5f63 6f72 6528 2652 4d69 6e4d  ne1d_core(&RMinM
+00034390: 6178 5b30 5d2c 2072 7374 6570 2c20 6c69  ax[0], rstep, li
+000343a0: 6d69 7473 5f64 6c2c 0a20 2020 2020 2020  mits_dl,.       
 000343b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000343c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000343d0: 5472 7565 2c20 302c 2023 2064 6973 6372  True, 0, # discr
-000343e0: 6574 697a 6520 696e 2061 6273 6f6c 7574  etize in absolut
-000343f0: 6520 6d6f 6465 0a20 2020 2020 2020 2020  e mode.         
+000343c0: 2020 2020 2020 2020 2020 2020 5472 7565              True
+000343d0: 2c20 302c 2023 2064 6973 6372 6574 697a  , 0, # discretiz
+000343e0: 6520 696e 2061 6273 6f6c 7574 6520 6d6f  e in absolute mo
+000343f0: 6465 0a20 2020 2020 2020 2020 2020 2020  de.             
 00034400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034410: 2020 2020 2020 2020 2020 6d61 7267 696e            margin
-00034420: 2c20 2664 6973 635f 7230 2c20 7265 736f  , &disc_r0, reso
-00034430: 5f72 302c 2026 6c69 6e64 6578 2c0a 2020  _r0, &lindex,.  
+00034410: 2020 2020 2020 6d61 7267 696e 2c20 2664        margin, &d
+00034420: 6973 635f 7230 2c20 7265 736f 5f72 302c  isc_r0, reso_r0,
+00034430: 2026 6c69 6e64 6578 2c0a 2020 2020 2020   &lindex,.      
 00034440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034460: 206e 6365 6c6c 735f 7230 290a 2020 2020   ncells_r0).    
-00034470: 6672 6565 286c 696e 6465 7829 2023 2067  free(lindex) # g
-00034480: 6574 7469 6e67 2072 6964 206f 6620 7468  etting rid of th
-00034490: 696e 6773 2077 6520 646f 6e74 206e 6565  ings we dont nee
-000344a0: 640a 2020 2020 6c69 6e64 6578 203d 204e  d.    lindex = N
-000344b0: 554c 4c0a 2020 2020 2320 2e2e 204e 6f77  ULL.    # .. Now
-000344c0: 2074 6865 2061 6374 7561 6c20 5220 6c69   the actual R li
-000344d0: 6d69 7465 6420 202e 2e2e 2e2e 2e2e 2e2e  mited  .........
+00034450: 2020 2020 2020 2020 2020 2020 206e 6365               nce
+00034460: 6c6c 735f 7230 290a 2020 2020 6672 6565  lls_r0).    free
+00034470: 286c 696e 6465 7829 2023 2067 6574 7469  (lindex) # getti
+00034480: 6e67 2072 6964 206f 6620 7468 696e 6773  ng rid of things
+00034490: 2077 6520 646f 6e74 206e 6565 640a 2020   we dont need.  
+000344a0: 2020 6c69 6e64 6578 203d 204e 554c 4c0a    lindex = NULL.
+000344b0: 2020 2020 2320 2e2e 204e 6f77 2074 6865      # .. Now the
+000344c0: 2061 6374 7561 6c20 5220 6c69 6d69 7465   actual R limite
+000344d0: 6420 202e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  d  .............
 000344e0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 000344f0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034500: 2e2e 2e2e 0a20 2020 205f 7374 2e63 7974  .....    _st.cyt
-00034510: 686f 6e69 7a65 5f73 7562 646f 6d61 696e  honize_subdomain
-00034520: 5f64 6c28 4452 2c20 6c69 6d69 7473 5f64  _dl(DR, limits_d
-00034530: 6c29 0a20 2020 2073 7a5f 7220 3d20 5f73  l).    sz_r = _s
-00034540: 742e 6469 7363 7265 7469 7a65 5f6c 696e  t.discretize_lin
-00034550: 6531 645f 636f 7265 2826 524d 696e 4d61  e1d_core(&RMinMa
-00034560: 785b 305d 2c20 7273 7465 702c 206c 696d  x[0], rstep, lim
-00034570: 6974 735f 646c 2c0a 2020 2020 2020 2020  its_dl,.        
+00034500: 0a20 2020 205f 7374 2e63 7974 686f 6e69  .    _st.cythoni
+00034510: 7a65 5f73 7562 646f 6d61 696e 5f64 6c28  ze_subdomain_dl(
+00034520: 4452 2c20 6c69 6d69 7473 5f64 6c29 0a20  DR, limits_dl). 
+00034530: 2020 2073 7a5f 7220 3d20 5f73 742e 6469     sz_r = _st.di
+00034540: 7363 7265 7469 7a65 5f6c 696e 6531 645f  scretize_line1d_
+00034550: 636f 7265 2826 524d 696e 4d61 785b 305d  core(&RMinMax[0]
+00034560: 2c20 7273 7465 702c 206c 696d 6974 735f  , rstep, limits_
+00034570: 646c 2c0a 2020 2020 2020 2020 2020 2020  dl,.            
 00034580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034590: 2020 2020 2020 2020 2020 2020 2020 5472                Tr
-000345a0: 7565 2c20 302c 2023 2064 6973 6372 6574  ue, 0, # discret
-000345b0: 697a 6520 696e 2061 6273 6f6c 7574 6520  ize in absolute 
-000345c0: 6d6f 6465 0a20 2020 2020 2020 2020 2020  mode.           
+00034590: 2020 2020 2020 2020 2020 5472 7565 2c20            True, 
+000345a0: 302c 2023 2064 6973 6372 6574 697a 6520  0, # discretize 
+000345b0: 696e 2061 6273 6f6c 7574 6520 6d6f 6465  in absolute mode
+000345c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 000345d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000345e0: 2020 2020 2020 2020 2020 206d 6172 6769             margi
-000345f0: 6e2c 2026 6469 7363 5f72 2c20 7265 736f  n, &disc_r, reso
-00034600: 5f72 2c20 266c 696e 6465 782c 0a20 2020  _r, &lindex,.   
+000345e0: 2020 2020 2020 206d 6172 6769 6e2c 2026         margin, &
+000345f0: 6469 7363 5f72 2c20 7265 736f 5f72 2c20  disc_r, reso_r, 
+00034600: 266c 696e 6465 782c 0a20 2020 2020 2020  &lindex,.       
 00034610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034630: 2020 206e 6365 6c6c 735f 7229 0a20 2020     ncells_r).   
-00034640: 2066 7265 6528 6c69 6e64 6578 2920 2320   free(lindex) # 
-00034650: 6765 7474 696e 6720 7269 6420 6f66 2074  getting rid of t
-00034660: 6869 6e67 7320 7765 2064 6f6e 7420 6e65  hings we dont ne
-00034670: 6564 0a20 2020 2023 202e 2e20 4e6f 7720  ed.    # .. Now 
-00034680: 5a20 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  Z ..............
+00034620: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00034630: 6365 6c6c 735f 7229 0a20 2020 2066 7265  cells_r).    fre
+00034640: 6528 6c69 6e64 6578 2920 2320 6765 7474  e(lindex) # gett
+00034650: 696e 6720 7269 6420 6f66 2074 6869 6e67  ing rid of thing
+00034660: 7320 7765 2064 6f6e 7420 6e65 6564 0a20  s we dont need. 
+00034670: 2020 2023 202e 2e20 4e6f 7720 5a20 2e2e     # .. Now Z ..
+00034680: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00034690: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 000346a0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-000346b0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-000346c0: 2e2e 2e0a 2020 2020 5f73 742e 6379 7468  ....    _st.cyth
-000346d0: 6f6e 697a 655f 7375 6264 6f6d 6169 6e5f  onize_subdomain_
-000346e0: 646c 2844 5a2c 206c 696d 6974 735f 646c  dl(DZ, limits_dl
-000346f0: 290a 2020 2020 737a 5f7a 203d 205f 7374  ).    sz_z = _st
-00034700: 2e64 6973 6372 6574 697a 655f 6c69 6e65  .discretize_line
-00034710: 3164 5f63 6f72 6528 265a 4d69 6e4d 6178  1d_core(&ZMinMax
-00034720: 5b30 5d2c 207a 7374 6570 2c20 6c69 6d69  [0], zstep, limi
-00034730: 7473 5f64 6c2c 0a20 2020 2020 2020 2020  ts_dl,.         
+000346b0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a  ................
+000346c0: 2020 2020 5f73 742e 6379 7468 6f6e 697a      _st.cythoniz
+000346d0: 655f 7375 6264 6f6d 6169 6e5f 646c 2844  e_subdomain_dl(D
+000346e0: 5a2c 206c 696d 6974 735f 646c 290a 2020  Z, limits_dl).  
+000346f0: 2020 737a 5f7a 203d 205f 7374 2e64 6973    sz_z = _st.dis
+00034700: 6372 6574 697a 655f 6c69 6e65 3164 5f63  cretize_line1d_c
+00034710: 6f72 6528 265a 4d69 6e4d 6178 5b30 5d2c  ore(&ZMinMax[0],
+00034720: 207a 7374 6570 2c20 6c69 6d69 7473 5f64   zstep, limits_d
+00034730: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
 00034740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00034750: 2020 2020 2020 2020 2020 2020 2054 7275               Tru
-00034760: 652c 2030 2c20 2320 6469 7363 7265 7469  e, 0, # discreti
-00034770: 7a65 2069 6e20 6162 736f 6c75 7465 206d  ze in absolute m
-00034780: 6f64 650a 2020 2020 2020 2020 2020 2020  ode.            
+00034750: 2020 2020 2020 2020 2054 7275 652c 2030           True, 0
+00034760: 2c20 2320 6469 7363 7265 7469 7a65 2069  , # discretize i
+00034770: 6e20 6162 736f 6c75 7465 206d 6f64 650a  n absolute mode.
+00034780: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00034790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000347a0: 2020 2020 2020 2020 2020 6d61 7267 696e            margin
-000347b0: 2c20 2664 6973 635f 7a2c 2072 6573 6f5f  , &disc_z, reso_
-000347c0: 7a2c 2026 6c69 6e64 6578 5f7a 2c0a 2020  z, &lindex_z,.  
+000347a0: 2020 2020 2020 6d61 7267 696e 2c20 2664        margin, &d
+000347b0: 6973 635f 7a2c 2072 6573 6f5f 7a2c 2026  isc_z, reso_z, &
+000347c0: 6c69 6e64 6578 5f7a 2c0a 2020 2020 2020  lindex_z,.      
 000347d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000347e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000347f0: 2020 2020 6e63 656c 6c73 5f7a 290a 2020      ncells_z).  
-00034800: 2020 2320 2e2e 2050 7265 7061 7269 6e67    # .. Preparing
-00034810: 2066 6f72 2070 6869 3a20 6765 7420 7468   for phi: get th
-00034820: 6520 6c69 6d69 7473 2069 6620 616e 7920  e limits if any 
-00034830: 616e 6420 6d61 6b65 2073 7572 6520 746f  and make sure to
-00034840: 2072 6570 6c61 6365 2074 6865 6d0a 2020   replace them.  
-00034850: 2020 2320 2e2e 2069 6e20 7468 6520 7072    # .. in the pr
-00034860: 6f70 6572 2071 7561 6472 616e 7473 202e  oper quadrants .
+000347f0: 6e63 656c 6c73 5f7a 290a 2020 2020 2320  ncells_z).    # 
+00034800: 2e2e 2050 7265 7061 7269 6e67 2066 6f72  .. Preparing for
+00034810: 2070 6869 3a20 6765 7420 7468 6520 6c69   phi: get the li
+00034820: 6d69 7473 2069 6620 616e 7920 616e 6420  mits if any and 
+00034830: 6d61 6b65 2073 7572 6520 746f 2072 6570  make sure to rep
+00034840: 6c61 6365 2074 6865 6d0a 2020 2020 2320  lace them.    # 
+00034850: 2e2e 2069 6e20 7468 6520 7072 6f70 6572  .. in the proper
+00034860: 2071 7561 6472 616e 7473 202e 2e2e 2e2e   quadrants .....
 00034870: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00034880: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034890: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20  ............... 
-000348a0: 2020 2069 6620 4450 6869 2069 7320 4e6f     if DPhi is No
-000348b0: 6e65 3a0a 2020 2020 2020 2020 6d69 6e5f  ne:.        min_
-000348c0: 7068 6920 3d20 2d63 5f70 690a 2020 2020  phi = -c_pi.    
-000348d0: 2020 2020 6d61 785f 7068 6920 3d20 635f      max_phi = c_
-000348e0: 7069 0a20 2020 2065 6c73 653a 0a20 2020  pi.    else:.   
-000348f0: 2020 2020 206d 696e 5f70 6869 203d 2044       min_phi = D
-00034900: 5068 695b 305d 2023 2074 6f20 6176 6f69  Phi[0] # to avoi
-00034910: 6420 636f 6e76 6572 7369 6f6e 730a 2020  d conversions.  
-00034920: 2020 2020 2020 6d69 6e5f 7068 6920 3d20        min_phi = 
-00034930: 635f 6174 616e 3228 635f 7369 6e28 6d69  c_atan2(c_sin(mi
-00034940: 6e5f 7068 6929 2c20 635f 636f 7328 6d69  n_phi), c_cos(mi
-00034950: 6e5f 7068 6929 290a 2020 2020 2020 2020  n_phi)).        
-00034960: 6d61 785f 7068 6920 3d20 4450 6869 5b31  max_phi = DPhi[1
-00034970: 5d20 2320 746f 2061 766f 6964 2063 6f6e  ] # to avoid con
-00034980: 7665 7273 696f 6e73 0a20 2020 2020 2020  versions.       
-00034990: 206d 6178 5f70 6869 203d 2063 5f61 7461   max_phi = c_ata
-000349a0: 6e32 2863 5f73 696e 286d 6178 5f70 6869  n2(c_sin(max_phi
-000349b0: 292c 2063 5f63 6f73 286d 6178 5f70 6869  ), c_cos(max_phi
-000349c0: 2929 0a20 2020 2023 202e 2e20 496e 6974  )).    # .. Init
-000349d0: 6961 6c69 7a61 7469 6f6e 202e 2e2e 2e2e  ialization .....
+00034890: 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020 2069  ...........    i
+000348a0: 6620 4450 6869 2069 7320 4e6f 6e65 3a0a  f DPhi is None:.
+000348b0: 2020 2020 2020 2020 6d69 6e5f 7068 6920          min_phi 
+000348c0: 3d20 2d63 5f70 690a 2020 2020 2020 2020  = -c_pi.        
+000348d0: 6d61 785f 7068 6920 3d20 635f 7069 0a20  max_phi = c_pi. 
+000348e0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000348f0: 206d 696e 5f70 6869 203d 2044 5068 695b   min_phi = DPhi[
+00034900: 305d 2023 2074 6f20 6176 6f69 6420 636f  0] # to avoid co
+00034910: 6e76 6572 7369 6f6e 730a 2020 2020 2020  nversions.      
+00034920: 2020 6d69 6e5f 7068 6920 3d20 635f 6174    min_phi = c_at
+00034930: 616e 3228 635f 7369 6e28 6d69 6e5f 7068  an2(c_sin(min_ph
+00034940: 6929 2c20 635f 636f 7328 6d69 6e5f 7068  i), c_cos(min_ph
+00034950: 6929 290a 2020 2020 2020 2020 6d61 785f  i)).        max_
+00034960: 7068 6920 3d20 4450 6869 5b31 5d20 2320  phi = DPhi[1] # 
+00034970: 746f 2061 766f 6964 2063 6f6e 7665 7273  to avoid convers
+00034980: 696f 6e73 0a20 2020 2020 2020 206d 6178  ions.        max
+00034990: 5f70 6869 203d 2063 5f61 7461 6e32 2863  _phi = c_atan2(c
+000349a0: 5f73 696e 286d 6178 5f70 6869 292c 2063  _sin(max_phi), c
+000349b0: 5f63 6f73 286d 6178 5f70 6869 2929 0a20  _cos(max_phi)). 
+000349c0: 2020 2023 202e 2e20 496e 6974 6961 6c69     # .. Initiali
+000349d0: 7a61 7469 6f6e 202e 2e2e 2e2e 2e2e 2e2e  zation .........
 000349e0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 000349f0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034a00: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034a10: 2e2e 2e0a 2020 2020 737a 5f70 6869 203d  ....    sz_phi =
-00034a20: 203c 6c6f 6e67 2a3e 6d61 6c6c 6f63 2873   <long*>malloc(s
-00034a30: 7a5f 722a 7369 7a65 6f66 286c 6f6e 6729  z_r*sizeof(long)
-00034a40: 290a 2020 2020 6e63 656c 6c73 5f72 7068  ).    ncells_rph
-00034a50: 6920 203d 203c 6c6f 6e67 2a3e 6d61 6c6c  i  = <long*>mall
-00034a60: 6f63 2873 7a5f 722a 7369 7a65 6f66 286c  oc(sz_r*sizeof(l
-00034a70: 6f6e 6729 290a 2020 2020 7374 6570 5f72  ong)).    step_r
-00034a80: 7068 6920 2020 203d 203c 646f 7562 6c65  phi    = <double
-00034a90: 2a3e 6d61 6c6c 6f63 2873 7a5f 722a 7369  *>malloc(sz_r*si
-00034aa0: 7a65 6f66 2864 6f75 626c 6529 290a 2020  zeof(double)).  
-00034ab0: 2020 725f 7261 7469 6f20 3d20 3c69 6e74    r_ratio = <int
-00034ac0: 3e28 635f 6365 696c 2864 6973 635f 725b  >(c_ceil(disc_r[
-00034ad0: 737a 5f72 202d 2031 5d20 2f20 6469 7363  sz_r - 1] / disc
-00034ae0: 5f72 5b30 5d29 290a 2020 2020 7477 6f70  _r[0])).    twop
-00034af0: 695f 6f76 6572 5f64 7068 6920 3d20 5f54  i_over_dphi = _T
-00034b00: 574f 5049 202f 2070 6869 7374 6570 0a20  WOPI / phistep. 
-00034b10: 2020 2069 6e64 5f6c 6f63 5f72 3020 3d20     ind_loc_r0 = 
-00034b20: 300a 2020 2020 6d69 6e5f 7068 695f 7069  0.    min_phi_pi
-00034b30: 203d 206d 696e 5f70 6869 202b 2063 5f70   = min_phi + c_p
-00034b40: 690a 2020 2020 6d61 785f 7068 695f 7069  i.    max_phi_pi
-00034b50: 203d 206d 6178 5f70 6869 202b 2063 5f70   = max_phi + c_p
-00034b60: 690a 2020 2020 6162 7330 203d 2063 5f61  i.    abs0 = c_a
-00034b70: 6273 286d 696e 5f70 6869 5f70 6929 0a20  bs(min_phi_pi). 
-00034b80: 2020 2061 6273 3120 3d20 635f 6162 7328     abs1 = c_abs(
-00034b90: 6d61 785f 7068 695f 7069 290a 2020 2020  max_phi_pi).    
-00034ba0: 2320 2e2e 2e20 646f 696e 6720 3020 6c6f  # ... doing 0 lo
-00034bb0: 6f70 2062 6566 6f72 6520 2e2e 2e2e 2e2e  op before ......
+00034a00: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a  ................
+00034a10: 2020 2020 737a 5f70 6869 203d 203c 6c6f      sz_phi = <lo
+00034a20: 6e67 2a3e 6d61 6c6c 6f63 2873 7a5f 722a  ng*>malloc(sz_r*
+00034a30: 7369 7a65 6f66 286c 6f6e 6729 290a 2020  sizeof(long)).  
+00034a40: 2020 6e63 656c 6c73 5f72 7068 6920 203d    ncells_rphi  =
+00034a50: 203c 6c6f 6e67 2a3e 6d61 6c6c 6f63 2873   <long*>malloc(s
+00034a60: 7a5f 722a 7369 7a65 6f66 286c 6f6e 6729  z_r*sizeof(long)
+00034a70: 290a 2020 2020 7374 6570 5f72 7068 6920  ).    step_rphi 
+00034a80: 2020 203d 203c 646f 7562 6c65 2a3e 6d61     = <double*>ma
+00034a90: 6c6c 6f63 2873 7a5f 722a 7369 7a65 6f66  lloc(sz_r*sizeof
+00034aa0: 2864 6f75 626c 6529 290a 2020 2020 725f  (double)).    r_
+00034ab0: 7261 7469 6f20 3d20 3c69 6e74 3e28 635f  ratio = <int>(c_
+00034ac0: 6365 696c 2864 6973 635f 725b 737a 5f72  ceil(disc_r[sz_r
+00034ad0: 202d 2031 5d20 2f20 6469 7363 5f72 5b30   - 1] / disc_r[0
+00034ae0: 5d29 290a 2020 2020 7477 6f70 695f 6f76  ])).    twopi_ov
+00034af0: 6572 5f64 7068 6920 3d20 5f54 574f 5049  er_dphi = _TWOPI
+00034b00: 202f 2070 6869 7374 6570 0a20 2020 2069   / phistep.    i
+00034b10: 6e64 5f6c 6f63 5f72 3020 3d20 300a 2020  nd_loc_r0 = 0.  
+00034b20: 2020 6d69 6e5f 7068 695f 7069 203d 206d    min_phi_pi = m
+00034b30: 696e 5f70 6869 202b 2063 5f70 690a 2020  in_phi + c_pi.  
+00034b40: 2020 6d61 785f 7068 695f 7069 203d 206d    max_phi_pi = m
+00034b50: 6178 5f70 6869 202b 2063 5f70 690a 2020  ax_phi + c_pi.  
+00034b60: 2020 6162 7330 203d 2063 5f61 6273 286d    abs0 = c_abs(m
+00034b70: 696e 5f70 6869 5f70 6929 0a20 2020 2061  in_phi_pi).    a
+00034b80: 6273 3120 3d20 635f 6162 7328 6d61 785f  bs1 = c_abs(max_
+00034b90: 7068 695f 7069 290a 2020 2020 2320 2e2e  phi_pi).    # ..
+00034ba0: 2e20 646f 696e 6720 3020 6c6f 6f70 2062  . doing 0 loop b
+00034bb0: 6566 6f72 6520 2e2e 2e2e 2e2e 2e2e 2e2e  efore ..........
 00034bc0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00034bd0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00034be0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020  .............   
-00034bf0: 2069 6620 6d69 6e5f 7068 6920 3c20 6d61   if min_phi < ma
-00034c00: 785f 7068 693a 0a20 2020 2020 2020 2023  x_phi:.        #
-00034c10: 2047 6574 2074 6865 2061 6374 7561 6c20   Get the actual 
-00034c20: 5250 6869 2072 6573 6f6c 7574 696f 6e20  RPhi resolution 
-00034c30: 616e 6420 5068 6920 6d65 7368 2065 6c65  and Phi mesh ele
-00034c40: 6d65 6e74 7320 2821 2064 6570 656e 6473  ments (! depends
-00034c50: 206f 6e20 5221 290a 2020 2020 2020 2020   on R!).        
-00034c60: 6e63 656c 6c73 5f72 7068 695b 305d 203d  ncells_rphi[0] =
-00034c70: 203c 696e 743e 635f 6365 696c 2874 776f   <int>c_ceil(two
-00034c80: 7069 5f6f 7665 725f 6470 6869 202a 2064  pi_over_dphi * d
-00034c90: 6973 635f 725b 305d 290a 2020 2020 2020  isc_r[0]).      
-00034ca0: 2020 6c6f 635f 6e63 5f72 7068 6920 3d20    loc_nc_rphi = 
-00034cb0: 6e63 656c 6c73 5f72 7068 695b 305d 0a20  ncells_rphi[0]. 
-00034cc0: 2020 2020 2020 2073 7465 705f 7270 6869         step_rphi
-00034cd0: 5b30 5d20 3d20 5f54 574f 5049 202f 206e  [0] = _TWOPI / n
-00034ce0: 6365 6c6c 735f 7270 6869 5b30 5d0a 2020  cells_rphi[0].  
-00034cf0: 2020 2020 2020 696e 765f 6472 7068 6920        inv_drphi 
-00034d00: 3d20 312e 202f 2073 7465 705f 7270 6869  = 1. / step_rphi
-00034d10: 5b30 5d0a 2020 2020 2020 2020 2320 4765  [0].        # Ge
-00034d20: 7420 696e 6465 7820 616e 6420 6375 6d75  t index and cumu
-00034d30: 6c61 7465 6420 696e 6469 6365 7320 6672  lated indices fr
-00034d40: 6f6d 2062 6163 6b67 726f 756e 640a 2020  om background.  
-00034d50: 2020 2020 2020 666f 7220 6a6a 2069 6e20        for jj in 
-00034d60: 7261 6e67 6528 696e 645f 6c6f 635f 7230  range(ind_loc_r0
-00034d70: 2c20 6e63 656c 6c73 5f72 305b 305d 293a  , ncells_r0[0]):
-00034d80: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00034d90: 6469 7363 5f72 305b 6a6a 5d3d 3d64 6973  disc_r0[jj]==dis
-00034da0: 635f 725b 305d 3a0a 2020 2020 2020 2020  c_r[0]:.        
-00034db0: 2020 2020 2020 2020 696e 645f 6c6f 635f          ind_loc_
-00034dc0: 7230 203d 206a 6a0a 2020 2020 2020 2020  r0 = jj.        
-00034dd0: 2020 2020 2020 2020 6272 6561 6b0a 2020          break.  
-00034de0: 2020 2020 2020 2320 4765 7420 696e 6469        # Get indi
-00034df0: 6365 7320 6f66 2070 6869 0a20 2020 2020  ces of phi.     
-00034e00: 2020 2023 2047 6574 2074 6865 2065 7874     # Get the ext
-00034e10: 7265 6d65 2069 6e64 6963 6573 206f 6620  reme indices of 
-00034e20: 7468 6520 6d65 7368 2065 6c65 6d65 6e74  the mesh element
-00034e30: 7320 7468 6174 2072 6561 6c6c 7920 6e65  s that really ne
-00034e40: 6564 2074 6f0a 2020 2020 2020 2020 2320  ed to.        # 
-00034e50: 6265 2063 7265 6174 6564 2077 6974 6869  be created withi
-00034e60: 6e20 7468 6f73 6520 6c69 6d69 7473 0a20  n those limits. 
-00034e70: 2020 2020 2020 2069 6620 6162 7330 202d         if abs0 -
-00034e80: 2073 7465 705f 7270 6869 5b30 5d2a 635f   step_rphi[0]*c_
-00034e90: 666c 6f6f 7228 6162 7330 202a 2069 6e76  floor(abs0 * inv
-00034ea0: 5f64 7270 6869 2920 3c20 6d61 7267 696e  _drphi) < margin
-00034eb0: 2a73 7465 705f 7270 6869 5b30 5d3a 0a20  *step_rphi[0]:. 
-00034ec0: 2020 2020 2020 2020 2020 206e 7068 6930             nphi0
-00034ed0: 203d 2069 6e74 2863 5f72 6f75 6e64 2828   = int(c_round((
-00034ee0: 6d69 6e5f 7068 6920 2b20 635f 7069 2920  min_phi + c_pi) 
-00034ef0: 2a20 696e 765f 6472 7068 6929 290a 2020  * inv_drphi)).  
-00034f00: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00034f10: 2020 2020 2020 2020 6e70 6869 3020 3d20          nphi0 = 
-00034f20: 696e 7428 635f 666c 6f6f 7228 286d 696e  int(c_floor((min
-00034f30: 5f70 6869 202b 635f 7069 2920 2a20 696e  _phi +c_pi) * in
-00034f40: 765f 6472 7068 6929 290a 2020 2020 2020  v_drphi)).      
-00034f50: 2020 6966 2061 6273 312d 7374 6570 5f72    if abs1-step_r
-00034f60: 7068 695b 305d 2a63 5f66 6c6f 6f72 2861  phi[0]*c_floor(a
-00034f70: 6273 3120 2a20 696e 765f 6472 7068 6929  bs1 * inv_drphi)
-00034f80: 203c 206d 6172 6769 6e2a 7374 6570 5f72   < margin*step_r
-00034f90: 7068 695b 305d 3a0a 2020 2020 2020 2020  phi[0]:.        
-00034fa0: 2020 2020 6e70 6869 3120 3d20 696e 7428      nphi1 = int(
-00034fb0: 635f 726f 756e 6428 286d 6178 5f70 6869  c_round((max_phi
-00034fc0: 2b63 5f70 6929 202a 2069 6e76 5f64 7270  +c_pi) * inv_drp
-00034fd0: 6869 292d 3129 0a20 2020 2020 2020 2065  hi)-1).        e
-00034fe0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00034ff0: 206e 7068 6931 203d 2069 6e74 2863 5f66   nphi1 = int(c_f
-00035000: 6c6f 6f72 2828 6d61 785f 7068 692b 635f  loor((max_phi+c_
-00035010: 7069 2920 2a20 696e 765f 6472 7068 6929  pi) * inv_drphi)
-00035020: 290a 2020 2020 2020 2020 737a 5f70 6869  ).        sz_phi
-00035030: 5b30 5d20 3d20 6e70 6869 3120 2b20 3120  [0] = nphi1 + 1 
-00035040: 2d20 6e70 6869 300a 2020 2020 2020 2020  - nphi0.        
-00035050: 6d61 785f 737a 5f70 6869 5b30 5d20 3d20  max_sz_phi[0] = 
-00035060: 737a 5f70 6869 5b30 5d0a 2020 2020 2020  sz_phi[0].      
-00035070: 2020 696e 645f 6920 3d20 2d6e 702e 6f6e    ind_i = -np.on
-00035080: 6573 2828 737a 5f72 2c20 737a 5f70 6869  es((sz_r, sz_phi
-00035090: 5b30 5d20 2a20 725f 7261 7469 6f20 2b20  [0] * r_ratio + 
-000350a0: 3129 2c20 6474 7970 653d 696e 7429 0a20  1), dtype=int). 
-000350b0: 2020 2020 2020 2069 6e64 695f 6d76 203d         indi_mv =
-000350c0: 2069 6e64 5f69 0a20 2020 2020 2020 2066   ind_i.        f
-000350d0: 6f72 206a 6a20 696e 2072 616e 6765 2873  or jj in range(s
-000350e0: 7a5f 7068 695b 305d 293a 0a20 2020 2020  z_phi[0]):.     
-000350f0: 2020 2020 2020 2069 6e64 695f 6d76 5b30         indi_mv[0
-00035100: 2c20 6a6a 5d20 3d20 6e70 6869 3020 2b20  , jj] = nphi0 + 
-00035110: 6a6a 0a20 2020 2020 2020 206e 7074 735f  jj.        npts_
-00035120: 6469 7363 202b 3d20 737a 5f7a 202a 2073  disc += sz_z * s
-00035130: 7a5f 7068 695b 305d 0a20 2020 2065 6c73  z_phi[0].    els
-00035140: 653a 0a20 2020 2020 2020 2023 2047 6574  e:.        # Get
-00035150: 2074 6865 2061 6374 7561 6c20 5250 6869   the actual RPhi
-00035160: 2072 6573 6f6c 7574 696f 6e20 616e 6420   resolution and 
-00035170: 5068 6920 6d65 7368 2065 6c65 6d65 6e74  Phi mesh element
-00035180: 7320 2821 2064 6570 656e 6473 206f 6e20  s (! depends on 
-00035190: 5221 290a 2020 2020 2020 2020 6e63 656c  R!).        ncel
-000351a0: 6c73 5f72 7068 695b 305d 203d 203c 696e  ls_rphi[0] = <in
-000351b0: 743e 635f 6365 696c 2874 776f 7069 5f6f  t>c_ceil(twopi_o
-000351c0: 7665 725f 6470 6869 202a 2064 6973 635f  ver_dphi * disc_
-000351d0: 725b 305d 290a 2020 2020 2020 2020 6c6f  r[0]).        lo
-000351e0: 635f 6e63 5f72 7068 6920 3d20 6e63 656c  c_nc_rphi = ncel
-000351f0: 6c73 5f72 7068 695b 305d 0a20 2020 2020  ls_rphi[0].     
-00035200: 2020 2073 7465 705f 7270 6869 5b30 5d20     step_rphi[0] 
-00035210: 3d20 5f54 574f 5049 202f 206e 6365 6c6c  = _TWOPI / ncell
-00035220: 735f 7270 6869 5b30 5d0a 2020 2020 2020  s_rphi[0].      
-00035230: 2020 696e 765f 6472 7068 6920 3d20 312e    inv_drphi = 1.
-00035240: 202f 2073 7465 705f 7270 6869 5b30 5d0a   / step_rphi[0].
-00035250: 2020 2020 2020 2020 2320 4765 7420 696e          # Get in
-00035260: 6465 7820 616e 6420 6375 6d75 6c61 7465  dex and cumulate
-00035270: 6420 696e 6469 6365 7320 6672 6f6d 2062  d indices from b
-00035280: 6163 6b67 726f 756e 640a 2020 2020 2020  ackground.      
-00035290: 2020 666f 7220 6a6a 2069 6e20 7261 6e67    for jj in rang
-000352a0: 6528 696e 645f 6c6f 635f 7230 2c20 6e63  e(ind_loc_r0, nc
-000352b0: 656c 6c73 5f72 305b 305d 293a 0a20 2020  ells_r0[0]):.   
-000352c0: 2020 2020 2020 2020 2069 6620 6469 7363           if disc
-000352d0: 5f72 305b 6a6a 5d3d 3d64 6973 635f 725b  _r0[jj]==disc_r[
-000352e0: 305d 3a0a 2020 2020 2020 2020 2020 2020  0]:.            
-000352f0: 2020 2020 696e 645f 6c6f 635f 7230 203d      ind_loc_r0 =
-00035300: 206a 6a0a 2020 2020 2020 2020 2020 2020   jj.            
-00035310: 2020 2020 6272 6561 6b0a 2020 2020 2020      break.      
-00035320: 2020 2320 4765 7420 696e 6469 6365 7320    # Get indices 
-00035330: 6f66 2070 6869 0a20 2020 2020 2020 2023  of phi.        #
-00035340: 2047 6574 2074 6865 2065 7874 7265 6d65   Get the extreme
-00035350: 2069 6e64 6963 6573 206f 6620 7468 6520   indices of the 
-00035360: 6d65 7368 2065 6c65 6d65 6e74 7320 7468  mesh elements th
-00035370: 6174 2072 6561 6c6c 7920 6e65 6564 2074  at really need t
-00035380: 6f0a 2020 2020 2020 2020 2320 6265 2063  o.        # be c
-00035390: 7265 6174 6564 2077 6974 6869 6e20 7468  reated within th
-000353a0: 6f73 6520 6c69 6d69 7473 0a20 2020 2020  ose limits.     
-000353b0: 2020 2069 6620 6162 7330 202d 2073 7465     if abs0 - ste
-000353c0: 705f 7270 6869 5b30 5d2a 635f 666c 6f6f  p_rphi[0]*c_floo
-000353d0: 7228 6162 7330 202a 2069 6e76 5f64 7270  r(abs0 * inv_drp
-000353e0: 6869 2920 3c20 6d61 7267 696e 2a73 7465  hi) < margin*ste
-000353f0: 705f 7270 6869 5b30 5d3a 0a20 2020 2020  p_rphi[0]:.     
-00035400: 2020 2020 2020 206e 7068 6930 203d 2069         nphi0 = i
-00035410: 6e74 2863 5f72 6f75 6e64 2828 6d69 6e5f  nt(c_round((min_
-00035420: 7068 6920 2b20 635f 7069 2920 2a20 696e  phi + c_pi) * in
-00035430: 765f 6472 7068 6929 290a 2020 2020 2020  v_drphi)).      
-00035440: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00035450: 2020 2020 6e70 6869 3020 3d20 696e 7428      nphi0 = int(
-00035460: 635f 666c 6f6f 7228 286d 696e 5f70 6869  c_floor((min_phi
-00035470: 202b 2063 5f70 6929 202a 2069 6e76 5f64   + c_pi) * inv_d
-00035480: 7270 6869 2929 0a20 2020 2020 2020 2069  rphi)).        i
-00035490: 6620 6162 7331 2d73 7465 705f 7270 6869  f abs1-step_rphi
-000354a0: 5b30 5d2a 635f 666c 6f6f 7228 6162 7331  [0]*c_floor(abs1
-000354b0: 202a 2069 6e76 5f64 7270 6869 2920 3c20   * inv_drphi) < 
-000354c0: 6d61 7267 696e 2a73 7465 705f 7270 6869  margin*step_rphi
-000354d0: 5b30 5d3a 0a20 2020 2020 2020 2020 2020  [0]:.           
-000354e0: 206e 7068 6931 203d 2069 6e74 2863 5f72   nphi1 = int(c_r
-000354f0: 6f75 6e64 2828 6d61 785f 7068 692b 635f  ound((max_phi+c_
-00035500: 7069 2920 2a20 696e 765f 6472 7068 6929  pi) * inv_drphi)
-00035510: 2d31 290a 2020 2020 2020 2020 656c 7365  -1).        else
-00035520: 3a0a 2020 2020 2020 2020 2020 2020 6e70  :.            np
-00035530: 6869 3120 3d20 696e 7428 635f 666c 6f6f  hi1 = int(c_floo
-00035540: 7228 286d 6178 5f70 6869 2b63 5f70 6929  r((max_phi+c_pi)
-00035550: 202a 2069 6e76 5f64 7270 6869 2929 0a20   * inv_drphi)). 
-00035560: 2020 2020 2020 2073 7a5f 7068 695b 305d         sz_phi[0]
-00035570: 203d 206e 7068 6931 2b31 2b6c 6f63 5f6e   = nphi1+1+loc_n
-00035580: 635f 7270 6869 2d6e 7068 6930 0a20 2020  c_rphi-nphi0.   
-00035590: 2020 2020 206d 6178 5f73 7a5f 7068 695b       max_sz_phi[
-000355a0: 305d 203d 2073 7a5f 7068 695b 305d 0a20  0] = sz_phi[0]. 
-000355b0: 2020 2020 2020 2069 6e64 5f69 203d 202d         ind_i = -
-000355c0: 6e70 2e6f 6e65 7328 2873 7a5f 722c 2073  np.ones((sz_r, s
-000355d0: 7a5f 7068 695b 305d 202a 2072 5f72 6174  z_phi[0] * r_rat
-000355e0: 696f 202b 2031 292c 2064 7479 7065 3d69  io + 1), dtype=i
-000355f0: 6e74 290a 2020 2020 2020 2020 696e 6469  nt).        indi
-00035600: 5f6d 7620 3d20 696e 645f 690a 2020 2020  _mv = ind_i.    
-00035610: 2020 2020 666f 7220 6a6a 2069 6e20 7261      for jj in ra
-00035620: 6e67 6528 6c6f 635f 6e63 5f72 7068 6920  nge(loc_nc_rphi 
-00035630: 2d20 6e70 6869 3029 3a0a 2020 2020 2020  - nphi0):.      
-00035640: 2020 2020 2020 696e 6469 5f6d 765b 302c        indi_mv[0,
-00035650: 206a 6a5d 203d 206e 7068 6930 202b 206a   jj] = nphi0 + j
-00035660: 6a0a 2020 2020 2020 2020 666f 7220 6a6a  j.        for jj
-00035670: 2069 6e20 7261 6e67 6528 6c6f 635f 6e63   in range(loc_nc
-00035680: 5f72 7068 6920 2d20 6e70 6869 302c 2073  _rphi - nphi0, s
-00035690: 7a5f 7068 695b 305d 293a 0a20 2020 2020  z_phi[0]):.     
-000356a0: 2020 2020 2020 2069 6e64 695f 6d76 5b30         indi_mv[0
-000356b0: 2c20 6a6a 5d20 3d20 6a6a 202d 2028 6c6f  , jj] = jj - (lo
-000356c0: 635f 6e63 5f72 7068 6920 2d20 6e70 6869  c_nc_rphi - nphi
-000356d0: 3029 0a20 2020 2020 2020 206e 7074 735f  0).        npts_
-000356e0: 6469 7363 202b 3d20 737a 5f7a 202a 2073  disc += sz_z * s
-000356f0: 7a5f 7068 695b 305d 0a20 2020 2023 202e  z_phi[0].    # .
-00035700: 2e2e 2064 6f69 6e67 2074 6865 206f 7468  .. doing the oth
-00035710: 6572 7320 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ers ............
+00034be0: 2e2e 2e2e 2e2e 2e2e 0a20 2020 2069 6620  .........    if 
+00034bf0: 6d69 6e5f 7068 6920 3c20 6d61 785f 7068  min_phi < max_ph
+00034c00: 693a 0a20 2020 2020 2020 2023 2047 6574  i:.        # Get
+00034c10: 2074 6865 2061 6374 7561 6c20 5250 6869   the actual RPhi
+00034c20: 2072 6573 6f6c 7574 696f 6e20 616e 6420   resolution and 
+00034c30: 5068 6920 6d65 7368 2065 6c65 6d65 6e74  Phi mesh element
+00034c40: 7320 2821 2064 6570 656e 6473 206f 6e20  s (! depends on 
+00034c50: 5221 290a 2020 2020 2020 2020 6e63 656c  R!).        ncel
+00034c60: 6c73 5f72 7068 695b 305d 203d 203c 696e  ls_rphi[0] = <in
+00034c70: 743e 635f 6365 696c 2874 776f 7069 5f6f  t>c_ceil(twopi_o
+00034c80: 7665 725f 6470 6869 202a 2064 6973 635f  ver_dphi * disc_
+00034c90: 725b 305d 290a 2020 2020 2020 2020 6c6f  r[0]).        lo
+00034ca0: 635f 6e63 5f72 7068 6920 3d20 6e63 656c  c_nc_rphi = ncel
+00034cb0: 6c73 5f72 7068 695b 305d 0a20 2020 2020  ls_rphi[0].     
+00034cc0: 2020 2073 7465 705f 7270 6869 5b30 5d20     step_rphi[0] 
+00034cd0: 3d20 5f54 574f 5049 202f 206e 6365 6c6c  = _TWOPI / ncell
+00034ce0: 735f 7270 6869 5b30 5d0a 2020 2020 2020  s_rphi[0].      
+00034cf0: 2020 696e 765f 6472 7068 6920 3d20 312e    inv_drphi = 1.
+00034d00: 202f 2073 7465 705f 7270 6869 5b30 5d0a   / step_rphi[0].
+00034d10: 2020 2020 2020 2020 2320 4765 7420 696e          # Get in
+00034d20: 6465 7820 616e 6420 6375 6d75 6c61 7465  dex and cumulate
+00034d30: 6420 696e 6469 6365 7320 6672 6f6d 2062  d indices from b
+00034d40: 6163 6b67 726f 756e 640a 2020 2020 2020  ackground.      
+00034d50: 2020 666f 7220 6a6a 2069 6e20 7261 6e67    for jj in rang
+00034d60: 6528 696e 645f 6c6f 635f 7230 2c20 6e63  e(ind_loc_r0, nc
+00034d70: 656c 6c73 5f72 305b 305d 293a 0a20 2020  ells_r0[0]):.   
+00034d80: 2020 2020 2020 2020 2069 6620 6469 7363           if disc
+00034d90: 5f72 305b 6a6a 5d3d 3d64 6973 635f 725b  _r0[jj]==disc_r[
+00034da0: 305d 3a0a 2020 2020 2020 2020 2020 2020  0]:.            
+00034db0: 2020 2020 696e 645f 6c6f 635f 7230 203d      ind_loc_r0 =
+00034dc0: 206a 6a0a 2020 2020 2020 2020 2020 2020   jj.            
+00034dd0: 2020 2020 6272 6561 6b0a 2020 2020 2020      break.      
+00034de0: 2020 2320 4765 7420 696e 6469 6365 7320    # Get indices 
+00034df0: 6f66 2070 6869 0a20 2020 2020 2020 2023  of phi.        #
+00034e00: 2047 6574 2074 6865 2065 7874 7265 6d65   Get the extreme
+00034e10: 2069 6e64 6963 6573 206f 6620 7468 6520   indices of the 
+00034e20: 6d65 7368 2065 6c65 6d65 6e74 7320 7468  mesh elements th
+00034e30: 6174 2072 6561 6c6c 7920 6e65 6564 2074  at really need t
+00034e40: 6f0a 2020 2020 2020 2020 2320 6265 2063  o.        # be c
+00034e50: 7265 6174 6564 2077 6974 6869 6e20 7468  reated within th
+00034e60: 6f73 6520 6c69 6d69 7473 0a20 2020 2020  ose limits.     
+00034e70: 2020 2069 6620 6162 7330 202d 2073 7465     if abs0 - ste
+00034e80: 705f 7270 6869 5b30 5d2a 635f 666c 6f6f  p_rphi[0]*c_floo
+00034e90: 7228 6162 7330 202a 2069 6e76 5f64 7270  r(abs0 * inv_drp
+00034ea0: 6869 2920 3c20 6d61 7267 696e 2a73 7465  hi) < margin*ste
+00034eb0: 705f 7270 6869 5b30 5d3a 0a20 2020 2020  p_rphi[0]:.     
+00034ec0: 2020 2020 2020 206e 7068 6930 203d 2069         nphi0 = i
+00034ed0: 6e74 2863 5f72 6f75 6e64 2828 6d69 6e5f  nt(c_round((min_
+00034ee0: 7068 6920 2b20 635f 7069 2920 2a20 696e  phi + c_pi) * in
+00034ef0: 765f 6472 7068 6929 290a 2020 2020 2020  v_drphi)).      
+00034f00: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00034f10: 2020 2020 6e70 6869 3020 3d20 696e 7428      nphi0 = int(
+00034f20: 635f 666c 6f6f 7228 286d 696e 5f70 6869  c_floor((min_phi
+00034f30: 202b 635f 7069 2920 2a20 696e 765f 6472   +c_pi) * inv_dr
+00034f40: 7068 6929 290a 2020 2020 2020 2020 6966  phi)).        if
+00034f50: 2061 6273 312d 7374 6570 5f72 7068 695b   abs1-step_rphi[
+00034f60: 305d 2a63 5f66 6c6f 6f72 2861 6273 3120  0]*c_floor(abs1 
+00034f70: 2a20 696e 765f 6472 7068 6929 203c 206d  * inv_drphi) < m
+00034f80: 6172 6769 6e2a 7374 6570 5f72 7068 695b  argin*step_rphi[
+00034f90: 305d 3a0a 2020 2020 2020 2020 2020 2020  0]:.            
+00034fa0: 6e70 6869 3120 3d20 696e 7428 635f 726f  nphi1 = int(c_ro
+00034fb0: 756e 6428 286d 6178 5f70 6869 2b63 5f70  und((max_phi+c_p
+00034fc0: 6929 202a 2069 6e76 5f64 7270 6869 292d  i) * inv_drphi)-
+00034fd0: 3129 0a20 2020 2020 2020 2065 6c73 653a  1).        else:
+00034fe0: 0a20 2020 2020 2020 2020 2020 206e 7068  .            nph
+00034ff0: 6931 203d 2069 6e74 2863 5f66 6c6f 6f72  i1 = int(c_floor
+00035000: 2828 6d61 785f 7068 692b 635f 7069 2920  ((max_phi+c_pi) 
+00035010: 2a20 696e 765f 6472 7068 6929 290a 2020  * inv_drphi)).  
+00035020: 2020 2020 2020 737a 5f70 6869 5b30 5d20        sz_phi[0] 
+00035030: 3d20 6e70 6869 3120 2b20 3120 2d20 6e70  = nphi1 + 1 - np
+00035040: 6869 300a 2020 2020 2020 2020 6d61 785f  hi0.        max_
+00035050: 737a 5f70 6869 5b30 5d20 3d20 737a 5f70  sz_phi[0] = sz_p
+00035060: 6869 5b30 5d0a 2020 2020 2020 2020 696e  hi[0].        in
+00035070: 645f 6920 3d20 2d6e 702e 6f6e 6573 2828  d_i = -np.ones((
+00035080: 737a 5f72 2c20 737a 5f70 6869 5b30 5d20  sz_r, sz_phi[0] 
+00035090: 2a20 725f 7261 7469 6f20 2b20 3129 2c20  * r_ratio + 1), 
+000350a0: 6474 7970 653d 696e 7429 0a20 2020 2020  dtype=int).     
+000350b0: 2020 2069 6e64 695f 6d76 203d 2069 6e64     indi_mv = ind
+000350c0: 5f69 0a20 2020 2020 2020 2066 6f72 206a  _i.        for j
+000350d0: 6a20 696e 2072 616e 6765 2873 7a5f 7068  j in range(sz_ph
+000350e0: 695b 305d 293a 0a20 2020 2020 2020 2020  i[0]):.         
+000350f0: 2020 2069 6e64 695f 6d76 5b30 2c20 6a6a     indi_mv[0, jj
+00035100: 5d20 3d20 6e70 6869 3020 2b20 6a6a 0a20  ] = nphi0 + jj. 
+00035110: 2020 2020 2020 206e 7074 735f 6469 7363         npts_disc
+00035120: 202b 3d20 737a 5f7a 202a 2073 7a5f 7068   += sz_z * sz_ph
+00035130: 695b 305d 0a20 2020 2065 6c73 653a 0a20  i[0].    else:. 
+00035140: 2020 2020 2020 2023 2047 6574 2074 6865         # Get the
+00035150: 2061 6374 7561 6c20 5250 6869 2072 6573   actual RPhi res
+00035160: 6f6c 7574 696f 6e20 616e 6420 5068 6920  olution and Phi 
+00035170: 6d65 7368 2065 6c65 6d65 6e74 7320 2821  mesh elements (!
+00035180: 2064 6570 656e 6473 206f 6e20 5221 290a   depends on R!).
+00035190: 2020 2020 2020 2020 6e63 656c 6c73 5f72          ncells_r
+000351a0: 7068 695b 305d 203d 203c 696e 743e 635f  phi[0] = <int>c_
+000351b0: 6365 696c 2874 776f 7069 5f6f 7665 725f  ceil(twopi_over_
+000351c0: 6470 6869 202a 2064 6973 635f 725b 305d  dphi * disc_r[0]
+000351d0: 290a 2020 2020 2020 2020 6c6f 635f 6e63  ).        loc_nc
+000351e0: 5f72 7068 6920 3d20 6e63 656c 6c73 5f72  _rphi = ncells_r
+000351f0: 7068 695b 305d 0a20 2020 2020 2020 2073  phi[0].        s
+00035200: 7465 705f 7270 6869 5b30 5d20 3d20 5f54  tep_rphi[0] = _T
+00035210: 574f 5049 202f 206e 6365 6c6c 735f 7270  WOPI / ncells_rp
+00035220: 6869 5b30 5d0a 2020 2020 2020 2020 696e  hi[0].        in
+00035230: 765f 6472 7068 6920 3d20 312e 202f 2073  v_drphi = 1. / s
+00035240: 7465 705f 7270 6869 5b30 5d0a 2020 2020  tep_rphi[0].    
+00035250: 2020 2020 2320 4765 7420 696e 6465 7820      # Get index 
+00035260: 616e 6420 6375 6d75 6c61 7465 6420 696e  and cumulated in
+00035270: 6469 6365 7320 6672 6f6d 2062 6163 6b67  dices from backg
+00035280: 726f 756e 640a 2020 2020 2020 2020 666f  round.        fo
+00035290: 7220 6a6a 2069 6e20 7261 6e67 6528 696e  r jj in range(in
+000352a0: 645f 6c6f 635f 7230 2c20 6e63 656c 6c73  d_loc_r0, ncells
+000352b0: 5f72 305b 305d 293a 0a20 2020 2020 2020  _r0[0]):.       
+000352c0: 2020 2020 2069 6620 6469 7363 5f72 305b       if disc_r0[
+000352d0: 6a6a 5d3d 3d64 6973 635f 725b 305d 3a0a  jj]==disc_r[0]:.
+000352e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000352f0: 696e 645f 6c6f 635f 7230 203d 206a 6a0a  ind_loc_r0 = jj.
+00035300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00035310: 6272 6561 6b0a 2020 2020 2020 2020 2320  break.        # 
+00035320: 4765 7420 696e 6469 6365 7320 6f66 2070  Get indices of p
+00035330: 6869 0a20 2020 2020 2020 2023 2047 6574  hi.        # Get
+00035340: 2074 6865 2065 7874 7265 6d65 2069 6e64   the extreme ind
+00035350: 6963 6573 206f 6620 7468 6520 6d65 7368  ices of the mesh
+00035360: 2065 6c65 6d65 6e74 7320 7468 6174 2072   elements that r
+00035370: 6561 6c6c 7920 6e65 6564 2074 6f0a 2020  eally need to.  
+00035380: 2020 2020 2020 2320 6265 2063 7265 6174        # be creat
+00035390: 6564 2077 6974 6869 6e20 7468 6f73 6520  ed within those 
+000353a0: 6c69 6d69 7473 0a20 2020 2020 2020 2069  limits.        i
+000353b0: 6620 6162 7330 202d 2073 7465 705f 7270  f abs0 - step_rp
+000353c0: 6869 5b30 5d2a 635f 666c 6f6f 7228 6162  hi[0]*c_floor(ab
+000353d0: 7330 202a 2069 6e76 5f64 7270 6869 2920  s0 * inv_drphi) 
+000353e0: 3c20 6d61 7267 696e 2a73 7465 705f 7270  < margin*step_rp
+000353f0: 6869 5b30 5d3a 0a20 2020 2020 2020 2020  hi[0]:.         
+00035400: 2020 206e 7068 6930 203d 2069 6e74 2863     nphi0 = int(c
+00035410: 5f72 6f75 6e64 2828 6d69 6e5f 7068 6920  _round((min_phi 
+00035420: 2b20 635f 7069 2920 2a20 696e 765f 6472  + c_pi) * inv_dr
+00035430: 7068 6929 290a 2020 2020 2020 2020 656c  phi)).        el
+00035440: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00035450: 6e70 6869 3020 3d20 696e 7428 635f 666c  nphi0 = int(c_fl
+00035460: 6f6f 7228 286d 696e 5f70 6869 202b 2063  oor((min_phi + c
+00035470: 5f70 6929 202a 2069 6e76 5f64 7270 6869  _pi) * inv_drphi
+00035480: 2929 0a20 2020 2020 2020 2069 6620 6162  )).        if ab
+00035490: 7331 2d73 7465 705f 7270 6869 5b30 5d2a  s1-step_rphi[0]*
+000354a0: 635f 666c 6f6f 7228 6162 7331 202a 2069  c_floor(abs1 * i
+000354b0: 6e76 5f64 7270 6869 2920 3c20 6d61 7267  nv_drphi) < marg
+000354c0: 696e 2a73 7465 705f 7270 6869 5b30 5d3a  in*step_rphi[0]:
+000354d0: 0a20 2020 2020 2020 2020 2020 206e 7068  .            nph
+000354e0: 6931 203d 2069 6e74 2863 5f72 6f75 6e64  i1 = int(c_round
+000354f0: 2828 6d61 785f 7068 692b 635f 7069 2920  ((max_phi+c_pi) 
+00035500: 2a20 696e 765f 6472 7068 6929 2d31 290a  * inv_drphi)-1).
+00035510: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00035520: 2020 2020 2020 2020 2020 6e70 6869 3120            nphi1 
+00035530: 3d20 696e 7428 635f 666c 6f6f 7228 286d  = int(c_floor((m
+00035540: 6178 5f70 6869 2b63 5f70 6929 202a 2069  ax_phi+c_pi) * i
+00035550: 6e76 5f64 7270 6869 2929 0a20 2020 2020  nv_drphi)).     
+00035560: 2020 2073 7a5f 7068 695b 305d 203d 206e     sz_phi[0] = n
+00035570: 7068 6931 2b31 2b6c 6f63 5f6e 635f 7270  phi1+1+loc_nc_rp
+00035580: 6869 2d6e 7068 6930 0a20 2020 2020 2020  hi-nphi0.       
+00035590: 206d 6178 5f73 7a5f 7068 695b 305d 203d   max_sz_phi[0] =
+000355a0: 2073 7a5f 7068 695b 305d 0a20 2020 2020   sz_phi[0].     
+000355b0: 2020 2069 6e64 5f69 203d 202d 6e70 2e6f     ind_i = -np.o
+000355c0: 6e65 7328 2873 7a5f 722c 2073 7a5f 7068  nes((sz_r, sz_ph
+000355d0: 695b 305d 202a 2072 5f72 6174 696f 202b  i[0] * r_ratio +
+000355e0: 2031 292c 2064 7479 7065 3d69 6e74 290a   1), dtype=int).
+000355f0: 2020 2020 2020 2020 696e 6469 5f6d 7620          indi_mv 
+00035600: 3d20 696e 645f 690a 2020 2020 2020 2020  = ind_i.        
+00035610: 666f 7220 6a6a 2069 6e20 7261 6e67 6528  for jj in range(
+00035620: 6c6f 635f 6e63 5f72 7068 6920 2d20 6e70  loc_nc_rphi - np
+00035630: 6869 3029 3a0a 2020 2020 2020 2020 2020  hi0):.          
+00035640: 2020 696e 6469 5f6d 765b 302c 206a 6a5d    indi_mv[0, jj]
+00035650: 203d 206e 7068 6930 202b 206a 6a0a 2020   = nphi0 + jj.  
+00035660: 2020 2020 2020 666f 7220 6a6a 2069 6e20        for jj in 
+00035670: 7261 6e67 6528 6c6f 635f 6e63 5f72 7068  range(loc_nc_rph
+00035680: 6920 2d20 6e70 6869 302c 2073 7a5f 7068  i - nphi0, sz_ph
+00035690: 695b 305d 293a 0a20 2020 2020 2020 2020  i[0]):.         
+000356a0: 2020 2069 6e64 695f 6d76 5b30 2c20 6a6a     indi_mv[0, jj
+000356b0: 5d20 3d20 6a6a 202d 2028 6c6f 635f 6e63  ] = jj - (loc_nc
+000356c0: 5f72 7068 6920 2d20 6e70 6869 3029 0a20  _rphi - nphi0). 
+000356d0: 2020 2020 2020 206e 7074 735f 6469 7363         npts_disc
+000356e0: 202b 3d20 737a 5f7a 202a 2073 7a5f 7068   += sz_z * sz_ph
+000356f0: 695b 305d 0a20 2020 2023 202e 2e2e 2064  i[0].    # ... d
+00035700: 6f69 6e67 2074 6865 206f 7468 6572 7320  oing the others 
+00035710: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00035720: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 00035730: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00035740: 2e2e 2e2e 2e2e 2e2e 2e0a 2020 2020 6e70  ..........    np
-00035750: 7473 5f64 6973 6320 2b3d 205f 7374 2e73  ts_disc += _st.s
-00035760: 615f 6469 7363 5f70 6869 2873 7a5f 722c  a_disc_phi(sz_r,
-00035770: 2073 7a5f 7a2c 206e 6365 6c6c 735f 7270   sz_z, ncells_rp
-00035780: 6869 2c20 7068 6973 7465 702c 0a20 2020  hi, phistep,.   
+00035740: 2e2e 2e2e 2e0a 2020 2020 6e70 7473 5f64  ......    npts_d
+00035750: 6973 6320 2b3d 205f 7374 2e73 615f 6469  isc += _st.sa_di
+00035760: 7363 5f70 6869 2873 7a5f 722c 2073 7a5f  sc_phi(sz_r, sz_
+00035770: 7a2c 206e 6365 6c6c 735f 7270 6869 2c20  z, ncells_rphi, 
+00035780: 7068 6973 7465 702c 0a20 2020 2020 2020  phistep,.       
 00035790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000357a0: 2020 2020 2020 2020 2020 2020 2020 6469                di
-000357b0: 7363 5f72 2c20 6469 7363 5f72 302c 2073  sc_r, disc_r0, s
-000357c0: 7465 705f 7270 6869 2c0a 2020 2020 2020  tep_rphi,.      
+000357a0: 2020 2020 2020 2020 2020 6469 7363 5f72            disc_r
+000357b0: 2c20 6469 7363 5f72 302c 2073 7465 705f  , disc_r0, step_
+000357c0: 7270 6869 2c0a 2020 2020 2020 2020 2020  rphi,.          
 000357d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000357e0: 2020 2020 2020 2020 2020 2069 6e64 5f6c             ind_l
-000357f0: 6f63 5f72 302c 0a20 2020 2020 2020 2020  oc_r0,.         
+000357e0: 2020 2020 2020 2069 6e64 5f6c 6f63 5f72         ind_loc_r
+000357f0: 302c 0a20 2020 2020 2020 2020 2020 2020  0,.             
 00035800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035810: 2020 2020 2020 2020 6e63 656c 6c73 5f72          ncells_r
-00035820: 305b 305d 2c20 6e63 656c 6c73 5f7a 5b30  0[0], ncells_z[0
-00035830: 5d2c 2026 6d61 785f 737a 5f70 6869 5b30  ], &max_sz_phi[0
-00035840: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00035810: 2020 2020 6e63 656c 6c73 5f72 305b 305d      ncells_r0[0]
+00035820: 2c20 6e63 656c 6c73 5f7a 5b30 5d2c 2026  , ncells_z[0], &
+00035830: 6d61 785f 737a 5f70 6869 5b30 5d2c 0a20  max_sz_phi[0],. 
+00035840: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00035850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035860: 2020 2020 6d69 6e5f 7068 692c 206d 6178      min_phi, max
-00035870: 5f70 6869 2c20 737a 5f70 6869 2c20 696e  _phi, sz_phi, in
-00035880: 6469 5f6d 762c 0a20 2020 2020 2020 2020  di_mv,.         
+00035860: 6d69 6e5f 7068 692c 206d 6178 5f70 6869  min_phi, max_phi
+00035870: 2c20 737a 5f70 6869 2c20 696e 6469 5f6d  , sz_phi, indi_m
+00035880: 762c 0a20 2020 2020 2020 2020 2020 2020  v,.             
 00035890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000358a0: 2020 2020 2020 2020 6d61 7267 696e 2c20          margin, 
-000358b0: 6e75 6d5f 7468 7265 6164 7329 0a20 2020  num_threads).   
-000358c0: 2023 202e 2e2e 2076 6967 6e65 7474 696e   # ... vignettin
-000358d0: 6720 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  g ..............
+000358a0: 2020 2020 6d61 7267 696e 2c20 6e75 6d5f      margin, num_
+000358b0: 7468 7265 6164 7329 0a20 2020 2023 202e  threads).    # .
+000358c0: 2e2e 2076 6967 6e65 7474 696e 6720 2e2e  .. vignetting ..
+000358d0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 000358e0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 000358f0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00035900: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a 2020  ..............  
-00035910: 2020 6973 5f69 6e5f 7669 676e 6574 7465    is_in_vignette
-00035920: 203d 206e 702e 6f6e 6573 2828 737a 5f72   = np.ones((sz_r
-00035930: 2c20 737a 5f7a 292c 2064 7479 7065 3d69  , sz_z), dtype=i
-00035940: 6e74 2920 2320 6279 2064 6566 6175 6c74  nt) # by default
-00035950: 2079 6573 0a20 2020 2069 6620 6c69 6d69   yes.    if limi
-00035960: 745f 7670 6f6c 7920 6973 206e 6f74 204e  t_vpoly is not N
-00035970: 6f6e 653a 0a20 2020 2020 2020 206e 7074  one:.        npt
-00035980: 735f 7670 6f6c 7920 3d20 6c69 6d69 745f  s_vpoly = limit_
-00035990: 7670 6f6c 792e 7368 6170 655b 315d 202d  vpoly.shape[1] -
-000359a0: 2031 0a20 2020 2020 2020 2023 2077 6520   1.        # we 
-000359b0: 6d61 6b65 2073 7572 6520 6974 2069 7320  make sure it is 
-000359c0: 636c 6f73 6564 0a20 2020 2020 2020 2069  closed.        i
-000359d0: 6620 6e6f 7428 6162 7328 6c69 6d69 745f  f not(abs(limit_
-000359e0: 7670 6f6c 795b 302c 2030 5d20 2d20 6c69  vpoly[0, 0] - li
-000359f0: 6d69 745f 7670 6f6c 795b 302c 206e 7074  mit_vpoly[0, npt
-00035a00: 735f 7670 6f6c 795d 2920 3c20 5f56 534d  s_vpoly]) < _VSM
-00035a10: 414c 4c0a 2020 2020 2020 2020 2020 2020  ALL.            
-00035a20: 2020 2020 616e 6420 6162 7328 6c69 6d69      and abs(limi
-00035a30: 745f 7670 6f6c 795b 312c 2030 5d0a 2020  t_vpoly[1, 0].  
+00035900: 2e2e 2e2e 2e2e 2e2e 2e0a 2020 2020 6973  ..........    is
+00035910: 5f69 6e5f 7669 676e 6574 7465 203d 206e  _in_vignette = n
+00035920: 702e 6f6e 6573 2828 737a 5f72 2c20 737a  p.ones((sz_r, sz
+00035930: 5f7a 292c 2064 7479 7065 3d69 6e74 2920  _z), dtype=int) 
+00035940: 2320 6279 2064 6566 6175 6c74 2079 6573  # by default yes
+00035950: 0a20 2020 2069 6620 6c69 6d69 745f 7670  .    if limit_vp
+00035960: 6f6c 7920 6973 206e 6f74 204e 6f6e 653a  oly is not None:
+00035970: 0a20 2020 2020 2020 206e 7074 735f 7670  .        npts_vp
+00035980: 6f6c 7920 3d20 6c69 6d69 745f 7670 6f6c  oly = limit_vpol
+00035990: 792e 7368 6170 655b 315d 202d 2031 0a20  y.shape[1] - 1. 
+000359a0: 2020 2020 2020 2023 2077 6520 6d61 6b65         # we make
+000359b0: 2073 7572 6520 6974 2069 7320 636c 6f73   sure it is clos
+000359c0: 6564 0a20 2020 2020 2020 2069 6620 6e6f  ed.        if no
+000359d0: 7428 6162 7328 6c69 6d69 745f 7670 6f6c  t(abs(limit_vpol
+000359e0: 795b 302c 2030 5d20 2d20 6c69 6d69 745f  y[0, 0] - limit_
+000359f0: 7670 6f6c 795b 302c 206e 7074 735f 7670  vpoly[0, npts_vp
+00035a00: 6f6c 795d 2920 3c20 5f56 534d 414c 4c0a  oly]) < _VSMALL.
+00035a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00035a20: 616e 6420 6162 7328 6c69 6d69 745f 7670  and abs(limit_vp
+00035a30: 6f6c 795b 312c 2030 5d0a 2020 2020 2020  oly[1, 0].      
 00035a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035a50: 2020 2020 2020 2d20 6c69 6d69 745f 7670        - limit_vp
-00035a60: 6f6c 795b 312c 206e 7074 735f 7670 6f6c  oly[1, npts_vpol
-00035a70: 795d 2920 3c20 5f56 534d 414c 4c29 3a0a  y]) < _VSMALL):.
-00035a80: 2020 2020 2020 2020 2020 2020 706f 6c79              poly
-00035a90: 5f6d 7620 3d20 6e70 2e63 6f6e 6361 7465  _mv = np.concate
-00035aa0: 6e61 7465 2828 6c69 6d69 745f 7670 6f6c  nate((limit_vpol
-00035ab0: 792c 206c 696d 6974 5f76 706f 6c79 5b3a  y, limit_vpoly[:
-00035ac0: 2c30 3a31 5d29 2c20 6178 6973 3d31 290a  ,0:1]), axis=1).
-00035ad0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00035ae0: 2020 2020 2020 2020 2020 706f 6c79 5f6d            poly_m
-00035af0: 7620 3d20 6c69 6d69 745f 7670 6f6c 790a  v = limit_vpoly.
-00035b00: 2020 2020 2020 2020 5f20 3d20 5f76 742e          _ = _vt.
-00035b10: 6172 655f 696e 5f76 6967 6e65 7474 6528  are_in_vignette(
-00035b20: 737a 5f72 2c20 737a 5f7a 2c0a 2020 2020  sz_r, sz_z,.    
+00035a50: 2020 2d20 6c69 6d69 745f 7670 6f6c 795b    - limit_vpoly[
+00035a60: 312c 206e 7074 735f 7670 6f6c 795d 2920  1, npts_vpoly]) 
+00035a70: 3c20 5f56 534d 414c 4c29 3a0a 2020 2020  < _VSMALL):.    
+00035a80: 2020 2020 2020 2020 706f 6c79 5f6d 7620          poly_mv 
+00035a90: 3d20 6e70 2e63 6f6e 6361 7465 6e61 7465  = np.concatenate
+00035aa0: 2828 6c69 6d69 745f 7670 6f6c 792c 206c  ((limit_vpoly, l
+00035ab0: 696d 6974 5f76 706f 6c79 5b3a 2c30 3a31  imit_vpoly[:,0:1
+00035ac0: 5d29 2c20 6178 6973 3d31 290a 2020 2020  ]), axis=1).    
+00035ad0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00035ae0: 2020 2020 2020 706f 6c79 5f6d 7620 3d20        poly_mv = 
+00035af0: 6c69 6d69 745f 7670 6f6c 790a 2020 2020  limit_vpoly.    
+00035b00: 2020 2020 5f20 3d20 5f76 742e 6172 655f      _ = _vt.are_
+00035b10: 696e 5f76 6967 6e65 7474 6528 737a 5f72  in_vignette(sz_r
+00035b20: 2c20 737a 5f7a 2c0a 2020 2020 2020 2020  , sz_z,.        
 00035b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035b40: 2020 2020 2020 2020 2020 2020 706f 6c79              poly
-00035b50: 5f6d 762c 206e 7074 735f 7670 6f6c 792c  _mv, npts_vpoly,
-00035b60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00035b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035b80: 2064 6973 635f 722c 2064 6973 635f 7a2c   disc_r, disc_z,
-00035b90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00035ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035bb0: 2069 735f 696e 5f76 6967 6e65 7474 6529   is_in_vignette)
-00035bc0: 0a20 2020 2023 202e 2e20 7072 6570 6172  .    # .. prepar
-00035bd0: 696e 6720 666f 7220 6163 7475 616c 2064  ing for actual d
-00035be0: 6973 6372 6574 697a 6174 696f 6e20 2e2e  iscretization ..
+00035b40: 2020 2020 2020 2020 706f 6c79 5f6d 762c          poly_mv,
+00035b50: 206e 7074 735f 7670 6f6c 792c 0a20 2020   npts_vpoly,.   
+00035b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00035b70: 2020 2020 2020 2020 2020 2020 2064 6973               dis
+00035b80: 635f 722c 2064 6973 635f 7a2c 0a20 2020  c_r, disc_z,.   
+00035b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00035ba0: 2020 2020 2020 2020 2020 2020 2069 735f               is_
+00035bb0: 696e 5f76 6967 6e65 7474 6529 0a20 2020  in_vignette).   
+00035bc0: 2023 202e 2e20 7072 6570 6172 696e 6720   # .. preparing 
+00035bd0: 666f 7220 6163 7475 616c 2064 6973 6372  for actual discr
+00035be0: 6574 697a 6174 696f 6e20 2e2e 2e2e 2e2e  etization ......
 00035bf0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00035c00: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-00035c10: 2e0a 2020 2020 696e 645f 727a 3270 6f6c  ..    ind_rz2pol
-00035c20: 203d 206e 702e 656d 7074 7928 2873 7a5f   = np.empty((sz_
-00035c30: 722c 2073 7a5f 7a29 2c20 6474 7970 653d  r, sz_z), dtype=
-00035c40: 696e 7429 0a20 2020 206e 7074 735f 706f  int).    npts_po
-00035c50: 6c20 3d20 5f73 742e 7361 5f67 6574 5f69  l = _st.sa_get_i
-00035c60: 6e64 6578 5f61 7272 6179 7328 696e 645f  ndex_arrays(ind_
-00035c70: 727a 3270 6f6c 2c0a 2020 2020 2020 2020  rz2pol,.        
+00035c00: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a 2020  ..............  
+00035c10: 2020 696e 645f 727a 3270 6f6c 203d 206e    ind_rz2pol = n
+00035c20: 702e 656d 7074 7928 2873 7a5f 722c 2073  p.empty((sz_r, s
+00035c30: 7a5f 7a29 2c20 6474 7970 653d 696e 7429  z_z), dtype=int)
+00035c40: 0a20 2020 206e 7074 735f 706f 6c20 3d20  .    npts_pol = 
+00035c50: 5f73 742e 7361 5f67 6574 5f69 6e64 6578  _st.sa_get_index
+00035c60: 5f61 7272 6179 7328 696e 645f 727a 3270  _arrays(ind_rz2p
+00035c70: 6f6c 2c0a 2020 2020 2020 2020 2020 2020  ol,.            
 00035c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035c90: 2020 2020 2020 2020 2020 2020 2069 735f               is_
-00035ca0: 696e 5f76 6967 6e65 7474 652c 0a20 2020  in_vignette,.   
+00035c90: 2020 2020 2020 2020 2069 735f 696e 5f76           is_in_v
+00035ca0: 6967 6e65 7474 652c 0a20 2020 2020 2020  ignette,.       
 00035cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035cd0: 2020 737a 5f72 2c20 737a 5f7a 290a 2020    sz_r, sz_z).  
-00035ce0: 2020 2320 696e 6974 6961 6c69 7a69 6e67    # initializing
-00035cf0: 2061 7272 6179 730a 2020 2020 7265 736f   arrays.    reso
-00035d00: 5f72 6472 647a 203d 206e 702e 656d 7074  _rdrdz = np.empt
-00035d10: 7928 286e 7074 735f 706f 6c2c 2029 290a  y((npts_pol, )).
-00035d20: 2020 2020 7361 5f6d 6170 203d 206e 702e      sa_map = np.
-00035d30: 7a65 726f 7328 286e 7074 735f 706f 6c2c  zeros((npts_pol,
-00035d40: 2073 7a5f 7029 290a 2020 2020 7074 7320   sz_p)).    pts 
-00035d50: 3d20 6e70 2e65 6d70 7479 2828 322c 206e  = np.empty((2, n
-00035d60: 7074 735f 706f 6c29 290a 2020 2020 696e  pts_pol)).    in
-00035d70: 6420 3d20 2d6e 702e 6f6e 6573 2828 6e70  d = -np.ones((np
-00035d80: 7473 5f70 6f6c 2c20 292c 2064 7479 7065  ts_pol, ), dtype
-00035d90: 3d69 6e74 290a 2020 2020 7074 735f 6d76  =int).    pts_mv
-00035da0: 203d 2070 7473 0a20 2020 2069 6e64 5f6d   = pts.    ind_m
-00035db0: 7620 3d20 696e 640a 2020 2020 7265 736f  v = ind.    reso
-00035dc0: 5f72 6472 647a 5f6d 7620 3d20 7265 736f  _rdrdz_mv = reso
-00035dd0: 5f72 6472 647a 0a20 2020 2072 6573 6f5f  _rdrdz.    reso_
-00035de0: 725f 7a20 3d20 7265 736f 5f72 5b30 5d2a  r_z = reso_r[0]*
-00035df0: 7265 736f 5f7a 5b30 5d0a 2020 2020 696e  reso_z[0].    in
-00035e00: 645f 6920 3d20 6e70 2e73 6f72 7428 696e  d_i = np.sort(in
-00035e10: 645f 692c 2061 7869 733d 3129 0a20 2020  d_i, axis=1).   
-00035e20: 2069 6e64 695f 6d76 203d 2069 6e64 5f69   indi_mv = ind_i
-00035e30: 0a20 2020 2066 6972 7374 5f69 6e64 5f6d  .    first_ind_m
-00035e40: 7620 3d20 6e70 2e61 7267 6d61 7828 696e  v = np.argmax(in
-00035e50: 645f 6920 3e20 2d31 2c20 6178 6973 3d31  d_i > -1, axis=1
-00035e60: 292e 6173 7479 7065 2869 6e74 290a 2020  ).astype(int).  
-00035e70: 2020 2320 696e 6974 6961 6c69 7a69 6e67    # initializing
-00035e80: 2075 7469 6c69 7461 7279 2061 7272 6179   utilitary array
-00035e90: 730a 2020 2020 6e75 6d5f 7468 7265 6164  s.    num_thread
-00035ea0: 7320 3d20 5f6f 6d70 742e 6765 745f 6566  s = _ompt.get_ef
-00035eb0: 6665 6374 6976 655f 6e75 6d5f 7468 7265  fective_num_thre
-00035ec0: 6164 7328 6e75 6d5f 7468 7265 6164 7329  ads(num_threads)
-00035ed0: 0a20 2020 206c 7374 7275 6374 5f6c 696d  .    lstruct_lim
-00035ee0: 735f 6e70 203d 2066 6c61 7474 656e 5f6c  s_np = flatten_l
-00035ef0: 7374 7275 6374 5f6c 696d 7328 6c73 7472  struct_lims(lstr
-00035f00: 7563 745f 6c69 6d73 290a 2020 2020 2320  uct_lims).    # 
-00035f10: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 0a20  ............... 
-00035f20: 2020 205f 7374 2e73 615f 6173 7365 6d62     _st.sa_assemb
-00035f30: 6c65 5f61 7272 6179 7328 626c 6f63 6b2c  le_arrays(block,
-00035f40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00035f50: 2020 2020 2020 2020 2020 2020 6170 7072              appr
-00035f60: 6f78 2c0a 2020 2020 2020 2020 2020 2020  ox,.            
-00035f70: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00035f80: 6172 745f 636f 6f72 6473 2c0a 2020 2020  art_coords,.    
+00035cc0: 2020 2020 2020 2020 2020 2020 2020 737a                sz
+00035cd0: 5f72 2c20 737a 5f7a 290a 2020 2020 2320  _r, sz_z).    # 
+00035ce0: 696e 6974 6961 6c69 7a69 6e67 2061 7272  initializing arr
+00035cf0: 6179 730a 2020 2020 7265 736f 5f72 6472  ays.    reso_rdr
+00035d00: 647a 203d 206e 702e 656d 7074 7928 286e  dz = np.empty((n
+00035d10: 7074 735f 706f 6c2c 2029 290a 2020 2020  pts_pol, )).    
+00035d20: 7361 5f6d 6170 203d 206e 702e 7a65 726f  sa_map = np.zero
+00035d30: 7328 286e 7074 735f 706f 6c2c 2073 7a5f  s((npts_pol, sz_
+00035d40: 7029 290a 2020 2020 7074 7320 3d20 6e70  p)).    pts = np
+00035d50: 2e65 6d70 7479 2828 322c 206e 7074 735f  .empty((2, npts_
+00035d60: 706f 6c29 290a 2020 2020 696e 6420 3d20  pol)).    ind = 
+00035d70: 2d6e 702e 6f6e 6573 2828 6e70 7473 5f70  -np.ones((npts_p
+00035d80: 6f6c 2c20 292c 2064 7479 7065 3d69 6e74  ol, ), dtype=int
+00035d90: 290a 2020 2020 7074 735f 6d76 203d 2070  ).    pts_mv = p
+00035da0: 7473 0a20 2020 2069 6e64 5f6d 7620 3d20  ts.    ind_mv = 
+00035db0: 696e 640a 2020 2020 7265 736f 5f72 6472  ind.    reso_rdr
+00035dc0: 647a 5f6d 7620 3d20 7265 736f 5f72 6472  dz_mv = reso_rdr
+00035dd0: 647a 0a20 2020 2072 6573 6f5f 725f 7a20  dz.    reso_r_z 
+00035de0: 3d20 7265 736f 5f72 5b30 5d2a 7265 736f  = reso_r[0]*reso
+00035df0: 5f7a 5b30 5d0a 2020 2020 696e 645f 6920  _z[0].    ind_i 
+00035e00: 3d20 6e70 2e73 6f72 7428 696e 645f 692c  = np.sort(ind_i,
+00035e10: 2061 7869 733d 3129 0a20 2020 2069 6e64   axis=1).    ind
+00035e20: 695f 6d76 203d 2069 6e64 5f69 0a20 2020  i_mv = ind_i.   
+00035e30: 2066 6972 7374 5f69 6e64 5f6d 7620 3d20   first_ind_mv = 
+00035e40: 6e70 2e61 7267 6d61 7828 696e 645f 6920  np.argmax(ind_i 
+00035e50: 3e20 2d31 2c20 6178 6973 3d31 292e 6173  > -1, axis=1).as
+00035e60: 7479 7065 2869 6e74 290a 2020 2020 2320  type(int).    # 
+00035e70: 696e 6974 6961 6c69 7a69 6e67 2075 7469  initializing uti
+00035e80: 6c69 7461 7279 2061 7272 6179 730a 2020  litary arrays.  
+00035e90: 2020 6e75 6d5f 7468 7265 6164 7320 3d20    num_threads = 
+00035ea0: 5f6f 6d70 742e 6765 745f 6566 6665 6374  _ompt.get_effect
+00035eb0: 6976 655f 6e75 6d5f 7468 7265 6164 7328  ive_num_threads(
+00035ec0: 6e75 6d5f 7468 7265 6164 7329 0a20 2020  num_threads).   
+00035ed0: 206c 7374 7275 6374 5f6c 696d 735f 6e70   lstruct_lims_np
+00035ee0: 203d 2066 6c61 7474 656e 5f6c 7374 7275   = flatten_lstru
+00035ef0: 6374 5f6c 696d 7328 6c73 7472 7563 745f  ct_lims(lstruct_
+00035f00: 6c69 6d73 290a 2020 2020 2320 2e2e 2e2e  lims).    # ....
+00035f10: 2e2e 2e2e 2e2e 2e2e 2e2e 0a20 2020 205f  ...........    _
+00035f20: 7374 2e73 615f 6173 7365 6d62 6c65 5f61  st.sa_assemble_a
+00035f30: 7272 6179 7328 626c 6f63 6b2c 0a20 2020  rrays(block,.   
+00035f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00035f50: 2020 2020 2020 2020 6170 7072 6f78 2c0a          approx,.
+00035f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00035f70: 2020 2020 2020 2020 2020 2070 6172 745f             part_
+00035f80: 636f 6f72 6473 2c0a 2020 2020 2020 2020  coords,.        
 00035f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035fa0: 2020 2020 2020 2070 6172 745f 722c 0a20         part_r,. 
+00035fa0: 2020 2070 6172 745f 722c 0a20 2020 2020     part_r,.     
 00035fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035fc0: 2020 2020 2020 2020 2020 6973 5f69 6e5f            is_in_
-00035fd0: 7669 676e 6574 7465 2c0a 2020 2020 2020  vignette,.      
+00035fc0: 2020 2020 2020 6973 5f69 6e5f 7669 676e        is_in_vign
+00035fd0: 6574 7465 2c0a 2020 2020 2020 2020 2020  ette,.          
 00035fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00035ff0: 2020 2020 2073 615f 6d61 702c 0a20 2020       sa_map,.   
+00035ff0: 2073 615f 6d61 702c 0a20 2020 2020 2020   sa_map,.       
 00036000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036010: 2020 2020 2020 2020 7665 735f 706f 6c79          ves_poly
-00036020: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00036030: 2020 2020 2020 2020 2020 2020 2076 6573               ves
-00036040: 5f6e 6f72 6d2c 0a20 2020 2020 2020 2020  _norm,.         
-00036050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036060: 2020 7665 735f 6c69 6d73 2c0a 2020 2020    ves_lims,.    
+00036010: 2020 2020 7665 735f 706f 6c79 2c0a 2020      ves_poly,.  
+00036020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036030: 2020 2020 2020 2020 2076 6573 5f6e 6f72           ves_nor
+00036040: 6d2c 0a20 2020 2020 2020 2020 2020 2020  m,.             
+00036050: 2020 2020 2020 2020 2020 2020 2020 7665                ve
+00036060: 735f 6c69 6d73 2c0a 2020 2020 2020 2020  s_lims,.        
 00036070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036080: 2020 2020 2020 206c 7374 7275 6374 5f6e         lstruct_n
-00036090: 6c69 6d2c 0a20 2020 2020 2020 2020 2020  lim,.           
-000360a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000360b0: 6c73 7472 7563 745f 706f 6c79 782c 0a20  lstruct_polyx,. 
+00036080: 2020 206c 7374 7275 6374 5f6e 6c69 6d2c     lstruct_nlim,
+00036090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000360a0: 2020 2020 2020 2020 2020 2020 6c73 7472              lstr
+000360b0: 7563 745f 706f 6c79 782c 0a20 2020 2020  uct_polyx,.     
 000360c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000360d0: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
-000360e0: 745f 706f 6c79 792c 0a20 2020 2020 2020  t_polyy,.       
+000360d0: 2020 2020 2020 6c73 7472 7563 745f 706f        lstruct_po
+000360e0: 6c79 792c 0a20 2020 2020 2020 2020 2020  lyy,.           
 000360f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036100: 2020 2020 6c73 7472 7563 745f 6c69 6d73      lstruct_lims
-00036110: 5f6e 702c 0a20 2020 2020 2020 2020 2020  _np,.           
-00036120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036130: 6c73 7472 7563 745f 6e6f 726d 782c 0a20  lstruct_normx,. 
+00036100: 6c73 7472 7563 745f 6c69 6d73 5f6e 702c  lstruct_lims_np,
+00036110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00036120: 2020 2020 2020 2020 2020 2020 6c73 7472              lstr
+00036130: 7563 745f 6e6f 726d 782c 0a20 2020 2020  uct_normx,.     
 00036140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036150: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
-00036160: 745f 6e6f 726d 792c 0a20 2020 2020 2020  t_normy,.       
+00036150: 2020 2020 2020 6c73 7472 7563 745f 6e6f        lstruct_no
+00036160: 726d 792c 0a20 2020 2020 2020 2020 2020  rmy,.           
 00036170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036180: 2020 2020 6c6e 7665 7274 2c0a 2020 2020      lnvert,.    
+00036180: 6c6e 7665 7274 2c0a 2020 2020 2020 2020  lnvert,.        
 00036190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000361a0: 2020 2020 2020 206e 7374 7275 6374 5f74         nstruct_t
-000361b0: 6f74 2c0a 2020 2020 2020 2020 2020 2020  ot,.            
-000361c0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-000361d0: 7374 7275 6374 5f6c 696d 2c0a 2020 2020  struct_lim,.    
+000361a0: 2020 206e 7374 7275 6374 5f74 6f74 2c0a     nstruct_tot,.
+000361b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000361c0: 2020 2020 2020 2020 2020 206e 7374 7275             nstru
+000361d0: 6374 5f6c 696d 2c0a 2020 2020 2020 2020  ct_lim,.        
 000361e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000361f0: 2020 2020 2020 2072 6d69 6e2c 0a20 2020         rmin,.   
+000361f0: 2020 2072 6d69 6e2c 0a20 2020 2020 2020     rmin,.       
 00036200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036210: 2020 2020 2020 2020 6570 735f 757a 2c20          eps_uz, 
-00036220: 6570 735f 612c 0a20 2020 2020 2020 2020  eps_a,.         
-00036230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036240: 2020 6570 735f 767a 2c20 6570 735f 622c    eps_vz, eps_b,
-00036250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00036260: 2020 2020 2020 2020 2020 2020 6570 735f              eps_
-00036270: 706c 616e 652c 0a20 2020 2020 2020 2020  plane,.         
-00036280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036290: 2020 666f 7262 6964 2c0a 2020 2020 2020    forbid,.      
+00036210: 2020 2020 6570 735f 757a 2c20 6570 735f      eps_uz, eps_
+00036220: 612c 0a20 2020 2020 2020 2020 2020 2020  a,.             
+00036230: 2020 2020 2020 2020 2020 2020 2020 6570                ep
+00036240: 735f 767a 2c20 6570 735f 622c 0a20 2020  s_vz, eps_b,.   
+00036250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036260: 2020 2020 2020 2020 6570 735f 706c 616e          eps_plan
+00036270: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+00036280: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00036290: 7262 6964 2c0a 2020 2020 2020 2020 2020  rbid,.          
 000362a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000362b0: 2020 2020 2066 6972 7374 5f69 6e64 5f6d       first_ind_m
-000362c0: 762c 0a20 2020 2020 2020 2020 2020 2020  v,.             
-000362d0: 2020 2020 2020 2020 2020 2020 2020 696e                in
-000362e0: 6469 5f6d 762c 0a20 2020 2020 2020 2020  di_mv,.         
-000362f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036300: 2020 737a 5f70 2c20 737a 5f72 2c20 737a    sz_p, sz_r, sz
-00036310: 5f7a 2c0a 2020 2020 2020 2020 2020 2020  _z,.            
-00036320: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00036330: 6365 6c6c 735f 7270 6869 2c0a 2020 2020  cells_rphi,.    
+000362b0: 2066 6972 7374 5f69 6e64 5f6d 762c 0a20   first_ind_mv,. 
+000362c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000362d0: 2020 2020 2020 2020 2020 696e 6469 5f6d            indi_m
+000362e0: 762c 0a20 2020 2020 2020 2020 2020 2020  v,.             
+000362f0: 2020 2020 2020 2020 2020 2020 2020 737a                sz
+00036300: 5f70 2c20 737a 5f72 2c20 737a 5f7a 2c0a  _p, sz_r, sz_z,.
+00036310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036320: 2020 2020 2020 2020 2020 206e 6365 6c6c             ncell
+00036330: 735f 7270 6869 2c0a 2020 2020 2020 2020  s_rphi,.        
 00036340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036350: 2020 2020 2020 2072 6573 6f5f 725f 7a2c         reso_r_z,
-00036360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00036370: 2020 2020 2020 2020 2020 2020 6469 7363              disc
-00036380: 5f72 2c0a 2020 2020 2020 2020 2020 2020  _r,.            
-00036390: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000363a0: 7465 705f 7270 6869 2c0a 2020 2020 2020  tep_rphi,.      
+00036350: 2020 2072 6573 6f5f 725f 7a2c 0a20 2020     reso_r_z,.   
+00036360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036370: 2020 2020 2020 2020 6469 7363 5f72 2c0a          disc_r,.
+00036380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036390: 2020 2020 2020 2020 2020 2073 7465 705f             step_
+000363a0: 7270 6869 2c0a 2020 2020 2020 2020 2020  rphi,.          
 000363b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000363c0: 2020 2020 2064 6973 635f 7a2c 0a20 2020       disc_z,.   
+000363c0: 2064 6973 635f 7a2c 0a20 2020 2020 2020   disc_z,.       
 000363d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000363e0: 2020 2020 2020 2020 696e 645f 727a 3270          ind_rz2p
-000363f0: 6f6c 2c0a 2020 2020 2020 2020 2020 2020  ol,.            
-00036400: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00036410: 7a5f 7068 692c 0a20 2020 2020 2020 2020  z_phi,.         
-00036420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036430: 2020 7265 736f 5f72 6472 647a 5f6d 762c    reso_rdrdz_mv,
-00036440: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00036450: 2020 2020 2020 2020 2020 2020 7074 735f              pts_
-00036460: 6d76 2c0a 2020 2020 2020 2020 2020 2020  mv,.            
-00036470: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00036480: 6e64 5f6d 762c 0a20 2020 2020 2020 2020  nd_mv,.         
-00036490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000364a0: 2020 6e75 6d5f 7468 7265 6164 7329 0a20    num_threads). 
-000364b0: 2020 2023 202e 2e2e 2066 7265 6569 6e67     # ... freeing
-000364c0: 2075 7020 6d65 6d6f 7279 202e 2e2e 2e2e   up memory .....
+000363e0: 2020 2020 696e 645f 727a 3270 6f6c 2c0a      ind_rz2pol,.
+000363f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036400: 2020 2020 2020 2020 2020 2073 7a5f 7068             sz_ph
+00036410: 692c 0a20 2020 2020 2020 2020 2020 2020  i,.             
+00036420: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00036430: 736f 5f72 6472 647a 5f6d 762c 0a20 2020  so_rdrdz_mv,.   
+00036440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036450: 2020 2020 2020 2020 7074 735f 6d76 2c0a          pts_mv,.
+00036460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00036470: 2020 2020 2020 2020 2020 2069 6e64 5f6d             ind_m
+00036480: 762c 0a20 2020 2020 2020 2020 2020 2020  v,.             
+00036490: 2020 2020 2020 2020 2020 2020 2020 6e75                nu
+000364a0: 6d5f 7468 7265 6164 7329 0a20 2020 2023  m_threads).    #
+000364b0: 202e 2e2e 2066 7265 6569 6e67 2075 7020   ... freeing up 
+000364c0: 6d65 6d6f 7279 202e 2e2e 2e2e 2e2e 2e2e  memory .........
 000364d0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
 000364e0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e  ................
-000364f0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a  ................
-00036500: 2020 2020 6672 6565 286c 696e 6465 785f      free(lindex_
-00036510: 7a29 0a20 2020 2066 7265 6528 6469 7363  z).    free(disc
-00036520: 5f72 290a 2020 2020 6672 6565 2864 6973  _r).    free(dis
-00036530: 635f 7a29 0a20 2020 2066 7265 6528 6469  c_z).    free(di
-00036540: 7363 5f72 3029 0a20 2020 2066 7265 6528  sc_r0).    free(
-00036550: 737a 5f70 6869 290a 2020 2020 6672 6565  sz_phi).    free
-00036560: 2873 7465 705f 7270 6869 290a 2020 2020  (step_rphi).    
-00036570: 6672 6565 286e 6365 6c6c 735f 7270 6869  free(ncells_rphi
-00036580: 290a 0a20 2020 2072 6574 7572 6e20 7074  )..    return pt
-00036590: 732c 2073 615f 6d61 702c 2069 6e64 2c20  s, sa_map, ind, 
-000365a0: 7265 736f 5f72 5f7a 0a0a 0a23 203d 3d3d  reso_r_z...# ===
+000364f0: 2e2e 2e2e 2e2e 2e2e 2e2e 2e0a 2020 2020  ............    
+00036500: 6672 6565 286c 696e 6465 785f 7a29 0a20  free(lindex_z). 
+00036510: 2020 2066 7265 6528 6469 7363 5f72 290a     free(disc_r).
+00036520: 2020 2020 6672 6565 2864 6973 635f 7a29      free(disc_z)
+00036530: 0a20 2020 2066 7265 6528 6469 7363 5f72  .    free(disc_r
+00036540: 3029 0a20 2020 2066 7265 6528 737a 5f70  0).    free(sz_p
+00036550: 6869 290a 2020 2020 6672 6565 2873 7465  hi).    free(ste
+00036560: 705f 7270 6869 290a 2020 2020 6672 6565  p_rphi).    free
+00036570: 286e 6365 6c6c 735f 7270 6869 290a 0a20  (ncells_rphi).. 
+00036580: 2020 2072 6574 7572 6e20 7074 732c 2073     return pts, s
+00036590: 615f 6d61 702c 2069 6e64 2c20 7265 736f  a_map, ind, reso
+000365a0: 5f72 5f7a 0a0a 0a23 203d 3d3d 3d3d 3d3d  _r_z...# =======
 000365b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000365c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000365d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000365e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000365f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 230a 2320  ===========.#.# 
+000365f0: 3d3d 3d3d 3d3d 3d0a 230a 2320 2020 2020  =======.#.#     
 00036600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036610: 2020 2020 2020 536f 6c69 6420 416e 676c        Solid Angl
-00036620: 6520 436f 6d70 7574 6174 696f 6e0a 2320  e Computation.# 
-00036630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00036640: 2020 7375 6274 656e 6465 6420 6279 206d    subtended by m
-00036650: 756c 7469 706c 6520 6170 6572 7475 7265  ultiple aperture
-00036660: 730a 230a 2320 3d3d 3d3d 3d3d 3d3d 3d3d  s.#.# ==========
+00036610: 2020 536f 6c69 6420 416e 676c 6520 436f    Solid Angle Co
+00036620: 6d70 7574 6174 696f 6e0a 2320 2020 2020  mputation.#     
+00036630: 2020 2020 2020 2020 2020 2020 2020 7375                su
+00036640: 6274 656e 6465 6420 6279 206d 756c 7469  btended by multi
+00036650: 706c 6520 6170 6572 7475 7265 730a 230a  ple apertures.#.
+00036660: 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  # ==============
 00036670: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00036680: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00036690: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000366a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000366b0: 3d3d 3d3d 0a0a 0a64 6566 2063 6f6d 7075  ====...def compu
-000366c0: 7465 5f73 6f6c 6964 5f61 6e67 6c65 5f61  te_solid_angle_a
-000366d0: 7065 7274 7572 6573 5f75 6e69 7476 6563  pertures_unitvec
-000366e0: 746f 7273 280a 2020 2020 2320 7074 733a  tors(.    # pts:
-000366f0: 2063 6f6f 7264 696e 6174 6573 2061 7320   coordinates as 
-00036700: 7468 7265 6520 3164 2061 7272 6179 730a  three 1d arrays.
-00036710: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
-00036720: 7074 735f 782c 0a20 2020 2064 6f75 626c  pts_x,.    doubl
-00036730: 655b 3a3a 315d 2070 7473 5f79 2c0a 2020  e[::1] pts_y,.  
-00036740: 2020 646f 7562 6c65 5b3a 3a31 5d20 7074    double[::1] pt
-00036750: 735f 7a2c 0a20 2020 2023 2064 6574 6563  s_z,.    # detec
-00036760: 746f 7273 3a20 706f 6c79 676f 6e20 636f  tors: polygon co
-00036770: 6f72 6469 6e61 7465 7320 696e 2032 6420  ordinates in 2d 
-00036780: 2863 6f6d 6d6f 6e20 746f 2061 6c6c 2064  (common to all d
-00036790: 6574 6563 746f 7273 290a 2020 2020 646f  etectors).    do
-000367a0: 7562 6c65 5b3a 3a31 5d20 6465 745f 6f75  uble[::1] det_ou
-000367b0: 746c 696e 655f 7830 2c0a 2020 2020 646f  tline_x0,.    do
-000367c0: 7562 6c65 5b3a 3a31 5d20 6465 745f 6f75  uble[::1] det_ou
-000367d0: 746c 696e 655f 7831 2c0a 2020 2020 2320  tline_x1,.    # 
-000367e0: 6465 7465 6374 6f72 733a 2063 656e 7465  detectors: cente
-000367f0: 7273 2063 6f6f 7264 696e 6174 6573 2061  rs coordinates a
-00036800: 7320 7468 7265 6520 3164 2061 7272 6179  s three 1d array
-00036810: 730a 2020 2020 646f 7562 6c65 5b3a 3a31  s.    double[::1
-00036820: 5d20 6465 745f 6365 6e74 735f 782c 0a20  ] det_cents_x,. 
-00036830: 2020 2064 6f75 626c 655b 3a3a 315d 2064     double[::1] d
-00036840: 6574 5f63 656e 7473 5f79 2c0a 2020 2020  et_cents_y,.    
-00036850: 646f 7562 6c65 5b3a 3a31 5d20 6465 745f  double[::1] det_
-00036860: 6365 6e74 735f 7a2c 0a20 2020 2023 2064  cents_z,.    # d
-00036870: 6574 6563 746f 7273 3a20 6e6f 726d 616c  etectors: normal
-00036880: 2075 6e69 7420 7665 6374 6f72 7320 6173   unit vectors as
-00036890: 2074 6872 6565 2031 6420 6172 7261 7973   three 1d arrays
-000368a0: 2028 6e64 203d 206c 656e 2864 6574 5f6e   (nd = len(det_n
-000368b0: 6f72 6d5f 7829 290a 2020 2020 646f 7562  orm_x)).    doub
-000368c0: 6c65 5b3a 3a31 5d20 6465 745f 6e6f 726d  le[::1] det_norm
-000368d0: 5f78 2c0a 2020 2020 646f 7562 6c65 5b3a  _x,.    double[:
-000368e0: 3a31 5d20 6465 745f 6e6f 726d 5f79 2c0a  :1] det_norm_y,.
-000368f0: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
-00036900: 6465 745f 6e6f 726d 5f7a 2c0a 2020 2020  det_norm_z,.    
-00036910: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-00036920: 652c 206e 6469 6d3d 315d 2064 6574 5f65  e, ndim=1] det_e
-00036930: 305f 782c 0a20 2020 206e 702e 6e64 6172  0_x,.    np.ndar
-00036940: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
-00036950: 3d31 5d20 6465 745f 6530 5f79 2c0a 2020  =1] det_e0_y,.  
-00036960: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
-00036970: 626c 652c 206e 6469 6d3d 315d 2064 6574  ble, ndim=1] det
-00036980: 5f65 305f 7a2c 0a20 2020 206e 702e 6e64  _e0_z,.    np.nd
-00036990: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
-000369a0: 696d 3d31 5d20 6465 745f 6531 5f78 2c0a  im=1] det_e1_x,.
-000369b0: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
-000369c0: 6f75 626c 652c 206e 6469 6d3d 315d 2064  ouble, ndim=1] d
-000369d0: 6574 5f65 315f 792c 0a20 2020 206e 702e  et_e1_y,.    np.
-000369e0: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-000369f0: 6e64 696d 3d31 5d20 6465 745f 6531 5f7a  ndim=1] det_e1_z
-00036a00: 2c0a 2020 2020 2320 6170 6572 7475 7265  ,.    # aperture
-00036a10: 733a 2069 6e64 6963 6573 206f 6620 6669  s: indices of fi
-00036a20: 7273 7420 636f 726e 6572 206f 6620 6561  rst corner of ea
-00036a30: 6368 2061 7020 706f 6c79 676f 6e3a 206e  ch ap polygon: n
-00036a40: 6120 3d20 6c65 6e28 6170 5f69 6e64 290a  a = len(ap_ind).
-00036a50: 2020 2020 6c6f 6e67 5b3a 3a31 5d20 6170      long[::1] ap
-00036a60: 5f69 6e64 2c0a 2020 2020 2320 6170 6572  _ind,.    # aper
-00036a70: 7475 7265 733a 2070 6f6c 7967 6f6e 2063  tures: polygon c
-00036a80: 6f6f 7264 696e 6174 6573 2061 7320 7468  oordinates as th
-00036a90: 7265 6520 3164 2061 7272 6179 730a 2020  ree 1d arrays.  
-00036aa0: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
-00036ab0: 626c 652c 206e 6469 6d3d 315d 2061 705f  ble, ndim=1] ap_
-00036ac0: 782c 0a20 2020 206e 702e 6e64 6172 7261  x,.    np.ndarra
-00036ad0: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
-00036ae0: 5d20 6170 5f79 2c0a 2020 2020 6e70 2e6e  ] ap_y,.    np.n
-00036af0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
-00036b00: 6469 6d3d 315d 2061 705f 7a2c 0a20 2020  dim=1] ap_z,.   
-00036b10: 2023 206e 6f72 6d61 6c20 756e 6974 2076   # normal unit v
-00036b20: 6563 746f 7273 0a20 2020 2064 6f75 626c  ectors.    doubl
-00036b30: 655b 3a3a 315d 2061 705f 6e6f 726d 5f78  e[::1] ap_norm_x
-00036b40: 2c0a 2020 2020 646f 7562 6c65 5b3a 3a31  ,.    double[::1
-00036b50: 5d20 6170 5f6e 6f72 6d5f 792c 0a20 2020  ] ap_norm_y,.   
-00036b60: 2064 6f75 626c 655b 3a3a 315d 2061 705f   double[::1] ap_
-00036b70: 6e6f 726d 5f7a 2c0a 2020 2020 2320 706f  norm_z,.    # po
-00036b80: 7373 6962 6c65 2065 7874 7261 2070 6172  ssible extra par
-00036b90: 616d 6574 6572 7320 3f0a 2020 2020 646f  ameters ?.    do
-00036ba0: 7562 6c65 206d 6172 6769 6e3d 5f56 534d  uble margin=_VSM
-00036bb0: 414c 4c2c 0a20 2020 2069 6e74 206e 756d  ALL,.    int num
-00036bc0: 5f74 6872 6561 6473 3d31 302c 0a29 3a0a  _threads=10,.):.
-00036bd0: 0a20 2020 2023 202d 2d2d 2d2d 2d2d 2d2d  .    # ---------
-00036be0: 2d2d 0a20 2020 2023 2044 6563 6c61 7261  --.    # Declara
-00036bf0: 7469 6f6e 0a0a 2020 2020 6364 6566 2069  tion..    cdef i
-00036c00: 6e74 206e 7074 7320 3d20 7074 735f 782e  nt npts = pts_x.
-00036c10: 7369 7a65 0a20 2020 2063 6465 6620 696e  size.    cdef in
-00036c20: 7420 6e64 203d 2064 6574 5f63 656e 7473  t nd = det_cents
-00036c30: 5f78 2e73 697a 650a 2020 2020 6364 6566  _x.size.    cdef
-00036c40: 2069 6e74 206e 6120 3d20 6170 5f6e 6f72   int na = ap_nor
-00036c50: 6d5f 782e 7369 7a65 0a20 2020 2063 6465  m_x.size.    cde
-00036c60: 6620 696e 7420 6464 2c20 7070 2c20 6161  f int dd, pp, aa
-00036c70: 2c20 7474 0a20 2020 2063 6465 6620 696e  , tt.    cdef in
-00036c80: 7420 6e70 610a 2020 2020 6364 6566 2066  t npa.    cdef f
-00036c90: 6c6f 6174 2073 6361 2c20 7363 6130 2c20  loat sca, sca0, 
-00036ca0: 7363 6131 0a20 2020 2063 6465 6620 666c  sca1.    cdef fl
-00036cb0: 6f61 7420 6b69 0a20 2020 2063 6465 6620  oat ki.    cdef 
-00036cc0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-00036cd0: 652c 206e 6469 6d3d 315d 2061 705f 7830  e, ndim=1] ap_x0
-00036ce0: 203d 206e 702e 636f 7079 2861 705f 7829   = np.copy(ap_x)
-00036cf0: 0a20 2020 2063 6465 6620 6e70 2e6e 6461  .    cdef np.nda
-00036d00: 7272 6179 5b64 6f75 626c 652c 206e 6469  rray[double, ndi
-00036d10: 6d3d 315d 2061 705f 7831 203d 206e 702e  m=1] ap_x1 = np.
-00036d20: 636f 7079 2861 705f 7829 0a20 2020 2063  copy(ap_x).    c
-00036d30: 6465 6620 6e70 2e6e 6461 7272 6179 5b64  def np.ndarray[d
-00036d40: 6f75 626c 652c 206e 6469 6d3d 315d 2070  ouble, ndim=1] p
-00036d50: 5f61 5f78 300a 2020 2020 6364 6566 206e  _a_x0.    cdef n
-00036d60: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-00036d70: 2c20 6e64 696d 3d31 5d20 705f 615f 7831  , ndim=1] p_a_x1
-00036d80: 0a20 2020 2063 6465 6620 666c 6f61 7420  .    cdef float 
-00036d90: 6378 302c 2063 7831 0a20 2020 2063 6465  cx0, cx1.    cde
-00036da0: 6620 666c 6f61 7420 7578 2c20 7579 2c20  f float ux, uy, 
-00036db0: 757a 2c20 696e 765f 6e6f 726d 0a20 2020  uz, inv_norm.   
-00036dc0: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
-00036dd0: 5b6c 6f6e 672c 206e 6469 6d3d 325d 2074  [long, ndim=2] t
-00036de0: 7269 0a20 2020 2063 6465 6620 6e70 2e6e  ri.    cdef np.n
-00036df0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
-00036e00: 6469 6d3d 315d 2074 7269 5f78 0a20 2020  dim=1] tri_x.   
-00036e10: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
-00036e20: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
-00036e30: 2074 7269 5f79 0a20 2020 2063 6465 6620   tri_y.    cdef 
-00036e40: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-00036e50: 652c 206e 6469 6d3d 315d 2074 7269 5f7a  e, ndim=1] tri_z
-00036e60: 0a0a 2020 2020 2320 696e 6974 6961 6c69  ..    # initiali
-00036e70: 7a65 2073 6f6c 6964 2061 6e67 6c65 2061  ze solid angle a
-00036e80: 7272 6179 2077 6974 6820 7a65 726f 730a  rray with zeros.
-00036e90: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-00036ea0: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
-00036eb0: 3d32 5d20 736f 6c69 645f 616e 676c 6520  =2] solid_angle 
-00036ec0: 3d20 6e70 2e7a 6572 6f73 2828 6e64 2c20  = np.zeros((nd, 
-00036ed0: 6e70 7473 292c 2064 7479 7065 3d66 6c6f  npts), dtype=flo
-00036ee0: 6174 290a 2020 2020 6364 6566 206e 702e  at).    cdef np.
-00036ef0: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-00036f00: 6e64 696d 3d32 5d20 7576 6563 745f 7820  ndim=2] uvect_x 
-00036f10: 3d20 6e70 2e7a 6572 6f73 2828 6e64 2c20  = np.zeros((nd, 
-00036f20: 6e70 7473 292c 2064 7479 7065 3d66 6c6f  npts), dtype=flo
-00036f30: 6174 290a 2020 2020 6364 6566 206e 702e  at).    cdef np.
-00036f40: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-00036f50: 6e64 696d 3d32 5d20 7576 6563 745f 7920  ndim=2] uvect_y 
-00036f60: 3d20 6e70 2e7a 6572 6f73 2828 6e64 2c20  = np.zeros((nd, 
-00036f70: 6e70 7473 292c 2064 7479 7065 3d66 6c6f  npts), dtype=flo
-00036f80: 6174 290a 2020 2020 6364 6566 206e 702e  at).    cdef np.
-00036f90: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-00036fa0: 6e64 696d 3d32 5d20 7576 6563 745f 7a20  ndim=2] uvect_z 
-00036fb0: 3d20 6e70 2e7a 6572 6f73 2828 6e64 2c20  = np.zeros((nd, 
-00036fc0: 6e70 7473 292c 2064 7479 7065 3d66 6c6f  npts), dtype=flo
-00036fd0: 6174 290a 0a20 2020 2023 202d 2d2d 2d2d  at)..    # -----
-00036fe0: 2d2d 0a20 2020 2023 2043 6f6d 7075 7465  --.    # Compute
-00036ff0: 0a0a 2020 2020 666f 7220 6464 2069 6e20  ..    for dd in 
-00037000: 7261 6e67 6528 6e64 293a 0a0a 2020 2020  range(nd):..    
-00037010: 2020 2020 2320 6c6f 6f70 2032 3a20 6f6e      # loop 2: on
-00037020: 206e 7074 7320 286f 6273 6572 7661 7469   npts (observati
-00037030: 6f6e 2070 6f69 6e74 7329 0a20 2020 2020  on points).     
-00037040: 2020 2066 6f72 2070 7020 696e 2072 616e     for pp in ran
-00037050: 6765 286e 7074 7329 3a0a 0a20 2020 2020  ge(npts):..     
-00037060: 2020 2020 2020 2023 2074 6573 7420 6966         # test if
-00037070: 206f 6e20 676f 6f64 2073 6964 6520 6f66   on good side of
-00037080: 2064 6574 6563 746f 720a 2020 2020 2020   detector.      
-00037090: 2020 2020 2020 7363 6130 203d 2028 0a20        sca0 = (. 
-000370a0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-000370b0: 7074 735f 785b 7070 5d20 2d20 6465 745f  pts_x[pp] - det_
-000370c0: 6365 6e74 735f 785b 6464 5d29 202a 2064  cents_x[dd]) * d
-000370d0: 6574 5f6e 6f72 6d5f 785b 6464 5d0a 2020  et_norm_x[dd].  
-000370e0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-000370f0: 2870 7473 5f79 5b70 705d 202d 2064 6574  (pts_y[pp] - det
-00037100: 5f63 656e 7473 5f79 5b64 645d 2920 2a20  _cents_y[dd]) * 
-00037110: 6465 745f 6e6f 726d 5f79 5b64 645d 0a20  det_norm_y[dd]. 
-00037120: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-00037130: 2028 7074 735f 7a5b 7070 5d20 2d20 6465   (pts_z[pp] - de
-00037140: 745f 6365 6e74 735f 7a5b 6464 5d29 202a  t_cents_z[dd]) *
-00037150: 2064 6574 5f6e 6f72 6d5f 7a5b 6464 5d0a   det_norm_z[dd].
-00037160: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
-00037170: 2020 2020 2020 2020 2020 2069 6620 7363             if sc
-00037180: 6130 203c 3d20 303a 0a20 2020 2020 2020  a0 <= 0:.       
-00037190: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
-000371a0: 650a 0a20 2020 2020 2020 2020 2020 2023  e..            #
-000371b0: 2066 6c61 670a 2020 2020 2020 2020 2020   flag.          
-000371c0: 2020 6973 6f6b 203d 2054 7275 650a 0a20    isok = True.. 
-000371d0: 2020 2020 2020 2020 2020 2023 206c 6f6f             # loo
-000371e0: 7020 333a 206f 6e20 6e61 2028 6170 6572  p 3: on na (aper
-000371f0: 7475 7265 7329 0a20 2020 2020 2020 2020  tures).         
-00037200: 2020 2066 6f72 2061 6120 696e 2072 616e     for aa in ran
-00037210: 6765 286e 6129 3a0a 0a20 2020 2020 2020  ge(na):..       
-00037220: 2020 2020 2020 2020 2023 2074 6573 7420           # test 
-00037230: 6966 206f 6e20 676f 6f64 2073 6964 6520  if on good side 
-00037240: 6f66 2061 7065 7274 7572 650a 2020 2020  of aperture.    
-00037250: 2020 2020 2020 2020 2020 2020 7363 6120              sca 
-00037260: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-00037270: 2020 2020 2020 2020 2870 7473 5f78 5b70          (pts_x[p
-00037280: 705d 202d 2061 705f 785b 6170 5f69 6e64  p] - ap_x[ap_ind
-00037290: 5b61 615d 5d29 202a 2061 705f 6e6f 726d  [aa]]) * ap_norm
-000372a0: 5f78 5b61 615d 0a20 2020 2020 2020 2020  _x[aa].         
-000372b0: 2020 2020 2020 2020 2020 202b 2028 7074             + (pt
-000372c0: 735f 795b 7070 5d20 2d20 6170 5f79 5b61  s_y[pp] - ap_y[a
-000372d0: 705f 696e 645b 6161 5d5d 2920 2a20 6170  p_ind[aa]]) * ap
-000372e0: 5f6e 6f72 6d5f 795b 6161 5d0a 2020 2020  _norm_y[aa].    
-000372f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00037300: 2b20 2870 7473 5f7a 5b70 705d 202d 2061  + (pts_z[pp] - a
-00037310: 705f 7a5b 6170 5f69 6e64 5b61 615d 5d29  p_z[ap_ind[aa]])
-00037320: 202a 2061 705f 6e6f 726d 5f7a 5b61 615d   * ap_norm_z[aa]
-00037330: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00037340: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
-00037350: 2020 2020 6966 2073 6361 203c 3d20 303a      if sca <= 0:
-00037360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00037370: 2020 2020 2069 736f 6b20 3d20 4661 6c73       isok = Fals
-00037380: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00037390: 2020 2020 2020 6272 6561 6b0a 0a20 2020        break..   
-000373a0: 2020 2020 2020 2020 2020 2020 2023 2074               # t
-000373b0: 6573 7420 6966 2061 6c6c 2061 7065 7274  est if all apert
-000373c0: 7572 6520 706f 696e 7473 2063 616e 2062  ure points can b
-000373d0: 6520 7072 6f6a 6563 7465 6420 6f6e 2064  e projected on d
-000373e0: 6574 6563 746f 7220 706c 616e 6520 6672  etector plane fr
-000373f0: 6f6d 2070 7473 0a20 2020 2020 2020 2020  om pts.         
-00037400: 2020 2020 2020 2066 6f72 206c 6c20 696e         for ll in
-00037410: 2072 616e 6765 2861 705f 696e 645b 6161   range(ap_ind[aa
-00037420: 5d2c 2061 705f 696e 645b 6161 2b31 5d29  ], ap_ind[aa+1])
-00037430: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00037440: 2020 2020 2020 7363 6131 203d 2028 0a20        sca1 = (. 
+000366b0: 0a0a 0a64 6566 2063 6f6d 7075 7465 5f73  ...def compute_s
+000366c0: 6f6c 6964 5f61 6e67 6c65 5f61 7065 7274  olid_angle_apert
+000366d0: 7572 6573 5f75 6e69 7476 6563 746f 7273  ures_unitvectors
+000366e0: 280a 2020 2020 2320 7074 733a 2063 6f6f  (.    # pts: coo
+000366f0: 7264 696e 6174 6573 2061 7320 7468 7265  rdinates as thre
+00036700: 6520 3164 2061 7272 6179 730a 2020 2020  e 1d arrays.    
+00036710: 646f 7562 6c65 5b3a 3a31 5d20 7074 735f  double[::1] pts_
+00036720: 782c 0a20 2020 2064 6f75 626c 655b 3a3a  x,.    double[::
+00036730: 315d 2070 7473 5f79 2c0a 2020 2020 646f  1] pts_y,.    do
+00036740: 7562 6c65 5b3a 3a31 5d20 7074 735f 7a2c  uble[::1] pts_z,
+00036750: 0a20 2020 2023 2064 6574 6563 746f 7273  .    # detectors
+00036760: 3a20 706f 6c79 676f 6e20 636f 6f72 6469  : polygon coordi
+00036770: 6e61 7465 7320 696e 2032 6420 2863 6f6d  nates in 2d (com
+00036780: 6d6f 6e20 746f 2061 6c6c 2064 6574 6563  mon to all detec
+00036790: 746f 7273 290a 2020 2020 646f 7562 6c65  tors).    double
+000367a0: 5b3a 3a31 5d20 6465 745f 6f75 746c 696e  [::1] det_outlin
+000367b0: 655f 7830 2c0a 2020 2020 646f 7562 6c65  e_x0,.    double
+000367c0: 5b3a 3a31 5d20 6465 745f 6f75 746c 696e  [::1] det_outlin
+000367d0: 655f 7831 2c0a 2020 2020 2320 6465 7465  e_x1,.    # dete
+000367e0: 6374 6f72 733a 2063 656e 7465 7273 2063  ctors: centers c
+000367f0: 6f6f 7264 696e 6174 6573 2061 7320 7468  oordinates as th
+00036800: 7265 6520 3164 2061 7272 6179 730a 2020  ree 1d arrays.  
+00036810: 2020 646f 7562 6c65 5b3a 3a31 5d20 6465    double[::1] de
+00036820: 745f 6365 6e74 735f 782c 0a20 2020 2064  t_cents_x,.    d
+00036830: 6f75 626c 655b 3a3a 315d 2064 6574 5f63  ouble[::1] det_c
+00036840: 656e 7473 5f79 2c0a 2020 2020 646f 7562  ents_y,.    doub
+00036850: 6c65 5b3a 3a31 5d20 6465 745f 6365 6e74  le[::1] det_cent
+00036860: 735f 7a2c 0a20 2020 2023 2064 6574 6563  s_z,.    # detec
+00036870: 746f 7273 3a20 6e6f 726d 616c 2075 6e69  tors: normal uni
+00036880: 7420 7665 6374 6f72 7320 6173 2074 6872  t vectors as thr
+00036890: 6565 2031 6420 6172 7261 7973 2028 6e64  ee 1d arrays (nd
+000368a0: 203d 206c 656e 2864 6574 5f6e 6f72 6d5f   = len(det_norm_
+000368b0: 7829 290a 2020 2020 646f 7562 6c65 5b3a  x)).    double[:
+000368c0: 3a31 5d20 6465 745f 6e6f 726d 5f78 2c0a  :1] det_norm_x,.
+000368d0: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
+000368e0: 6465 745f 6e6f 726d 5f79 2c0a 2020 2020  det_norm_y,.    
+000368f0: 646f 7562 6c65 5b3a 3a31 5d20 6465 745f  double[::1] det_
+00036900: 6e6f 726d 5f7a 2c0a 2020 2020 6e70 2e6e  norm_z,.    np.n
+00036910: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+00036920: 6469 6d3d 315d 2064 6574 5f65 305f 782c  dim=1] det_e0_x,
+00036930: 0a20 2020 206e 702e 6e64 6172 7261 795b  .    np.ndarray[
+00036940: 646f 7562 6c65 2c20 6e64 696d 3d31 5d20  double, ndim=1] 
+00036950: 6465 745f 6530 5f79 2c0a 2020 2020 6e70  det_e0_y,.    np
+00036960: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
+00036970: 206e 6469 6d3d 315d 2064 6574 5f65 305f   ndim=1] det_e0_
+00036980: 7a2c 0a20 2020 206e 702e 6e64 6172 7261  z,.    np.ndarra
+00036990: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
+000369a0: 5d20 6465 745f 6531 5f78 2c0a 2020 2020  ] det_e1_x,.    
+000369b0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+000369c0: 652c 206e 6469 6d3d 315d 2064 6574 5f65  e, ndim=1] det_e
+000369d0: 315f 792c 0a20 2020 206e 702e 6e64 6172  1_y,.    np.ndar
+000369e0: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+000369f0: 3d31 5d20 6465 745f 6531 5f7a 2c0a 2020  =1] det_e1_z,.  
+00036a00: 2020 2320 6170 6572 7475 7265 733a 2069    # apertures: i
+00036a10: 6e64 6963 6573 206f 6620 6669 7273 7420  ndices of first 
+00036a20: 636f 726e 6572 206f 6620 6561 6368 2061  corner of each a
+00036a30: 7020 706f 6c79 676f 6e3a 206e 6120 3d20  p polygon: na = 
+00036a40: 6c65 6e28 6170 5f69 6e64 290a 2020 2020  len(ap_ind).    
+00036a50: 6c6f 6e67 5b3a 3a31 5d20 6170 5f69 6e64  long[::1] ap_ind
+00036a60: 2c0a 2020 2020 2320 6170 6572 7475 7265  ,.    # aperture
+00036a70: 733a 2070 6f6c 7967 6f6e 2063 6f6f 7264  s: polygon coord
+00036a80: 696e 6174 6573 2061 7320 7468 7265 6520  inates as three 
+00036a90: 3164 2061 7272 6179 730a 2020 2020 6e70  1d arrays.    np
+00036aa0: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
+00036ab0: 206e 6469 6d3d 315d 2061 705f 782c 0a20   ndim=1] ap_x,. 
+00036ac0: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
+00036ad0: 7562 6c65 2c20 6e64 696d 3d31 5d20 6170  uble, ndim=1] ap
+00036ae0: 5f79 2c0a 2020 2020 6e70 2e6e 6461 7272  _y,.    np.ndarr
+00036af0: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
+00036b00: 315d 2061 705f 7a2c 0a20 2020 2023 206e  1] ap_z,.    # n
+00036b10: 6f72 6d61 6c20 756e 6974 2076 6563 746f  ormal unit vecto
+00036b20: 7273 0a20 2020 2064 6f75 626c 655b 3a3a  rs.    double[::
+00036b30: 315d 2061 705f 6e6f 726d 5f78 2c0a 2020  1] ap_norm_x,.  
+00036b40: 2020 646f 7562 6c65 5b3a 3a31 5d20 6170    double[::1] ap
+00036b50: 5f6e 6f72 6d5f 792c 0a20 2020 2064 6f75  _norm_y,.    dou
+00036b60: 626c 655b 3a3a 315d 2061 705f 6e6f 726d  ble[::1] ap_norm
+00036b70: 5f7a 2c0a 2020 2020 2320 706f 7373 6962  _z,.    # possib
+00036b80: 6c65 2065 7874 7261 2070 6172 616d 6574  le extra paramet
+00036b90: 6572 7320 3f0a 2020 2020 646f 7562 6c65  ers ?.    double
+00036ba0: 206d 6172 6769 6e3d 5f56 534d 414c 4c2c   margin=_VSMALL,
+00036bb0: 0a20 2020 2069 6e74 206e 756d 5f74 6872  .    int num_thr
+00036bc0: 6561 6473 3d31 302c 0a29 3a0a 0a20 2020  eads=10,.):..   
+00036bd0: 2023 202d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20   # -----------. 
+00036be0: 2020 2023 2044 6563 6c61 7261 7469 6f6e     # Declaration
+00036bf0: 0a0a 2020 2020 6364 6566 2069 6e74 206e  ..    cdef int n
+00036c00: 7074 7320 3d20 7074 735f 782e 7369 7a65  pts = pts_x.size
+00036c10: 0a20 2020 2063 6465 6620 696e 7420 6e64  .    cdef int nd
+00036c20: 203d 2064 6574 5f63 656e 7473 5f78 2e73   = det_cents_x.s
+00036c30: 697a 650a 2020 2020 6364 6566 2069 6e74  ize.    cdef int
+00036c40: 206e 6120 3d20 6170 5f6e 6f72 6d5f 782e   na = ap_norm_x.
+00036c50: 7369 7a65 0a20 2020 2063 6465 6620 696e  size.    cdef in
+00036c60: 7420 6464 2c20 7070 2c20 6161 2c20 7474  t dd, pp, aa, tt
+00036c70: 0a20 2020 2063 6465 6620 696e 7420 6e70  .    cdef int np
+00036c80: 610a 2020 2020 6364 6566 2066 6c6f 6174  a.    cdef float
+00036c90: 2073 6361 2c20 7363 6130 2c20 7363 6131   sca, sca0, sca1
+00036ca0: 0a20 2020 2063 6465 6620 666c 6f61 7420  .    cdef float 
+00036cb0: 6b69 0a20 2020 2063 6465 6620 6e70 2e6e  ki.    cdef np.n
+00036cc0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+00036cd0: 6469 6d3d 315d 2061 705f 7830 203d 206e  dim=1] ap_x0 = n
+00036ce0: 702e 636f 7079 2861 705f 7829 0a20 2020  p.copy(ap_x).   
+00036cf0: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
+00036d00: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
+00036d10: 2061 705f 7831 203d 206e 702e 636f 7079   ap_x1 = np.copy
+00036d20: 2861 705f 7829 0a20 2020 2063 6465 6620  (ap_x).    cdef 
+00036d30: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+00036d40: 652c 206e 6469 6d3d 315d 2070 5f61 5f78  e, ndim=1] p_a_x
+00036d50: 300a 2020 2020 6364 6566 206e 702e 6e64  0.    cdef np.nd
+00036d60: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
+00036d70: 696d 3d31 5d20 705f 615f 7831 0a20 2020  im=1] p_a_x1.   
+00036d80: 2063 6465 6620 666c 6f61 7420 6378 302c   cdef float cx0,
+00036d90: 2063 7831 0a20 2020 2063 6465 6620 666c   cx1.    cdef fl
+00036da0: 6f61 7420 7578 2c20 7579 2c20 757a 2c20  oat ux, uy, uz, 
+00036db0: 696e 765f 6e6f 726d 0a20 2020 2063 6465  inv_norm.    cde
+00036dc0: 6620 6e70 2e6e 6461 7272 6179 5b6c 6f6e  f np.ndarray[lon
+00036dd0: 672c 206e 6469 6d3d 325d 2074 7269 0a20  g, ndim=2] tri. 
+00036de0: 2020 2063 6465 6620 6e70 2e6e 6461 7272     cdef np.ndarr
+00036df0: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
+00036e00: 315d 2074 7269 5f78 0a20 2020 2063 6465  1] tri_x.    cde
+00036e10: 6620 6e70 2e6e 6461 7272 6179 5b64 6f75  f np.ndarray[dou
+00036e20: 626c 652c 206e 6469 6d3d 315d 2074 7269  ble, ndim=1] tri
+00036e30: 5f79 0a20 2020 2063 6465 6620 6e70 2e6e  _y.    cdef np.n
+00036e40: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+00036e50: 6469 6d3d 315d 2074 7269 5f7a 0a0a 2020  dim=1] tri_z..  
+00036e60: 2020 2320 696e 6974 6961 6c69 7a65 2073    # initialize s
+00036e70: 6f6c 6964 2061 6e67 6c65 2061 7272 6179  olid angle array
+00036e80: 2077 6974 6820 7a65 726f 730a 2020 2020   with zeros.    
+00036e90: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+00036ea0: 646f 7562 6c65 2c20 6e64 696d 3d32 5d20  double, ndim=2] 
+00036eb0: 736f 6c69 645f 616e 676c 6520 3d20 6e70  solid_angle = np
+00036ec0: 2e7a 6572 6f73 2828 6e64 2c20 6e70 7473  .zeros((nd, npts
+00036ed0: 292c 2064 7479 7065 3d66 6c6f 6174 290a  ), dtype=float).
+00036ee0: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+00036ef0: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+00036f00: 3d32 5d20 7576 6563 745f 7820 3d20 6e70  =2] uvect_x = np
+00036f10: 2e7a 6572 6f73 2828 6e64 2c20 6e70 7473  .zeros((nd, npts
+00036f20: 292c 2064 7479 7065 3d66 6c6f 6174 290a  ), dtype=float).
+00036f30: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+00036f40: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+00036f50: 3d32 5d20 7576 6563 745f 7920 3d20 6e70  =2] uvect_y = np
+00036f60: 2e7a 6572 6f73 2828 6e64 2c20 6e70 7473  .zeros((nd, npts
+00036f70: 292c 2064 7479 7065 3d66 6c6f 6174 290a  ), dtype=float).
+00036f80: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+00036f90: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+00036fa0: 3d32 5d20 7576 6563 745f 7a20 3d20 6e70  =2] uvect_z = np
+00036fb0: 2e7a 6572 6f73 2828 6e64 2c20 6e70 7473  .zeros((nd, npts
+00036fc0: 292c 2064 7479 7065 3d66 6c6f 6174 290a  ), dtype=float).
+00036fd0: 0a20 2020 2023 202d 2d2d 2d2d 2d2d 0a20  .    # -------. 
+00036fe0: 2020 2023 2043 6f6d 7075 7465 0a0a 2020     # Compute..  
+00036ff0: 2020 666f 7220 6464 2069 6e20 7261 6e67    for dd in rang
+00037000: 6528 6e64 293a 0a0a 2020 2020 2020 2020  e(nd):..        
+00037010: 2320 6c6f 6f70 2032 3a20 6f6e 206e 7074  # loop 2: on npt
+00037020: 7320 286f 6273 6572 7661 7469 6f6e 2070  s (observation p
+00037030: 6f69 6e74 7329 0a20 2020 2020 2020 2066  oints).        f
+00037040: 6f72 2070 7020 696e 2072 616e 6765 286e  or pp in range(n
+00037050: 7074 7329 3a0a 0a20 2020 2020 2020 2020  pts):..         
+00037060: 2020 2023 2074 6573 7420 6966 206f 6e20     # test if on 
+00037070: 676f 6f64 2073 6964 6520 6f66 2064 6574  good side of det
+00037080: 6563 746f 720a 2020 2020 2020 2020 2020  ector.          
+00037090: 2020 7363 6130 203d 2028 0a20 2020 2020    sca0 = (.     
+000370a0: 2020 2020 2020 2020 2020 2028 7074 735f             (pts_
+000370b0: 785b 7070 5d20 2d20 6465 745f 6365 6e74  x[pp] - det_cent
+000370c0: 735f 785b 6464 5d29 202a 2064 6574 5f6e  s_x[dd]) * det_n
+000370d0: 6f72 6d5f 785b 6464 5d0a 2020 2020 2020  orm_x[dd].      
+000370e0: 2020 2020 2020 2020 2020 2b20 2870 7473            + (pts
+000370f0: 5f79 5b70 705d 202d 2064 6574 5f63 656e  _y[pp] - det_cen
+00037100: 7473 5f79 5b64 645d 2920 2a20 6465 745f  ts_y[dd]) * det_
+00037110: 6e6f 726d 5f79 5b64 645d 0a20 2020 2020  norm_y[dd].     
+00037120: 2020 2020 2020 2020 2020 202b 2028 7074             + (pt
+00037130: 735f 7a5b 7070 5d20 2d20 6465 745f 6365  s_z[pp] - det_ce
+00037140: 6e74 735f 7a5b 6464 5d29 202a 2064 6574  nts_z[dd]) * det
+00037150: 5f6e 6f72 6d5f 7a5b 6464 5d0a 2020 2020  _norm_z[dd].    
+00037160: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+00037170: 2020 2020 2020 2069 6620 7363 6130 203c         if sca0 <
+00037180: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
+00037190: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
+000371a0: 2020 2020 2020 2020 2020 2023 2066 6c61             # fla
+000371b0: 670a 2020 2020 2020 2020 2020 2020 6973  g.            is
+000371c0: 6f6b 203d 2054 7275 650a 0a20 2020 2020  ok = True..     
+000371d0: 2020 2020 2020 2023 206c 6f6f 7020 333a         # loop 3:
+000371e0: 206f 6e20 6e61 2028 6170 6572 7475 7265   on na (aperture
+000371f0: 7329 0a20 2020 2020 2020 2020 2020 2066  s).            f
+00037200: 6f72 2061 6120 696e 2072 616e 6765 286e  or aa in range(n
+00037210: 6129 3a0a 0a20 2020 2020 2020 2020 2020  a):..           
+00037220: 2020 2020 2023 2074 6573 7420 6966 206f       # test if o
+00037230: 6e20 676f 6f64 2073 6964 6520 6f66 2061  n good side of a
+00037240: 7065 7274 7572 650a 2020 2020 2020 2020  perture.        
+00037250: 2020 2020 2020 2020 7363 6120 3d20 280a          sca = (.
+00037260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037270: 2020 2020 2870 7473 5f78 5b70 705d 202d      (pts_x[pp] -
+00037280: 2061 705f 785b 6170 5f69 6e64 5b61 615d   ap_x[ap_ind[aa]
+00037290: 5d29 202a 2061 705f 6e6f 726d 5f78 5b61  ]) * ap_norm_x[a
+000372a0: 615d 0a20 2020 2020 2020 2020 2020 2020  a].             
+000372b0: 2020 2020 2020 202b 2028 7074 735f 795b         + (pts_y[
+000372c0: 7070 5d20 2d20 6170 5f79 5b61 705f 696e  pp] - ap_y[ap_in
+000372d0: 645b 6161 5d5d 2920 2a20 6170 5f6e 6f72  d[aa]]) * ap_nor
+000372e0: 6d5f 795b 6161 5d0a 2020 2020 2020 2020  m_y[aa].        
+000372f0: 2020 2020 2020 2020 2020 2020 2b20 2870              + (p
+00037300: 7473 5f7a 5b70 705d 202d 2061 705f 7a5b  ts_z[pp] - ap_z[
+00037310: 6170 5f69 6e64 5b61 615d 5d29 202a 2061  ap_ind[aa]]) * a
+00037320: 705f 6e6f 726d 5f7a 5b61 615d 0a20 2020  p_norm_z[aa].   
+00037330: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
+00037340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037350: 6966 2073 6361 203c 3d20 303a 0a20 2020  if sca <= 0:.   
+00037360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037370: 2069 736f 6b20 3d20 4661 6c73 650a 2020   isok = False.  
+00037380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037390: 2020 6272 6561 6b0a 0a20 2020 2020 2020    break..       
+000373a0: 2020 2020 2020 2020 2023 2074 6573 7420           # test 
+000373b0: 6966 2061 6c6c 2061 7065 7274 7572 6520  if all aperture 
+000373c0: 706f 696e 7473 2063 616e 2062 6520 7072  points can be pr
+000373d0: 6f6a 6563 7465 6420 6f6e 2064 6574 6563  ojected on detec
+000373e0: 746f 7220 706c 616e 6520 6672 6f6d 2070  tor plane from p
+000373f0: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
+00037400: 2020 2066 6f72 206c 6c20 696e 2072 616e     for ll in ran
+00037410: 6765 2861 705f 696e 645b 6161 5d2c 2061  ge(ap_ind[aa], a
+00037420: 705f 696e 645b 6161 2b31 5d29 3a0a 2020  p_ind[aa+1]):.  
+00037430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037440: 2020 7363 6131 203d 2028 0a20 2020 2020    sca1 = (.     
 00037450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00037460: 2020 2020 2020 2028 6170 5f78 5b6c 6c5d         (ap_x[ll]
-00037470: 202d 2070 7473 5f78 5b70 705d 2920 2a20   - pts_x[pp]) * 
-00037480: 6465 745f 6e6f 726d 5f78 5b64 645d 0a20  det_norm_x[dd]. 
+00037460: 2020 2028 6170 5f78 5b6c 6c5d 202d 2070     (ap_x[ll] - p
+00037470: 7473 5f78 5b70 705d 2920 2a20 6465 745f  ts_x[pp]) * det_
+00037480: 6e6f 726d 5f78 5b64 645d 0a20 2020 2020  norm_x[dd].     
 00037490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000374a0: 2020 2020 2020 202b 2028 6170 5f79 5b6c         + (ap_y[l
-000374b0: 6c5d 202d 2070 7473 5f79 5b70 705d 2920  l] - pts_y[pp]) 
-000374c0: 2a20 6465 745f 6e6f 726d 5f79 5b64 645d  * det_norm_y[dd]
-000374d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000374e0: 2020 2020 2020 2020 202b 2028 6170 5f7a           + (ap_z
-000374f0: 5b6c 6c5d 202d 2070 7473 5f7a 5b70 705d  [ll] - pts_z[pp]
-00037500: 2920 2a20 6465 745f 6e6f 726d 5f7a 5b64  ) * det_norm_z[d
-00037510: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
-00037520: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00037530: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00037540: 2073 6361 3120 3e3d 2030 3a0a 2020 2020   sca1 >= 0:.    
+000374a0: 2020 202b 2028 6170 5f79 5b6c 6c5d 202d     + (ap_y[ll] -
+000374b0: 2070 7473 5f79 5b70 705d 2920 2a20 6465   pts_y[pp]) * de
+000374c0: 745f 6e6f 726d 5f79 5b64 645d 0a20 2020  t_norm_y[dd].   
+000374d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000374e0: 2020 2020 202b 2028 6170 5f7a 5b6c 6c5d       + (ap_z[ll]
+000374f0: 202d 2070 7473 5f7a 5b70 705d 2920 2a20   - pts_z[pp]) * 
+00037500: 6465 745f 6e6f 726d 5f7a 5b64 645d 0a20  det_norm_z[dd]. 
+00037510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037520: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+00037530: 2020 2020 2020 2020 2020 6966 2073 6361            if sca
+00037540: 3120 3e3d 2030 3a0a 2020 2020 2020 2020  1 >= 0:.        
 00037550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00037560: 2020 2020 6973 6f6b 203d 2046 616c 7365      isok = False
-00037570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00037580: 2020 2020 2020 2020 2062 7265 616b 0a0a           break..
+00037560: 6973 6f6b 203d 2046 616c 7365 0a20 2020  isok = False.   
+00037570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037580: 2020 2020 2062 7265 616b 0a0a 2020 2020       break..    
 00037590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000375a0: 2020 2020 2320 7072 6f6a 6563 7420 696e      # project in
-000375b0: 2032 640a 2020 2020 2020 2020 2020 2020   2d.            
-000375c0: 2020 2020 2020 2020 6b20 3d20 2d20 7363          k = - sc
-000375d0: 6130 202f 2073 6361 310a 2020 2020 2020  a0 / sca1.      
-000375e0: 2020 2020 2020 2020 2020 2020 2020 505f                P_
-000375f0: 7820 3d20 7074 735f 785b 7070 5d20 2b20  x = pts_x[pp] + 
-00037600: 6b20 2a20 2861 705f 785b 6c6c 5d20 2d20  k * (ap_x[ll] - 
-00037610: 7074 735f 785b 7070 5d29 0a20 2020 2020  pts_x[pp]).     
-00037620: 2020 2020 2020 2020 2020 2020 2020 2050                 P
-00037630: 5f79 203d 2070 7473 5f79 5b70 705d 202b  _y = pts_y[pp] +
-00037640: 206b 202a 2028 6170 5f79 5b6c 6c5d 202d   k * (ap_y[ll] -
-00037650: 2070 7473 5f79 5b70 705d 290a 2020 2020   pts_y[pp]).    
-00037660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00037670: 505f 7a20 3d20 7074 735f 7a5b 7070 5d20  P_z = pts_z[pp] 
-00037680: 2b20 6b20 2a20 2861 705f 7a5b 6c6c 5d20  + k * (ap_z[ll] 
-00037690: 2d20 7074 735f 7a5b 7070 5d29 0a0a 2020  - pts_z[pp])..  
-000376a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000376b0: 2020 2320 7072 6f6a 6563 7420 696e 2032    # project in 2
-000376c0: 640a 2020 2020 2020 2020 2020 2020 2020  d.              
-000376d0: 2020 2020 2020 6170 5f78 305b 6c6c 5d20        ap_x0[ll] 
-000376e0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-000376f0: 2020 2020 2020 2020 2020 2020 2850 5f78              (P_x
-00037700: 202d 2064 6574 5f63 656e 7473 5f78 5b64   - det_cents_x[d
-00037710: 645d 2920 2a20 6465 745f 6530 5f78 5b64  d]) * det_e0_x[d
-00037720: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
-00037730: 2020 2020 2020 2020 2020 202b 2028 505f             + (P_
-00037740: 7920 2d20 6465 745f 6365 6e74 735f 795b  y - det_cents_y[
-00037750: 6464 5d29 202a 2064 6574 5f65 305f 795b  dd]) * det_e0_y[
-00037760: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-00037770: 2020 2020 2020 2020 2020 2020 2b20 2850              + (P
-00037780: 5f7a 202d 2064 6574 5f63 656e 7473 5f7a  _z - det_cents_z
-00037790: 5b64 645d 2920 2a20 6465 745f 6530 5f7a  [dd]) * det_e0_z
-000377a0: 5b64 645d 0a20 2020 2020 2020 2020 2020  [dd].           
-000377b0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-000377c0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-000377d0: 705f 7831 5b6c 6c5d 203d 2028 0a20 2020  p_x1[ll] = (.   
+000375a0: 2320 7072 6f6a 6563 7420 696e 2032 640a  # project in 2d.
+000375b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000375c0: 2020 2020 6b20 3d20 2d20 7363 6130 202f      k = - sca0 /
+000375d0: 2073 6361 310a 2020 2020 2020 2020 2020   sca1.          
+000375e0: 2020 2020 2020 2020 2020 505f 7820 3d20            P_x = 
+000375f0: 7074 735f 785b 7070 5d20 2b20 6b20 2a20  pts_x[pp] + k * 
+00037600: 2861 705f 785b 6c6c 5d20 2d20 7074 735f  (ap_x[ll] - pts_
+00037610: 785b 7070 5d29 0a20 2020 2020 2020 2020  x[pp]).         
+00037620: 2020 2020 2020 2020 2020 2050 5f79 203d             P_y =
+00037630: 2070 7473 5f79 5b70 705d 202b 206b 202a   pts_y[pp] + k *
+00037640: 2028 6170 5f79 5b6c 6c5d 202d 2070 7473   (ap_y[ll] - pts
+00037650: 5f79 5b70 705d 290a 2020 2020 2020 2020  _y[pp]).        
+00037660: 2020 2020 2020 2020 2020 2020 505f 7a20              P_z 
+00037670: 3d20 7074 735f 7a5b 7070 5d20 2b20 6b20  = pts_z[pp] + k 
+00037680: 2a20 2861 705f 7a5b 6c6c 5d20 2d20 7074  * (ap_z[ll] - pt
+00037690: 735f 7a5b 7070 5d29 0a0a 2020 2020 2020  s_z[pp])..      
+000376a0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+000376b0: 7072 6f6a 6563 7420 696e 2032 640a 2020  project in 2d.  
+000376c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000376d0: 2020 6170 5f78 305b 6c6c 5d20 3d20 280a    ap_x0[ll] = (.
+000376e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000376f0: 2020 2020 2020 2020 2850 5f78 202d 2064          (P_x - d
+00037700: 6574 5f63 656e 7473 5f78 5b64 645d 2920  et_cents_x[dd]) 
+00037710: 2a20 6465 745f 6530 5f78 5b64 645d 0a20  * det_e0_x[dd]. 
+00037720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037730: 2020 2020 2020 202b 2028 505f 7920 2d20         + (P_y - 
+00037740: 6465 745f 6365 6e74 735f 795b 6464 5d29  det_cents_y[dd])
+00037750: 202a 2064 6574 5f65 305f 795b 6464 5d0a   * det_e0_y[dd].
+00037760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00037770: 2020 2020 2020 2020 2b20 2850 5f7a 202d          + (P_z -
+00037780: 2064 6574 5f63 656e 7473 5f7a 5b64 645d   det_cents_z[dd]
+00037790: 2920 2a20 6465 745f 6530 5f7a 5b64 645d  ) * det_e0_z[dd]
+000377a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000377b0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+000377c0: 2020 2020 2020 2020 2020 2061 705f 7831             ap_x1
+000377d0: 5b6c 6c5d 203d 2028 0a20 2020 2020 2020  [ll] = (.       
 000377e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000377f0: 2020 2020 2028 505f 7820 2d20 6465 745f       (P_x - det_
-00037800: 6365 6e74 735f 785b 6464 5d29 202a 2064  cents_x[dd]) * d
-00037810: 6574 5f65 315f 785b 6464 5d0a 2020 2020  et_e1_x[dd].    
+000377f0: 2028 505f 7820 2d20 6465 745f 6365 6e74   (P_x - det_cent
+00037800: 735f 785b 6464 5d29 202a 2064 6574 5f65  s_x[dd]) * det_e
+00037810: 315f 785b 6464 5d0a 2020 2020 2020 2020  1_x[dd].        
 00037820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00037830: 2020 2020 2b20 2850 5f79 202d 2064 6574      + (P_y - det
-00037840: 5f63 656e 7473 5f79 5b64 645d 2920 2a20  _cents_y[dd]) * 
-00037850: 6465 745f 6531 5f79 5b64 645d 0a20 2020  det_e1_y[dd].   
+00037830: 2b20 2850 5f79 202d 2064 6574 5f63 656e  + (P_y - det_cen
+00037840: 7473 5f79 5b64 645d 2920 2a20 6465 745f  ts_y[dd]) * det_
+00037850: 6531 5f79 5b64 645d 0a20 2020 2020 2020  e1_y[dd].       
 00037860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00037870: 2020 2020 202b 2028 505f 7a20 2d20 6465       + (P_z - de
-00037880: 745f 6365 6e74 735f 7a5b 6464 5d29 202a  t_cents_z[dd]) *
-00037890: 2064 6574 5f65 315f 7a5b 6464 5d0a 2020   det_e1_z[dd].  
-000378a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000378b0: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
-000378c0: 2020 2020 2069 6620 6e6f 7420 6973 6f6b       if not isok
-000378d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000378e0: 2020 2020 2020 6272 6561 6b0a 0a20 2020        break..   
-000378f0: 2020 2020 2020 2020 2023 2067 6f20 746f           # go to
-00037900: 206e 6578 7420 706f 696e 740a 2020 2020   next point.    
-00037910: 2020 2020 2020 2020 6966 206e 6f74 2069          if not i
-00037920: 736f 6b3a 0a20 2020 2020 2020 2020 2020  sok:.           
-00037930: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
-00037940: 2020 2020 2020 2020 2020 2023 202d 2d2d             # ---
+00037870: 202b 2028 505f 7a20 2d20 6465 745f 6365   + (P_z - det_ce
+00037880: 6e74 735f 7a5b 6464 5d29 202a 2064 6574  nts_z[dd]) * det
+00037890: 5f65 315f 7a5b 6464 5d0a 2020 2020 2020  _e1_z[dd].      
+000378a0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+000378b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000378c0: 2069 6620 6e6f 7420 6973 6f6b 3a0a 2020   if not isok:.  
+000378d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000378e0: 2020 6272 6561 6b0a 0a20 2020 2020 2020    break..       
+000378f0: 2020 2020 2023 2067 6f20 746f 206e 6578       # go to nex
+00037900: 7420 706f 696e 740a 2020 2020 2020 2020  t point.        
+00037910: 2020 2020 6966 206e 6f74 2069 736f 6b3a      if not isok:
+00037920: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00037930: 2063 6f6e 7469 6e75 650a 0a20 2020 2020   continue..     
+00037940: 2020 2020 2020 2023 202d 2d2d 2d2d 2d2d         # -------
 00037950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00037960: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
-00037970: 2020 2020 2020 2320 636f 6d70 7574 6520        # compute 
-00037980: 706f 6c79 676f 6e20 696e 7465 7273 6563  polygon intersec
-00037990: 7469 6f6e 0a0a 2020 2020 2020 2020 2020  tion..          
-000379a0: 2020 2320 636f 6d70 7574 6520 696e 7465    # compute inte
-000379b0: 7273 6563 7469 6f6e 0a20 2020 2020 2020  rsection.       
-000379c0: 2020 2020 2070 5f61 203d 2070 6c67 2e50       p_a = plg.P
-000379d0: 6f6c 7967 6f6e 286e 702e 6172 7261 7928  olygon(np.array(
-000379e0: 5b64 6574 5f6f 7574 6c69 6e65 5f78 302c  [det_outline_x0,
-000379f0: 2064 6574 5f6f 7574 6c69 6e65 5f78 315d   det_outline_x1]
-00037a00: 292e 5429 0a20 2020 2020 2020 2020 2020  ).T).           
-00037a10: 2066 6f72 2061 6120 696e 2072 616e 6765   for aa in range
-00037a20: 286e 6129 3a0a 2020 2020 2020 2020 2020  (na):.          
-00037a30: 2020 2020 2020 705f 6120 3d20 705f 6120        p_a = p_a 
-00037a40: 2620 706c 672e 506f 6c79 676f 6e28 6e70  & plg.Polygon(np
-00037a50: 2e61 7272 6179 285b 0a20 2020 2020 2020  .array([.       
-00037a60: 2020 2020 2020 2020 2020 2020 2061 705f               ap_
-00037a70: 7830 5b61 705f 696e 645b 6161 5d3a 6170  x0[ap_ind[aa]:ap
-00037a80: 5f69 6e64 5b61 612b 315d 5d2c 0a20 2020  _ind[aa+1]],.   
-00037a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00037aa0: 2061 705f 7831 5b61 705f 696e 645b 6161   ap_x1[ap_ind[aa
-00037ab0: 5d3a 6170 5f69 6e64 5b61 612b 315d 5d2c  ]:ap_ind[aa+1]],
-00037ac0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00037ad0: 205d 292e 5429 0a0a 2020 2020 2020 2020   ]).T)..        
-00037ae0: 2020 2020 2020 2020 2320 7374 6f70 2069          # stop i
-00037af0: 6620 6e6f 2069 6e74 6572 7365 6374 696f  f no intersectio
-00037b00: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
-00037b10: 2020 6966 2070 5f61 2e6e 506f 696e 7473    if p_a.nPoints
-00037b20: 2829 203c 2033 3a0a 2020 2020 2020 2020  () < 3:.        
-00037b30: 2020 2020 2020 2020 2020 2020 6973 6f6b              isok
-00037b40: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
-00037b50: 2020 2020 2020 2020 2020 2020 2062 7265               bre
-00037b60: 616b 0a0a 2020 2020 2020 2020 2020 2020  ak..            
-00037b70: 2320 7374 6f70 2069 6620 6e6f 2069 6e74  # stop if no int
-00037b80: 6572 7365 6374 696f 6e0a 2020 2020 2020  ersection.      
-00037b90: 2020 2020 2020 6966 206e 6f74 2069 736f        if not iso
-00037ba0: 6b3a 0a20 2020 2020 2020 2020 2020 2020  k:.             
-00037bb0: 2020 2063 6f6e 7469 6e75 650a 0a20 2020     continue..   
-00037bc0: 2020 2020 2020 2020 2023 202d 2d2d 2d2d           # -----
-00037bd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-00037be0: 2020 2020 2020 2020 2020 2023 2047 6574             # Get
-00037bf0: 2075 6e69 7420 7665 6374 6f72 730a 0a20   unit vectors.. 
-00037c00: 2020 2020 2020 2020 2020 2063 7830 2c20             cx0, 
-00037c10: 6378 3120 3d20 705f 612e 6365 6e74 6572  cx1 = p_a.center
-00037c20: 2830 290a 2020 2020 2020 2020 2020 2020  (0).            
-00037c30: 7578 203d 2064 6574 5f63 656e 7473 5f78  ux = det_cents_x
-00037c40: 5b64 645d 202b 2063 7830 2a64 6574 5f65  [dd] + cx0*det_e
-00037c50: 305f 785b 6464 5d20 2b20 6378 312a 6465  0_x[dd] + cx1*de
-00037c60: 745f 6531 5f78 5b64 645d 202d 2070 7473  t_e1_x[dd] - pts
-00037c70: 5f78 5b70 705d 0a20 2020 2020 2020 2020  _x[pp].         
-00037c80: 2020 2075 7920 3d20 6465 745f 6365 6e74     uy = det_cent
-00037c90: 735f 795b 6464 5d20 2b20 6378 302a 6465  s_y[dd] + cx0*de
-00037ca0: 745f 6530 5f79 5b64 645d 202b 2063 7831  t_e0_y[dd] + cx1
-00037cb0: 2a64 6574 5f65 315f 795b 6464 5d20 2d20  *det_e1_y[dd] - 
-00037cc0: 7074 735f 795b 7070 5d0a 2020 2020 2020  pts_y[pp].      
-00037cd0: 2020 2020 2020 757a 203d 2064 6574 5f63        uz = det_c
-00037ce0: 656e 7473 5f7a 5b64 645d 202b 2063 7830  ents_z[dd] + cx0
-00037cf0: 2a64 6574 5f65 305f 7a5b 6464 5d20 2b20  *det_e0_z[dd] + 
-00037d00: 6378 312a 6465 745f 6531 5f7a 5b64 645d  cx1*det_e1_z[dd]
-00037d10: 202d 2070 7473 5f7a 5b70 705d 0a20 2020   - pts_z[pp].   
-00037d20: 2020 2020 2020 2020 2069 6e76 5f6e 6f72           inv_nor
-00037d30: 6d20 3d20 312e 2f63 5f73 7172 7428 7578  m = 1./c_sqrt(ux
-00037d40: 2a2a 3220 2b20 7579 2a2a 3220 2b20 757a  **2 + uy**2 + uz
-00037d50: 2a2a 3229 0a20 2020 2020 2020 2020 2020  **2).           
-00037d60: 2075 7665 6374 5f78 5b64 642c 2070 705d   uvect_x[dd, pp]
-00037d70: 203d 2075 782a 696e 765f 6e6f 726d 0a20   = ux*inv_norm. 
-00037d80: 2020 2020 2020 2020 2020 2075 7665 6374             uvect
-00037d90: 5f79 5b64 642c 2070 705d 203d 2075 792a  _y[dd, pp] = uy*
-00037da0: 696e 765f 6e6f 726d 0a20 2020 2020 2020  inv_norm.       
-00037db0: 2020 2020 2075 7665 6374 5f7a 5b64 642c       uvect_z[dd,
-00037dc0: 2070 705d 203d 2075 7a2a 696e 765f 6e6f   pp] = uz*inv_no
-00037dd0: 726d 0a0a 2020 2020 2020 2020 2020 2020  rm..            
-00037de0: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
-00037df0: 2d2d 2d2d 2d0a 2020 2020 2020 2020 2020  -----.          
-00037e00: 2020 2320 7265 6275 696c 6420 3364 2070    # rebuild 3d p
-00037e10: 6f6c 7967 6f6e 0a0a 2020 2020 2020 2020  olygon..        
-00037e20: 2020 2020 2320 6368 6563 6b20 6363 770a      # check ccw.
-00037e30: 2020 2020 2020 2020 2020 2020 705f 615f              p_a_
-00037e40: 7830 203d 206e 702e 6173 636f 6e74 6967  x0 = np.ascontig
-00037e50: 756f 7573 6172 7261 7928 6e70 2e61 7272  uousarray(np.arr
-00037e60: 6179 2870 5f61 2e63 6f6e 746f 7572 2830  ay(p_a.contour(0
-00037e70: 2929 5b3a 2c20 305d 290a 2020 2020 2020  ))[:, 0]).      
-00037e80: 2020 2020 2020 705f 615f 7831 203d 206e        p_a_x1 = n
-00037e90: 702e 6173 636f 6e74 6967 756f 7573 6172  p.ascontiguousar
-00037ea0: 7261 7928 6e70 2e61 7272 6179 2870 5f61  ray(np.array(p_a
-00037eb0: 2e63 6f6e 746f 7572 2830 2929 5b3a 2c20  .contour(0))[:, 
-00037ec0: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
-00037ed0: 6966 206e 6f74 205f 6368 6563 6b5f 706f  if not _check_po
-00037ee0: 6c79 676f 6e5f 3264 5f63 6f75 6e74 6572  lygon_2d_counter
-00037ef0: 5f63 6c6f 636b 7769 7365 2870 5f61 5f78  _clockwise(p_a_x
-00037f00: 302c 2070 5f61 5f78 3129 3a0a 2020 2020  0, p_a_x1):.    
-00037f10: 2020 2020 2020 2020 2020 2020 705f 615f              p_a_
-00037f20: 7830 203d 206e 702e 6173 636f 6e74 6967  x0 = np.ascontig
-00037f30: 756f 7573 6172 7261 7928 705f 615f 7830  uousarray(p_a_x0
-00037f40: 5b3a 3a2d 315d 290a 2020 2020 2020 2020  [::-1]).        
-00037f50: 2020 2020 2020 2020 705f 615f 7831 203d          p_a_x1 =
-00037f60: 206e 702e 6173 636f 6e74 6967 756f 7573   np.ascontiguous
-00037f70: 6172 7261 7928 705f 615f 7831 5b3a 3a2d  array(p_a_x1[::-
-00037f80: 315d 290a 0a20 2020 2020 2020 2020 2020  1])..           
-00037f90: 2023 2074 7269 616e 6775 6c61 7465 2062   # triangulate b
-00037fa0: 7920 6561 722d 636c 6970 7069 6e67 2028  y ear-clipping (
-00037fb0: 290a 2020 2020 2020 2020 2020 2020 7472  ).            tr
-00037fc0: 6920 3d20 7472 6961 6e67 756c 6174 655f  i = triangulate_
-00037fd0: 6279 5f65 6172 636c 6970 7069 6e67 5f32  by_earclipping_2
-00037fe0: 6428 0a20 2020 2020 2020 2020 2020 2020  d(.             
-00037ff0: 2020 206e 702e 6173 636f 6e74 6967 756f     np.ascontiguo
-00038000: 7573 6172 7261 7928 5b70 5f61 5f78 302c  usarray([p_a_x0,
-00038010: 2070 5f61 5f78 315d 290a 2020 2020 2020   p_a_x1]).      
-00038020: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-00038030: 2020 2020 2023 202d 2d2d 2d2d 2d2d 2d2d       # ---------
-00038040: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
-00038050: 2020 2020 2020 2023 2063 6f6d 7075 7465         # compute
-00038060: 2073 6f6c 6964 2061 6e67 6c65 0a0a 2020   solid angle..  
-00038070: 2020 2020 2020 2020 2020 2320 6c6f 6f70            # loop
-00038080: 206f 6e20 7472 6961 6e67 6c65 730a 2020   on triangles.  
-00038090: 2020 2020 2020 2020 2020 666f 7220 7474            for tt
-000380a0: 2069 6e20 7261 6e67 6528 7472 692e 7368   in range(tri.sh
-000380b0: 6170 655b 305d 293a 0a0a 2020 2020 2020  ape[0]):..      
-000380c0: 2020 2020 2020 2020 2020 2320 6765 7420            # get 
-000380d0: 7472 6961 6e67 6c65 0a20 2020 2020 2020  triangle.       
-000380e0: 2020 2020 2020 2020 2074 7269 5f78 203d           tri_x =
-000380f0: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00038100: 2020 2020 2020 2064 6574 5f63 656e 7473         det_cents
-00038110: 5f78 5b64 645d 0a20 2020 2020 2020 2020  _x[dd].         
-00038120: 2020 2020 2020 2020 2020 202b 2070 5f61             + p_a
-00038130: 5f78 305b 7472 695b 7474 2c20 3a5d 5d20  _x0[tri[tt, :]] 
-00038140: 2a20 6465 745f 6530 5f78 5b64 645d 0a20  * det_e0_x[dd]. 
-00038150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00038160: 2020 202b 2070 5f61 5f78 315b 7472 695b     + p_a_x1[tri[
-00038170: 7474 2c20 3a5d 5d20 2a20 6465 745f 6531  tt, :]] * det_e1
-00038180: 5f78 5b64 645d 0a20 2020 2020 2020 2020  _x[dd].         
-00038190: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-000381a0: 2020 2020 2020 2020 2074 7269 5f79 203d           tri_y =
-000381b0: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-000381c0: 2020 2020 2020 2064 6574 5f63 656e 7473         det_cents
-000381d0: 5f79 5b64 645d 0a20 2020 2020 2020 2020  _y[dd].         
-000381e0: 2020 2020 2020 2020 2020 202b 2070 5f61             + p_a
-000381f0: 5f78 305b 7472 695b 7474 2c20 3a5d 5d20  _x0[tri[tt, :]] 
-00038200: 2a20 6465 745f 6530 5f79 5b64 645d 0a20  * det_e0_y[dd]. 
-00038210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00038220: 2020 202b 2070 5f61 5f78 315b 7472 695b     + p_a_x1[tri[
-00038230: 7474 2c20 3a5d 5d20 2a20 6465 745f 6531  tt, :]] * det_e1
-00038240: 5f79 5b64 645d 0a20 2020 2020 2020 2020  _y[dd].         
-00038250: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00038260: 2020 2020 2020 2020 2074 7269 5f7a 203d           tri_z =
-00038270: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00038280: 2020 2020 2020 2064 6574 5f63 656e 7473         det_cents
-00038290: 5f7a 5b64 645d 0a20 2020 2020 2020 2020  _z[dd].         
-000382a0: 2020 2020 2020 2020 2020 202b 2070 5f61             + p_a
-000382b0: 5f78 305b 7472 695b 7474 2c20 3a5d 5d20  _x0[tri[tt, :]] 
-000382c0: 2a20 6465 745f 6530 5f7a 5b64 645d 0a20  * det_e0_z[dd]. 
-000382d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000382e0: 2020 202b 2070 5f61 5f78 315b 7472 695b     + p_a_x1[tri[
-000382f0: 7474 2c20 3a5d 5d20 2a20 6465 745f 6531  tt, :]] * det_e1
-00038300: 5f7a 5b64 645d 0a20 2020 2020 2020 2020  _z[dd].         
-00038310: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00038320: 2020 2020 2020 2020 2020 2320 636f 6d70            # comp
-00038330: 7574 6174 696f 6e20 323a 2073 6f6c 6964  utation 2: solid
-00038340: 2061 6e67 6c65 206f 6620 7472 6961 6e67   angle of triang
-00038350: 6c65 2066 726f 6d20 7074 730a 2020 2020  le from pts.    
-00038360: 2020 2020 2020 2020 2020 2020 736f 6c69              soli
-00038370: 645f 616e 676c 655b 6464 2c20 7070 5d20  d_angle[dd, pp] 
-00038380: 2b3d 205f 7374 2e63 6f6d 705f 7361 5f74  += _st.comp_sa_t
-00038390: 7269 280a 2020 2020 2020 2020 2020 2020  ri(.            
-000383a0: 2020 2020 2020 2020 7472 695f 785b 305d          tri_x[0]
-000383b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000383c0: 2020 2020 2020 7472 695f 795b 305d 2c0a        tri_y[0],.
+00037960: 2d2d 2d2d 2d0a 2020 2020 2020 2020 2020  -----.          
+00037970: 2020 2320 636f 6d70 7574 6520 706f 6c79    # compute poly
+00037980: 676f 6e20 696e 7465 7273 6563 7469 6f6e  gon intersection
+00037990: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+000379a0: 636f 6d70 7574 6520 696e 7465 7273 6563  compute intersec
+000379b0: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
+000379c0: 2070 5f61 203d 2070 6c67 2e50 6f6c 7967   p_a = plg.Polyg
+000379d0: 6f6e 286e 702e 6172 7261 7928 5b64 6574  on(np.array([det
+000379e0: 5f6f 7574 6c69 6e65 5f78 302c 2064 6574  _outline_x0, det
+000379f0: 5f6f 7574 6c69 6e65 5f78 315d 292e 5429  _outline_x1]).T)
+00037a00: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00037a10: 2061 6120 696e 2072 616e 6765 286e 6129   aa in range(na)
+00037a20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00037a30: 2020 705f 6120 3d20 705f 6120 2620 706c    p_a = p_a & pl
+00037a40: 672e 506f 6c79 676f 6e28 6e70 2e61 7272  g.Polygon(np.arr
+00037a50: 6179 285b 0a20 2020 2020 2020 2020 2020  ay([.           
+00037a60: 2020 2020 2020 2020 2061 705f 7830 5b61           ap_x0[a
+00037a70: 705f 696e 645b 6161 5d3a 6170 5f69 6e64  p_ind[aa]:ap_ind
+00037a80: 5b61 612b 315d 5d2c 0a20 2020 2020 2020  [aa+1]],.       
+00037a90: 2020 2020 2020 2020 2020 2020 2061 705f               ap_
+00037aa0: 7831 5b61 705f 696e 645b 6161 5d3a 6170  x1[ap_ind[aa]:ap
+00037ab0: 5f69 6e64 5b61 612b 315d 5d2c 0a20 2020  _ind[aa+1]],.   
+00037ac0: 2020 2020 2020 2020 2020 2020 205d 292e               ]).
+00037ad0: 5429 0a0a 2020 2020 2020 2020 2020 2020  T)..            
+00037ae0: 2020 2020 2320 7374 6f70 2069 6620 6e6f      # stop if no
+00037af0: 2069 6e74 6572 7365 6374 696f 6e0a 2020   intersection.  
+00037b00: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00037b10: 2070 5f61 2e6e 506f 696e 7473 2829 203c   p_a.nPoints() <
+00037b20: 2033 3a0a 2020 2020 2020 2020 2020 2020   3:.            
+00037b30: 2020 2020 2020 2020 6973 6f6b 203d 2046          isok = F
+00037b40: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
+00037b50: 2020 2020 2020 2020 2062 7265 616b 0a0a           break..
+00037b60: 2020 2020 2020 2020 2020 2020 2320 7374              # st
+00037b70: 6f70 2069 6620 6e6f 2069 6e74 6572 7365  op if no interse
+00037b80: 6374 696f 6e0a 2020 2020 2020 2020 2020  ction.          
+00037b90: 2020 6966 206e 6f74 2069 736f 6b3a 0a20    if not isok:. 
+00037ba0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00037bb0: 6f6e 7469 6e75 650a 0a20 2020 2020 2020  ontinue..       
+00037bc0: 2020 2020 2023 202d 2d2d 2d2d 2d2d 2d2d       # ---------
+00037bd0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+00037be0: 2020 2020 2020 2023 2047 6574 2075 6e69         # Get uni
+00037bf0: 7420 7665 6374 6f72 730a 0a20 2020 2020  t vectors..     
+00037c00: 2020 2020 2020 2063 7830 2c20 6378 3120         cx0, cx1 
+00037c10: 3d20 705f 612e 6365 6e74 6572 2830 290a  = p_a.center(0).
+00037c20: 2020 2020 2020 2020 2020 2020 7578 203d              ux =
+00037c30: 2064 6574 5f63 656e 7473 5f78 5b64 645d   det_cents_x[dd]
+00037c40: 202b 2063 7830 2a64 6574 5f65 305f 785b   + cx0*det_e0_x[
+00037c50: 6464 5d20 2b20 6378 312a 6465 745f 6531  dd] + cx1*det_e1
+00037c60: 5f78 5b64 645d 202d 2070 7473 5f78 5b70  _x[dd] - pts_x[p
+00037c70: 705d 0a20 2020 2020 2020 2020 2020 2075  p].            u
+00037c80: 7920 3d20 6465 745f 6365 6e74 735f 795b  y = det_cents_y[
+00037c90: 6464 5d20 2b20 6378 302a 6465 745f 6530  dd] + cx0*det_e0
+00037ca0: 5f79 5b64 645d 202b 2063 7831 2a64 6574  _y[dd] + cx1*det
+00037cb0: 5f65 315f 795b 6464 5d20 2d20 7074 735f  _e1_y[dd] - pts_
+00037cc0: 795b 7070 5d0a 2020 2020 2020 2020 2020  y[pp].          
+00037cd0: 2020 757a 203d 2064 6574 5f63 656e 7473    uz = det_cents
+00037ce0: 5f7a 5b64 645d 202b 2063 7830 2a64 6574  _z[dd] + cx0*det
+00037cf0: 5f65 305f 7a5b 6464 5d20 2b20 6378 312a  _e0_z[dd] + cx1*
+00037d00: 6465 745f 6531 5f7a 5b64 645d 202d 2070  det_e1_z[dd] - p
+00037d10: 7473 5f7a 5b70 705d 0a20 2020 2020 2020  ts_z[pp].       
+00037d20: 2020 2020 2069 6e76 5f6e 6f72 6d20 3d20       inv_norm = 
+00037d30: 312e 2f63 5f73 7172 7428 7578 2a2a 3220  1./c_sqrt(ux**2 
+00037d40: 2b20 7579 2a2a 3220 2b20 757a 2a2a 3229  + uy**2 + uz**2)
+00037d50: 0a20 2020 2020 2020 2020 2020 2075 7665  .            uve
+00037d60: 6374 5f78 5b64 642c 2070 705d 203d 2075  ct_x[dd, pp] = u
+00037d70: 782a 696e 765f 6e6f 726d 0a20 2020 2020  x*inv_norm.     
+00037d80: 2020 2020 2020 2075 7665 6374 5f79 5b64         uvect_y[d
+00037d90: 642c 2070 705d 203d 2075 792a 696e 765f  d, pp] = uy*inv_
+00037da0: 6e6f 726d 0a20 2020 2020 2020 2020 2020  norm.           
+00037db0: 2075 7665 6374 5f7a 5b64 642c 2070 705d   uvect_z[dd, pp]
+00037dc0: 203d 2075 7a2a 696e 765f 6e6f 726d 0a0a   = uz*inv_norm..
+00037dd0: 2020 2020 2020 2020 2020 2020 2320 2d2d              # --
+00037de0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00037df0: 2d0a 2020 2020 2020 2020 2020 2020 2320  -.            # 
+00037e00: 7265 6275 696c 6420 3364 2070 6f6c 7967  rebuild 3d polyg
+00037e10: 6f6e 0a0a 2020 2020 2020 2020 2020 2020  on..            
+00037e20: 2320 6368 6563 6b20 6363 770a 2020 2020  # check ccw.    
+00037e30: 2020 2020 2020 2020 705f 615f 7830 203d          p_a_x0 =
+00037e40: 206e 702e 6173 636f 6e74 6967 756f 7573   np.ascontiguous
+00037e50: 6172 7261 7928 6e70 2e61 7272 6179 2870  array(np.array(p
+00037e60: 5f61 2e63 6f6e 746f 7572 2830 2929 5b3a  _a.contour(0))[:
+00037e70: 2c20 305d 290a 2020 2020 2020 2020 2020  , 0]).          
+00037e80: 2020 705f 615f 7831 203d 206e 702e 6173    p_a_x1 = np.as
+00037e90: 636f 6e74 6967 756f 7573 6172 7261 7928  contiguousarray(
+00037ea0: 6e70 2e61 7272 6179 2870 5f61 2e63 6f6e  np.array(p_a.con
+00037eb0: 746f 7572 2830 2929 5b3a 2c20 315d 290a  tour(0))[:, 1]).
+00037ec0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00037ed0: 6f74 205f 6368 6563 6b5f 706f 6c79 676f  ot _check_polygo
+00037ee0: 6e5f 3264 5f63 6f75 6e74 6572 5f63 6c6f  n_2d_counter_clo
+00037ef0: 636b 7769 7365 2870 5f61 5f78 302c 2070  ckwise(p_a_x0, p
+00037f00: 5f61 5f78 3129 3a0a 2020 2020 2020 2020  _a_x1):.        
+00037f10: 2020 2020 2020 2020 705f 615f 7830 203d          p_a_x0 =
+00037f20: 206e 702e 6173 636f 6e74 6967 756f 7573   np.ascontiguous
+00037f30: 6172 7261 7928 705f 615f 7830 5b3a 3a2d  array(p_a_x0[::-
+00037f40: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
+00037f50: 2020 2020 705f 615f 7831 203d 206e 702e      p_a_x1 = np.
+00037f60: 6173 636f 6e74 6967 756f 7573 6172 7261  ascontiguousarra
+00037f70: 7928 705f 615f 7831 5b3a 3a2d 315d 290a  y(p_a_x1[::-1]).
+00037f80: 0a20 2020 2020 2020 2020 2020 2023 2074  .            # t
+00037f90: 7269 616e 6775 6c61 7465 2062 7920 6561  riangulate by ea
+00037fa0: 722d 636c 6970 7069 6e67 2028 290a 2020  r-clipping ().  
+00037fb0: 2020 2020 2020 2020 2020 7472 6920 3d20            tri = 
+00037fc0: 7472 6961 6e67 756c 6174 655f 6279 5f65  triangulate_by_e
+00037fd0: 6172 636c 6970 7069 6e67 5f32 6428 0a20  arclipping_2d(. 
+00037fe0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00037ff0: 702e 6173 636f 6e74 6967 756f 7573 6172  p.ascontiguousar
+00038000: 7261 7928 5b70 5f61 5f78 302c 2070 5f61  ray([p_a_x0, p_a
+00038010: 5f78 315d 290a 2020 2020 2020 2020 2020  _x1]).          
+00038020: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
+00038030: 2023 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   # -------------
+00038040: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2020  ------.         
+00038050: 2020 2023 2063 6f6d 7075 7465 2073 6f6c     # compute sol
+00038060: 6964 2061 6e67 6c65 0a0a 2020 2020 2020  id angle..      
+00038070: 2020 2020 2020 2320 6c6f 6f70 206f 6e20        # loop on 
+00038080: 7472 6961 6e67 6c65 730a 2020 2020 2020  triangles.      
+00038090: 2020 2020 2020 666f 7220 7474 2069 6e20        for tt in 
+000380a0: 7261 6e67 6528 7472 692e 7368 6170 655b  range(tri.shape[
+000380b0: 305d 293a 0a0a 2020 2020 2020 2020 2020  0]):..          
+000380c0: 2020 2020 2020 2320 6765 7420 7472 6961        # get tria
+000380d0: 6e67 6c65 0a20 2020 2020 2020 2020 2020  ngle.           
+000380e0: 2020 2020 2074 7269 5f78 203d 2028 0a20       tri_x = (. 
+000380f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00038100: 2020 2064 6574 5f63 656e 7473 5f78 5b64     det_cents_x[d
+00038110: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
+00038120: 2020 2020 2020 202b 2070 5f61 5f78 305b         + p_a_x0[
+00038130: 7472 695b 7474 2c20 3a5d 5d20 2a20 6465  tri[tt, :]] * de
+00038140: 745f 6530 5f78 5b64 645d 0a20 2020 2020  t_e0_x[dd].     
+00038150: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+00038160: 2070 5f61 5f78 315b 7472 695b 7474 2c20   p_a_x1[tri[tt, 
+00038170: 3a5d 5d20 2a20 6465 745f 6531 5f78 5b64  :]] * det_e1_x[d
+00038180: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
+00038190: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+000381a0: 2020 2020 2074 7269 5f79 203d 2028 0a20       tri_y = (. 
+000381b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000381c0: 2020 2064 6574 5f63 656e 7473 5f79 5b64     det_cents_y[d
+000381d0: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
+000381e0: 2020 2020 2020 202b 2070 5f61 5f78 305b         + p_a_x0[
+000381f0: 7472 695b 7474 2c20 3a5d 5d20 2a20 6465  tri[tt, :]] * de
+00038200: 745f 6530 5f79 5b64 645d 0a20 2020 2020  t_e0_y[dd].     
+00038210: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+00038220: 2070 5f61 5f78 315b 7472 695b 7474 2c20   p_a_x1[tri[tt, 
+00038230: 3a5d 5d20 2a20 6465 745f 6531 5f79 5b64  :]] * det_e1_y[d
+00038240: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
+00038250: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00038260: 2020 2020 2074 7269 5f7a 203d 2028 0a20       tri_z = (. 
+00038270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00038280: 2020 2064 6574 5f63 656e 7473 5f7a 5b64     det_cents_z[d
+00038290: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
+000382a0: 2020 2020 2020 202b 2070 5f61 5f78 305b         + p_a_x0[
+000382b0: 7472 695b 7474 2c20 3a5d 5d20 2a20 6465  tri[tt, :]] * de
+000382c0: 745f 6530 5f7a 5b64 645d 0a20 2020 2020  t_e0_z[dd].     
+000382d0: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+000382e0: 2070 5f61 5f78 315b 7472 695b 7474 2c20   p_a_x1[tri[tt, 
+000382f0: 3a5d 5d20 2a20 6465 745f 6531 5f7a 5b64  :]] * det_e1_z[d
+00038300: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
+00038310: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+00038320: 2020 2020 2020 2320 636f 6d70 7574 6174        # computat
+00038330: 696f 6e20 323a 2073 6f6c 6964 2061 6e67  ion 2: solid ang
+00038340: 6c65 206f 6620 7472 6961 6e67 6c65 2066  le of triangle f
+00038350: 726f 6d20 7074 730a 2020 2020 2020 2020  rom pts.        
+00038360: 2020 2020 2020 2020 736f 6c69 645f 616e          solid_an
+00038370: 676c 655b 6464 2c20 7070 5d20 2b3d 205f  gle[dd, pp] += _
+00038380: 7374 2e63 6f6d 705f 7361 5f74 7269 280a  st.comp_sa_tri(.
+00038390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000383a0: 2020 2020 7472 695f 785b 305d 2c0a 2020      tri_x[0],.  
+000383b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000383c0: 2020 7472 695f 795b 305d 2c0a 2020 2020    tri_y[0],.    
 000383d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000383e0: 2020 2020 7472 695f 7a5b 305d 2c0a 2020      tri_z[0],.  
-000383f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00038400: 2020 7472 695f 785b 315d 2c0a 2020 2020    tri_x[1],.    
-00038410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00038420: 7472 695f 795b 315d 2c0a 2020 2020 2020  tri_y[1],.      
-00038430: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-00038440: 695f 7a5b 315d 2c0a 2020 2020 2020 2020  i_z[1],.        
-00038450: 2020 2020 2020 2020 2020 2020 7472 695f              tri_
-00038460: 785b 325d 2c0a 2020 2020 2020 2020 2020  x[2],.          
-00038470: 2020 2020 2020 2020 2020 7472 695f 795b            tri_y[
-00038480: 325d 2c0a 2020 2020 2020 2020 2020 2020  2],.            
-00038490: 2020 2020 2020 2020 7472 695f 7a5b 325d          tri_z[2]
-000384a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000384b0: 2020 2020 2020 7074 735f 785b 7070 5d2c        pts_x[pp],
-000384c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000384d0: 2020 2020 2070 7473 5f79 5b70 705d 2c0a       pts_y[pp],.
+000383e0: 7472 695f 7a5b 305d 2c0a 2020 2020 2020  tri_z[0],.      
+000383f0: 2020 2020 2020 2020 2020 2020 2020 7472                tr
+00038400: 695f 785b 315d 2c0a 2020 2020 2020 2020  i_x[1],.        
+00038410: 2020 2020 2020 2020 2020 2020 7472 695f              tri_
+00038420: 795b 315d 2c0a 2020 2020 2020 2020 2020  y[1],.          
+00038430: 2020 2020 2020 2020 2020 7472 695f 7a5b            tri_z[
+00038440: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
+00038450: 2020 2020 2020 2020 7472 695f 785b 325d          tri_x[2]
+00038460: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00038470: 2020 2020 2020 7472 695f 795b 325d 2c0a        tri_y[2],.
+00038480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00038490: 2020 2020 7472 695f 7a5b 325d 2c0a 2020      tri_z[2],.  
+000384a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000384b0: 2020 7074 735f 785b 7070 5d2c 0a20 2020    pts_x[pp],.   
+000384c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000384d0: 2070 7473 5f79 5b70 705d 2c0a 2020 2020   pts_y[pp],.    
 000384e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000384f0: 2020 2020 7074 735f 7a5b 7070 5d2c 0a20      pts_z[pp],. 
-00038500: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00038510: 0a0a 2020 2020 2320 2d2d 2d2d 2d2d 2d0a  ..    # -------.
-00038520: 2020 2020 2320 5265 7475 726e 0a0a 0a20      # Return... 
-00038530: 2020 2072 6574 7572 6e20 736f 6c69 645f     return solid_
-00038540: 616e 676c 652c 2075 7665 6374 5f78 2c20  angle, uvect_x, 
-00038550: 7576 6563 745f 792c 2075 7665 6374 5f7a  uvect_y, uvect_z
-00038560: 0a0a 0a64 6566 2063 6f6d 7075 7465 5f73  ...def compute_s
-00038570: 6f6c 6964 5f61 6e67 6c65 5f61 7065 7274  olid_angle_apert
-00038580: 7572 6573 5f76 6973 6962 696c 6974 7928  ures_visibility(
-00038590: 0a20 2020 2023 2070 7473 3a20 636f 6f72  .    # pts: coor
-000385a0: 6469 6e61 7465 7320 6173 2074 6872 6565  dinates as three
-000385b0: 2031 6420 6172 7261 7973 0a20 2020 2064   1d arrays.    d
-000385c0: 6f75 626c 655b 3a3a 315d 2070 7473 5f78  ouble[::1] pts_x
-000385d0: 2c0a 2020 2020 646f 7562 6c65 5b3a 3a31  ,.    double[::1
-000385e0: 5d20 7074 735f 792c 0a20 2020 2064 6f75  ] pts_y,.    dou
-000385f0: 626c 655b 3a3a 315d 2070 7473 5f7a 2c0a  ble[::1] pts_z,.
-00038600: 2020 2020 2320 6465 7465 6374 6f72 733a      # detectors:
-00038610: 2070 6f6c 7967 6f6e 2063 6f6f 7264 696e   polygon coordin
-00038620: 6174 6573 2069 6e20 3264 2028 636f 6d6d  ates in 2d (comm
-00038630: 6f6e 2074 6f20 616c 6c20 6465 7465 6374  on to all detect
-00038640: 6f72 7329 0a20 2020 2064 6f75 626c 655b  ors).    double[
-00038650: 3a3a 315d 2064 6574 5f6f 7574 6c69 6e65  ::1] det_outline
-00038660: 5f78 302c 0a20 2020 2064 6f75 626c 655b  _x0,.    double[
-00038670: 3a3a 315d 2064 6574 5f6f 7574 6c69 6e65  ::1] det_outline
-00038680: 5f78 312c 0a20 2020 2023 2064 6574 6563  _x1,.    # detec
-00038690: 746f 7273 3a20 6365 6e74 6572 7320 636f  tors: centers co
-000386a0: 6f72 6469 6e61 7465 7320 6173 2074 6872  ordinates as thr
-000386b0: 6565 2031 6420 6172 7261 7973 0a20 2020  ee 1d arrays.   
-000386c0: 2064 6f75 626c 655b 3a3a 315d 2064 6574   double[::1] det
-000386d0: 5f63 656e 7473 5f78 2c0a 2020 2020 646f  _cents_x,.    do
-000386e0: 7562 6c65 5b3a 3a31 5d20 6465 745f 6365  uble[::1] det_ce
-000386f0: 6e74 735f 792c 0a20 2020 2064 6f75 626c  nts_y,.    doubl
-00038700: 655b 3a3a 315d 2064 6574 5f63 656e 7473  e[::1] det_cents
-00038710: 5f7a 2c0a 2020 2020 2320 6465 7465 6374  _z,.    # detect
-00038720: 6f72 733a 206e 6f72 6d61 6c20 756e 6974  ors: normal unit
-00038730: 2076 6563 746f 7273 2061 7320 7468 7265   vectors as thre
-00038740: 6520 3164 2061 7272 6179 7320 286e 6420  e 1d arrays (nd 
-00038750: 3d20 6c65 6e28 6465 745f 6e6f 726d 5f78  = len(det_norm_x
-00038760: 2929 0a20 2020 2064 6f75 626c 655b 3a3a  )).    double[::
-00038770: 315d 2064 6574 5f6e 6f72 6d5f 782c 0a20  1] det_norm_x,. 
-00038780: 2020 2064 6f75 626c 655b 3a3a 315d 2064     double[::1] d
-00038790: 6574 5f6e 6f72 6d5f 792c 0a20 2020 2064  et_norm_y,.    d
-000387a0: 6f75 626c 655b 3a3a 315d 2064 6574 5f6e  ouble[::1] det_n
-000387b0: 6f72 6d5f 7a2c 0a20 2020 206e 702e 6e64  orm_z,.    np.nd
-000387c0: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
-000387d0: 696d 3d31 5d20 6465 745f 6530 5f78 2c0a  im=1] det_e0_x,.
-000387e0: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
-000387f0: 6f75 626c 652c 206e 6469 6d3d 315d 2064  ouble, ndim=1] d
-00038800: 6574 5f65 305f 792c 0a20 2020 206e 702e  et_e0_y,.    np.
-00038810: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-00038820: 6e64 696d 3d31 5d20 6465 745f 6530 5f7a  ndim=1] det_e0_z
-00038830: 2c0a 2020 2020 6e70 2e6e 6461 7272 6179  ,.    np.ndarray
-00038840: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
-00038850: 2064 6574 5f65 315f 782c 0a20 2020 206e   det_e1_x,.    n
-00038860: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-00038870: 2c20 6e64 696d 3d31 5d20 6465 745f 6531  , ndim=1] det_e1
-00038880: 5f79 2c0a 2020 2020 6e70 2e6e 6461 7272  _y,.    np.ndarr
-00038890: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
-000388a0: 315d 2064 6574 5f65 315f 7a2c 0a20 2020  1] det_e1_z,.   
-000388b0: 2023 2061 7065 7274 7572 6573 3a20 696e   # apertures: in
-000388c0: 6469 6365 7320 6f66 2066 6972 7374 2063  dices of first c
-000388d0: 6f72 6e65 7220 6f66 2065 6163 6820 6170  orner of each ap
-000388e0: 2070 6f6c 7967 6f6e 3a20 6e61 203d 206c   polygon: na = l
-000388f0: 656e 2861 705f 696e 6429 0a20 2020 206c  en(ap_ind).    l
-00038900: 6f6e 675b 3a3a 315d 2061 705f 696e 642c  ong[::1] ap_ind,
-00038910: 0a20 2020 2023 2061 7065 7274 7572 6573  .    # apertures
-00038920: 3a20 706f 6c79 676f 6e20 636f 6f72 6469  : polygon coordi
-00038930: 6e61 7465 7320 6173 2074 6872 6565 2031  nates as three 1
-00038940: 6420 6172 7261 7973 0a20 2020 206e 702e  d arrays.    np.
-00038950: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-00038960: 6e64 696d 3d31 5d20 6170 5f78 2c0a 2020  ndim=1] ap_x,.  
-00038970: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
-00038980: 626c 652c 206e 6469 6d3d 315d 2061 705f  ble, ndim=1] ap_
-00038990: 792c 0a20 2020 206e 702e 6e64 6172 7261  y,.    np.ndarra
-000389a0: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
-000389b0: 5d20 6170 5f7a 2c0a 2020 2020 2320 6e6f  ] ap_z,.    # no
-000389c0: 726d 616c 2075 6e69 7420 7665 6374 6f72  rmal unit vector
-000389d0: 730a 2020 2020 646f 7562 6c65 5b3a 3a31  s.    double[::1
-000389e0: 5d20 6170 5f6e 6f72 6d5f 782c 0a20 2020  ] ap_norm_x,.   
-000389f0: 2064 6f75 626c 655b 3a3a 315d 2061 705f   double[::1] ap_
-00038a00: 6e6f 726d 5f79 2c0a 2020 2020 646f 7562  norm_y,.    doub
-00038a10: 6c65 5b3a 3a31 5d20 6170 5f6e 6f72 6d5f  le[::1] ap_norm_
-00038a20: 7a2c 0a20 2020 2023 2076 6973 6962 696c  z,.    # visibil
-00038a30: 6974 7920 7465 7374 696e 670a 2020 2020  ity testing.    
-00038a40: 7665 735f 706f 6c79 3d4e 6f6e 652c 0a20  ves_poly=None,. 
-00038a50: 2020 2076 6573 5f6e 6f72 6d3d 4e6f 6e65     ves_norm=None
-00038a60: 2c0a 2020 2020 7665 735f 6c69 6d73 3d4e  ,.    ves_lims=N
-00038a70: 6f6e 652c 0a20 2020 206c 7374 7275 6374  one,.    lstruct
-00038a80: 5f70 6f6c 7978 3d4e 6f6e 652c 0a20 2020  _polyx=None,.   
-00038a90: 206c 7374 7275 6374 5f70 6f6c 7979 3d4e   lstruct_polyy=N
-00038aa0: 6f6e 652c 0a20 2020 206c 7374 7275 6374  one,.    lstruct
-00038ab0: 5f6c 696d 733d 4e6f 6e65 2c0a 2020 2020  _lims=None,.    
-00038ac0: 6c73 7472 7563 745f 6e6c 696d 3d4e 6f6e  lstruct_nlim=Non
-00038ad0: 652c 0a20 2020 206c 7374 7275 6374 5f6e  e,.    lstruct_n
-00038ae0: 6f72 6d78 3d4e 6f6e 652c 0a20 2020 206c  ormx=None,.    l
-00038af0: 7374 7275 6374 5f6e 6f72 6d79 3d4e 6f6e  struct_normy=Non
-00038b00: 652c 0a20 2020 206e 7374 7275 6374 5f74  e,.    nstruct_t
-00038b10: 6f74 3d4e 6f6e 652c 0a20 2020 206e 7374  ot=None,.    nst
-00038b20: 7275 6374 5f6c 696d 3d4e 6f6e 652c 0a20  ruct_lim=None,. 
-00038b30: 2020 206c 6e76 6572 743d 4e6f 6e65 2c0a     lnvert=None,.
-00038b40: 2020 2020 726d 696e 3d4e 6f6e 652c 0a20      rmin=None,. 
-00038b50: 2020 2023 2070 6f73 7369 626c 6520 6578     # possible ex
-00038b60: 7472 6120 7061 7261 6d65 7465 7273 203f  tra parameters ?
-00038b70: 0a20 2020 2064 6f75 626c 6520 6d61 7267  .    double marg
-00038b80: 696e 3d5f 5653 4d41 4c4c 2c0a 2020 2020  in=_VSMALL,.    
-00038b90: 696e 7420 6e75 6d5f 7468 7265 6164 733d  int num_threads=
-00038ba0: 3130 2c0a 293a 0a0a 2020 2020 2320 2d2d  10,.):..    # --
-00038bb0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2320  ---------.    # 
-00038bc0: 4465 636c 6172 6174 696f 6e0a 0a20 2020  Declaration..   
-00038bd0: 2063 6465 6620 696e 7420 6e70 7473 203d   cdef int npts =
-00038be0: 2070 7473 5f78 2e73 697a 650a 2020 2020   pts_x.size.    
-00038bf0: 6364 6566 2069 6e74 206e 6420 3d20 6465  cdef int nd = de
-00038c00: 745f 6365 6e74 735f 782e 7369 7a65 0a20  t_cents_x.size. 
-00038c10: 2020 2063 6465 6620 696e 7420 6e61 203d     cdef int na =
-00038c20: 2061 705f 6e6f 726d 5f78 2e73 697a 650a   ap_norm_x.size.
-00038c30: 2020 2020 6364 6566 2069 6e74 2064 642c      cdef int dd,
-00038c40: 2070 702c 2061 612c 2074 740a 2020 2020   pp, aa, tt.    
-00038c50: 6364 6566 2069 6e74 206e 7061 0a20 2020  cdef int npa.   
-00038c60: 2063 6465 6620 666c 6f61 7420 7363 612c   cdef float sca,
-00038c70: 2073 6361 302c 2073 6361 310a 2020 2020   sca0, sca1.    
-00038c80: 6364 6566 2066 6c6f 6174 206b 690a 2020  cdef float ki.  
-00038c90: 2020 6364 6566 206e 702e 6e64 6172 7261    cdef np.ndarra
-00038ca0: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
-00038cb0: 5d20 6170 5f78 3020 3d20 6e70 2e63 6f70  ] ap_x0 = np.cop
-00038cc0: 7928 6170 5f78 290a 2020 2020 6364 6566  y(ap_x).    cdef
-00038cd0: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
-00038ce0: 6c65 2c20 6e64 696d 3d31 5d20 6170 5f78  le, ndim=1] ap_x
-00038cf0: 3120 3d20 6e70 2e63 6f70 7928 6170 5f78  1 = np.copy(ap_x
-00038d00: 290a 2020 2020 6364 6566 206e 702e 6e64  ).    cdef np.nd
-00038d10: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
-00038d20: 696d 3d31 5d20 705f 615f 7830 0a20 2020  im=1] p_a_x0.   
-00038d30: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
-00038d40: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
-00038d50: 2070 5f61 5f78 310a 2020 2020 6364 6566   p_a_x1.    cdef
-00038d60: 2066 6c6f 6174 2063 7830 2c20 6378 310a   float cx0, cx1.
-00038d70: 2020 2020 6364 6566 2066 6c6f 6174 2075      cdef float u
-00038d80: 782c 2075 792c 2075 7a2c 2069 6e76 5f6e  x, uy, uz, inv_n
-00038d90: 6f72 6d0a 2020 2020 6364 6566 206e 702e  orm.    cdef np.
-00038da0: 6e64 6172 7261 795b 6c6f 6e67 2c20 6e64  ndarray[long, nd
-00038db0: 696d 3d32 5d20 7472 690a 2020 2020 6364  im=2] tri.    cd
-00038dc0: 6566 206e 702e 6e64 6172 7261 795b 646f  ef np.ndarray[do
-00038dd0: 7562 6c65 2c20 6e64 696d 3d31 5d20 7472  uble, ndim=1] tr
-00038de0: 695f 780a 2020 2020 6364 6566 206e 702e  i_x.    cdef np.
-00038df0: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-00038e00: 6e64 696d 3d31 5d20 7472 695f 790a 2020  ndim=1] tri_y.  
-00038e10: 2020 6364 6566 206e 702e 6e64 6172 7261    cdef np.ndarra
-00038e20: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
-00038e30: 5d20 7472 695f 7a0a 0a20 2020 2023 2069  ] tri_z..    # i
-00038e40: 6e69 7469 616c 697a 6520 736f 6c69 6420  nitialize solid 
-00038e50: 616e 676c 6520 6172 7261 7920 7769 7468  angle array with
-00038e60: 207a 6572 6f73 0a20 2020 2063 6465 6620   zeros.    cdef 
-00038e70: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-00038e80: 652c 206e 6469 6d3d 325d 2073 6f6c 6964  e, ndim=2] solid
-00038e90: 5f61 6e67 6c65 203d 206e 702e 7a65 726f  _angle = np.zero
-00038ea0: 7328 286e 642c 206e 7074 7329 2c20 6474  s((nd, npts), dt
-00038eb0: 7970 653d 666c 6f61 7429 0a0a 2020 2020  ype=float)..    
-00038ec0: 2320 2d2d 2d2d 2d2d 2d0a 2020 2020 2320  # -------.    # 
-00038ed0: 436f 6d70 7574 650a 0a20 2020 2066 6f72  Compute..    for
-00038ee0: 2064 6420 696e 2072 616e 6765 286e 6429   dd in range(nd)
-00038ef0: 3a0a 0a20 2020 2020 2020 2023 206c 6f6f  :..        # loo
-00038f00: 7020 323a 206f 6e20 6e70 7473 2028 6f62  p 2: on npts (ob
-00038f10: 7365 7276 6174 696f 6e20 706f 696e 7473  servation points
-00038f20: 290a 2020 2020 2020 2020 666f 7220 7070  ).        for pp
-00038f30: 2069 6e20 7261 6e67 6528 6e70 7473 293a   in range(npts):
-00038f40: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00038f50: 7465 7374 2069 6620 6f6e 2067 6f6f 6420  test if on good 
-00038f60: 7369 6465 206f 6620 6465 7465 6374 6f72  side of detector
-00038f70: 0a20 2020 2020 2020 2020 2020 2073 6361  .            sca
-00038f80: 3020 3d20 280a 2020 2020 2020 2020 2020  0 = (.          
-00038f90: 2020 2020 2020 2870 7473 5f78 5b70 705d        (pts_x[pp]
-00038fa0: 202d 2064 6574 5f63 656e 7473 5f78 5b64   - det_cents_x[d
-00038fb0: 645d 2920 2a20 6465 745f 6e6f 726d 5f78  d]) * det_norm_x
-00038fc0: 5b64 645d 0a20 2020 2020 2020 2020 2020  [dd].           
-00038fd0: 2020 2020 202b 2028 7074 735f 795b 7070       + (pts_y[pp
-00038fe0: 5d20 2d20 6465 745f 6365 6e74 735f 795b  ] - det_cents_y[
-00038ff0: 6464 5d29 202a 2064 6574 5f6e 6f72 6d5f  dd]) * det_norm_
-00039000: 795b 6464 5d0a 2020 2020 2020 2020 2020  y[dd].          
-00039010: 2020 2020 2020 2b20 2870 7473 5f7a 5b70        + (pts_z[p
-00039020: 705d 202d 2064 6574 5f63 656e 7473 5f7a  p] - det_cents_z
-00039030: 5b64 645d 2920 2a20 6465 745f 6e6f 726d  [dd]) * det_norm
-00039040: 5f7a 5b64 645d 0a20 2020 2020 2020 2020  _z[dd].         
-00039050: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
-00039060: 2020 6966 2073 6361 3020 3c3d 2030 3a0a    if sca0 <= 0:.
-00039070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039080: 636f 6e74 696e 7565 0a0a 2020 2020 2020  continue..      
-00039090: 2020 2020 2020 2320 666c 6167 0a20 2020        # flag.   
-000390a0: 2020 2020 2020 2020 2069 736f 6b20 3d20           isok = 
-000390b0: 5472 7565 0a0a 2020 2020 2020 2020 2020  True..          
-000390c0: 2020 2320 6c6f 6f70 2033 3a20 6f6e 206e    # loop 3: on n
-000390d0: 6120 2861 7065 7274 7572 6573 290a 2020  a (apertures).  
-000390e0: 2020 2020 2020 2020 2020 666f 7220 6161            for aa
-000390f0: 2069 6e20 7261 6e67 6528 6e61 293a 0a0a   in range(na):..
-00039100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039110: 2320 7465 7374 2069 6620 6f6e 2067 6f6f  # test if on goo
-00039120: 6420 7369 6465 206f 6620 6170 6572 7475  d side of apertu
-00039130: 7265 0a20 2020 2020 2020 2020 2020 2020  re.             
-00039140: 2020 2073 6361 203d 2028 0a20 2020 2020     sca = (.     
-00039150: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00039160: 7074 735f 785b 7070 5d20 2d20 6170 5f78  pts_x[pp] - ap_x
-00039170: 5b61 705f 696e 645b 6161 5d5d 2920 2a20  [ap_ind[aa]]) * 
-00039180: 6170 5f6e 6f72 6d5f 785b 6161 5d0a 2020  ap_norm_x[aa].  
-00039190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000391a0: 2020 2b20 2870 7473 5f79 5b70 705d 202d    + (pts_y[pp] -
-000391b0: 2061 705f 795b 6170 5f69 6e64 5b61 615d   ap_y[ap_ind[aa]
-000391c0: 5d29 202a 2061 705f 6e6f 726d 5f79 5b61  ]) * ap_norm_y[a
-000391d0: 615d 0a20 2020 2020 2020 2020 2020 2020  a].             
-000391e0: 2020 2020 2020 202b 2028 7074 735f 7a5b         + (pts_z[
-000391f0: 7070 5d20 2d20 6170 5f7a 5b61 705f 696e  pp] - ap_z[ap_in
-00039200: 645b 6161 5d5d 2920 2a20 6170 5f6e 6f72  d[aa]]) * ap_nor
-00039210: 6d5f 7a5b 6161 5d0a 2020 2020 2020 2020  m_z[aa].        
-00039220: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-00039230: 2020 2020 2020 2020 2020 2069 6620 7363             if sc
-00039240: 6120 3c3d 2030 3a0a 2020 2020 2020 2020  a <= 0:.        
-00039250: 2020 2020 2020 2020 2020 2020 6973 6f6b              isok
-00039260: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
-00039270: 2020 2020 2020 2020 2020 2020 2062 7265               bre
-00039280: 616b 0a0a 2020 2020 2020 2020 2020 2020  ak..            
-00039290: 2020 2020 2320 7465 7374 2069 6620 616c      # test if al
-000392a0: 6c20 6170 6572 7475 7265 2070 6f69 6e74  l aperture point
-000392b0: 7320 6361 6e20 6265 2070 726f 6a65 6374  s can be project
-000392c0: 6564 206f 6e20 6465 7465 6374 6f72 2070  ed on detector p
-000392d0: 6c61 6e65 2066 726f 6d20 7074 730a 2020  lane from pts.  
-000392e0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-000392f0: 7220 6c6c 2069 6e20 7261 6e67 6528 6170  r ll in range(ap
-00039300: 5f69 6e64 5b61 615d 2c20 6170 5f69 6e64  _ind[aa], ap_ind
-00039310: 5b61 612b 315d 293a 0a20 2020 2020 2020  [aa+1]):.       
-00039320: 2020 2020 2020 2020 2020 2020 2073 6361               sca
-00039330: 3120 3d20 280a 2020 2020 2020 2020 2020  1 = (.          
-00039340: 2020 2020 2020 2020 2020 2020 2020 2861                (a
-00039350: 705f 785b 6c6c 5d20 2d20 7074 735f 785b  p_x[ll] - pts_x[
-00039360: 7070 5d29 202a 2064 6574 5f6e 6f72 6d5f  pp]) * det_norm_
-00039370: 785b 6464 5d0a 2020 2020 2020 2020 2020  x[dd].          
-00039380: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-00039390: 2861 705f 795b 6c6c 5d20 2d20 7074 735f  (ap_y[ll] - pts_
-000393a0: 795b 7070 5d29 202a 2064 6574 5f6e 6f72  y[pp]) * det_nor
-000393b0: 6d5f 795b 6464 5d0a 2020 2020 2020 2020  m_y[dd].        
-000393c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000393d0: 2b20 2861 705f 7a5b 6c6c 5d20 2d20 7074  + (ap_z[ll] - pt
-000393e0: 735f 7a5b 7070 5d29 202a 2064 6574 5f6e  s_z[pp]) * det_n
-000393f0: 6f72 6d5f 7a5b 6464 5d0a 2020 2020 2020  orm_z[dd].      
-00039400: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00039410: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00039420: 2020 2020 2069 6620 7363 6131 203e 3d20       if sca1 >= 
-00039430: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-00039440: 2020 2020 2020 2020 2020 2069 736f 6b20             isok 
-00039450: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
-00039460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039470: 6272 6561 6b0a 0a20 2020 2020 2020 2020  break..         
-00039480: 2020 2020 2020 2020 2020 2023 2070 726f             # pro
-00039490: 6a65 6374 2069 6e20 3264 0a20 2020 2020  ject in 2d.     
-000394a0: 2020 2020 2020 2020 2020 2020 2020 206b                 k
-000394b0: 203d 202d 2073 6361 3020 2f20 7363 6131   = - sca0 / sca1
-000394c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000394d0: 2020 2020 2050 5f78 203d 2070 7473 5f78       P_x = pts_x
-000394e0: 5b70 705d 202b 206b 202a 2028 6170 5f78  [pp] + k * (ap_x
-000394f0: 5b6c 6c5d 202d 2070 7473 5f78 5b70 705d  [ll] - pts_x[pp]
-00039500: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00039510: 2020 2020 2020 505f 7920 3d20 7074 735f        P_y = pts_
-00039520: 795b 7070 5d20 2b20 6b20 2a20 2861 705f  y[pp] + k * (ap_
-00039530: 795b 6c6c 5d20 2d20 7074 735f 795b 7070  y[ll] - pts_y[pp
-00039540: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-00039550: 2020 2020 2020 2050 5f7a 203d 2070 7473         P_z = pts
-00039560: 5f7a 5b70 705d 202b 206b 202a 2028 6170  _z[pp] + k * (ap
-00039570: 5f7a 5b6c 6c5d 202d 2070 7473 5f7a 5b70  _z[ll] - pts_z[p
-00039580: 705d 290a 0a20 2020 2020 2020 2020 2020  p])..           
-00039590: 2020 2020 2020 2020 2023 2070 726f 6a65           # proje
-000395a0: 6374 2069 6e20 3264 0a20 2020 2020 2020  ct in 2d.       
-000395b0: 2020 2020 2020 2020 2020 2020 2061 705f               ap_
-000395c0: 7830 5b6c 6c5d 203d 2028 0a20 2020 2020  x0[ll] = (.     
-000395d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000395e0: 2020 2028 505f 7820 2d20 6465 745f 6365     (P_x - det_ce
-000395f0: 6e74 735f 785b 6464 5d29 202a 2064 6574  nts_x[dd]) * det
-00039600: 5f65 305f 785b 6464 5d0a 2020 2020 2020  _e0_x[dd].      
-00039610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039620: 2020 2b20 2850 5f79 202d 2064 6574 5f63    + (P_y - det_c
-00039630: 656e 7473 5f79 5b64 645d 2920 2a20 6465  ents_y[dd]) * de
-00039640: 745f 6530 5f79 5b64 645d 0a20 2020 2020  t_e0_y[dd].     
-00039650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039660: 2020 202b 2028 505f 7a20 2d20 6465 745f     + (P_z - det_
-00039670: 6365 6e74 735f 7a5b 6464 5d29 202a 2064  cents_z[dd]) * d
-00039680: 6574 5f65 305f 7a5b 6464 5d0a 2020 2020  et_e0_z[dd].    
-00039690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000396a0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000396b0: 2020 2020 2020 6170 5f78 315b 6c6c 5d20        ap_x1[ll] 
-000396c0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-000396d0: 2020 2020 2020 2020 2020 2020 2850 5f78              (P_x
-000396e0: 202d 2064 6574 5f63 656e 7473 5f78 5b64   - det_cents_x[d
-000396f0: 645d 2920 2a20 6465 745f 6531 5f78 5b64  d]) * det_e1_x[d
-00039700: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
-00039710: 2020 2020 2020 2020 2020 202b 2028 505f             + (P_
-00039720: 7920 2d20 6465 745f 6365 6e74 735f 795b  y - det_cents_y[
-00039730: 6464 5d29 202a 2064 6574 5f65 315f 795b  dd]) * det_e1_y[
-00039740: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-00039750: 2020 2020 2020 2020 2020 2020 2b20 2850              + (P
-00039760: 5f7a 202d 2064 6574 5f63 656e 7473 5f7a  _z - det_cents_z
-00039770: 5b64 645d 2920 2a20 6465 745f 6531 5f7a  [dd]) * det_e1_z
-00039780: 5b64 645d 0a20 2020 2020 2020 2020 2020  [dd].           
-00039790: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-000397a0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-000397b0: 6f74 2069 736f 6b3a 0a20 2020 2020 2020  ot isok:.       
-000397c0: 2020 2020 2020 2020 2020 2020 2062 7265               bre
-000397d0: 616b 0a0a 2020 2020 2020 2020 2020 2020  ak..            
-000397e0: 2320 676f 2074 6f20 6e65 7874 2070 6f69  # go to next poi
-000397f0: 6e74 0a20 2020 2020 2020 2020 2020 2069  nt.            i
-00039800: 6620 6e6f 7420 6973 6f6b 3a0a 2020 2020  f not isok:.    
-00039810: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
-00039820: 696e 7565 0a0a 2020 2020 2020 2020 2020  inue..          
-00039830: 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    # ------------
-00039840: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00039850: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
-00039860: 6f6d 7075 7465 2070 6f6c 7967 6f6e 2069  ompute polygon i
-00039870: 6e74 6572 7365 6374 696f 6e0a 0a20 2020  ntersection..   
-00039880: 2020 2020 2020 2020 2023 2063 6f6d 7075           # compu
-00039890: 7465 2069 6e74 6572 7365 6374 696f 6e0a  te intersection.
-000398a0: 2020 2020 2020 2020 2020 2020 705f 6120              p_a 
-000398b0: 3d20 706c 672e 506f 6c79 676f 6e28 6e70  = plg.Polygon(np
-000398c0: 2e61 7272 6179 285b 6465 745f 6f75 746c  .array([det_outl
-000398d0: 696e 655f 7830 2c20 6465 745f 6f75 746c  ine_x0, det_outl
-000398e0: 696e 655f 7831 5d29 2e54 290a 2020 2020  ine_x1]).T).    
-000398f0: 2020 2020 2020 2020 666f 7220 6161 2069          for aa i
-00039900: 6e20 7261 6e67 6528 6e61 293a 0a20 2020  n range(na):.   
-00039910: 2020 2020 2020 2020 2020 2020 2070 5f61               p_a
-00039920: 203d 2070 5f61 2026 2070 6c67 2e50 6f6c   = p_a & plg.Pol
-00039930: 7967 6f6e 286e 702e 6172 7261 7928 5b0a  ygon(np.array([.
+000384f0: 7074 735f 7a5b 7070 5d2c 0a20 2020 2020  pts_z[pp],.     
+00038500: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+00038510: 2020 2320 2d2d 2d2d 2d2d 2d0a 2020 2020    # -------.    
+00038520: 2320 5265 7475 726e 0a0a 0a20 2020 2072  # Return...    r
+00038530: 6574 7572 6e20 736f 6c69 645f 616e 676c  eturn solid_angl
+00038540: 652c 2075 7665 6374 5f78 2c20 7576 6563  e, uvect_x, uvec
+00038550: 745f 792c 2075 7665 6374 5f7a 0a0a 0a64  t_y, uvect_z...d
+00038560: 6566 2063 6f6d 7075 7465 5f73 6f6c 6964  ef compute_solid
+00038570: 5f61 6e67 6c65 5f61 7065 7274 7572 6573  _angle_apertures
+00038580: 5f76 6973 6962 696c 6974 7928 0a20 2020  _visibility(.   
+00038590: 2023 2070 7473 3a20 636f 6f72 6469 6e61   # pts: coordina
+000385a0: 7465 7320 6173 2074 6872 6565 2031 6420  tes as three 1d 
+000385b0: 6172 7261 7973 0a20 2020 2064 6f75 626c  arrays.    doubl
+000385c0: 655b 3a3a 315d 2070 7473 5f78 2c0a 2020  e[::1] pts_x,.  
+000385d0: 2020 646f 7562 6c65 5b3a 3a31 5d20 7074    double[::1] pt
+000385e0: 735f 792c 0a20 2020 2064 6f75 626c 655b  s_y,.    double[
+000385f0: 3a3a 315d 2070 7473 5f7a 2c0a 2020 2020  ::1] pts_z,.    
+00038600: 2320 6465 7465 6374 6f72 733a 2070 6f6c  # detectors: pol
+00038610: 7967 6f6e 2063 6f6f 7264 696e 6174 6573  ygon coordinates
+00038620: 2069 6e20 3264 2028 636f 6d6d 6f6e 2074   in 2d (common t
+00038630: 6f20 616c 6c20 6465 7465 6374 6f72 7329  o all detectors)
+00038640: 0a20 2020 2064 6f75 626c 655b 3a3a 315d  .    double[::1]
+00038650: 2064 6574 5f6f 7574 6c69 6e65 5f78 302c   det_outline_x0,
+00038660: 0a20 2020 2064 6f75 626c 655b 3a3a 315d  .    double[::1]
+00038670: 2064 6574 5f6f 7574 6c69 6e65 5f78 312c   det_outline_x1,
+00038680: 0a20 2020 2023 2064 6574 6563 746f 7273  .    # detectors
+00038690: 3a20 6365 6e74 6572 7320 636f 6f72 6469  : centers coordi
+000386a0: 6e61 7465 7320 6173 2074 6872 6565 2031  nates as three 1
+000386b0: 6420 6172 7261 7973 0a20 2020 2064 6f75  d arrays.    dou
+000386c0: 626c 655b 3a3a 315d 2064 6574 5f63 656e  ble[::1] det_cen
+000386d0: 7473 5f78 2c0a 2020 2020 646f 7562 6c65  ts_x,.    double
+000386e0: 5b3a 3a31 5d20 6465 745f 6365 6e74 735f  [::1] det_cents_
+000386f0: 792c 0a20 2020 2064 6f75 626c 655b 3a3a  y,.    double[::
+00038700: 315d 2064 6574 5f63 656e 7473 5f7a 2c0a  1] det_cents_z,.
+00038710: 2020 2020 2320 6465 7465 6374 6f72 733a      # detectors:
+00038720: 206e 6f72 6d61 6c20 756e 6974 2076 6563   normal unit vec
+00038730: 746f 7273 2061 7320 7468 7265 6520 3164  tors as three 1d
+00038740: 2061 7272 6179 7320 286e 6420 3d20 6c65   arrays (nd = le
+00038750: 6e28 6465 745f 6e6f 726d 5f78 2929 0a20  n(det_norm_x)). 
+00038760: 2020 2064 6f75 626c 655b 3a3a 315d 2064     double[::1] d
+00038770: 6574 5f6e 6f72 6d5f 782c 0a20 2020 2064  et_norm_x,.    d
+00038780: 6f75 626c 655b 3a3a 315d 2064 6574 5f6e  ouble[::1] det_n
+00038790: 6f72 6d5f 792c 0a20 2020 2064 6f75 626c  orm_y,.    doubl
+000387a0: 655b 3a3a 315d 2064 6574 5f6e 6f72 6d5f  e[::1] det_norm_
+000387b0: 7a2c 0a20 2020 206e 702e 6e64 6172 7261  z,.    np.ndarra
+000387c0: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
+000387d0: 5d20 6465 745f 6530 5f78 2c0a 2020 2020  ] det_e0_x,.    
+000387e0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+000387f0: 652c 206e 6469 6d3d 315d 2064 6574 5f65  e, ndim=1] det_e
+00038800: 305f 792c 0a20 2020 206e 702e 6e64 6172  0_y,.    np.ndar
+00038810: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+00038820: 3d31 5d20 6465 745f 6530 5f7a 2c0a 2020  =1] det_e0_z,.  
+00038830: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
+00038840: 626c 652c 206e 6469 6d3d 315d 2064 6574  ble, ndim=1] det
+00038850: 5f65 315f 782c 0a20 2020 206e 702e 6e64  _e1_x,.    np.nd
+00038860: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
+00038870: 696d 3d31 5d20 6465 745f 6531 5f79 2c0a  im=1] det_e1_y,.
+00038880: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
+00038890: 6f75 626c 652c 206e 6469 6d3d 315d 2064  ouble, ndim=1] d
+000388a0: 6574 5f65 315f 7a2c 0a20 2020 2023 2061  et_e1_z,.    # a
+000388b0: 7065 7274 7572 6573 3a20 696e 6469 6365  pertures: indice
+000388c0: 7320 6f66 2066 6972 7374 2063 6f72 6e65  s of first corne
+000388d0: 7220 6f66 2065 6163 6820 6170 2070 6f6c  r of each ap pol
+000388e0: 7967 6f6e 3a20 6e61 203d 206c 656e 2861  ygon: na = len(a
+000388f0: 705f 696e 6429 0a20 2020 206c 6f6e 675b  p_ind).    long[
+00038900: 3a3a 315d 2061 705f 696e 642c 0a20 2020  ::1] ap_ind,.   
+00038910: 2023 2061 7065 7274 7572 6573 3a20 706f   # apertures: po
+00038920: 6c79 676f 6e20 636f 6f72 6469 6e61 7465  lygon coordinate
+00038930: 7320 6173 2074 6872 6565 2031 6420 6172  s as three 1d ar
+00038940: 7261 7973 0a20 2020 206e 702e 6e64 6172  rays.    np.ndar
+00038950: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+00038960: 3d31 5d20 6170 5f78 2c0a 2020 2020 6e70  =1] ap_x,.    np
+00038970: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
+00038980: 206e 6469 6d3d 315d 2061 705f 792c 0a20   ndim=1] ap_y,. 
+00038990: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
+000389a0: 7562 6c65 2c20 6e64 696d 3d31 5d20 6170  uble, ndim=1] ap
+000389b0: 5f7a 2c0a 2020 2020 2320 6e6f 726d 616c  _z,.    # normal
+000389c0: 2075 6e69 7420 7665 6374 6f72 730a 2020   unit vectors.  
+000389d0: 2020 646f 7562 6c65 5b3a 3a31 5d20 6170    double[::1] ap
+000389e0: 5f6e 6f72 6d5f 782c 0a20 2020 2064 6f75  _norm_x,.    dou
+000389f0: 626c 655b 3a3a 315d 2061 705f 6e6f 726d  ble[::1] ap_norm
+00038a00: 5f79 2c0a 2020 2020 646f 7562 6c65 5b3a  _y,.    double[:
+00038a10: 3a31 5d20 6170 5f6e 6f72 6d5f 7a2c 0a20  :1] ap_norm_z,. 
+00038a20: 2020 2023 2076 6973 6962 696c 6974 7920     # visibility 
+00038a30: 7465 7374 696e 670a 2020 2020 7665 735f  testing.    ves_
+00038a40: 706f 6c79 3d4e 6f6e 652c 0a20 2020 2076  poly=None,.    v
+00038a50: 6573 5f6e 6f72 6d3d 4e6f 6e65 2c0a 2020  es_norm=None,.  
+00038a60: 2020 7665 735f 6c69 6d73 3d4e 6f6e 652c    ves_lims=None,
+00038a70: 0a20 2020 206c 7374 7275 6374 5f70 6f6c  .    lstruct_pol
+00038a80: 7978 3d4e 6f6e 652c 0a20 2020 206c 7374  yx=None,.    lst
+00038a90: 7275 6374 5f70 6f6c 7979 3d4e 6f6e 652c  ruct_polyy=None,
+00038aa0: 0a20 2020 206c 7374 7275 6374 5f6c 696d  .    lstruct_lim
+00038ab0: 733d 4e6f 6e65 2c0a 2020 2020 6c73 7472  s=None,.    lstr
+00038ac0: 7563 745f 6e6c 696d 3d4e 6f6e 652c 0a20  uct_nlim=None,. 
+00038ad0: 2020 206c 7374 7275 6374 5f6e 6f72 6d78     lstruct_normx
+00038ae0: 3d4e 6f6e 652c 0a20 2020 206c 7374 7275  =None,.    lstru
+00038af0: 6374 5f6e 6f72 6d79 3d4e 6f6e 652c 0a20  ct_normy=None,. 
+00038b00: 2020 206e 7374 7275 6374 5f74 6f74 3d4e     nstruct_tot=N
+00038b10: 6f6e 652c 0a20 2020 206e 7374 7275 6374  one,.    nstruct
+00038b20: 5f6c 696d 3d4e 6f6e 652c 0a20 2020 206c  _lim=None,.    l
+00038b30: 6e76 6572 743d 4e6f 6e65 2c0a 2020 2020  nvert=None,.    
+00038b40: 726d 696e 3d4e 6f6e 652c 0a20 2020 2023  rmin=None,.    #
+00038b50: 2070 6f73 7369 626c 6520 6578 7472 6120   possible extra 
+00038b60: 7061 7261 6d65 7465 7273 203f 0a20 2020  parameters ?.   
+00038b70: 2064 6f75 626c 6520 6d61 7267 696e 3d5f   double margin=_
+00038b80: 5653 4d41 4c4c 2c0a 2020 2020 696e 7420  VSMALL,.    int 
+00038b90: 6e75 6d5f 7468 7265 6164 733d 3130 2c0a  num_threads=10,.
+00038ba0: 293a 0a0a 2020 2020 2320 2d2d 2d2d 2d2d  ):..    # ------
+00038bb0: 2d2d 2d2d 2d0a 2020 2020 2320 4465 636c  -----.    # Decl
+00038bc0: 6172 6174 696f 6e0a 0a20 2020 2063 6465  aration..    cde
+00038bd0: 6620 696e 7420 6e70 7473 203d 2070 7473  f int npts = pts
+00038be0: 5f78 2e73 697a 650a 2020 2020 6364 6566  _x.size.    cdef
+00038bf0: 2069 6e74 206e 6420 3d20 6465 745f 6365   int nd = det_ce
+00038c00: 6e74 735f 782e 7369 7a65 0a20 2020 2063  nts_x.size.    c
+00038c10: 6465 6620 696e 7420 6e61 203d 2061 705f  def int na = ap_
+00038c20: 6e6f 726d 5f78 2e73 697a 650a 2020 2020  norm_x.size.    
+00038c30: 6364 6566 2069 6e74 2064 642c 2070 702c  cdef int dd, pp,
+00038c40: 2061 612c 2074 740a 2020 2020 6364 6566   aa, tt.    cdef
+00038c50: 2069 6e74 206e 7061 0a20 2020 2063 6465   int npa.    cde
+00038c60: 6620 666c 6f61 7420 7363 612c 2073 6361  f float sca, sca
+00038c70: 302c 2073 6361 310a 2020 2020 6364 6566  0, sca1.    cdef
+00038c80: 2066 6c6f 6174 206b 690a 2020 2020 6364   float ki.    cd
+00038c90: 6566 206e 702e 6e64 6172 7261 795b 646f  ef np.ndarray[do
+00038ca0: 7562 6c65 2c20 6e64 696d 3d31 5d20 6170  uble, ndim=1] ap
+00038cb0: 5f78 3020 3d20 6e70 2e63 6f70 7928 6170  _x0 = np.copy(ap
+00038cc0: 5f78 290a 2020 2020 6364 6566 206e 702e  _x).    cdef np.
+00038cd0: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
+00038ce0: 6e64 696d 3d31 5d20 6170 5f78 3120 3d20  ndim=1] ap_x1 = 
+00038cf0: 6e70 2e63 6f70 7928 6170 5f78 290a 2020  np.copy(ap_x).  
+00038d00: 2020 6364 6566 206e 702e 6e64 6172 7261    cdef np.ndarra
+00038d10: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
+00038d20: 5d20 705f 615f 7830 0a20 2020 2063 6465  ] p_a_x0.    cde
+00038d30: 6620 6e70 2e6e 6461 7272 6179 5b64 6f75  f np.ndarray[dou
+00038d40: 626c 652c 206e 6469 6d3d 315d 2070 5f61  ble, ndim=1] p_a
+00038d50: 5f78 310a 2020 2020 6364 6566 2066 6c6f  _x1.    cdef flo
+00038d60: 6174 2063 7830 2c20 6378 310a 2020 2020  at cx0, cx1.    
+00038d70: 6364 6566 2066 6c6f 6174 2075 782c 2075  cdef float ux, u
+00038d80: 792c 2075 7a2c 2069 6e76 5f6e 6f72 6d0a  y, uz, inv_norm.
+00038d90: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+00038da0: 7261 795b 6c6f 6e67 2c20 6e64 696d 3d32  ray[long, ndim=2
+00038db0: 5d20 7472 690a 2020 2020 6364 6566 206e  ] tri.    cdef n
+00038dc0: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+00038dd0: 2c20 6e64 696d 3d31 5d20 7472 695f 780a  , ndim=1] tri_x.
+00038de0: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
+00038df0: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+00038e00: 3d31 5d20 7472 695f 790a 2020 2020 6364  =1] tri_y.    cd
+00038e10: 6566 206e 702e 6e64 6172 7261 795b 646f  ef np.ndarray[do
+00038e20: 7562 6c65 2c20 6e64 696d 3d31 5d20 7472  uble, ndim=1] tr
+00038e30: 695f 7a0a 0a20 2020 2023 2069 6e69 7469  i_z..    # initi
+00038e40: 616c 697a 6520 736f 6c69 6420 616e 676c  alize solid angl
+00038e50: 6520 6172 7261 7920 7769 7468 207a 6572  e array with zer
+00038e60: 6f73 0a20 2020 2063 6465 6620 6e70 2e6e  os.    cdef np.n
+00038e70: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+00038e80: 6469 6d3d 325d 2073 6f6c 6964 5f61 6e67  dim=2] solid_ang
+00038e90: 6c65 203d 206e 702e 7a65 726f 7328 286e  le = np.zeros((n
+00038ea0: 642c 206e 7074 7329 2c20 6474 7970 653d  d, npts), dtype=
+00038eb0: 666c 6f61 7429 0a0a 2020 2020 2320 2d2d  float)..    # --
+00038ec0: 2d2d 2d2d 2d0a 2020 2020 2320 436f 6d70  -----.    # Comp
+00038ed0: 7574 650a 0a20 2020 2066 6f72 2064 6420  ute..    for dd 
+00038ee0: 696e 2072 616e 6765 286e 6429 3a0a 0a20  in range(nd):.. 
+00038ef0: 2020 2020 2020 2023 206c 6f6f 7020 323a         # loop 2:
+00038f00: 206f 6e20 6e70 7473 2028 6f62 7365 7276   on npts (observ
+00038f10: 6174 696f 6e20 706f 696e 7473 290a 2020  ation points).  
+00038f20: 2020 2020 2020 666f 7220 7070 2069 6e20        for pp in 
+00038f30: 7261 6e67 6528 6e70 7473 293a 0a0a 2020  range(npts):..  
+00038f40: 2020 2020 2020 2020 2020 2320 7465 7374            # test
+00038f50: 2069 6620 6f6e 2067 6f6f 6420 7369 6465   if on good side
+00038f60: 206f 6620 6465 7465 6374 6f72 0a20 2020   of detector.   
+00038f70: 2020 2020 2020 2020 2073 6361 3020 3d20           sca0 = 
+00038f80: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00038f90: 2020 2870 7473 5f78 5b70 705d 202d 2064    (pts_x[pp] - d
+00038fa0: 6574 5f63 656e 7473 5f78 5b64 645d 2920  et_cents_x[dd]) 
+00038fb0: 2a20 6465 745f 6e6f 726d 5f78 5b64 645d  * det_norm_x[dd]
+00038fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00038fd0: 202b 2028 7074 735f 795b 7070 5d20 2d20   + (pts_y[pp] - 
+00038fe0: 6465 745f 6365 6e74 735f 795b 6464 5d29  det_cents_y[dd])
+00038ff0: 202a 2064 6574 5f6e 6f72 6d5f 795b 6464   * det_norm_y[dd
+00039000: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00039010: 2020 2b20 2870 7473 5f7a 5b70 705d 202d    + (pts_z[pp] -
+00039020: 2064 6574 5f63 656e 7473 5f7a 5b64 645d   det_cents_z[dd]
+00039030: 2920 2a20 6465 745f 6e6f 726d 5f7a 5b64  ) * det_norm_z[d
+00039040: 645d 0a20 2020 2020 2020 2020 2020 2029  d].            )
+00039050: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
+00039060: 2073 6361 3020 3c3d 2030 3a0a 2020 2020   sca0 <= 0:.    
+00039070: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+00039080: 696e 7565 0a0a 2020 2020 2020 2020 2020  inue..          
+00039090: 2020 2320 666c 6167 0a20 2020 2020 2020    # flag.       
+000390a0: 2020 2020 2069 736f 6b20 3d20 5472 7565       isok = True
+000390b0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+000390c0: 6c6f 6f70 2033 3a20 6f6e 206e 6120 2861  loop 3: on na (a
+000390d0: 7065 7274 7572 6573 290a 2020 2020 2020  pertures).      
+000390e0: 2020 2020 2020 666f 7220 6161 2069 6e20        for aa in 
+000390f0: 7261 6e67 6528 6e61 293a 0a0a 2020 2020  range(na):..    
+00039100: 2020 2020 2020 2020 2020 2020 2320 7465              # te
+00039110: 7374 2069 6620 6f6e 2067 6f6f 6420 7369  st if on good si
+00039120: 6465 206f 6620 6170 6572 7475 7265 0a20  de of aperture. 
+00039130: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00039140: 6361 203d 2028 0a20 2020 2020 2020 2020  ca = (.         
+00039150: 2020 2020 2020 2020 2020 2028 7074 735f             (pts_
+00039160: 785b 7070 5d20 2d20 6170 5f78 5b61 705f  x[pp] - ap_x[ap_
+00039170: 696e 645b 6161 5d5d 2920 2a20 6170 5f6e  ind[aa]]) * ap_n
+00039180: 6f72 6d5f 785b 6161 5d0a 2020 2020 2020  orm_x[aa].      
+00039190: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+000391a0: 2870 7473 5f79 5b70 705d 202d 2061 705f  (pts_y[pp] - ap_
+000391b0: 795b 6170 5f69 6e64 5b61 615d 5d29 202a  y[ap_ind[aa]]) *
+000391c0: 2061 705f 6e6f 726d 5f79 5b61 615d 0a20   ap_norm_y[aa]. 
+000391d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000391e0: 2020 202b 2028 7074 735f 7a5b 7070 5d20     + (pts_z[pp] 
+000391f0: 2d20 6170 5f7a 5b61 705f 696e 645b 6161  - ap_z[ap_ind[aa
+00039200: 5d5d 2920 2a20 6170 5f6e 6f72 6d5f 7a5b  ]]) * ap_norm_z[
+00039210: 6161 5d0a 2020 2020 2020 2020 2020 2020  aa].            
+00039220: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+00039230: 2020 2020 2020 2069 6620 7363 6120 3c3d         if sca <=
+00039240: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00039250: 2020 2020 2020 2020 6973 6f6b 203d 2046          isok = F
+00039260: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
+00039270: 2020 2020 2020 2020 2062 7265 616b 0a0a           break..
+00039280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039290: 2320 7465 7374 2069 6620 616c 6c20 6170  # test if all ap
+000392a0: 6572 7475 7265 2070 6f69 6e74 7320 6361  erture points ca
+000392b0: 6e20 6265 2070 726f 6a65 6374 6564 206f  n be projected o
+000392c0: 6e20 6465 7465 6374 6f72 2070 6c61 6e65  n detector plane
+000392d0: 2066 726f 6d20 7074 730a 2020 2020 2020   from pts.      
+000392e0: 2020 2020 2020 2020 2020 666f 7220 6c6c            for ll
+000392f0: 2069 6e20 7261 6e67 6528 6170 5f69 6e64   in range(ap_ind
+00039300: 5b61 615d 2c20 6170 5f69 6e64 5b61 612b  [aa], ap_ind[aa+
+00039310: 315d 293a 0a20 2020 2020 2020 2020 2020  1]):.           
+00039320: 2020 2020 2020 2020 2073 6361 3120 3d20           sca1 = 
+00039330: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00039340: 2020 2020 2020 2020 2020 2861 705f 785b            (ap_x[
+00039350: 6c6c 5d20 2d20 7074 735f 785b 7070 5d29  ll] - pts_x[pp])
+00039360: 202a 2064 6574 5f6e 6f72 6d5f 785b 6464   * det_norm_x[dd
+00039370: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00039380: 2020 2020 2020 2020 2020 2b20 2861 705f            + (ap_
+00039390: 795b 6c6c 5d20 2d20 7074 735f 795b 7070  y[ll] - pts_y[pp
+000393a0: 5d29 202a 2064 6574 5f6e 6f72 6d5f 795b  ]) * det_norm_y[
+000393b0: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+000393c0: 2020 2020 2020 2020 2020 2020 2b20 2861              + (a
+000393d0: 705f 7a5b 6c6c 5d20 2d20 7074 735f 7a5b  p_z[ll] - pts_z[
+000393e0: 7070 5d29 202a 2064 6574 5f6e 6f72 6d5f  pp]) * det_norm_
+000393f0: 7a5b 6464 5d0a 2020 2020 2020 2020 2020  z[dd].          
+00039400: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+00039410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039420: 2069 6620 7363 6131 203e 3d20 303a 0a20   if sca1 >= 0:. 
+00039430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039440: 2020 2020 2020 2069 736f 6b20 3d20 4661         isok = Fa
+00039450: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
+00039460: 2020 2020 2020 2020 2020 2020 6272 6561              brea
+00039470: 6b0a 0a20 2020 2020 2020 2020 2020 2020  k..             
+00039480: 2020 2020 2020 2023 2070 726f 6a65 6374         # project
+00039490: 2069 6e20 3264 0a20 2020 2020 2020 2020   in 2d.         
+000394a0: 2020 2020 2020 2020 2020 206b 203d 202d             k = -
+000394b0: 2073 6361 3020 2f20 7363 6131 0a20 2020   sca0 / sca1.   
+000394c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000394d0: 2050 5f78 203d 2070 7473 5f78 5b70 705d   P_x = pts_x[pp]
+000394e0: 202b 206b 202a 2028 6170 5f78 5b6c 6c5d   + k * (ap_x[ll]
+000394f0: 202d 2070 7473 5f78 5b70 705d 290a 2020   - pts_x[pp]).  
+00039500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039510: 2020 505f 7920 3d20 7074 735f 795b 7070    P_y = pts_y[pp
+00039520: 5d20 2b20 6b20 2a20 2861 705f 795b 6c6c  ] + k * (ap_y[ll
+00039530: 5d20 2d20 7074 735f 795b 7070 5d29 0a20  ] - pts_y[pp]). 
+00039540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039550: 2020 2050 5f7a 203d 2070 7473 5f7a 5b70     P_z = pts_z[p
+00039560: 705d 202b 206b 202a 2028 6170 5f7a 5b6c  p] + k * (ap_z[l
+00039570: 6c5d 202d 2070 7473 5f7a 5b70 705d 290a  l] - pts_z[pp]).
+00039580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00039590: 2020 2020 2023 2070 726f 6a65 6374 2069       # project i
+000395a0: 6e20 3264 0a20 2020 2020 2020 2020 2020  n 2d.           
+000395b0: 2020 2020 2020 2020 2061 705f 7830 5b6c           ap_x0[l
+000395c0: 6c5d 203d 2028 0a20 2020 2020 2020 2020  l] = (.         
+000395d0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+000395e0: 505f 7820 2d20 6465 745f 6365 6e74 735f  P_x - det_cents_
+000395f0: 785b 6464 5d29 202a 2064 6574 5f65 305f  x[dd]) * det_e0_
+00039600: 785b 6464 5d0a 2020 2020 2020 2020 2020  x[dd].          
+00039610: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+00039620: 2850 5f79 202d 2064 6574 5f63 656e 7473  (P_y - det_cents
+00039630: 5f79 5b64 645d 2920 2a20 6465 745f 6530  _y[dd]) * det_e0
+00039640: 5f79 5b64 645d 0a20 2020 2020 2020 2020  _y[dd].         
+00039650: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+00039660: 2028 505f 7a20 2d20 6465 745f 6365 6e74   (P_z - det_cent
+00039670: 735f 7a5b 6464 5d29 202a 2064 6574 5f65  s_z[dd]) * det_e
+00039680: 305f 7a5b 6464 5d0a 2020 2020 2020 2020  0_z[dd].        
+00039690: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+000396a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000396b0: 2020 6170 5f78 315b 6c6c 5d20 3d20 280a    ap_x1[ll] = (.
+000396c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000396d0: 2020 2020 2020 2020 2850 5f78 202d 2064          (P_x - d
+000396e0: 6574 5f63 656e 7473 5f78 5b64 645d 2920  et_cents_x[dd]) 
+000396f0: 2a20 6465 745f 6531 5f78 5b64 645d 0a20  * det_e1_x[dd]. 
+00039700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039710: 2020 2020 2020 202b 2028 505f 7920 2d20         + (P_y - 
+00039720: 6465 745f 6365 6e74 735f 795b 6464 5d29  det_cents_y[dd])
+00039730: 202a 2064 6574 5f65 315f 795b 6464 5d0a   * det_e1_y[dd].
+00039740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039750: 2020 2020 2020 2020 2b20 2850 5f7a 202d          + (P_z -
+00039760: 2064 6574 5f63 656e 7473 5f7a 5b64 645d   det_cents_z[dd]
+00039770: 2920 2a20 6465 745f 6531 5f7a 5b64 645d  ) * det_e1_z[dd]
+00039780: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00039790: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+000397a0: 2020 2020 2020 2020 6966 206e 6f74 2069          if not i
+000397b0: 736f 6b3a 0a20 2020 2020 2020 2020 2020  sok:.           
+000397c0: 2020 2020 2020 2020 2062 7265 616b 0a0a           break..
+000397d0: 2020 2020 2020 2020 2020 2020 2320 676f              # go
+000397e0: 2074 6f20 6e65 7874 2070 6f69 6e74 0a20   to next point. 
+000397f0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00039800: 7420 6973 6f6b 3a0a 2020 2020 2020 2020  t isok:.        
+00039810: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+00039820: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+00039830: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00039840: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020  ------------.   
+00039850: 2020 2020 2020 2020 2023 2063 6f6d 7075           # compu
+00039860: 7465 2070 6f6c 7967 6f6e 2069 6e74 6572  te polygon inter
+00039870: 7365 6374 696f 6e0a 0a20 2020 2020 2020  section..       
+00039880: 2020 2020 2023 2063 6f6d 7075 7465 2069       # compute i
+00039890: 6e74 6572 7365 6374 696f 6e0a 2020 2020  ntersection.    
+000398a0: 2020 2020 2020 2020 705f 6120 3d20 706c          p_a = pl
+000398b0: 672e 506f 6c79 676f 6e28 6e70 2e61 7272  g.Polygon(np.arr
+000398c0: 6179 285b 6465 745f 6f75 746c 696e 655f  ay([det_outline_
+000398d0: 7830 2c20 6465 745f 6f75 746c 696e 655f  x0, det_outline_
+000398e0: 7831 5d29 2e54 290a 2020 2020 2020 2020  x1]).T).        
+000398f0: 2020 2020 666f 7220 6161 2069 6e20 7261      for aa in ra
+00039900: 6e67 6528 6e61 293a 0a20 2020 2020 2020  nge(na):.       
+00039910: 2020 2020 2020 2020 2070 5f61 203d 2070           p_a = p
+00039920: 5f61 2026 2070 6c67 2e50 6f6c 7967 6f6e  _a & plg.Polygon
+00039930: 286e 702e 6172 7261 7928 5b0a 2020 2020  (np.array([.    
 00039940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039950: 2020 2020 6170 5f78 305b 6170 5f69 6e64      ap_x0[ap_ind
-00039960: 5b61 615d 3a61 705f 696e 645b 6161 2b31  [aa]:ap_ind[aa+1
-00039970: 5d5d 2c0a 2020 2020 2020 2020 2020 2020  ]],.            
-00039980: 2020 2020 2020 2020 6170 5f78 315b 6170          ap_x1[ap
-00039990: 5f69 6e64 5b61 615d 3a61 705f 696e 645b  _ind[aa]:ap_ind[
-000399a0: 6161 2b31 5d5d 2c0a 2020 2020 2020 2020  aa+1]],.        
-000399b0: 2020 2020 2020 2020 5d29 2e54 290a 0a20          ]).T).. 
-000399c0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000399d0: 2073 746f 7020 6966 206e 6f20 696e 7465   stop if no inte
-000399e0: 7273 6563 7469 6f6e 0a20 2020 2020 2020  rsection.       
-000399f0: 2020 2020 2020 2020 2069 6620 705f 612e           if p_a.
-00039a00: 6e50 6f69 6e74 7328 2920 3c20 333a 0a20  nPoints() < 3:. 
-00039a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039a20: 2020 2069 736f 6b20 3d20 4661 6c73 650a     isok = False.
+00039950: 6170 5f78 305b 6170 5f69 6e64 5b61 615d  ap_x0[ap_ind[aa]
+00039960: 3a61 705f 696e 645b 6161 2b31 5d5d 2c0a  :ap_ind[aa+1]],.
+00039970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039980: 2020 2020 6170 5f78 315b 6170 5f69 6e64      ap_x1[ap_ind
+00039990: 5b61 615d 3a61 705f 696e 645b 6161 2b31  [aa]:ap_ind[aa+1
+000399a0: 5d5d 2c0a 2020 2020 2020 2020 2020 2020  ]],.            
+000399b0: 2020 2020 5d29 2e54 290a 0a20 2020 2020      ]).T)..     
+000399c0: 2020 2020 2020 2020 2020 2023 2073 746f             # sto
+000399d0: 7020 6966 206e 6f20 696e 7465 7273 6563  p if no intersec
+000399e0: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
+000399f0: 2020 2020 2069 6620 705f 612e 6e50 6f69       if p_a.nPoi
+00039a00: 6e74 7328 2920 3c20 333a 0a20 2020 2020  nts() < 3:.     
+00039a10: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00039a20: 736f 6b20 3d20 4661 6c73 650a 2020 2020  sok = False.    
 00039a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039a40: 2020 2020 6272 6561 6b0a 0a20 2020 2020      break..     
-00039a50: 2020 2020 2020 2023 2073 746f 7020 6966         # stop if
-00039a60: 206e 6f20 696e 7465 7273 6563 7469 6f6e   no intersection
-00039a70: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00039a80: 6e6f 7420 6973 6f6b 3a0a 2020 2020 2020  not isok:.      
-00039a90: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00039aa0: 7565 0a0a 2020 2020 2020 2020 2020 2020  ue..            
-00039ab0: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
-00039ac0: 2d2d 2d2d 2d0a 2020 2020 2020 2020 2020  -----.          
-00039ad0: 2020 2320 4765 7420 756e 6974 2076 6563    # Get unit vec
-00039ae0: 746f 720a 0a20 2020 2020 2020 2020 2020  tor..           
-00039af0: 2063 7830 2c20 6378 3120 3d20 705f 612e   cx0, cx1 = p_a.
-00039b00: 6365 6e74 6572 2830 290a 2020 2020 2020  center(0).      
-00039b10: 2020 2020 2020 6378 203d 2064 6574 5f63        cx = det_c
-00039b20: 656e 7473 5f78 5b64 645d 202b 2063 7830  ents_x[dd] + cx0
-00039b30: 2a64 6574 5f65 305f 785b 6464 5d20 2b20  *det_e0_x[dd] + 
-00039b40: 6378 312a 6465 745f 6531 5f78 5b64 645d  cx1*det_e1_x[dd]
-00039b50: 0a20 2020 2020 2020 2020 2020 2063 7920  .            cy 
-00039b60: 3d20 6465 745f 6365 6e74 735f 795b 6464  = det_cents_y[dd
-00039b70: 5d20 2b20 6378 302a 6465 745f 6530 5f79  ] + cx0*det_e0_y
-00039b80: 5b64 645d 202b 2063 7831 2a64 6574 5f65  [dd] + cx1*det_e
-00039b90: 315f 795b 6464 5d0a 2020 2020 2020 2020  1_y[dd].        
-00039ba0: 2020 2020 637a 203d 2064 6574 5f63 656e      cz = det_cen
-00039bb0: 7473 5f7a 5b64 645d 202b 2063 7830 2a64  ts_z[dd] + cx0*d
-00039bc0: 6574 5f65 305f 7a5b 6464 5d20 2b20 6378  et_e0_z[dd] + cx
-00039bd0: 312a 6465 745f 6531 5f7a 5b64 645d 0a0a  1*det_e1_z[dd]..
-00039be0: 2020 2020 2020 2020 2020 2020 2320 6368              # ch
-00039bf0: 6563 6b20 7669 7369 6269 6c69 7479 0a20  eck visibility. 
-00039c00: 2020 2020 2020 2020 2020 2076 6973 203d             vis =
-00039c10: 204c 4f53 5f69 7356 6973 5f50 7446 726f   LOS_isVis_PtFro
-00039c20: 6d50 7473 5f56 6573 5374 7275 6374 280a  mPts_VesStruct(.
-00039c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039c40: 6378 2c0a 2020 2020 2020 2020 2020 2020  cx,.            
-00039c50: 2020 2020 6379 2c0a 2020 2020 2020 2020      cy,.        
-00039c60: 2020 2020 2020 2020 637a 2c0a 2020 2020          cz,.    
-00039c70: 2020 2020 2020 2020 2020 2020 6e70 2e61              np.a
-00039c80: 7272 6179 285b 5b70 7473 5f78 5b70 705d  rray([[pts_x[pp]
-00039c90: 5d2c 205b 7074 735f 795b 7070 5d5d 2c20  ], [pts_y[pp]], 
-00039ca0: 5b70 7473 5f7a 5b70 705d 5d5d 292c 0a20  [pts_z[pp]]]),. 
-00039cb0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00039cc0: 6973 743d 4e6f 6e65 2c0a 2020 2020 2020  ist=None,.      
-00039cd0: 2020 2020 2020 2020 2020 726d 696e 3d72            rmin=r
-00039ce0: 6d69 6e2c 0a20 2020 2020 2020 2020 2020  min,.           
-00039cf0: 2020 2020 2076 6573 5f70 6f6c 793d 7665       ves_poly=ve
-00039d00: 735f 706f 6c79 2c0a 2020 2020 2020 2020  s_poly,.        
-00039d10: 2020 2020 2020 2020 7665 735f 6e6f 726d          ves_norm
-00039d20: 3d76 6573 5f6e 6f72 6d2c 0a20 2020 2020  =ves_norm,.     
-00039d30: 2020 2020 2020 2020 2020 2076 6573 5f6c             ves_l
-00039d40: 696d 733d 7665 735f 6c69 6d73 2c0a 2020  ims=ves_lims,.  
-00039d50: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
-00039d60: 7472 7563 745f 706f 6c79 783d 6c73 7472  truct_polyx=lstr
-00039d70: 7563 745f 706f 6c79 782c 0a20 2020 2020  uct_polyx,.     
-00039d80: 2020 2020 2020 2020 2020 206c 7374 7275             lstru
-00039d90: 6374 5f70 6f6c 7979 3d6c 7374 7275 6374  ct_polyy=lstruct
-00039da0: 5f70 6f6c 7979 2c0a 2020 2020 2020 2020  _polyy,.        
-00039db0: 2020 2020 2020 2020 6c73 7472 7563 745f          lstruct_
-00039dc0: 6c69 6d73 3d6c 7374 7275 6374 5f6c 696d  lims=lstruct_lim
-00039dd0: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
-00039de0: 2020 206c 7374 7275 6374 5f6e 6c69 6d3d     lstruct_nlim=
-00039df0: 6c73 7472 7563 745f 6e6c 696d 2c0a 2020  lstruct_nlim,.  
-00039e00: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
-00039e10: 7472 7563 745f 6e6f 726d 783d 6c73 7472  truct_normx=lstr
-00039e20: 7563 745f 6e6f 726d 782c 0a20 2020 2020  uct_normx,.     
-00039e30: 2020 2020 2020 2020 2020 206c 7374 7275             lstru
-00039e40: 6374 5f6e 6f72 6d79 3d6c 7374 7275 6374  ct_normy=lstruct
-00039e50: 5f6e 6f72 6d79 2c0a 2020 2020 2020 2020  _normy,.        
-00039e60: 2020 2020 2020 2020 6c6e 7665 7274 3d6c          lnvert=l
-00039e70: 6e76 6572 742c 0a20 2020 2020 2020 2020  nvert,.         
-00039e80: 2020 2020 2020 206e 7374 7275 6374 5f74         nstruct_t
-00039e90: 6f74 3d6e 7374 7275 6374 5f74 6f74 2c0a  ot=nstruct_tot,.
-00039ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00039eb0: 6e73 7472 7563 745f 6c69 6d3d 6e73 7472  nstruct_lim=nstr
-00039ec0: 7563 745f 6c69 6d2c 0a20 2020 2020 2020  uct_lim,.       
-00039ed0: 2020 2020 2020 2020 2066 6f72 6269 643d           forbid=
-00039ee0: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
-00039ef0: 2020 2020 2020 7665 735f 7479 7065 3d27        ves_type='
-00039f00: 546f 7227 2c0a 2020 2020 2020 2020 2020  Tor',.          
-00039f10: 2020 2020 2020 7465 7374 3d54 7275 652c        test=True,
-00039f20: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
-00039f30: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00039f40: 6f74 2076 6973 5b30 5d3a 0a20 2020 2020  ot vis[0]:.     
-00039f50: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-00039f60: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
-00039f70: 2023 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   # -------------
-00039f80: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2020  ------.         
-00039f90: 2020 2023 2072 6562 7569 6c64 2033 6420     # rebuild 3d 
-00039fa0: 706f 6c79 676f 6e0a 0a20 2020 2020 2020  polygon..       
-00039fb0: 2020 2020 2023 2063 6865 636b 2063 6377       # check ccw
-00039fc0: 0a20 2020 2020 2020 2020 2020 2070 5f61  .            p_a
-00039fd0: 5f78 3020 3d20 6e70 2e61 7363 6f6e 7469  _x0 = np.asconti
-00039fe0: 6775 6f75 7361 7272 6179 286e 702e 6172  guousarray(np.ar
-00039ff0: 7261 7928 705f 612e 636f 6e74 6f75 7228  ray(p_a.contour(
-0003a000: 3029 295b 3a2c 2030 5d29 0a20 2020 2020  0))[:, 0]).     
-0003a010: 2020 2020 2020 2070 5f61 5f78 3120 3d20         p_a_x1 = 
-0003a020: 6e70 2e61 7363 6f6e 7469 6775 6f75 7361  np.ascontiguousa
-0003a030: 7272 6179 286e 702e 6172 7261 7928 705f  rray(np.array(p_
-0003a040: 612e 636f 6e74 6f75 7228 3029 295b 3a2c  a.contour(0))[:,
-0003a050: 2031 5d29 0a20 2020 2020 2020 2020 2020   1]).           
-0003a060: 2069 6620 6e6f 7420 5f63 6865 636b 5f70   if not _check_p
-0003a070: 6f6c 7967 6f6e 5f32 645f 636f 756e 7465  olygon_2d_counte
-0003a080: 725f 636c 6f63 6b77 6973 6528 705f 615f  r_clockwise(p_a_
-0003a090: 7830 2c20 705f 615f 7831 293a 0a20 2020  x0, p_a_x1):.   
-0003a0a0: 2020 2020 2020 2020 2020 2020 2070 5f61               p_a
-0003a0b0: 5f78 3020 3d20 6e70 2e61 7363 6f6e 7469  _x0 = np.asconti
-0003a0c0: 6775 6f75 7361 7272 6179 2870 5f61 5f78  guousarray(p_a_x
-0003a0d0: 305b 3a3a 2d31 5d29 0a20 2020 2020 2020  0[::-1]).       
-0003a0e0: 2020 2020 2020 2020 2070 5f61 5f78 3120           p_a_x1 
-0003a0f0: 3d20 6e70 2e61 7363 6f6e 7469 6775 6f75  = np.ascontiguou
-0003a100: 7361 7272 6179 2870 5f61 5f78 315b 3a3a  sarray(p_a_x1[::
-0003a110: 2d31 5d29 0a0a 2020 2020 2020 2020 2020  -1])..          
-0003a120: 2020 2320 7472 6961 6e67 756c 6174 6520    # triangulate 
-0003a130: 6279 2065 6172 2d63 6c69 7070 696e 6720  by ear-clipping 
-0003a140: 2829 0a20 2020 2020 2020 2020 2020 2074  ().            t
-0003a150: 7269 203d 2074 7269 616e 6775 6c61 7465  ri = triangulate
-0003a160: 5f62 795f 6561 7263 6c69 7070 696e 675f  _by_earclipping_
-0003a170: 3264 280a 2020 2020 2020 2020 2020 2020  2d(.            
-0003a180: 2020 2020 6e70 2e61 7363 6f6e 7469 6775      np.ascontigu
-0003a190: 6f75 7361 7272 6179 285b 705f 615f 7830  ousarray([p_a_x0
-0003a1a0: 2c20 705f 615f 7831 5d29 0a20 2020 2020  , p_a_x1]).     
-0003a1b0: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-0003a1c0: 2020 2020 2020 2320 2d2d 2d2d 2d2d 2d2d        # --------
-0003a1d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
-0003a1e0: 2020 2020 2020 2020 2320 636f 6d70 7574          # comput
-0003a1f0: 6520 736f 6c69 6420 616e 676c 650a 0a20  e solid angle.. 
-0003a200: 2020 2020 2020 2020 2020 2023 206c 6f6f             # loo
-0003a210: 7020 6f6e 2074 7269 616e 676c 6573 0a20  p on triangles. 
-0003a220: 2020 2020 2020 2020 2020 2066 6f72 2074             for t
-0003a230: 7420 696e 2072 616e 6765 2874 7269 2e73  t in range(tri.s
-0003a240: 6861 7065 5b30 5d29 3a0a 0a20 2020 2020  hape[0]):..     
-0003a250: 2020 2020 2020 2020 2020 2023 2067 6574             # get
-0003a260: 2074 7269 616e 676c 650a 2020 2020 2020   triangle.      
-0003a270: 2020 2020 2020 2020 2020 7472 695f 7820            tri_x 
-0003a280: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-0003a290: 2020 2020 2020 2020 6465 745f 6365 6e74          det_cent
-0003a2a0: 735f 785b 6464 5d0a 2020 2020 2020 2020  s_x[dd].        
-0003a2b0: 2020 2020 2020 2020 2020 2020 2b20 705f              + p_
-0003a2c0: 615f 7830 5b74 7269 5b74 742c 203a 5d5d  a_x0[tri[tt, :]]
-0003a2d0: 202a 2064 6574 5f65 305f 785b 6464 5d0a   * det_e0_x[dd].
+00039a40: 6272 6561 6b0a 0a20 2020 2020 2020 2020  break..         
+00039a50: 2020 2023 2073 746f 7020 6966 206e 6f20     # stop if no 
+00039a60: 696e 7465 7273 6563 7469 6f6e 0a20 2020  intersection.   
+00039a70: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+00039a80: 6973 6f6b 3a0a 2020 2020 2020 2020 2020  isok:.          
+00039a90: 2020 2020 2020 636f 6e74 696e 7565 0a0a        continue..
+00039aa0: 2020 2020 2020 2020 2020 2020 2320 2d2d              # --
+00039ab0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00039ac0: 2d0a 2020 2020 2020 2020 2020 2020 2320  -.            # 
+00039ad0: 4765 7420 756e 6974 2076 6563 746f 720a  Get unit vector.
+00039ae0: 0a20 2020 2020 2020 2020 2020 2063 7830  .            cx0
+00039af0: 2c20 6378 3120 3d20 705f 612e 6365 6e74  , cx1 = p_a.cent
+00039b00: 6572 2830 290a 2020 2020 2020 2020 2020  er(0).          
+00039b10: 2020 6378 203d 2064 6574 5f63 656e 7473    cx = det_cents
+00039b20: 5f78 5b64 645d 202b 2063 7830 2a64 6574  _x[dd] + cx0*det
+00039b30: 5f65 305f 785b 6464 5d20 2b20 6378 312a  _e0_x[dd] + cx1*
+00039b40: 6465 745f 6531 5f78 5b64 645d 0a20 2020  det_e1_x[dd].   
+00039b50: 2020 2020 2020 2020 2063 7920 3d20 6465           cy = de
+00039b60: 745f 6365 6e74 735f 795b 6464 5d20 2b20  t_cents_y[dd] + 
+00039b70: 6378 302a 6465 745f 6530 5f79 5b64 645d  cx0*det_e0_y[dd]
+00039b80: 202b 2063 7831 2a64 6574 5f65 315f 795b   + cx1*det_e1_y[
+00039b90: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+00039ba0: 637a 203d 2064 6574 5f63 656e 7473 5f7a  cz = det_cents_z
+00039bb0: 5b64 645d 202b 2063 7830 2a64 6574 5f65  [dd] + cx0*det_e
+00039bc0: 305f 7a5b 6464 5d20 2b20 6378 312a 6465  0_z[dd] + cx1*de
+00039bd0: 745f 6531 5f7a 5b64 645d 0a0a 2020 2020  t_e1_z[dd]..    
+00039be0: 2020 2020 2020 2020 2320 6368 6563 6b20          # check 
+00039bf0: 7669 7369 6269 6c69 7479 0a20 2020 2020  visibility.     
+00039c00: 2020 2020 2020 2076 6973 203d 204c 4f53         vis = LOS
+00039c10: 5f69 7356 6973 5f50 7446 726f 6d50 7473  _isVis_PtFromPts
+00039c20: 5f56 6573 5374 7275 6374 280a 2020 2020  _VesStruct(.    
+00039c30: 2020 2020 2020 2020 2020 2020 6378 2c0a              cx,.
+00039c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00039c50: 6379 2c0a 2020 2020 2020 2020 2020 2020  cy,.            
+00039c60: 2020 2020 637a 2c0a 2020 2020 2020 2020      cz,.        
+00039c70: 2020 2020 2020 2020 6e70 2e61 7272 6179          np.array
+00039c80: 285b 5b70 7473 5f78 5b70 705d 5d2c 205b  ([[pts_x[pp]], [
+00039c90: 7074 735f 795b 7070 5d5d 2c20 5b70 7473  pts_y[pp]], [pts
+00039ca0: 5f7a 5b70 705d 5d5d 292c 0a20 2020 2020  _z[pp]]]),.     
+00039cb0: 2020 2020 2020 2020 2020 2064 6973 743d             dist=
+00039cc0: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
+00039cd0: 2020 2020 2020 726d 696e 3d72 6d69 6e2c        rmin=rmin,
+00039ce0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00039cf0: 2076 6573 5f70 6f6c 793d 7665 735f 706f   ves_poly=ves_po
+00039d00: 6c79 2c0a 2020 2020 2020 2020 2020 2020  ly,.            
+00039d10: 2020 2020 7665 735f 6e6f 726d 3d76 6573      ves_norm=ves
+00039d20: 5f6e 6f72 6d2c 0a20 2020 2020 2020 2020  _norm,.         
+00039d30: 2020 2020 2020 2076 6573 5f6c 696d 733d         ves_lims=
+00039d40: 7665 735f 6c69 6d73 2c0a 2020 2020 2020  ves_lims,.      
+00039d50: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
+00039d60: 745f 706f 6c79 783d 6c73 7472 7563 745f  t_polyx=lstruct_
+00039d70: 706f 6c79 782c 0a20 2020 2020 2020 2020  polyx,.         
+00039d80: 2020 2020 2020 206c 7374 7275 6374 5f70         lstruct_p
+00039d90: 6f6c 7979 3d6c 7374 7275 6374 5f70 6f6c  olyy=lstruct_pol
+00039da0: 7979 2c0a 2020 2020 2020 2020 2020 2020  yy,.            
+00039db0: 2020 2020 6c73 7472 7563 745f 6c69 6d73      lstruct_lims
+00039dc0: 3d6c 7374 7275 6374 5f6c 696d 732c 0a20  =lstruct_lims,. 
+00039dd0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00039de0: 7374 7275 6374 5f6e 6c69 6d3d 6c73 7472  struct_nlim=lstr
+00039df0: 7563 745f 6e6c 696d 2c0a 2020 2020 2020  uct_nlim,.      
+00039e00: 2020 2020 2020 2020 2020 6c73 7472 7563            lstruc
+00039e10: 745f 6e6f 726d 783d 6c73 7472 7563 745f  t_normx=lstruct_
+00039e20: 6e6f 726d 782c 0a20 2020 2020 2020 2020  normx,.         
+00039e30: 2020 2020 2020 206c 7374 7275 6374 5f6e         lstruct_n
+00039e40: 6f72 6d79 3d6c 7374 7275 6374 5f6e 6f72  ormy=lstruct_nor
+00039e50: 6d79 2c0a 2020 2020 2020 2020 2020 2020  my,.            
+00039e60: 2020 2020 6c6e 7665 7274 3d6c 6e76 6572      lnvert=lnver
+00039e70: 742c 0a20 2020 2020 2020 2020 2020 2020  t,.             
+00039e80: 2020 206e 7374 7275 6374 5f74 6f74 3d6e     nstruct_tot=n
+00039e90: 7374 7275 6374 5f74 6f74 2c0a 2020 2020  struct_tot,.    
+00039ea0: 2020 2020 2020 2020 2020 2020 6e73 7472              nstr
+00039eb0: 7563 745f 6c69 6d3d 6e73 7472 7563 745f  uct_lim=nstruct_
+00039ec0: 6c69 6d2c 0a20 2020 2020 2020 2020 2020  lim,.           
+00039ed0: 2020 2020 2066 6f72 6269 643d 5472 7565       forbid=True
+00039ee0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00039ef0: 2020 7665 735f 7479 7065 3d27 546f 7227    ves_type='Tor'
+00039f00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00039f10: 2020 7465 7374 3d54 7275 652c 0a20 2020    test=True,.   
+00039f20: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00039f30: 2020 2020 2020 2020 6966 206e 6f74 2076          if not v
+00039f40: 6973 5b30 5d3a 0a20 2020 2020 2020 2020  is[0]:.         
+00039f50: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+00039f60: 0a20 2020 2020 2020 2020 2020 2023 202d  .            # -
+00039f70: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00039f80: 2d2d 0a20 2020 2020 2020 2020 2020 2023  --.            #
+00039f90: 2072 6562 7569 6c64 2033 6420 706f 6c79   rebuild 3d poly
+00039fa0: 676f 6e0a 0a20 2020 2020 2020 2020 2020  gon..           
+00039fb0: 2023 2063 6865 636b 2063 6377 0a20 2020   # check ccw.   
+00039fc0: 2020 2020 2020 2020 2070 5f61 5f78 3020           p_a_x0 
+00039fd0: 3d20 6e70 2e61 7363 6f6e 7469 6775 6f75  = np.ascontiguou
+00039fe0: 7361 7272 6179 286e 702e 6172 7261 7928  sarray(np.array(
+00039ff0: 705f 612e 636f 6e74 6f75 7228 3029 295b  p_a.contour(0))[
+0003a000: 3a2c 2030 5d29 0a20 2020 2020 2020 2020  :, 0]).         
+0003a010: 2020 2070 5f61 5f78 3120 3d20 6e70 2e61     p_a_x1 = np.a
+0003a020: 7363 6f6e 7469 6775 6f75 7361 7272 6179  scontiguousarray
+0003a030: 286e 702e 6172 7261 7928 705f 612e 636f  (np.array(p_a.co
+0003a040: 6e74 6f75 7228 3029 295b 3a2c 2031 5d29  ntour(0))[:, 1])
+0003a050: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0003a060: 6e6f 7420 5f63 6865 636b 5f70 6f6c 7967  not _check_polyg
+0003a070: 6f6e 5f32 645f 636f 756e 7465 725f 636c  on_2d_counter_cl
+0003a080: 6f63 6b77 6973 6528 705f 615f 7830 2c20  ockwise(p_a_x0, 
+0003a090: 705f 615f 7831 293a 0a20 2020 2020 2020  p_a_x1):.       
+0003a0a0: 2020 2020 2020 2020 2070 5f61 5f78 3020           p_a_x0 
+0003a0b0: 3d20 6e70 2e61 7363 6f6e 7469 6775 6f75  = np.ascontiguou
+0003a0c0: 7361 7272 6179 2870 5f61 5f78 305b 3a3a  sarray(p_a_x0[::
+0003a0d0: 2d31 5d29 0a20 2020 2020 2020 2020 2020  -1]).           
+0003a0e0: 2020 2020 2070 5f61 5f78 3120 3d20 6e70       p_a_x1 = np
+0003a0f0: 2e61 7363 6f6e 7469 6775 6f75 7361 7272  .ascontiguousarr
+0003a100: 6179 2870 5f61 5f78 315b 3a3a 2d31 5d29  ay(p_a_x1[::-1])
+0003a110: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+0003a120: 7472 6961 6e67 756c 6174 6520 6279 2065  triangulate by e
+0003a130: 6172 2d63 6c69 7070 696e 6720 2829 0a20  ar-clipping (). 
+0003a140: 2020 2020 2020 2020 2020 2074 7269 203d             tri =
+0003a150: 2074 7269 616e 6775 6c61 7465 5f62 795f   triangulate_by_
+0003a160: 6561 7263 6c69 7070 696e 675f 3264 280a  earclipping_2d(.
+0003a170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a180: 6e70 2e61 7363 6f6e 7469 6775 6f75 7361  np.ascontiguousa
+0003a190: 7272 6179 285b 705f 615f 7830 2c20 705f  rray([p_a_x0, p_
+0003a1a0: 615f 7831 5d29 0a20 2020 2020 2020 2020  a_x1]).         
+0003a1b0: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+0003a1c0: 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    # ------------
+0003a1d0: 2d2d 2d2d 2d2d 2d0a 2020 2020 2020 2020  -------.        
+0003a1e0: 2020 2020 2320 636f 6d70 7574 6520 736f      # compute so
+0003a1f0: 6c69 6420 616e 676c 650a 0a20 2020 2020  lid angle..     
+0003a200: 2020 2020 2020 2023 206c 6f6f 7020 6f6e         # loop on
+0003a210: 2074 7269 616e 676c 6573 0a20 2020 2020   triangles.     
+0003a220: 2020 2020 2020 2066 6f72 2074 7420 696e         for tt in
+0003a230: 2072 616e 6765 2874 7269 2e73 6861 7065   range(tri.shape
+0003a240: 5b30 5d29 3a0a 0a20 2020 2020 2020 2020  [0]):..         
+0003a250: 2020 2020 2020 2023 2067 6574 2074 7269         # get tri
+0003a260: 616e 676c 650a 2020 2020 2020 2020 2020  angle.          
+0003a270: 2020 2020 2020 7472 695f 7820 3d20 280a        tri_x = (.
+0003a280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a290: 2020 2020 6465 745f 6365 6e74 735f 785b      det_cents_x[
+0003a2a0: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+0003a2b0: 2020 2020 2020 2020 2b20 705f 615f 7830          + p_a_x0
+0003a2c0: 5b74 7269 5b74 742c 203a 5d5d 202a 2064  [tri[tt, :]] * d
+0003a2d0: 6574 5f65 305f 785b 6464 5d0a 2020 2020  et_e0_x[dd].    
 0003a2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003a2f0: 2020 2020 2b20 705f 615f 7831 5b74 7269      + p_a_x1[tri
-0003a300: 5b74 742c 203a 5d5d 202a 2064 6574 5f65  [tt, :]] * det_e
-0003a310: 315f 785b 6464 5d0a 2020 2020 2020 2020  1_x[dd].        
-0003a320: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0003a330: 2020 2020 2020 2020 2020 7472 695f 7920            tri_y 
-0003a340: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-0003a350: 2020 2020 2020 2020 6465 745f 6365 6e74          det_cent
-0003a360: 735f 795b 6464 5d0a 2020 2020 2020 2020  s_y[dd].        
-0003a370: 2020 2020 2020 2020 2020 2020 2b20 705f              + p_
-0003a380: 615f 7830 5b74 7269 5b74 742c 203a 5d5d  a_x0[tri[tt, :]]
-0003a390: 202a 2064 6574 5f65 305f 795b 6464 5d0a   * det_e0_y[dd].
+0003a2f0: 2b20 705f 615f 7831 5b74 7269 5b74 742c  + p_a_x1[tri[tt,
+0003a300: 203a 5d5d 202a 2064 6574 5f65 315f 785b   :]] * det_e1_x[
+0003a310: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+0003a320: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+0003a330: 2020 2020 2020 7472 695f 7920 3d20 280a        tri_y = (.
+0003a340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a350: 2020 2020 6465 745f 6365 6e74 735f 795b      det_cents_y[
+0003a360: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+0003a370: 2020 2020 2020 2020 2b20 705f 615f 7830          + p_a_x0
+0003a380: 5b74 7269 5b74 742c 203a 5d5d 202a 2064  [tri[tt, :]] * d
+0003a390: 6574 5f65 305f 795b 6464 5d0a 2020 2020  et_e0_y[dd].    
 0003a3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003a3b0: 2020 2020 2b20 705f 615f 7831 5b74 7269      + p_a_x1[tri
-0003a3c0: 5b74 742c 203a 5d5d 202a 2064 6574 5f65  [tt, :]] * det_e
-0003a3d0: 315f 795b 6464 5d0a 2020 2020 2020 2020  1_y[dd].        
-0003a3e0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0003a3f0: 2020 2020 2020 2020 2020 7472 695f 7a20            tri_z 
-0003a400: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-0003a410: 2020 2020 2020 2020 6465 745f 6365 6e74          det_cent
-0003a420: 735f 7a5b 6464 5d0a 2020 2020 2020 2020  s_z[dd].        
-0003a430: 2020 2020 2020 2020 2020 2020 2b20 705f              + p_
-0003a440: 615f 7830 5b74 7269 5b74 742c 203a 5d5d  a_x0[tri[tt, :]]
-0003a450: 202a 2064 6574 5f65 305f 7a5b 6464 5d0a   * det_e0_z[dd].
+0003a3b0: 2b20 705f 615f 7831 5b74 7269 5b74 742c  + p_a_x1[tri[tt,
+0003a3c0: 203a 5d5d 202a 2064 6574 5f65 315f 795b   :]] * det_e1_y[
+0003a3d0: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+0003a3e0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+0003a3f0: 2020 2020 2020 7472 695f 7a20 3d20 280a        tri_z = (.
+0003a400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a410: 2020 2020 6465 745f 6365 6e74 735f 7a5b      det_cents_z[
+0003a420: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+0003a430: 2020 2020 2020 2020 2b20 705f 615f 7830          + p_a_x0
+0003a440: 5b74 7269 5b74 742c 203a 5d5d 202a 2064  [tri[tt, :]] * d
+0003a450: 6574 5f65 305f 7a5b 6464 5d0a 2020 2020  et_e0_z[dd].    
 0003a460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003a470: 2020 2020 2b20 705f 615f 7831 5b74 7269      + p_a_x1[tri
-0003a480: 5b74 742c 203a 5d5d 202a 2064 6574 5f65  [tt, :]] * det_e
-0003a490: 315f 7a5b 6464 5d0a 2020 2020 2020 2020  1_z[dd].        
-0003a4a0: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-0003a4b0: 2020 2020 2020 2020 2020 2023 2063 6f6d             # com
-0003a4c0: 7075 7461 7469 6f6e 2032 3a20 736f 6c69  putation 2: soli
-0003a4d0: 6420 616e 676c 6520 6f66 2074 7269 616e  d angle of trian
-0003a4e0: 676c 6520 6672 6f6d 2070 7473 0a20 2020  gle from pts.   
-0003a4f0: 2020 2020 2020 2020 2020 2020 2073 6f6c               sol
-0003a500: 6964 5f61 6e67 6c65 5b64 642c 2070 705d  id_angle[dd, pp]
-0003a510: 202b 3d20 5f73 742e 636f 6d70 5f73 615f   += _st.comp_sa_
-0003a520: 7472 6928 0a20 2020 2020 2020 2020 2020  tri(.           
-0003a530: 2020 2020 2020 2020 2074 7269 5f78 5b30           tri_x[0
-0003a540: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-0003a550: 2020 2020 2020 2074 7269 5f79 5b30 5d2c         tri_y[0],
-0003a560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003a570: 2020 2020 2074 7269 5f7a 5b30 5d2c 0a20       tri_z[0],. 
-0003a580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003a590: 2020 2074 7269 5f78 5b31 5d2c 0a20 2020     tri_x[1],.   
-0003a5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003a5b0: 2074 7269 5f79 5b31 5d2c 0a20 2020 2020   tri_y[1],.     
-0003a5c0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0003a5d0: 7269 5f7a 5b31 5d2c 0a20 2020 2020 2020  ri_z[1],.       
-0003a5e0: 2020 2020 2020 2020 2020 2020 2074 7269               tri
-0003a5f0: 5f78 5b32 5d2c 0a20 2020 2020 2020 2020  _x[2],.         
-0003a600: 2020 2020 2020 2020 2020 2074 7269 5f79             tri_y
-0003a610: 5b32 5d2c 0a20 2020 2020 2020 2020 2020  [2],.           
-0003a620: 2020 2020 2020 2020 2074 7269 5f7a 5b32           tri_z[2
-0003a630: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-0003a640: 2020 2020 2020 2070 7473 5f78 5b70 705d         pts_x[pp]
-0003a650: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0003a660: 2020 2020 2020 7074 735f 795b 7070 5d2c        pts_y[pp],
-0003a670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003a680: 2020 2020 2070 7473 5f7a 5b70 705d 2c0a       pts_z[pp],.
-0003a690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003a6a0: 290a 0a0a 2020 2020 2320 2d2d 2d2d 2d2d  )...    # ------
-0003a6b0: 2d0a 2020 2020 2320 5265 7475 726e 0a0a  -.    # Return..
-0003a6c0: 2020 2020 7265 7475 726e 2073 6f6c 6964      return solid
-0003a6d0: 5f61 6e67 6c65 0a0a 0a64 6566 2063 6f6d  _angle...def com
-0003a6e0: 7075 7465 5f73 6f6c 6964 5f61 6e67 6c65  pute_solid_angle
-0003a6f0: 5f61 7065 7274 7572 6573 5f6c 6967 6874  _apertures_light
-0003a700: 280a 2020 2020 2320 7074 733a 2063 6f6f  (.    # pts: coo
-0003a710: 7264 696e 6174 6573 2061 7320 7468 7265  rdinates as thre
-0003a720: 6520 3164 2061 7272 6179 730a 2020 2020  e 1d arrays.    
-0003a730: 646f 7562 6c65 5b3a 3a31 5d20 7074 735f  double[::1] pts_
-0003a740: 782c 0a20 2020 2064 6f75 626c 655b 3a3a  x,.    double[::
-0003a750: 315d 2070 7473 5f79 2c0a 2020 2020 646f  1] pts_y,.    do
-0003a760: 7562 6c65 5b3a 3a31 5d20 7074 735f 7a2c  uble[::1] pts_z,
-0003a770: 0a20 2020 2023 2064 6574 6563 746f 7273  .    # detectors
-0003a780: 3a20 706f 6c79 676f 6e20 636f 6f72 6469  : polygon coordi
-0003a790: 6e61 7465 7320 696e 2032 6420 2863 6f6d  nates in 2d (com
-0003a7a0: 6d6f 6e20 746f 2061 6c6c 2064 6574 6563  mon to all detec
-0003a7b0: 746f 7273 290a 2020 2020 646f 7562 6c65  tors).    double
-0003a7c0: 5b3a 3a31 5d20 6465 745f 6f75 746c 696e  [::1] det_outlin
-0003a7d0: 655f 7830 2c0a 2020 2020 646f 7562 6c65  e_x0,.    double
-0003a7e0: 5b3a 3a31 5d20 6465 745f 6f75 746c 696e  [::1] det_outlin
-0003a7f0: 655f 7831 2c0a 2020 2020 2320 6465 7465  e_x1,.    # dete
-0003a800: 6374 6f72 733a 2063 656e 7465 7273 2063  ctors: centers c
-0003a810: 6f6f 7264 696e 6174 6573 2061 7320 7468  oordinates as th
-0003a820: 7265 6520 3164 2061 7272 6179 730a 2020  ree 1d arrays.  
-0003a830: 2020 646f 7562 6c65 5b3a 3a31 5d20 6465    double[::1] de
-0003a840: 745f 6365 6e74 735f 782c 0a20 2020 2064  t_cents_x,.    d
-0003a850: 6f75 626c 655b 3a3a 315d 2064 6574 5f63  ouble[::1] det_c
-0003a860: 656e 7473 5f79 2c0a 2020 2020 646f 7562  ents_y,.    doub
-0003a870: 6c65 5b3a 3a31 5d20 6465 745f 6365 6e74  le[::1] det_cent
-0003a880: 735f 7a2c 0a20 2020 2023 2064 6574 6563  s_z,.    # detec
-0003a890: 746f 7273 3a20 6e6f 726d 616c 2075 6e69  tors: normal uni
-0003a8a0: 7420 7665 6374 6f72 7320 6173 2074 6872  t vectors as thr
-0003a8b0: 6565 2031 6420 6172 7261 7973 2028 6e64  ee 1d arrays (nd
-0003a8c0: 203d 206c 656e 2864 6574 5f6e 6f72 6d5f   = len(det_norm_
-0003a8d0: 7829 290a 2020 2020 646f 7562 6c65 5b3a  x)).    double[:
-0003a8e0: 3a31 5d20 6465 745f 6e6f 726d 5f78 2c0a  :1] det_norm_x,.
-0003a8f0: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
-0003a900: 6465 745f 6e6f 726d 5f79 2c0a 2020 2020  det_norm_y,.    
-0003a910: 646f 7562 6c65 5b3a 3a31 5d20 6465 745f  double[::1] det_
-0003a920: 6e6f 726d 5f7a 2c0a 2020 2020 6e70 2e6e  norm_z,.    np.n
-0003a930: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
-0003a940: 6469 6d3d 315d 2064 6574 5f65 305f 782c  dim=1] det_e0_x,
-0003a950: 0a20 2020 206e 702e 6e64 6172 7261 795b  .    np.ndarray[
-0003a960: 646f 7562 6c65 2c20 6e64 696d 3d31 5d20  double, ndim=1] 
-0003a970: 6465 745f 6530 5f79 2c0a 2020 2020 6e70  det_e0_y,.    np
-0003a980: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
-0003a990: 206e 6469 6d3d 315d 2064 6574 5f65 305f   ndim=1] det_e0_
-0003a9a0: 7a2c 0a20 2020 206e 702e 6e64 6172 7261  z,.    np.ndarra
-0003a9b0: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
-0003a9c0: 5d20 6465 745f 6531 5f78 2c0a 2020 2020  ] det_e1_x,.    
-0003a9d0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0003a9e0: 652c 206e 6469 6d3d 315d 2064 6574 5f65  e, ndim=1] det_e
-0003a9f0: 315f 792c 0a20 2020 206e 702e 6e64 6172  1_y,.    np.ndar
-0003aa00: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
-0003aa10: 3d31 5d20 6465 745f 6531 5f7a 2c0a 2020  =1] det_e1_z,.  
-0003aa20: 2020 2320 6170 6572 7475 7265 733a 2069    # apertures: i
-0003aa30: 6e64 6963 6573 206f 6620 6669 7273 7420  ndices of first 
-0003aa40: 636f 726e 6572 206f 6620 6561 6368 2061  corner of each a
-0003aa50: 7020 706f 6c79 676f 6e3a 206e 6120 3d20  p polygon: na = 
-0003aa60: 6c65 6e28 6170 5f69 6e64 290a 2020 2020  len(ap_ind).    
-0003aa70: 6c6f 6e67 5b3a 3a31 5d20 6170 5f69 6e64  long[::1] ap_ind
-0003aa80: 2c0a 2020 2020 2320 6170 6572 7475 7265  ,.    # aperture
-0003aa90: 733a 2070 6f6c 7967 6f6e 2063 6f6f 7264  s: polygon coord
-0003aaa0: 696e 6174 6573 2061 7320 7468 7265 6520  inates as three 
-0003aab0: 3164 2061 7272 6179 730a 2020 2020 6e70  1d arrays.    np
-0003aac0: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
-0003aad0: 206e 6469 6d3d 315d 2061 705f 782c 0a20   ndim=1] ap_x,. 
-0003aae0: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
-0003aaf0: 7562 6c65 2c20 6e64 696d 3d31 5d20 6170  uble, ndim=1] ap
-0003ab00: 5f79 2c0a 2020 2020 6e70 2e6e 6461 7272  _y,.    np.ndarr
-0003ab10: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
-0003ab20: 315d 2061 705f 7a2c 0a20 2020 2023 206e  1] ap_z,.    # n
-0003ab30: 6f72 6d61 6c20 756e 6974 2076 6563 746f  ormal unit vecto
-0003ab40: 7273 0a20 2020 2064 6f75 626c 655b 3a3a  rs.    double[::
-0003ab50: 315d 2061 705f 6e6f 726d 5f78 2c0a 2020  1] ap_norm_x,.  
-0003ab60: 2020 646f 7562 6c65 5b3a 3a31 5d20 6170    double[::1] ap
-0003ab70: 5f6e 6f72 6d5f 792c 0a20 2020 2064 6f75  _norm_y,.    dou
-0003ab80: 626c 655b 3a3a 315d 2061 705f 6e6f 726d  ble[::1] ap_norm
-0003ab90: 5f7a 2c0a 2020 2020 2320 706f 7373 6962  _z,.    # possib
-0003aba0: 6c65 2065 7874 7261 2070 6172 616d 6574  le extra paramet
-0003abb0: 6572 7320 3f0a 2020 2020 646f 7562 6c65  ers ?.    double
-0003abc0: 206d 6172 6769 6e3d 5f56 534d 414c 4c2c   margin=_VSMALL,
-0003abd0: 0a20 2020 2069 6e74 206e 756d 5f74 6872  .    int num_thr
-0003abe0: 6561 6473 3d31 302c 0a29 3a0a 0a20 2020  eads=10,.):..   
-0003abf0: 2023 202d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20   # -----------. 
-0003ac00: 2020 2023 2044 6563 6c61 7261 7469 6f6e     # Declaration
-0003ac10: 0a0a 2020 2020 6364 6566 2069 6e74 206e  ..    cdef int n
-0003ac20: 7074 7320 3d20 7074 735f 782e 7369 7a65  pts = pts_x.size
-0003ac30: 0a20 2020 2063 6465 6620 696e 7420 6e64  .    cdef int nd
-0003ac40: 203d 2064 6574 5f63 656e 7473 5f78 2e73   = det_cents_x.s
-0003ac50: 697a 650a 2020 2020 6364 6566 2069 6e74  ize.    cdef int
-0003ac60: 206e 6120 3d20 6170 5f6e 6f72 6d5f 782e   na = ap_norm_x.
-0003ac70: 7369 7a65 0a20 2020 2063 6465 6620 696e  size.    cdef in
-0003ac80: 7420 6464 2c20 7070 2c20 6161 2c20 7474  t dd, pp, aa, tt
-0003ac90: 0a20 2020 2063 6465 6620 696e 7420 6e70  .    cdef int np
-0003aca0: 610a 2020 2020 6364 6566 2066 6c6f 6174  a.    cdef float
-0003acb0: 2073 6361 2c20 7363 6130 2c20 7363 6131   sca, sca0, sca1
-0003acc0: 0a20 2020 2063 6465 6620 666c 6f61 7420  .    cdef float 
-0003acd0: 6b69 0a20 2020 2063 6465 6620 6e70 2e6e  ki.    cdef np.n
-0003ace0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
-0003acf0: 6469 6d3d 315d 2061 705f 7830 203d 206e  dim=1] ap_x0 = n
-0003ad00: 702e 636f 7079 2861 705f 7829 0a20 2020  p.copy(ap_x).   
-0003ad10: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
-0003ad20: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
-0003ad30: 2061 705f 7831 203d 206e 702e 636f 7079   ap_x1 = np.copy
-0003ad40: 2861 705f 7829 0a20 2020 2063 6465 6620  (ap_x).    cdef 
-0003ad50: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0003ad60: 652c 206e 6469 6d3d 315d 2070 5f61 5f78  e, ndim=1] p_a_x
-0003ad70: 300a 2020 2020 6364 6566 206e 702e 6e64  0.    cdef np.nd
-0003ad80: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
-0003ad90: 696d 3d31 5d20 705f 615f 7831 0a20 2020  im=1] p_a_x1.   
-0003ada0: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
-0003adb0: 5b6c 6f6e 672c 206e 6469 6d3d 325d 2074  [long, ndim=2] t
-0003adc0: 7269 0a20 2020 2063 6465 6620 6e70 2e6e  ri.    cdef np.n
-0003add0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
-0003ade0: 6469 6d3d 315d 2074 7269 5f78 0a20 2020  dim=1] tri_x.   
-0003adf0: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
-0003ae00: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
-0003ae10: 2074 7269 5f79 0a20 2020 2063 6465 6620   tri_y.    cdef 
-0003ae20: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0003ae30: 652c 206e 6469 6d3d 315d 2074 7269 5f7a  e, ndim=1] tri_z
-0003ae40: 0a0a 2020 2020 2320 696e 6974 6961 6c69  ..    # initiali
-0003ae50: 7a65 2073 6f6c 6964 2061 6e67 6c65 2061  ze solid angle a
-0003ae60: 7272 6179 2077 6974 6820 7a65 726f 730a  rray with zeros.
-0003ae70: 2020 2020 6364 6566 206e 702e 6e64 6172      cdef np.ndar
-0003ae80: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
-0003ae90: 3d32 5d20 736f 6c69 645f 616e 676c 6520  =2] solid_angle 
-0003aea0: 3d20 6e70 2e7a 6572 6f73 2828 6e64 2c20  = np.zeros((nd, 
-0003aeb0: 6e70 7473 292c 2064 7479 7065 3d66 6c6f  npts), dtype=flo
-0003aec0: 6174 290a 0a20 2020 2023 202d 2d2d 2d2d  at)..    # -----
-0003aed0: 2d2d 0a20 2020 2023 2043 6f6d 7075 7465  --.    # Compute
-0003aee0: 0a0a 2020 2020 666f 7220 6464 2069 6e20  ..    for dd in 
-0003aef0: 7261 6e67 6528 6e64 293a 0a0a 2020 2020  range(nd):..    
-0003af00: 2020 2020 2320 7072 696e 7428 2764 6574      # print('det
-0003af10: 5f63 656e 7427 2c20 6465 745f 6365 6e74  _cent', det_cent
-0003af20: 735f 785b 6464 5d2c 2064 6574 5f63 656e  s_x[dd], det_cen
-0003af30: 7473 5f79 5b64 645d 2c20 6465 745f 6365  ts_y[dd], det_ce
-0003af40: 6e74 735f 7a5b 6464 5d29 0a20 2020 2020  nts_z[dd]).     
-0003af50: 2020 2023 2070 7269 6e74 2827 6465 745f     # print('det_
-0003af60: 6e69 6e27 2c20 6465 745f 6e6f 726d 5f78  nin', det_norm_x
-0003af70: 5b64 645d 2c20 6465 745f 6e6f 726d 5f79  [dd], det_norm_y
-0003af80: 5b64 645d 2c20 6465 745f 6e6f 726d 5f7a  [dd], det_norm_z
-0003af90: 5b64 645d 2920 2020 2020 2020 2023 2044  [dd])        # D
-0003afa0: 420a 2020 2020 2020 2020 2320 7072 696e  B.        # prin
-0003afb0: 7428 2764 6574 5f65 3027 2c20 6465 745f  t('det_e0', det_
-0003afc0: 6530 5f78 5b64 645d 2c20 6465 745f 6530  e0_x[dd], det_e0
-0003afd0: 5f79 5b64 645d 2c20 6465 745f 6530 5f7a  _y[dd], det_e0_z
-0003afe0: 5b64 645d 2920 2020 2020 2020 2023 2044  [dd])        # D
-0003aff0: 420a 2020 2020 2020 2020 2320 7072 696e  B.        # prin
-0003b000: 7428 2764 6574 5f65 3127 2c20 6465 745f  t('det_e1', det_
-0003b010: 6531 5f78 5b64 645d 2c20 6465 745f 6531  e1_x[dd], det_e1
-0003b020: 5f79 5b64 645d 2c20 6465 745f 6531 5f7a  _y[dd], det_e1_z
-0003b030: 5b64 645d 2920 2020 2020 2020 2023 2044  [dd])        # D
-0003b040: 420a 0a20 2020 2020 2020 2023 206c 6f6f  B..        # loo
-0003b050: 7020 323a 206f 6e20 6e70 7473 2028 6f62  p 2: on npts (ob
-0003b060: 7365 7276 6174 696f 6e20 706f 696e 7473  servation points
-0003b070: 290a 2020 2020 2020 2020 666f 7220 7070  ).        for pp
-0003b080: 2069 6e20 7261 6e67 6528 6e70 7473 293a   in range(npts):
-0003b090: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0003b0a0: 7072 696e 7428 2770 7473 272c 2070 702c  print('pts', pp,
-0003b0b0: 2070 7473 5f78 5b70 705d 2c20 7074 735f   pts_x[pp], pts_
-0003b0c0: 795b 7070 5d2c 2070 7473 5f7a 5b70 705d  y[pp], pts_z[pp]
-0003b0d0: 2920 2020 2020 2020 2023 2044 420a 0a20  )        # DB.. 
-0003b0e0: 2020 2020 2020 2020 2020 2023 2074 6573             # tes
-0003b0f0: 7420 6966 206f 6e20 676f 6f64 2073 6964  t if on good sid
-0003b100: 6520 6f66 2064 6574 6563 746f 720a 2020  e of detector.  
-0003b110: 2020 2020 2020 2020 2020 7363 6130 203d            sca0 =
-0003b120: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-0003b130: 2020 2028 7074 735f 785b 7070 5d20 2d20     (pts_x[pp] - 
-0003b140: 6465 745f 6365 6e74 735f 785b 6464 5d29  det_cents_x[dd])
-0003b150: 202a 2064 6574 5f6e 6f72 6d5f 785b 6464   * det_norm_x[dd
-0003b160: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003b170: 2020 2b20 2870 7473 5f79 5b70 705d 202d    + (pts_y[pp] -
-0003b180: 2064 6574 5f63 656e 7473 5f79 5b64 645d   det_cents_y[dd]
-0003b190: 2920 2a20 6465 745f 6e6f 726d 5f79 5b64  ) * det_norm_y[d
-0003b1a0: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
-0003b1b0: 2020 202b 2028 7074 735f 7a5b 7070 5d20     + (pts_z[pp] 
-0003b1c0: 2d20 6465 745f 6365 6e74 735f 7a5b 6464  - det_cents_z[dd
-0003b1d0: 5d29 202a 2064 6574 5f6e 6f72 6d5f 7a5b  ]) * det_norm_z[
-0003b1e0: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-0003b1f0: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
-0003b200: 6620 7363 6130 203c 3d20 303a 0a20 2020  f sca0 <= 0:.   
-0003b210: 2020 2020 2020 2020 2020 2020 2023 2070               # p
-0003b220: 7269 6e74 2827 736b 6970 272c 2073 6361  rint('skip', sca
-0003b230: 3029 2020 2020 2020 2020 2320 4442 0a20  0)        # DB. 
-0003b240: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0003b250: 6f6e 7469 6e75 650a 0a20 2020 2020 2020  ontinue..       
-0003b260: 2020 2020 2023 2066 6c61 670a 2020 2020       # flag.    
-0003b270: 2020 2020 2020 2020 6973 6f6b 203d 2054          isok = T
-0003b280: 7275 650a 0a20 2020 2020 2020 2020 2020  rue..           
-0003b290: 2023 206c 6f6f 7020 333a 206f 6e20 6e61   # loop 3: on na
-0003b2a0: 2028 6170 6572 7475 7265 7329 0a20 2020   (apertures).   
-0003b2b0: 2020 2020 2020 2020 2066 6f72 2061 6120           for aa 
-0003b2c0: 696e 2072 616e 6765 286e 6129 3a0a 0a20  in range(na):.. 
-0003b2d0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0003b2e0: 2070 7269 6e74 2827 6170 272c 2061 6129   print('ap', aa)
-0003b2f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003b300: 2023 2070 7269 6e74 2827 6170 2069 6e64   # print('ap ind
-0003b310: 272c 2061 705f 696e 645b 6161 5d2c 2061  ', ap_ind[aa], a
-0003b320: 705f 696e 645b 6161 2b31 5d29 0a20 2020  p_ind[aa+1]).   
-0003b330: 2020 2020 2020 2020 2020 2020 2023 2070               # p
-0003b340: 7269 6e74 2827 6170 206e 696e 272c 2061  rint('ap nin', a
-0003b350: 705f 6e6f 726d 5f78 5b61 615d 2c20 6170  p_norm_x[aa], ap
-0003b360: 5f6e 6f72 6d5f 795b 6161 5d2c 2061 705f  _norm_y[aa], ap_
-0003b370: 6e6f 726d 5f7a 5b61 615d 290a 2020 2020  norm_z[aa]).    
-0003b380: 2020 2020 2020 2020 2020 2020 2320 7072              # pr
-0003b390: 696e 7428 2761 705f 7827 2c20 6170 5f78  int('ap_x', ap_x
-0003b3a0: 5b61 705f 696e 645b 6161 5d3a 6170 5f69  [ap_ind[aa]:ap_i
-0003b3b0: 6e64 5b61 612b 315d 5d29 0a20 2020 2020  nd[aa+1]]).     
-0003b3c0: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
-0003b3d0: 6e74 2827 6170 5f79 272c 2061 705f 795b  nt('ap_y', ap_y[
-0003b3e0: 6170 5f69 6e64 5b61 615d 3a61 705f 696e  ap_ind[aa]:ap_in
-0003b3f0: 645b 6161 2b31 5d5d 290a 2020 2020 2020  d[aa+1]]).      
-0003b400: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
-0003b410: 7428 2761 705f 7a27 2c20 6170 5f7a 5b61  t('ap_z', ap_z[a
-0003b420: 705f 696e 645b 6161 5d3a 6170 5f69 6e64  p_ind[aa]:ap_ind
-0003b430: 5b61 612b 315d 5d29 0a0a 2020 2020 2020  [aa+1]])..      
-0003b440: 2020 2020 2020 2020 2020 2320 7465 7374            # test
-0003b450: 2069 6620 6f6e 2067 6f6f 6420 7369 6465   if on good side
-0003b460: 206f 6620 6170 6572 7475 7265 0a20 2020   of aperture.   
-0003b470: 2020 2020 2020 2020 2020 2020 2073 6361               sca
-0003b480: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-0003b490: 2020 2020 2020 2020 2028 7074 735f 785b           (pts_x[
-0003b4a0: 7070 5d20 2d20 6170 5f78 5b61 705f 696e  pp] - ap_x[ap_in
-0003b4b0: 645b 6161 5d5d 2920 2a20 6170 5f6e 6f72  d[aa]]) * ap_nor
-0003b4c0: 6d5f 785b 6161 5d0a 2020 2020 2020 2020  m_x[aa].        
-0003b4d0: 2020 2020 2020 2020 2020 2020 2b20 2870              + (p
-0003b4e0: 7473 5f79 5b70 705d 202d 2061 705f 795b  ts_y[pp] - ap_y[
-0003b4f0: 6170 5f69 6e64 5b61 615d 5d29 202a 2061  ap_ind[aa]]) * a
-0003b500: 705f 6e6f 726d 5f79 5b61 615d 0a20 2020  p_norm_y[aa].   
-0003b510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b520: 202b 2028 7074 735f 7a5b 7070 5d20 2d20   + (pts_z[pp] - 
-0003b530: 6170 5f7a 5b61 705f 696e 645b 6161 5d5d  ap_z[ap_ind[aa]]
-0003b540: 2920 2a20 6170 5f6e 6f72 6d5f 7a5b 6161  ) * ap_norm_z[aa
-0003b550: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003b560: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
-0003b570: 2020 2020 2069 6620 7363 6120 3c3d 2030       if sca <= 0
-0003b580: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0003b590: 2020 2020 2020 6973 6f6b 203d 2046 616c        isok = Fal
-0003b5a0: 7365 0a20 2020 2020 2020 2020 2020 2020  se.             
-0003b5b0: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
-0003b5c0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0003b5d0: 7465 7374 2069 6620 616c 6c20 6170 6572  test if all aper
-0003b5e0: 7475 7265 2070 6f69 6e74 7320 6361 6e20  ture points can 
-0003b5f0: 6265 2070 726f 6a65 6374 6564 206f 6e20  be projected on 
-0003b600: 6465 7465 6374 6f72 2070 6c61 6e65 2066  detector plane f
-0003b610: 726f 6d20 7074 730a 2020 2020 2020 2020  rom pts.        
-0003b620: 2020 2020 2020 2020 666f 7220 6c6c 2069          for ll i
-0003b630: 6e20 7261 6e67 6528 6170 5f69 6e64 5b61  n range(ap_ind[a
-0003b640: 615d 2c20 6170 5f69 6e64 5b61 612b 315d  a], ap_ind[aa+1]
-0003b650: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-0003b660: 2020 2020 2020 2073 6361 3120 3d20 280a         sca1 = (.
+0003a470: 2b20 705f 615f 7831 5b74 7269 5b74 742c  + p_a_x1[tri[tt,
+0003a480: 203a 5d5d 202a 2064 6574 5f65 315f 7a5b   :]] * det_e1_z[
+0003a490: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+0003a4a0: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+0003a4b0: 2020 2020 2020 2023 2063 6f6d 7075 7461         # computa
+0003a4c0: 7469 6f6e 2032 3a20 736f 6c69 6420 616e  tion 2: solid an
+0003a4d0: 676c 6520 6f66 2074 7269 616e 676c 6520  gle of triangle 
+0003a4e0: 6672 6f6d 2070 7473 0a20 2020 2020 2020  from pts.       
+0003a4f0: 2020 2020 2020 2020 2073 6f6c 6964 5f61           solid_a
+0003a500: 6e67 6c65 5b64 642c 2070 705d 202b 3d20  ngle[dd, pp] += 
+0003a510: 5f73 742e 636f 6d70 5f73 615f 7472 6928  _st.comp_sa_tri(
+0003a520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003a530: 2020 2020 2074 7269 5f78 5b30 5d2c 0a20       tri_x[0],. 
+0003a540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a550: 2020 2074 7269 5f79 5b30 5d2c 0a20 2020     tri_y[0],.   
+0003a560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a570: 2074 7269 5f7a 5b30 5d2c 0a20 2020 2020   tri_z[0],.     
+0003a580: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0003a590: 7269 5f78 5b31 5d2c 0a20 2020 2020 2020  ri_x[1],.       
+0003a5a0: 2020 2020 2020 2020 2020 2020 2074 7269               tri
+0003a5b0: 5f79 5b31 5d2c 0a20 2020 2020 2020 2020  _y[1],.         
+0003a5c0: 2020 2020 2020 2020 2020 2074 7269 5f7a             tri_z
+0003a5d0: 5b31 5d2c 0a20 2020 2020 2020 2020 2020  [1],.           
+0003a5e0: 2020 2020 2020 2020 2074 7269 5f78 5b32           tri_x[2
+0003a5f0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0003a600: 2020 2020 2020 2074 7269 5f79 5b32 5d2c         tri_y[2],
+0003a610: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003a620: 2020 2020 2074 7269 5f7a 5b32 5d2c 0a20       tri_z[2],. 
+0003a630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a640: 2020 2070 7473 5f78 5b70 705d 2c0a 2020     pts_x[pp],.  
+0003a650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a660: 2020 7074 735f 795b 7070 5d2c 0a20 2020    pts_y[pp],.   
+0003a670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003a680: 2070 7473 5f7a 5b70 705d 2c0a 2020 2020   pts_z[pp],.    
+0003a690: 2020 2020 2020 2020 2020 2020 290a 0a0a              )...
+0003a6a0: 2020 2020 2320 2d2d 2d2d 2d2d 2d0a 2020      # -------.  
+0003a6b0: 2020 2320 5265 7475 726e 0a0a 2020 2020    # Return..    
+0003a6c0: 7265 7475 726e 2073 6f6c 6964 5f61 6e67  return solid_ang
+0003a6d0: 6c65 0a0a 0a64 6566 2063 6f6d 7075 7465  le...def compute
+0003a6e0: 5f73 6f6c 6964 5f61 6e67 6c65 5f61 7065  _solid_angle_ape
+0003a6f0: 7274 7572 6573 5f6c 6967 6874 280a 2020  rtures_light(.  
+0003a700: 2020 2320 7074 733a 2063 6f6f 7264 696e    # pts: coordin
+0003a710: 6174 6573 2061 7320 7468 7265 6520 3164  ates as three 1d
+0003a720: 2061 7272 6179 730a 2020 2020 646f 7562   arrays.    doub
+0003a730: 6c65 5b3a 3a31 5d20 7074 735f 782c 0a20  le[::1] pts_x,. 
+0003a740: 2020 2064 6f75 626c 655b 3a3a 315d 2070     double[::1] p
+0003a750: 7473 5f79 2c0a 2020 2020 646f 7562 6c65  ts_y,.    double
+0003a760: 5b3a 3a31 5d20 7074 735f 7a2c 0a20 2020  [::1] pts_z,.   
+0003a770: 2023 2064 6574 6563 746f 7273 3a20 706f   # detectors: po
+0003a780: 6c79 676f 6e20 636f 6f72 6469 6e61 7465  lygon coordinate
+0003a790: 7320 696e 2032 6420 2863 6f6d 6d6f 6e20  s in 2d (common 
+0003a7a0: 746f 2061 6c6c 2064 6574 6563 746f 7273  to all detectors
+0003a7b0: 290a 2020 2020 646f 7562 6c65 5b3a 3a31  ).    double[::1
+0003a7c0: 5d20 6465 745f 6f75 746c 696e 655f 7830  ] det_outline_x0
+0003a7d0: 2c0a 2020 2020 646f 7562 6c65 5b3a 3a31  ,.    double[::1
+0003a7e0: 5d20 6465 745f 6f75 746c 696e 655f 7831  ] det_outline_x1
+0003a7f0: 2c0a 2020 2020 2320 6465 7465 6374 6f72  ,.    # detector
+0003a800: 733a 2063 656e 7465 7273 2063 6f6f 7264  s: centers coord
+0003a810: 696e 6174 6573 2061 7320 7468 7265 6520  inates as three 
+0003a820: 3164 2061 7272 6179 730a 2020 2020 646f  1d arrays.    do
+0003a830: 7562 6c65 5b3a 3a31 5d20 6465 745f 6365  uble[::1] det_ce
+0003a840: 6e74 735f 782c 0a20 2020 2064 6f75 626c  nts_x,.    doubl
+0003a850: 655b 3a3a 315d 2064 6574 5f63 656e 7473  e[::1] det_cents
+0003a860: 5f79 2c0a 2020 2020 646f 7562 6c65 5b3a  _y,.    double[:
+0003a870: 3a31 5d20 6465 745f 6365 6e74 735f 7a2c  :1] det_cents_z,
+0003a880: 0a20 2020 2023 2064 6574 6563 746f 7273  .    # detectors
+0003a890: 3a20 6e6f 726d 616c 2075 6e69 7420 7665  : normal unit ve
+0003a8a0: 6374 6f72 7320 6173 2074 6872 6565 2031  ctors as three 1
+0003a8b0: 6420 6172 7261 7973 2028 6e64 203d 206c  d arrays (nd = l
+0003a8c0: 656e 2864 6574 5f6e 6f72 6d5f 7829 290a  en(det_norm_x)).
+0003a8d0: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
+0003a8e0: 6465 745f 6e6f 726d 5f78 2c0a 2020 2020  det_norm_x,.    
+0003a8f0: 646f 7562 6c65 5b3a 3a31 5d20 6465 745f  double[::1] det_
+0003a900: 6e6f 726d 5f79 2c0a 2020 2020 646f 7562  norm_y,.    doub
+0003a910: 6c65 5b3a 3a31 5d20 6465 745f 6e6f 726d  le[::1] det_norm
+0003a920: 5f7a 2c0a 2020 2020 6e70 2e6e 6461 7272  _z,.    np.ndarr
+0003a930: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
+0003a940: 315d 2064 6574 5f65 305f 782c 0a20 2020  1] det_e0_x,.   
+0003a950: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
+0003a960: 6c65 2c20 6e64 696d 3d31 5d20 6465 745f  le, ndim=1] det_
+0003a970: 6530 5f79 2c0a 2020 2020 6e70 2e6e 6461  e0_y,.    np.nda
+0003a980: 7272 6179 5b64 6f75 626c 652c 206e 6469  rray[double, ndi
+0003a990: 6d3d 315d 2064 6574 5f65 305f 7a2c 0a20  m=1] det_e0_z,. 
+0003a9a0: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
+0003a9b0: 7562 6c65 2c20 6e64 696d 3d31 5d20 6465  uble, ndim=1] de
+0003a9c0: 745f 6531 5f78 2c0a 2020 2020 6e70 2e6e  t_e1_x,.    np.n
+0003a9d0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+0003a9e0: 6469 6d3d 315d 2064 6574 5f65 315f 792c  dim=1] det_e1_y,
+0003a9f0: 0a20 2020 206e 702e 6e64 6172 7261 795b  .    np.ndarray[
+0003aa00: 646f 7562 6c65 2c20 6e64 696d 3d31 5d20  double, ndim=1] 
+0003aa10: 6465 745f 6531 5f7a 2c0a 2020 2020 2320  det_e1_z,.    # 
+0003aa20: 6170 6572 7475 7265 733a 2069 6e64 6963  apertures: indic
+0003aa30: 6573 206f 6620 6669 7273 7420 636f 726e  es of first corn
+0003aa40: 6572 206f 6620 6561 6368 2061 7020 706f  er of each ap po
+0003aa50: 6c79 676f 6e3a 206e 6120 3d20 6c65 6e28  lygon: na = len(
+0003aa60: 6170 5f69 6e64 290a 2020 2020 6c6f 6e67  ap_ind).    long
+0003aa70: 5b3a 3a31 5d20 6170 5f69 6e64 2c0a 2020  [::1] ap_ind,.  
+0003aa80: 2020 2320 6170 6572 7475 7265 733a 2070    # apertures: p
+0003aa90: 6f6c 7967 6f6e 2063 6f6f 7264 696e 6174  olygon coordinat
+0003aaa0: 6573 2061 7320 7468 7265 6520 3164 2061  es as three 1d a
+0003aab0: 7272 6179 730a 2020 2020 6e70 2e6e 6461  rrays.    np.nda
+0003aac0: 7272 6179 5b64 6f75 626c 652c 206e 6469  rray[double, ndi
+0003aad0: 6d3d 315d 2061 705f 782c 0a20 2020 206e  m=1] ap_x,.    n
+0003aae0: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
+0003aaf0: 2c20 6e64 696d 3d31 5d20 6170 5f79 2c0a  , ndim=1] ap_y,.
+0003ab00: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
+0003ab10: 6f75 626c 652c 206e 6469 6d3d 315d 2061  ouble, ndim=1] a
+0003ab20: 705f 7a2c 0a20 2020 2023 206e 6f72 6d61  p_z,.    # norma
+0003ab30: 6c20 756e 6974 2076 6563 746f 7273 0a20  l unit vectors. 
+0003ab40: 2020 2064 6f75 626c 655b 3a3a 315d 2061     double[::1] a
+0003ab50: 705f 6e6f 726d 5f78 2c0a 2020 2020 646f  p_norm_x,.    do
+0003ab60: 7562 6c65 5b3a 3a31 5d20 6170 5f6e 6f72  uble[::1] ap_nor
+0003ab70: 6d5f 792c 0a20 2020 2064 6f75 626c 655b  m_y,.    double[
+0003ab80: 3a3a 315d 2061 705f 6e6f 726d 5f7a 2c0a  ::1] ap_norm_z,.
+0003ab90: 2020 2020 2320 706f 7373 6962 6c65 2065      # possible e
+0003aba0: 7874 7261 2070 6172 616d 6574 6572 7320  xtra parameters 
+0003abb0: 3f0a 2020 2020 646f 7562 6c65 206d 6172  ?.    double mar
+0003abc0: 6769 6e3d 5f56 534d 414c 4c2c 0a20 2020  gin=_VSMALL,.   
+0003abd0: 2069 6e74 206e 756d 5f74 6872 6561 6473   int num_threads
+0003abe0: 3d31 302c 0a29 3a0a 0a20 2020 2023 202d  =10,.):..    # -
+0003abf0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2023  ----------.    #
+0003ac00: 2044 6563 6c61 7261 7469 6f6e 0a0a 2020   Declaration..  
+0003ac10: 2020 6364 6566 2069 6e74 206e 7074 7320    cdef int npts 
+0003ac20: 3d20 7074 735f 782e 7369 7a65 0a20 2020  = pts_x.size.   
+0003ac30: 2063 6465 6620 696e 7420 6e64 203d 2064   cdef int nd = d
+0003ac40: 6574 5f63 656e 7473 5f78 2e73 697a 650a  et_cents_x.size.
+0003ac50: 2020 2020 6364 6566 2069 6e74 206e 6120      cdef int na 
+0003ac60: 3d20 6170 5f6e 6f72 6d5f 782e 7369 7a65  = ap_norm_x.size
+0003ac70: 0a20 2020 2063 6465 6620 696e 7420 6464  .    cdef int dd
+0003ac80: 2c20 7070 2c20 6161 2c20 7474 0a20 2020  , pp, aa, tt.   
+0003ac90: 2063 6465 6620 696e 7420 6e70 610a 2020   cdef int npa.  
+0003aca0: 2020 6364 6566 2066 6c6f 6174 2073 6361    cdef float sca
+0003acb0: 2c20 7363 6130 2c20 7363 6131 0a20 2020  , sca0, sca1.   
+0003acc0: 2063 6465 6620 666c 6f61 7420 6b69 0a20   cdef float ki. 
+0003acd0: 2020 2063 6465 6620 6e70 2e6e 6461 7272     cdef np.ndarr
+0003ace0: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
+0003acf0: 315d 2061 705f 7830 203d 206e 702e 636f  1] ap_x0 = np.co
+0003ad00: 7079 2861 705f 7829 0a20 2020 2063 6465  py(ap_x).    cde
+0003ad10: 6620 6e70 2e6e 6461 7272 6179 5b64 6f75  f np.ndarray[dou
+0003ad20: 626c 652c 206e 6469 6d3d 315d 2061 705f  ble, ndim=1] ap_
+0003ad30: 7831 203d 206e 702e 636f 7079 2861 705f  x1 = np.copy(ap_
+0003ad40: 7829 0a20 2020 2063 6465 6620 6e70 2e6e  x).    cdef np.n
+0003ad50: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+0003ad60: 6469 6d3d 315d 2070 5f61 5f78 300a 2020  dim=1] p_a_x0.  
+0003ad70: 2020 6364 6566 206e 702e 6e64 6172 7261    cdef np.ndarra
+0003ad80: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
+0003ad90: 5d20 705f 615f 7831 0a20 2020 2063 6465  ] p_a_x1.    cde
+0003ada0: 6620 6e70 2e6e 6461 7272 6179 5b6c 6f6e  f np.ndarray[lon
+0003adb0: 672c 206e 6469 6d3d 325d 2074 7269 0a20  g, ndim=2] tri. 
+0003adc0: 2020 2063 6465 6620 6e70 2e6e 6461 7272     cdef np.ndarr
+0003add0: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
+0003ade0: 315d 2074 7269 5f78 0a20 2020 2063 6465  1] tri_x.    cde
+0003adf0: 6620 6e70 2e6e 6461 7272 6179 5b64 6f75  f np.ndarray[dou
+0003ae00: 626c 652c 206e 6469 6d3d 315d 2074 7269  ble, ndim=1] tri
+0003ae10: 5f79 0a20 2020 2063 6465 6620 6e70 2e6e  _y.    cdef np.n
+0003ae20: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+0003ae30: 6469 6d3d 315d 2074 7269 5f7a 0a0a 2020  dim=1] tri_z..  
+0003ae40: 2020 2320 696e 6974 6961 6c69 7a65 2073    # initialize s
+0003ae50: 6f6c 6964 2061 6e67 6c65 2061 7272 6179  olid angle array
+0003ae60: 2077 6974 6820 7a65 726f 730a 2020 2020   with zeros.    
+0003ae70: 6364 6566 206e 702e 6e64 6172 7261 795b  cdef np.ndarray[
+0003ae80: 646f 7562 6c65 2c20 6e64 696d 3d32 5d20  double, ndim=2] 
+0003ae90: 736f 6c69 645f 616e 676c 6520 3d20 6e70  solid_angle = np
+0003aea0: 2e7a 6572 6f73 2828 6e64 2c20 6e70 7473  .zeros((nd, npts
+0003aeb0: 292c 2064 7479 7065 3d66 6c6f 6174 290a  ), dtype=float).
+0003aec0: 0a20 2020 2023 202d 2d2d 2d2d 2d2d 0a20  .    # -------. 
+0003aed0: 2020 2023 2043 6f6d 7075 7465 0a0a 2020     # Compute..  
+0003aee0: 2020 666f 7220 6464 2069 6e20 7261 6e67    for dd in rang
+0003aef0: 6528 6e64 293a 0a0a 2020 2020 2020 2020  e(nd):..        
+0003af00: 2320 7072 696e 7428 2764 6574 5f63 656e  # print('det_cen
+0003af10: 7427 2c20 6465 745f 6365 6e74 735f 785b  t', det_cents_x[
+0003af20: 6464 5d2c 2064 6574 5f63 656e 7473 5f79  dd], det_cents_y
+0003af30: 5b64 645d 2c20 6465 745f 6365 6e74 735f  [dd], det_cents_
+0003af40: 7a5b 6464 5d29 0a20 2020 2020 2020 2023  z[dd]).        #
+0003af50: 2070 7269 6e74 2827 6465 745f 6e69 6e27   print('det_nin'
+0003af60: 2c20 6465 745f 6e6f 726d 5f78 5b64 645d  , det_norm_x[dd]
+0003af70: 2c20 6465 745f 6e6f 726d 5f79 5b64 645d  , det_norm_y[dd]
+0003af80: 2c20 6465 745f 6e6f 726d 5f7a 5b64 645d  , det_norm_z[dd]
+0003af90: 2920 2020 2020 2020 2023 2044 420a 2020  )        # DB.  
+0003afa0: 2020 2020 2020 2320 7072 696e 7428 2764        # print('d
+0003afb0: 6574 5f65 3027 2c20 6465 745f 6530 5f78  et_e0', det_e0_x
+0003afc0: 5b64 645d 2c20 6465 745f 6530 5f79 5b64  [dd], det_e0_y[d
+0003afd0: 645d 2c20 6465 745f 6530 5f7a 5b64 645d  d], det_e0_z[dd]
+0003afe0: 2920 2020 2020 2020 2023 2044 420a 2020  )        # DB.  
+0003aff0: 2020 2020 2020 2320 7072 696e 7428 2764        # print('d
+0003b000: 6574 5f65 3127 2c20 6465 745f 6531 5f78  et_e1', det_e1_x
+0003b010: 5b64 645d 2c20 6465 745f 6531 5f79 5b64  [dd], det_e1_y[d
+0003b020: 645d 2c20 6465 745f 6531 5f7a 5b64 645d  d], det_e1_z[dd]
+0003b030: 2920 2020 2020 2020 2023 2044 420a 0a20  )        # DB.. 
+0003b040: 2020 2020 2020 2023 206c 6f6f 7020 323a         # loop 2:
+0003b050: 206f 6e20 6e70 7473 2028 6f62 7365 7276   on npts (observ
+0003b060: 6174 696f 6e20 706f 696e 7473 290a 2020  ation points).  
+0003b070: 2020 2020 2020 666f 7220 7070 2069 6e20        for pp in 
+0003b080: 7261 6e67 6528 6e70 7473 293a 0a0a 2020  range(npts):..  
+0003b090: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
+0003b0a0: 7428 2770 7473 272c 2070 702c 2070 7473  t('pts', pp, pts
+0003b0b0: 5f78 5b70 705d 2c20 7074 735f 795b 7070  _x[pp], pts_y[pp
+0003b0c0: 5d2c 2070 7473 5f7a 5b70 705d 2920 2020  ], pts_z[pp])   
+0003b0d0: 2020 2020 2023 2044 420a 0a20 2020 2020       # DB..     
+0003b0e0: 2020 2020 2020 2023 2074 6573 7420 6966         # test if
+0003b0f0: 206f 6e20 676f 6f64 2073 6964 6520 6f66   on good side of
+0003b100: 2064 6574 6563 746f 720a 2020 2020 2020   detector.      
+0003b110: 2020 2020 2020 7363 6130 203d 2028 0a20        sca0 = (. 
+0003b120: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+0003b130: 7074 735f 785b 7070 5d20 2d20 6465 745f  pts_x[pp] - det_
+0003b140: 6365 6e74 735f 785b 6464 5d29 202a 2064  cents_x[dd]) * d
+0003b150: 6574 5f6e 6f72 6d5f 785b 6464 5d0a 2020  et_norm_x[dd].  
+0003b160: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+0003b170: 2870 7473 5f79 5b70 705d 202d 2064 6574  (pts_y[pp] - det
+0003b180: 5f63 656e 7473 5f79 5b64 645d 2920 2a20  _cents_y[dd]) * 
+0003b190: 6465 745f 6e6f 726d 5f79 5b64 645d 0a20  det_norm_y[dd]. 
+0003b1a0: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+0003b1b0: 2028 7074 735f 7a5b 7070 5d20 2d20 6465   (pts_z[pp] - de
+0003b1c0: 745f 6365 6e74 735f 7a5b 6464 5d29 202a  t_cents_z[dd]) *
+0003b1d0: 2064 6574 5f6e 6f72 6d5f 7a5b 6464 5d0a   det_norm_z[dd].
+0003b1e0: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+0003b1f0: 2020 2020 2020 2020 2020 2069 6620 7363             if sc
+0003b200: 6130 203c 3d20 303a 0a20 2020 2020 2020  a0 <= 0:.       
+0003b210: 2020 2020 2020 2020 2023 2070 7269 6e74           # print
+0003b220: 2827 736b 6970 272c 2073 6361 3029 2020  ('skip', sca0)  
+0003b230: 2020 2020 2020 2320 4442 0a20 2020 2020        # DB.     
+0003b240: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+0003b250: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
+0003b260: 2023 2066 6c61 670a 2020 2020 2020 2020   # flag.        
+0003b270: 2020 2020 6973 6f6b 203d 2054 7275 650a      isok = True.
+0003b280: 0a20 2020 2020 2020 2020 2020 2023 206c  .            # l
+0003b290: 6f6f 7020 333a 206f 6e20 6e61 2028 6170  oop 3: on na (ap
+0003b2a0: 6572 7475 7265 7329 0a20 2020 2020 2020  ertures).       
+0003b2b0: 2020 2020 2066 6f72 2061 6120 696e 2072       for aa in r
+0003b2c0: 616e 6765 286e 6129 3a0a 0a20 2020 2020  ange(na):..     
+0003b2d0: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
+0003b2e0: 6e74 2827 6170 272c 2061 6129 0a20 2020  nt('ap', aa).   
+0003b2f0: 2020 2020 2020 2020 2020 2020 2023 2070               # p
+0003b300: 7269 6e74 2827 6170 2069 6e64 272c 2061  rint('ap ind', a
+0003b310: 705f 696e 645b 6161 5d2c 2061 705f 696e  p_ind[aa], ap_in
+0003b320: 645b 6161 2b31 5d29 0a20 2020 2020 2020  d[aa+1]).       
+0003b330: 2020 2020 2020 2020 2023 2070 7269 6e74           # print
+0003b340: 2827 6170 206e 696e 272c 2061 705f 6e6f  ('ap nin', ap_no
+0003b350: 726d 5f78 5b61 615d 2c20 6170 5f6e 6f72  rm_x[aa], ap_nor
+0003b360: 6d5f 795b 6161 5d2c 2061 705f 6e6f 726d  m_y[aa], ap_norm
+0003b370: 5f7a 5b61 615d 290a 2020 2020 2020 2020  _z[aa]).        
+0003b380: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
+0003b390: 2761 705f 7827 2c20 6170 5f78 5b61 705f  'ap_x', ap_x[ap_
+0003b3a0: 696e 645b 6161 5d3a 6170 5f69 6e64 5b61  ind[aa]:ap_ind[a
+0003b3b0: 612b 315d 5d29 0a20 2020 2020 2020 2020  a+1]]).         
+0003b3c0: 2020 2020 2020 2023 2070 7269 6e74 2827         # print('
+0003b3d0: 6170 5f79 272c 2061 705f 795b 6170 5f69  ap_y', ap_y[ap_i
+0003b3e0: 6e64 5b61 615d 3a61 705f 696e 645b 6161  nd[aa]:ap_ind[aa
+0003b3f0: 2b31 5d5d 290a 2020 2020 2020 2020 2020  +1]]).          
+0003b400: 2020 2020 2020 2320 7072 696e 7428 2761        # print('a
+0003b410: 705f 7a27 2c20 6170 5f7a 5b61 705f 696e  p_z', ap_z[ap_in
+0003b420: 645b 6161 5d3a 6170 5f69 6e64 5b61 612b  d[aa]:ap_ind[aa+
+0003b430: 315d 5d29 0a0a 2020 2020 2020 2020 2020  1]])..          
+0003b440: 2020 2020 2020 2320 7465 7374 2069 6620        # test if 
+0003b450: 6f6e 2067 6f6f 6420 7369 6465 206f 6620  on good side of 
+0003b460: 6170 6572 7475 7265 0a20 2020 2020 2020  aperture.       
+0003b470: 2020 2020 2020 2020 2073 6361 203d 2028           sca = (
+0003b480: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003b490: 2020 2020 2028 7074 735f 785b 7070 5d20       (pts_x[pp] 
+0003b4a0: 2d20 6170 5f78 5b61 705f 696e 645b 6161  - ap_x[ap_ind[aa
+0003b4b0: 5d5d 2920 2a20 6170 5f6e 6f72 6d5f 785b  ]]) * ap_norm_x[
+0003b4c0: 6161 5d0a 2020 2020 2020 2020 2020 2020  aa].            
+0003b4d0: 2020 2020 2020 2020 2b20 2870 7473 5f79          + (pts_y
+0003b4e0: 5b70 705d 202d 2061 705f 795b 6170 5f69  [pp] - ap_y[ap_i
+0003b4f0: 6e64 5b61 615d 5d29 202a 2061 705f 6e6f  nd[aa]]) * ap_no
+0003b500: 726d 5f79 5b61 615d 0a20 2020 2020 2020  rm_y[aa].       
+0003b510: 2020 2020 2020 2020 2020 2020 202b 2028               + (
+0003b520: 7074 735f 7a5b 7070 5d20 2d20 6170 5f7a  pts_z[pp] - ap_z
+0003b530: 5b61 705f 696e 645b 6161 5d5d 2920 2a20  [ap_ind[aa]]) * 
+0003b540: 6170 5f6e 6f72 6d5f 7a5b 6161 5d0a 2020  ap_norm_z[aa].  
+0003b550: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003b560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003b570: 2069 6620 7363 6120 3c3d 2030 3a0a 2020   if sca <= 0:.  
+0003b580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b590: 2020 6973 6f6b 203d 2046 616c 7365 0a20    isok = False. 
+0003b5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b5b0: 2020 2062 7265 616b 0a0a 2020 2020 2020     break..      
+0003b5c0: 2020 2020 2020 2020 2020 2320 7465 7374            # test
+0003b5d0: 2069 6620 616c 6c20 6170 6572 7475 7265   if all aperture
+0003b5e0: 2070 6f69 6e74 7320 6361 6e20 6265 2070   points can be p
+0003b5f0: 726f 6a65 6374 6564 206f 6e20 6465 7465  rojected on dete
+0003b600: 6374 6f72 2070 6c61 6e65 2066 726f 6d20  ctor plane from 
+0003b610: 7074 730a 2020 2020 2020 2020 2020 2020  pts.            
+0003b620: 2020 2020 666f 7220 6c6c 2069 6e20 7261      for ll in ra
+0003b630: 6e67 6528 6170 5f69 6e64 5b61 615d 2c20  nge(ap_ind[aa], 
+0003b640: 6170 5f69 6e64 5b61 612b 315d 293a 0a20  ap_ind[aa+1]):. 
+0003b650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b660: 2020 2073 6361 3120 3d20 280a 2020 2020     sca1 = (.    
 0003b670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b680: 2020 2020 2020 2020 2861 705f 785b 6c6c          (ap_x[ll
-0003b690: 5d20 2d20 7074 735f 785b 7070 5d29 202a  ] - pts_x[pp]) *
-0003b6a0: 2064 6574 5f6e 6f72 6d5f 785b 6464 5d0a   det_norm_x[dd].
+0003b680: 2020 2020 2861 705f 785b 6c6c 5d20 2d20      (ap_x[ll] - 
+0003b690: 7074 735f 785b 7070 5d29 202a 2064 6574  pts_x[pp]) * det
+0003b6a0: 5f6e 6f72 6d5f 785b 6464 5d0a 2020 2020  _norm_x[dd].    
 0003b6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b6c0: 2020 2020 2020 2020 2b20 2861 705f 795b          + (ap_y[
-0003b6d0: 6c6c 5d20 2d20 7074 735f 795b 7070 5d29  ll] - pts_y[pp])
-0003b6e0: 202a 2064 6574 5f6e 6f72 6d5f 795b 6464   * det_norm_y[dd
-0003b6f0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003b700: 2020 2020 2020 2020 2020 2b20 2861 705f            + (ap_
-0003b710: 7a5b 6c6c 5d20 2d20 7074 735f 7a5b 7070  z[ll] - pts_z[pp
-0003b720: 5d29 202a 2064 6574 5f6e 6f72 6d5f 7a5b  ]) * det_norm_z[
-0003b730: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-0003b740: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-0003b750: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0003b760: 6620 7363 6131 203e 3d20 303a 0a20 2020  f sca1 >= 0:.   
+0003b6c0: 2020 2020 2b20 2861 705f 795b 6c6c 5d20      + (ap_y[ll] 
+0003b6d0: 2d20 7074 735f 795b 7070 5d29 202a 2064  - pts_y[pp]) * d
+0003b6e0: 6574 5f6e 6f72 6d5f 795b 6464 5d0a 2020  et_norm_y[dd].  
+0003b6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b700: 2020 2020 2020 2b20 2861 705f 7a5b 6c6c        + (ap_z[ll
+0003b710: 5d20 2d20 7074 735f 7a5b 7070 5d29 202a  ] - pts_z[pp]) *
+0003b720: 2064 6574 5f6e 6f72 6d5f 7a5b 6464 5d0a   det_norm_z[dd].
+0003b730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b740: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+0003b750: 2020 2020 2020 2020 2020 2069 6620 7363             if sc
+0003b760: 6131 203e 3d20 303a 0a20 2020 2020 2020  a1 >= 0:.       
 0003b770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b780: 2020 2020 2069 736f 6b20 3d20 4661 6c73       isok = Fals
-0003b790: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-0003b7a0: 2020 2020 2020 2020 2020 6272 6561 6b0a            break.
-0003b7b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003b7c0: 2020 2020 2023 2070 726f 6a65 6374 2069       # project i
-0003b7d0: 6e20 3264 0a20 2020 2020 2020 2020 2020  n 2d.           
-0003b7e0: 2020 2020 2020 2020 206b 203d 202d 2073           k = - s
-0003b7f0: 6361 3020 2f20 7363 6131 0a20 2020 2020  ca0 / sca1.     
-0003b800: 2020 2020 2020 2020 2020 2020 2020 2050                 P
-0003b810: 5f78 203d 2070 7473 5f78 5b70 705d 202b  _x = pts_x[pp] +
-0003b820: 206b 202a 2028 6170 5f78 5b6c 6c5d 202d   k * (ap_x[ll] -
-0003b830: 2070 7473 5f78 5b70 705d 290a 2020 2020   pts_x[pp]).    
-0003b840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b850: 505f 7920 3d20 7074 735f 795b 7070 5d20  P_y = pts_y[pp] 
-0003b860: 2b20 6b20 2a20 2861 705f 795b 6c6c 5d20  + k * (ap_y[ll] 
-0003b870: 2d20 7074 735f 795b 7070 5d29 0a20 2020  - pts_y[pp]).   
-0003b880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b890: 2050 5f7a 203d 2070 7473 5f7a 5b70 705d   P_z = pts_z[pp]
-0003b8a0: 202b 206b 202a 2028 6170 5f7a 5b6c 6c5d   + k * (ap_z[ll]
-0003b8b0: 202d 2070 7473 5f7a 5b70 705d 290a 0a20   - pts_z[pp]).. 
-0003b8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b8d0: 2020 2023 2070 726f 6a65 6374 2069 6e20     # project in 
-0003b8e0: 3264 0a20 2020 2020 2020 2020 2020 2020  2d.             
-0003b8f0: 2020 2020 2020 2061 705f 7830 5b6c 6c5d         ap_x0[ll]
-0003b900: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-0003b910: 2020 2020 2020 2020 2020 2020 2028 505f               (P_
-0003b920: 7820 2d20 6465 745f 6365 6e74 735f 785b  x - det_cents_x[
-0003b930: 6464 5d29 202a 2064 6574 5f65 305f 785b  dd]) * det_e0_x[
-0003b940: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-0003b950: 2020 2020 2020 2020 2020 2020 2b20 2850              + (P
-0003b960: 5f79 202d 2064 6574 5f63 656e 7473 5f79  _y - det_cents_y
-0003b970: 5b64 645d 2920 2a20 6465 745f 6530 5f79  [dd]) * det_e0_y
-0003b980: 5b64 645d 0a20 2020 2020 2020 2020 2020  [dd].           
-0003b990: 2020 2020 2020 2020 2020 2020 202b 2028               + (
-0003b9a0: 505f 7a20 2d20 6465 745f 6365 6e74 735f  P_z - det_cents_
-0003b9b0: 7a5b 6464 5d29 202a 2064 6574 5f65 305f  z[dd]) * det_e0_
-0003b9c0: 7a5b 6464 5d0a 2020 2020 2020 2020 2020  z[dd].          
-0003b9d0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-0003b9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003b9f0: 6170 5f78 315b 6c6c 5d20 3d20 280a 2020  ap_x1[ll] = (.  
+0003b780: 2069 736f 6b20 3d20 4661 6c73 650a 2020   isok = False.  
+0003b790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b7a0: 2020 2020 2020 6272 6561 6b0a 0a20 2020        break..   
+0003b7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b7c0: 2023 2070 726f 6a65 6374 2069 6e20 3264   # project in 2d
+0003b7d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003b7e0: 2020 2020 206b 203d 202d 2073 6361 3020       k = - sca0 
+0003b7f0: 2f20 7363 6131 0a20 2020 2020 2020 2020  / sca1.         
+0003b800: 2020 2020 2020 2020 2020 2050 5f78 203d             P_x =
+0003b810: 2070 7473 5f78 5b70 705d 202b 206b 202a   pts_x[pp] + k *
+0003b820: 2028 6170 5f78 5b6c 6c5d 202d 2070 7473   (ap_x[ll] - pts
+0003b830: 5f78 5b70 705d 290a 2020 2020 2020 2020  _x[pp]).        
+0003b840: 2020 2020 2020 2020 2020 2020 505f 7920              P_y 
+0003b850: 3d20 7074 735f 795b 7070 5d20 2b20 6b20  = pts_y[pp] + k 
+0003b860: 2a20 2861 705f 795b 6c6c 5d20 2d20 7074  * (ap_y[ll] - pt
+0003b870: 735f 795b 7070 5d29 0a20 2020 2020 2020  s_y[pp]).       
+0003b880: 2020 2020 2020 2020 2020 2020 2050 5f7a               P_z
+0003b890: 203d 2070 7473 5f7a 5b70 705d 202b 206b   = pts_z[pp] + k
+0003b8a0: 202a 2028 6170 5f7a 5b6c 6c5d 202d 2070   * (ap_z[ll] - p
+0003b8b0: 7473 5f7a 5b70 705d 290a 0a20 2020 2020  ts_z[pp])..     
+0003b8c0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0003b8d0: 2070 726f 6a65 6374 2069 6e20 3264 0a20   project in 2d. 
+0003b8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b8f0: 2020 2061 705f 7830 5b6c 6c5d 203d 2028     ap_x0[ll] = (
+0003b900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003b910: 2020 2020 2020 2020 2028 505f 7820 2d20           (P_x - 
+0003b920: 6465 745f 6365 6e74 735f 785b 6464 5d29  det_cents_x[dd])
+0003b930: 202a 2064 6574 5f65 305f 785b 6464 5d0a   * det_e0_x[dd].
+0003b940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003b950: 2020 2020 2020 2020 2b20 2850 5f79 202d          + (P_y -
+0003b960: 2064 6574 5f63 656e 7473 5f79 5b64 645d   det_cents_y[dd]
+0003b970: 2920 2a20 6465 745f 6530 5f79 5b64 645d  ) * det_e0_y[dd]
+0003b980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003b990: 2020 2020 2020 2020 202b 2028 505f 7a20           + (P_z 
+0003b9a0: 2d20 6465 745f 6365 6e74 735f 7a5b 6464  - det_cents_z[dd
+0003b9b0: 5d29 202a 2064 6574 5f65 305f 7a5b 6464  ]) * det_e0_z[dd
+0003b9c0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0003b9d0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0003b9e0: 2020 2020 2020 2020 2020 2020 6170 5f78              ap_x
+0003b9f0: 315b 6c6c 5d20 3d20 280a 2020 2020 2020  1[ll] = (.      
 0003ba00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003ba10: 2020 2020 2020 2850 5f78 202d 2064 6574        (P_x - det
-0003ba20: 5f63 656e 7473 5f78 5b64 645d 2920 2a20  _cents_x[dd]) * 
-0003ba30: 6465 745f 6531 5f78 5b64 645d 0a20 2020  det_e1_x[dd].   
+0003ba10: 2020 2850 5f78 202d 2064 6574 5f63 656e    (P_x - det_cen
+0003ba20: 7473 5f78 5b64 645d 2920 2a20 6465 745f  ts_x[dd]) * det_
+0003ba30: 6531 5f78 5b64 645d 0a20 2020 2020 2020  e1_x[dd].       
 0003ba40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003ba50: 2020 2020 202b 2028 505f 7920 2d20 6465       + (P_y - de
-0003ba60: 745f 6365 6e74 735f 795b 6464 5d29 202a  t_cents_y[dd]) *
-0003ba70: 2064 6574 5f65 315f 795b 6464 5d0a 2020   det_e1_y[dd].  
+0003ba50: 202b 2028 505f 7920 2d20 6465 745f 6365   + (P_y - det_ce
+0003ba60: 6e74 735f 795b 6464 5d29 202a 2064 6574  nts_y[dd]) * det
+0003ba70: 5f65 315f 795b 6464 5d0a 2020 2020 2020  _e1_y[dd].      
 0003ba80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003ba90: 2020 2020 2020 2b20 2850 5f7a 202d 2064        + (P_z - d
-0003baa0: 6574 5f63 656e 7473 5f7a 5b64 645d 2920  et_cents_z[dd]) 
-0003bab0: 2a20 6465 745f 6531 5f7a 5b64 645d 0a20  * det_e1_z[dd]. 
-0003bac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003bad0: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
-0003bae0: 2020 2020 2020 6966 206e 6f74 2069 736f        if not iso
-0003baf0: 6b3a 0a20 2020 2020 2020 2020 2020 2020  k:.             
-0003bb00: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
-0003bb10: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0003bb20: 7072 696e 7428 2773 6361 302c 2073 6361  print('sca0, sca
-0003bb30: 312c 206b 2020 272c 2073 6361 302c 2073  1, k  ', sca0, s
-0003bb40: 6361 312c 206b 290a 2020 2020 2020 2020  ca1, k).        
-0003bb50: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
-0003bb60: 2750 782c 2050 792c 2050 7a3a 2020 272c  'Px, Py, Pz:  ',
-0003bb70: 2050 5f78 2c20 505f 792c 2050 5f7a 290a   P_x, P_y, P_z).
-0003bb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003bb90: 2320 7072 696e 7428 0a20 2020 2020 2020  # print(.       
-0003bba0: 2020 2020 2020 2020 2020 2020 2023 2027               # '
-0003bbb0: 6170 3031 3a20 272c 0a20 2020 2020 2020  ap01: ',.       
-0003bbc0: 2020 2020 2020 2020 2020 2020 2023 2061               # a
-0003bbd0: 705f 7830 5b61 705f 696e 645b 6161 5d3a  p_x0[ap_ind[aa]:
-0003bbe0: 6170 5f69 6e64 5b61 612b 315d 5d2c 0a20  ap_ind[aa+1]],. 
-0003bbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003bc00: 2020 2023 2061 705f 7831 5b61 705f 696e     # ap_x1[ap_in
-0003bc10: 645b 6161 5d3a 6170 5f69 6e64 5b61 612b  d[aa]:ap_ind[aa+
-0003bc20: 315d 5d2c 0a20 2020 2020 2020 2020 2020  1]],.           
-0003bc30: 2020 2020 2023 2029 0a0a 0a20 2020 2020       # )...     
-0003bc40: 2020 2020 2020 2023 2067 6f20 746f 206e         # go to n
-0003bc50: 6578 7420 706f 696e 740a 2020 2020 2020  ext point.      
-0003bc60: 2020 2020 2020 6966 206e 6f74 2069 736f        if not iso
-0003bc70: 6b3a 0a20 2020 2020 2020 2020 2020 2020  k:.             
-0003bc80: 2020 2023 2070 7269 6e74 2827 736b 6970     # print('skip
-0003bc90: 2032 272c 2073 6361 2c20 6161 2920 2020   2', sca, aa)   
-0003bca0: 2020 2020 2023 2044 420a 2020 2020 2020       # DB.      
-0003bcb0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-0003bcc0: 7565 0a0a 2020 2020 2020 2020 2020 2020  ue..            
-0003bcd0: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
-0003bce0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-0003bcf0: 2020 2020 2020 2020 2020 2023 2063 6f6d             # com
-0003bd00: 7075 7465 2070 6f6c 7967 6f6e 2069 6e74  pute polygon int
-0003bd10: 6572 7365 6374 696f 6e0a 0a20 2020 2020  ersection..     
-0003bd20: 2020 2020 2020 2023 2063 6f6d 7075 7465         # compute
-0003bd30: 2069 6e74 6572 7365 6374 696f 6e0a 2020   intersection.  
-0003bd40: 2020 2020 2020 2020 2020 705f 6120 3d20            p_a = 
-0003bd50: 706c 672e 506f 6c79 676f 6e28 6e70 2e61  plg.Polygon(np.a
-0003bd60: 7272 6179 285b 6465 745f 6f75 746c 696e  rray([det_outlin
-0003bd70: 655f 7830 2c20 6465 745f 6f75 746c 696e  e_x0, det_outlin
-0003bd80: 655f 7831 5d29 2e54 290a 2020 2020 2020  e_x1]).T).      
-0003bd90: 2020 2020 2020 666f 7220 6161 2069 6e20        for aa in 
-0003bda0: 7261 6e67 6528 6e61 293a 0a20 2020 2020  range(na):.     
-0003bdb0: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
-0003bdc0: 6e74 2827 705f 613a 2027 2c20 6e70 2e61  nt('p_a: ', np.a
-0003bdd0: 7272 6179 2870 5f61 2e63 6f6e 746f 7572  rray(p_a.contour
-0003bde0: 2830 2929 2e54 290a 2020 2020 2020 2020  (0)).T).        
-0003bdf0: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
-0003be00: 2777 6974 683a 2027 2c20 6170 5f78 305b  'with: ', ap_x0[
-0003be10: 6170 5f69 6e64 5b61 615d 3a61 705f 696e  ap_ind[aa]:ap_in
-0003be20: 645b 6161 2b31 5d5d 2c20 6170 5f78 315b  d[aa+1]], ap_x1[
-0003be30: 6170 5f69 6e64 5b61 615d 3a61 705f 696e  ap_ind[aa]:ap_in
-0003be40: 645b 6161 2b31 5d5d 290a 2020 2020 2020  d[aa+1]]).      
-0003be50: 2020 2020 2020 2020 2020 705f 6120 3d20            p_a = 
-0003be60: 705f 6120 2620 706c 672e 506f 6c79 676f  p_a & plg.Polygo
-0003be70: 6e28 6e70 2e61 7272 6179 285b 0a20 2020  n(np.array([.   
-0003be80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003be90: 2061 705f 7830 5b61 705f 696e 645b 6161   ap_x0[ap_ind[aa
-0003bea0: 5d3a 6170 5f69 6e64 5b61 612b 315d 5d2c  ]:ap_ind[aa+1]],
-0003beb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003bec0: 2020 2020 2061 705f 7831 5b61 705f 696e       ap_x1[ap_in
-0003bed0: 645b 6161 5d3a 6170 5f69 6e64 5b61 612b  d[aa]:ap_ind[aa+
-0003bee0: 315d 5d2c 0a20 2020 2020 2020 2020 2020  1]],.           
-0003bef0: 2020 2020 205d 292e 5429 0a0a 2020 2020       ]).T)..    
-0003bf00: 2020 2020 2020 2020 2020 2020 2320 7374              # st
-0003bf10: 6f70 2069 6620 6e6f 2069 6e74 6572 7365  op if no interse
-0003bf20: 6374 696f 6e0a 2020 2020 2020 2020 2020  ction.          
-0003bf30: 2020 2020 2020 6966 2070 5f61 2e6e 506f        if p_a.nPo
-0003bf40: 696e 7473 2829 203c 2033 3a0a 2020 2020  ints() < 3:.    
-0003bf50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003bf60: 6973 6f6b 203d 2046 616c 7365 0a20 2020  isok = False.   
-0003bf70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003bf80: 2062 7265 616b 0a0a 2020 2020 2020 2020   break..        
-0003bf90: 2020 2020 2320 7374 6f70 2069 6620 6e6f      # stop if no
-0003bfa0: 2069 6e74 6572 7365 6374 696f 6e0a 2020   intersection.  
-0003bfb0: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
-0003bfc0: 2069 736f 6b3a 0a20 2020 2020 2020 2020   isok:.         
-0003bfd0: 2020 2020 2020 2023 2070 7269 6e74 2827         # print('
-0003bfe0: 736b 6970 2033 2729 2020 2020 2020 2020  skip 3')        
-0003bff0: 2320 4442 0a20 2020 2020 2020 2020 2020  # DB.           
-0003c000: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
-0003c010: 2020 2020 2020 2020 2020 2023 202d 2d2d             # ---
-0003c020: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0003c030: 0a20 2020 2020 2020 2020 2020 2023 2072  .            # r
-0003c040: 6562 7569 6c64 2033 6420 706f 6c79 676f  ebuild 3d polygo
-0003c050: 6e0a 0a20 2020 2020 2020 2020 2020 2023  n..            #
-0003c060: 2063 6865 636b 2063 6377 0a20 2020 2020   check ccw.     
-0003c070: 2020 2020 2020 2070 5f61 5f78 3020 3d20         p_a_x0 = 
-0003c080: 6e70 2e61 7363 6f6e 7469 6775 6f75 7361  np.ascontiguousa
-0003c090: 7272 6179 286e 702e 6172 7261 7928 705f  rray(np.array(p_
-0003c0a0: 612e 636f 6e74 6f75 7228 3029 295b 3a2c  a.contour(0))[:,
-0003c0b0: 2030 5d29 0a20 2020 2020 2020 2020 2020   0]).           
-0003c0c0: 2070 5f61 5f78 3120 3d20 6e70 2e61 7363   p_a_x1 = np.asc
-0003c0d0: 6f6e 7469 6775 6f75 7361 7272 6179 286e  ontiguousarray(n
-0003c0e0: 702e 6172 7261 7928 705f 612e 636f 6e74  p.array(p_a.cont
-0003c0f0: 6f75 7228 3029 295b 3a2c 2031 5d29 0a20  our(0))[:, 1]). 
-0003c100: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-0003c110: 7420 5f63 6865 636b 5f70 6f6c 7967 6f6e  t _check_polygon
-0003c120: 5f32 645f 636f 756e 7465 725f 636c 6f63  _2d_counter_cloc
-0003c130: 6b77 6973 6528 705f 615f 7830 2c20 705f  kwise(p_a_x0, p_
-0003c140: 615f 7831 293a 0a20 2020 2020 2020 2020  a_x1):.         
-0003c150: 2020 2020 2020 2070 5f61 5f78 3020 3d20         p_a_x0 = 
-0003c160: 6e70 2e61 7363 6f6e 7469 6775 6f75 7361  np.ascontiguousa
-0003c170: 7272 6179 2870 5f61 5f78 305b 3a3a 2d31  rray(p_a_x0[::-1
-0003c180: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-0003c190: 2020 2070 5f61 5f78 3120 3d20 6e70 2e61     p_a_x1 = np.a
-0003c1a0: 7363 6f6e 7469 6775 6f75 7361 7272 6179  scontiguousarray
-0003c1b0: 2870 5f61 5f78 315b 3a3a 2d31 5d29 0a0a  (p_a_x1[::-1])..
-0003c1c0: 2020 2020 2020 2020 2020 2020 2320 7472              # tr
-0003c1d0: 6961 6e67 756c 6174 6520 6279 2065 6172  iangulate by ear
-0003c1e0: 2d63 6c69 7070 696e 6720 2829 0a20 2020  -clipping ().   
-0003c1f0: 2020 2020 2020 2020 2074 7269 203d 2074           tri = t
-0003c200: 7269 616e 6775 6c61 7465 5f62 795f 6561  riangulate_by_ea
-0003c210: 7263 6c69 7070 696e 675f 3264 280a 2020  rclipping_2d(.  
-0003c220: 2020 2020 2020 2020 2020 2020 2020 6e70                np
-0003c230: 2e61 7363 6f6e 7469 6775 6f75 7361 7272  .ascontiguousarr
-0003c240: 6179 285b 705f 615f 7830 2c20 705f 615f  ay([p_a_x0, p_a_
-0003c250: 7831 5d29 0a20 2020 2020 2020 2020 2020  x1]).           
-0003c260: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
-0003c270: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
-0003c280: 2d2d 2d2d 2d0a 2020 2020 2020 2020 2020  -----.          
-0003c290: 2020 2320 636f 6d70 7574 6520 736f 6c69    # compute soli
-0003c2a0: 6420 616e 676c 650a 0a20 2020 2020 2020  d angle..       
-0003c2b0: 2020 2020 2023 206c 6f6f 7020 6f6e 2074       # loop on t
-0003c2c0: 7269 616e 676c 6573 0a20 2020 2020 2020  riangles.       
-0003c2d0: 2020 2020 2066 6f72 2074 7420 696e 2072       for tt in r
-0003c2e0: 616e 6765 2874 7269 2e73 6861 7065 5b30  ange(tri.shape[0
-0003c2f0: 5d29 3a0a 0a20 2020 2020 2020 2020 2020  ]):..           
-0003c300: 2020 2020 2023 2067 6574 2074 7269 616e       # get trian
-0003c310: 676c 650a 2020 2020 2020 2020 2020 2020  gle.            
-0003c320: 2020 2020 7472 695f 7820 3d20 280a 2020      tri_x = (.  
-0003c330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c340: 2020 6465 745f 6365 6e74 735f 785b 6464    det_cents_x[dd
-0003c350: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003c360: 2020 2020 2020 2b20 705f 615f 7830 5b74        + p_a_x0[t
-0003c370: 7269 5b74 742c 203a 5d5d 202a 2064 6574  ri[tt, :]] * det
-0003c380: 5f65 305f 785b 6464 5d0a 2020 2020 2020  _e0_x[dd].      
-0003c390: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0003c3a0: 705f 615f 7831 5b74 7269 5b74 742c 203a  p_a_x1[tri[tt, :
-0003c3b0: 5d5d 202a 2064 6574 5f65 315f 785b 6464  ]] * det_e1_x[dd
-0003c3c0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003c3d0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0003c3e0: 2020 2020 7472 695f 7920 3d20 280a 2020      tri_y = (.  
-0003c3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c400: 2020 6465 745f 6365 6e74 735f 795b 6464    det_cents_y[dd
-0003c410: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003c420: 2020 2020 2020 2b20 705f 615f 7830 5b74        + p_a_x0[t
-0003c430: 7269 5b74 742c 203a 5d5d 202a 2064 6574  ri[tt, :]] * det
-0003c440: 5f65 305f 795b 6464 5d0a 2020 2020 2020  _e0_y[dd].      
-0003c450: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0003c460: 705f 615f 7831 5b74 7269 5b74 742c 203a  p_a_x1[tri[tt, :
-0003c470: 5d5d 202a 2064 6574 5f65 315f 795b 6464  ]] * det_e1_y[dd
-0003c480: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003c490: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0003c4a0: 2020 2020 7472 695f 7a20 3d20 280a 2020      tri_z = (.  
-0003c4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c4c0: 2020 6465 745f 6365 6e74 735f 7a5b 6464    det_cents_z[dd
-0003c4d0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003c4e0: 2020 2020 2020 2b20 705f 615f 7830 5b74        + p_a_x0[t
-0003c4f0: 7269 5b74 742c 203a 5d5d 202a 2064 6574  ri[tt, :]] * det
-0003c500: 5f65 305f 7a5b 6464 5d0a 2020 2020 2020  _e0_z[dd].      
-0003c510: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0003c520: 705f 615f 7831 5b74 7269 5b74 742c 203a  p_a_x1[tri[tt, :
-0003c530: 5d5d 202a 2064 6574 5f65 315f 7a5b 6464  ]] * det_e1_z[dd
-0003c540: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003c550: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
-0003c560: 2020 2020 2023 2063 6f6d 7075 7461 7469       # computati
-0003c570: 6f6e 2032 3a20 736f 6c69 6420 616e 676c  on 2: solid angl
-0003c580: 6520 6f66 2074 7269 616e 676c 6520 6672  e of triangle fr
-0003c590: 6f6d 2070 7473 0a20 2020 2020 2020 2020  om pts.         
-0003c5a0: 2020 2020 2020 2073 6f6c 6964 5f61 6e67         solid_ang
-0003c5b0: 6c65 5b64 642c 2070 705d 202b 3d20 5f73  le[dd, pp] += _s
-0003c5c0: 742e 636f 6d70 5f73 615f 7472 6928 0a20  t.comp_sa_tri(. 
-0003c5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c5e0: 2020 2074 7269 5f78 5b30 5d2c 0a20 2020     tri_x[0],.   
-0003c5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c600: 2074 7269 5f79 5b30 5d2c 0a20 2020 2020   tri_y[0],.     
-0003c610: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0003c620: 7269 5f7a 5b30 5d2c 0a20 2020 2020 2020  ri_z[0],.       
-0003c630: 2020 2020 2020 2020 2020 2020 2074 7269               tri
-0003c640: 5f78 5b31 5d2c 0a20 2020 2020 2020 2020  _x[1],.         
-0003c650: 2020 2020 2020 2020 2020 2074 7269 5f79             tri_y
-0003c660: 5b31 5d2c 0a20 2020 2020 2020 2020 2020  [1],.           
-0003c670: 2020 2020 2020 2020 2074 7269 5f7a 5b31           tri_z[1
-0003c680: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-0003c690: 2020 2020 2020 2074 7269 5f78 5b32 5d2c         tri_x[2],
-0003c6a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003c6b0: 2020 2020 2074 7269 5f79 5b32 5d2c 0a20       tri_y[2],. 
-0003c6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c6d0: 2020 2074 7269 5f7a 5b32 5d2c 0a20 2020     tri_z[2],.   
-0003c6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c6f0: 2070 7473 5f78 5b70 705d 2c0a 2020 2020   pts_x[pp],.    
-0003c700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003c710: 7074 735f 795b 7070 5d2c 0a20 2020 2020  pts_y[pp],.     
-0003c720: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0003c730: 7473 5f7a 5b70 705d 2c0a 2020 2020 2020  ts_z[pp],.      
-0003c740: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-0003c750: 2020 2020 2020 2020 2020 2020 2320 7072              # pr
-0003c760: 696e 7428 2774 7269 272c 2074 742c 2073  int('tri', tt, s
-0003c770: 6f6c 6964 5f61 6e67 6c65 5b64 642c 2070  olid_angle[dd, p
-0003c780: 705d 2920 2020 2020 2020 2023 2044 420a  p])        # DB.
-0003c790: 0a20 2020 2023 202d 2d2d 2d2d 2d2d 0a20  .    # -------. 
-0003c7a0: 2020 2023 2052 6574 7572 6e0a 0a20 2020     # Return..   
-0003c7b0: 2072 6574 7572 6e20 736f 6c69 645f 616e   return solid_an
-0003c7c0: 676c 650a 0a0a 6465 6620 636f 6d70 7574  gle...def comput
-0003c7d0: 655f 736f 6c69 645f 616e 676c 655f 6170  e_solid_angle_ap
-0003c7e0: 6572 7475 7265 735f 6c69 6768 745f 7375  ertures_light_su
-0003c7f0: 6d6d 6564 280a 2020 2020 2320 7074 733a  mmed(.    # pts:
-0003c800: 2063 6f6f 7264 696e 6174 6573 2061 7320   coordinates as 
-0003c810: 7468 7265 6520 3164 2061 7272 6179 730a  three 1d arrays.
-0003c820: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
-0003c830: 7074 735f 782c 0a20 2020 2064 6f75 626c  pts_x,.    doubl
-0003c840: 655b 3a3a 315d 2070 7473 5f79 2c0a 2020  e[::1] pts_y,.  
-0003c850: 2020 646f 7562 6c65 5b3a 3a31 5d20 7074    double[::1] pt
-0003c860: 735f 7a2c 0a20 2020 2023 2064 6574 6563  s_z,.    # detec
-0003c870: 746f 7273 3a20 706f 6c79 676f 6e20 636f  tors: polygon co
-0003c880: 6f72 6469 6e61 7465 7320 696e 2032 6420  ordinates in 2d 
-0003c890: 2863 6f6d 6d6f 6e20 746f 2061 6c6c 2064  (common to all d
-0003c8a0: 6574 6563 746f 7273 290a 2020 2020 646f  etectors).    do
-0003c8b0: 7562 6c65 5b3a 3a31 5d20 6465 745f 6f75  uble[::1] det_ou
-0003c8c0: 746c 696e 655f 7830 2c0a 2020 2020 646f  tline_x0,.    do
-0003c8d0: 7562 6c65 5b3a 3a31 5d20 6465 745f 6f75  uble[::1] det_ou
-0003c8e0: 746c 696e 655f 7831 2c0a 2020 2020 2320  tline_x1,.    # 
-0003c8f0: 6465 7465 6374 6f72 733a 2063 656e 7465  detectors: cente
-0003c900: 7273 2063 6f6f 7264 696e 6174 6573 2061  rs coordinates a
-0003c910: 7320 7468 7265 6520 3164 2061 7272 6179  s three 1d array
-0003c920: 730a 2020 2020 646f 7562 6c65 5b3a 3a31  s.    double[::1
-0003c930: 5d20 6465 745f 6365 6e74 735f 782c 0a20  ] det_cents_x,. 
-0003c940: 2020 2064 6f75 626c 655b 3a3a 315d 2064     double[::1] d
-0003c950: 6574 5f63 656e 7473 5f79 2c0a 2020 2020  et_cents_y,.    
-0003c960: 646f 7562 6c65 5b3a 3a31 5d20 6465 745f  double[::1] det_
-0003c970: 6365 6e74 735f 7a2c 0a20 2020 2023 2064  cents_z,.    # d
-0003c980: 6574 6563 746f 7273 3a20 6e6f 726d 616c  etectors: normal
-0003c990: 2075 6e69 7420 7665 6374 6f72 7320 6173   unit vectors as
-0003c9a0: 2074 6872 6565 2031 6420 6172 7261 7973   three 1d arrays
-0003c9b0: 2028 6e64 203d 206c 656e 2864 6574 5f6e   (nd = len(det_n
-0003c9c0: 6f72 6d5f 7829 290a 2020 2020 646f 7562  orm_x)).    doub
-0003c9d0: 6c65 5b3a 3a31 5d20 6465 745f 6e6f 726d  le[::1] det_norm
-0003c9e0: 5f78 2c0a 2020 2020 646f 7562 6c65 5b3a  _x,.    double[:
-0003c9f0: 3a31 5d20 6465 745f 6e6f 726d 5f79 2c0a  :1] det_norm_y,.
-0003ca00: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
-0003ca10: 6465 745f 6e6f 726d 5f7a 2c0a 2020 2020  det_norm_z,.    
-0003ca20: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0003ca30: 652c 206e 6469 6d3d 315d 2064 6574 5f65  e, ndim=1] det_e
-0003ca40: 305f 782c 0a20 2020 206e 702e 6e64 6172  0_x,.    np.ndar
-0003ca50: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
-0003ca60: 3d31 5d20 6465 745f 6530 5f79 2c0a 2020  =1] det_e0_y,.  
-0003ca70: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
-0003ca80: 626c 652c 206e 6469 6d3d 315d 2064 6574  ble, ndim=1] det
-0003ca90: 5f65 305f 7a2c 0a20 2020 206e 702e 6e64  _e0_z,.    np.nd
-0003caa0: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
-0003cab0: 696d 3d31 5d20 6465 745f 6531 5f78 2c0a  im=1] det_e1_x,.
-0003cac0: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
-0003cad0: 6f75 626c 652c 206e 6469 6d3d 315d 2064  ouble, ndim=1] d
-0003cae0: 6574 5f65 315f 792c 0a20 2020 206e 702e  et_e1_y,.    np.
-0003caf0: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-0003cb00: 6e64 696d 3d31 5d20 6465 745f 6531 5f7a  ndim=1] det_e1_z
-0003cb10: 2c0a 2020 2020 2320 6170 6572 7475 7265  ,.    # aperture
-0003cb20: 733a 2069 6e64 6963 6573 206f 6620 6669  s: indices of fi
-0003cb30: 7273 7420 636f 726e 6572 206f 6620 6561  rst corner of ea
-0003cb40: 6368 2061 7020 706f 6c79 676f 6e3a 206e  ch ap polygon: n
-0003cb50: 6120 3d20 6c65 6e28 6170 5f69 6e64 290a  a = len(ap_ind).
-0003cb60: 2020 2020 6c6f 6e67 5b3a 3a31 5d20 6170      long[::1] ap
-0003cb70: 5f69 6e64 2c0a 2020 2020 2320 6170 6572  _ind,.    # aper
-0003cb80: 7475 7265 733a 2070 6f6c 7967 6f6e 2063  tures: polygon c
-0003cb90: 6f6f 7264 696e 6174 6573 2061 7320 7468  oordinates as th
-0003cba0: 7265 6520 3164 2061 7272 6179 730a 2020  ree 1d arrays.  
-0003cbb0: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
-0003cbc0: 626c 652c 206e 6469 6d3d 315d 2061 705f  ble, ndim=1] ap_
-0003cbd0: 782c 0a20 2020 206e 702e 6e64 6172 7261  x,.    np.ndarra
-0003cbe0: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
-0003cbf0: 5d20 6170 5f79 2c0a 2020 2020 6e70 2e6e  ] ap_y,.    np.n
-0003cc00: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
-0003cc10: 6469 6d3d 315d 2061 705f 7a2c 0a20 2020  dim=1] ap_z,.   
-0003cc20: 2023 206e 6f72 6d61 6c20 756e 6974 2076   # normal unit v
-0003cc30: 6563 746f 7273 0a20 2020 2064 6f75 626c  ectors.    doubl
-0003cc40: 655b 3a3a 315d 2061 705f 6e6f 726d 5f78  e[::1] ap_norm_x
-0003cc50: 2c0a 2020 2020 646f 7562 6c65 5b3a 3a31  ,.    double[::1
-0003cc60: 5d20 6170 5f6e 6f72 6d5f 792c 0a20 2020  ] ap_norm_y,.   
-0003cc70: 2064 6f75 626c 655b 3a3a 315d 2061 705f   double[::1] ap_
-0003cc80: 6e6f 726d 5f7a 2c0a 2020 2020 2320 706f  norm_z,.    # po
-0003cc90: 7373 6962 6c65 2065 7874 7261 2070 6172  ssible extra par
-0003cca0: 616d 6574 6572 7320 3f0a 2020 2020 646f  ameters ?.    do
-0003ccb0: 7562 6c65 206d 6172 6769 6e3d 5f56 534d  uble margin=_VSM
-0003ccc0: 414c 4c2c 0a20 2020 2069 6e74 206e 756d  ALL,.    int num
-0003ccd0: 5f74 6872 6561 6473 3d31 302c 0a29 3a0a  _threads=10,.):.
-0003cce0: 0a20 2020 2023 202d 2d2d 2d2d 2d2d 2d2d  .    # ---------
-0003ccf0: 2d2d 0a20 2020 2023 2044 6563 6c61 7261  --.    # Declara
-0003cd00: 7469 6f6e 0a0a 2020 2020 6364 6566 2069  tion..    cdef i
-0003cd10: 6e74 206e 7074 7320 3d20 7074 735f 782e  nt npts = pts_x.
-0003cd20: 7369 7a65 0a20 2020 2063 6465 6620 696e  size.    cdef in
-0003cd30: 7420 6e64 203d 2064 6574 5f63 656e 7473  t nd = det_cents
-0003cd40: 5f78 2e73 697a 650a 2020 2020 6364 6566  _x.size.    cdef
-0003cd50: 2069 6e74 206e 6120 3d20 6170 5f6e 6f72   int na = ap_nor
-0003cd60: 6d5f 782e 7369 7a65 0a20 2020 2063 6465  m_x.size.    cde
-0003cd70: 6620 696e 7420 6464 2c20 7070 2c20 6161  f int dd, pp, aa
-0003cd80: 2c20 7474 0a20 2020 2063 6465 6620 696e  , tt.    cdef in
-0003cd90: 7420 6e70 610a 2020 2020 6364 6566 2066  t npa.    cdef f
-0003cda0: 6c6f 6174 2073 6361 2c20 7363 6130 2c20  loat sca, sca0, 
-0003cdb0: 7363 6131 0a20 2020 2063 6465 6620 666c  sca1.    cdef fl
-0003cdc0: 6f61 7420 6b69 0a20 2020 2063 6465 6620  oat ki.    cdef 
-0003cdd0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0003cde0: 652c 206e 6469 6d3d 315d 2061 705f 7830  e, ndim=1] ap_x0
-0003cdf0: 203d 206e 702e 636f 7079 2861 705f 7829   = np.copy(ap_x)
-0003ce00: 0a20 2020 2063 6465 6620 6e70 2e6e 6461  .    cdef np.nda
-0003ce10: 7272 6179 5b64 6f75 626c 652c 206e 6469  rray[double, ndi
-0003ce20: 6d3d 315d 2061 705f 7831 203d 206e 702e  m=1] ap_x1 = np.
-0003ce30: 636f 7079 2861 705f 7829 0a20 2020 2063  copy(ap_x).    c
-0003ce40: 6465 6620 6e70 2e6e 6461 7272 6179 5b64  def np.ndarray[d
-0003ce50: 6f75 626c 652c 206e 6469 6d3d 315d 2070  ouble, ndim=1] p
-0003ce60: 5f61 5f78 300a 2020 2020 6364 6566 206e  _a_x0.    cdef n
-0003ce70: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-0003ce80: 2c20 6e64 696d 3d31 5d20 705f 615f 7831  , ndim=1] p_a_x1
-0003ce90: 0a20 2020 2063 6465 6620 6e70 2e6e 6461  .    cdef np.nda
-0003cea0: 7272 6179 5b6c 6f6e 672c 206e 6469 6d3d  rray[long, ndim=
-0003ceb0: 325d 2074 7269 0a20 2020 2063 6465 6620  2] tri.    cdef 
-0003cec0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
-0003ced0: 652c 206e 6469 6d3d 315d 2074 7269 5f78  e, ndim=1] tri_x
-0003cee0: 0a20 2020 2063 6465 6620 6e70 2e6e 6461  .    cdef np.nda
-0003cef0: 7272 6179 5b64 6f75 626c 652c 206e 6469  rray[double, ndi
-0003cf00: 6d3d 315d 2074 7269 5f79 0a20 2020 2063  m=1] tri_y.    c
-0003cf10: 6465 6620 6e70 2e6e 6461 7272 6179 5b64  def np.ndarray[d
-0003cf20: 6f75 626c 652c 206e 6469 6d3d 315d 2074  ouble, ndim=1] t
-0003cf30: 7269 5f7a 0a0a 2020 2020 2320 696e 6974  ri_z..    # init
-0003cf40: 6961 6c69 7a65 2073 6f6c 6964 2061 6e67  ialize solid ang
-0003cf50: 6c65 2061 7272 6179 2077 6974 6820 7a65  le array with ze
-0003cf60: 726f 730a 2020 2020 6364 6566 2066 6c6f  ros.    cdef flo
-0003cf70: 6174 2073 6f6c 6964 5f61 6e67 6c65 203d  at solid_angle =
-0003cf80: 2030 2e0a 0a20 2020 2023 202d 2d2d 2d2d   0...    # -----
-0003cf90: 2d2d 0a20 2020 2023 2043 6f6d 7075 7465  --.    # Compute
-0003cfa0: 0a0a 2020 2020 666f 7220 6464 2069 6e20  ..    for dd in 
-0003cfb0: 7261 6e67 6528 6e64 293a 0a0a 2020 2020  range(nd):..    
-0003cfc0: 2020 2020 2320 7072 696e 7428 2764 6574      # print('det
-0003cfd0: 5f63 656e 7427 2c20 6465 745f 6365 6e74  _cent', det_cent
-0003cfe0: 735f 785b 6464 5d2c 2064 6574 5f63 656e  s_x[dd], det_cen
-0003cff0: 7473 5f79 5b64 645d 2c20 6465 745f 6365  ts_y[dd], det_ce
-0003d000: 6e74 735f 7a5b 6464 5d29 0a20 2020 2020  nts_z[dd]).     
-0003d010: 2020 2023 2070 7269 6e74 2827 6465 745f     # print('det_
-0003d020: 6e69 6e27 2c20 6465 745f 6e6f 726d 5f78  nin', det_norm_x
-0003d030: 5b64 645d 2c20 6465 745f 6e6f 726d 5f79  [dd], det_norm_y
-0003d040: 5b64 645d 2c20 6465 745f 6e6f 726d 5f7a  [dd], det_norm_z
-0003d050: 5b64 645d 2920 2020 2020 2020 2023 2044  [dd])        # D
-0003d060: 420a 2020 2020 2020 2020 2320 7072 696e  B.        # prin
-0003d070: 7428 2764 6574 5f65 3027 2c20 6465 745f  t('det_e0', det_
-0003d080: 6530 5f78 5b64 645d 2c20 6465 745f 6530  e0_x[dd], det_e0
-0003d090: 5f79 5b64 645d 2c20 6465 745f 6530 5f7a  _y[dd], det_e0_z
-0003d0a0: 5b64 645d 2920 2020 2020 2020 2023 2044  [dd])        # D
-0003d0b0: 420a 2020 2020 2020 2020 2320 7072 696e  B.        # prin
-0003d0c0: 7428 2764 6574 5f65 3127 2c20 6465 745f  t('det_e1', det_
-0003d0d0: 6531 5f78 5b64 645d 2c20 6465 745f 6531  e1_x[dd], det_e1
-0003d0e0: 5f79 5b64 645d 2c20 6465 745f 6531 5f7a  _y[dd], det_e1_z
-0003d0f0: 5b64 645d 2920 2020 2020 2020 2023 2044  [dd])        # D
-0003d100: 420a 0a20 2020 2020 2020 2023 206c 6f6f  B..        # loo
-0003d110: 7020 323a 206f 6e20 6e70 7473 2028 6f62  p 2: on npts (ob
-0003d120: 7365 7276 6174 696f 6e20 706f 696e 7473  servation points
-0003d130: 290a 2020 2020 2020 2020 666f 7220 7070  ).        for pp
-0003d140: 2069 6e20 7261 6e67 6528 6e70 7473 293a   in range(npts):
-0003d150: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0003d160: 7072 696e 7428 2770 7473 272c 2070 702c  print('pts', pp,
-0003d170: 2070 7473 5f78 5b70 705d 2c20 7074 735f   pts_x[pp], pts_
-0003d180: 795b 7070 5d2c 2070 7473 5f7a 5b70 705d  y[pp], pts_z[pp]
-0003d190: 2920 2020 2020 2020 2023 2044 420a 0a20  )        # DB.. 
-0003d1a0: 2020 2020 2020 2020 2020 2023 2074 6573             # tes
-0003d1b0: 7420 6966 206f 6e20 676f 6f64 2073 6964  t if on good sid
-0003d1c0: 6520 6f66 2064 6574 6563 746f 720a 2020  e of detector.  
-0003d1d0: 2020 2020 2020 2020 2020 7363 6130 203d            sca0 =
-0003d1e0: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-0003d1f0: 2020 2028 7074 735f 785b 7070 5d20 2d20     (pts_x[pp] - 
-0003d200: 6465 745f 6365 6e74 735f 785b 6464 5d29  det_cents_x[dd])
-0003d210: 202a 2064 6574 5f6e 6f72 6d5f 785b 6464   * det_norm_x[dd
-0003d220: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003d230: 2020 2b20 2870 7473 5f79 5b70 705d 202d    + (pts_y[pp] -
-0003d240: 2064 6574 5f63 656e 7473 5f79 5b64 645d   det_cents_y[dd]
-0003d250: 2920 2a20 6465 745f 6e6f 726d 5f79 5b64  ) * det_norm_y[d
-0003d260: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
-0003d270: 2020 202b 2028 7074 735f 7a5b 7070 5d20     + (pts_z[pp] 
-0003d280: 2d20 6465 745f 6365 6e74 735f 7a5b 6464  - det_cents_z[dd
-0003d290: 5d29 202a 2064 6574 5f6e 6f72 6d5f 7a5b  ]) * det_norm_z[
-0003d2a0: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-0003d2b0: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
-0003d2c0: 6620 7363 6130 203c 3d20 303a 0a20 2020  f sca0 <= 0:.   
-0003d2d0: 2020 2020 2020 2020 2020 2020 2023 2070               # p
-0003d2e0: 7269 6e74 2827 736b 6970 272c 2073 6361  rint('skip', sca
-0003d2f0: 3029 2020 2020 2020 2020 2320 4442 0a20  0)        # DB. 
-0003d300: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0003d310: 6f6e 7469 6e75 650a 0a20 2020 2020 2020  ontinue..       
-0003d320: 2020 2020 2023 2066 6c61 670a 2020 2020       # flag.    
-0003d330: 2020 2020 2020 2020 6973 6f6b 203d 2054          isok = T
-0003d340: 7275 650a 0a20 2020 2020 2020 2020 2020  rue..           
-0003d350: 2023 206c 6f6f 7020 333a 206f 6e20 6e61   # loop 3: on na
-0003d360: 2028 6170 6572 7475 7265 7329 0a20 2020   (apertures).   
-0003d370: 2020 2020 2020 2020 2066 6f72 2061 6120           for aa 
-0003d380: 696e 2072 616e 6765 286e 6129 3a0a 0a20  in range(na):.. 
-0003d390: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0003d3a0: 2070 7269 6e74 2827 6170 272c 2061 6129   print('ap', aa)
-0003d3b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003d3c0: 2023 2070 7269 6e74 2827 6170 2069 6e64   # print('ap ind
-0003d3d0: 272c 2061 705f 696e 645b 6161 5d2c 2061  ', ap_ind[aa], a
-0003d3e0: 705f 696e 645b 6161 2b31 5d29 0a20 2020  p_ind[aa+1]).   
-0003d3f0: 2020 2020 2020 2020 2020 2020 2023 2070               # p
-0003d400: 7269 6e74 2827 6170 206e 696e 272c 2061  rint('ap nin', a
-0003d410: 705f 6e6f 726d 5f78 5b61 615d 2c20 6170  p_norm_x[aa], ap
-0003d420: 5f6e 6f72 6d5f 795b 6161 5d2c 2061 705f  _norm_y[aa], ap_
-0003d430: 6e6f 726d 5f7a 5b61 615d 290a 2020 2020  norm_z[aa]).    
-0003d440: 2020 2020 2020 2020 2020 2020 2320 7072              # pr
-0003d450: 696e 7428 2761 705f 7827 2c20 6170 5f78  int('ap_x', ap_x
-0003d460: 5b61 705f 696e 645b 6161 5d3a 6170 5f69  [ap_ind[aa]:ap_i
-0003d470: 6e64 5b61 612b 315d 5d29 0a20 2020 2020  nd[aa+1]]).     
-0003d480: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
-0003d490: 6e74 2827 6170 5f79 272c 2061 705f 795b  nt('ap_y', ap_y[
-0003d4a0: 6170 5f69 6e64 5b61 615d 3a61 705f 696e  ap_ind[aa]:ap_in
-0003d4b0: 645b 6161 2b31 5d5d 290a 2020 2020 2020  d[aa+1]]).      
-0003d4c0: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
-0003d4d0: 7428 2761 705f 7a27 2c20 6170 5f7a 5b61  t('ap_z', ap_z[a
-0003d4e0: 705f 696e 645b 6161 5d3a 6170 5f69 6e64  p_ind[aa]:ap_ind
-0003d4f0: 5b61 612b 315d 5d29 0a0a 2020 2020 2020  [aa+1]])..      
-0003d500: 2020 2020 2020 2020 2020 2320 7465 7374            # test
-0003d510: 2069 6620 6f6e 2067 6f6f 6420 7369 6465   if on good side
-0003d520: 206f 6620 6170 6572 7475 7265 0a20 2020   of aperture.   
-0003d530: 2020 2020 2020 2020 2020 2020 2073 6361               sca
-0003d540: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-0003d550: 2020 2020 2020 2020 2028 7074 735f 785b           (pts_x[
-0003d560: 7070 5d20 2d20 6170 5f78 5b61 705f 696e  pp] - ap_x[ap_in
-0003d570: 645b 6161 5d5d 2920 2a20 6170 5f6e 6f72  d[aa]]) * ap_nor
-0003d580: 6d5f 785b 6161 5d0a 2020 2020 2020 2020  m_x[aa].        
-0003d590: 2020 2020 2020 2020 2020 2020 2b20 2870              + (p
-0003d5a0: 7473 5f79 5b70 705d 202d 2061 705f 795b  ts_y[pp] - ap_y[
-0003d5b0: 6170 5f69 6e64 5b61 615d 5d29 202a 2061  ap_ind[aa]]) * a
-0003d5c0: 705f 6e6f 726d 5f79 5b61 615d 0a20 2020  p_norm_y[aa].   
-0003d5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003d5e0: 202b 2028 7074 735f 7a5b 7070 5d20 2d20   + (pts_z[pp] - 
-0003d5f0: 6170 5f7a 5b61 705f 696e 645b 6161 5d5d  ap_z[ap_ind[aa]]
-0003d600: 2920 2a20 6170 5f6e 6f72 6d5f 7a5b 6161  ) * ap_norm_z[aa
-0003d610: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003d620: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
-0003d630: 2020 2020 2069 6620 7363 6120 3c3d 2030       if sca <= 0
-0003d640: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0003d650: 2020 2020 2020 6973 6f6b 203d 2046 616c        isok = Fal
-0003d660: 7365 0a20 2020 2020 2020 2020 2020 2020  se.             
-0003d670: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
-0003d680: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0003d690: 7465 7374 2069 6620 616c 6c20 6170 6572  test if all aper
-0003d6a0: 7475 7265 2070 6f69 6e74 7320 6361 6e20  ture points can 
-0003d6b0: 6265 2070 726f 6a65 6374 6564 206f 6e20  be projected on 
-0003d6c0: 6465 7465 6374 6f72 2070 6c61 6e65 2066  detector plane f
-0003d6d0: 726f 6d20 7074 730a 2020 2020 2020 2020  rom pts.        
-0003d6e0: 2020 2020 2020 2020 666f 7220 6c6c 2069          for ll i
-0003d6f0: 6e20 7261 6e67 6528 6170 5f69 6e64 5b61  n range(ap_ind[a
-0003d700: 615d 2c20 6170 5f69 6e64 5b61 612b 315d  a], ap_ind[aa+1]
-0003d710: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-0003d720: 2020 2020 2020 2073 6361 3120 3d20 280a         sca1 = (.
+0003ba90: 2020 2b20 2850 5f7a 202d 2064 6574 5f63    + (P_z - det_c
+0003baa0: 656e 7473 5f7a 5b64 645d 2920 2a20 6465  ents_z[dd]) * de
+0003bab0: 745f 6531 5f7a 5b64 645d 0a20 2020 2020  t_e1_z[dd].     
+0003bac0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0003bad0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0003bae0: 2020 6966 206e 6f74 2069 736f 6b3a 0a20    if not isok:. 
+0003baf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003bb00: 2020 2062 7265 616b 0a0a 2020 2020 2020     break..      
+0003bb10: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
+0003bb20: 7428 2773 6361 302c 2073 6361 312c 206b  t('sca0, sca1, k
+0003bb30: 2020 272c 2073 6361 302c 2073 6361 312c    ', sca0, sca1,
+0003bb40: 206b 290a 2020 2020 2020 2020 2020 2020   k).            
+0003bb50: 2020 2020 2320 7072 696e 7428 2750 782c      # print('Px,
+0003bb60: 2050 792c 2050 7a3a 2020 272c 2050 5f78   Py, Pz:  ', P_x
+0003bb70: 2c20 505f 792c 2050 5f7a 290a 2020 2020  , P_y, P_z).    
+0003bb80: 2020 2020 2020 2020 2020 2020 2320 7072              # pr
+0003bb90: 696e 7428 0a20 2020 2020 2020 2020 2020  int(.           
+0003bba0: 2020 2020 2020 2020 2023 2027 6170 3031           # 'ap01
+0003bbb0: 3a20 272c 0a20 2020 2020 2020 2020 2020  : ',.           
+0003bbc0: 2020 2020 2020 2020 2023 2061 705f 7830           # ap_x0
+0003bbd0: 5b61 705f 696e 645b 6161 5d3a 6170 5f69  [ap_ind[aa]:ap_i
+0003bbe0: 6e64 5b61 612b 315d 5d2c 0a20 2020 2020  nd[aa+1]],.     
+0003bbf0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0003bc00: 2061 705f 7831 5b61 705f 696e 645b 6161   ap_x1[ap_ind[aa
+0003bc10: 5d3a 6170 5f69 6e64 5b61 612b 315d 5d2c  ]:ap_ind[aa+1]],
+0003bc20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003bc30: 2023 2029 0a0a 0a20 2020 2020 2020 2020   # )...         
+0003bc40: 2020 2023 2067 6f20 746f 206e 6578 7420     # go to next 
+0003bc50: 706f 696e 740a 2020 2020 2020 2020 2020  point.          
+0003bc60: 2020 6966 206e 6f74 2069 736f 6b3a 0a20    if not isok:. 
+0003bc70: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0003bc80: 2070 7269 6e74 2827 736b 6970 2032 272c   print('skip 2',
+0003bc90: 2073 6361 2c20 6161 2920 2020 2020 2020   sca, aa)       
+0003bca0: 2023 2044 420a 2020 2020 2020 2020 2020   # DB.          
+0003bcb0: 2020 2020 2020 636f 6e74 696e 7565 0a0a        continue..
+0003bcc0: 2020 2020 2020 2020 2020 2020 2320 2d2d              # --
+0003bcd0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0003bce0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+0003bcf0: 2020 2020 2020 2023 2063 6f6d 7075 7465         # compute
+0003bd00: 2070 6f6c 7967 6f6e 2069 6e74 6572 7365   polygon interse
+0003bd10: 6374 696f 6e0a 0a20 2020 2020 2020 2020  ction..         
+0003bd20: 2020 2023 2063 6f6d 7075 7465 2069 6e74     # compute int
+0003bd30: 6572 7365 6374 696f 6e0a 2020 2020 2020  ersection.      
+0003bd40: 2020 2020 2020 705f 6120 3d20 706c 672e        p_a = plg.
+0003bd50: 506f 6c79 676f 6e28 6e70 2e61 7272 6179  Polygon(np.array
+0003bd60: 285b 6465 745f 6f75 746c 696e 655f 7830  ([det_outline_x0
+0003bd70: 2c20 6465 745f 6f75 746c 696e 655f 7831  , det_outline_x1
+0003bd80: 5d29 2e54 290a 2020 2020 2020 2020 2020  ]).T).          
+0003bd90: 2020 666f 7220 6161 2069 6e20 7261 6e67    for aa in rang
+0003bda0: 6528 6e61 293a 0a20 2020 2020 2020 2020  e(na):.         
+0003bdb0: 2020 2020 2020 2023 2070 7269 6e74 2827         # print('
+0003bdc0: 705f 613a 2027 2c20 6e70 2e61 7272 6179  p_a: ', np.array
+0003bdd0: 2870 5f61 2e63 6f6e 746f 7572 2830 2929  (p_a.contour(0))
+0003bde0: 2e54 290a 2020 2020 2020 2020 2020 2020  .T).            
+0003bdf0: 2020 2020 2320 7072 696e 7428 2777 6974      # print('wit
+0003be00: 683a 2027 2c20 6170 5f78 305b 6170 5f69  h: ', ap_x0[ap_i
+0003be10: 6e64 5b61 615d 3a61 705f 696e 645b 6161  nd[aa]:ap_ind[aa
+0003be20: 2b31 5d5d 2c20 6170 5f78 315b 6170 5f69  +1]], ap_x1[ap_i
+0003be30: 6e64 5b61 615d 3a61 705f 696e 645b 6161  nd[aa]:ap_ind[aa
+0003be40: 2b31 5d5d 290a 2020 2020 2020 2020 2020  +1]]).          
+0003be50: 2020 2020 2020 705f 6120 3d20 705f 6120        p_a = p_a 
+0003be60: 2620 706c 672e 506f 6c79 676f 6e28 6e70  & plg.Polygon(np
+0003be70: 2e61 7272 6179 285b 0a20 2020 2020 2020  .array([.       
+0003be80: 2020 2020 2020 2020 2020 2020 2061 705f               ap_
+0003be90: 7830 5b61 705f 696e 645b 6161 5d3a 6170  x0[ap_ind[aa]:ap
+0003bea0: 5f69 6e64 5b61 612b 315d 5d2c 0a20 2020  _ind[aa+1]],.   
+0003beb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003bec0: 2061 705f 7831 5b61 705f 696e 645b 6161   ap_x1[ap_ind[aa
+0003bed0: 5d3a 6170 5f69 6e64 5b61 612b 315d 5d2c  ]:ap_ind[aa+1]],
+0003bee0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003bef0: 205d 292e 5429 0a0a 2020 2020 2020 2020   ]).T)..        
+0003bf00: 2020 2020 2020 2020 2320 7374 6f70 2069          # stop i
+0003bf10: 6620 6e6f 2069 6e74 6572 7365 6374 696f  f no intersectio
+0003bf20: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+0003bf30: 2020 6966 2070 5f61 2e6e 506f 696e 7473    if p_a.nPoints
+0003bf40: 2829 203c 2033 3a0a 2020 2020 2020 2020  () < 3:.        
+0003bf50: 2020 2020 2020 2020 2020 2020 6973 6f6b              isok
+0003bf60: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
+0003bf70: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+0003bf80: 616b 0a0a 2020 2020 2020 2020 2020 2020  ak..            
+0003bf90: 2320 7374 6f70 2069 6620 6e6f 2069 6e74  # stop if no int
+0003bfa0: 6572 7365 6374 696f 6e0a 2020 2020 2020  ersection.      
+0003bfb0: 2020 2020 2020 6966 206e 6f74 2069 736f        if not iso
+0003bfc0: 6b3a 0a20 2020 2020 2020 2020 2020 2020  k:.             
+0003bfd0: 2020 2023 2070 7269 6e74 2827 736b 6970     # print('skip
+0003bfe0: 2033 2729 2020 2020 2020 2020 2320 4442   3')        # DB
+0003bff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003c000: 2063 6f6e 7469 6e75 650a 0a20 2020 2020   continue..     
+0003c010: 2020 2020 2020 2023 202d 2d2d 2d2d 2d2d         # -------
+0003c020: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020  ------------.   
+0003c030: 2020 2020 2020 2020 2023 2072 6562 7569           # rebui
+0003c040: 6c64 2033 6420 706f 6c79 676f 6e0a 0a20  ld 3d polygon.. 
+0003c050: 2020 2020 2020 2020 2020 2023 2063 6865             # che
+0003c060: 636b 2063 6377 0a20 2020 2020 2020 2020  ck ccw.         
+0003c070: 2020 2070 5f61 5f78 3020 3d20 6e70 2e61     p_a_x0 = np.a
+0003c080: 7363 6f6e 7469 6775 6f75 7361 7272 6179  scontiguousarray
+0003c090: 286e 702e 6172 7261 7928 705f 612e 636f  (np.array(p_a.co
+0003c0a0: 6e74 6f75 7228 3029 295b 3a2c 2030 5d29  ntour(0))[:, 0])
+0003c0b0: 0a20 2020 2020 2020 2020 2020 2070 5f61  .            p_a
+0003c0c0: 5f78 3120 3d20 6e70 2e61 7363 6f6e 7469  _x1 = np.asconti
+0003c0d0: 6775 6f75 7361 7272 6179 286e 702e 6172  guousarray(np.ar
+0003c0e0: 7261 7928 705f 612e 636f 6e74 6f75 7228  ray(p_a.contour(
+0003c0f0: 3029 295b 3a2c 2031 5d29 0a20 2020 2020  0))[:, 1]).     
+0003c100: 2020 2020 2020 2069 6620 6e6f 7420 5f63         if not _c
+0003c110: 6865 636b 5f70 6f6c 7967 6f6e 5f32 645f  heck_polygon_2d_
+0003c120: 636f 756e 7465 725f 636c 6f63 6b77 6973  counter_clockwis
+0003c130: 6528 705f 615f 7830 2c20 705f 615f 7831  e(p_a_x0, p_a_x1
+0003c140: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0003c150: 2020 2070 5f61 5f78 3020 3d20 6e70 2e61     p_a_x0 = np.a
+0003c160: 7363 6f6e 7469 6775 6f75 7361 7272 6179  scontiguousarray
+0003c170: 2870 5f61 5f78 305b 3a3a 2d31 5d29 0a20  (p_a_x0[::-1]). 
+0003c180: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0003c190: 5f61 5f78 3120 3d20 6e70 2e61 7363 6f6e  _a_x1 = np.ascon
+0003c1a0: 7469 6775 6f75 7361 7272 6179 2870 5f61  tiguousarray(p_a
+0003c1b0: 5f78 315b 3a3a 2d31 5d29 0a0a 2020 2020  _x1[::-1])..    
+0003c1c0: 2020 2020 2020 2020 2320 7472 6961 6e67          # triang
+0003c1d0: 756c 6174 6520 6279 2065 6172 2d63 6c69  ulate by ear-cli
+0003c1e0: 7070 696e 6720 2829 0a20 2020 2020 2020  pping ().       
+0003c1f0: 2020 2020 2074 7269 203d 2074 7269 616e       tri = trian
+0003c200: 6775 6c61 7465 5f62 795f 6561 7263 6c69  gulate_by_earcli
+0003c210: 7070 696e 675f 3264 280a 2020 2020 2020  pping_2d(.      
+0003c220: 2020 2020 2020 2020 2020 6e70 2e61 7363            np.asc
+0003c230: 6f6e 7469 6775 6f75 7361 7272 6179 285b  ontiguousarray([
+0003c240: 705f 615f 7830 2c20 705f 615f 7831 5d29  p_a_x0, p_a_x1])
+0003c250: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+0003c260: 2020 2020 2020 2020 2020 2020 2320 2d2d              # --
+0003c270: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0003c280: 2d0a 2020 2020 2020 2020 2020 2020 2320  -.            # 
+0003c290: 636f 6d70 7574 6520 736f 6c69 6420 616e  compute solid an
+0003c2a0: 676c 650a 0a20 2020 2020 2020 2020 2020  gle..           
+0003c2b0: 2023 206c 6f6f 7020 6f6e 2074 7269 616e   # loop on trian
+0003c2c0: 676c 6573 0a20 2020 2020 2020 2020 2020  gles.           
+0003c2d0: 2066 6f72 2074 7420 696e 2072 616e 6765   for tt in range
+0003c2e0: 2874 7269 2e73 6861 7065 5b30 5d29 3a0a  (tri.shape[0]):.
+0003c2f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003c300: 2023 2067 6574 2074 7269 616e 676c 650a   # get triangle.
+0003c310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c320: 7472 695f 7820 3d20 280a 2020 2020 2020  tri_x = (.      
+0003c330: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0003c340: 745f 6365 6e74 735f 785b 6464 5d0a 2020  t_cents_x[dd].  
+0003c350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c360: 2020 2b20 705f 615f 7830 5b74 7269 5b74    + p_a_x0[tri[t
+0003c370: 742c 203a 5d5d 202a 2064 6574 5f65 305f  t, :]] * det_e0_
+0003c380: 785b 6464 5d0a 2020 2020 2020 2020 2020  x[dd].          
+0003c390: 2020 2020 2020 2020 2020 2b20 705f 615f            + p_a_
+0003c3a0: 7831 5b74 7269 5b74 742c 203a 5d5d 202a  x1[tri[tt, :]] *
+0003c3b0: 2064 6574 5f65 315f 785b 6464 5d0a 2020   det_e1_x[dd].  
+0003c3c0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003c3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c3e0: 7472 695f 7920 3d20 280a 2020 2020 2020  tri_y = (.      
+0003c3f0: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0003c400: 745f 6365 6e74 735f 795b 6464 5d0a 2020  t_cents_y[dd].  
+0003c410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c420: 2020 2b20 705f 615f 7830 5b74 7269 5b74    + p_a_x0[tri[t
+0003c430: 742c 203a 5d5d 202a 2064 6574 5f65 305f  t, :]] * det_e0_
+0003c440: 795b 6464 5d0a 2020 2020 2020 2020 2020  y[dd].          
+0003c450: 2020 2020 2020 2020 2020 2b20 705f 615f            + p_a_
+0003c460: 7831 5b74 7269 5b74 742c 203a 5d5d 202a  x1[tri[tt, :]] *
+0003c470: 2064 6574 5f65 315f 795b 6464 5d0a 2020   det_e1_y[dd].  
+0003c480: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003c490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c4a0: 7472 695f 7a20 3d20 280a 2020 2020 2020  tri_z = (.      
+0003c4b0: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0003c4c0: 745f 6365 6e74 735f 7a5b 6464 5d0a 2020  t_cents_z[dd].  
+0003c4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c4e0: 2020 2b20 705f 615f 7830 5b74 7269 5b74    + p_a_x0[tri[t
+0003c4f0: 742c 203a 5d5d 202a 2064 6574 5f65 305f  t, :]] * det_e0_
+0003c500: 7a5b 6464 5d0a 2020 2020 2020 2020 2020  z[dd].          
+0003c510: 2020 2020 2020 2020 2020 2b20 705f 615f            + p_a_
+0003c520: 7831 5b74 7269 5b74 742c 203a 5d5d 202a  x1[tri[tt, :]] *
+0003c530: 2064 6574 5f65 315f 7a5b 6464 5d0a 2020   det_e1_z[dd].  
+0003c540: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003c550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003c560: 2023 2063 6f6d 7075 7461 7469 6f6e 2032   # computation 2
+0003c570: 3a20 736f 6c69 6420 616e 676c 6520 6f66  : solid angle of
+0003c580: 2074 7269 616e 676c 6520 6672 6f6d 2070   triangle from p
+0003c590: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
+0003c5a0: 2020 2073 6f6c 6964 5f61 6e67 6c65 5b64     solid_angle[d
+0003c5b0: 642c 2070 705d 202b 3d20 5f73 742e 636f  d, pp] += _st.co
+0003c5c0: 6d70 5f73 615f 7472 6928 0a20 2020 2020  mp_sa_tri(.     
+0003c5d0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0003c5e0: 7269 5f78 5b30 5d2c 0a20 2020 2020 2020  ri_x[0],.       
+0003c5f0: 2020 2020 2020 2020 2020 2020 2074 7269               tri
+0003c600: 5f79 5b30 5d2c 0a20 2020 2020 2020 2020  _y[0],.         
+0003c610: 2020 2020 2020 2020 2020 2074 7269 5f7a             tri_z
+0003c620: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
+0003c630: 2020 2020 2020 2020 2074 7269 5f78 5b31           tri_x[1
+0003c640: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0003c650: 2020 2020 2020 2074 7269 5f79 5b31 5d2c         tri_y[1],
+0003c660: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003c670: 2020 2020 2074 7269 5f7a 5b31 5d2c 0a20       tri_z[1],. 
+0003c680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c690: 2020 2074 7269 5f78 5b32 5d2c 0a20 2020     tri_x[2],.   
+0003c6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003c6b0: 2074 7269 5f79 5b32 5d2c 0a20 2020 2020   tri_y[2],.     
+0003c6c0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0003c6d0: 7269 5f7a 5b32 5d2c 0a20 2020 2020 2020  ri_z[2],.       
+0003c6e0: 2020 2020 2020 2020 2020 2020 2070 7473               pts
+0003c6f0: 5f78 5b70 705d 2c0a 2020 2020 2020 2020  _x[pp],.        
+0003c700: 2020 2020 2020 2020 2020 2020 7074 735f              pts_
+0003c710: 795b 7070 5d2c 0a20 2020 2020 2020 2020  y[pp],.         
+0003c720: 2020 2020 2020 2020 2020 2070 7473 5f7a             pts_z
+0003c730: 5b70 705d 2c0a 2020 2020 2020 2020 2020  [pp],.          
+0003c740: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0003c750: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
+0003c760: 2774 7269 272c 2074 742c 2073 6f6c 6964  'tri', tt, solid
+0003c770: 5f61 6e67 6c65 5b64 642c 2070 705d 2920  _angle[dd, pp]) 
+0003c780: 2020 2020 2020 2023 2044 420a 0a20 2020         # DB..   
+0003c790: 2023 202d 2d2d 2d2d 2d2d 0a20 2020 2023   # -------.    #
+0003c7a0: 2052 6574 7572 6e0a 0a20 2020 2072 6574   Return..    ret
+0003c7b0: 7572 6e20 736f 6c69 645f 616e 676c 650a  urn solid_angle.
+0003c7c0: 0a0a 6465 6620 636f 6d70 7574 655f 736f  ..def compute_so
+0003c7d0: 6c69 645f 616e 676c 655f 6170 6572 7475  lid_angle_apertu
+0003c7e0: 7265 735f 6c69 6768 745f 7375 6d6d 6564  res_light_summed
+0003c7f0: 280a 2020 2020 2320 7074 733a 2063 6f6f  (.    # pts: coo
+0003c800: 7264 696e 6174 6573 2061 7320 7468 7265  rdinates as thre
+0003c810: 6520 3164 2061 7272 6179 730a 2020 2020  e 1d arrays.    
+0003c820: 646f 7562 6c65 5b3a 3a31 5d20 7074 735f  double[::1] pts_
+0003c830: 782c 0a20 2020 2064 6f75 626c 655b 3a3a  x,.    double[::
+0003c840: 315d 2070 7473 5f79 2c0a 2020 2020 646f  1] pts_y,.    do
+0003c850: 7562 6c65 5b3a 3a31 5d20 7074 735f 7a2c  uble[::1] pts_z,
+0003c860: 0a20 2020 2023 2064 6574 6563 746f 7273  .    # detectors
+0003c870: 3a20 706f 6c79 676f 6e20 636f 6f72 6469  : polygon coordi
+0003c880: 6e61 7465 7320 696e 2032 6420 2863 6f6d  nates in 2d (com
+0003c890: 6d6f 6e20 746f 2061 6c6c 2064 6574 6563  mon to all detec
+0003c8a0: 746f 7273 290a 2020 2020 646f 7562 6c65  tors).    double
+0003c8b0: 5b3a 3a31 5d20 6465 745f 6f75 746c 696e  [::1] det_outlin
+0003c8c0: 655f 7830 2c0a 2020 2020 646f 7562 6c65  e_x0,.    double
+0003c8d0: 5b3a 3a31 5d20 6465 745f 6f75 746c 696e  [::1] det_outlin
+0003c8e0: 655f 7831 2c0a 2020 2020 2320 6465 7465  e_x1,.    # dete
+0003c8f0: 6374 6f72 733a 2063 656e 7465 7273 2063  ctors: centers c
+0003c900: 6f6f 7264 696e 6174 6573 2061 7320 7468  oordinates as th
+0003c910: 7265 6520 3164 2061 7272 6179 730a 2020  ree 1d arrays.  
+0003c920: 2020 646f 7562 6c65 5b3a 3a31 5d20 6465    double[::1] de
+0003c930: 745f 6365 6e74 735f 782c 0a20 2020 2064  t_cents_x,.    d
+0003c940: 6f75 626c 655b 3a3a 315d 2064 6574 5f63  ouble[::1] det_c
+0003c950: 656e 7473 5f79 2c0a 2020 2020 646f 7562  ents_y,.    doub
+0003c960: 6c65 5b3a 3a31 5d20 6465 745f 6365 6e74  le[::1] det_cent
+0003c970: 735f 7a2c 0a20 2020 2023 2064 6574 6563  s_z,.    # detec
+0003c980: 746f 7273 3a20 6e6f 726d 616c 2075 6e69  tors: normal uni
+0003c990: 7420 7665 6374 6f72 7320 6173 2074 6872  t vectors as thr
+0003c9a0: 6565 2031 6420 6172 7261 7973 2028 6e64  ee 1d arrays (nd
+0003c9b0: 203d 206c 656e 2864 6574 5f6e 6f72 6d5f   = len(det_norm_
+0003c9c0: 7829 290a 2020 2020 646f 7562 6c65 5b3a  x)).    double[:
+0003c9d0: 3a31 5d20 6465 745f 6e6f 726d 5f78 2c0a  :1] det_norm_x,.
+0003c9e0: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
+0003c9f0: 6465 745f 6e6f 726d 5f79 2c0a 2020 2020  det_norm_y,.    
+0003ca00: 646f 7562 6c65 5b3a 3a31 5d20 6465 745f  double[::1] det_
+0003ca10: 6e6f 726d 5f7a 2c0a 2020 2020 6e70 2e6e  norm_z,.    np.n
+0003ca20: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+0003ca30: 6469 6d3d 315d 2064 6574 5f65 305f 782c  dim=1] det_e0_x,
+0003ca40: 0a20 2020 206e 702e 6e64 6172 7261 795b  .    np.ndarray[
+0003ca50: 646f 7562 6c65 2c20 6e64 696d 3d31 5d20  double, ndim=1] 
+0003ca60: 6465 745f 6530 5f79 2c0a 2020 2020 6e70  det_e0_y,.    np
+0003ca70: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
+0003ca80: 206e 6469 6d3d 315d 2064 6574 5f65 305f   ndim=1] det_e0_
+0003ca90: 7a2c 0a20 2020 206e 702e 6e64 6172 7261  z,.    np.ndarra
+0003caa0: 795b 646f 7562 6c65 2c20 6e64 696d 3d31  y[double, ndim=1
+0003cab0: 5d20 6465 745f 6531 5f78 2c0a 2020 2020  ] det_e1_x,.    
+0003cac0: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+0003cad0: 652c 206e 6469 6d3d 315d 2064 6574 5f65  e, ndim=1] det_e
+0003cae0: 315f 792c 0a20 2020 206e 702e 6e64 6172  1_y,.    np.ndar
+0003caf0: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+0003cb00: 3d31 5d20 6465 745f 6531 5f7a 2c0a 2020  =1] det_e1_z,.  
+0003cb10: 2020 2320 6170 6572 7475 7265 733a 2069    # apertures: i
+0003cb20: 6e64 6963 6573 206f 6620 6669 7273 7420  ndices of first 
+0003cb30: 636f 726e 6572 206f 6620 6561 6368 2061  corner of each a
+0003cb40: 7020 706f 6c79 676f 6e3a 206e 6120 3d20  p polygon: na = 
+0003cb50: 6c65 6e28 6170 5f69 6e64 290a 2020 2020  len(ap_ind).    
+0003cb60: 6c6f 6e67 5b3a 3a31 5d20 6170 5f69 6e64  long[::1] ap_ind
+0003cb70: 2c0a 2020 2020 2320 6170 6572 7475 7265  ,.    # aperture
+0003cb80: 733a 2070 6f6c 7967 6f6e 2063 6f6f 7264  s: polygon coord
+0003cb90: 696e 6174 6573 2061 7320 7468 7265 6520  inates as three 
+0003cba0: 3164 2061 7272 6179 730a 2020 2020 6e70  1d arrays.    np
+0003cbb0: 2e6e 6461 7272 6179 5b64 6f75 626c 652c  .ndarray[double,
+0003cbc0: 206e 6469 6d3d 315d 2061 705f 782c 0a20   ndim=1] ap_x,. 
+0003cbd0: 2020 206e 702e 6e64 6172 7261 795b 646f     np.ndarray[do
+0003cbe0: 7562 6c65 2c20 6e64 696d 3d31 5d20 6170  uble, ndim=1] ap
+0003cbf0: 5f79 2c0a 2020 2020 6e70 2e6e 6461 7272  _y,.    np.ndarr
+0003cc00: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
+0003cc10: 315d 2061 705f 7a2c 0a20 2020 2023 206e  1] ap_z,.    # n
+0003cc20: 6f72 6d61 6c20 756e 6974 2076 6563 746f  ormal unit vecto
+0003cc30: 7273 0a20 2020 2064 6f75 626c 655b 3a3a  rs.    double[::
+0003cc40: 315d 2061 705f 6e6f 726d 5f78 2c0a 2020  1] ap_norm_x,.  
+0003cc50: 2020 646f 7562 6c65 5b3a 3a31 5d20 6170    double[::1] ap
+0003cc60: 5f6e 6f72 6d5f 792c 0a20 2020 2064 6f75  _norm_y,.    dou
+0003cc70: 626c 655b 3a3a 315d 2061 705f 6e6f 726d  ble[::1] ap_norm
+0003cc80: 5f7a 2c0a 2020 2020 2320 706f 7373 6962  _z,.    # possib
+0003cc90: 6c65 2065 7874 7261 2070 6172 616d 6574  le extra paramet
+0003cca0: 6572 7320 3f0a 2020 2020 646f 7562 6c65  ers ?.    double
+0003ccb0: 206d 6172 6769 6e3d 5f56 534d 414c 4c2c   margin=_VSMALL,
+0003ccc0: 0a20 2020 2069 6e74 206e 756d 5f74 6872  .    int num_thr
+0003ccd0: 6561 6473 3d31 302c 0a29 3a0a 0a20 2020  eads=10,.):..   
+0003cce0: 2023 202d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20   # -----------. 
+0003ccf0: 2020 2023 2044 6563 6c61 7261 7469 6f6e     # Declaration
+0003cd00: 0a0a 2020 2020 6364 6566 2069 6e74 206e  ..    cdef int n
+0003cd10: 7074 7320 3d20 7074 735f 782e 7369 7a65  pts = pts_x.size
+0003cd20: 0a20 2020 2063 6465 6620 696e 7420 6e64  .    cdef int nd
+0003cd30: 203d 2064 6574 5f63 656e 7473 5f78 2e73   = det_cents_x.s
+0003cd40: 697a 650a 2020 2020 6364 6566 2069 6e74  ize.    cdef int
+0003cd50: 206e 6120 3d20 6170 5f6e 6f72 6d5f 782e   na = ap_norm_x.
+0003cd60: 7369 7a65 0a20 2020 2063 6465 6620 696e  size.    cdef in
+0003cd70: 7420 6464 2c20 7070 2c20 6161 2c20 7474  t dd, pp, aa, tt
+0003cd80: 0a20 2020 2063 6465 6620 696e 7420 6e70  .    cdef int np
+0003cd90: 610a 2020 2020 6364 6566 2066 6c6f 6174  a.    cdef float
+0003cda0: 2073 6361 2c20 7363 6130 2c20 7363 6131   sca, sca0, sca1
+0003cdb0: 0a20 2020 2063 6465 6620 666c 6f61 7420  .    cdef float 
+0003cdc0: 6b69 0a20 2020 2063 6465 6620 6e70 2e6e  ki.    cdef np.n
+0003cdd0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+0003cde0: 6469 6d3d 315d 2061 705f 7830 203d 206e  dim=1] ap_x0 = n
+0003cdf0: 702e 636f 7079 2861 705f 7829 0a20 2020  p.copy(ap_x).   
+0003ce00: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
+0003ce10: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
+0003ce20: 2061 705f 7831 203d 206e 702e 636f 7079   ap_x1 = np.copy
+0003ce30: 2861 705f 7829 0a20 2020 2063 6465 6620  (ap_x).    cdef 
+0003ce40: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+0003ce50: 652c 206e 6469 6d3d 315d 2070 5f61 5f78  e, ndim=1] p_a_x
+0003ce60: 300a 2020 2020 6364 6566 206e 702e 6e64  0.    cdef np.nd
+0003ce70: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
+0003ce80: 696d 3d31 5d20 705f 615f 7831 0a20 2020  im=1] p_a_x1.   
+0003ce90: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
+0003cea0: 5b6c 6f6e 672c 206e 6469 6d3d 325d 2074  [long, ndim=2] t
+0003ceb0: 7269 0a20 2020 2063 6465 6620 6e70 2e6e  ri.    cdef np.n
+0003cec0: 6461 7272 6179 5b64 6f75 626c 652c 206e  darray[double, n
+0003ced0: 6469 6d3d 315d 2074 7269 5f78 0a20 2020  dim=1] tri_x.   
+0003cee0: 2063 6465 6620 6e70 2e6e 6461 7272 6179   cdef np.ndarray
+0003cef0: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
+0003cf00: 2074 7269 5f79 0a20 2020 2063 6465 6620   tri_y.    cdef 
+0003cf10: 6e70 2e6e 6461 7272 6179 5b64 6f75 626c  np.ndarray[doubl
+0003cf20: 652c 206e 6469 6d3d 315d 2074 7269 5f7a  e, ndim=1] tri_z
+0003cf30: 0a0a 2020 2020 2320 696e 6974 6961 6c69  ..    # initiali
+0003cf40: 7a65 2073 6f6c 6964 2061 6e67 6c65 2061  ze solid angle a
+0003cf50: 7272 6179 2077 6974 6820 7a65 726f 730a  rray with zeros.
+0003cf60: 2020 2020 6364 6566 2066 6c6f 6174 2073      cdef float s
+0003cf70: 6f6c 6964 5f61 6e67 6c65 203d 2030 2e0a  olid_angle = 0..
+0003cf80: 0a20 2020 2023 202d 2d2d 2d2d 2d2d 0a20  .    # -------. 
+0003cf90: 2020 2023 2043 6f6d 7075 7465 0a0a 2020     # Compute..  
+0003cfa0: 2020 666f 7220 6464 2069 6e20 7261 6e67    for dd in rang
+0003cfb0: 6528 6e64 293a 0a0a 2020 2020 2020 2020  e(nd):..        
+0003cfc0: 2320 7072 696e 7428 2764 6574 5f63 656e  # print('det_cen
+0003cfd0: 7427 2c20 6465 745f 6365 6e74 735f 785b  t', det_cents_x[
+0003cfe0: 6464 5d2c 2064 6574 5f63 656e 7473 5f79  dd], det_cents_y
+0003cff0: 5b64 645d 2c20 6465 745f 6365 6e74 735f  [dd], det_cents_
+0003d000: 7a5b 6464 5d29 0a20 2020 2020 2020 2023  z[dd]).        #
+0003d010: 2070 7269 6e74 2827 6465 745f 6e69 6e27   print('det_nin'
+0003d020: 2c20 6465 745f 6e6f 726d 5f78 5b64 645d  , det_norm_x[dd]
+0003d030: 2c20 6465 745f 6e6f 726d 5f79 5b64 645d  , det_norm_y[dd]
+0003d040: 2c20 6465 745f 6e6f 726d 5f7a 5b64 645d  , det_norm_z[dd]
+0003d050: 2920 2020 2020 2020 2023 2044 420a 2020  )        # DB.  
+0003d060: 2020 2020 2020 2320 7072 696e 7428 2764        # print('d
+0003d070: 6574 5f65 3027 2c20 6465 745f 6530 5f78  et_e0', det_e0_x
+0003d080: 5b64 645d 2c20 6465 745f 6530 5f79 5b64  [dd], det_e0_y[d
+0003d090: 645d 2c20 6465 745f 6530 5f7a 5b64 645d  d], det_e0_z[dd]
+0003d0a0: 2920 2020 2020 2020 2023 2044 420a 2020  )        # DB.  
+0003d0b0: 2020 2020 2020 2320 7072 696e 7428 2764        # print('d
+0003d0c0: 6574 5f65 3127 2c20 6465 745f 6531 5f78  et_e1', det_e1_x
+0003d0d0: 5b64 645d 2c20 6465 745f 6531 5f79 5b64  [dd], det_e1_y[d
+0003d0e0: 645d 2c20 6465 745f 6531 5f7a 5b64 645d  d], det_e1_z[dd]
+0003d0f0: 2920 2020 2020 2020 2023 2044 420a 0a20  )        # DB.. 
+0003d100: 2020 2020 2020 2023 206c 6f6f 7020 323a         # loop 2:
+0003d110: 206f 6e20 6e70 7473 2028 6f62 7365 7276   on npts (observ
+0003d120: 6174 696f 6e20 706f 696e 7473 290a 2020  ation points).  
+0003d130: 2020 2020 2020 666f 7220 7070 2069 6e20        for pp in 
+0003d140: 7261 6e67 6528 6e70 7473 293a 0a0a 2020  range(npts):..  
+0003d150: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
+0003d160: 7428 2770 7473 272c 2070 702c 2070 7473  t('pts', pp, pts
+0003d170: 5f78 5b70 705d 2c20 7074 735f 795b 7070  _x[pp], pts_y[pp
+0003d180: 5d2c 2070 7473 5f7a 5b70 705d 2920 2020  ], pts_z[pp])   
+0003d190: 2020 2020 2023 2044 420a 0a20 2020 2020       # DB..     
+0003d1a0: 2020 2020 2020 2023 2074 6573 7420 6966         # test if
+0003d1b0: 206f 6e20 676f 6f64 2073 6964 6520 6f66   on good side of
+0003d1c0: 2064 6574 6563 746f 720a 2020 2020 2020   detector.      
+0003d1d0: 2020 2020 2020 7363 6130 203d 2028 0a20        sca0 = (. 
+0003d1e0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+0003d1f0: 7074 735f 785b 7070 5d20 2d20 6465 745f  pts_x[pp] - det_
+0003d200: 6365 6e74 735f 785b 6464 5d29 202a 2064  cents_x[dd]) * d
+0003d210: 6574 5f6e 6f72 6d5f 785b 6464 5d0a 2020  et_norm_x[dd].  
+0003d220: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+0003d230: 2870 7473 5f79 5b70 705d 202d 2064 6574  (pts_y[pp] - det
+0003d240: 5f63 656e 7473 5f79 5b64 645d 2920 2a20  _cents_y[dd]) * 
+0003d250: 6465 745f 6e6f 726d 5f79 5b64 645d 0a20  det_norm_y[dd]. 
+0003d260: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+0003d270: 2028 7074 735f 7a5b 7070 5d20 2d20 6465   (pts_z[pp] - de
+0003d280: 745f 6365 6e74 735f 7a5b 6464 5d29 202a  t_cents_z[dd]) *
+0003d290: 2064 6574 5f6e 6f72 6d5f 7a5b 6464 5d0a   det_norm_z[dd].
+0003d2a0: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+0003d2b0: 2020 2020 2020 2020 2020 2069 6620 7363             if sc
+0003d2c0: 6130 203c 3d20 303a 0a20 2020 2020 2020  a0 <= 0:.       
+0003d2d0: 2020 2020 2020 2020 2023 2070 7269 6e74           # print
+0003d2e0: 2827 736b 6970 272c 2073 6361 3029 2020  ('skip', sca0)  
+0003d2f0: 2020 2020 2020 2320 4442 0a20 2020 2020        # DB.     
+0003d300: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+0003d310: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
+0003d320: 2023 2066 6c61 670a 2020 2020 2020 2020   # flag.        
+0003d330: 2020 2020 6973 6f6b 203d 2054 7275 650a      isok = True.
+0003d340: 0a20 2020 2020 2020 2020 2020 2023 206c  .            # l
+0003d350: 6f6f 7020 333a 206f 6e20 6e61 2028 6170  oop 3: on na (ap
+0003d360: 6572 7475 7265 7329 0a20 2020 2020 2020  ertures).       
+0003d370: 2020 2020 2066 6f72 2061 6120 696e 2072       for aa in r
+0003d380: 616e 6765 286e 6129 3a0a 0a20 2020 2020  ange(na):..     
+0003d390: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
+0003d3a0: 6e74 2827 6170 272c 2061 6129 0a20 2020  nt('ap', aa).   
+0003d3b0: 2020 2020 2020 2020 2020 2020 2023 2070               # p
+0003d3c0: 7269 6e74 2827 6170 2069 6e64 272c 2061  rint('ap ind', a
+0003d3d0: 705f 696e 645b 6161 5d2c 2061 705f 696e  p_ind[aa], ap_in
+0003d3e0: 645b 6161 2b31 5d29 0a20 2020 2020 2020  d[aa+1]).       
+0003d3f0: 2020 2020 2020 2020 2023 2070 7269 6e74           # print
+0003d400: 2827 6170 206e 696e 272c 2061 705f 6e6f  ('ap nin', ap_no
+0003d410: 726d 5f78 5b61 615d 2c20 6170 5f6e 6f72  rm_x[aa], ap_nor
+0003d420: 6d5f 795b 6161 5d2c 2061 705f 6e6f 726d  m_y[aa], ap_norm
+0003d430: 5f7a 5b61 615d 290a 2020 2020 2020 2020  _z[aa]).        
+0003d440: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
+0003d450: 2761 705f 7827 2c20 6170 5f78 5b61 705f  'ap_x', ap_x[ap_
+0003d460: 696e 645b 6161 5d3a 6170 5f69 6e64 5b61  ind[aa]:ap_ind[a
+0003d470: 612b 315d 5d29 0a20 2020 2020 2020 2020  a+1]]).         
+0003d480: 2020 2020 2020 2023 2070 7269 6e74 2827         # print('
+0003d490: 6170 5f79 272c 2061 705f 795b 6170 5f69  ap_y', ap_y[ap_i
+0003d4a0: 6e64 5b61 615d 3a61 705f 696e 645b 6161  nd[aa]:ap_ind[aa
+0003d4b0: 2b31 5d5d 290a 2020 2020 2020 2020 2020  +1]]).          
+0003d4c0: 2020 2020 2020 2320 7072 696e 7428 2761        # print('a
+0003d4d0: 705f 7a27 2c20 6170 5f7a 5b61 705f 696e  p_z', ap_z[ap_in
+0003d4e0: 645b 6161 5d3a 6170 5f69 6e64 5b61 612b  d[aa]:ap_ind[aa+
+0003d4f0: 315d 5d29 0a0a 2020 2020 2020 2020 2020  1]])..          
+0003d500: 2020 2020 2020 2320 7465 7374 2069 6620        # test if 
+0003d510: 6f6e 2067 6f6f 6420 7369 6465 206f 6620  on good side of 
+0003d520: 6170 6572 7475 7265 0a20 2020 2020 2020  aperture.       
+0003d530: 2020 2020 2020 2020 2073 6361 203d 2028           sca = (
+0003d540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003d550: 2020 2020 2028 7074 735f 785b 7070 5d20       (pts_x[pp] 
+0003d560: 2d20 6170 5f78 5b61 705f 696e 645b 6161  - ap_x[ap_ind[aa
+0003d570: 5d5d 2920 2a20 6170 5f6e 6f72 6d5f 785b  ]]) * ap_norm_x[
+0003d580: 6161 5d0a 2020 2020 2020 2020 2020 2020  aa].            
+0003d590: 2020 2020 2020 2020 2b20 2870 7473 5f79          + (pts_y
+0003d5a0: 5b70 705d 202d 2061 705f 795b 6170 5f69  [pp] - ap_y[ap_i
+0003d5b0: 6e64 5b61 615d 5d29 202a 2061 705f 6e6f  nd[aa]]) * ap_no
+0003d5c0: 726d 5f79 5b61 615d 0a20 2020 2020 2020  rm_y[aa].       
+0003d5d0: 2020 2020 2020 2020 2020 2020 202b 2028               + (
+0003d5e0: 7074 735f 7a5b 7070 5d20 2d20 6170 5f7a  pts_z[pp] - ap_z
+0003d5f0: 5b61 705f 696e 645b 6161 5d5d 2920 2a20  [ap_ind[aa]]) * 
+0003d600: 6170 5f6e 6f72 6d5f 7a5b 6161 5d0a 2020  ap_norm_z[aa].  
+0003d610: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003d620: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003d630: 2069 6620 7363 6120 3c3d 2030 3a0a 2020   if sca <= 0:.  
+0003d640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d650: 2020 6973 6f6b 203d 2046 616c 7365 0a20    isok = False. 
+0003d660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d670: 2020 2062 7265 616b 0a0a 2020 2020 2020     break..      
+0003d680: 2020 2020 2020 2020 2020 2320 7465 7374            # test
+0003d690: 2069 6620 616c 6c20 6170 6572 7475 7265   if all aperture
+0003d6a0: 2070 6f69 6e74 7320 6361 6e20 6265 2070   points can be p
+0003d6b0: 726f 6a65 6374 6564 206f 6e20 6465 7465  rojected on dete
+0003d6c0: 6374 6f72 2070 6c61 6e65 2066 726f 6d20  ctor plane from 
+0003d6d0: 7074 730a 2020 2020 2020 2020 2020 2020  pts.            
+0003d6e0: 2020 2020 666f 7220 6c6c 2069 6e20 7261      for ll in ra
+0003d6f0: 6e67 6528 6170 5f69 6e64 5b61 615d 2c20  nge(ap_ind[aa], 
+0003d700: 6170 5f69 6e64 5b61 612b 315d 293a 0a20  ap_ind[aa+1]):. 
+0003d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d720: 2020 2073 6361 3120 3d20 280a 2020 2020     sca1 = (.    
 0003d730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003d740: 2020 2020 2020 2020 2861 705f 785b 6c6c          (ap_x[ll
-0003d750: 5d20 2d20 7074 735f 785b 7070 5d29 202a  ] - pts_x[pp]) *
-0003d760: 2064 6574 5f6e 6f72 6d5f 785b 6464 5d0a   det_norm_x[dd].
+0003d740: 2020 2020 2861 705f 785b 6c6c 5d20 2d20      (ap_x[ll] - 
+0003d750: 7074 735f 785b 7070 5d29 202a 2064 6574  pts_x[pp]) * det
+0003d760: 5f6e 6f72 6d5f 785b 6464 5d0a 2020 2020  _norm_x[dd].    
 0003d770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003d780: 2020 2020 2020 2020 2b20 2861 705f 795b          + (ap_y[
-0003d790: 6c6c 5d20 2d20 7074 735f 795b 7070 5d29  ll] - pts_y[pp])
-0003d7a0: 202a 2064 6574 5f6e 6f72 6d5f 795b 6464   * det_norm_y[dd
-0003d7b0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003d7c0: 2020 2020 2020 2020 2020 2b20 2861 705f            + (ap_
-0003d7d0: 7a5b 6c6c 5d20 2d20 7074 735f 7a5b 7070  z[ll] - pts_z[pp
-0003d7e0: 5d29 202a 2064 6574 5f6e 6f72 6d5f 7a5b  ]) * det_norm_z[
-0003d7f0: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-0003d800: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-0003d810: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0003d820: 6620 7363 6131 203e 3d20 303a 0a20 2020  f sca1 >= 0:.   
+0003d780: 2020 2020 2b20 2861 705f 795b 6c6c 5d20      + (ap_y[ll] 
+0003d790: 2d20 7074 735f 795b 7070 5d29 202a 2064  - pts_y[pp]) * d
+0003d7a0: 6574 5f6e 6f72 6d5f 795b 6464 5d0a 2020  et_norm_y[dd].  
+0003d7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d7c0: 2020 2020 2020 2b20 2861 705f 7a5b 6c6c        + (ap_z[ll
+0003d7d0: 5d20 2d20 7074 735f 7a5b 7070 5d29 202a  ] - pts_z[pp]) *
+0003d7e0: 2064 6574 5f6e 6f72 6d5f 7a5b 6464 5d0a   det_norm_z[dd].
+0003d7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d800: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+0003d810: 2020 2020 2020 2020 2020 2069 6620 7363             if sc
+0003d820: 6131 203e 3d20 303a 0a20 2020 2020 2020  a1 >= 0:.       
 0003d830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003d840: 2020 2020 2069 736f 6b20 3d20 4661 6c73       isok = Fals
-0003d850: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-0003d860: 2020 2020 2020 2020 2020 6272 6561 6b0a            break.
-0003d870: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003d880: 2020 2020 2023 2070 726f 6a65 6374 2069       # project i
-0003d890: 6e20 3264 0a20 2020 2020 2020 2020 2020  n 2d.           
-0003d8a0: 2020 2020 2020 2020 206b 203d 202d 2073           k = - s
-0003d8b0: 6361 3020 2f20 7363 6131 0a20 2020 2020  ca0 / sca1.     
-0003d8c0: 2020 2020 2020 2020 2020 2020 2020 2050                 P
-0003d8d0: 5f78 203d 2070 7473 5f78 5b70 705d 202b  _x = pts_x[pp] +
-0003d8e0: 206b 202a 2028 6170 5f78 5b6c 6c5d 202d   k * (ap_x[ll] -
-0003d8f0: 2070 7473 5f78 5b70 705d 290a 2020 2020   pts_x[pp]).    
-0003d900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003d910: 505f 7920 3d20 7074 735f 795b 7070 5d20  P_y = pts_y[pp] 
-0003d920: 2b20 6b20 2a20 2861 705f 795b 6c6c 5d20  + k * (ap_y[ll] 
-0003d930: 2d20 7074 735f 795b 7070 5d29 0a20 2020  - pts_y[pp]).   
-0003d940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003d950: 2050 5f7a 203d 2070 7473 5f7a 5b70 705d   P_z = pts_z[pp]
-0003d960: 202b 206b 202a 2028 6170 5f7a 5b6c 6c5d   + k * (ap_z[ll]
-0003d970: 202d 2070 7473 5f7a 5b70 705d 290a 0a20   - pts_z[pp]).. 
-0003d980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003d990: 2020 2023 2070 726f 6a65 6374 2069 6e20     # project in 
-0003d9a0: 3264 0a20 2020 2020 2020 2020 2020 2020  2d.             
-0003d9b0: 2020 2020 2020 2061 705f 7830 5b6c 6c5d         ap_x0[ll]
-0003d9c0: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-0003d9d0: 2020 2020 2020 2020 2020 2020 2028 505f               (P_
-0003d9e0: 7820 2d20 6465 745f 6365 6e74 735f 785b  x - det_cents_x[
-0003d9f0: 6464 5d29 202a 2064 6574 5f65 305f 785b  dd]) * det_e0_x[
-0003da00: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
-0003da10: 2020 2020 2020 2020 2020 2020 2b20 2850              + (P
-0003da20: 5f79 202d 2064 6574 5f63 656e 7473 5f79  _y - det_cents_y
-0003da30: 5b64 645d 2920 2a20 6465 745f 6530 5f79  [dd]) * det_e0_y
-0003da40: 5b64 645d 0a20 2020 2020 2020 2020 2020  [dd].           
-0003da50: 2020 2020 2020 2020 2020 2020 202b 2028               + (
-0003da60: 505f 7a20 2d20 6465 745f 6365 6e74 735f  P_z - det_cents_
-0003da70: 7a5b 6464 5d29 202a 2064 6574 5f65 305f  z[dd]) * det_e0_
-0003da80: 7a5b 6464 5d0a 2020 2020 2020 2020 2020  z[dd].          
-0003da90: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-0003daa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003dab0: 6170 5f78 315b 6c6c 5d20 3d20 280a 2020  ap_x1[ll] = (.  
+0003d840: 2069 736f 6b20 3d20 4661 6c73 650a 2020   isok = False.  
+0003d850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d860: 2020 2020 2020 6272 6561 6b0a 0a20 2020        break..   
+0003d870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d880: 2023 2070 726f 6a65 6374 2069 6e20 3264   # project in 2d
+0003d890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003d8a0: 2020 2020 206b 203d 202d 2073 6361 3020       k = - sca0 
+0003d8b0: 2f20 7363 6131 0a20 2020 2020 2020 2020  / sca1.         
+0003d8c0: 2020 2020 2020 2020 2020 2050 5f78 203d             P_x =
+0003d8d0: 2070 7473 5f78 5b70 705d 202b 206b 202a   pts_x[pp] + k *
+0003d8e0: 2028 6170 5f78 5b6c 6c5d 202d 2070 7473   (ap_x[ll] - pts
+0003d8f0: 5f78 5b70 705d 290a 2020 2020 2020 2020  _x[pp]).        
+0003d900: 2020 2020 2020 2020 2020 2020 505f 7920              P_y 
+0003d910: 3d20 7074 735f 795b 7070 5d20 2b20 6b20  = pts_y[pp] + k 
+0003d920: 2a20 2861 705f 795b 6c6c 5d20 2d20 7074  * (ap_y[ll] - pt
+0003d930: 735f 795b 7070 5d29 0a20 2020 2020 2020  s_y[pp]).       
+0003d940: 2020 2020 2020 2020 2020 2020 2050 5f7a               P_z
+0003d950: 203d 2070 7473 5f7a 5b70 705d 202b 206b   = pts_z[pp] + k
+0003d960: 202a 2028 6170 5f7a 5b6c 6c5d 202d 2070   * (ap_z[ll] - p
+0003d970: 7473 5f7a 5b70 705d 290a 0a20 2020 2020  ts_z[pp])..     
+0003d980: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0003d990: 2070 726f 6a65 6374 2069 6e20 3264 0a20   project in 2d. 
+0003d9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003d9b0: 2020 2061 705f 7830 5b6c 6c5d 203d 2028     ap_x0[ll] = (
+0003d9c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003d9d0: 2020 2020 2020 2020 2028 505f 7820 2d20           (P_x - 
+0003d9e0: 6465 745f 6365 6e74 735f 785b 6464 5d29  det_cents_x[dd])
+0003d9f0: 202a 2064 6574 5f65 305f 785b 6464 5d0a   * det_e0_x[dd].
+0003da00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003da10: 2020 2020 2020 2020 2b20 2850 5f79 202d          + (P_y -
+0003da20: 2064 6574 5f63 656e 7473 5f79 5b64 645d   det_cents_y[dd]
+0003da30: 2920 2a20 6465 745f 6530 5f79 5b64 645d  ) * det_e0_y[dd]
+0003da40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003da50: 2020 2020 2020 2020 202b 2028 505f 7a20           + (P_z 
+0003da60: 2d20 6465 745f 6365 6e74 735f 7a5b 6464  - det_cents_z[dd
+0003da70: 5d29 202a 2064 6574 5f65 305f 7a5b 6464  ]) * det_e0_z[dd
+0003da80: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0003da90: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0003daa0: 2020 2020 2020 2020 2020 2020 6170 5f78              ap_x
+0003dab0: 315b 6c6c 5d20 3d20 280a 2020 2020 2020  1[ll] = (.      
 0003dac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003dad0: 2020 2020 2020 2850 5f78 202d 2064 6574        (P_x - det
-0003dae0: 5f63 656e 7473 5f78 5b64 645d 2920 2a20  _cents_x[dd]) * 
-0003daf0: 6465 745f 6531 5f78 5b64 645d 0a20 2020  det_e1_x[dd].   
+0003dad0: 2020 2850 5f78 202d 2064 6574 5f63 656e    (P_x - det_cen
+0003dae0: 7473 5f78 5b64 645d 2920 2a20 6465 745f  ts_x[dd]) * det_
+0003daf0: 6531 5f78 5b64 645d 0a20 2020 2020 2020  e1_x[dd].       
 0003db00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003db10: 2020 2020 202b 2028 505f 7920 2d20 6465       + (P_y - de
-0003db20: 745f 6365 6e74 735f 795b 6464 5d29 202a  t_cents_y[dd]) *
-0003db30: 2064 6574 5f65 315f 795b 6464 5d0a 2020   det_e1_y[dd].  
+0003db10: 202b 2028 505f 7920 2d20 6465 745f 6365   + (P_y - det_ce
+0003db20: 6e74 735f 795b 6464 5d29 202a 2064 6574  nts_y[dd]) * det
+0003db30: 5f65 315f 795b 6464 5d0a 2020 2020 2020  _e1_y[dd].      
 0003db40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003db50: 2020 2020 2020 2b20 2850 5f7a 202d 2064        + (P_z - d
-0003db60: 6574 5f63 656e 7473 5f7a 5b64 645d 2920  et_cents_z[dd]) 
-0003db70: 2a20 6465 745f 6531 5f7a 5b64 645d 0a20  * det_e1_z[dd]. 
-0003db80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003db90: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
-0003dba0: 2020 2020 2020 6966 206e 6f74 2069 736f        if not iso
-0003dbb0: 6b3a 0a20 2020 2020 2020 2020 2020 2020  k:.             
-0003dbc0: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
-0003dbd0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0003dbe0: 7072 696e 7428 2773 6361 302c 2073 6361  print('sca0, sca
-0003dbf0: 312c 206b 2020 272c 2073 6361 302c 2073  1, k  ', sca0, s
-0003dc00: 6361 312c 206b 290a 2020 2020 2020 2020  ca1, k).        
-0003dc10: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
-0003dc20: 2750 782c 2050 792c 2050 7a3a 2020 272c  'Px, Py, Pz:  ',
-0003dc30: 2050 5f78 2c20 505f 792c 2050 5f7a 290a   P_x, P_y, P_z).
-0003dc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003dc50: 2320 7072 696e 7428 0a20 2020 2020 2020  # print(.       
-0003dc60: 2020 2020 2020 2020 2020 2020 2023 2027               # '
-0003dc70: 6170 3031 3a20 272c 0a20 2020 2020 2020  ap01: ',.       
-0003dc80: 2020 2020 2020 2020 2020 2020 2023 2061               # a
-0003dc90: 705f 7830 5b61 705f 696e 645b 6161 5d3a  p_x0[ap_ind[aa]:
-0003dca0: 6170 5f69 6e64 5b61 612b 315d 5d2c 0a20  ap_ind[aa+1]],. 
-0003dcb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003dcc0: 2020 2023 2061 705f 7831 5b61 705f 696e     # ap_x1[ap_in
-0003dcd0: 645b 6161 5d3a 6170 5f69 6e64 5b61 612b  d[aa]:ap_ind[aa+
-0003dce0: 315d 5d2c 0a20 2020 2020 2020 2020 2020  1]],.           
-0003dcf0: 2020 2020 2023 2029 0a0a 0a20 2020 2020       # )...     
-0003dd00: 2020 2020 2020 2023 2067 6f20 746f 206e         # go to n
-0003dd10: 6578 7420 706f 696e 740a 2020 2020 2020  ext point.      
-0003dd20: 2020 2020 2020 6966 206e 6f74 2069 736f        if not iso
-0003dd30: 6b3a 0a20 2020 2020 2020 2020 2020 2020  k:.             
-0003dd40: 2020 2023 2070 7269 6e74 2827 736b 6970     # print('skip
-0003dd50: 2032 272c 2073 6361 2c20 6161 2920 2020   2', sca, aa)   
-0003dd60: 2020 2020 2023 2044 420a 2020 2020 2020       # DB.      
-0003dd70: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-0003dd80: 7565 0a0a 2020 2020 2020 2020 2020 2020  ue..            
-0003dd90: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
-0003dda0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  --------------. 
-0003ddb0: 2020 2020 2020 2020 2020 2023 2063 6f6d             # com
-0003ddc0: 7075 7465 2070 6f6c 7967 6f6e 2069 6e74  pute polygon int
-0003ddd0: 6572 7365 6374 696f 6e0a 0a20 2020 2020  ersection..     
-0003dde0: 2020 2020 2020 2023 2063 6f6d 7075 7465         # compute
-0003ddf0: 2069 6e74 6572 7365 6374 696f 6e0a 2020   intersection.  
-0003de00: 2020 2020 2020 2020 2020 705f 6120 3d20            p_a = 
-0003de10: 706c 672e 506f 6c79 676f 6e28 6e70 2e61  plg.Polygon(np.a
-0003de20: 7272 6179 285b 6465 745f 6f75 746c 696e  rray([det_outlin
-0003de30: 655f 7830 2c20 6465 745f 6f75 746c 696e  e_x0, det_outlin
-0003de40: 655f 7831 5d29 2e54 290a 2020 2020 2020  e_x1]).T).      
-0003de50: 2020 2020 2020 666f 7220 6161 2069 6e20        for aa in 
-0003de60: 7261 6e67 6528 6e61 293a 0a20 2020 2020  range(na):.     
-0003de70: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
-0003de80: 6e74 2827 705f 613a 2027 2c20 6e70 2e61  nt('p_a: ', np.a
-0003de90: 7272 6179 2870 5f61 2e63 6f6e 746f 7572  rray(p_a.contour
-0003dea0: 2830 2929 2e54 290a 2020 2020 2020 2020  (0)).T).        
-0003deb0: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
-0003dec0: 2777 6974 683a 2027 2c20 6170 5f78 305b  'with: ', ap_x0[
-0003ded0: 6170 5f69 6e64 5b61 615d 3a61 705f 696e  ap_ind[aa]:ap_in
-0003dee0: 645b 6161 2b31 5d5d 2c20 6170 5f78 315b  d[aa+1]], ap_x1[
-0003def0: 6170 5f69 6e64 5b61 615d 3a61 705f 696e  ap_ind[aa]:ap_in
-0003df00: 645b 6161 2b31 5d5d 290a 2020 2020 2020  d[aa+1]]).      
-0003df10: 2020 2020 2020 2020 2020 705f 6120 3d20            p_a = 
-0003df20: 705f 6120 2620 706c 672e 506f 6c79 676f  p_a & plg.Polygo
-0003df30: 6e28 6e70 2e61 7272 6179 285b 0a20 2020  n(np.array([.   
-0003df40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003df50: 2061 705f 7830 5b61 705f 696e 645b 6161   ap_x0[ap_ind[aa
-0003df60: 5d3a 6170 5f69 6e64 5b61 612b 315d 5d2c  ]:ap_ind[aa+1]],
-0003df70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003df80: 2020 2020 2061 705f 7831 5b61 705f 696e       ap_x1[ap_in
-0003df90: 645b 6161 5d3a 6170 5f69 6e64 5b61 612b  d[aa]:ap_ind[aa+
-0003dfa0: 315d 5d2c 0a20 2020 2020 2020 2020 2020  1]],.           
-0003dfb0: 2020 2020 205d 292e 5429 0a0a 2020 2020       ]).T)..    
-0003dfc0: 2020 2020 2020 2020 2020 2020 2320 7374              # st
-0003dfd0: 6f70 2069 6620 6e6f 2069 6e74 6572 7365  op if no interse
-0003dfe0: 6374 696f 6e0a 2020 2020 2020 2020 2020  ction.          
-0003dff0: 2020 2020 2020 6966 2070 5f61 2e6e 506f        if p_a.nPo
-0003e000: 696e 7473 2829 203c 2033 3a0a 2020 2020  ints() < 3:.    
-0003e010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003e020: 6973 6f6b 203d 2046 616c 7365 0a20 2020  isok = False.   
-0003e030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003e040: 2062 7265 616b 0a0a 2020 2020 2020 2020   break..        
-0003e050: 2020 2020 2320 7374 6f70 2069 6620 6e6f      # stop if no
-0003e060: 2069 6e74 6572 7365 6374 696f 6e0a 2020   intersection.  
-0003e070: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
-0003e080: 2069 736f 6b3a 0a20 2020 2020 2020 2020   isok:.         
-0003e090: 2020 2020 2020 2023 2070 7269 6e74 2827         # print('
-0003e0a0: 736b 6970 2033 2729 2020 2020 2020 2020  skip 3')        
-0003e0b0: 2320 4442 0a20 2020 2020 2020 2020 2020  # DB.           
-0003e0c0: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
-0003e0d0: 2020 2020 2020 2020 2020 2023 202d 2d2d             # ---
-0003e0e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0003e0f0: 0a20 2020 2020 2020 2020 2020 2023 2072  .            # r
-0003e100: 6562 7569 6c64 2033 6420 706f 6c79 676f  ebuild 3d polygo
-0003e110: 6e0a 0a20 2020 2020 2020 2020 2020 2023  n..            #
-0003e120: 2063 6865 636b 2063 6377 0a20 2020 2020   check ccw.     
-0003e130: 2020 2020 2020 2070 5f61 5f78 3020 3d20         p_a_x0 = 
-0003e140: 6e70 2e61 7363 6f6e 7469 6775 6f75 7361  np.ascontiguousa
-0003e150: 7272 6179 286e 702e 6172 7261 7928 705f  rray(np.array(p_
-0003e160: 612e 636f 6e74 6f75 7228 3029 295b 3a2c  a.contour(0))[:,
-0003e170: 2030 5d29 0a20 2020 2020 2020 2020 2020   0]).           
-0003e180: 2070 5f61 5f78 3120 3d20 6e70 2e61 7363   p_a_x1 = np.asc
-0003e190: 6f6e 7469 6775 6f75 7361 7272 6179 286e  ontiguousarray(n
-0003e1a0: 702e 6172 7261 7928 705f 612e 636f 6e74  p.array(p_a.cont
-0003e1b0: 6f75 7228 3029 295b 3a2c 2031 5d29 0a20  our(0))[:, 1]). 
-0003e1c0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-0003e1d0: 7420 5f63 6865 636b 5f70 6f6c 7967 6f6e  t _check_polygon
-0003e1e0: 5f32 645f 636f 756e 7465 725f 636c 6f63  _2d_counter_cloc
-0003e1f0: 6b77 6973 6528 705f 615f 7830 2c20 705f  kwise(p_a_x0, p_
-0003e200: 615f 7831 293a 0a20 2020 2020 2020 2020  a_x1):.         
-0003e210: 2020 2020 2020 2070 5f61 5f78 3020 3d20         p_a_x0 = 
-0003e220: 6e70 2e61 7363 6f6e 7469 6775 6f75 7361  np.ascontiguousa
-0003e230: 7272 6179 2870 5f61 5f78 305b 3a3a 2d31  rray(p_a_x0[::-1
-0003e240: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-0003e250: 2020 2070 5f61 5f78 3120 3d20 6e70 2e61     p_a_x1 = np.a
-0003e260: 7363 6f6e 7469 6775 6f75 7361 7272 6179  scontiguousarray
-0003e270: 2870 5f61 5f78 315b 3a3a 2d31 5d29 0a0a  (p_a_x1[::-1])..
-0003e280: 2020 2020 2020 2020 2020 2020 2320 7472              # tr
-0003e290: 6961 6e67 756c 6174 6520 6279 2065 6172  iangulate by ear
-0003e2a0: 2d63 6c69 7070 696e 6720 2829 0a20 2020  -clipping ().   
-0003e2b0: 2020 2020 2020 2020 2074 7269 203d 2074           tri = t
-0003e2c0: 7269 616e 6775 6c61 7465 5f62 795f 6561  riangulate_by_ea
-0003e2d0: 7263 6c69 7070 696e 675f 3264 280a 2020  rclipping_2d(.  
-0003e2e0: 2020 2020 2020 2020 2020 2020 2020 6e70                np
-0003e2f0: 2e61 7363 6f6e 7469 6775 6f75 7361 7272  .ascontiguousarr
-0003e300: 6179 285b 705f 615f 7830 2c20 705f 615f  ay([p_a_x0, p_a_
-0003e310: 7831 5d29 0a20 2020 2020 2020 2020 2020  x1]).           
-0003e320: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
-0003e330: 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  # --------------
-0003e340: 2d2d 2d2d 2d0a 2020 2020 2020 2020 2020  -----.          
-0003e350: 2020 2320 636f 6d70 7574 6520 736f 6c69    # compute soli
-0003e360: 6420 616e 676c 650a 0a20 2020 2020 2020  d angle..       
-0003e370: 2020 2020 2023 206c 6f6f 7020 6f6e 2074       # loop on t
-0003e380: 7269 616e 676c 6573 0a20 2020 2020 2020  riangles.       
-0003e390: 2020 2020 2066 6f72 2074 7420 696e 2072       for tt in r
-0003e3a0: 616e 6765 2874 7269 2e73 6861 7065 5b30  ange(tri.shape[0
-0003e3b0: 5d29 3a0a 0a20 2020 2020 2020 2020 2020  ]):..           
-0003e3c0: 2020 2020 2023 2067 6574 2074 7269 616e       # get trian
-0003e3d0: 676c 650a 2020 2020 2020 2020 2020 2020  gle.            
-0003e3e0: 2020 2020 7472 695f 7820 3d20 280a 2020      tri_x = (.  
-0003e3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003e400: 2020 6465 745f 6365 6e74 735f 785b 6464    det_cents_x[dd
-0003e410: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003e420: 2020 2020 2020 2b20 705f 615f 7830 5b74        + p_a_x0[t
-0003e430: 7269 5b74 742c 203a 5d5d 202a 2064 6574  ri[tt, :]] * det
-0003e440: 5f65 305f 785b 6464 5d0a 2020 2020 2020  _e0_x[dd].      
-0003e450: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0003e460: 705f 615f 7831 5b74 7269 5b74 742c 203a  p_a_x1[tri[tt, :
-0003e470: 5d5d 202a 2064 6574 5f65 315f 785b 6464  ]] * det_e1_x[dd
-0003e480: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003e490: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0003e4a0: 2020 2020 7472 695f 7920 3d20 280a 2020      tri_y = (.  
-0003e4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003e4c0: 2020 6465 745f 6365 6e74 735f 795b 6464    det_cents_y[dd
-0003e4d0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003e4e0: 2020 2020 2020 2b20 705f 615f 7830 5b74        + p_a_x0[t
-0003e4f0: 7269 5b74 742c 203a 5d5d 202a 2064 6574  ri[tt, :]] * det
-0003e500: 5f65 305f 795b 6464 5d0a 2020 2020 2020  _e0_y[dd].      
-0003e510: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0003e520: 705f 615f 7831 5b74 7269 5b74 742c 203a  p_a_x1[tri[tt, :
-0003e530: 5d5d 202a 2064 6574 5f65 315f 795b 6464  ]] * det_e1_y[dd
-0003e540: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003e550: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0003e560: 2020 2020 7472 695f 7a20 3d20 280a 2020      tri_z = (.  
-0003e570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003e580: 2020 6465 745f 6365 6e74 735f 7a5b 6464    det_cents_z[dd
-0003e590: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003e5a0: 2020 2020 2020 2b20 705f 615f 7830 5b74        + p_a_x0[t
-0003e5b0: 7269 5b74 742c 203a 5d5d 202a 2064 6574  ri[tt, :]] * det
-0003e5c0: 5f65 305f 7a5b 6464 5d0a 2020 2020 2020  _e0_z[dd].      
-0003e5d0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0003e5e0: 705f 615f 7831 5b74 7269 5b74 742c 203a  p_a_x1[tri[tt, :
-0003e5f0: 5d5d 202a 2064 6574 5f65 315f 7a5b 6464  ]] * det_e1_z[dd
-0003e600: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0003e610: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
-0003e620: 2020 2020 2023 2063 6f6d 7075 7461 7469       # computati
-0003e630: 6f6e 2032 3a20 736f 6c69 6420 616e 676c  on 2: solid angl
-0003e640: 6520 6f66 2074 7269 616e 676c 6520 6672  e of triangle fr
-0003e650: 6f6d 2070 7473 0a20 2020 2020 2020 2020  om pts.         
-0003e660: 2020 2020 2020 2073 6f6c 6964 5f61 6e67         solid_ang
-0003e670: 6c65 202b 3d20 5f73 742e 636f 6d70 5f73  le += _st.comp_s
-0003e680: 615f 7472 6928 0a20 2020 2020 2020 2020  a_tri(.         
-0003e690: 2020 2020 2020 2020 2020 2074 7269 5f78             tri_x
-0003e6a0: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
-0003e6b0: 2020 2020 2020 2020 2074 7269 5f79 5b30           tri_y[0
-0003e6c0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-0003e6d0: 2020 2020 2020 2074 7269 5f7a 5b30 5d2c         tri_z[0],
-0003e6e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0003e6f0: 2020 2020 2074 7269 5f78 5b31 5d2c 0a20       tri_x[1],. 
-0003e700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003e710: 2020 2074 7269 5f79 5b31 5d2c 0a20 2020     tri_y[1],.   
-0003e720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003e730: 2074 7269 5f7a 5b31 5d2c 0a20 2020 2020   tri_z[1],.     
-0003e740: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0003e750: 7269 5f78 5b32 5d2c 0a20 2020 2020 2020  ri_x[2],.       
-0003e760: 2020 2020 2020 2020 2020 2020 2074 7269               tri
-0003e770: 5f79 5b32 5d2c 0a20 2020 2020 2020 2020  _y[2],.         
-0003e780: 2020 2020 2020 2020 2020 2074 7269 5f7a             tri_z
-0003e790: 5b32 5d2c 0a20 2020 2020 2020 2020 2020  [2],.           
-0003e7a0: 2020 2020 2020 2020 2070 7473 5f78 5b70           pts_x[p
-0003e7b0: 705d 2c0a 2020 2020 2020 2020 2020 2020  p],.            
-0003e7c0: 2020 2020 2020 2020 7074 735f 795b 7070          pts_y[pp
-0003e7d0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-0003e7e0: 2020 2020 2020 2070 7473 5f7a 5b70 705d         pts_z[pp]
-0003e7f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0003e800: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0003e810: 2020 2020 2320 7072 696e 7428 2774 7269      # print('tri
-0003e820: 272c 2074 742c 2073 6f6c 6964 5f61 6e67  ', tt, solid_ang
-0003e830: 6c65 5b64 642c 2070 705d 2920 2020 2020  le[dd, pp])     
-0003e840: 2020 2023 2044 420a 0a20 2020 2023 202d     # DB..    # -
-0003e850: 2d2d 2d2d 2d2d 0a20 2020 2023 2052 6574  ------.    # Ret
-0003e860: 7572 6e0a 0a20 2020 2072 6574 7572 6e20  urn..    return 
-0003e870: 736f 6c69 645f 616e 676c 650a 0a0a 6465  solid_angle...de
-0003e880: 6620 636f 6d70 7574 655f 736f 6c69 645f  f compute_solid_
-0003e890: 616e 676c 655f 6e6f 6170 6572 7475 7265  angle_noaperture
-0003e8a0: 7328 0a20 2020 2023 2070 7473 3a20 636f  s(.    # pts: co
-0003e8b0: 6f72 6469 6e61 7465 7320 6173 2074 6872  ordinates as thr
-0003e8c0: 6565 2031 6420 6172 7261 7973 0a20 2020  ee 1d arrays.   
-0003e8d0: 2064 6f75 626c 655b 3a3a 315d 2070 7473   double[::1] pts
-0003e8e0: 5f78 2c0a 2020 2020 646f 7562 6c65 5b3a  _x,.    double[:
-0003e8f0: 3a31 5d20 7074 735f 792c 0a20 2020 2064  :1] pts_y,.    d
-0003e900: 6f75 626c 655b 3a3a 315d 2070 7473 5f7a  ouble[::1] pts_z
-0003e910: 2c0a 2020 2020 2320 6465 7465 6374 6f72  ,.    # detector
-0003e920: 733a 2070 6f6c 7967 6f6e 2063 6f6f 7264  s: polygon coord
-0003e930: 696e 6174 6573 2069 6e20 3264 2028 636f  inates in 2d (co
-0003e940: 6d6d 6f6e 2074 6f20 616c 6c20 6465 7465  mmon to all dete
-0003e950: 6374 6f72 7329 0a20 2020 2064 6f75 626c  ctors).    doubl
-0003e960: 655b 3a3a 315d 2064 6574 5f6f 7574 6c69  e[::1] det_outli
-0003e970: 6e65 5f78 302c 0a20 2020 2064 6f75 626c  ne_x0,.    doubl
-0003e980: 655b 3a3a 315d 2064 6574 5f6f 7574 6c69  e[::1] det_outli
-0003e990: 6e65 5f78 312c 0a20 2020 2023 2064 6574  ne_x1,.    # det
-0003e9a0: 6563 746f 7273 3a20 6365 6e74 6572 7320  ectors: centers 
-0003e9b0: 636f 6f72 6469 6e61 7465 7320 6173 2074  coordinates as t
-0003e9c0: 6872 6565 2031 6420 6172 7261 7973 0a20  hree 1d arrays. 
-0003e9d0: 2020 2064 6f75 626c 655b 3a3a 315d 2064     double[::1] d
-0003e9e0: 6574 5f63 656e 7473 5f78 2c0a 2020 2020  et_cents_x,.    
-0003e9f0: 646f 7562 6c65 5b3a 3a31 5d20 6465 745f  double[::1] det_
-0003ea00: 6365 6e74 735f 792c 0a20 2020 2064 6f75  cents_y,.    dou
-0003ea10: 626c 655b 3a3a 315d 2064 6574 5f63 656e  ble[::1] det_cen
-0003ea20: 7473 5f7a 2c0a 2020 2020 2320 6465 7465  ts_z,.    # dete
-0003ea30: 6374 6f72 733a 206e 6f72 6d61 6c20 756e  ctors: normal un
-0003ea40: 6974 2076 6563 746f 7273 2061 7320 7468  it vectors as th
-0003ea50: 7265 6520 3164 2061 7272 6179 7320 286e  ree 1d arrays (n
-0003ea60: 6420 3d20 6c65 6e28 6465 745f 6e6f 726d  d = len(det_norm
-0003ea70: 5f78 2929 0a20 2020 2064 6f75 626c 655b  _x)).    double[
-0003ea80: 3a3a 315d 2064 6574 5f6e 6f72 6d5f 782c  ::1] det_norm_x,
-0003ea90: 0a20 2020 2064 6f75 626c 655b 3a3a 315d  .    double[::1]
-0003eaa0: 2064 6574 5f6e 6f72 6d5f 792c 0a20 2020   det_norm_y,.   
-0003eab0: 2064 6f75 626c 655b 3a3a 315d 2064 6574   double[::1] det
-0003eac0: 5f6e 6f72 6d5f 7a2c 0a20 2020 206e 702e  _norm_z,.    np.
-0003ead0: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
-0003eae0: 6e64 696d 3d31 5d20 6465 745f 6530 5f78  ndim=1] det_e0_x
-0003eaf0: 2c0a 2020 2020 6e70 2e6e 6461 7272 6179  ,.    np.ndarray
-0003eb00: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
-0003eb10: 2064 6574 5f65 305f 792c 0a20 2020 206e   det_e0_y,.    n
-0003eb20: 702e 6e64 6172 7261 795b 646f 7562 6c65  p.ndarray[double
-0003eb30: 2c20 6e64 696d 3d31 5d20 6465 745f 6530  , ndim=1] det_e0
-0003eb40: 5f7a 2c0a 2020 2020 6e70 2e6e 6461 7272  _z,.    np.ndarr
-0003eb50: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
-0003eb60: 315d 2064 6574 5f65 315f 782c 0a20 2020  1] det_e1_x,.   
-0003eb70: 206e 702e 6e64 6172 7261 795b 646f 7562   np.ndarray[doub
-0003eb80: 6c65 2c20 6e64 696d 3d31 5d20 6465 745f  le, ndim=1] det_
-0003eb90: 6531 5f79 2c0a 2020 2020 6e70 2e6e 6461  e1_y,.    np.nda
-0003eba0: 7272 6179 5b64 6f75 626c 652c 206e 6469  rray[double, ndi
-0003ebb0: 6d3d 315d 2064 6574 5f65 315f 7a2c 0a20  m=1] det_e1_z,. 
-0003ebc0: 2020 2023 2070 6f73 7369 626c 6520 6578     # possible ex
-0003ebd0: 7472 6120 7061 7261 6d65 7465 7273 203f  tra parameters ?
-0003ebe0: 0a20 2020 2064 6f75 626c 6520 6d61 7267  .    double marg
-0003ebf0: 696e 3d5f 5653 4d41 4c4c 2c0a 2020 2020  in=_VSMALL,.    
-0003ec00: 696e 7420 6e75 6d5f 7468 7265 6164 733d  int num_threads=
-0003ec10: 3130 2c0a 293a 0a20 2020 2022 2222 2054  10,.):.    """ T
-0003ec20: 7970 6963 616c 6c79 2075 7365 6420 746f  ypically used to
-0003ec30: 2063 6f6d 7075 7465 2074 6865 2065 7465   compute the ete
-0003ec40: 6e64 7565 206f 6620 6120 7369 6e67 6c65  ndue of a single
-0003ec50: 2d61 7065 7274 7572 6520 7365 7420 6f66  -aperture set of
-0003ec60: 0a20 2020 2064 6574 6563 746f 7273 2c20  .    detectors, 
-0003ec70: 7768 6572 6520 7468 6520 706f 696e 7473  where the points
-0003ec80: 2061 7265 2074 616b 656e 2069 6e20 7468   are taken in th
-0003ec90: 6520 6170 6572 7475 7265 2070 6c61 6e65  e aperture plane
-0003eca0: 2074 6f20 6765 7420 7269 6420 6f66 0a20   to get rid of. 
-0003ecb0: 2020 2069 740a 0a20 2020 204f 6e6c 7920     it..    Only 
-0003ecc0: 7661 6c69 6420 6f6e 2061 2070 6c61 6e65  valid on a plane
-0003ecd0: 2070 6572 7065 6e64 6963 756c 6172 2074   perpendicular t
-0003ece0: 6f20 7468 6520 4c4f 530a 0a20 2020 203d  o the LOS..    =
-0003ecf0: 3e20 7573 6520 666f 7220 7369 6d70 6c65  > use for simple
-0003ed00: 2063 6173 6573 0a20 2020 203d 3e20 7573   cases.    => us
-0003ed10: 6564 2061 7320 6120 7465 7374 696e 6720  ed as a testing 
-0003ed20: 6772 6f75 6e64 2062 6566 6f72 6520 6d6f  ground before mo
-0003ed30: 7265 2063 6f6d 706c 6578 2072 6f75 7469  re complex routi
-0003ed40: 6e65 730a 0a20 2020 2022 2222 0a0a 2020  nes..    """..  
-0003ed50: 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a    # -----------.
-0003ed60: 2020 2020 2320 4465 636c 6172 6174 696f      # Declaratio
-0003ed70: 6e0a 0a20 2020 2063 6465 6620 696e 7420  n..    cdef int 
-0003ed80: 6e70 7473 203d 2070 7473 5f78 2e73 697a  npts = pts_x.siz
-0003ed90: 650a 2020 2020 6364 6566 2069 6e74 206e  e.    cdef int n
-0003eda0: 6420 3d20 6465 745f 6365 6e74 735f 782e  d = det_cents_x.
-0003edb0: 7369 7a65 0a20 2020 2063 6465 6620 6464  size.    cdef dd
-0003edc0: 2c20 7070 2c20 7474 0a20 2020 2063 6465  , pp, tt.    cde
-0003edd0: 6620 666c 6f61 7420 7363 610a 2020 2020  f float sca.    
-0003ede0: 6364 6566 2064 6f75 626c 655b 3a3a 315d  cdef double[::1]
-0003edf0: 2070 6f6c 795f 780a 2020 2020 6364 6566   poly_x.    cdef
-0003ee00: 2064 6f75 626c 655b 3a3a 315d 2070 6f6c   double[::1] pol
-0003ee10: 795f 790a 2020 2020 6364 6566 2064 6f75  y_y.    cdef dou
-0003ee20: 626c 655b 3a3a 315d 2070 6f6c 795f 7a0a  ble[::1] poly_z.
-0003ee30: 0a20 2020 2023 2069 6e69 7469 616c 697a  .    # initializ
-0003ee40: 6520 736f 6c69 6420 616e 676c 6520 6172  e solid angle ar
-0003ee50: 7261 7920 7769 7468 207a 6572 6f73 0a20  ray with zeros. 
-0003ee60: 2020 2063 6465 6620 6e70 2e6e 6461 7272     cdef np.ndarr
-0003ee70: 6179 5b64 6f75 626c 652c 206e 6469 6d3d  ay[double, ndim=
-0003ee80: 325d 2073 6f6c 6964 5f61 6e67 6c65 203d  2] solid_angle =
-0003ee90: 206e 702e 7a65 726f 7328 286e 642c 206e   np.zeros((nd, n
-0003eea0: 7074 7329 2c20 6474 7970 653d 666c 6f61  pts), dtype=floa
-0003eeb0: 7429 0a0a 2020 2020 2320 2d2d 2d2d 2d2d  t)..    # ------
-0003eec0: 2d0a 2020 2020 2320 436f 6d70 7574 650a  -.    # Compute.
-0003eed0: 0a20 2020 2023 2074 7269 616e 6775 6c61  .    # triangula
-0003eee0: 7465 2064 6574 2062 7920 6561 722d 636c  te det by ear-cl
-0003eef0: 6970 7069 6e67 0a20 2020 2074 7269 203d  ipping.    tri =
-0003ef00: 2074 7269 616e 6775 6c61 7465 5f62 795f   triangulate_by_
-0003ef10: 6561 7263 6c69 7070 696e 675f 3264 286e  earclipping_2d(n
-0003ef20: 702e 6172 7261 7928 5b64 6574 5f6f 7574  p.array([det_out
-0003ef30: 6c69 6e65 5f78 302c 2064 6574 5f6f 7574  line_x0, det_out
-0003ef40: 6c69 6e65 5f78 315d 2929 0a0a 2020 2020  line_x1]))..    
-0003ef50: 666f 7220 6464 2069 6e20 7261 6e67 6528  for dd in range(
-0003ef60: 6e64 293a 0a0a 2020 2020 2020 2020 2320  nd):..        # 
-0003ef70: 6275 696c 6420 3364 2070 6f6c 7967 6f6e  build 3d polygon
-0003ef80: 0a20 2020 2020 2020 2070 6f6c 795f 7820  .        poly_x 
-0003ef90: 3d20 6465 745f 6365 6e74 735f 785b 6464  = det_cents_x[dd
-0003efa0: 5d20 2b20 6465 745f 6f75 746c 696e 655f  ] + det_outline_
-0003efb0: 7830 202a 2064 6574 5f65 305f 785b 6464  x0 * det_e0_x[dd
-0003efc0: 5d20 2b20 6465 745f 6f75 746c 696e 655f  ] + det_outline_
-0003efd0: 7831 202a 2064 6574 5f65 315f 785b 6464  x1 * det_e1_x[dd
-0003efe0: 5d0a 2020 2020 2020 2020 706f 6c79 5f79  ].        poly_y
-0003eff0: 203d 2064 6574 5f63 656e 7473 5f79 5b64   = det_cents_y[d
-0003f000: 645d 202b 2064 6574 5f6f 7574 6c69 6e65  d] + det_outline
-0003f010: 5f78 3020 2a20 6465 745f 6530 5f79 5b64  _x0 * det_e0_y[d
-0003f020: 645d 202b 2064 6574 5f6f 7574 6c69 6e65  d] + det_outline
-0003f030: 5f78 3120 2a20 6465 745f 6531 5f79 5b64  _x1 * det_e1_y[d
-0003f040: 645d 0a20 2020 2020 2020 2070 6f6c 795f  d].        poly_
-0003f050: 7a20 3d20 6465 745f 6365 6e74 735f 7a5b  z = det_cents_z[
-0003f060: 6464 5d20 2b20 6465 745f 6f75 746c 696e  dd] + det_outlin
-0003f070: 655f 7830 202a 2064 6574 5f65 305f 7a5b  e_x0 * det_e0_z[
-0003f080: 6464 5d20 2b20 6465 745f 6f75 746c 696e  dd] + det_outlin
-0003f090: 655f 7831 202a 2064 6574 5f65 315f 7a5b  e_x1 * det_e1_z[
-0003f0a0: 6464 5d0a 0a20 2020 2020 2020 2023 206c  dd]..        # l
-0003f0b0: 6f6f 7020 323a 206f 6e20 6e70 7473 2028  oop 2: on npts (
-0003f0c0: 6f62 7365 7276 6174 696f 6e20 706f 696e  observation poin
-0003f0d0: 7473 290a 2020 2020 2020 2020 666f 7220  ts).        for 
-0003f0e0: 7070 2069 6e20 7261 6e67 6528 6e70 7473  pp in range(npts
-0003f0f0: 293a 0a0a 2020 2020 2020 2020 2020 2020  ):..            
-0003f100: 2320 7465 7374 2069 6620 6f6e 2067 6f6f  # test if on goo
-0003f110: 6420 7369 6465 206f 6620 6465 7465 6374  d side of detect
-0003f120: 6f72 0a20 2020 2020 2020 2020 2020 2073  or.            s
-0003f130: 6361 203d 2028 0a20 2020 2020 2020 2020  ca = (.         
-0003f140: 2020 2020 2020 2028 7074 735f 785b 7070         (pts_x[pp
-0003f150: 5d20 2d20 6465 745f 6365 6e74 735f 785b  ] - det_cents_x[
-0003f160: 6464 5d29 202a 2064 6574 5f6e 6f72 6d5f  dd]) * det_norm_
-0003f170: 785b 6464 5d0a 2020 2020 2020 2020 2020  x[dd].          
-0003f180: 2020 2020 2020 2b20 2870 7473 5f79 5b70        + (pts_y[p
-0003f190: 705d 202d 2064 6574 5f63 656e 7473 5f79  p] - det_cents_y
-0003f1a0: 5b64 645d 2920 2a20 6465 745f 6e6f 726d  [dd]) * det_norm
-0003f1b0: 5f79 5b64 645d 0a20 2020 2020 2020 2020  _y[dd].         
-0003f1c0: 2020 2020 2020 202b 2028 7074 735f 7a5b         + (pts_z[
-0003f1d0: 7070 5d20 2d20 6465 745f 6365 6e74 735f  pp] - det_cents_
-0003f1e0: 7a5b 6464 5d29 202a 2064 6574 5f6e 6f72  z[dd]) * det_nor
-0003f1f0: 6d5f 7a5b 6464 5d0a 2020 2020 2020 2020  m_z[dd].        
-0003f200: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
-0003f210: 2020 2069 6620 7363 6120 3c3d 2030 3a0a     if sca <= 0:.
-0003f220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003f230: 636f 6e74 696e 7565 0a0a 2020 2020 2020  continue..      
-0003f240: 2020 2020 2020 2320 6c6f 6f70 206f 6e20        # loop on 
-0003f250: 7472 6961 6e67 6c65 730a 2020 2020 2020  triangles.      
-0003f260: 2020 2020 2020 666f 7220 7474 2069 6e20        for tt in 
-0003f270: 7261 6e67 6528 7472 692e 7368 6170 655b  range(tri.shape[
-0003f280: 305d 293a 0a0a 2020 2020 2020 2020 2020  0]):..          
-0003f290: 2020 2020 2020 2320 636f 6d70 7574 6174        # computat
-0003f2a0: 696f 6e20 323a 2073 6f6c 6964 2061 6e67  ion 2: solid ang
-0003f2b0: 6c65 206f 6620 7472 6961 6e67 6c65 2066  le of triangle f
-0003f2c0: 726f 6d20 7074 730a 2020 2020 2020 2020  rom pts.        
-0003f2d0: 2020 2020 2020 2020 736f 6c69 645f 616e          solid_an
-0003f2e0: 676c 655b 6464 2c20 7070 5d20 2b3d 205f  gle[dd, pp] += _
-0003f2f0: 7374 2e63 6f6d 705f 7361 5f74 7269 280a  st.comp_sa_tri(.
+0003db50: 2020 2b20 2850 5f7a 202d 2064 6574 5f63    + (P_z - det_c
+0003db60: 656e 7473 5f7a 5b64 645d 2920 2a20 6465  ents_z[dd]) * de
+0003db70: 745f 6531 5f7a 5b64 645d 0a20 2020 2020  t_e1_z[dd].     
+0003db80: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0003db90: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0003dba0: 2020 6966 206e 6f74 2069 736f 6b3a 0a20    if not isok:. 
+0003dbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003dbc0: 2020 2062 7265 616b 0a0a 2020 2020 2020     break..      
+0003dbd0: 2020 2020 2020 2020 2020 2320 7072 696e            # prin
+0003dbe0: 7428 2773 6361 302c 2073 6361 312c 206b  t('sca0, sca1, k
+0003dbf0: 2020 272c 2073 6361 302c 2073 6361 312c    ', sca0, sca1,
+0003dc00: 206b 290a 2020 2020 2020 2020 2020 2020   k).            
+0003dc10: 2020 2020 2320 7072 696e 7428 2750 782c      # print('Px,
+0003dc20: 2050 792c 2050 7a3a 2020 272c 2050 5f78   Py, Pz:  ', P_x
+0003dc30: 2c20 505f 792c 2050 5f7a 290a 2020 2020  , P_y, P_z).    
+0003dc40: 2020 2020 2020 2020 2020 2020 2320 7072              # pr
+0003dc50: 696e 7428 0a20 2020 2020 2020 2020 2020  int(.           
+0003dc60: 2020 2020 2020 2020 2023 2027 6170 3031           # 'ap01
+0003dc70: 3a20 272c 0a20 2020 2020 2020 2020 2020  : ',.           
+0003dc80: 2020 2020 2020 2020 2023 2061 705f 7830           # ap_x0
+0003dc90: 5b61 705f 696e 645b 6161 5d3a 6170 5f69  [ap_ind[aa]:ap_i
+0003dca0: 6e64 5b61 612b 315d 5d2c 0a20 2020 2020  nd[aa+1]],.     
+0003dcb0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0003dcc0: 2061 705f 7831 5b61 705f 696e 645b 6161   ap_x1[ap_ind[aa
+0003dcd0: 5d3a 6170 5f69 6e64 5b61 612b 315d 5d2c  ]:ap_ind[aa+1]],
+0003dce0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003dcf0: 2023 2029 0a0a 0a20 2020 2020 2020 2020   # )...         
+0003dd00: 2020 2023 2067 6f20 746f 206e 6578 7420     # go to next 
+0003dd10: 706f 696e 740a 2020 2020 2020 2020 2020  point.          
+0003dd20: 2020 6966 206e 6f74 2069 736f 6b3a 0a20    if not isok:. 
+0003dd30: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0003dd40: 2070 7269 6e74 2827 736b 6970 2032 272c   print('skip 2',
+0003dd50: 2073 6361 2c20 6161 2920 2020 2020 2020   sca, aa)       
+0003dd60: 2023 2044 420a 2020 2020 2020 2020 2020   # DB.          
+0003dd70: 2020 2020 2020 636f 6e74 696e 7565 0a0a        continue..
+0003dd80: 2020 2020 2020 2020 2020 2020 2320 2d2d              # --
+0003dd90: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0003dda0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+0003ddb0: 2020 2020 2020 2023 2063 6f6d 7075 7465         # compute
+0003ddc0: 2070 6f6c 7967 6f6e 2069 6e74 6572 7365   polygon interse
+0003ddd0: 6374 696f 6e0a 0a20 2020 2020 2020 2020  ction..         
+0003dde0: 2020 2023 2063 6f6d 7075 7465 2069 6e74     # compute int
+0003ddf0: 6572 7365 6374 696f 6e0a 2020 2020 2020  ersection.      
+0003de00: 2020 2020 2020 705f 6120 3d20 706c 672e        p_a = plg.
+0003de10: 506f 6c79 676f 6e28 6e70 2e61 7272 6179  Polygon(np.array
+0003de20: 285b 6465 745f 6f75 746c 696e 655f 7830  ([det_outline_x0
+0003de30: 2c20 6465 745f 6f75 746c 696e 655f 7831  , det_outline_x1
+0003de40: 5d29 2e54 290a 2020 2020 2020 2020 2020  ]).T).          
+0003de50: 2020 666f 7220 6161 2069 6e20 7261 6e67    for aa in rang
+0003de60: 6528 6e61 293a 0a20 2020 2020 2020 2020  e(na):.         
+0003de70: 2020 2020 2020 2023 2070 7269 6e74 2827         # print('
+0003de80: 705f 613a 2027 2c20 6e70 2e61 7272 6179  p_a: ', np.array
+0003de90: 2870 5f61 2e63 6f6e 746f 7572 2830 2929  (p_a.contour(0))
+0003dea0: 2e54 290a 2020 2020 2020 2020 2020 2020  .T).            
+0003deb0: 2020 2020 2320 7072 696e 7428 2777 6974      # print('wit
+0003dec0: 683a 2027 2c20 6170 5f78 305b 6170 5f69  h: ', ap_x0[ap_i
+0003ded0: 6e64 5b61 615d 3a61 705f 696e 645b 6161  nd[aa]:ap_ind[aa
+0003dee0: 2b31 5d5d 2c20 6170 5f78 315b 6170 5f69  +1]], ap_x1[ap_i
+0003def0: 6e64 5b61 615d 3a61 705f 696e 645b 6161  nd[aa]:ap_ind[aa
+0003df00: 2b31 5d5d 290a 2020 2020 2020 2020 2020  +1]]).          
+0003df10: 2020 2020 2020 705f 6120 3d20 705f 6120        p_a = p_a 
+0003df20: 2620 706c 672e 506f 6c79 676f 6e28 6e70  & plg.Polygon(np
+0003df30: 2e61 7272 6179 285b 0a20 2020 2020 2020  .array([.       
+0003df40: 2020 2020 2020 2020 2020 2020 2061 705f               ap_
+0003df50: 7830 5b61 705f 696e 645b 6161 5d3a 6170  x0[ap_ind[aa]:ap
+0003df60: 5f69 6e64 5b61 612b 315d 5d2c 0a20 2020  _ind[aa+1]],.   
+0003df70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003df80: 2061 705f 7831 5b61 705f 696e 645b 6161   ap_x1[ap_ind[aa
+0003df90: 5d3a 6170 5f69 6e64 5b61 612b 315d 5d2c  ]:ap_ind[aa+1]],
+0003dfa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003dfb0: 205d 292e 5429 0a0a 2020 2020 2020 2020   ]).T)..        
+0003dfc0: 2020 2020 2020 2020 2320 7374 6f70 2069          # stop i
+0003dfd0: 6620 6e6f 2069 6e74 6572 7365 6374 696f  f no intersectio
+0003dfe0: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+0003dff0: 2020 6966 2070 5f61 2e6e 506f 696e 7473    if p_a.nPoints
+0003e000: 2829 203c 2033 3a0a 2020 2020 2020 2020  () < 3:.        
+0003e010: 2020 2020 2020 2020 2020 2020 6973 6f6b              isok
+0003e020: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
+0003e030: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+0003e040: 616b 0a0a 2020 2020 2020 2020 2020 2020  ak..            
+0003e050: 2320 7374 6f70 2069 6620 6e6f 2069 6e74  # stop if no int
+0003e060: 6572 7365 6374 696f 6e0a 2020 2020 2020  ersection.      
+0003e070: 2020 2020 2020 6966 206e 6f74 2069 736f        if not iso
+0003e080: 6b3a 0a20 2020 2020 2020 2020 2020 2020  k:.             
+0003e090: 2020 2023 2070 7269 6e74 2827 736b 6970     # print('skip
+0003e0a0: 2033 2729 2020 2020 2020 2020 2320 4442   3')        # DB
+0003e0b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003e0c0: 2063 6f6e 7469 6e75 650a 0a20 2020 2020   continue..     
+0003e0d0: 2020 2020 2020 2023 202d 2d2d 2d2d 2d2d         # -------
+0003e0e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020  ------------.   
+0003e0f0: 2020 2020 2020 2020 2023 2072 6562 7569           # rebui
+0003e100: 6c64 2033 6420 706f 6c79 676f 6e0a 0a20  ld 3d polygon.. 
+0003e110: 2020 2020 2020 2020 2020 2023 2063 6865             # che
+0003e120: 636b 2063 6377 0a20 2020 2020 2020 2020  ck ccw.         
+0003e130: 2020 2070 5f61 5f78 3020 3d20 6e70 2e61     p_a_x0 = np.a
+0003e140: 7363 6f6e 7469 6775 6f75 7361 7272 6179  scontiguousarray
+0003e150: 286e 702e 6172 7261 7928 705f 612e 636f  (np.array(p_a.co
+0003e160: 6e74 6f75 7228 3029 295b 3a2c 2030 5d29  ntour(0))[:, 0])
+0003e170: 0a20 2020 2020 2020 2020 2020 2070 5f61  .            p_a
+0003e180: 5f78 3120 3d20 6e70 2e61 7363 6f6e 7469  _x1 = np.asconti
+0003e190: 6775 6f75 7361 7272 6179 286e 702e 6172  guousarray(np.ar
+0003e1a0: 7261 7928 705f 612e 636f 6e74 6f75 7228  ray(p_a.contour(
+0003e1b0: 3029 295b 3a2c 2031 5d29 0a20 2020 2020  0))[:, 1]).     
+0003e1c0: 2020 2020 2020 2069 6620 6e6f 7420 5f63         if not _c
+0003e1d0: 6865 636b 5f70 6f6c 7967 6f6e 5f32 645f  heck_polygon_2d_
+0003e1e0: 636f 756e 7465 725f 636c 6f63 6b77 6973  counter_clockwis
+0003e1f0: 6528 705f 615f 7830 2c20 705f 615f 7831  e(p_a_x0, p_a_x1
+0003e200: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0003e210: 2020 2070 5f61 5f78 3020 3d20 6e70 2e61     p_a_x0 = np.a
+0003e220: 7363 6f6e 7469 6775 6f75 7361 7272 6179  scontiguousarray
+0003e230: 2870 5f61 5f78 305b 3a3a 2d31 5d29 0a20  (p_a_x0[::-1]). 
+0003e240: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0003e250: 5f61 5f78 3120 3d20 6e70 2e61 7363 6f6e  _a_x1 = np.ascon
+0003e260: 7469 6775 6f75 7361 7272 6179 2870 5f61  tiguousarray(p_a
+0003e270: 5f78 315b 3a3a 2d31 5d29 0a0a 2020 2020  _x1[::-1])..    
+0003e280: 2020 2020 2020 2020 2320 7472 6961 6e67          # triang
+0003e290: 756c 6174 6520 6279 2065 6172 2d63 6c69  ulate by ear-cli
+0003e2a0: 7070 696e 6720 2829 0a20 2020 2020 2020  pping ().       
+0003e2b0: 2020 2020 2074 7269 203d 2074 7269 616e       tri = trian
+0003e2c0: 6775 6c61 7465 5f62 795f 6561 7263 6c69  gulate_by_earcli
+0003e2d0: 7070 696e 675f 3264 280a 2020 2020 2020  pping_2d(.      
+0003e2e0: 2020 2020 2020 2020 2020 6e70 2e61 7363            np.asc
+0003e2f0: 6f6e 7469 6775 6f75 7361 7272 6179 285b  ontiguousarray([
+0003e300: 705f 615f 7830 2c20 705f 615f 7831 5d29  p_a_x0, p_a_x1])
+0003e310: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+0003e320: 2020 2020 2020 2020 2020 2020 2320 2d2d              # --
+0003e330: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0003e340: 2d0a 2020 2020 2020 2020 2020 2020 2320  -.            # 
+0003e350: 636f 6d70 7574 6520 736f 6c69 6420 616e  compute solid an
+0003e360: 676c 650a 0a20 2020 2020 2020 2020 2020  gle..           
+0003e370: 2023 206c 6f6f 7020 6f6e 2074 7269 616e   # loop on trian
+0003e380: 676c 6573 0a20 2020 2020 2020 2020 2020  gles.           
+0003e390: 2066 6f72 2074 7420 696e 2072 616e 6765   for tt in range
+0003e3a0: 2874 7269 2e73 6861 7065 5b30 5d29 3a0a  (tri.shape[0]):.
+0003e3b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003e3c0: 2023 2067 6574 2074 7269 616e 676c 650a   # get triangle.
+0003e3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e3e0: 7472 695f 7820 3d20 280a 2020 2020 2020  tri_x = (.      
+0003e3f0: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0003e400: 745f 6365 6e74 735f 785b 6464 5d0a 2020  t_cents_x[dd].  
+0003e410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e420: 2020 2b20 705f 615f 7830 5b74 7269 5b74    + p_a_x0[tri[t
+0003e430: 742c 203a 5d5d 202a 2064 6574 5f65 305f  t, :]] * det_e0_
+0003e440: 785b 6464 5d0a 2020 2020 2020 2020 2020  x[dd].          
+0003e450: 2020 2020 2020 2020 2020 2b20 705f 615f            + p_a_
+0003e460: 7831 5b74 7269 5b74 742c 203a 5d5d 202a  x1[tri[tt, :]] *
+0003e470: 2064 6574 5f65 315f 785b 6464 5d0a 2020   det_e1_x[dd].  
+0003e480: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003e490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e4a0: 7472 695f 7920 3d20 280a 2020 2020 2020  tri_y = (.      
+0003e4b0: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0003e4c0: 745f 6365 6e74 735f 795b 6464 5d0a 2020  t_cents_y[dd].  
+0003e4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e4e0: 2020 2b20 705f 615f 7830 5b74 7269 5b74    + p_a_x0[tri[t
+0003e4f0: 742c 203a 5d5d 202a 2064 6574 5f65 305f  t, :]] * det_e0_
+0003e500: 795b 6464 5d0a 2020 2020 2020 2020 2020  y[dd].          
+0003e510: 2020 2020 2020 2020 2020 2b20 705f 615f            + p_a_
+0003e520: 7831 5b74 7269 5b74 742c 203a 5d5d 202a  x1[tri[tt, :]] *
+0003e530: 2064 6574 5f65 315f 795b 6464 5d0a 2020   det_e1_y[dd].  
+0003e540: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003e550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e560: 7472 695f 7a20 3d20 280a 2020 2020 2020  tri_z = (.      
+0003e570: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0003e580: 745f 6365 6e74 735f 7a5b 6464 5d0a 2020  t_cents_z[dd].  
+0003e590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e5a0: 2020 2b20 705f 615f 7830 5b74 7269 5b74    + p_a_x0[tri[t
+0003e5b0: 742c 203a 5d5d 202a 2064 6574 5f65 305f  t, :]] * det_e0_
+0003e5c0: 7a5b 6464 5d0a 2020 2020 2020 2020 2020  z[dd].          
+0003e5d0: 2020 2020 2020 2020 2020 2b20 705f 615f            + p_a_
+0003e5e0: 7831 5b74 7269 5b74 742c 203a 5d5d 202a  x1[tri[tt, :]] *
+0003e5f0: 2064 6574 5f65 315f 7a5b 6464 5d0a 2020   det_e1_z[dd].  
+0003e600: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003e610: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003e620: 2023 2063 6f6d 7075 7461 7469 6f6e 2032   # computation 2
+0003e630: 3a20 736f 6c69 6420 616e 676c 6520 6f66  : solid angle of
+0003e640: 2074 7269 616e 676c 6520 6672 6f6d 2070   triangle from p
+0003e650: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
+0003e660: 2020 2073 6f6c 6964 5f61 6e67 6c65 202b     solid_angle +
+0003e670: 3d20 5f73 742e 636f 6d70 5f73 615f 7472  = _st.comp_sa_tr
+0003e680: 6928 0a20 2020 2020 2020 2020 2020 2020  i(.             
+0003e690: 2020 2020 2020 2074 7269 5f78 5b30 5d2c         tri_x[0],
+0003e6a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003e6b0: 2020 2020 2074 7269 5f79 5b30 5d2c 0a20       tri_y[0],. 
+0003e6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e6d0: 2020 2074 7269 5f7a 5b30 5d2c 0a20 2020     tri_z[0],.   
+0003e6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e6f0: 2074 7269 5f78 5b31 5d2c 0a20 2020 2020   tri_x[1],.     
+0003e700: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0003e710: 7269 5f79 5b31 5d2c 0a20 2020 2020 2020  ri_y[1],.       
+0003e720: 2020 2020 2020 2020 2020 2020 2074 7269               tri
+0003e730: 5f7a 5b31 5d2c 0a20 2020 2020 2020 2020  _z[1],.         
+0003e740: 2020 2020 2020 2020 2020 2074 7269 5f78             tri_x
+0003e750: 5b32 5d2c 0a20 2020 2020 2020 2020 2020  [2],.           
+0003e760: 2020 2020 2020 2020 2074 7269 5f79 5b32           tri_y[2
+0003e770: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0003e780: 2020 2020 2020 2074 7269 5f7a 5b32 5d2c         tri_z[2],
+0003e790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003e7a0: 2020 2020 2070 7473 5f78 5b70 705d 2c0a       pts_x[pp],.
+0003e7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e7c0: 2020 2020 7074 735f 795b 7070 5d2c 0a20      pts_y[pp],. 
+0003e7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e7e0: 2020 2070 7473 5f7a 5b70 705d 2c0a 2020     pts_z[pp],.  
+0003e7f0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0003e800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0003e810: 2320 7072 696e 7428 2774 7269 272c 2074  # print('tri', t
+0003e820: 742c 2073 6f6c 6964 5f61 6e67 6c65 5b64  t, solid_angle[d
+0003e830: 642c 2070 705d 2920 2020 2020 2020 2023  d, pp])        #
+0003e840: 2044 420a 0a20 2020 2023 202d 2d2d 2d2d   DB..    # -----
+0003e850: 2d2d 0a20 2020 2023 2052 6574 7572 6e0a  --.    # Return.
+0003e860: 0a20 2020 2072 6574 7572 6e20 736f 6c69  .    return soli
+0003e870: 645f 616e 676c 650a 0a0a 6465 6620 636f  d_angle...def co
+0003e880: 6d70 7574 655f 736f 6c69 645f 616e 676c  mpute_solid_angl
+0003e890: 655f 6e6f 6170 6572 7475 7265 7328 0a20  e_noapertures(. 
+0003e8a0: 2020 2023 2070 7473 3a20 636f 6f72 6469     # pts: coordi
+0003e8b0: 6e61 7465 7320 6173 2074 6872 6565 2031  nates as three 1
+0003e8c0: 6420 6172 7261 7973 0a20 2020 2064 6f75  d arrays.    dou
+0003e8d0: 626c 655b 3a3a 315d 2070 7473 5f78 2c0a  ble[::1] pts_x,.
+0003e8e0: 2020 2020 646f 7562 6c65 5b3a 3a31 5d20      double[::1] 
+0003e8f0: 7074 735f 792c 0a20 2020 2064 6f75 626c  pts_y,.    doubl
+0003e900: 655b 3a3a 315d 2070 7473 5f7a 2c0a 2020  e[::1] pts_z,.  
+0003e910: 2020 2320 6465 7465 6374 6f72 733a 2070    # detectors: p
+0003e920: 6f6c 7967 6f6e 2063 6f6f 7264 696e 6174  olygon coordinat
+0003e930: 6573 2069 6e20 3264 2028 636f 6d6d 6f6e  es in 2d (common
+0003e940: 2074 6f20 616c 6c20 6465 7465 6374 6f72   to all detector
+0003e950: 7329 0a20 2020 2064 6f75 626c 655b 3a3a  s).    double[::
+0003e960: 315d 2064 6574 5f6f 7574 6c69 6e65 5f78  1] det_outline_x
+0003e970: 302c 0a20 2020 2064 6f75 626c 655b 3a3a  0,.    double[::
+0003e980: 315d 2064 6574 5f6f 7574 6c69 6e65 5f78  1] det_outline_x
+0003e990: 312c 0a20 2020 2023 2064 6574 6563 746f  1,.    # detecto
+0003e9a0: 7273 3a20 6365 6e74 6572 7320 636f 6f72  rs: centers coor
+0003e9b0: 6469 6e61 7465 7320 6173 2074 6872 6565  dinates as three
+0003e9c0: 2031 6420 6172 7261 7973 0a20 2020 2064   1d arrays.    d
+0003e9d0: 6f75 626c 655b 3a3a 315d 2064 6574 5f63  ouble[::1] det_c
+0003e9e0: 656e 7473 5f78 2c0a 2020 2020 646f 7562  ents_x,.    doub
+0003e9f0: 6c65 5b3a 3a31 5d20 6465 745f 6365 6e74  le[::1] det_cent
+0003ea00: 735f 792c 0a20 2020 2064 6f75 626c 655b  s_y,.    double[
+0003ea10: 3a3a 315d 2064 6574 5f63 656e 7473 5f7a  ::1] det_cents_z
+0003ea20: 2c0a 2020 2020 2320 6465 7465 6374 6f72  ,.    # detector
+0003ea30: 733a 206e 6f72 6d61 6c20 756e 6974 2076  s: normal unit v
+0003ea40: 6563 746f 7273 2061 7320 7468 7265 6520  ectors as three 
+0003ea50: 3164 2061 7272 6179 7320 286e 6420 3d20  1d arrays (nd = 
+0003ea60: 6c65 6e28 6465 745f 6e6f 726d 5f78 2929  len(det_norm_x))
+0003ea70: 0a20 2020 2064 6f75 626c 655b 3a3a 315d  .    double[::1]
+0003ea80: 2064 6574 5f6e 6f72 6d5f 782c 0a20 2020   det_norm_x,.   
+0003ea90: 2064 6f75 626c 655b 3a3a 315d 2064 6574   double[::1] det
+0003eaa0: 5f6e 6f72 6d5f 792c 0a20 2020 2064 6f75  _norm_y,.    dou
+0003eab0: 626c 655b 3a3a 315d 2064 6574 5f6e 6f72  ble[::1] det_nor
+0003eac0: 6d5f 7a2c 0a20 2020 206e 702e 6e64 6172  m_z,.    np.ndar
+0003ead0: 7261 795b 646f 7562 6c65 2c20 6e64 696d  ray[double, ndim
+0003eae0: 3d31 5d20 6465 745f 6530 5f78 2c0a 2020  =1] det_e0_x,.  
+0003eaf0: 2020 6e70 2e6e 6461 7272 6179 5b64 6f75    np.ndarray[dou
+0003eb00: 626c 652c 206e 6469 6d3d 315d 2064 6574  ble, ndim=1] det
+0003eb10: 5f65 305f 792c 0a20 2020 206e 702e 6e64  _e0_y,.    np.nd
+0003eb20: 6172 7261 795b 646f 7562 6c65 2c20 6e64  array[double, nd
+0003eb30: 696d 3d31 5d20 6465 745f 6530 5f7a 2c0a  im=1] det_e0_z,.
+0003eb40: 2020 2020 6e70 2e6e 6461 7272 6179 5b64      np.ndarray[d
+0003eb50: 6f75 626c 652c 206e 6469 6d3d 315d 2064  ouble, ndim=1] d
+0003eb60: 6574 5f65 315f 782c 0a20 2020 206e 702e  et_e1_x,.    np.
+0003eb70: 6e64 6172 7261 795b 646f 7562 6c65 2c20  ndarray[double, 
+0003eb80: 6e64 696d 3d31 5d20 6465 745f 6531 5f79  ndim=1] det_e1_y
+0003eb90: 2c0a 2020 2020 6e70 2e6e 6461 7272 6179  ,.    np.ndarray
+0003eba0: 5b64 6f75 626c 652c 206e 6469 6d3d 315d  [double, ndim=1]
+0003ebb0: 2064 6574 5f65 315f 7a2c 0a20 2020 2023   det_e1_z,.    #
+0003ebc0: 2070 6f73 7369 626c 6520 6578 7472 6120   possible extra 
+0003ebd0: 7061 7261 6d65 7465 7273 203f 0a20 2020  parameters ?.   
+0003ebe0: 2064 6f75 626c 6520 6d61 7267 696e 3d5f   double margin=_
+0003ebf0: 5653 4d41 4c4c 2c0a 2020 2020 696e 7420  VSMALL,.    int 
+0003ec00: 6e75 6d5f 7468 7265 6164 733d 3130 2c0a  num_threads=10,.
+0003ec10: 293a 0a20 2020 2022 2222 2054 7970 6963  ):.    """ Typic
+0003ec20: 616c 6c79 2075 7365 6420 746f 2063 6f6d  ally used to com
+0003ec30: 7075 7465 2074 6865 2065 7465 6e64 7565  pute the etendue
+0003ec40: 206f 6620 6120 7369 6e67 6c65 2d61 7065   of a single-ape
+0003ec50: 7274 7572 6520 7365 7420 6f66 0a20 2020  rture set of.   
+0003ec60: 2064 6574 6563 746f 7273 2c20 7768 6572   detectors, wher
+0003ec70: 6520 7468 6520 706f 696e 7473 2061 7265  e the points are
+0003ec80: 2074 616b 656e 2069 6e20 7468 6520 6170   taken in the ap
+0003ec90: 6572 7475 7265 2070 6c61 6e65 2074 6f20  erture plane to 
+0003eca0: 6765 7420 7269 6420 6f66 0a20 2020 2069  get rid of.    i
+0003ecb0: 740a 0a20 2020 204f 6e6c 7920 7661 6c69  t..    Only vali
+0003ecc0: 6420 6f6e 2061 2070 6c61 6e65 2070 6572  d on a plane per
+0003ecd0: 7065 6e64 6963 756c 6172 2074 6f20 7468  pendicular to th
+0003ece0: 6520 4c4f 530a 0a20 2020 203d 3e20 7573  e LOS..    => us
+0003ecf0: 6520 666f 7220 7369 6d70 6c65 2063 6173  e for simple cas
+0003ed00: 6573 0a20 2020 203d 3e20 7573 6564 2061  es.    => used a
+0003ed10: 7320 6120 7465 7374 696e 6720 6772 6f75  s a testing grou
+0003ed20: 6e64 2062 6566 6f72 6520 6d6f 7265 2063  nd before more c
+0003ed30: 6f6d 706c 6578 2072 6f75 7469 6e65 730a  omplex routines.
+0003ed40: 0a20 2020 2022 2222 0a0a 2020 2020 2320  .    """..    # 
+0003ed50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020  -----------.    
+0003ed60: 2320 4465 636c 6172 6174 696f 6e0a 0a20  # Declaration.. 
+0003ed70: 2020 2063 6465 6620 696e 7420 6e70 7473     cdef int npts
+0003ed80: 203d 2070 7473 5f78 2e73 697a 650a 2020   = pts_x.size.  
+0003ed90: 2020 6364 6566 2069 6e74 206e 6420 3d20    cdef int nd = 
+0003eda0: 6465 745f 6365 6e74 735f 782e 7369 7a65  det_cents_x.size
+0003edb0: 0a20 2020 2063 6465 6620 6464 2c20 7070  .    cdef dd, pp
+0003edc0: 2c20 7474 0a20 2020 2063 6465 6620 666c  , tt.    cdef fl
+0003edd0: 6f61 7420 7363 610a 2020 2020 6364 6566  oat sca.    cdef
+0003ede0: 2064 6f75 626c 655b 3a3a 315d 2070 6f6c   double[::1] pol
+0003edf0: 795f 780a 2020 2020 6364 6566 2064 6f75  y_x.    cdef dou
+0003ee00: 626c 655b 3a3a 315d 2070 6f6c 795f 790a  ble[::1] poly_y.
+0003ee10: 2020 2020 6364 6566 2064 6f75 626c 655b      cdef double[
+0003ee20: 3a3a 315d 2070 6f6c 795f 7a0a 0a20 2020  ::1] poly_z..   
+0003ee30: 2023 2069 6e69 7469 616c 697a 6520 736f   # initialize so
+0003ee40: 6c69 6420 616e 676c 6520 6172 7261 7920  lid angle array 
+0003ee50: 7769 7468 207a 6572 6f73 0a20 2020 2063  with zeros.    c
+0003ee60: 6465 6620 6e70 2e6e 6461 7272 6179 5b64  def np.ndarray[d
+0003ee70: 6f75 626c 652c 206e 6469 6d3d 325d 2073  ouble, ndim=2] s
+0003ee80: 6f6c 6964 5f61 6e67 6c65 203d 206e 702e  olid_angle = np.
+0003ee90: 7a65 726f 7328 286e 642c 206e 7074 7329  zeros((nd, npts)
+0003eea0: 2c20 6474 7970 653d 666c 6f61 7429 0a0a  , dtype=float)..
+0003eeb0: 2020 2020 2320 2d2d 2d2d 2d2d 2d0a 2020      # -------.  
+0003eec0: 2020 2320 436f 6d70 7574 650a 0a20 2020    # Compute..   
+0003eed0: 2023 2074 7269 616e 6775 6c61 7465 2064   # triangulate d
+0003eee0: 6574 2062 7920 6561 722d 636c 6970 7069  et by ear-clippi
+0003eef0: 6e67 0a20 2020 2074 7269 203d 2074 7269  ng.    tri = tri
+0003ef00: 616e 6775 6c61 7465 5f62 795f 6561 7263  angulate_by_earc
+0003ef10: 6c69 7070 696e 675f 3264 286e 702e 6172  lipping_2d(np.ar
+0003ef20: 7261 7928 5b64 6574 5f6f 7574 6c69 6e65  ray([det_outline
+0003ef30: 5f78 302c 2064 6574 5f6f 7574 6c69 6e65  _x0, det_outline
+0003ef40: 5f78 315d 2929 0a0a 2020 2020 666f 7220  _x1]))..    for 
+0003ef50: 6464 2069 6e20 7261 6e67 6528 6e64 293a  dd in range(nd):
+0003ef60: 0a0a 2020 2020 2020 2020 2320 6275 696c  ..        # buil
+0003ef70: 6420 3364 2070 6f6c 7967 6f6e 0a20 2020  d 3d polygon.   
+0003ef80: 2020 2020 2070 6f6c 795f 7820 3d20 6465       poly_x = de
+0003ef90: 745f 6365 6e74 735f 785b 6464 5d20 2b20  t_cents_x[dd] + 
+0003efa0: 6465 745f 6f75 746c 696e 655f 7830 202a  det_outline_x0 *
+0003efb0: 2064 6574 5f65 305f 785b 6464 5d20 2b20   det_e0_x[dd] + 
+0003efc0: 6465 745f 6f75 746c 696e 655f 7831 202a  det_outline_x1 *
+0003efd0: 2064 6574 5f65 315f 785b 6464 5d0a 2020   det_e1_x[dd].  
+0003efe0: 2020 2020 2020 706f 6c79 5f79 203d 2064        poly_y = d
+0003eff0: 6574 5f63 656e 7473 5f79 5b64 645d 202b  et_cents_y[dd] +
+0003f000: 2064 6574 5f6f 7574 6c69 6e65 5f78 3020   det_outline_x0 
+0003f010: 2a20 6465 745f 6530 5f79 5b64 645d 202b  * det_e0_y[dd] +
+0003f020: 2064 6574 5f6f 7574 6c69 6e65 5f78 3120   det_outline_x1 
+0003f030: 2a20 6465 745f 6531 5f79 5b64 645d 0a20  * det_e1_y[dd]. 
+0003f040: 2020 2020 2020 2070 6f6c 795f 7a20 3d20         poly_z = 
+0003f050: 6465 745f 6365 6e74 735f 7a5b 6464 5d20  det_cents_z[dd] 
+0003f060: 2b20 6465 745f 6f75 746c 696e 655f 7830  + det_outline_x0
+0003f070: 202a 2064 6574 5f65 305f 7a5b 6464 5d20   * det_e0_z[dd] 
+0003f080: 2b20 6465 745f 6f75 746c 696e 655f 7831  + det_outline_x1
+0003f090: 202a 2064 6574 5f65 315f 7a5b 6464 5d0a   * det_e1_z[dd].
+0003f0a0: 0a20 2020 2020 2020 2023 206c 6f6f 7020  .        # loop 
+0003f0b0: 323a 206f 6e20 6e70 7473 2028 6f62 7365  2: on npts (obse
+0003f0c0: 7276 6174 696f 6e20 706f 696e 7473 290a  rvation points).
+0003f0d0: 2020 2020 2020 2020 666f 7220 7070 2069          for pp i
+0003f0e0: 6e20 7261 6e67 6528 6e70 7473 293a 0a0a  n range(npts):..
+0003f0f0: 2020 2020 2020 2020 2020 2020 2320 7465              # te
+0003f100: 7374 2069 6620 6f6e 2067 6f6f 6420 7369  st if on good si
+0003f110: 6465 206f 6620 6465 7465 6374 6f72 0a20  de of detector. 
+0003f120: 2020 2020 2020 2020 2020 2073 6361 203d             sca =
+0003f130: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+0003f140: 2020 2028 7074 735f 785b 7070 5d20 2d20     (pts_x[pp] - 
+0003f150: 6465 745f 6365 6e74 735f 785b 6464 5d29  det_cents_x[dd])
+0003f160: 202a 2064 6574 5f6e 6f72 6d5f 785b 6464   * det_norm_x[dd
+0003f170: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0003f180: 2020 2b20 2870 7473 5f79 5b70 705d 202d    + (pts_y[pp] -
+0003f190: 2064 6574 5f63 656e 7473 5f79 5b64 645d   det_cents_y[dd]
+0003f1a0: 2920 2a20 6465 745f 6e6f 726d 5f79 5b64  ) * det_norm_y[d
+0003f1b0: 645d 0a20 2020 2020 2020 2020 2020 2020  d].             
+0003f1c0: 2020 202b 2028 7074 735f 7a5b 7070 5d20     + (pts_z[pp] 
+0003f1d0: 2d20 6465 745f 6365 6e74 735f 7a5b 6464  - det_cents_z[dd
+0003f1e0: 5d29 202a 2064 6574 5f6e 6f72 6d5f 7a5b  ]) * det_norm_z[
+0003f1f0: 6464 5d0a 2020 2020 2020 2020 2020 2020  dd].            
+0003f200: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
+0003f210: 6620 7363 6120 3c3d 2030 3a0a 2020 2020  f sca <= 0:.    
+0003f220: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+0003f230: 696e 7565 0a0a 2020 2020 2020 2020 2020  inue..          
+0003f240: 2020 2320 6c6f 6f70 206f 6e20 7472 6961    # loop on tria
+0003f250: 6e67 6c65 730a 2020 2020 2020 2020 2020  ngles.          
+0003f260: 2020 666f 7220 7474 2069 6e20 7261 6e67    for tt in rang
+0003f270: 6528 7472 692e 7368 6170 655b 305d 293a  e(tri.shape[0]):
+0003f280: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0003f290: 2020 2320 636f 6d70 7574 6174 696f 6e20    # computation 
+0003f2a0: 323a 2073 6f6c 6964 2061 6e67 6c65 206f  2: solid angle o
+0003f2b0: 6620 7472 6961 6e67 6c65 2066 726f 6d20  f triangle from 
+0003f2c0: 7074 730a 2020 2020 2020 2020 2020 2020  pts.            
+0003f2d0: 2020 2020 736f 6c69 645f 616e 676c 655b      solid_angle[
+0003f2e0: 6464 2c20 7070 5d20 2b3d 205f 7374 2e63  dd, pp] += _st.c
+0003f2f0: 6f6d 705f 7361 5f74 7269 280a 2020 2020  omp_sa_tri(.    
 0003f300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003f310: 2020 2020 706f 6c79 5f78 5b74 7269 5b74      poly_x[tri[t
-0003f320: 742c 2030 5d5d 2c0a 2020 2020 2020 2020  t, 0]],.        
-0003f330: 2020 2020 2020 2020 2020 2020 706f 6c79              poly
-0003f340: 5f79 5b74 7269 5b74 742c 2030 5d5d 2c0a  _y[tri[tt, 0]],.
+0003f310: 706f 6c79 5f78 5b74 7269 5b74 742c 2030  poly_x[tri[tt, 0
+0003f320: 5d5d 2c0a 2020 2020 2020 2020 2020 2020  ]],.            
+0003f330: 2020 2020 2020 2020 706f 6c79 5f79 5b74          poly_y[t
+0003f340: 7269 5b74 742c 2030 5d5d 2c0a 2020 2020  ri[tt, 0]],.    
 0003f350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003f360: 2020 2020 706f 6c79 5f7a 5b74 7269 5b74      poly_z[tri[t
-0003f370: 742c 2030 5d5d 2c0a 2020 2020 2020 2020  t, 0]],.        
-0003f380: 2020 2020 2020 2020 2020 2020 706f 6c79              poly
-0003f390: 5f78 5b74 7269 5b74 742c 2031 5d5d 2c0a  _x[tri[tt, 1]],.
+0003f360: 706f 6c79 5f7a 5b74 7269 5b74 742c 2030  poly_z[tri[tt, 0
+0003f370: 5d5d 2c0a 2020 2020 2020 2020 2020 2020  ]],.            
+0003f380: 2020 2020 2020 2020 706f 6c79 5f78 5b74          poly_x[t
+0003f390: 7269 5b74 742c 2031 5d5d 2c0a 2020 2020  ri[tt, 1]],.    
 0003f3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003f3b0: 2020 2020 706f 6c79 5f79 5b74 7269 5b74      poly_y[tri[t
-0003f3c0: 742c 2031 5d5d 2c0a 2020 2020 2020 2020  t, 1]],.        
-0003f3d0: 2020 2020 2020 2020 2020 2020 706f 6c79              poly
-0003f3e0: 5f7a 5b74 7269 5b74 742c 2031 5d5d 2c0a  _z[tri[tt, 1]],.
+0003f3b0: 706f 6c79 5f79 5b74 7269 5b74 742c 2031  poly_y[tri[tt, 1
+0003f3c0: 5d5d 2c0a 2020 2020 2020 2020 2020 2020  ]],.            
+0003f3d0: 2020 2020 2020 2020 706f 6c79 5f7a 5b74          poly_z[t
+0003f3e0: 7269 5b74 742c 2031 5d5d 2c0a 2020 2020  ri[tt, 1]],.    
 0003f3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003f400: 2020 2020 706f 6c79 5f78 5b74 7269 5b74      poly_x[tri[t
-0003f410: 742c 2032 5d5d 2c0a 2020 2020 2020 2020  t, 2]],.        
-0003f420: 2020 2020 2020 2020 2020 2020 706f 6c79              poly
-0003f430: 5f79 5b74 7269 5b74 742c 2032 5d5d 2c0a  _y[tri[tt, 2]],.
+0003f400: 706f 6c79 5f78 5b74 7269 5b74 742c 2032  poly_x[tri[tt, 2
+0003f410: 5d5d 2c0a 2020 2020 2020 2020 2020 2020  ]],.            
+0003f420: 2020 2020 2020 2020 706f 6c79 5f79 5b74          poly_y[t
+0003f430: 7269 5b74 742c 2032 5d5d 2c0a 2020 2020  ri[tt, 2]],.    
 0003f440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0003f450: 2020 2020 706f 6c79 5f7a 5b74 7269 5b74      poly_z[tri[t
-0003f460: 742c 2032 5d5d 2c0a 2020 2020 2020 2020  t, 2]],.        
-0003f470: 2020 2020 2020 2020 2020 2020 7074 735f              pts_
-0003f480: 785b 7070 5d2c 0a20 2020 2020 2020 2020  x[pp],.         
-0003f490: 2020 2020 2020 2020 2020 2070 7473 5f79             pts_y
-0003f4a0: 5b70 705d 2c0a 2020 2020 2020 2020 2020  [pp],.          
-0003f4b0: 2020 2020 2020 2020 2020 7074 735f 7a5b            pts_z[
-0003f4c0: 7070 5d2c 0a20 2020 2020 2020 2020 2020  pp],.           
-0003f4d0: 2020 2020 2029 0a0a 2020 2020 7265 7475       )..    retu
-0003f4e0: 726e 2073 6f6c 6964 5f61 6e67 6c65 0a    rn solid_angle.
+0003f450: 706f 6c79 5f7a 5b74 7269 5b74 742c 2032  poly_z[tri[tt, 2
+0003f460: 5d5d 2c0a 2020 2020 2020 2020 2020 2020  ]],.            
+0003f470: 2020 2020 2020 2020 7074 735f 785b 7070          pts_x[pp
+0003f480: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0003f490: 2020 2020 2020 2070 7473 5f79 5b70 705d         pts_y[pp]
+0003f4a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0003f4b0: 2020 2020 2020 7074 735f 7a5b 7070 5d2c        pts_z[pp],
+0003f4c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0003f4d0: 2029 0a0a 2020 2020 7265 7475 726e 2073   )..    return s
+0003f4e0: 6f6c 6964 5f61 6e67 6c65 0a              olid_angle.
```

### Comparing `tofu-1.6.5/tofu/geom/_basic_geom_tools.pxd` & `tofu-1.7.0/tofu/geom/_basic_geom_tools.pxd`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_basic_geom_tools.pyx` & `tofu-1.7.0/tofu/geom/_basic_geom_tools.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_chained_list.pyx` & `tofu-1.7.0/tofu/geom/_chained_list.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_check_optics.py` & `tofu-1.7.0/tofu/geom/_check_optics.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_comp.py` & `tofu-1.7.0/tofu/geom/_comp.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_comp_optics.py` & `tofu-1.7.0/tofu/geom/_comp_optics.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_core.py` & `tofu-1.7.0/tofu/geom/_core.py`

 * *Files 0% similar despite different names*

```diff
@@ -5333,25 +5333,27 @@
                 PIn = self.D[:, ind] + kIn[None, ind] * self.u[:, ind]
                 POut = self.D[:, ind] + kOut[None, ind] * self.u[:, ind]
                 msg2 = ("\n\tD = {}\n".format(self.D[:, ind])
                         + "\tu = {}\n".format(self.u[:, ind])
                         + "\tPIn = {}\n".format(PIn)
                         + "\tPOut = {}".format(POut))
                 warnings.warn(msg2)
-                # plot 3d debug figure
+                # # plot 3d debug figure
                 # _plot._LOS_calc_InOutPolProj_Debug(
-                # self.config,
-                # self.D[:, ind],
-                # self.u[:, ind],
-                # PIn,
-                # POut,
-                # nptstot=kOut.size,
-                # Lim=[np.pi / 4.0, 2.0 * np.pi / 4],
-                # Nstep=50,
+                    # self.config,
+                    # self.D[:, ind],
+                    # self.u[:, ind],
+                    # PIn,
+                    # POut,
+                    # nptstot=kOut.size,
+                    # Lim=[np.pi / 4.0, 2.0 * np.pi / 4],
+                    # Nstep=50,
                 # )
+                # import pdb; pdb.set_trace()     # DB
+
             kOut[ind] = np.nan
             if strict is True:
                 raise Exception(msg)
             else:
                 warnings.warn(msg)
 
         # Handle particular cases with kIn > kOut
```

### Comparing `tofu-1.6.5/tofu/geom/_core_optics.py` & `tofu-1.7.0/tofu/geom/_core_optics.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_def.py` & `tofu-1.7.0/tofu/geom/_def.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_def_config.py` & `tofu-1.7.0/tofu/geom/_def_config.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_distance_tools.pxd` & `tofu-1.7.0/tofu/geom/_distance_tools.pxd`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_distance_tools.pyx` & `tofu-1.7.0/tofu/geom/_distance_tools.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_etendue.py` & `tofu-1.7.0/tofu/geom/_etendue.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_openmp_tools.pyx` & `tofu-1.7.0/tofu/geom/_openmp_tools.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_plot.py` & `tofu-1.7.0/tofu/geom/_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_plot_optics.py` & `tofu-1.7.0/tofu/geom/_plot_optics.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_raytracing_tools.pxd` & `tofu-1.7.0/tofu/geom/_raytracing_tools.pxd`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_raytracing_tools.pyx` & `tofu-1.7.0/tofu/geom/_raytracing_tools.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_sampling_tools.pxd` & `tofu-1.7.0/tofu/geom/_sampling_tools.pxd`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_sampling_tools.pyx` & `tofu-1.7.0/tofu/geom/_sampling_tools.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_sorted_set.pyx` & `tofu-1.7.0/tofu/geom/_sorted_set.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_vignetting_tools.pxd` & `tofu-1.7.0/tofu/geom/_vignetting_tools.pxd`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/_vignetting_tools.pyx` & `tofu-1.7.0/tofu/geom/_vignetting_tools.pyx`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/AUG_V0_from_V1.py` & `tofu-1.7.0/tofu/geom/inputs/AUG_V0_from_V1.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCupper0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_EFCupper0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlatelower.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlatelower.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlateupper.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpSPARC_VStabPlateupper.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_B03A3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_E03A3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpTCV_T03A3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow1V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow1V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow2V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivLow2V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp1V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp1V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp2V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_CoilPF_ExpWEST_DivUp2V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_ICRHa.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_ICRHa.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpAUG_SBi.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpAUG_SBi.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_inner.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_inner.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_lower.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_lower.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_outer.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_outer.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_upper.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpCOMPASS_upper.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketInnerV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketInnerV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketOuterV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_BlanketOuterV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_DivertorV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_DivertorV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterEquatV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterEquatV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterUpperV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpDEMO2019_LimiterUpperV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK01.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK01.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK02.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK02.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK03.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK03.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK04.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK04.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK05.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK05.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK06.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK06.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK07.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK07.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK08.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK08.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK09.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK09.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK10.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK10.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK11.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK11.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK12.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK12.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK13.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK13.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK14.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK14.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK15.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK15.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK16.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK16.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK17.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK17.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_BLK18.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_BLK18.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div4.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div4.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div5.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div5.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div6.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div6.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpITER_Div7.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpITER_Div7.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter01.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter01.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter02.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter02.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter03.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter03.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter04.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_BumperOutter04.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorLower.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorLower.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorUpper.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_DivertorUpper.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_ICRFAntenna.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_ICRFAntenna.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter01.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter01.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter02.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_VesselOutter02.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70015.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70015.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70085.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpNSTX_path70085.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpSPARC_ICRH0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpSPARC_ICRH0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpTOMAS_AntennaV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpTOMAS_AntennaV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpTOMAS_LimiterV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpTOMAS_LimiterV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BaffleV2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperInnerV3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_BumperOuterV3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverLDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverLDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverUDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingCoverUDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingLDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingLDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateLDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateLDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateUDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPFUPlateUDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJLDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJLDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJUDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingPJUDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingUDivV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_CasingUDivV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowGCV3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivLowITERV3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV3.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_DivUpV3.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC1V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC2V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_IC3V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH1V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_LH2V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_RippleV1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldHFSV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldHFSV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSLowV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSLowV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSSlimV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSSlimV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSUpV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSUpV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSWideV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_ThermalShieldLFSWideV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PFC_ExpWEST_VDEV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PFC_ExpWEST_VDEV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_PlasmaDomain_ExpWEST_Sep.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_PlasmaDomain_ExpWEST_Sep.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpAUG_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpAUG_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpAUG_VESiR.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpAUG_VESiR.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpCOMPASS2_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpCOMPASS2_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_InnerV1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_InnerV1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpCOMPASS_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpDEMO2019_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpDEMO2019_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_Cryostat.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_Cryostat.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_InnerV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_InnerV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_OuterV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_OuterV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpITER_V1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpITER_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpJET_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpJET_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpKSTAR_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpKSTAR_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpMAST_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpMAST_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpNSTX_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpNSTX_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpNSTX_VesselInner.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpNSTX_VesselInner.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFInner.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFInner.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFOuter.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_CoilTFOuter.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_FirstWallV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_FirstWallV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesInner.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesInner.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesOuter.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpSPARC_VesOuter.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTCV_t.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTCV_t.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTCV_vIn.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTCV_vIn.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTCV_vOut.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTCV_vOut.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpTOMAS_V0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpTOMAS_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_InnerV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_InnerV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_OuterV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_OuterV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV0.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV1.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV2.txt` & `tofu-1.7.0/tofu/geom/inputs/TFG_Ves_ExpWEST_StandardV2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/WEST_get_details_from_excel.py` & `tofu-1.7.0/tofu/geom/inputs/WEST_get_details_from_excel.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/inputs/get_geom_TCV.py` & `tofu-1.7.0/tofu/geom/inputs/get_geom_TCV.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/geom/utils.py` & `tofu-1.7.0/tofu/geom/utils.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/imas2tofu/__init__.py` & `tofu-1.7.0/tofu/imas2tofu/__init__.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/imas2tofu/_comp.py` & `tofu-1.7.0/tofu/imas2tofu/_comp.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/imas2tofu/_comp_mesh.py` & `tofu-1.7.0/tofu/imas2tofu/_comp_mesh.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/imas2tofu/_comp_toobjects.py` & `tofu-1.7.0/tofu/spectro/_fit12d.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,1391 +1,1623 @@
 
+# Built-in
 import os
 import warnings
+import datetime as dtm      # DB
 
+# Common
 import numpy as np
+import scipy.optimize as scpopt
+import scipy.interpolate as scpinterp
+import scipy.sparse as sparse
+from scipy.interpolate import BSpline
+import matplotlib.pyplot as plt
+
+
+# ToFu-specific
+from ._fit12d_dinput import *
+from ._fit12d_dinput import _dict2vector_dscalesx0bounds
+from . import _fit12d_funccostjac as _funccostjac
+from ._fit12d_dextract import *
+from . import _plot
+
+
+__all__ = [
+    'fit1d_dinput',
+    'fit2d_dinput',
+    'fit12d_dvalid',
+    'fit12d_dscales',
+    'fit1d',
+    'fit2d',
+    'fit1d_extract',
+    'fit2d_extract',
+]
+
+
+_TOL1D = {'x': 1e-10, 'f': 1.e-10, 'g': 1.e-10}
+_TOL2D = {'x': 1e-6, 'f': 1.e-6, 'g': 1.e-6}
+_CHAIN = True
+_METHOD = 'trf'
+_LOSS = 'linear'
+_SIGMA_MARGIN = 3.
+_DVALIDITY = {
+    0: 'ok',
+    -1: 'non-valid input data',
+    -2: 'convergence failed',
+    -3: 'insufficient lines / bck',
+}
+
+
+
+###########################################################
+###########################################################
+#
+#           Load dinput
+#
+###########################################################
+###########################################################
+
+
+def _rebuild_dict(dd):
+    for k0, v0 in dd.items():
+        if isinstance(v0, np.ndarray) and v0.shape == ():
+            dd[k0] = v0.tolist()
+        if isinstance(dd[k0], dict):
+            _rebuild_dict(dd[k0])
+
+
+def _checkformat_dinput(dinput, allow_pickle=True):
+    if isinstance(dinput, str):
+        if not (os.path.isfile(dinput) and dinput[-4:] == '.npz'):
+            msg = ("Arg dinput must be aither a dict or "
+                   + "the absolute path to a .npz\n"
+                   + "  You provided: {}".format(dinput))
+            raise Exception(msg)
+        dinput = dict(np.load(dinput, allow_pickle=allow_pickle))
 
+    if not isinstance(dinput, dict):
+        msg = (
+            "dinput must be a dict!\n"
+            + "  You provided: {}".format(type(dinput))
+        )
 
-from . import _def
+    _rebuild_dict(dinput)
+    return dinput
 
 
-# tofu
-pfe = os.path.join(os.path.expanduser('~'), '.tofu', '_imas2tofu_def.py')
-if os.path.isfile(pfe):
-    # Make sure we load the user-specific file
-    # sys.path method
-    # sys.path.insert(1, os.path.join(os.path.expanduser('~'), '.tofu'))
-    # import _scripts_def as _defscripts
-    # _ = sys.path.pop(1)
-    # importlib method
-    import importlib.util
-    spec = importlib.util.spec_from_file_location("_defimas2tofu", pfe)
-    _defimas2tofu = importlib.util.module_from_spec(spec)
-    spec.loader.exec_module(_defimas2tofu)
-else:
-    try:
-        import tofu.imas2tofu._def as _defimas2tofu
-    except Exception as err:
-        from . import _def as _defimas2tofu
-
-_ERRSHOT = False
-_ERREXP = False
-
-_DTLIM = _defimas2tofu._DTLIM
-_INDEVENT = _defimas2tofu._INDEVENT
-
-
-# #############################################################################
-#                       Generic
-# #############################################################################
-
-
-def _check_shotExp_consistency(didd, lidd, tofustr='shot', imasstr='shot',
-                               err=True, fallback=0):
-    crit = None
-    for idd in lidd:
-        v0 = didd[idd]
-        if imasstr in v0['params']:
-            if crit is None:
-                crit = v0['params'][imasstr]
-            elif crit != v0['params'][imasstr]:
-                ss = '{} : {}'.format(idd, str(v0['params'][imasstr]))
-                msg = ("All idd refer to different {}!\n".format(imasstr)
-                       + "\t- {}".format(ss))
-                if err:
-                    raise Exception(msg)
-                else:
-                    warnings.warn(msg)
-    if crit is None:
-        crit = fallback
-    return crit
-
-
-def get_lidsidd_shotExp(lidsok,
-                        errshot=None, errExp=None, upper=True,
-                        dids=None, didd=None):
-    """ Check whether all shot / Exp are consistent accross the ids """
-
-    if errshot is None:
-        errshot = _ERRSHOT
-    if errExp is None:
-        errExp = _ERREXP
-
-    lids = set(lidsok).intersection(dids.keys())
-    lidd = set([dids[ids]['idd'] for ids in lids])
-
-    # shot (non-identical => error if errshot is True, warning otherwise)
-    shot = _check_shotExp_consistency(didd, lidd,
-                                      tofustr='shot', imasstr='shot',
-                                      err=errshot, fallback=0)
-
-    # Exp (non-identical => error if errExp is True, warning otherwise)
-    Exp = _check_shotExp_consistency(didd, lidd,
-                                     tofustr='Exp', imasstr='database',
-                                     err=errExp, fallback='Dummy')
-    if upper is True:
-        Exp = Exp.upper()
-    return lids, lidd, shot, Exp
-
-
-# #############################################################################
-#                       Extra
-# #############################################################################
-
-
-def extra_checkformat(dextra, fordata=None,
-                      dids=None, didd=None, dshort=None):
-
-    lc = [dextra is False, dextra is None,
-          isinstance(dextra, str),
-          isinstance(dextra, list),
-          isinstance(dextra, dict)]
-    if not any(lc):
-        msg = ("Arg dextra must be either:\n"
-               + "\t- None:     set to default\n"
-               + "\t- False:    no extra signal\n"
-               + "\t- str:      a single extra signal (shortcut)\n"
-               + "\t- list:     a list of extra signals\n"
-               + "\t- dict:     a dict of extra signals {ids: list of short}\n"
-               + "\n  You provided: {}".format(dextra))
-        raise Exception(msg)
+###########################################################
+###########################################################
+#
+#           Main fitting sub-routines
+#
+###########################################################
+###########################################################
+
+
+def _checkformat_options(
+    chain, method, tr_solver, tr_options,
+    xtol, ftol, gtol, loss, max_nfev, verbose, strict,
+):
+    if chain is None:
+        chain = _CHAIN
+    if method is None:
+        method = _METHOD
+    assert method in ['trf', 'dogbox'], method
+    if tr_solver is None:
+        tr_solver = None
+    if tr_options is None:
+        tr_options = {}
+    if xtol is None:
+        xtol = _TOL1D['x']
+    if ftol is None:
+        ftol = _TOL1D['f']
+    if gtol is None:
+        gtol = _TOL1D['g']
+    if loss is None:
+        loss = _LOSS
+    if max_nfev is None:
+        max_nfev = None
+    if verbose is None:
+        verbose = 1
+    if verbose == 3:
+        verbscp = 2
+    else:
+        verbscp = 0
+    if strict is None:
+        strict = False
+
+    return (chain, method, tr_solver, tr_options,
+            xtol, ftol, gtol, loss, max_nfev, verbose, verbscp, strict)
 
-    if dextra is False:
-        if fordata is True:
-            return None
-        else:
-            return None, None
 
-    elif dextra is None:
-        dextra = {}
-        if 'equilibrium' in dids.keys():
-            dextra.update({'equilibrium': [('ip', 'k'), ('BT0', 'm'),
-                                           ('axR', (0., 0.8, 0.)),
-                                           ('axZ', (0., 1., 0.)),
-                                           'ax', 'sep', 't']})
-        if 'core_profiles' in dids.keys():
-            dextra.update({'core_profiles': ['ip', 'vloop', 't']})
-        if 'lh_antennas' in dids.keys():
-            dextra.update({'lh_antennas': [('power0', (0.8, 0., 0.)),
-                                           ('power1', (1., 0., 0.)), 't']})
-        if 'ic_antennas' in dids.keys():
-            dextra.update({'ic_antennas': [
-                ('power0', (0., 0., 0.8)),
-                ('power1', (0., 0., 1.)),
-                ('power2', (0., 0., 0.9)), 't']})
-    if type(dextra) is str:
-        dextra = [dextra]
-    if type(dextra) is list:
-        dex = {}
-        for ee in dextra:
-            lids = [ids for ids in dids.keys()
-                    if ee in dshort[ids].keys()]
-            if len(lids) != 1:
-                msg = ("No / multiple matches:\n"
-                       + "extra {} not available from self._dshort".format(ee))
-                raise Exception(msg)
-            if lids[0] not in dex.keys():
-                dex = {lids[0]: [ee]}
-            else:
-                dex[lids[0]].append(ee)
-        dextra = dex
-    return dextra
+def multigausfit1d_from_dlines(
+    dinput=None,
+    method=None, tr_solver=None, tr_options=None,
+    xtol=None, ftol=None, gtol=None,
+    max_nfev=None, chain=None, verbose=None,
+    loss=None, jac=None,
+    strict=None,
+):
+    """ Solve multi_gaussian fit in 1d from dlines
 
+    If double is True, all lines are double with common shift and ratio
 
-def extra_get_fordataTrue(inds, vs, vc, out, dout,
-                          ids=None, dshort=None, dcomp=None):
-    for ii in inds:
-        ss = vs[ii]
-        if ss == 't':
-            continue
-        if out[ss]['isempty'] is True:
-            continue
-        if ss in dshort[ids].keys():
-            dd = dshort[ids][ss]
-        else:
-            dd = dcomp[ids][ss]
-        label = dd.get('quant', 'unknown')
-        units = out[ss]['units']
-        key = '{}.{}'.format(ids, ss)
-
-        if 'sep' == ss.split('.')[-1].lower():
-            out[ss]['data'] = np.swapaxes(out[ss]['data'], 1, 2)
-
-        datastr = 'data'
-        if any([ss.split('.')[-1].lower() == s0 for s0 in ['sep', 'ax', 'x']]):
-            datastr = 'data2D'
-
-        dout[key] = {'t': out['t']['data'],
-                     datastr: out[ss]['data'],
-                     'label': label, 'units': units, 'c': vc[ii]}
-
-
-def extra_get_fordataFalse(out, d0d, dt0,
-                           ids=None, dshort=None, dcomp=None):
-    any_ = False
-    keyt = '{}.t'.format(ids)
-    for ss in out.keys():
-        if ss == 't':
-            continue
-        if out[ss]['isempty'] is True:
-            continue
-        if ss in dshort[ids].keys():
-            dd = dshort[ids][ss]
-        else:
-            dd = dcomp[ids][ss]
-        dim = dd.get('dim', 'unknown')
-        quant = dd.get('quant', 'unknown')
-        units = out[ss]['units']
-        key = '{}.{}'.format(ids, ss)
-
-        if 'sep' == ss.split('.')[-1].lower():
-            out[ss]['data'] = np.swapaxes(out[ss]['data'], 1, 2)
-
-        d0d[key] = {'data': out[ss]['data'], 'name': ss,
-                    'source': ids, 'dim': dim, 'quant': quant,
-                    'units': units, 'depend': (keyt,)}
-        any_ = True
-    if any_ is True:
-        dt0[keyt] = {'data': out['t']['data'], 'name': 't',
-                     'source': ids, 'depend': (keyt,)}
-
-
-# #############################################################################
-#                       Config
-# #############################################################################
-
-
-def config_extract_lS(ids, occ, wall, description_2d, mod,
-                      kwargs=None, mobile=None):
-    """ Extract all relevant structures """
-
-    nlim = len(wall.limiter.unit)
-    nmob = len(wall.mobile.unit)
-    # onelimonly = False
-
-    # ----------------------------------
-    # Relevant only if vessel is filled
-    # try:
-    #    if len(wall.vessel.unit) != 1:
-    #        msg = "There is no / several vessel.unit!"
-    #        raise Exception(msg)
-    #    if len(wall.vessel.unit[0].element) != 1:
-    #        msg = "There is no / several vessel.unit[0].element!"
-    #        raise Exception(msg)
-    #    if len(wall.vessel.unit[0].element[0].outline.r) < 3:
-    #        msg = "wall.vessel polygon has less than 3 points!"
-    #        raise Exception(msg)
-    #    name = wall.vessel.unit[0].element[0].name
-    #    poly = np.array([wall.vessel.unit[0].element[0].outline.r,
-    #                     wall.vessel.unit[0].element[0].outline.z])
-    # except Exception as err:
-    #    # If vessel not in vessel, sometimes stored a a single limiter
-    #    if nlim == 1:
-    #        name = wall.limiter.unit[0].name
-    #        poly = np.array([wall.limiter.unit[0].outline.r,
-    #                         wall.limiter.unit[0].outline.z])
-    #        onelimonly = True
-    #    else:
-    #        msg = ("There does not seem to be any vessel, "
-    #               + "not in wall.vessel nor in wall.limiter!")
-    #        raise Exception(msg)
-    # cls = None
-    # if name == '':
-    #     name = 'ImasVessel'
-    # if '_' in name:
-    #     ln = name.split('_')
-    #     if len(ln) == 2:
-    #         cls, name = ln
-    #     else:
-    #         name = name.replace('_', '')
-    # if cls is None:
-    #     cls = 'Ves'
-    # assert cls in ['Ves', 'PlasmaDomain']
-    # ves = getattr(mod, cls)(Poly=poly, Name=name, **kwargs)
-
-    # Determine if mobile or not
-    # if onelimonly is False:
-    if mobile is None:
-        if nlim == 0 and nmob > 0:
-            mobile = True
-        elif nmob == 0 and nlim > 0:
-            mobile = False
-        elif nmob > nlim:
-            msgw = 'wall.description_2[{}]'.format(description_2d)
-            msg = ("\nids wall has less limiter than mobile units\n"
-                   + "\t- len({}.limiter.unit) = {}\n".format(msgw, nlim)
-                   + "\t- len({}.mobile.unit) = {}\n".format(msgw, nmob)
-                   + "  => Choosing mobile by default")
-            warnings.warn(msg)
-            mobile = True
-        elif nmob <= nlim:
-            msgw = 'wall.description_2[{}]'.format(description_2d)
-            msg = ("\nids wall has more limiter than mobile units\n"
-                   + "\t- len({}.limiter.unit) = {}\n".format(msgw, nlim)
-                   + "\t- len({}.mobile.unit) = {}\n".format(msgw, nmob)
-                   + "  => Choosing limiter by default")
-            warnings.warn(msg)
-            mobile = False
-    assert isinstance(mobile, bool)
+    Unknowns are:
+        x = [bck, w0, v0, c00, c01, ..., c0n, w1, v1, c10, c11, ..., c1N, ...]
+
+        - bck : constant background
+        - wi  : spectral width of a group of lines (ion): wi^2 = 2kTi / m*c**2
+                This way, it is dimensionless
+        - vni : normalised velicity of the ion: vni = vi / c
+        - cij : normalised coef (intensity) of line: cij = Aij
+
+    Scaling is done so each quantity is close to unity:
+        - bck: np.mean(data[data < mean(data)/2])
+        - wi : Dlamb / 20
+        - vni: 10 km/s
+        - cij: np.mean(data)
+
+    """
+
+    # ---------------------------
+    # Check format options
+    (
+        chain, method, tr_solver, tr_options,
+        xtol, ftol, gtol, loss, max_nfev,
+        verbose, verbscp, strict,
+    ) = _checkformat_options(
+         chain, method, tr_solver, tr_options,
+         xtol, ftol, gtol, loss, max_nfev, verbose, strict,
+    )
 
-    # Get PFC
-    if mobile is True:
-        units = wall.mobile.unit
+    # ---------------------------
+    # Load dinput if necessary
+    dinput = _checkformat_dinput(dinput)
+    dprepare, dind = dinput['dprepare'], dinput['dind']
+    nspect = dprepare['data'].shape[0]
+
+    # ---------------------------
+    # If same spectrum => consider a single data set
+    if dinput['same_spectrum'] is True:
+        lamb = (
+            dinput['same_spectrum_dlamb']*np.arange(0, nspect)[:, None]
+            + dprepare['lamb'][None, :]
+        ).ravel()
+        datacost = dprepare['data'].ravel()[None, :]
+        nspect = data.shape[0]
+        chain = False
     else:
-        units = wall.limiter.unit
-    nunits = len(units)
+        lamb = dprepare['lamb']
+        datacost = dprepare['data']
 
-    if nunits == 0:
-        msg = ("There is no unit stored !\n"
-               + "The required 2d description is empty:\n")
-        ms = "len(idd.{}[occ={}].description_2d".format(ids, occ)
-        msg += "{}[{}].limiter.unit) = 0".format(ms,
-                                                 description_2d)
-        raise Exception(msg)
+    # ---------------------------
+    # Get scaling, x0, bounds from dict
+    scales = _dict2vector_dscalesx0bounds(
+        dd=dinput['dscales'], dd_name='dscales', dinput=dinput,
+    )
+    x0 = _dict2vector_dscalesx0bounds(
+        dd=dinput['dx0'], dd_name='dx0', dinput=dinput,
+    )
+    boundmin = _dict2vector_dscalesx0bounds(
+        dd=dinput['dbounds']['min'], dd_name="dbounds['min']", dinput=dinput,
+    )
+    boundmax = _dict2vector_dscalesx0bounds(
+        dd=dinput['dbounds']['max'], dd_name="dbounds['max']", dinput=dinput,
+    )
+    bounds = np.array([boundmin[0, :], boundmax[0, :]])
+
+    # ---------------------------
+    # Separate free from constant parameters
+    const = _dict2vector_dscalesx0bounds(
+        dd=dinput['dconstants'], dd_name='dconstants', dinput=dinput,
+    )
+    indx = np.any(np.isnan(const), axis=0)
+    const = const[:, ~indx]
+    x0[:, ~indx] = const / scales[:, ~indx]
+
+    # ---------------------------
+    # Get function, cost function and jacobian
+    (
+        func_detail, func_cost, func_jac,
+    ) = _funccostjac.multigausfit1d_from_dlines_funccostjac(
+        lamb, dinput=dinput, dind=dind, jac=jac, indx=indx,
+    )
+
+    # ---------------------------
+    # Prepare output
+    sol_x = np.full((nspect, dind['sizex']), np.nan)
+    success = np.full((nspect,), np.nan)
+    time = np.full((nspect,), np.nan)
+    cost = np.full((nspect,), np.nan)
+    nfev = np.full((nspect,), np.nan)
+    validity = np.zeros((nspect,), dtype=int)
+    message = ['' for ss in range(nspect)]
+    errmsg = ['' for ss in range(nspect)]
+
+    # Prepare msg
+    if verbose in [1, 2]:
+        col = np.char.array([
+            'spect', 'time (s)', 'cost', 'nfev', 'njev', 'msg',
+        ])
+        maxl = max(np.max(np.char.str_len(col)), 10)
+        msg = '\n'.join([' '.join([cc.ljust(maxl) for cc in col]),
+                         ' '.join(['-'*maxl]*6)])
+        print(msg)
+
+    # ------------
+    # Main loop
+
+    end = '\r'
+    t0 = dtm.datetime.now()     # DB
+    for ii in range(nspect):
+
+        if verbose == 3:
+            msg = "\nspect {} / {}".format(ii+1, nspect)
+            print(msg)
 
-    lS = [None for _ in units]
-    for ii in range(0, nunits):
         try:
-            if mobile is True:
-                outline = units[ii].outline[0]
+            dti = None
+            t0i = dtm.datetime.now()     # DB
+            if not dinput['valid']['indt'][ii]:
+                validity[ii] = -1
+                continue
+
+            # optimization
+            res = scpopt.least_squares(
+                func_cost,
+                x0[ii, indx],
+                jac=func_jac,
+                bounds=bounds[:, indx],
+                method=method,
+                ftol=ftol,
+                xtol=xtol,
+                gtol=gtol,
+                x_scale=1.0,
+                f_scale=1.0,
+                loss=loss,
+                diff_step=None,
+                tr_solver=tr_solver,
+                tr_options=tr_options,
+                jac_sparsity=None,
+                max_nfev=max_nfev,
+                verbose=verbscp,
+                args=(),
+                kwargs={
+                    'data': datacost[ii, :],
+                    'scales': scales[ii, :],
+                    'const': const[ii, :],
+                    'indok': dprepare['indok_bool'][ii, :],
+                },
+            )
+            dti = (dtm.datetime.now() - t0i).total_seconds()
+
+            if chain is True and ii < nspect-1:
+                x0[ii+1, indx] = res.x
+
+            # cost, message, time
+            success[ii] = res.success
+            cost[ii] = res.cost
+            nfev[ii] = res.nfev
+            message[ii] = res.message
+            time[ii] = round(
+                (dtm.datetime.now()-t0i).total_seconds(),
+                ndigits=3,
+            )
+            sol_x[ii, indx] = res.x
+            sol_x[ii, ~indx] = const[ii, :] / scales[ii, ~indx]
+
+        except Exception as err:
+            if strict:
+                raise err
             else:
-                outline = units[ii].outline
-            poly = np.array([outline.r, outline.z])
+                errmsg[ii] = str(err)
+                validity[ii] = -2
 
-            if units[ii].phi_extensions.size > 0:
-                pos, extent = units[ii].phi_extensions.T
+        # verbose
+        if verbose in [1, 2]:
+            if validity[ii] == 0:
+                col = np.char.array([
+                    '{} / {}'.format(ii+1, nspect),
+                    '{}'.format(dti),
+                    '{:5.3e}'.format(res.cost),
+                    str(res.nfev),
+                    str(res.njev),
+                    res.message,
+                ])
             else:
-                pos, extent = None, None
-            name = units[ii].name
-            cls, mobi = None, None
-            if name == '':
-                name = 'unit{:02.0f}'.format(ii)
-            if '_' in name:
-                name = name.strip('_')
-                ln = name.split('_')
-                if len(ln) == 2:
-                    cls, name = ln
-                elif len(ln) == 3:
-                    cls, name, mobi = ln
-                else:
-                    name = name.replace('_', '')
-            if ' ' in name:
-                name = name.strip(' ')
-                ln = name.split(' ')
-                if len(ln) > 1:
-                    for ii, nn in enumerate(ln[1:]):
-                        if nn[0].islower():
-                            ln[ii+1] = nn.capitalize()
-                    name = ''.join(ln)
-            if cls is None:
-                if ii == nunits - 1:
-                    cls = 'Ves'
-                else:
-                    cls = 'PFC'
-            # mobi = mobi == 'mobile'
-            lS[ii] = getattr(mod, cls)(Poly=poly, pos=pos,
-                                       extent=extent,
-                                       Name=name,
-                                       **kwargs)
-        except Exception as err:
-            msg = ("PFC unit[{}] named {} ".format(ii, name)
-                   + "could not be loaded!\n"
-                   + str(err))
-            raise Exception(msg)
-    return lS
+                col = np.char.array([
+                    '{} / {}'.format(ii+1, nspect),
+                    '{}'.format(dti),
+                    ' - ', ' - ', ' - ',
+                    errmsg[ii],
+                ])
+            msg = ' '.join([cc.ljust(maxl) for cc in col])
+            if verbose == 1:
+                if ii == nspect - 1:
+                    end = '\n'
+                print(msg, end=end, flush=True)
+            else:
+                print(msg, end='\n')
 
+    # ---------------------------
+    # Reshape in case of same_spectrum
+    if dinput['same_spectrum'] is True:
+        nspect0 = dinput['same_spectrum_nspect']
+
+        def reshape_custom(aa, nspect0=nspect0):
+            return aa.reshape((nspect0, int(aa.size/nspect0)))
+
+        nlamb = int(lamb.size / nspect0)
+        nlines = int((sol_detail.shape[1]-1)/nspect0)
+        lamb = lamb[:nlamb]
+
+        nxbis = int(
+            dind['bck_amp']['x'].size
+            + dind['bck_rate']['x'].size
+            + (dind['amp']['x'].size + dind['width']['x'].size)/nspect0
+            + dind['shift']['x'].size
+        )
+        if dinput['double'] is not False:
+            if dinput['double'] is True:
+                nxbis += 2
+            else:
+                nxbis += (
+                    dinput['double'].get('dratio') is not None
+                    + dinput['double'].get('dshift') is not None
+                )
+        nba = dind['bck_amp']['x'].size
+        nbr = dind['bck_rate']['x'].size
+        nb = nba+nbr
+        na = int(dind['amp']['x'].size/nspect0)
+        nw = int(dind['width']['x'].size/nspect0)
+        ns = dind['shift']['x'].size
+        x2 = np.full((nspect0, nxbis), np.nan)
+        x2[:, :nba] = sol_x[0, dind['bck_amp']['x']][None, :]
+        x2[:, nba:nbr] = sol_x[0, dind['bck_rate']['x']][None, :]
+        x2[:, nb:nb+na] = reshape_custom(sol_x[0, dind['amp']['x']])
+        x2[:, nb+na:nb+na+nw] = reshape_custom(sol_x[0, dind['width']['x']])
+        x2[:, nb+na+nw:nb+na+nw+ns] = sol_x[:, dind['shift']['x']]
+        if dinput['double'] is True:
+            x2[:, dind['dratio']['x']] = sol_x[:, dind['dratio']['x']]
+            x2[:, dind['dshift']['x']] = sol_x[:, dind['dshift']['x']]
+        import pdb; pdb.set_trace()     # DB
+        sol_x = x2
+
+    # ---------------------------
+    # Isolate dratio and dshift
+    dratio, dshift = None, None
+    if dinput['double'] is not False:
+        if dinput['double'] is True:
+            dratio = (
+                sol_x[:, dind['dratio']['x']] * scales[:, dind['dratio']['x']]
+            )
+            dshift = (
+                sol_x[:, dind['dshift']['x']] * scales[:, dind['dshift']['x']]
+            )
+        else:
+            if dinput['double'].get('dratio') is None:
+                dratio = (
+                    sol_x[:, dind['dratio']['x']]
+                    * scales[:, dind['dratio']['x']]
+                )
+            else:
+                dratio = np.full((nspect,), dinput['double']['dratio'])
 
-# #############################################################################
-#                       Plasma
-# #############################################################################
-
-
-def plasma_checkformat_dsig(dsig=None,
-                            lidsplasma=None, dids=None,
-                            dshort=None, dcomp=None):
-    lidsok = set(lidsplasma).intersection(dids.keys())
-
-    lscom = ['t']
-    lsmesh = ['2dmeshNodes', '2dmeshFaces',
-              '2dmeshR', '2dmeshZ']
-
-    lc = [dsig is None,
-          type(dsig) is str,
-          type(dsig) is list,
-          type(dsig) is dict]
-    assert any(lc)
-
-    # Convert to dict
-    if lc[0]:
-        dsig = dict.fromkeys(lidsok)
-    elif lc[1] or lc[2]:
-        if lc[1]:
-            dsig = [dsig]
-        dsig = dict.fromkeys(lidsok.intersection(dsig))
-
-    for ids in dsig.keys():
-        if dsig[ids] is None:
-            dsig[ids] = sorted(set(list(dshort[ids].keys())
-                                   + list(dcomp[ids].keys())))
-
-    # Check content
-    dout = {}
-    for k0, v0 in dsig.items():
-        lkeysok = sorted(set(list(dshort[k0].keys())
-                             + list(dcomp[k0].keys())))
-        if k0 not in lidsok:
-            msg = ("Only the following ids are relevant to Plasma2D:\n"
-                   + "\t- {}\n".format(lidsok)
-                   + "  => ids {} from dsig is ignored".format(k0))
-            warnings.warn(msg)
-            continue
-        lc = [v0 is None, type(v0) is str, type(v0) is list]
-        if not any(lc):
-            msg = ("Each value in dsig must be either:\n"
-                   + "\t- None\n"
-                   + "\t- str : a valid shortcut\n"
-                   + "\t- list of str: list of valid shortcuts\n"
-                   + "You provided:\n{}".format(dsig))
-            raise Exception(msg)
-        if lc[0]:
-            dsig[k0] = lkeysok
-        if lc[1]:
-            dsig[k0] = [dsig[k0]]
-        if not all([ss in lkeysok for ss in dsig[k0]]):
-            msg = ("All requested signals must be valid shortcuts !\n"
-                   + "    - dsig[{}] = {}".format(k0, dsig[k0]))
-            raise Exception(msg)
+            if dinput['double'].get('dshift') is None:
+                dshift = (
+                    sol_x[:, dind['dshift']['x']]
+                    * scales[:, dind['dshift']['x']]
+                )
+            else:
+                dshift = np.full((nspect,), dinput['double']['dshift'])
 
-        # Check presence of minimum
-        lc = [ss for ss in lscom if ss not in dsig[k0]]
-        if len(lc) > 0:
-            msg = ("dsig[{}] does not have {}\n".format(k0, lc)
-                   + "    - dsig[{}] = {}".format(k0, dsig[k0]))
-            raise Exception(msg)
+    if verbose > 0:
+        dt = (dtm.datetime.now() - t0).total_seconds()
+        msg = (
+            "Total computation time:"
+            + "\t{} s for {} spectra ({} s per spectrum)".format(
+                round(dt, ndigits=3),
+                nspect,
+                round(dt/nspect, ndigits=3),
+            )
+        )
+        print(msg)
 
-        # Check required minimum for 2dmesh, for valid shortcuts
-        if any(['2d' in ss for ss in dsig[k0]]):
-            lsmesh0 = set(lsmesh).intersection(dshort[k0].keys())
-            dsig[k0] += list(lsmesh0.difference(dsig[k0]))
-        dout[k0] = dsig[k0]
-    return dout
-
-
-def get_plasma(
-    multi=None,
-    dtime0=None,
-    d0d=None,
-    out0=None,
-    lids=None,
-    # radial base
-    radius_base=None,
-    # parameters
-    tlim=None,
-    t0=None,
-    indt0=None,
-    indevent=None,
-    nan=None,
-    pos=None,
-    stack=None,
-    isclose=None,
-    empty=None,
+    # ---------------------------
+    # Format output as dict
+    dfit = {
+        'dinput': dinput,
+        'scales': scales, 'x0': x0, 'bounds': bounds,
+        'jac': jac, 'sol_x': sol_x,
+        'dratio': dratio, 'dshift': dshift,
+        'indx': indx,
+        'time': time, 'success': success,
+        'validity': validity,
+        'dvalidity': _DVALIDITY,
+        'errmsg': np.array(errmsg),
+        'cost': cost, 'nfev': nfev, 'msg': np.array(message),
+        'const': const,
+        'xtol': xtol, 'ftol': ftol, 'gtol': gtol,
+    }
+    return dfit
+
+
+def multigausfit2d_from_dlines(
+    dinput=None,
+    method=None, tr_solver=None, tr_options=None,
+    xtol=None, ftol=None, gtol=None,
+    max_nfev=None, chain=None, verbose=None,
+    loss=None, jac=None,
     strict=None,
-    # plotting
-    plot=None,
-    plot_sig=None,
 ):
+    """ Solve multi_gaussian fit in 1d from dlines
 
-    import tofu.data as tfd
-    plasma = tfd.Plasma2D()
+    If double is True, all lines are double with common shift and ratio
 
-    # -----------
-    # loop on ids
+    Unknowns are:
+        x = [bck, w0, v0, c00, c01, ..., c0n, w1, v1, c10, c11, ..., c1N, ...]
 
-    for ids in lids:
-        idsshort = _def._dshortids.get(ids, ids)
+        - bck : constant background
+        - wi  : spectral width of a group of lines (ion): wi^2 = 2kTi / m*c**2
+                This way, it is dimensionless
+        - vni : normalised velicity of the ion: vni = vi / c
+        - cij : normalised coef (intensity) of line: cij = Aij
+
+    Scaling is done so each quantity is close to unity:
+        - bck: np.mean(data[data < mean(data)/2])
+        - wi : Dlamb / 20
+        - vni: 10 km/s
+        - cij: np.mean(data)
+
+    """
+
+    # ---------------------------
+    # Check format options
+    (
+        chain, method, tr_solver, tr_options,
+        xtol, ftol, gtol, loss, max_nfev,
+        verbose, verbscp, strict,
+    ) = _checkformat_options(
+         chain, method, tr_solver, tr_options,
+         xtol, ftol, gtol, loss, max_nfev, verbose, strict,
+    )
 
-        # -----
-        # time
-
-        out_ = {'t': out0[ids].get('t', None)}
-        lc = (
-            out_['t'] is not None
-            and out_['t']['isempty'] is False
-        )
+    # ---------------------------
+    # Load dinput if necessary
+    dinput = _checkformat_dinput(dinput)
+    dprepare, dind = dinput['dprepare'], dinput['dind']
+    nspect = dprepare['data'].shape[0]
+
+    # ---------------------------
+    # lamb and phi (symmetry axis?)
+    lamb = dprepare['lamb']
+    if dinput['symmetry'] is True:
+        phi = np.abs(dprepare['phi'] - np.nanmean(dinput['symmetry_axis']))
+    else:
+        phi = dprepare['phi']
 
-        keynt, nt, indt = None, None, None
-        if lc is True:
+    # ---------------------------
+    # Get scaling, x0, bounds from dict
+    scales = _dict2vector_dscalesx0bounds(
+        dd=dinput['dscales'], dd_name='dscales', dinput=dinput,
+    )
+    # muliply amplitudes by scales bs in [0, 1]
+    scales[:, dinput['dind']['amp']['x']] *= dinput['dscales']['bs'][..., None]
 
-            # get tlim
-            dtt = multi.get_tlim(
-                out_['t']['data'],
-                tlim=tlim,
-                indevent=indevent,
-                returnas=int,
-            )
-            indt = dtt['indt']
-            keynt = f'{idsshort}.nt'
-            nt = dtt['t'].size
-
-            # add ref and data
-            plasma.add_ref(key=keynt, size=nt)
-            plasma.add_data(
-                key=f'{idsshort}.t',
-                data=dtt['t'],
-                ref=keynt,
-                quant='t',
-                name='t',
-                dim='time',
-                units='s',
-                source=ids,
-            )
+    x0 = _dict2vector_dscalesx0bounds(
+        dd=dinput['dx0'], dd_name='dx0', dinput=dinput,
+    )
+    boundmin = _dict2vector_dscalesx0bounds(
+        dd=dinput['dbounds']['min'], dd_name="dbounds['min']", dinput=dinput,
+    )
+    boundmax = _dict2vector_dscalesx0bounds(
+        dd=dinput['dbounds']['max'], dd_name="dbounds['max']", dinput=dinput,
+    )
+    bounds = np.array([boundmin[0, :], boundmax[0, :]])
 
-            # -----------------
-            # time-only
+    # ---------------------------
+    # Prepare const
 
-            lsig = [
-                k0 for k0, v0 in out0[ids].items()
-                if isinstance(v0['data'], np.ndarray)
-                and v0['data'].shape == (dtt['nt0'],)
-                and k0 != 't'
-            ]
-            out_ = multi.get_data(
-                dsig={ids: lsig},
-                indt=indt,
-                nan=nan,
-                pos=pos,
-                stack=stack,
-                isclose=isclose,
-                empty=empty,
-                strict=strict,
-                return_all=False,
-                warn=False,
-            )[ids]
-
-            # add data
-            for k0, v0 in out_.items():
-
-                # Get dim / quant from dshort / dcomp + units
-                if k0 in multi._dshort[ids].keys():
-                    dim = multi._dshort[ids][k0].get('dim', 'unknown')
-                    quant = multi._dshort[ids][k0].get('quant', 'unknown')
-                else:
-                    dim = multi._dcomp[ids][k0].get('dim', 'unknown')
-                    quant = multi._dcomp[ids][k0].get('quant', 'unknown')
-
-                plasma.add_data(
-                    key=f'{idsshort}.{k0}',
-                    data=v0['data'],
-                    ref=(keynt,),
-                    dim=dim,
-                    quant=quant,
-                    units=v0['units'],
-                    source=ids,
-                )
+    const = _dict2vector_dscalesx0bounds(
+        dd=dinput['dconstants'], dd_name='dconstants', dinput=dinput,
+    )
 
-        # -------------
-        # d2d and dmesh
+    # -----------------------
+    # Prepare indbs
 
-        lsig = [kk for kk in out0[ids].keys() if '2d' in kk]
-        lsigmesh = [kk for kk in lsig if 'mesh' in kk]
-        out_ = multi.get_data(
-            dsig={ids: lsig},
-            indt=indt,
-            nan=nan,
-            pos=pos,
-            stack=stack,
-            isclose=isclose,
-            empty=empty,
-            strict=strict,
-            return_all=False,
-            warn=False,
-        )[ids]
-
-        cmesh = any([ss in out_.keys() for ss in lsigmesh])
-
-        if len(out_) > 0 and cmesh is True:
-
-            npts, datashape = None, None
-            keym = None
-
-            # ----
-            # mesh
-
-            keym = f'{idsshort}.mesh'
-            lc = [
-                all([ss in lsig for ss in ['2dmeshNodes', '2dmeshFaces']]),
-                all([ss in lsig for ss in ['2dmeshR', '2dmeshZ']]),
-            ]
-            if not np.sum(lc) == 1:
-                msg = (
-                    "2d mesh shall be provided either via:\n"
-                    "\t- '2dmeshR' and '2dmeshZ'\n"
-                    "\t- '2dmeshNodes' and '2dmeshFaces'"
-                )
-                raise Exception(msg)
+    # bck_amp, bck_rate, all amp, width and shift are affected
+    indbs = dinput['valid']['indbs']
+    indbsfull = ~np.tile(indbs, dinput['dind']['nvar_bs'])
+    ndiff = const.shape[1] - indbsfull.shape[1]
+    assert ndiff <= 2
+    if ndiff > 0:
+        indbsfull = np.concatenate(
+            (indbsfull, np.zeros((nspect, ndiff), dtype=bool)),
+            axis=1,
+        )
+    const[indbsfull] = 1.
 
-            # Nodes / Faces case
-            if lc[0]:
-                plasma.add_mesh(
-                    key=keym,
-                    source=ids,
-                    knots=out_['2dmeshNodes']['data'],
-                    cents=out_['2dmeshFaces']['data'],
-                )
-                n1 = plasma.dobj[plasma._which_mesh][keym]['shape-k'][0]
-                n2 = plasma.dobj[plasma._which_mesh][keym]['shape-c'][0]
+    # ---------------------------
+    # Separate free from constant parameters
 
-            # R / Z case
-            elif lc[1]:
-                plasma.add_mesh(
-                    key=keym,
-                    source=ids,
-                    R=out_['2dmeshR']['data'],
-                    Z=out_['2dmeshZ']['data'],
-                )
-                n1, n2 = plasma.dobj[plasma._which_mesh][keym]['shape']
+    # const = nan => x valid
+    indx = np.isnan(const)
+    x0[~indx] = const[~indx] / scales[~indx]
+
+    # -----------------------
+    # Prepare flattened data
+
+    indok_all = np.any(dprepare['indok_bool'], axis=0)
+    indok_flat = dprepare['indok_bool'][:, indok_all].reshape((nspect, -1))
+    data_flat = dprepare['data'][:, indok_all].reshape((nspect, -1))
+    phi_flat = phi[indok_all].ravel()
+    lamb_flat = lamb[indok_all].ravel()
+
+    # prepare lambrel and lambn
+    lambrel_flat = lamb_flat - dinput['lambmin_bck']
+    lambn_flat = lamb_flat[:, None] / dinput['lines'][None, ...]
+
+    # jac0
+    jac0 = np.zeros((phi_flat.size, dind['sizex']), dtype=float)
+
+    # libs
+    libs = np.array([
+        (phi_flat >= dinput['knots_mult'][ii])
+        & (phi_flat <= dinput['knots_mult'][ii + dinput['nknotsperbs'] - 1])
+        for ii in range(dinput['nbs'])
+    ])
+
+    # ---------------------------
+    # Get function, cost function and jacobian
+
+    (
+        func_cost, func_jac,
+    ) = _funccostjac.multigausfit2d_from_dlines_funccostjac(
+        phi_flat=phi_flat,
+        dinput=dinput, dind=dind, jac=jac,
+    )[2:]
+
+    # ---------------------------
+    # Prepare output
+    sol_x = np.full((nspect, dind['sizex']), np.nan)
+    sol_x[~indx] = const[~indx] / scales[~indx]
+    success = np.full((nspect,), np.nan)
+    time = np.full((nspect,), np.nan)
+    cost = np.full((nspect,), np.nan)
+    nfev = np.full((nspect,), np.nan)
+    validity = np.zeros((nspect,), dtype=int)
+    saturated = np.zeros((nspect, dind['sizex']), dtype=bool)
+    message = ['' for ss in range(nspect)]
+    errmsg = ['' for ss in range(nspect)]
+
+    indamp = np.zeros((dind['sizex'],), dtype=bool)
+    indamp[dinput['dind']['amp']['x'].T.ravel()] = True
+
+    # Prepare msg
+    if verbose in [1, 2]:
+        col = np.char.array(['Spect', 'time (s)', 'cost',
+                             'nfev', 'njev', 'msg'])
+        maxl = max(np.max(np.char.str_len(col)), 10)
+        msg = '\n'.join([
+            ' '.join([cc.ljust(maxl) for cc in col]),
+            ' '.join(['-'*maxl]*6),
+        ])
+        print(msg)
+
+    # ------------
+    # Main loop
+
+    end = '\r'
+    t0 = dtm.datetime.now()     # DB
+    for ii in range(nspect):
+
+        if verbose == 3:
+            msg = "\nSpect {} / {}".format(ii+1, nspect)
+            print(msg)
 
-            # ------------------
-            # profiles2d on mesh
+        try:
+            dti = None
+            t0i = dtm.datetime.now()     # DB
+            if not dinput['valid']['indt'][ii]:
+                validity[ii] = -1
+                continue
+
+            deltab = bounds[1, indx[ii, :]] - bounds[0, indx[ii, :]]
+
+            # optimization
+            res = scpopt.least_squares(
+                func_cost,
+                x0[ii, indx[ii, :]],
+                jac=func_jac,
+                bounds=bounds[:, indx[ii, :]],
+                method=method,
+                ftol=ftol,
+                xtol=xtol,
+                gtol=gtol,
+                x_scale=1.0,
+                f_scale=1.0,
+                loss=loss,
+                diff_step=None,
+                tr_solver=tr_solver,
+                tr_options=tr_options,
+                jac_sparsity=None,
+                max_nfev=max_nfev,
+                verbose=verbscp,
+                args=(),
+                kwargs={
+                    'indx': indx[ii, :],
+                    'data_flat': data_flat[ii, indok_flat[ii]],
+                    'scales': scales[ii, :],
+                    'const': const[ii, ~indx[ii, :]],
+                    'indok_flat': indok_flat[ii],
+                    'phi_flat': phi_flat[indok_flat[ii]],
+                    'lambrel_flat': lambrel_flat[indok_flat[ii]],
+                    'lambn_flat': lambn_flat[indok_flat[ii], :],
+                    'jac0': jac0[indok_flat[ii], :],
+                    'libs': [ibs[indok_flat[ii]] for ibs in libs],
+                }
+            )
+            dti = (dtm.datetime.now() - t0i).total_seconds()
 
-            meshtype = plasma.dobj[plasma._which_mesh][keym]['type']
-            for ss in set(out_.keys()).difference(lsigmesh):
-                add_profile2d(
-                    multi=multi,
-                    ids=ids,
-                    idsshort=idsshort,
-                    plasma=plasma,
-                    out_=out_,
-                    ss=ss,
-                    # for references
-                    keynt=keynt,
-                    keym=keym,
-                    # mesh
-                    meshtype=meshtype,
-                    n1=n1,
-                    n2=n2,
-                    nt=nt,
-                )
+            if chain is True and ii < nspect-1:
+                x0[ii+1, indx[ii, :]] = res.x
 
-        elif len(out_) > 0:
-            msg = (
-                "No mesh to be used as reference!"
+            # cost, message, time
+            success[ii] = res.success
+            cost[ii] = res.cost
+            nfev[ii] = res.nfev
+            message[ii] = res.message
+            time[ii] = round(
+                (dtm.datetime.now()-t0i).total_seconds(),
+                ndigits=3,
             )
-            raise Exception(msg)
-
-        # ---------------
-        # d1d and dradius
+            sol_x[ii, indx[ii, :]] = res.x
 
-        lsig = [k for k in out0[ids].keys() if '1d' in k]
-        out_ = multi.get_data(
-            dsig={ids: lsig},
-            indt=indt,
-            nan=nan,
-            pos=pos,
-            stack=stack,
-            isclose=isclose,
-            empty=empty,
-            strict=strict,
-            return_all=False,
-            warn=False,
-        )[ids]
-
-        if len(out_) > 0:
-
-            # Identify radius base
-            drad = {}
-            for k0, v0 in out_.items():
-                c0 = (
-                    isinstance(v0['data'], np.ndarray)
-                    and np.all(np.isfinite(v0['data']))
-                    and v0['data'].ndim in [1, 2]
-                )
-                if c0:
-                    if v0['data'].ndim == 1:
-                        diff = v0['data'][1] - v0['data'][0]
-                        if np.all(np.diff(v0['data'])*diff > 0):
-                            drad[k0] = v0['data']
-                    else:
-                        if np.allclose(v0['data'][0:1, :], v0['data']):
-                            diff = v0['data'][0, 1] - v0['data'][0, 0]
-                            if np.all(np.diff(v0['data'][0, :])*diff > 0):
-                                drad[k0] = v0['data'][0, :]
-                        elif np.allclose(v0['data'][:, 0:1], v0['data']):
-                            diff = v0['data'][1, 0] - v0['data'][0, 0]
-                            if np.all(np.diff(v0['data'][:, 0])*diff > 0):
-                                drad[k0] = v0['data'][:, 0]
-
-            if len(drad) == 0:
-                msg = (
-                    "No valid radial base could be identified!\n"
-                    "A valid radial base should be a 1d monotonous array"
+            # detect saturated values
+            # amp at 0 are ok
+            saturated[ii, indx[ii, :]] = (
+                res.x > bounds[1, indx[ii, :]] - deltab*1e-4
+            )
+            saturated[ii, indx[ii, :] & indamp] |= (
+                res.x[indamp[indx[ii, :]]] < 0.
+            )
+            saturated[ii, indx[ii, :] & (~indamp)] |= (
+                res.x[(~indamp)[indx[ii, :]]]
+                < (
+                    bounds[0, indx[ii, :] & (~indamp)]
+                    + 1.e-4 * deltab[(~indamp)[indx[ii, :]]]
                 )
-                raise Exception(msg)
+            )
 
-            elif len(drad) == 1:
-                k0ref = list(drad.keys())[0]
-            else:
-                if not np.unique([v0.size for v0 in drad.values()]).size == 1:
-                    lstr = [f"\t- {k0}: {v0.size}" for k0, v0 in drad.items()]
-                    msg = (
-                        "Several possible radial bases identified:\n"
-                        + "\n".join(lstr)
-                    )
-                    raise Exception(msg)
-
-                if radius_base is not None and radius_base in drad.keys():
-                    k0ref = radius_base
-                else:
-                    k0ref = list(drad.keys())[0]
-
-            nr = drad[k0ref].size
-            kref = f'{idsshort}.nr'
-
-            # add ref and data for radial base
-            plasma.add_ref(key=kref, size=nr)
-
-            # Get dim / quant from dshort / dcomp + units
-            if k0ref in multi._dshort[ids].keys():
-                dim = multi._dshort[ids][k0ref].get('dim', 'unknown')
-                quant = multi._dshort[ids][k0ref].get('quant', 'unknown')
+        except Exception as err:
+            if strict:
+                raise err
             else:
-                dim = multi._dcomp[ids][k0ref].get('dim', 'unknown')
-                quant = multi._dcomp[ids][k0ref].get('quant', 'unknown')
+                errmsg[ii] = str(err)
+                validity[ii] = -2
 
-            radius2d = [
-                k0 for k0, v0 in plasma.ddata.items()
-                if '2d' in k0
-                and v0['dim'] == dim
-                and v0['quant'] == quant
-                and v0['bsplines'] is not None
-            ]
-            if len(radius2d) == 1:
-                radius2d = radius2d[0]
-            elif len(radius2d) == 0:
-                msg = (
-                    "No 2d radius for polar mesh!\n"
-                )
-                raise Exception(msg)
+        # verbose
+        if verbose in [1, 2]:
+            if validity[ii] == 0:
+                col = np.char.array([
+                    '{} / {}'.format(ii+1, nspect),
+                    '{}'.format(dti),
+                    '{:5.3e}'.format(res.cost),
+                    str(res.nfev),
+                    str(res.njev),
+                    res.message,
+                ])
             else:
-                msg = (
-                    "Several possible 2d radius identified!\n"
-                    + str(radius2d)
-                )
-                raise Exception(msg)
-
-            kmrad = f'{idsshort}.radial'
-            plasma.add_mesh_polar(
-                key=kmrad,
-                radius=drad[k0ref],
-                radius2d=radius2d,
-                radius_dim=dim,
-                radius_quant=quant,
-                radius_units=out_[k0ref]['units'],
-                deg=1,
-            )
-
-            # Add other radial data
-            for ss in out_.keys():
-
-                # safeguard
-                shape = out_[ss]['data'].shape
-                if out_[ss]['data'].ndim not in [1, 2]:
-                    msg = (
-                        f"Non-conform {ids}.{ss}.ndim\n"
-                        "\t- expected: 1 or 2\n"
-                        f"\t- {ids}.{ss}.shape = {shape}"
-                    )
-                    raise Exception(msg)
-
-                # nr and nt
-                if len(shape) == 1:
-                    assert shape[0] == nr, shape
-
-                elif len(shape) == 2:
-                    if nt is None:
-                        msg = (
-                            f"{ids}.t could not be retrieved\n"
-                            "=> Assuming 't' is the first dimension of "
-                            "{ids}.{ss}"
-                        )
-                        warnings.warn(msg)
-
-                        nt = shape[0]
-                        keynt = f"{ids}.nt"
-
-                        # add ref
-                        plasma.add_ref(key=keynt, size=nt)
-
-                    elif nt not in shape or nr not in shape:
-                        msg = (
-                            "Inconsistent shape with respect to 't' and nr!\n"
-                            f"\t- {ids}.{ss}.shape = {shape}"
-                            f"\t- One dim should be nt = {nt}"
-                            f"\t- One dim should be nr = {nr}"
-                        )
-                        raise Exception(msg)
+                col = np.char.array([
+                    '{} / {}'.format(ii+1, nspect),
+                    '{}'.format(dti),
+                    ' - ', ' - ', ' - ',
+                    errmsg[ii],
+                ])
+            msg = ' '.join([cc.ljust(maxl) for cc in col])
+            if verbose == 1:
+                if ii == nspect - 1:
+                    end = '\n'
+                print(msg, end=end, flush=True)
+            else:
+                print(msg, end='\n')
 
-                    # Make sure shape is (nt, nr)
-                    axist = shape.index(nt)
-                    if axist == 1:
-                        out_[ss]['data'] = out_[ss]['data'].T
-
-                    if out_[ss]['data'].shape != (nt, nr):
-                        msg = (
-                            f"Wrong shape for {ids}.{ss}:\n"
-                            f"\t- expected: {(nt, nr)}\n"
-                            f"\t- got:  {out_[ss]['data'].shape}"
+    # ---------------
+    # Display saturated values
+    dsat = None
+    if np.any(saturated):
+        lksat = [
+            'bck_amp', 'bck_rate',
+            'amp', 'width', 'shift',
+            'dshift', 'dratio',
+        ]
+        dsat = {
+            k0: {
+                'ind': np.sum(saturated[:, dind[k0]['x']], axis=1),
+            }
+            for k0 in lksat
+            if dind.get(k0) is not None
+            and np.any(saturated[:, dind[k0]['x']])
+        }
+
+        for k0 in dsat.keys():
+            if k0 in ['amp', 'width', 'shift']:
+                dsat[k0]['str'] = {}
+                for ik, k1 in enumerate(dinput[k0]['keys']):
+                    indk1 = dsat[k0]['ind'][:, ik] > 0
+                    if np.any(indk1):
+                        dsat[k0]['str'][k1] = (
+                            indk1.sum(),
+                            np.mean(dsat[k0]['ind'][indk1, ik]),
                         )
-                        raise Exception(msg)
+            else:
+                indk1 = dsat[k0]['ind'][:, 0] > 0
+                if np.any(indk1):
+                    dsat[k0]['str'] = {
+                        '': (indk1.sum(), np.mean(dsat[k0]['ind'][indk1, 0])),
+                    }
+
+        lstr = [
+            "\n".join([
+                f"\t{k0} {k1}: {v1[0]} / {nspect} "
+                f"(mean {v1[1]} / {dinput['nbs']} bsplines)"
+                for k1, v1 in v0['str'].items()
+            ])
+            for k0, v0 in dsat.items()
+        ]
+        msg = (
+            "The following variables seem to have saturated:\n"
+            + "\n".join(lstr)
+        )
+        print(msg)
 
-                # Get dim / quant from dshort / dcomp + units
-                if ss in multi._dshort[ids].keys():
-                    dim = multi._dshort[ids][ss].get('dim', 'unknown')
-                    quant = multi._dshort[ids][ss].get('quant', 'unknown')
-                else:
-                    dim = multi._dcomp[ids][ss].get('dim', 'unknown')
-                    quant = multi._dcomp[ids][ss].get('quant', 'unknown')
-
-                # add data
-                plasma.add_data(
-                    key=f'{idsshort}.{ss}',
-                    data=out_[ss]['data'],
-                    ref=kmrad if len(shape) == 1 else (keynt, kmrad),
-                    dim=dim,
-                    quant=quant,
-                    units=out_[ss]['units'],
-                    source=ids,
+    # ---------------------------
+    # Isolate dratio and dshift
+    dratio, dshift = None, None
+    if dinput['double'] is not False:
+        if dinput['double'] is True:
+            dratio = (
+                sol_x[:, dind['dratio']['x']] * scales[:, dind['dratio']['x']]
+            )
+            dshift = (
+                sol_x[:, dind['dshift']['x']] * scales[:, dind['dshift']['x']]
+            )
+        else:
+            if dinput['double'].get('dratio') is None:
+                dratio = (
+                    sol_x[:, dind['dratio']['x']]
+                    * scales[:, dind['dratio']['x']]
                 )
+            else:
+                dratio = np.full((nspect,), dinput['double']['dratio'])
 
-    # t0
-    if indt0 is None:
-        indt0 = 0
-    t0 = multi._get_t0(t0, ind=indt0)
-    if t0 is not False:
-        lt = [
-            k0 for k0, v0 in plasma.ddata.items()
-            if v0['dim'] == 'time'
-        ]
-        for tt in lt:
-            plasma.ddata[lt]['data'] -= t0
-
-    return plasma
+            if dinput['double'].get('dshift') is None:
+                dshift = (
+                    sol_x[:, dind['dshift']['x']]
+                    * scales[:, dind['dshift']['x']]
+                )
+            else:
+                dshift = np.full((nspect,), dinput['double']['dshift'])
 
+    if verbose > 0:
+        dt = (dtm.datetime.now() - t0).total_seconds()
+        msg = (
+            "Total computation time:"
+            + "\t{} s for {} spectra ({} s per spectrum)".format(
+                round(dt, ndigits=3),
+                nspect,
+                round(dt/nspect, ndigits=3)
+            )
+        )
+        print(msg)
 
-def add_profile2d(
-    multi=None,
-    ids=None,
-    idsshort=None,
-    plasma=None,
-    out_=None,
-    ss=None,
-    # for references
-    keynt=None,
-    keym=None,
-    # mesh
-    meshtype=None,
-    n1=None,
-    n2=None,
-    nt=None,
+    # ---------------------------
+    # Format output as dict
+    dfit = {
+        'dinput': dinput,
+        'scales': scales, 'x0': x0, 'bounds': bounds,
+        'jac': jac, 'sol_x': sol_x,
+        'dratio': dratio, 'dshift': dshift,
+        'indx': indx,
+        'time': time, 'success': success,
+        'validity': validity,
+        'dvalidity': _DVALIDITY,
+        'errmsg': np.array(errmsg),
+        'cost': cost, 'nfev': nfev, 'msg': np.array(message),
+        'phi': phi,
+        'const': const,
+        'dsat': dsat,
+        'xtol': xtol, 'ftol': ftol, 'gtol': gtol,
+    }
+    return dfit
+
+
+###########################################################
+###########################################################
+#
+#   Main fit functions
+#
+###########################################################
+###########################################################
+
+
+def fit1d(
+    dinput=None,
+    method=None, tr_solver=None, tr_options=None,
+    xtol=None, ftol=None, gtol=None,
+    max_nfev=None, loss=None, chain=None,
+    jac=None, verbose=None, strict=None,
+    # saving
+    save=None,
+    name=None,
+    path=None,
+    # extract for plotting
+    amp=None, ratio=None,
+    Ti=None, width=None,
+    vi=None, shift=None,
+    sol_total=None, sol_detail=None, sol_lamb=None,
+    # plotting
+    plot=None,
+    showonly=None,
+    fs=None, wintit=None, tit=None, dmargin=None,
+    return_dax=None,
 ):
-    """ Add profile2d data to existing plasma2D instance (mesh already in) """
 
-    # -----------------
-    # Check data dimension
-
-    shape = out_[ss]['data'].shape
-    if out_[ss]['data'].ndim not in [1, 2, 3]:
-        msg = (
-            f"Non-conform {ids}.{ss}.ndim\n"
-            "\t- expected: 1, 2 or 3\n"
-            f"\t- {ids}.{ss}.shape = {shape}"
-        )
+    # ----------------------
+    # Check / format
+    if showonly is None:
+        showonly = False
+    if save is None:
+        save = False
+    if plot is None:
+        plot = False
+    if return_dax is None:
+        return_dax = False
+
+    # ----------------------
+    # Get dinput for 1d fitting from dlines, dconstraints, dprepare...
+    if not isinstance(dinput, dict):
+        msg = ("Please provide a properly formatted dict of inputs!\n"
+               + "fit1d() needs the problem to be given as a dinput dict\n"
+               + "  => Use dinput = fit1d_dinput()")
         raise Exception(msg)
 
-    # -----------------
-    # check per shape
+    # ----------------------
+    # Perform 2d fitting
+    if showonly is True:
+        msg = "TBF: lambfit and spect1d not defined"
+        raise Exception(msg)
 
-    shape = out_[ss]['data'].shape
+        dfit1d = {
+            'shift': np.zeros((1, dinput['nlines'])),
+            'coefs': np.zeros((1, dinput['nlines'])),
+            'lamb': lambfit,
+            'data': spect1d,
+            'double': False,
+            'Ti': False,
+            'vi': False,
+            'ratio': None,
+        }
+    else:
+        dfit1d = multigausfit1d_from_dlines(
+            dinput=dinput,
+            method=method,
+            max_nfev=max_nfev,
+            tr_solver=tr_solver,
+            tr_options=tr_options,
+            xtol=xtol,
+            ftol=ftol,
+            gtol=gtol,
+            loss=loss,
+            chain=chain,
+            verbose=verbose,
+            jac=jac,
+            strict=strict,
+        )
 
-    if len(shape) == 1:
-        # time-independent triangular mesh profile
-        if meshtype != 'tri':
-            msg = "1d profile2d should refer to a triangular mesh!"
-            raise Exception(msg)
+    # ----------------------
+    # Optional saving
+    if save is True:
+        if name is None:
+            name = 'custom'
+        name = 'TFS_fit1d_doutput_{}_{}_tol{}.npz'.format(
+            name, dinput['method'], dinput['xtol'],
+        )
+        if not name.endswith('.npz'):
+            name = name + '.npz'
+        if path is None:
+            path = os.getcwd()
+        pfe = os.path.join(os.path.abspath(path), name)
+        np.savez(pfe, **dfit1d)
+        print(f"Saved in:\n\t{pfe}")
+
+    # ----------------------
+    # Optional plotting
+    if plot is True:
+        dout = fit1d_extract(
+            dfit1d,
+            amp=amp, ratio=ratio,
+            Ti=Ti, width=width,
+            vi=vi, shift=shift,
+            sol_total=sol_total,
+            sol_detail=sol_detail,
+            sol_lamb=sol_lamb,
+        )
+        # TBF
+        dax = _plot.plot_fit1d(
+            dfit1d=dfit1d, dout=dout, showonly=showonly,
+            fs=fs, dmargin=dmargin,
+            tit=tit, wintit=wintit,
+        )
 
-        if shape[0] == n1:
-            deg = 1
-        elif shape[0] == n2:
-            deg = 0
-        else:
-            msg = (
-                "Wrong size of data, no matching deg!"
-            )
-            raise Exception(msg)
-        ref = keym
+    # ----------------------
+    # return
+    if return_dax is True:
+        return dfit1d, dax
+    else:
+        return dfit1d
 
-    elif len(shape) == 2:
-        # time-dependent triangular mesh or time-independent rectangular mesh
 
-        # check shape compatibility
-        if meshtype == 'tri':
-            compat_shapes = [(nt, n1), (nt, n2)]
-        else:
-            compat_shapes = [(n1, n2)]
-        compat_shapesT = [(sh[1], sh[0]) for sh in compat_shapes]
+def fit2d(
+    dinput=None,
+    method=None, tr_solver=None, tr_options=None,
+    xtol=None, ftol=None, gtol=None,
+    max_nfev=None, loss=None, chain=None,
+    jac=None,
+    verbose=None, strict=None,
+    # saving
+    save=None,
+    name=None,
+    path=None,
+    # extract for plotting
+    amp=None, ratio=None,
+    Ti=None, width=None,
+    vi=None, shift=None,
+    sol_total=None, sol_detail=None, sol_lamb_phi=None,
+    # plotting
+    plot=None,
+    showonly=None,
+    fs=None, wintit=None, tit=None, dmargin=None,
+    return_dax=None,
+):
 
-        if not shape in compat_shapes + compat_shapesT:
-            msg = (
-                f"Data {ss} has incompatible shape for mesh\n"
-                f"\t- Data shape: {shape}\n"
-                f"\t- nt: {nt}\n"
-                f"\t- n1, n2: {n1}, {n2}"
-            )
-            raise Exception(msg)
+    # ----------------------
+    # Check / format
+    if showonly is None:
+        showonly = False
+    if save is None:
+        save = False
+    if plot is None:
+        plot = False
+    if return_dax is None:
+        return_dax = False
+
+    # ----------------------
+    # Get dinput for 1d fitting from dlines, dconstraints, dprepare...
+    if not isinstance(dinput, dict):
+        msg = ("Please provide a properly formatted dict of inputs!\n"
+               + "fit2d() needs the problem to be given as a dinput dict\n"
+               + "  => Use dinput = fit2d_dinput()")
+        raise Exception(msg)
 
-        # Make sure time is the first dimension
-        if shape not in compat_shapes:
-            out_[ss]['data'] = out_[ss]['data'].T
-            shape = out_[ss]['data'].shape
-
-        # choose degree
-        if meshtype == 'tri':
-            if shape == (nt, n1):
-                deg = 1
-            else:
-                deg = 0
-            ref = (keynt, keym)
-        else:
-            deg = 0
-            ref = keym
+    # ----------------------
+    # Perform 2d fitting
+    if showonly is True:
+        msg = "TBF: lambfit and spect1d not defined"
+        raise Exception(msg)
 
+        dfit2d = {
+            'shift': np.zeros((1, dinput['nlines'])),
+            'coefs': np.zeros((1, dinput['nlines'])),
+            'lamb': None,
+            'phi': None,
+            'data': spect1d,
+            'double': False,
+            'Ti': False,
+            'vi': False,
+            'ratio': None,
+        }
     else:
+        dfit2d = multigausfit2d_from_dlines(
+            dinput=dinput,
+            method=method,
+            tr_solver=tr_solver,
+            tr_options=tr_options,
+            xtol=xtol,
+            ftol=ftol,
+            gtol=gtol,
+            max_nfev=max_nfev,
+            chain=chain,
+            verbose=verbose,
+            loss=loss,
+            jac=jac,
+            strict=strict,
+        )
 
-        # check shape
-        c0 = (
-            meshtype == 'rect'
-            and sorted(shape) == sorted((nt, n1, n2))
+    # ----------------------
+    # Optional saving
+    if save is True:
+        if name is None:
+            name = 'custom'
+        name = 'TFS_fit2d_doutput_{}_nbs{}_{}_tol{}.npz'.format(
+            name, dinput['nbs'], dinput['method'], dinput['xtol'],
+        )
+        if not name.endswith('.npz'):
+            name = name + '.npz'
+        if path is None:
+            path = os.getcwd()
+        pfe = os.path.join(os.path.abspath(path), name)
+        np.savez(pfe, **dfit2d)
+        print(f"Saved in:\n\t{pfe}")
+
+    # ----------------------
+    # Optional plotting
+    if plot is True:
+        dout = fit2d_extract(
+            dfit2d,
+            amp=amp, ratio=ratio,
+            Ti=Ti, width=width,
+            vi=vi, shift=shift,
+            sol_total=sol_total,
+            sol_detail=sol_detail,
+            sol_lamb_phi=sol_lamb_phi,
+        )
+        # TBF
+        dax = _plot.plot_fit2d(
+            dfit2d=dfit2d, dout=dout, showonly=showonly,
+            fs=fs, dmargin=dmargin,
+            tit=tit, wintit=wintit,
         )
-        if not c0:
-            msg = ("Data should be time-varying rect mesh!")
-            raise Exception(msg)
 
-        # re-order shape if necessary
-        if shape == (nt, n1, n2):
-            pass
-        elif shape == (nt, n2, n1):
-            out_[ss]['data'] = np.swapaxes(out_[ss]['data'], 1, 2)
-        elif shape == (n1, n2, nt):
-            out_[ss]['data'] = out_[ss]['data']
-        elif shape == (n2, n1, nt):
-            out_[ss]['data'] = out_[ss]['data'].T
-        else:
-            import pdb; pdb.set_trace()     # DB
-            pass
-        ref = (keynt, keym)
+    # ----------------------
+    # return
+    if return_dax is True:
+        return dfit2d, dax
+    else:
+        return dfit2d
+
 
+###########################################################
+###########################################################
+#
+#   Plot fitted data from pre-computed dict of fitted results
+#
+###########################################################
+###########################################################
+
+def fit2d_plot(dout=None):
+
+    # ----------------------
+    # Optional plotting
+    if plot is True:
+        if plotmode is None:
+            plotmode = 'transform'
+        if indspect is None:
+            indspect = 0
+
+        if spect1d is not None:
+            # Compute lambfit / phifit and spectrum1d
+            if nlambfit is None:
+                nlambfit = 200
+            ((spect1d, fit1d), lambfit,
+             phifit, _, phiminmax) = self._calc_spect1d_from_data2d(
+                 [dataflat[indspect, :], dfit2d['sol_tot'][indspect, :]],
+                 lambflat, phiflat,
+                 nlambfit=nlambfit, nphifit=10,
+                 spect1d=spect1d, mask=None, vertsum1d=False)
+        else:
+            fit1d, lambfit, phiminmax = None, None, None
 
-    # get parameters
-    if ss in multi._dshort[ids].keys():
-        dim = multi._dshort[ids][ss].get('dim', 'unknown')
-        quant = multi._dshort[ids][ss].get('quant', 'unknown')
+        dax = _plot_optics.CrystalBragg_plot_data_fit2d(
+            xi=xi, xj=xj, data=dfit2d['data'],
+            lamb=dfit2d['lamb'], phi=dfit2d['phi'], indspect=indspect,
+            indok=indok, dfit2d=dfit2d,
+            dax=dax, plotmode=plotmode, angunits=angunits,
+            cmap=cmap, vmin=vmin, vmax=vmax,
+            spect1d=spect1d, fit1d=fit1d,
+            lambfit=lambfit, phiminmax=phiminmax,
+            dmargin=dmargin, tit=tit, wintit=wintit, fs=fs)
+    return dax
+
+
+###########################################################
+###########################################################
+#
+#           1d vertical fitting for noise analysis
+#
+###########################################################
+###########################################################
+
+
+def get_noise_costjac(deg=None, nbsplines=None, dbsplines=None, phi=None,
+                      phiminmax=None, symmetryaxis=None, sparse=None):
+
+    if sparse is None:
+        sparse = False
+
+    if dbsplines is None:
+        dbsplines = multigausfit2d_from_dlines_dbsplines(
+            knots=None, deg=deg, nbsplines=nbsplines,
+            phimin=phiminmax[0], phimax=phiminmax[1],
+            symmetryaxis=symmetryaxis)
+
+    def cost(x,
+             km=dbsplines['knots_mult'],
+             deg=dbsplines['deg'],
+             data=0., phi=phi):
+        return scpinterp.BSpline(km, x, deg,
+                                 extrapolate=False, axis=0)(phi) - data
+
+    jac = np.zeros((phi.size, dbsplines['nbs']), dtype=float)
+    km = dbsplines['knots_mult']
+    kpb = dbsplines['nknotsperbs']
+    lind = [(phi >= km[ii]) & (phi < km[ii+kpb-1])
+            for ii in range(dbsplines['nbs'])]
+    if sparse is True:
+        def jac_func(x, jac=jac, km=km, data=None,
+                     phi=phi, kpb=kpb, lind=lind):
+            for ii in range(x.size):
+                jac[lind[ii], ii] = scpinterp.BSpline.basis_element(
+                    km[ii:ii+kpb], extrapolate=False)(phi[lind[ii]])
+            return scpsparse.csr_matrix(jac)
     else:
-        dim = multi._dcomp[ids][ss].get('dim', 'unknown')
-        quant = multi._dcomp[ids][ss].get('quant', 'unknown')
-    units = out_[ss]['units']
-    key = f'{ids}.{ss}'
-
-    # add / check bsplines
-    if plasma.dobj.get('bsplines') is None:
-        plasma.add_bsplines(deg=deg)
-    elif list(plasma.dobj['bsplines'].values())[0]['deg'] != deg:
-        degref = list(plasma.dobj['bsplines'].values())[0]['deg']
-        msg = "Degree not matching!\n\t{deg} vs {degref}"
-        raise Exception(msg)
+        def jac_func(x, jac=jac, km=km, data=None,
+                     phi=phi, kpb=kpb, lind=lind):
+            for ii in range(x.size):
+                jac[lind[ii], ii] = scpinterp.BSpline.basis_element(
+                    km[ii:ii+kpb], extrapolate=False)(phi[lind[ii]])
+            return jac
+    return cost, jac_func
 
-    # add data
-    plasma.add_data(
-        key=f'{idsshort}.{ss}',
-        data=out_[ss]['data'],
-        name=ss,
-        dim=dim,
-        quant=quant,
-        units=units,
-        source=ids,
-        ref=ref,
-    )
 
+def _basic_loop(ilambu=None, ilamb=None, phi=None, data=None, mask=None,
+                domain=None, nbs=None, dbsplines=None, nspect=None,
+                method=None, tr_solver=None, tr_options=None, loss=None,
+                xtol=None, ftol=None, gtol=None, max_nfev=None, verbose=None):
 
-# def plasma_plot_args(plot, plot_X, plot_sig,
-                     # dsig=None):
-    # # Set plot
-    # if plot is None:
-        # plot = not (plot_sig is None and plot_X is None)
-
-    # if plot is True:
-        # # set plot_sig
-        # if plot_sig is None:
-            # lsplot = [ss for ss in list(dsig.values())[0]
-                      # if ('1d' in ss and ss != 't'
-                          # and all([sub not in ss
-                                   # for sub in ['rho', 'psi', 'phi']]))]
-            # if not (len(dsig) == 1 and len(lsplot) == 1):
-                # msg = ("Direct plotting only possible if\n"
-                       # + "sig_plot is provided, or can be derived from:\n"
-                       # + "\t- unique ids: {}\n\t".format(dsig.keys())
-                       # + "- unique non-(t, radius) 1d sig: {}".format(lsplot))
-                # raise Exception(msg)
-            # plot_sig = lsplot
-        # if type(plot_sig) is str:
-            # plot_sig = [plot_sig]
-
-        # # set plot_X
-        # if plot_X is None:
-            # lsplot = [ss for ss in list(dsig.values())[0]
-                      # if ('1d' in ss and ss != 't'
-                          # and any([sub in ss
-                                   # for sub in ['rho', 'psi', 'phi']]))]
-            # if not (len(dsig) == 1 and len(lsplot) == 1):
-                # msg = ("Direct plotting only possible if\n"
-                       # + "X_plot is provided, or can be derived from:\n"
-                       # + "\t- unique ids: {}\n".format(dsig.keys())
-                       # + "\t- unique non-t, 1d radius: {}".format(lsplot))
-                # raise Exception(msg)
-            # plot_X = lsplot
-        # if type(plot_X) is str:
-            # plot_X = [plot_X]
-    # return plot, plot_X, plot_sig
-
-
-# #############################################################################
-#                       Cam
-# #############################################################################
-
-
-def cam_checkformat_geom(ids=None, geomcls=None, indch=None,
-                         lidsdiag=None, dids=None, didsdiag=None):
-
-    # Check ids
-    idsok = set(lidsdiag).intersection(dids.keys())
-    if ids is None and len(idsok) == 1:
-        ids = next(iter(idsok))
-
-    if ids not in dids.keys():
-        msg = ("Provided ids should be available as a self.dids.keys()!\n"
-               + "\t- provided: {}\n".format(str(ids))
-               + "\t- available: {}".format(sorted(dids.keys())))
-        raise Exception(msg)
+    # ---------------
+    # Check inputs
+    if method is None:
+        method = _METHOD
+    assert method in ['trf', 'dogbox', 'lm'], method
+    if tr_solver is None:
+        tr_solver = None
+    if tr_options is None:
+        tr_options = {}
+    if xtol is None:
+        xtol = _TOL2D['x']
+    if ftol is None:
+        ftol = _TOL2D['f']
+    if gtol is None:
+        gtol = _TOL2D['g']
+    if loss is None:
+        loss = _LOSS
+    if max_nfev is None:
+        max_nfev = None
+
+    x0 = 1. - (2.*np.arange(nbs)/nbs - 1.)**2
+
+    # ---------------
+    # Prepare outputs
+    dataint = np.full((nspect, ilambu.size), np.nan)
+    fit = np.full(data.shape, np.nan)
+    indsort = np.zeros((2, phi.size), dtype=int)
+    indout_noeval = np.zeros(phi.shape, dtype=bool)
+    chi2n = np.full((nspect, ilambu.size), np.nan)
+    chi2_meandata = np.full((nspect, ilambu.size), np.nan)
+
+    # ---------------
+    # Main loop
+    i0, indnan = 0, []
+    for jj in range(ilambu.size):
+        ind = ilamb == ilambu[jj]
+        nind = ind.sum()
+        isort = i0 + np.arange(0, nind)
 
-    if ids not in lidsdiag:
-        msg = ("Requested ids is not pre-tabulated !\n"
-               + "  => Be careful with args (geomcls, indch)")
-        warnings.warn(msg)
-    else:
-        if geomcls is None:
-            geomcls = didsdiag[ids]['geomcls']
+        # skips cases with no points
+        if not np.any(ind):
+            continue
 
-    # Check data and geom
-    import tofu.geom as tfg
+        inds = np.argsort(phi[ind])
+        inds_rev = np.argsort(inds)
+        indsort[0, isort] = ind.nonzero()[0][inds]
+        indsort[1, isort] = ind.nonzero()[1][inds]
+
+        phisort = phi[indsort[0, isort], indsort[1, isort]]
+        datasort = data[:, indsort[0, isort], indsort[1, isort]]
+        dataint[:, jj] = np.nanmean(datasort, axis=1)
+
+        # skips cases with to few points
+        indok = ~np.any(np.isnan(datasort), axis=0)
+        if mask is not None:
+            indok &= mask[indsort[0, isort], indsort[1, isort]]
+
+        # Check there are enough phi vs bsplines
+        indphimin = np.searchsorted(np.linspace(domain['phi']['minmax'][0],
+                                                domain['phi']['minmax'][1],
+                                                nbs + 1),
+                                    phisort[indok])
+        if np.unique(indphimin).size < nbs:
+            indout_noeval[ind] = True
+            continue
+        indout_noeval[ind] = ~indok[inds_rev]
 
-    lgeom = [kk for kk in dir(tfg) if 'Cam' in kk]
-    if geomcls not in [False] + lgeom:
-        msg = "Arg geomcls must be in {}".format([False]+lgeom)
-        raise Exception(msg)
+        # get bsplines func
+        func_cost, func_jac = get_noise_costjac(phi=phisort[indok],
+                                                dbsplines=dbsplines,
+                                                sparse=False,
+                                                symmetryaxis=False)
+        for tt in range(nspect):
+            if verbose > 0:
+                msg = ("\tlambbin {} / {}".format(jj+1, ilambu.size)
+                       + "    "
+                       + "time step = {} / {}".format(tt+1, nspect))
+                print(msg.ljust(50), end='\r', flush=True)
+
+            if dataint[tt, jj] == 0.:
+                continue
+
+            datai = datasort[tt, indok] / dataint[tt, jj]
+            res = scpopt.least_squares(
+                func_cost, x0, jac=func_jac,
+                method=method, ftol=ftol, xtol=xtol, gtol=gtol,
+                x_scale='jac', f_scale=1.0, loss=loss, diff_step=None,
+                tr_solver=tr_solver, tr_options={}, jac_sparsity=None,
+                max_nfev=max_nfev, verbose=0, args=(),
+                kwargs={'data': datai})
+
+            # Store in original shape
+            fit[tt, ind] = (
+                func_cost(res.x, phi=phisort, data=0.)
+                * dataint[tt, jj]
+            )[inds_rev]
+            chi2_meandata[tt, jj] = np.nanmean(fit[tt, ind])
+            chi2n[tt, jj] = np.nanmean(func_cost(x=res.x, data=datai)**2)
+
+        i0 += nind
+        indnan.append(i0)
+    return (fit, dataint, indsort, np.array(indnan), indout_noeval,
+            chi2n, chi2_meandata)
+
+
+def noise_analysis_2d(
+    data, lamb, phi, mask=None, margin=None, valid_fraction=None,
+    deg=None, knots=None, nbsplines=None, nxerrbin=None,
+    nlamb=None, loss=None, max_nfev=None,
+    xtol=None, ftol=None, gtol=None,
+    method=None, tr_solver=None, tr_options=None,
+    verbose=None, plot=None,
+    ms=None, dcolor=None,
+    dax=None, fs=None, dmargin=None,
+    wintit=None, tit=None, sublab=None,
+    save_fig=None, name_fig=None, path_fig=None, fmt=None,
+    return_dax=None,
+):
 
-    if geomcls is False:
-        msg = "ids {} does not seem to be a ids with a camera".format(ids)
+    # -------------
+    # Check inputs
+    if not isinstance(nbsplines, int):
+        msg = "Please provide a (>0) integer value for nbsplines"
         raise Exception(msg)
 
-    return geomcls
+    if deg is None:
+        deg = 2
+    if plot is None:
+        plot = True
+    if verbose is None:
+        verbose = 1
+    if return_dax is None:
+        return_dax = False
 
+    c0 = lamb.shape == phi.shape == data.shape[1:]
+    if c0 is not True:
+        msg = (
+            "input data, lamb, phi are non-conform!\n"
+            + "\t- expected lamb.shape == phi.shape == data.shape[1:]\n"
+            + "\t- provided:\n"
+            + "\t\tlamb.shape = {}\n".format(lamb.shape)
+            + "\t\tphi.shape = {}\n".format(phi.shape)
+            + "\t\tdata.shape = {}\n".format(data.shape)
+        )
+        raise Exception(msg)
 
-def cam_compare_indch_indchr(indch, indchr, nch, indch_auto=None):
-    if indch_auto is None:
-        indch_auto = True
-    if indch is None:
-        indch = np.arange(0, nch)
-    if not np.all(np.in1d(indch, indchr)):
-        msg = ("indch has to be changed, some data may be missing\n"
-               + "\t- indch: {}\n".format(indch)
-               + "\t- indch recommended: {}".format(indchr)
-               + "\n\n  => check self.inspect_channels() for details")
-        if indch_auto is True:
-            indch = indchr
-            warnings.warn(msg)
+    nspect = data.shape[0]
+    domain = {'lamb': {'minmax': [np.nanmin(lamb), np.nanmax(lamb)]},
+              'phi': {'minmax': [np.nanmin(phi), np.nanmax(phi)]}}
+
+    if nlamb is None:
+        if lamb.ndim == 2:
+            nlamb = lamb.shape[0]
         else:
+            msg = ("Please provide a value for nlamb (nb of bins)!")
             raise Exception(msg)
-    return indch
+    nlamb = int(nlamb)
 
+    # -------------
+    # lamb binning
+    lambedges = np.linspace(domain['lamb']['minmax'][0],
+                            domain['lamb']['minmax'][1], nlamb+1)
+    ilamb = np.searchsorted(lambedges, lamb)
+    ilambu = np.unique(ilamb)
+
+    # -------------
+    # bspline dict and plotting utilities
+    dbsplines = multigausfit2d_from_dlines_dbsplines(
+        knots=None, deg=deg, nbsplines=nbsplines,
+        phimin=domain['phi']['minmax'][0],
+        phimax=domain['phi']['minmax'][1],
+        symmetryaxis=False)
+
+    # plotting utils
+    bs_phi = np.linspace(domain['phi']['minmax'][0],
+                         domain['phi']['minmax'][1], 101)
+    bs_val = np.array([
+        scpinterp.BSpline.basis_element(
+            dbsplines['knots_mult'][ii:ii+dbsplines['nknotsperbs']],
+            extrapolate=False)(bs_phi)
+        for ii in range(nbsplines)]).T
+
+    # -------------
+    # Perform fits
+    (fit, dataint, indsort, indnan, indout_noeval,
+     chi2n, chi2_meandata) = _basic_loop(
+        ilambu=ilambu, ilamb=ilamb, phi=phi, data=data, mask=mask,
+        domain=domain, nbs=nbsplines, dbsplines=dbsplines, nspect=nspect,
+        method=method, tr_solver=tr_solver, tr_options=tr_options, loss=loss,
+        xtol=xtol, ftol=ftol, gtol=gtol,
+        max_nfev=max_nfev, verbose=verbose)
+
+    # -------------
+    # Identify outliers with respect to noise model
+    (mean, var, xdata, const,
+     indout_var, _, margin, valid_fraction) = get_noise_analysis_var_mask(
+         fit=fit, data=data, mask=(mask & (~indout_noeval)),
+         margin=margin, valid_fraction=valid_fraction)
+
+    # Safety check
+    if mask is None:
+        indout_mask = np.zeros(lamb.shape, dtype=bool)
+    else:
+        indout_mask = ~mask
+    indout_noeval[~mask] = False
+    indout_tot = np.array([~mask,
+                           indout_noeval,
+                           np.any(indout_var, axis=0)])
+    c0 = np.all(np.sum(indout_tot.astype(int), axis=0) <= 1)
+    if not c0:
+        msg = "Overlapping indout!"
+        raise Exception(msg)
 
-def inspect_channels_dout(ids=None, indch=None, geom=None,
-                          out=None, nch=None, dshort=None,
-                          lsig=None, lsigshape=None,
-                          compute_ind=None):
-    dout = {}
-    for k0, v0 in out.items():
-        v0 = v0['data']
-        if len(v0) != nch:
-            if len(v0) != 1:
-                import pdb          # DB
-                pdb.set_trace()     # DB
-            continue
-        if isinstance(v0[0], np.ndarray):
-            dout[k0] = {'shapes': np.array([vv.shape for vv in v0]),
-                        'isnan': np.array([np.any(np.isnan(vv))
-                                           for vv in v0])}
-            if k0 == 'los_ptsRZPhi':
-                dout[k0]['equal'] = np.array([np.allclose(vv[0, ...],
-                                                          vv[1, ...])
-                                             for vv in v0])
-        elif type(v0[0]) in [int, float, np.int, np.float, str]:
-            dout[k0] = {'value': np.asarray(v0).ravel()}
-        else:
-            typv = type(v0[0])
-            k0str = (dshort[ids][k0]['str']
-                     if k0 in dshort[ids].keys() else k0)
-            msg = ("\nUnknown data type:\n"
-                   + "\ttype({}) = {}".format(k0str, typv))
-            raise Exception(msg)
+    indin = ~np.any(indout_tot, axis=0)
 
-    lsig = sorted(set(lsig).intersection(dout.keys()))
-    lsigshape = sorted(set(lsigshape).intersection(dout.keys()))
+    # -------------
+    # output dict
+    dnoise = {
+        'data': data, 'phi': phi, 'fit': fit,
+        'chi2n': chi2n, 'chi2_meandata': chi2_meandata, 'dataint': dataint,
+        'domain': domain, 'indin': indin, 'indout_mask': indout_mask,
+        'indout_noeval': indout_noeval, 'indout_var': indout_var,
+        'mask': mask, 'ind_noeval': None,
+        'indsort': indsort, 'indnan': np.array(indnan),
+        'nbsplines': nbsplines, 'bs_phi': bs_phi, 'bs_val': bs_val,
+        'deg': deg, 'lambedges': lambedges, 'deg': deg,
+        'ilamb': ilamb, 'ilambu': ilambu,
+        'var_mean': mean, 'var': var, 'var_xdata': xdata,
+        'var_const': const, 'var_margin': margin,
+        'var_fraction': valid_fraction}
 
-    # --------------
-    # Get indchout
-    indchout = None
-    if compute_ind:
-        if geom in ['only', True] and 'los_ptsRZPhi' in out.keys():
-            indg = ((np.prod(dout['los_ptsRZPhi']['shapes'], axis=1) == 0)
-                    | dout['los_ptsRZPhi']['isnan']
-                    | dout['los_ptsRZPhi']['equal'])
-            if geom == 'only':
-                indok = ~indg
-                indchout = indok.nonzero()[0]
-        if geom != 'only':
-            shapes0 = np.concatenate([np.prod(dout[k0]['shapes'],
-                                              axis=1, keepdims=True)
-                                      for k0 in lsigshape], axis=1)
-            indok = np.all(shapes0 != 0, axis=1)
-            if geom is True and 'los_ptsRZPhi' in out.keys():
-                indok[indg] = False
-        if not np.any(indok):
-            indchout = np.array([], dtype=int)
-        elif geom != 'only':
-            indchout = (np.arange(0, nch)[indok]
-                        if indch is None else np.r_[indch][indok])
-            lshapes = [dout[k0]['shapes'][indchout, :] for k0 in lsigshape]
-            lshapesu = [np.unique(ss, axis=0) for ss in lshapes]
-            if any([ss.shape[0] > 1 for ss in lshapesu]):
-                for ii in range(len(lshapesu)):
-                    if lshapesu[ii].shape[0] > 1:
-                        _, inv, counts = np.unique(lshapes[ii], axis=0,
-                                                   return_counts=True,
-                                                   return_inverse=True)
-                        indchout = indchout[inv == np.argmax(counts)]
-                        lshapes = [dout[k0]['shapes'][indchout, :]
-                                   for k0 in lsigshape]
-                        lshapesu = [np.unique(ss, axis=0) for ss in lshapes]
-    return dout, indchout
-
-
-def cam_to_Cam_Du(out, ids=None):
-    Etendues, Surfaces, names = None, None, None
-    if 'los_ptsRZPhi' in out.keys():
-        oo = out['los_ptsRZPhi']['data']
-        D = np.array([oo[:, 0, 0]*np.cos(oo[:, 0, 2]),
-                      oo[:, 0, 0]*np.sin(oo[:, 0, 2]), oo[:, 0, 1]])
-        u = np.array([oo[:, 1, 0]*np.cos(oo[:, 1, 2]),
-                      oo[:, 1, 0]*np.sin(oo[:, 1, 2]), oo[:, 1, 1]])
-        u = (u-D) / np.sqrt(np.sum((u-D)**2, axis=0))[None, :]
-        dgeom = (D, u)
-        indnan = np.any(np.isnan(D), axis=0) | np.any(np.isnan(u), axis=0)
-        if np.any(indnan):
-            nunav, ntot = str(indnan.sum()), str(D.shape[1])
-            msg = ("Some lines of sight unavailable in {}:\n".format(ids)
-                   + "\t- unavailable LOS: {0} / {1}\n".format(nunav, ntot)
-                   + "\t- indices: {0}".format(str(indnan.nonzero()[0])))
+    # Plot
+    if plot is True:
+        try:
+            dax = _plot.plot_noise_analysis(
+                dnoise=dnoise,
+                ms=ms, dcolor=dcolor,
+                dax=dax, fs=fs, dmargin=dmargin,
+                wintit=wintit, tit=tit, sublab=sublab,
+                save=save_fig, name=name_fig, path=path_fig, fmt=fmt)
+        except Exception as err:
+            msg = ("Plotting failed: {}".format(str(err)))
             warnings.warn(msg)
+    if return_dax is True:
+        return dnoise, dax
     else:
-        dgeom = None
+        return dnoise
 
-    if 'etendue' in out.keys():
-        Etendues = out['etendue']['data']
-    if 'surface' in out.keys():
-        Surfaces = out['surface']['data']
-    if 'names' in out.keys():
-        names = out['names']['data']
-    return dgeom, Etendues, Surfaces, names
-
-
-# #############################################################################
-#                       Data
-# #############################################################################
 
+def noise_analysis_2d_scannbs(
+    data, lamb, phi, mask=None, nxerrbin=None,
+    deg=None, knots=None, nbsplines=None, lnbsplines=None,
+    nlamb=None, loss=None, max_nfev=None,
+    xtol=None, ftol=None, gtol=None,
+    method=None, tr_solver=None, tr_options=None,
+    verbose=None, plot=None,
+    dax=None, fs=None, dmargin=None,
+    wintit=None, tit=None, ms=None, sublab=None,
+    save_fig=None, name_fig=None, path_fig=None,
+    fmt=None, return_dax=None,
+):
 
-def data_checkformat_tlim(t, tlim=None,
-                          names=None, times=None, indevent=None,
-                          returnas=bool, Exp=None):
+    # -------------
     # Check inputs
-    if tlim is None:
-        tlim = _DTLIM.get(Exp, False)
-    if indevent is None:
-        indevent = _INDEVENT
-    if names is not None:
-        names = np.char.strip(names)
-    if returnas is None:
-        returnas = bool
-    if returnas not in [bool, int]:
-        msg = ("Arg returnas must be in [bool, int]\n"
-               + "\t- provided: {}".format(returnas))
-        raise Exception(msg)
-    assert returnas in [bool, int]
-    lc = [tlim is None,
-          tlim is False,
-          (isinstance(tlim, list) and len(tlim) == 2
-           and all([(type(tt) in [int, float, np.int_, np.float_]
-                     or (isinstance(tt, str)
-                         and names is not None
-                         and tt in names)
-                     or tt is None) for tt in tlim]))]
-
-    if not any(lc):
-        msg = ("tlim must be either:\n"
-               + "\t- None:  set to default (False)\n"
-               + "\t- False: no time limit\n"
-               + "\t- list:  a list of 2, lower and upper limits [t0, t1]:\n"
-               + "\t\t- [None, float]: no lower, explicit upper limit\n"
-               + "\t\t- [float, float]: explicit lower and upper limit\n"
-               + "\t\t- [float, str]: explicit lower, event name for upper\n\n"
-               + "  You provided: {}".format(tlim))
-        if any([isinstance(tt, str) for tt in tlim]):
-            msg += '\n\nAvailable events:\n' + str(names)
-        warnings.warn(msg)
-        tlim = False
-    if tlim is None:
-        tlim = False
-
-    # Compute
-    nt0 = t.size
-    indt = np.ones((nt0,), dtype=bool)
-    if tlim is not False:
-        for ii in range(len(tlim)):
-            if isinstance(tlim[ii], str):
-                ind = (names == tlim[ii]).nonzero()[0][indevent]
-                tlim[ii] = times[ind]
-        if tlim[0] is not None:
-            indt[t < tlim[0]] = False
-        if tlim[1] is not None:
-            indt[t > tlim[1]] = False
-    t = t[indt]
-    if returnas is int:
-        indt = np.nonzero(indt)[0]
-    return {'tlim': tlim, 'nt': t.size, 't': t, 'indt': indt, 'nt0': nt0}
-
-
-def data_checkformat_dsig(ids=None, dsig=None, data=None, X=None,
-                          datacls=None, geomcls=None,
-                          lidsdiag=None, dids=None, didsdiag=None,
-                          dshort=None, dcomp=None):
-
-    # Check ids
-    idsok = set(lidsdiag).intersection(dids.keys())
-    if ids is None and len(idsok) == 1:
-        ids = next(iter(idsok))
-
-    if ids not in dids.keys():
-        msg = "Provided ids should be available as a self.dids.keys() !"
+    if lnbsplines is None:
+        lnbsplines = np.arange(5, 21)
+    else:
+        lnbsplines = np.atleast_1d(lnbsplines).ravel().astype(int)
+    if nbsplines is None:
+        nbsplines = int(lnbsplines.size/2)
+    if nbsplines is not None:
+        nbsplines = np.unique(np.atleast_1d(nbsplines)).astype(int)
+    nlnbs = lnbsplines.size
+    if nxerrbin is None:
+        nxerrbin = 100
+
+    if deg is None:
+        deg = 2
+    if plot is None:
+        plot = True
+    if verbose is None:
+        verbose = 1
+    if return_dax is None:
+        return_dax = False
+
+    c0 = lamb.shape == phi.shape == data.shape[1:]
+    if c0 is not True:
+        msg = ("input data, lamb, phi are non-conform!\n"
+               + "\t- expected lamb.shape == phi.shape == data.shape[1:]\n"
+               + "\t- provided: ")
         raise Exception(msg)
 
-    if ids not in lidsdiag:
-        msg = "Requested ids is not pre-tabulated !\n"
-        msg = "  => Be careful with args (dsig, datacls, geomcls)"
-        warnings.warn(msg)
-    else:
-        if datacls is None:
-            datacls = didsdiag[ids]['datacls']
-        if geomcls is None:
-            geomcls = didsdiag[ids]['geomcls']
-        if dsig is None:
-            dsig = didsdiag[ids]['sig']
-    if data is not None:
-        if not isinstance(data, str):
-            msg = ("data was expected as a str\n"
-                   + "\t- provided: {}".format(data))
-            raise Exception(msg)
-        dsig['data'] = data
-    if X is not None:
-        if not isinstance(X, str):
-            msg = ("X was expected as a str\n"
-                   + "\t- provided: {}".format(X))
+    nspect = data.shape[0]
+    domain = {'lamb': {'minmax': [np.nanmin(lamb), np.nanmax(lamb)]},
+              'phi': {'minmax': [np.nanmin(phi), np.nanmax(phi)]}}
+
+    if nlamb is None:
+        if lamb.ndim == 2:
+            nlamb = lamb.shape[0]
+        else:
+            msg = ("Please provide a value for nlamb (nb of bins)!")
             raise Exception(msg)
-        dsig['X'] = X
+    nlamb = int(nlamb)
 
-    # Check data and geom
-    import tofu.geom as tfg
-    import tofu.data as tfd
-
-    if datacls is None:
-        datacls = 'DataCam1D'
-    ldata = [kk for kk in dir(tfd) if 'DataCam' in kk]
-    if datacls not in ldata:
-        msg = "Arg datacls must be in {}".format(ldata)
-        raise Exception(msg)
-    lgeom = [kk for kk in dir(tfg) if 'Cam' in kk]
-    if geomcls not in [False] + lgeom:
-        msg = "Arg geom must be in {}".format([False] + lgeom)
-        raise Exception(msg)
+    # -------------
+    # lamb binning
+    lambedges = np.linspace(domain['lamb']['minmax'][0],
+                            domain['lamb']['minmax'][1], nlamb+1)
+    ilamb = np.searchsorted(lambedges, lamb)
+    ilambu = np.unique(ilamb)
+
+    # -------------
+    # Perform fits
+    xdata_edge = np.linspace(0, np.nanmax(data[:, mask]), nxerrbin+1)
+    xdata = 0.5*(xdata_edge[1:] + xdata_edge[:-1])
+    dataint = np.full((nspect, ilambu.size), np.nan)
+    # fit = np.full(data.shape, np.nan)
+    indsort = np.zeros((2, phi.size), dtype=int)
+    # indout_noeval = np.zeros(phi.shape, dtype=bool)
+    chi2n = np.full((nlnbs, nspect, ilambu.size), np.nan)
+    chi2_meandata = np.full((nlnbs, nspect, ilambu.size), np.nan)
+    const = np.full((nlnbs,), np.nan)
+    mean = np.full((nlnbs, nxerrbin), np.nan)
+    var = np.full((nlnbs, nxerrbin), np.nan)
+    bs_phidata, bs_data, bs_fit, bs_indin = [], [], [], []
+    for ii in range(lnbsplines.size):
+        nbs = int(lnbsplines[ii])
+        # -------------
+        # bspline dict and plotting utilities
+        dbsplines = multigausfit2d_from_dlines_dbsplines(
+            knots=None, deg=deg, nbsplines=nbs,
+            phimin=domain['phi']['minmax'][0],
+            phimax=domain['phi']['minmax'][1],
+            symmetryaxis=False,
+        )
 
-    # Check signals
-    c0 = type(dsig) is dict
-    c0 = c0 and 'data' in dsig.keys()
-    ls = ['t', 'X', 'lamb', 'data']
-    c0 = c0 and all([ss in ls for ss in dsig.keys()])
-    if not c0:
-        msg = ("Arg dsig must be a dict with keys:\n"
-               + "\t- 'data' : shortcut to the main data to be loaded\n"
-               + "\t- 't':       (optional) shortcut to time vector\n"
-               + "\t- 'X':       (optional) shortcut to abscissa vector\n"
-               + "\t- 'lamb':    (optional) shortcut to wavelengths")
-        raise Exception(msg)
+        # -------------
+        # Perform fits
+        if verbose > 0:
+            msg = "nbs = {} ({} / {})".format(nbs, ii+1, lnbsplines.size)
+            print(msg)
+        (fiti, dataint, indsort, indnan, indout_noeval,
+         chi2n[ii, ...], chi2_meandata[ii, ...]) = _basic_loop(
+             ilambu=ilambu, ilamb=ilamb, phi=phi, data=data, mask=mask,
+             domain=domain, nbs=nbs, dbsplines=dbsplines, nspect=nspect,
+             method=method, tr_solver=tr_solver, tr_options=tr_options,
+             loss=loss, xtol=xtol, ftol=ftol, gtol=gtol,
+             max_nfev=max_nfev, verbose=verbose)
+
+        if ii == 0:
+            ind_intmax = np.unravel_index(np.argmax(dataint, axis=None),
+                                          dataint.shape)
+
+        if nbs in nbsplines:
+            isi = np.split(indsort, indnan, axis=1)[ind_intmax[1]]
+            bs_phidata.append(phi[isi[0], isi[1]])
+            bs_data.append(data[ind_intmax[0], isi[0], isi[1]])
+            bs_fit.append(fiti[ind_intmax[0], isi[0], isi[1]])
+            indini = ~np.any(np.array([~mask, indout_noeval]), axis=0)
+            bs_indin.append(indini[isi[0], isi[1]])
 
-    dout = {}
-    lok = set(dshort[ids].keys()).union(dcomp[ids].keys())
-    for k, v in dsig.items():
-        if v in lok:
-            dout[k] = v
-
-    return datacls, geomcls, dout
-
-
-# #############################################################################
-#                       signal
-# #############################################################################
-
-
-def signal_get_synth(ids, dsig=None,
-                     quant=None, ref1d=None, ref2d=None,
-                     q2dR=None, q2dPhi=None, q2dZ=None,
-                     didsdiag=None, lidsplasma=None, dshort=None, dcomp=None):
-
-    # Check quant, ref1d, ref2d
-    dq = {'quant': quant, 'ref1d': ref1d, 'ref2d': ref2d,
-          'q2dR': q2dR, 'q2dPhi': q2dPhi, 'q2dZ': q2dZ}
-    for kk, vv in dq.items():
-        lc = [vv is None, type(vv) is str, type(vv) in [list, tuple]]
-        assert any(lc)
-        if lc[0]:
-            dq[kk] = didsdiag[ids]['synth']['dsynth'].get(kk, None)
-        if type(dq[kk]) is str:
-            dq[kk] = [dq[kk]]
-        if dq[kk] is not None:
-            for ii in range(0, len(dq[kk])):
-                v1 = tuple(dq[kk][ii].split('.'))
-                assert len(v1) == 2
-                assert v1[0] in lidsplasma
-                assert (v1[1] in dshort[v1[0]].keys()
-                        or v1[1] in dcomp[v1[0]].keys())
-                dq[kk][ii] = v1
-
-    # Check dsig
-    if dsig is None:
-        dsig = didsdiag[ids]['synth']['dsig']
-
-    for k0, v0 in dsig.items():
-        if type(v0) is not list:
-            v0 = [v0]
-        c0 = k0 in lidsplasma
-        c0 = c0 and all([type(vv) is str for vv in v0])
-        if not c0:
-            msg = "Arg dsig must be a dict (ids:[shortcut1, shortcut2...])"
-            raise Exception(msg)
-        dsig[k0] = v0
+        # -------------
+        # Identify outliers with respect to noise model
+        (meani, vari, xdatai, consti,
+         _, inderrui, _, _) = get_noise_analysis_var_mask(
+             fit=fiti, data=data, xdata_edge=xdata_edge,
+             mask=(mask & (~indout_noeval)),
+             margin=None, valid_fraction=False)
+
+        const[ii] = consti
+        mean[ii, inderrui] = meani
+        var[ii, inderrui] = vari
+
+    # -------------
+    # output dict
+    dnoise_scan = {
+        'data': data,
+        'chi2n': chi2n, 'chi2_meandata': chi2_meandata, 'dataint': dataint,
+        'domain': domain, 'lnbsplines': lnbsplines, 'nbsplines': nbsplines,
+        'deg': deg, 'lambedges': lambedges, 'deg': deg,
+        'ilamb': ilamb, 'ilambu': ilambu,
+        'bs_phidata': bs_phidata, 'bs_data': bs_data,
+        'bs_fit': bs_fit, 'bs_indin': bs_indin,
+        'var_mean': mean, 'var': var, 'var_xdata': xdata,
+        'var_const': const,
+    }
 
-    # Check dsig vs quant/ref1d/ref2d consistency
-    for kk, vv in dq.items():
-        if vv is None:
-            continue
-        for ii in range(0, len(vv)):
-            if vv[ii][0] not in dsig.keys():
-                dsig[vv[ii][0]] = []
-            if vv[ii][1] not in dsig[vv[ii][0]]:
-                dsig[vv[ii][0]].append(vv[ii][1])
-            dq[kk][ii] = '{}.{}'.format(vv[ii][0], vv[ii][1])
-
-    lq = didsdiag[ids]['synth']['dsynth'].get('fargs', None)
-    if lq is not None:
-        for qq in lq:
-            q01 = qq.split('.')
-            assert len(q01) == 2
-            if q01[0] not in dsig.keys():
-                dsig[q01[0]] = [q01[1]]
-            else:
-                dsig[q01[0]].append(q01[1])
+    # Plot
+    if plot is True:
+        try:
+            dax = _plot.plot_noise_analysis_scannbs(
+                dnoise=dnoise_scan, ms=ms,
+                dax=dax, fs=fs, dmargin=dmargin,
+                wintit=wintit, tit=tit, sublab=sublab,
+                save=save_fig, name=name_fig, path=path_fig, fmt=fmt)
+        except Exception as err:
+            msg = ("Plotting failed: {}".format(str(err)))
+            warnings.warn(msg)
 
-    if dq['quant'] is None and dq['q2dR'] is None and lq is None:
-        msg = "both quant and q2dR are not specified !"
-        raise Exception(msg)
+    if return_dax is True:
+        return dnoise_scan, dax
+    else:
+        return dnoise_scan
+
+
+def get_noise_analysis_var_mask(fit=None, data=None,
+                                xdata_edge=None, nxerrbin=None,
+                                valid_fraction=None,
+                                mask=None, margin=None):
+    if margin is None:
+        margin = _SIGMA_MARGIN
+    if valid_fraction is None:
+        valid_fraction = False
+    if nxerrbin is None:
+        nxerrbin = 100
+
+    err = fit - data
+    if mask is None:
+        mask = np.ones(err.shape[1:], dtype=bool)
+    if xdata_edge is None:
+        xdata_edge = np.linspace(0, np.nanmax(fit[:, mask]), nxerrbin)
+    inderr = np.searchsorted(xdata_edge[1:-1], fit[:, mask])
+    inderru = np.unique(inderr[~np.isnan(err[:, mask])])
+    xdata = 0.5*(xdata_edge[1:] + xdata_edge[:-1])[inderru]
+    mean = np.full((inderru.size,), np.nan)
+    var = np.full((inderru.size,), np.nan)
+    nn = np.full((inderru.size,), np.nan)
+    for ii in range(inderru.size):
+        ind = inderr == inderru[ii]
+        indok = ~np.isnan(err[:, mask][ind])
+        nn[ii] = np.sum(indok)
+        mean[ii] = np.nanmean(err[:, mask][ind])
+        var[ii] = nn[ii] * np.nanmean(err[:, mask][ind]**2) / (nn[ii] - 1)
+
+    # fit sqrt on sigma (weight by log10 to take into account diff. nb. of pts)
+    const = np.nansum(
+        (np.log10(nn)*np.sqrt(var / xdata)) / np.nansum(np.log10(nn))
+    )
 
-    # Remove unused keys
-    for kk in list(dq.keys()):
-        if dq[kk] is None:
-            del dq[kk]
-    return dsig, dq, lq
+    # indout
+    indok = (~np.isnan(err)) & mask[None, ...]
+    indout = np.zeros(err.shape, dtype=bool)
+    indout[indok] = (np.abs(err[indok])
+                     > margin*const*np.sqrt(np.abs(fit[indok])))
+    if valid_fraction is not False:
+        indout = np.sum(indout, axis=0)/float(indout.shape[0]) > valid_fraction
+    return mean, var, xdata, const, indout, inderru, margin, valid_fraction
```

### Comparing `tofu-1.6.5/tofu/imas2tofu/_core.py` & `tofu-1.7.0/tofu/imas2tofu/_core.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/imas2tofu/_def.py` & `tofu-1.7.0/tofu/imas2tofu/_def.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/imas2tofu/_mat2ids2calc.py` & `tofu-1.7.0/tofu/imas2tofu/_mat2ids2calc.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/__init__.py` & `tofu-1.7.0/tofu/mag/__init__.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/equimap.py` & `tofu-1.7.0/tofu/mag/equimap.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/magFieldLines.py` & `tofu-1.7.0/tofu/mag/magFieldLines.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/mag_ripple/compile_f2py.sh` & `tofu-1.7.0/tofu/mag/mag_ripple/compile_f2py.sh`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/mag_ripple/mag_ripple.f` & `tofu-1.7.0/tofu/mag/mag_ripple/mag_ripple.f`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/regression_test.py` & `tofu-1.7.0/tofu/mag/regression_test.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/test_equimap.py` & `tofu-1.7.0/tofu/mag/test_equimap.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/test_magFieldLines.py` & `tofu-1.7.0/tofu/mag/test_magFieldLines.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/mag/test_ripple.py` & `tofu-1.7.0/tofu/mag/test_ripple.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/nist2tofu/_requests.py` & `tofu-1.7.0/tofu/nist2tofu/_requests.py`

 * *Files 1% similar despite different names*

```diff
@@ -319,17 +319,20 @@
 # #############################################################################
 # #############################################################################
 #                           SSL certificates handling
 # #############################################################################
 
 
 def _try_request_handle_ITER_SSL_step01(url=None):
+
     try:
         resp = requests.get(url)
+
     except requests.exceptions.SSLError as err:
+
         if 'certificate' in str(err):
             lbund = [
                 vv['bund'] for kk, vv in _DCERTIFICATES_BUNDLE.items()
                 if os.uname()[1].endswith(vv['host'])
             ]
             if len(lbund) == 1:
                 resp = requests.get(url, verify=lbund[0])
@@ -339,30 +342,35 @@
                     + "\n\nLooks like a certificate error occured!\n"
                     + "=> try changing the certificate bundle of requests\n"
                     + "=> ask your admin which certificate bundle to use!"
                 )
                 raise Exception(msg)
         else:
             raise err
+
     except Exception as err:
         raise err
+
     return resp
 
 
 def _try_request_handle_ITER_SSL_step02(url=None, pfe=None):
+
     try:
         with requests.get(url, stream=True) as rr:
             rr.raise_for_status()
             with open(pfe, 'wb') as ff:
                 for chunk in rr.iter_content(chunk_size=8192):
                     # filter-out keep-alive new chunks
                     if chunk:
                         ff.write(chunk)
                         # ff.flush()
+
     except requests.exceptions.SSLError as err:
+
         if 'certificate' in str(err):
             lbund = [
                 vv['bund'] for kk, vv in _DCERTIFICATES_BUNDLE.items()
                 if os.uname()[1].endswith(vv['host'])
             ]
             if len(lbund) == 1:
                 with requests.get(url, stream=True, verify=lbund[0]) as rr:
@@ -377,16 +385,18 @@
                 msg = (
                     str(err)
                     + "\n\nLooks like a certificate error occured!\n"
                     + "=> try changing the certificate bundle of requests\n"
                     + "=> ask your admin which certificate bundle to use!"
                 )
                 raise Exception(msg)
+
         else:
             raise err
+
     except Exception as err:
         raise err
 
 
 # #############################################################################
 # #############################################################################
 #                           csv parsing
```

### Comparing `tofu-1.6.5/tofu/openadas2tofu/_read_files.py` & `tofu-1.7.0/tofu/openadas2tofu/_read_files.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/openadas2tofu/_requests.py` & `tofu-1.7.0/tofu/openadas2tofu/_requests.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/pathfile.py` & `tofu-1.7.0/tofu/pathfile.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/spectro/_analysis_tools.py` & `tofu-1.7.0/tofu/spectro/_analysis_tools.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/spectro/_fit12d_dextract.py` & `tofu-1.7.0/tofu/spectro/_fit12d_dextract.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/spectro/_fit12d_dinput.py` & `tofu-1.7.0/tofu/spectro/_fit12d_dinput.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/spectro/_fit12d_funccostjac.py` & `tofu-1.7.0/tofu/spectro/_fit12d_funccostjac.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/spectro/_plot.py` & `tofu-1.7.0/tofu/spectro/_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/spectro/_rockingcurve.py` & `tofu-1.7.0/tofu/spectro/_rockingcurve.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,41 +1,41 @@
 
 
 # Built-in
-import sys
-import os
-import warnings
 import copy
+import warnings
+
 
 # Common
 import numpy as np
 import scipy.interpolate
 import matplotlib.pyplot as plt
 import matplotlib.gridspec as gridspec
-from matplotlib.axes._axes import Axes
+
 
 # tofu
-from tofu.version import __version__
-import tofu.spectro._rockingcurve_def as _rockingcurve_def
+from . import _rockingcurve_def as _def
 
 
 # ##########################################################
 # ##########################################################
 #                  compute rocking curve
 # ##########################################################
 # ##########################################################
 
 
 def compute_rockingcurve(
     # Type of crystal
-    crystal=None, din=None,
+    crystal=None,
+    din=None,
     # Wavelength
     lamb=None,
     # Lattice modifications
-    miscut=None, nn=None,
+    miscut=None,
+    nn=None,
     alpha_limits=None,
     therm_exp=None,
     temp_limits=None,
     # Plot
     plot_therm_exp=None,
     plot_asf=None,
     plot_power_ratio=None,
@@ -96,15 +96,15 @@
         ex: lamb=np.r_[3.96]
     miscut:    str
         Introduce miscut between dioptre and reflecting planes
     alpha_limits:    array
         Asymmetry angle range. Provide only both boundary limits
         Ex: np.r_[-3, 3] in radians
     nn:    int
-        Number of miscut angles and thermical changes steps,
+        Number of miscut angles and thermal changes steps,
         odd number preferred in order to have a median value at 0
     therm_exp:    str
         Compute relative changes of the crystal inter-planar distance by
         thermal expansion
     temp_limits:    array
         Limits of temperature variation around an average value
         Ex: np.r_[-10, 10, 25] for between 15 and 35C
@@ -119,85 +119,58 @@
     plot_asymmetry:    str
         Plot relations between the integrated reflectivity, the intrinsic
         width and the parameter b vs the glancing angle
     plot_cmaps:    str
         Build colormaps of the main properties of the rocking curves wanted
         (integrated and maxmimum values, FWMD and shift from reference curve)
         with respect to the asymmetry angle alpha and the temperature changes
-    returnas:    str
+    returnas:    type
         Entry 'dict' to allow optionnal returning of 'dout' dictionnary
     """
 
     # Check inputs
     # ------------
-    if crystal is None:
-        msg = (
-            "You must choose a type of crystal from "
-            + "tofu/spectro/_rockingcurve_def.py to use among:\n"
-            + "\t - Quartz_110:\n"
-            + "\t\t - target: ArXVII"
-            + "\t\t - Miller indices (h,k,l): (1,1,0)"
-            + "\t\t - Material: Quartz\n"
-            + "\t - Quartz_102:\n"
-            + "\t\t - target: ArXVIII"
-            + "\t\t - Miller indices (h,k,l): (1,0,2)"
-            + "\t\t - Material: Quartz\n"
-        )
-        raise Exception(msg)
-    elif crystal == 'Quartz_110':
-        din = _rockingcurve_def._DCRYST['Quartz_110']
-    elif crystal == 'Quartz_102':
-        din = _rockingcurve_def._DCRYST['Quartz_102']
-
-    if therm_exp is None:
-        therm_exp = False
-    if plot_therm_exp is None and therm_exp is not False:
-        plot_therm_exp = True
-    if miscut is None:
-        miscut = False
-    if alpha_limits is None:
-        alpha_limits = np.r_[-(3/60)*np.pi/180, (3/60)*np.pi/180]
-    if temp_limits is None:
-        temp_limits = np.r_[-10, 10, 25]
-    if nn is None:
-        nn = 20
-    na = 2*nn + 1
-    if plot_asf is None:
-        plot_asf = False
-    if plot_power_ratio is None:
-        plot_power_ratio = True
-    if plot_asymmetry is None and miscut is not False:
-        plot_asymmetry = True
-    lc = [therm_exp, miscut]
-    if plot_cmaps is None and all(lc) is True:
-        plot_cmaps = True
-    if returnas is None:
-        returnas = dict
 
-    ih, ik, il, lamb = CrystBragg_check_inputs_rockingcurve(
-        ih=din['miller'][0],
-        ik=din['miller'][1],
-        il=din['miller'][2],
-        lamb=lamb,
-    )
+    (
+        crystal, din, lamb,
+        # lattice expansion
+        therm_exp,
+        miscut,
+        alpha_limits,
+        temp_limits,
+        nn,
+        na,
+        # plotting
+        plot_asf,
+        plot_therm_exp,
+        plot_power_ratio,
+        plot_asymmetry,
+        plot_cmaps,
+        # return
+        returnas,
+    ) =  _checks(**locals())
 
     # Classical electronical radius, in Angstroms, from the NIST Reference on
     # Constants, Units and Uncertainty, CODATA 2018 recommended values
     re = 2.817940e-5
 
     # Computation of the unit cell volume, inter-planar distance,
     # sin(theta)/lambda parameter and Bragg angle associated to the wavelength
     # exits: T0, TD, a1, c1, Volume, d_atom, sol, sin_theta, theta, theta_deg
     dout = CrystBragg_comp_lattice_spacing(
-        crystal=crystal, din=din,
-        lamb=lamb, na=na, nn=nn,
+        crystal=crystal,
+        din=din,
+        lamb=lamb,
+        na=na,
+        nn=nn,
         therm_exp=therm_exp,
         temp_limits=temp_limits,
         plot_therm_exp=plot_therm_exp,
     )
+
     T0 = dout['Temperature of reference (C)']
     TD = dout['Temperature variations (C)']
     Volume = dout['Volume (1/m3)']
     d_atom = dout['Inter-reticular spacing (A)']
     sol = dout['sinus over lambda']
     theta = dout['theta_Bragg (rad)']
     theta_deg = dout['theta_Bragg (deg)']
@@ -206,75 +179,72 @@
     alpha, bb = CrystBragg_check_alpha_angle(
         theta=theta,
         alpha_limits=alpha_limits, na=na, nn=nn,
         miscut=miscut,
         therm_exp=therm_exp,
     )
 
-    l0 = ['Quartz_110', 'Quartz_102']
-    cond0 = any([crystal == l00 for l00 in l0])
+    cond0 = crystal in ['Quartz_110', 'Quartz_102']
     if cond0:
 
         # Calculation of the structure factor
         # -----------------------------------
 
         # Atomic absorption coefficient
-        if lamb > 6.74:
-            mu_si = _rockingcurve_def.mu_si1(lamb=lamb)
-        else:
-            mu_si = _rockingcurve_def.mu_si(lamb=lamb)
-        mu_o = _rockingcurve_def.mu_o(lamb=lamb)
-        mu = _rockingcurve_def.mu(lamb=lamb, mu_si=mu_si, mu_o=mu_o)
+        mu = din['mu'](lamb)
 
         # Atomic scattering factor ("f") in function of sol
         # ("_re") for the real part and ("_im") for the imaginary part
         fsi_re = np.full((sol.size), np.nan)
         fo_re = np.full((sol.size), np.nan)
 
-        dfsi_re = _rockingcurve_def.dfsi_re(lamb=lamb)
-        dfo_re = _rockingcurve_def.dfo_re(lamb=lamb)
-        for i in range(sol.size):
-            fsi_re[i] = _rockingcurve_def.fsi_re(lamb=lamb, sol=sol[i])
-            fo_re[i] = _rockingcurve_def.fo_re(lamb=lamb, sol=sol[i])
-        fsi_im = _rockingcurve_def.fsi_im(lamb=lamb, mu_si=mu_si)
-        fo_im = _rockingcurve_def.fo_im(lamb=lamb, mu_o=mu_o)
+        dfsi_re = din['dfsi_re'](lamb)
+        dfo_re = din['dfo_re'](lamb)
+        for ii in range(sol.size):
+            fsi_re[ii] = din['fsi_re'](lamb, sol[ii])
+            fo_re[ii] = din['fo_re'](lamb, sol[ii])
+        fsi_im = din['fsi_im'](lamb)
+        fo_im = din['fo_im'](lamb)
 
         # Structure factor ("F") for (hkl) reflection
         # xsi and ih have already been defined with din
         phasesi = din['phases']['Si']
         phaseo = din['phases']['O']
 
         Fsi_re1 = np.full((sol.size), np.nan)
         Fsi_re2 = Fsi_re1.copy()
         Fo_re1 = Fsi_re1.copy()
         Fo_re2 = Fsi_re1.copy()
 
-        for i in range(sol.size):
-            Fsi_re1[i] = np.sum(fsi_re[i]*np.cos(2*np.pi*phasesi))
-            Fsi_re2[i] = np.sum(fsi_re[i]*np.sin(2*np.pi*phasesi))
-            Fo_re1[i] = np.sum(fo_re[i]*np.cos(2*np.pi*phaseo))
-            Fo_re2[i] = np.sum(fo_re[i]*np.sin(2*np.pi*phaseo))
+        for ii in range(sol.size):
+            Fsi_re1[ii] = np.sum(fsi_re[ii]*np.cos(2*np.pi*phasesi))
+            Fsi_re2[ii] = np.sum(fsi_re[ii]*np.sin(2*np.pi*phasesi))
+            Fo_re1[ii] = np.sum(fo_re[ii]*np.cos(2*np.pi*phaseo))
+            Fo_re2[ii] = np.sum(fo_re[ii]*np.sin(2*np.pi*phaseo))
+
         Fsi_im1 = np.sum(fsi_im*np.cos(2*np.pi*phasesi))
         Fsi_im2 = np.sum(fsi_im*np.sin(2*np.pi*phasesi))
         Fo_im1 = np.sum(fo_im*np.cos(2*np.pi*phaseo))
         Fo_im2 = np.sum(fo_im*np.sin(2*np.pi*phaseo))
 
         F_re_cos = np.full((sol.size), np.nan)
         F_re_sin = F_re_cos.copy()
 
-        for i in range(sol.size):
-            F_re_cos[i] = Fsi_re1[i] + Fo_re1[i]
-            F_re_sin[i] = Fsi_re2[i] + Fo_re2[i]
+        for ii in range(sol.size):
+            F_re_cos[ii] = Fsi_re1[ii] + Fo_re1[ii]
+            F_re_sin[ii] = Fsi_re2[ii] + Fo_re2[ii]
+
         F_im_cos = Fsi_im1 + Fo_im1
         F_im_sin = Fsi_im2 + Fo_im2
 
         F_re = np.full((sol.size), np.nan)
 
-        for i in range(sol.size):
-            F_re[i] = np.sqrt(F_re_cos[i]**2 + F_re_sin[i]**2)
+        for ii in range(sol.size):
+            F_re[ii] = np.sqrt(F_re_cos[ii]**2 + F_re_sin[ii]**2)
+
         F_im = np.sqrt(F_im_cos**2 + F_im_sin**2)
 
         # Calculation of Fourier coefficients of polarization
         # ---------------------------------------------------
 
         Nsi = din['mesh']['positions']['Si']['N']
         No = din['mesh']['positions']['O']['N']
@@ -285,49 +255,54 @@
         Fbmod = Fmod.copy()
         kk = Fmod.copy()
         rek = Fmod.copy()
         psi_re = Fmod.copy()
         psi0_dre = Fmod.copy()
         psi0_im = Fmod.copy()
 
-        for i in range(sol.size):
+        for ii in range(sol.size):
             # Expression of the Fourier coef. psi_H
-            Fmod[i] = np.sqrt(
-                F_re[i]**2 + F_im**2 - 2.*(
-                    F_re_cos[i]*F_im_sin - F_im_cos*F_re_sin[i]
+            Fmod[ii] = np.sqrt(
+                F_re[ii]**2 + F_im**2 - 2.*(
+                    F_re_cos[ii]*F_im_sin - F_im_cos*F_re_sin[ii]
                 )
             )
             # psi_-H equivalent to (-ih, -ik, -il)
-            Fbmod[i] = np.sqrt(
-                F_re[i]**2 + F_im**2 - 2.*(
-                    F_re_sin[i]*F_im_cos - F_re_cos[i]*F_im_sin
+            Fbmod[ii] = np.sqrt(
+                F_re[ii]**2 + F_im**2 - 2.*(
+                    F_re_sin[ii]*F_im_cos - F_re_cos[ii]*F_im_sin
                 )
             )
-            if Fmod[i] == 0.:
-                Fmod[i] == 1e-30
-            if Fbmod[i] == 0.:
-                Fbmod[i] == 1e-30
+            if Fmod[ii] == 0.:
+                Fmod[ii] == 1e-30
+            if Fbmod[ii] == 0.:
+                Fbmod[ii] == 1e-30
+
             # Ratio imaginary part and real part of the structure factor
-            kk[i] = F_im/F_re[i]
+            kk[ii] = F_im / F_re[ii]
+
             # Real part of kk
-            rek[i] = (
-                (F_re_cos[i]*F_im_cos + F_re_sin[i]*F_im_sin)
-                / (F_re[i]**2.)
+            rek[ii] = (
+                (F_re_cos[ii]*F_im_cos + F_re_sin[ii]*F_im_sin)
+                / (F_re[ii]**2.)
             )
+
             # Real part of psi_H
-            psi_re[i] = (re*(lamb**2)*F_re[i])/(np.pi*Volume[i])
+            psi_re[ii] = (re*(lamb**2)*F_re[ii])/(np.pi*Volume[ii])
+
             # Zero-order real part (averaged)
-            psi0_dre[i] = -re*(lamb**2)*(
+            psi0_dre[ii] = -re*(lamb**2)*(
                 No*(Zo + dfo_re) + Nsi*(Zsi + dfsi_re)
-            )/(np.pi*Volume[i])
+            )/(np.pi*Volume[ii])
+
             # Zero-order imaginary part (averaged)
-            psi0_im[i] = (
+            psi0_im[ii] = (
                 -re*(lamb**2)
                 * (No*fo_im + Nsi*fsi_im)
-                / (np.pi*Volume[i])
+                / (np.pi*Volume[ii])
             )
 
     # Power ratio and their integrated reflectivity for 3 crystals models:
     # perfect (Darwin model), ideally mosaic thick and dynamical
     # --------------------------------------------------------------------
 
     if miscut is False and therm_exp is False:
@@ -420,42 +395,176 @@
 
     if not miscut and not therm_exp:
         P_dyn = P_dyn[0, 0]
         rhg_perp = rhg[0, 0, 0]
         rhg_para = rhg[1, 0, 0]
         det_perp = det_perp[0, 0]
 
-    dout = {
-        'Wavelength (A)': lamb,
-        'Miller indices': (ih, ik, il),
+    # -------------
+    # store results
+
+    # reminder: dimensions of power_ratio
+    # (polar.ndim, temperature.size, alpha.size, y.size)
+
+    dreturn = copy.deepcopy(din)
+    dreturn.update({
+        'wavelength': lamb,
         'Inter-reticular distance (A)': d_atom,
         'Volume (A^3)': Volume,
         'Bragg angle of reference (rad)': theta,
-        'Glancing angles': dth,
-        'Power ratio': power_ratio,
         'Integrated reflectivity': {
             'perfect model': P_per,
             'mosaic model': P_mos,
             'dynamical model': P_dyn,
         },
         'P_{dyn,para}/P_{dyn,perp} (integrated values)': rhg_para/rhg_perp,
         'Maximum reflectivity (perp. compo)': max_pr[0],
         'Maximum reflectivity (para. compo)': max_pr[1],
         'RC width (perp. compo)': det_perp,
         'RC width (para. compo)': det_para,
-    }
+        # polar
+        'polar': polar,
+        # y => angles
+        'y': y,
+        'Glancing angles': dth,
+        'Glancing angles rel': th,
+        'alpha': alpha,
+        # power ratio
+        'Power ratio': power_ratio,
+        # temperatures
+        'Temperature ref': T0,
+        'Temperature changes (C)': TD,
+        # miscut
+        'Miscut angles (deg)': alpha*(180/np.pi),
+
+    })
+
+    # add miscut
     if miscut:
-        dout['Miscut angles (deg)'] = alpha*(180/np.pi)
-        dout['Shift from RC of reference (perp. compo)'] = shift_perp
-        dout['Shift from RC of reference (para. compo)'] = shift_para
-    if therm_exp:
-        dout['Temperature changes (C)'] = TD
+        dreturn['Shift from RC of reference (perp. compo)'] = shift_perp
+        dreturn['Shift from RC of reference (para. compo)'] = shift_para
 
     if returnas is dict:
-        return dout
+        return dreturn
+
+
+# ####################################################################
+# ####################################################################
+#               Checks
+# ####################################################################
+# ####################################################################
+
+
+def _checks(
+    # Type of crystal
+    crystal=None,
+    din=None,
+    # Wavelength
+    lamb=None,
+    # Lattice modifications
+    miscut=None,
+    nn=None,
+    alpha_limits=None,
+    therm_exp=None,
+    temp_limits=None,
+    # Plot
+    plot_therm_exp=None,
+    plot_asf=None,
+    plot_power_ratio=None,
+    plot_asymmetry=None,
+    plot_cmaps=None,
+    # Returning dictionnary
+    returnas=None,
+):
+
+    # ------------
+    # crystal
+
+    if crystal not in _def._DCRYST.keys():
+        lk1 = ['material', 'symbol', 'miller', 'target']
+        dstr = {
+            k0: "\n".join([f"\t\t{k1}: {v0[k1]}" for k1 in lk1])
+            for k0, v0 in _def._DCRYST.items()
+        }
+        lstr = [f"\t- {k0}:\n{v0}" for k0, v0 in dstr.items()]
+        msg = (
+            "You must choose a type of crystal from "
+            + "tofu/spectro/_rockingcurve_def.py to use among:\n"
+            + "\n".join(lstr)
+        )
+        raise Exception(msg)
+
+    din = _def._DCRYST[crystal]
+
+    # lamb
+    if lamb is None:
+        lamb = din['target']['lamb']
+
+    # --------------------
+    # lattice modification
+
+    if therm_exp is None:
+        therm_exp = False
+
+    if miscut is None:
+        miscut = False
+
+    if alpha_limits is None:
+        alpha_limits = np.r_[-(3/60)*np.pi/180, (3/60)*np.pi/180]
+
+    if temp_limits is None:
+        temp_limits = np.r_[-10, 10, 25]
+
+    if nn is None:
+        nn = 20
+    na = 2*nn + 1
+
+    # --------------
+    # plotting args
+
+    if plot_asf is None:
+        plot_asf = False
+
+    if plot_therm_exp is None and therm_exp is not False:
+        plot_therm_exp = True
+
+    if plot_power_ratio is None:
+        plot_power_ratio = True
+
+    if plot_asymmetry is None and miscut is not False:
+        plot_asymmetry = True
+
+    lc = [therm_exp, miscut]
+    if plot_cmaps is None and all(lc) is True:
+        plot_cmaps = True
+
+    # ---------
+    # returnas
+
+    if returnas is None:
+        returnas = dict
+
+    return (
+        crystal, din, lamb,
+        # lattice expansion
+        therm_exp,
+        miscut,
+        alpha_limits,
+        temp_limits,
+        nn,
+        na,
+        # plotting
+        plot_asf,
+        plot_therm_exp,
+        plot_power_ratio,
+        plot_asymmetry,
+        plot_cmaps,
+        # return
+        returnas,
+    )
 
 
 # #############################################################################
 # #############################################################################
 #          Plot variations of RC components vs temperature & asymetry
 #                        for multiple wavelengths
 # #############################################################################
@@ -721,65 +830,61 @@
 # ##########################################################
 #                       Check inputs
 # ##########################################################
 # ##########################################################
 
 
 def CrystBragg_check_inputs_rockingcurve(
-    ih=None, ik=None, il=None, lamb=None,
+    ih=None,
+    ik=None,
+    il=None,
+    lamb=None,
 ):
 
     dd = {'ih': ih, 'ik': ik, 'il': il, 'lamb': lamb}
     lc = [v0 is None for k0, v0 in dd.items()]
+
+    # prepare msg
+    msg = (
+        "Args h, k, l and lamb were not explicitely specified\n"
+        f"\t - h: first Miller index ({ih})\n"
+        f"\t - k: second Miller index ({ik})\n"
+        f"\t - l: third Miller index ({il})\n"
+        f"\t - lamb: wavelength of interest ({lamb})\n"
+    )
+
     # All args are None
     if all(lc):
         ih = 1
         ik = 1
         il = 0
         lamb = self.dbragg['lambref']
-        msg = (
-            "Args h, k, l and lamb were not explicitely specified\n"
-            "and have been put to the following default values:\n"
-            + "\t - h: first Miller index ({})\n".format(ih)
-            + "\t - k: second Miller index ({})\n".format(ik)
-            + "\t - l: third Miller index ({})\n".format(il)
-            + "\t - lamb: wavelength of interest ({})\n".format(lamb)
-        )
+        msg = "The following default values are used because " + msg
         warnings.warn(msg)
-    elif any(lc):
+
     # Some args are bot but not all
-        msg = (
-            "Args h, k, l and lamb must be provided together:\n"
-            + "\t - h: first Miller index ({})\n".format(ih)
-            + "\t - k: second Miller index ({})\n".format(ik)
-            + "\t - l: third Miller index ({})\n".format(il)
-            + "\t - lamb: wavelength of interest ({})\n".format(lamb)
-        )
+    elif any(lc):
         raise Exception(msg)
 
     # Some args are string values
     cdt = [type(v0) == str for k0, v0 in dd.items()]
     if any(cdt) or all(cdt):
-        msg = (
-            "Args h, k, l and lamb must not be string inputs:\n"
-            "and have been put to default values:\n"
-            + "\t - h: first Miller index ({})\n".format(ih)
-            + "\t - k: second Miller index ({})\n".format(ik)
-            + "\t - l: third Miller index ({})\n".format(il)
-            + "\t - lamb: wavelength of interest ({})\n".format(lamb)
-        )
+        msg = "No str allowed - " + msg
         raise Exception(msg)
 
     return ih, ik, il, lamb,
 
 
 def CrystBragg_check_alpha_angle(
     theta=None,
-    miscut=None, therm_exp=None,
-    alpha_limits=None, na=None, nn=None,
+    miscut=None,
+    therm_exp=None,
+    alpha_limits=None,
+    na=None,
+    nn=None,
 ):
 
     if alpha_limits is None:
         if not miscut:
             alpha = np.full((na), 0.)
             bb = np.full((theta.size, alpha.size), -1.)
         else:
@@ -832,31 +937,33 @@
                     alpha = np.linspace(
                         alpha_limits[0], alpha_limits[1], na
                     ).reshape(na)
                     bb[i, ...] = np.sin(alpha + theta[i])/np.sin(
                         alpha - theta[i]
                     )
 
-    return alpha, bb,
+    return alpha, bb
 
 
 # ##########################################################
 # ##########################################################
 #             Computation of 2d lattice spacing
 #                    and rocking curves
 # ##########################################################
 # ##########################################################
 
 
 def CrystBragg_comp_lattice_spacing(
     # Type of crystal
-    crystal=None, din=None,
+    crystal=None,
+    din=None,
     lamb=None,
     # Plot
-    na=None, nn=None,
+    na=None,
+    nn=None,
     therm_exp=None,
     temp_limits=None,
     plot_therm_exp=None,
 ):
     """
     Compute the inter-atomic spacing d_hkl for a given crystal of Miller
     indices (ih, ik ,il).
@@ -886,40 +993,26 @@
         Miller indices of crystal used, by default to (1,1,0)
     lamb:    float
         Wavelength of interest, in Angstroms (1e-10 m), by default to 3.96A
     """
 
     # Check inputs
     # ------------
+
     ih, ik, il, lamb = CrystBragg_check_inputs_rockingcurve(
         ih=din['miller'][0],
         ik=din['miller'][1],
         il=din['miller'][2],
         lamb=lamb,
     )
-    if nn is None:
-        nn = 20
-    na = 2*nn + 1
-    if therm_exp is None:
-        therm_exp = False
-    if plot_therm_exp is None and therm_exp is not False:
-        plot_therm_exp = True
-    lc = [ih is None, ik is None, il is None, lamb is None]
-    if any(lc):
-        msg = (
-            "Please make sure that the foolowing arguments are valid:\n"
-            "\t - ih, ik, il: ({},{},{})\n".format(ih, ik, il)
-            + "\t - lamb: ({})\n".format(lamb)
-        )
-        raise Exception(msg)
 
     # Prepare
     # -------
-    l0 = ['Quartz_110', 'Quartz_102']
-    cond0 = any([crystal == l00 for l00 in l0])
+
+    cond0 = crystal in ['Quartz_110', 'Quartz_102']
 
     # Inter-atomic distances and thermal expansion coefficients
     if cond0:
         a0 = din['inter_atomic']['distances']['a0']
         c0 = din['inter_atomic']['distances']['c0']
         alpha_a = din['thermal_expansion']['coefs']['alpha_a']
         alpha_c = din['thermal_expansion']['coefs']['alpha_c']
@@ -927,49 +1020,54 @@
     # Temperature changes
     T0 = temp_limits[2]  # Reference temperature in C
     if therm_exp:
         TD = np.linspace(temp_limits[0], temp_limits[1], na)
     else:
         TD = np.r_[0.]
 
-    # Results arrays
+    # Prepare results arrays
+    # -----------------------
+
     d_atom = np.full((TD.size), np.nan)
     if cond0:
         a1, c1 = d_atom.copy(), d_atom.copy()
     Volume, sol = d_atom.copy(), d_atom.copy()
     sin_theta, theta, theta_deg = d_atom.copy(), d_atom.copy(), d_atom.copy()
 
-    # Compute
-    # -------
+    # Compute (loop on temperature)
+    # -----------------------------
+
+    for ii in range(TD.size):
 
-    for i in range(TD.size):
         if cond0:
-            a1[i] = a0*(1 + alpha_a*TD[i])
-            c1[i] = c0*(1 + alpha_c*TD[i])
-            Volume[i] = _rockingcurve_def.hexa_volume(a1[i], c1[i])
-            d_atom[i] = _rockingcurve_def.hexa_spacing(
-                ih, ik, il, a1[i], c1[i],
+            a1[ii] = a0*(1 + alpha_a*TD[ii])
+            c1[ii] = c0*(1 + alpha_c*TD[ii])
+            Volume[ii] = _def.hexa_volume(a1[ii], c1[ii])
+            d_atom[ii] = _def.hexa_spacing(
+                ih, ik, il, a1[ii], c1[ii],
             )
-        if d_atom[i] < lamb/2.:
+
+        if d_atom[ii] < lamb/2.:
             msg = (
                 "According to Bragg law, Bragg scattering need d > lamb/2!\n"
                 "Please check your wavelength argument.\n"
             )
             raise Exception(msg)
-        sol[i] = 1./(2.*d_atom[i])
-        sin_theta[i] = lamb/(2.*d_atom[i])
-        theta[i] = np.arcsin(sin_theta[i])
-        theta_deg[i] = theta[i]*(180./np.pi)
 
-        lc = [theta_deg[i] < 10., theta_deg[i] > 89.]
+        sol[ii] = 1./(2.*d_atom[ii])
+        sin_theta[ii] = lamb / (2.*d_atom[ii])
+        theta[ii] = np.arcsin(sin_theta[ii])
+        theta_deg[ii] = theta[ii]*(180./np.pi)
+
+        lc = [theta_deg[ii] < 10., theta_deg[ii] > 89.]
         if any(lc):
             msg = (
                 "The computed value of theta is behind the arbitrary limits.\n"
                 "Limit condition: 10 < theta < 89 and\n"
-                "theta = ({})\n".format(theta_deg)
+                f"theta = {theta_deg} \n"
             )
             raise Exception(msg)
 
     # Plot calling
     # ------------
 
     if plot_therm_exp:
@@ -979,15 +1077,15 @@
         )
 
     dout = {
         'Temperature of reference (C)': T0,
         'Temperature variations (C)': TD,
         'Inter_atomic distance a1 (A)': a1,
         'Inter_atomic distance c1 (A)': c1,
-        'Volume (1/m3)': Volume,
+        'Volume (1/m3)': Volume,                # m3 ?
         'Inter-reticular spacing (A)': d_atom,
         'sinus over lambda': sol,
         'sinus theta_Bragg': sin_theta,
         'theta_Bragg (rad)': theta,
         'theta_Bragg (deg)': theta_deg,
     }
```

### Comparing `tofu-1.6.5/tofu/tests/tests00_root/test_03_plot.py` & `tofu-1.7.0/tofu/tests/tests00_root/test_03_plot.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_01_GG.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_01_GG.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_02_compute.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_02_compute.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_03_core.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_03_core.py`

 * *Files 0% similar despite different names*

```diff
@@ -996,22 +996,23 @@
                 Ds, us = obj.D[:], obj.u[:]
                 out = obj.get_sample(0.02, resMode='abs',
                                      method='sum',DL=None)
                 k, res, lind = out
                 # nbrepet = np.r_[lind[0], np.diff(lind), k.size - lind[-1]]
                 # kus = k * np.repeat(us, nbrepet, axis=1)
                 # Pts = np.repeat(Ds, nbrepet, axis=1) + kus
-                k = np.asarray(np.split(k, lind))
-                assert len(res)==len(k)==obj.nRays
-                for ii in range(0,len(k)):
+                k = np.split(k, lind)
+                assert len(res) == len(k) == obj.nRays
+                for ii in range(0, len(k)):
                     if not (np.isnan(obj.kIn[ii]) or np.isnan(obj.kOut[ii])):
                         ind = ~np.isnan(k[ii])
                         assert np.all((k[ii][ind]>=obj.kIn[ii]-res[ii])
                                       & (k[ii][ind]<=obj.kOut[ii]+res[ii]))
                 assert np.all(res[~np.isnan(res)]<0.02)
+
                 out = obj.get_sample(0.1, resMode='rel',
                                      method='simps',DL=[0,1])
                 k, res, lind = out
                 k = np.split(k, lind)
                 assert len(res)==len(k)==obj.nRays
                 for ii in range(0,len(k)):
                     if not (np.isnan(obj.kIn[ii]) or np.isnan(obj.kOut[ii])):
@@ -1019,14 +1020,15 @@
                         if not np.all((k[ii][ind]>=obj.kIn[ii]-res[ii])
                                       & (k[ii][ind]<=obj.kOut[ii]+res[ii])):
                             msg = typ+' '+c+' '+str(ii)
                             msg += "\n {0} {1}".format(obj.kIn[ii],obj.kOut[ii])
                             msg += "\n {0}".format(str(k[ii][ind]))
                             print(msg)
                             raise Exception(msg)
+
                 out = obj.get_sample(0.1, resMode='rel',
                                      method='romb',DL=[0,1])
                 k, res, lind = out
                 k = np.split(k, lind)
                 assert len(res)==len(k)==obj.nRays
                 for ii in range(0,len(k)):
                     if not (np.isnan(obj.kIn[ii]) or np.isnan(obj.kOut[ii])):
```

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_04_core_optics.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_04_core_optics.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_04_sampling.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_04_sampling.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_05_solid_angles.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_05_solid_angles.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/Inkscape.svg` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/Inkscape.svg`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_CoilPF_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Baffle_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V2.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperInner_V2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V2.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_BumperOuter_V2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V2.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowGC_V2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V2.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivLowITER_V2.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_DivUp_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC1_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC2_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_IC3_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH1_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V1.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_LH2_V1.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PFC_Ripple_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_PlasmaDomain_Standard_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_PlasmaDomain_Standard_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesIn_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_Notes.py` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_Notes.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_V0.txt` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/WEST_Ves_VesOut_V0.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/test_data/det37_CTVD_incC4_New.npz` & `tofu-1.7.0/tofu/tests/tests01_geom/test_data/det37_CTVD_incC4_New.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests01_geom/testing_tools.py` & `tofu-1.7.0/tofu/tests/tests01_geom/testing_tools.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests02_data/test_03_core.py` & `tofu-1.7.0/tofu/tests/tests02_data/test_03_core.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests02_data/test_04_spectrallines.py` & `tofu-1.7.0/tofu/tests/tests02_data/test_04_spectrallines.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests03_openadas/test_03_core.py` & `tofu-1.7.0/tofu/tests/tests03_openadas/test_03_core.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_01_fit12d.py` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_01_fit12d.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_02_analysistools.py` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_02_analysistools.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_03_rockingcurve.py` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_03_rockingcurve.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/TFG_CrystalBragg_ExpWEST_DgXICS_ArXVII_sh00000_Vers1.5.0.npz` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/TFG_CrystalBragg_ExpWEST_DgXICS_ArXVII_sh00000_Vers1.5.0.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/UV_spectra_sh55506.npz` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/UV_spectra_sh55506.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/_lines_database.py` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/_lines_database.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/_mask_54041.npz` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/_mask_54041.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/_spectral_constraints.py` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/_spectral_constraints.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/det37_CTVD_incC4_New.npz` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/det37_CTVD_incC4_New.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/spectral_fit.npz` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/spectral_fit.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests04_spectro/test_data/west_54046_xics.npz` & `tofu-1.7.0/tofu/tests/tests04_spectro/test_data/west_54046_xics.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests05_nist/test_03_core.py` & `tofu-1.7.0/tofu/tests/tests05_nist/test_03_core.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,17 @@
 """
 This module contains tests for tofu.geom in its structured version
 """
 
 # Built-in
 import os
-import warnings
 import shutil
 import itertools as itt
-import subprocess
-from subprocess import PIPE
-
-# Standard
-import numpy as np
-import matplotlib.pyplot as plt
 
 # tofu-specific
-from tofu import __version__
 import tofu.nist2tofu as tfn
 
 _here = os.path.abspath(os.path.dirname(__file__))
 VerbHead = 'tofu.nist2tofu.test_03_core'
 _TOFU_USER = os.path.join(os.path.expanduser("~"), '.tofu')
 _CUSTOM = os.path.dirname(os.path.dirname(os.path.dirname(_here)))
 _CUSTOM = os.path.join(_CUSTOM, 'scripts', 'tofucustom.py')
@@ -49,15 +41,15 @@
 #######################################################
 #
 #     Creating Ves objects and testing methods
 #
 #######################################################
 
 
-class Test01_openadas(object):
+class Test01_nist(object):
 
     @classmethod
     def setup_class(cls):
         pass
 
     @classmethod
     def setup_method(self):
@@ -92,23 +84,25 @@
                 continue
             if comb[2] == 'H' and comb[1] is None:
                 continue
             if comb[2] == 'H' and all([vv is not None for vv in comb[:2]]):
                 continue
             if any([vv is None for vv in comb[:2]]) and comb[2] != 'H':
                 continue
-            print('{} / {}  -  {}'.format(ii, itot, comb))
-            out = tfn.step01_search_online_by_wavelengthA(
-                lambmin=comb[0],
-                lambmax=comb[1],
-                ion=comb[2],
-                verb=True,
-                return_dout=True,
-                return_dsources=True,
-                cache_from=comb[3],
-                cache_info=True,
-                format_for_DataStock=comb[4],
-                create_custom=True,
-            )
+            print(f'{ii} / {itot}  -  {comb}')
+
+            # out = tfn.step01_search_online_by_wavelengthA(
+                # lambmin=comb[0],
+                # lambmax=comb[1],
+                # ion=comb[2],
+                # verb=True,
+                # return_dout=True,
+                # return_dsources=True,
+                # cache_from=comb[3],
+                # cache_info=True,
+                # format_for_DataStock=comb[4],
+                # create_custom=True,
+            # )
+            # del out
 
     def test02_clear_cache(self):
         tfn.clear_cache()
```

### Comparing `tofu-1.6.5/tofu/tests/tests06_mesh/test_01_checks.py` & `tofu-1.7.0/tofu/tests/tests06_mesh/test_01_checks.py`

 * *Files 8% similar despite different names*

```diff
@@ -63,90 +63,89 @@
 #     Basic instanciation
 #
 #######################################################
 
 
 def _add_rect_uniform(plasma):
     # add uniform rect mesh
-    plasma.add_mesh(key='m0', domain=[[2, 3], [-1, 1]], res=0.1)
+    plasma.add_mesh_2d_rect(key='m0', domain=[[2, 3], [-1, 1]], res=0.1)
 
 
 def _add_rect_variable(plasma):
     # add variable rect mesh
-    plasma.add_mesh(
+    plasma.add_mesh_2d_rect(
         key='m1',
         domain=[[2, 2.3, 2.6, 3], [-1, 0., 1]],
         res=[[0.2, 0.1, 0.1, 0.2], [0.2, 0.1, 0.2]],
     )
 
 
 def _add_rect_variable_crop(plasma):
     # add variable rect mesh
-    plasma.add_mesh(
+    plasma.add_mesh_2d_rect(
         key='m2',
         domain=[[2, 2.3, 2.6, 3], [-1, 0., 1]],
         res=[[0.2, 0.1, 0.1, 0.2], [0.2, 0.1, 0.2]],
         crop_poly=tf.load_config('WEST'),
     )
 
 
 def _add_tri_ntri1(plasma):
     cents = _DTRI['cents']['data']
     cents2 = np.zeros((cents.shape[0]*2, 3))
     cents2[::2, :] = cents[:, :3]
     cents2[1::2, :2] = cents[:, 2:]
     cents2[1::2, -1] = cents[:, 0]
 
-    plasma.add_mesh(
+    plasma.add_mesh_2d_tri(
         key='m3',
         knots=_DTRI['nodes']['data'],
-        cents=cents2,
+        indices=cents2,
     )
 
 
 def _add_tri_ntri2(plasma):
-    plasma.add_mesh(
+    plasma.add_mesh_2d_tri(
         key='m4',
         knots=_DTRI['nodes']['data'],
-        cents=_DTRI['cents']['data'],
+        indices=_DTRI['cents']['data'],
     )
 
 
 def _add_polar1(plasma, key='m5'):
     """ Time-independent """
 
-    kR, kZ = plasma.dobj['bsplines']['m2-bs1']['apex']
+    kR, kZ = plasma.dobj['bsplines']['m2_bs1']['apex']
     R = plasma.ddata[kR]['data']
     Z = plasma.ddata[kZ]['data']
     RR = np.repeat(R[:, None], Z.size, axis=1)
     ZZ = np.repeat(Z[None, :], R.size, axis=0)
     rho = (RR - 2.5)**2/0.08 + (ZZ - 0)**2/0.35
 
     plasma.add_data(
         key='rho1',
         data=rho,
-        ref='m2-bs1',
+        ref='m2_bs1',
         unit='',
         dim='',
         quant='rho',
         name='rho',
     )
 
-    plasma.add_mesh_polar(
+    plasma.add_mesh_1d(
         key=key,
-        radius=np.linspace(0, 1.2, 7),
-        angle=None,
-        radius2d='rho1',
+        knots=np.linspace(0, 1.2, 7),
+        subkey='rho1',
     )
 
 
 def _add_polar2(plasma, key='m6'):
     """ Time-dependent """
 
-    kR, kZ = plasma.dobj['bsplines']['m2-bs1']['apex']
+    kR, kZ = plasma.dobj['bsplines']['m2_bs1']['apex']
     R = plasma.ddata[kR]['data']
     Z = plasma.ddata[kZ]['data']
     RR = np.repeat(R[:, None], Z.size, axis=1)
     ZZ = np.repeat(Z[None, :], R.size, axis=0)
 
     rho = (RR - 2.5)**2/0.08 + (ZZ - 0)**2/0.35
     angle = np.arctan2(ZZ/2., (RR - 2.5))
@@ -171,26 +170,26 @@
             dim='time',
         )
 
     if 'rho2' not in plasma.ddata.keys():
         plasma.add_data(
             key='rho2',
             data=rho,
-            ref=('nt', 'm2-bs1'),
+            ref=('nt', 'm2_bs1'),
             unit='',
             dim='',
             quant='rho',
             name='rho',
         )
 
     if 'angle2' not in plasma.ddata.keys():
         plasma.add_data(
             key='angle2',
             data=angle,
-            ref=('nt', 'm2-bs1'),
+            ref=('nt', 'm2_bs1'),
             unit='rad',
             dim='',
             quant='angle',
             name='theta',
         )
 
     # ang
@@ -240,39 +239,52 @@
                 plasma.add_bsplines(key=k0, deg=1, angle=[None]*6 + [angle])
                 plasma.add_bsplines(key=k0, deg=2, angle=[None]*7 + [angle])
                 plasma.add_bsplines(key=k0, deg=3, angle=[None]*8 + [angle])
 
 
 def _add_data_fix(plasma, key):
 
-    kdata = f'{key}-data-fix'
+    kdata = f'{key}_data_fix'
     shape = plasma.dobj['bsplines'][key]['shape']
     data = np.random.random(shape)
 
-    plasma.add_data(
-        key=kdata,
-        data=data,
-        ref=key,
-    )
+    if kdata not in plasma.ddata.keys():
+        plasma.add_data(
+            key=kdata,
+            data=data,
+            ref=key,
+        )
     return kdata
 
 
 def _add_data_var(plasma, key):
 
+    if 't' not in plasma.ddata.keys():
+        nt = 11
+        t = np.linspace(30, 40, nt)
+        plasma.add_ref('nt', nt)
+        plasma.add_data(
+            key='t',
+            data=t,
+            ref=('nt',),
+            dim='time',
+        )
+
     kdata = f'{key}-data-var'
     shape = plasma.dobj['bsplines'][key]['shape']
     t = plasma.ddata['t']['data']
     tsh = tuple([t.size] + [1 for ii in shape])
     data = np.cos(t.reshape(tsh)) * np.random.random(shape)[None, ...]
 
-    plasma.add_data(
-        key=kdata,
-        data=data,
-        ref=('nt', key),
-    )
+    if kdata not in plasma.ddata.keys():
+        plasma.add_data(
+            key=kdata,
+            data=data,
+            ref=('nt', key),
+        )
     return kdata
 
 
 #######################################################
 #
 #     checking routines
 #
@@ -339,31 +351,31 @@
     def test07_add_mesh_polar_radial(self):
         plasma = tfd.Collection()
         _add_rect_variable_crop(plasma)
         _add_bsplines(plasma)
         _add_polar1(plasma)
         _add_bsplines(plasma, kind=['polar'])
 
-    def test08_add_mesh_polar_angle_regular(self):
-        plasma = tfd.Collection()
-        _add_rect_variable_crop(plasma)
-        _add_bsplines(plasma)
-        _add_polar2(plasma)
-        _add_bsplines(plasma, kind=['polar'])
-
-    def test09_add_mesh_polar_angle_variable(self):
-        plasma = tfd.Collection()
-        _add_rect_variable_crop(plasma)
-        _add_bsplines(plasma)
-        _add_polar2(plasma, key='m7')
-        _add_bsplines(
-            plasma,
-            kind=['polar'],
-            angle=np.pi*np.r_[-3./4., -1/4, 0, 1/4, 3/4],
-        )
+    # def test08_add_mesh_polar_angle_regular(self):
+        # plasma = tfd.Collection()
+        # _add_rect_variable_crop(plasma)
+        # _add_bsplines(plasma)
+        # _add_polar2(plasma)
+        # _add_bsplines(plasma, kind=['polar'])
+
+    # def test09_add_mesh_polar_angle_variable(self):
+        # plasma = tfd.Collection()
+        # _add_rect_variable_crop(plasma)
+        # _add_bsplines(plasma)
+        # _add_polar2(plasma, key='m7')
+        # _add_bsplines(
+            # plasma,
+            # kind=['polar'],
+            # angle=np.pi*np.r_[-3./4., -1/4, 0, 1/4, 3/4],
+        # )
 
 
 #######################################################
 #
 #     object mesh2D
 #
 #######################################################
@@ -388,31 +400,44 @@
         _add_tri_ntri2(plasma)
 
         # add bsplines
         _add_bsplines(plasma)
 
         # add polar mesh
         _add_polar1(plasma)
-        _add_polar2(plasma)
+        # _add_polar2(plasma)
 
         # add bsplines for polar meshes
         _add_bsplines(plasma, kind=['polar'])
 
         # Add polar with variable poloidal discretization
-        _add_polar2(plasma, key='m7')
-        _add_bsplines(
-            plasma,
-            key=['m7'],
-            angle=np.pi*np.r_[-3./4., -1/4, 0, 1/4, 3/4],
-        )
+        # _add_polar2(plasma, key='m7')
+        # _add_bsplines(
+            # plasma,
+            # key=['m7'],
+            # angle=np.pi*np.r_[-3./4., -1/4, 0, 1/4, 3/4],
+        # )
+
+        # add data
+        lbsdata = []
+        for k0 in list(plasma.dobj['bsplines'].keys()):
+            k1 = f'{k0}_data'
+            plasma.add_data(
+                key=k1,
+                data=np.ones(plasma.dobj['bsplines'][k0]['shape']),
+                ref=k0,
+                units='W',
+            )
+            lbsdata.append(k1)
 
         # store
         self.obj = plasma
         self.lm = list(plasma.dobj['mesh'].keys())
         self.lbs = list(plasma.dobj['bsplines'].keys())
+        self.lbsdata = lbsdata
 
     def teardown_method(self):
         pass
 
     @classmethod
     def teardown_class(cls):
         pass
@@ -487,40 +512,40 @@
                 ind=lind[ii%len(lind)],
                 elements=lelem[ii%3],
                 returnas='ind' if ii%2 == 0 else 'data',
                 return_neighbours=return_neighbours,
                 crop=ii%3 == 1,
             )
 
-    def test04_select_bsplines(self):
-
-        lind0 = [None, ([0, 2], [0, 4]), [0, 2, 4], ([0, 2, 4], [0, 2, 3])]
-        lind1 = [None, [1], 1, [0, 1]]
-        for ii, k0 in enumerate(self.lbs):
-
-            km = self.obj.dobj['bsplines'][k0]['mesh']
-            if len(self.obj.dobj['bsplines'][k0]['shape']) == 2:
-                lind = lind0
-            else:
-                lind = lind1
-
-            if self.obj.dobj['mesh'][km]['type'] == 'polar':
-                return_cents = False
-                return_knots = False
-            else:
-                return_cents = None if ii == 1 else bool(ii%3)
-                return_knots = None if ii == 2 else bool(ii%2)
+    # def test04_select_bsplines(self):
 
-            out = self.obj.select_bsplines(
-                key=k0,
-                ind=lind[ii%len(lind)],
-                returnas='ind' if ii%3 == 0 else 'data',
-                return_cents=return_cents,
-                return_knots=return_knots,
-            )
+        # lind0 = [None, ([0, 2], [0, 4]), [0, 2, 4], ([0, 2, 4], [0, 2, 3])]
+        # lind1 = [None, [1], 1, [0, 1]]
+        # for ii, k0 in enumerate(self.lbs):
+
+            # km = self.obj.dobj['bsplines'][k0]['mesh']
+            # if len(self.obj.dobj['bsplines'][k0]['shape']) == 2:
+                # lind = lind0
+            # else:
+                # lind = lind1
+
+            # if self.obj.dobj['mesh'][km]['type'] == 'polar':
+                # return_cents = False
+                # return_knots = False
+            # else:
+                # return_cents = None if ii == 1 else bool(ii%3)
+                # return_knots = None if ii == 2 else bool(ii%2)
+
+            # out = self.obj.select_bsplines(
+                # key=k0,
+                # ind=lind[ii%len(lind)],
+                # returnas='ind' if ii%3 == 0 else 'data',
+                # return_cents=return_cents,
+                # return_knots=return_knots,
+            # )
 
     def test05_sample_mesh(self):
 
         lres = [None, 0.1, [0.1, 0.05]]
         lmode = [None, 'rel', 'abs']
         lgrid = [None, True, False]
         for ii, k0 in enumerate(self.lm):
@@ -529,14 +554,17 @@
             mode = lmode[ii%len(lmode)]
             if self.obj.dobj['mesh'][k0]['type'] == 'tri':
                 if mode == 'rel':
                     if res == 0.1:
                         res = 0.5
                     elif res == [0.1, 0.05]:
                         res = [0.5, 0.4]
+            elif self.obj.dobj['mesh'][k0]['nd'] == '1d':
+                if isinstance(res, list):
+                    res = res[0]
 
             out = self.obj.get_sample_mesh(
                 key=k0,
                 res=res,
                 mode=mode,
                 grid=lgrid[ii%len(lgrid)],
             )
@@ -548,147 +576,128 @@
         lgrid = [None, True, False, False]
         for ii, (k0, v0) in enumerate(self.dobj.items()):
             out = v0.get_sample_bspline(
                 res=lres[ii], grid=lgrid[ii], mode=lmode[ii],
             )
     """
 
-    def test07_interpolate_profile2d_sum(self):
+    def test07_interpolate_sum(self):
         x = np.linspace(2.2, 2.8, 5)
         y = np.linspace(-0.5, 0.5, 5)
         x = np.tile(x, (y.size, 1))
         y = np.tile(y, (x.shape[1], 1)).T
 
         dfail = {}
-        for ii, k0 in enumerate(self.lbs):
+        for ii, k0 in enumerate(self.lbsdata):
 
+            kbs = self.obj.ddata[k0]['bsplines'][0]
             # try:
-            val = self.obj.interpolate_profile2d(
-                key=k0,
-                R=x,
-                Z=y,
-                coefs=None,
-                indbs=None,
-                indt=None,
+            val = self.obj.interpolate(
+                keys=k0,
+                x0=x,
+                x1=y,
                 grid=False,
                 details=False,
-                reshape=True,
                 res=None,
                 crop=None,
                 nan0=ii % 2 == 0,
-                imshow=False,
             )
 
             # add fix data
-            kdata = _add_data_fix(self.obj, k0)
-            val = self.obj.interpolate_profile2d(
-                key=kdata,
-                R=x,
-                Z=y,
-                coefs=None,
-                indbs=None,
-                indt=None,
+            kdata = _add_data_fix(self.obj, kbs)
+            val = self.obj.interpolate(
+                keys=kdata,
+                x0=x,
+                x1=y,
                 grid=False,
                 details=False,
-                reshape=True,
                 res=None,
                 crop=None,
                 nan0=ii % 2 == 0,
-                imshow=False,
             )
 
             # add time-dependent data
-            kdata = _add_data_var(self.obj, k0)
-            val = self.obj.interpolate_profile2d(
-                key=kdata,
-                R=x,
-                Z=y,
-                coefs=None,
-                indbs=None,
-                indt=None,
+            kdata = _add_data_var(self.obj, kbs)
+            val = self.obj.interpolate(
+                keys=kdata,
+                x0=x,
+                x1=y,
                 grid=False,
                 details=False,
-                reshape=True,
                 res=None,
                 crop=None,
                 nan0=ii % 2 == 0,
-                imshow=False,
             )
             # except Exception as err:
                 # dfail[k0] = str(err)
 
         # raise error if any fail
         if len(dfail) > 0:
             lstr = [f"\t- {k0}: {v0}" for k0, v0 in dfail.items()]
             msg = (
                 "The following bsplines could not be interpolated:\n"
                 + "\n".join(lstr)
             )
             raise Exception(msg)
 
-    def test08_interpolate_profile2d_details_vs_sum(self):
+    def test08_interpolate_details_vs_sum(self):
 
         x = np.linspace(2.2, 2.8, 5)
         y = np.linspace(-0.5, 0.5, 5)
         x = np.tile(x, (y.size, 1))
         y = np.tile(y, (x.shape[1], 1)).T
 
-        for ii, k0 in enumerate(self.lbs):
+        for ii, k0 in enumerate(self.lbsdata):
 
-            keym = self.obj.dobj['bsplines'][k0]['mesh']
+            kbs = self.obj.ddata[k0]['bsplines'][0]
+            keym = self.obj.dobj['bsplines'][kbs]['mesh']
             mtype = self.obj.dobj['mesh'][keym]['type']
 
-            val, t, ref = self.obj.interpolate_profile2d(
-                key=k0,
-                R=x,
-                Z=y,
-                coefs=None,
-                indbs=None,
-                indt=None,
+            dout0 = self.obj.interpolate(
+                keys=k0,
+                ref_key=kbs,
+                x0=x,
+                x1=y,
                 grid=False,
                 details=True,
-                reshape=True,
                 res=None,
                 crop=None,
                 nan0=ii % 2 == 0,
-                imshow=False,
                 return_params=False,
-            )
+            )[f'{kbs}_details']
 
-            crop = self.obj.dobj['bsplines'][k0].get('crop', False)
-            nbs = np.prod(self.obj.dobj['bsplines'][k0]['shape'])
+            crop = self.obj.dobj['bsplines'][kbs].get('crop', False)
+            nbs = np.prod(self.obj.dobj['bsplines'][kbs]['shape'])
             if isinstance(crop, str):
                 nbs = self.obj.ddata[crop]['data'].sum()
 
+            val = dout0['data']
             vshap0 = tuple(np.r_[x.shape, nbs])
             if mtype == 'polar':
                 # radius2d can be time-dependent => additional dimension
                 vshap = val.shape[-len(vshap0):]
             else:
                 vshap = val.shape
             assert vshap == vshap0, val.shape
 
-            val_sum, t, ref = self.obj.interpolate_profile2d(
-                key=k0,
-                R=x,
-                Z=y,
-                coefs=None,
-                indbs=None,
-                indt=None,
+            dout1 = self.obj.interpolate(
+                keys=k0,
+                ref_key=kbs,
+                x0=x,
+                x1=y,
                 grid=False,
                 details=False,
-                reshape=True,
                 res=None,
                 crop=None,
                 nan0=False,
                 val_out=0.,
-                imshow=False,
                 return_params=False,
-            )
+            )[k0]
 
+            val_sum = dout1['data']
             if mtype == 'polar':
                 # radius2d can be time-dependent => additional dimension
                 vshap_sum = val_sum.shape[-len(x.shape):]
             else:
                 vshap_sum = val_sum.shape
             assert vshap_sum == x.shape, val_sum.shape
             assert (val.ndim == x.ndim + 2) == (val_sum.ndim == x.ndim + 1), [val.shape, val_sum.shape]
@@ -728,105 +737,105 @@
             dax = self.obj.plot_mesh(
                 key=k0,
                 ind_knot=lik[ii%len(lik)] if lik is not None else None,
                 ind_cent=lic[ii%len(lic)] if lic is not None else None,
             )
         plt.close('all')
 
-    def test10_plot_bsplines(self):
-
-        li0 = [None, ([1, 2], [2, 1]), (1, 1), [1, 2, 4]]
-        li1 = [None, [1, 2], (1, 1), [1, 2, 4]]
-        for ii, k0 in enumerate(self.lbs):
-
-            km = self.obj.dobj['bsplines'][k0]['mesh']
-            if len(self.obj.dobj['mesh'][km]['shape-c']) == 2:
-                li = li0
-            else:
-                li = li1
-
-            if self.obj.dobj['mesh'][km]['type'] == 'polar':
-                plot_mesh = False
-            else:
-                plot_mesh = True
-
-            dax = self.obj.plot_bsplines(
-                key=k0,
-                indbs=li[ii%len(li)],
-                knots=bool(ii%3),
-                cents=bool(ii%2),
-                res=0.05,
-                plot_mesh=plot_mesh,
-            )
-            plt.close('all')
-
-    def test11_plot_profile2d(self):
+    # def test10_plot_bsplines(self):
 
-        # plotting
-        for k0 in self.lbs:
-
-            # fix
-            k1 = _add_data_fix(self.obj, k0)
-            dax = self.obj.plot_profile2d(key=k1, res=0.05)
-
-            # time-variable
-            k1 = _add_data_var(self.obj, k0)
-            dax = self.obj.plot_profile2d(key=k1, res=0.05)
-
-            plt.close('all')
-
-    def test12_add_bsplines_operator(self):
-        lkey = ['m0-bs0', 'm1-bs1', 'm2-bs2']
-        lop = ['D0N1', 'D0N2', 'D1N2', 'D2N2']
-        lgeom = ['linear', 'toroidal']
-        lcrop = [False, True]
-
-        dfail = {}
-        for ii, k0 in enumerate(self.lbs):
-
-            km = self.obj.dobj['bsplines'][k0]['mesh']
-            if self.obj.dobj['mesh'][km]['type'] == 'tri':
-                continue
-            elif self.obj.dobj['mesh'][km]['type'] == 'polar':
-                continue
-
-            for comb in itt.product(lop, lgeom, lcrop):
-                deg = self.obj.dobj['bsplines'][k0]['deg']
-
-                if deg == 3 and comb[0] in ['D0N1', 'D0N2', 'D1N2', 'D2N2']:
-                    continue
-
-                # only test exact operators
-                if int(comb[0][1]) > deg:
-                    # except deg = 0 D1N2
-                    if deg == 0 and comb[0] == 'D1N2':
-                        pass
-                    else:
-                        continue
-                try:
-                    self.obj.add_bsplines_operator(
-                        key=k0,
-                        operator=comb[0],
-                        geometry=comb[1],
-                        crop=comb[2],
-                    )
-                except Exception as err:
-                    dfail[k0] = (
-                        f"key {k0}, op '{comb[0]}', geom '{comb[1]}': "
-                        + str(err)
-                    )
-
-        # Raise error if any fail
-        if len(dfail) > 0:
-            lstr = [f'\t- {k0}: {v0}' for k0, v0 in dfail.items()]
-            msg = (
-                "The following operators failed:\n"
-                + "\n".join(lstr)
-            )
-            raise Exception(msg)
+        # li0 = [None, ([1, 2], [2, 1]), (1, 1), [1, 2, 4]]
+        # li1 = [None, [1, 2], (1, 1), [1, 2, 4]]
+        # for ii, k0 in enumerate(self.lbs):
+
+            # km = self.obj.dobj['bsplines'][k0]['mesh']
+            # if len(self.obj.dobj['mesh'][km]['shape-c']) == 2:
+                # li = li0
+            # else:
+                # li = li1
+
+            # if self.obj.dobj['mesh'][km]['type'] == 'polar':
+                # plot_mesh = False
+            # else:
+                # plot_mesh = True
+
+            # dax = self.obj.plot_bsplines(
+                # key=k0,
+                # indbs=li[ii%len(li)],
+                # knots=bool(ii%3),
+                # cents=bool(ii%2),
+                # res=0.05,
+                # plot_mesh=plot_mesh,
+            # )
+            # plt.close('all')
+
+    # def test11_plot_as_profile2d(self):
+
+        # # plotting
+        # for k0 in self.lbs:
+
+            # # fix
+            # k1 = _add_data_fix(self.obj, k0)
+            # dax = self.obj.plot_as_profile2d(key=k1, dres=0.05)
+
+            # # time-variable
+            # k1 = _add_data_var(self.obj, k0)
+            # dax = self.obj.plot_as_profile2d(key=k1, dres=0.05)
+
+            # plt.close('all')
+
+    # def test12_add_bsplines_operator(self):
+        # lkey = ['m0-bs0', 'm1-bs1', 'm2-bs2']
+        # lop = ['D0N1', 'D0N2', 'D1N2', 'D2N2']
+        # lgeom = ['linear', 'toroidal']
+        # lcrop = [False, True]
+
+        # dfail = {}
+        # for ii, k0 in enumerate(self.lbs):
+
+            # km = self.obj.dobj['bsplines'][k0]['mesh']
+            # if self.obj.dobj['mesh'][km]['type'] == 'tri':
+                # continue
+            # elif self.obj.dobj['mesh'][km]['type'] == 'polar':
+                # continue
+
+            # for comb in itt.product(lop, lgeom, lcrop):
+                # deg = self.obj.dobj['bsplines'][k0]['deg']
+
+                # if deg == 3 and comb[0] in ['D0N1', 'D0N2', 'D1N2', 'D2N2']:
+                    # continue
+
+                # # only test exact operators
+                # if int(comb[0][1]) > deg:
+                    # # except deg = 0 D1N2
+                    # if deg == 0 and comb[0] == 'D1N2':
+                        # pass
+                    # else:
+                        # continue
+                # try:
+                    # self.obj.add_bsplines_operator(
+                        # key=k0,
+                        # operator=comb[0],
+                        # geometry=comb[1],
+                        # crop=comb[2],
+                    # )
+                # except Exception as err:
+                    # dfail[k0] = (
+                        # f"key {k0}, op '{comb[0]}', geom '{comb[1]}': "
+                        # + str(err)
+                    # )
+
+        # # Raise error if any fail
+        # if len(dfail) > 0:
+            # lstr = [f'\t- {k0}: {v0}' for k0, v0 in dfail.items()]
+            # msg = (
+                # "The following operators failed:\n"
+                # + "\n".join(lstr)
+            # )
+            # raise Exception(msg)
 
     # TBF for triangular
     # def test13_compute_plot_geometry_matrix(self, kind=None):
 
         # # get config and cam
         # conf = tf.load_config('WEST-V0')
         # cam = tf.geom.utils.create_CamLOS1D(
```

### Comparing `tofu-1.6.5/tofu/tests/tests06_mesh/test_data/ITER_JINTRAC_sh134000_run30_public_edgesources_quadtrimesh.npz` & `tofu-1.7.0/tofu/tests/tests06_mesh/test_data/ITER_JINTRAC_sh134000_run30_public_edgesources_quadtrimesh.npz`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests06_mesh/test_data/mesh_triangular_WEST_eq.txt` & `tofu-1.7.0/tofu/tests/tests06_mesh/test_data/mesh_triangular_WEST_eq.txt`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests07_inversions/test_01_isotropic.py` & `tofu-1.7.0/tofu/tests/tests07_inversions/test_01_isotropic.py`

 * *Files 8% similar despite different names*

```diff
@@ -80,14 +80,15 @@
             focal=0.1,
             pix_size=0.1,
             pix_nb=npix,
             theta=-5*np.pi/6,
             dphi=0,
             tilt=0,
             config=conf0,
+            compute=False,
         )
 
         coll.add_camera_pinhole(
             key='camV',
             key_diag='d0',
             x=3.0,
             y=1.,
@@ -116,15 +117,15 @@
             theta=5*np.pi/6,
             dphi=0,
             tilt=0,
             config=conf0,
         )
 
         # mesh rect deg 1 and 2
-        coll.add_mesh(
+        coll.add_mesh_2d_rect(
             crop_poly=conf0,
             key='m1',
             res=0.10,
             deg=0,
         )
         coll.add_bsplines(deg=1)
         coll.add_bsplines(deg=2)
@@ -133,51 +134,51 @@
         kR, kZ = coll.dobj['mesh']['m1']['knots']
         R, Z = coll.ddata[kR]['data'], coll.ddata[kZ]['data']
         nR, nZ = R.size, Z.size
         R = np.repeat(R[:, None], nZ, axis=1)
         Z = np.repeat(Z[None, :], nR, axis=0)
         rad2d = ((R-2.4)/0.4)**2 + (Z/0.5)**2
         krad = 'rad2d'
-        coll.add_data(key=krad, data=rad2d, ref='m1-bs1')
+        coll.add_data(key=krad, data=rad2d, ref='m1_bs1')
 
         # mesh polar deg 1 and 2
-        coll.add_mesh_polar(
+        coll.add_mesh_1d(
             key='m2',
-            radius=[0, 0.1, 0.2, 0.3, 0.4, 0.5, 1.],
-            radius2d=krad,
+            knots=[0, 0.1, 0.2, 0.3, 0.4, 0.5, 1.],
+            subkey=krad,
             deg=0,
         )
         coll.add_bsplines(key='m2', deg=1)
         coll.add_bsplines(key='m2', deg=2)
 
         # add geometry matrices
         # coll.add_ref(key='chan', data=chan, group='chan')
-        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m1-bs0')
-        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m1-bs1')
-        coll.add_geometry_matrix(key_diag='d1', key_bsplines='m1-bs2')
-        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m2-bs0')
-        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m2-bs1')
-        coll.add_geometry_matrix(key_diag='d1', key_bsplines='m2-bs2')
+        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m1_bs0')
+        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m1_bs1')
+        coll.add_geometry_matrix(key_diag='d1', key_bsplines='m1_bs2')
+        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m2_bs0')
+        coll.add_geometry_matrix(key_diag='d0', key_bsplines='m2_bs1')
+        coll.add_geometry_matrix(key_diag='d1', key_bsplines='m2_bs2')
 
         # add emiss
         t0 = np.array([0, 1])
-        kap = coll.dobj['bsplines']['m2-bs1']['apex'][0]
+        kap = coll.dobj['bsplines']['m2_bs1']['apex'][0]
         rad = coll.ddata[kap]['data']
         emiss = (
             np.exp(-(rad)**2/0.2**2)
             + 0.1*np.cos(t0)[:, None]*np.exp(-rad**2/0.05**2)
         )
 
         coll.add_ref(key='nt0', size=2)
-        coll.add_data(key='t0', data=t0, dim='time', ref='nt0')
+        coll.add_data(key='t0', data=t0, dim='time', ref='nt0', units='s')
         coll.add_data(
             key='emiss',
             data=emiss,
-            ref=('nt0', 'm2-bs1'),
-            units='W/m3/sr',
+            ref=('nt0', 'm2_bs1'),
+            units='W/(m3.sr)',
         )
 
         # add synthetic data
         coll.compute_diagnostic_signal(
             key='s0',
             key_diag='d0',
             key_integrand='emiss',
@@ -202,58 +203,63 @@
 
     def test01_run_all_and_plot(self):
 
         dalgo = tf.data.get_available_inversions_algo(returnas=dict)
         lstore = [True, False]
 
         # running
-        for kmat in self.coll.dobj['geom matrix'].keys():
+        lkmat = list(self.coll.dobj['geom matrix'].keys())
+        for ii, kmat in enumerate(lkmat):
 
             kbs = self.coll.dobj['geom matrix'][kmat]['bsplines']
             kd = self.coll.dobj['geom matrix'][kmat]['diagnostic']
             km = self.coll.dobj['bsplines'][kbs]['mesh']
+            nd = self.coll.dobj['mesh'][km]['nd']
             mtype = self.coll.dobj['mesh'][km]['type']
+            submesh = self.coll.dobj['mesh'][km]['submesh']
             deg = self.coll.dobj['bsplines'][kbs]['deg']
 
             if deg in [0, 1]:
                 lop = ['D1N2']
             else:
                 lop = ['D1N2', 'D2N2']
 
-            for comb in itt.product(dalgo.keys(), lop, lstore):
+            for jj, comb in enumerate(itt.product(dalgo.keys(), lop)):
 
                 if comb[0] == 'algo5':
                     continue
 
-                if comb[2] == 'D2N2' and deg != 2:
+                if comb[1] == 'D2N2' and deg != 2:
                     continue
 
                 if 'mfr' in comb[0].lower() and deg != 0:
                     continue
 
                 algofam = dalgo[comb[0]]['family']
-                if algofam == 'Non-regularized' and mtype != 'polar':
-                    continue
-                if algofam != 'Non-regularized' and mtype == 'polar':
+                if algofam == 'Non-regularized' and nd != '1d':
                     continue
 
+                if kmat == 'gmat05' and comb == ('algo1', 'D2N2'):
+                    continue
 
                 kdat = 's0' if kd == 'd0' else 's1'
                 try:
 
                     self.coll.add_inversion(
                         algo=comb[0],
                         key_matrix=kmat,
                         key_data=kdat,
                         sigma=0.10,
                         operator=comb[1],
-                        store=comb[2],
-                        conv_crit=1.e-2,
+                        store=jj%2 == 0,
+                        conv_crit=1.e-3,
                         kwdargs={'tol': 1.e-2, 'maxiter': 100},
-                        verb=0,
+                        maxiter_outer=10,
+                        dref_vector={'units': 's'},
+                        verb=1,
                     )
                     ksig = f'{kdat}-sigma'
                     if ksig in self.coll.ddata.keys():
                         self.coll.remove_data(ksig)
 
                 except Exception as err:
                     c0 = (
@@ -267,10 +273,13 @@
                         pass
                     else:
                         raise err
 
         # plotting
         linv = list(self.coll.dobj['inversions'].keys())[::7]
         for kinv in linv:
-            dax = self.coll.plot_inversion(key=kinv, res=0.1)
-
-        plt.close('all')
+            dax = self.coll.plot_inversion(
+                key=kinv,
+                res=0.1,
+                dref_vector={'units': 's'},
+            )
+            plt.close('all')
```

### Comparing `tofu-1.6.5/tofu/tests/tests08_diagnostics/test_01_diagnostics.py` & `tofu-1.7.0/tofu/tests/tests08_diagnostics/test_01_diagnostics.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 This module contains tests for tofu.geom in its structured version
 """
 
 
 # Built-in
 import sys
 import os
-import warnings
+import copy
 
 
 # Standard
 import numpy as np
 import matplotlib.pyplot as plt
 
 
@@ -261,15 +261,15 @@
             'e0_y': e0s[0, 1],
             'e0_z': e0s[0, 2],
             'e1_x': e1s[0, 0],
             'e1_y': e1s[0, 1],
             'e1_z': e1s[0, 2],
         },
         'dmat': {
-            'energy': np.linspace(1, 10, 100)*1e3,
+            'qeff_E': np.linspace(1, 10, 100)*1e3,
             'qeff': 0.99*np.ones((100,)),
         },
     }
 
     # c2: 2d
     out0 = 0.005 * np.r_[-1, 1, 1, -1]
     out1 = 0.005 * np.r_[-1, -1, 1, 1]
@@ -295,15 +295,25 @@
             'cents_x1': cent1,
             'nin': nin,
             'e0': e0,
             'e1': e1,
         },
     }
 
-    return {'cam0': c0, 'cam1': c1, 'cam2': c2}
+    return {
+        'cam0': c0,
+        'cam1': c1,
+        'cam2': c2,
+        'cam00': copy.deepcopy(c0),
+        'cam11': copy.deepcopy(c1),
+        'cam22': copy.deepcopy(c2),
+        'cam000': copy.deepcopy(c0),
+        'cam111': copy.deepcopy(c1),
+        'cam222': copy.deepcopy(c2),
+    }
 
 
 def _crystals():
 
     start, vect, v0, v1 = _ref_line()
 
     # cryst0: planar
@@ -398,30 +408,30 @@
     # d1: single 2d camera
     d1 = {'doptics': 'cam1', 'resolution': 0.2}
 
     # d2: single 2d camera
     d2 = {'doptics': 'cam2'}
 
     # d3: 1d + 1 aperture
-    d3 = {'doptics': ('cam0', 'ap0')}
+    d3 = {'doptics': ('cam00', 'ap0')}
 
     # d4: 2d + 1 aperture
-    d4 = {'doptics': ('cam1', 'ap0')}
+    d4 = {'doptics': ('cam11', 'ap0')}
 
     # d5: 2d + 1 aperture
-    d5 = {'doptics': ('cam2', 'ap0')}
+    d5 = {'doptics': ('cam22', 'ap0')}
 
     # d6: 1d + multiple apertures
-    d6 = {'doptics': ('cam0', 'ap0', 'filt0', 'ap2')}
+    d6 = {'doptics': ('cam000', 'ap0', 'filt0', 'ap2')}
 
     # d7: 1d parallel coplanar + multiple apertures
-    d7 = {'doptics': ('cam1', 'ap0', 'filt0', 'ap2')}
+    d7 = {'doptics': ('cam111', 'ap0', 'filt0', 'ap2')}
 
     # d8: 2d + multiple apertures
-    d8 = {'doptics': ('cam2', 'ap0', 'filt0', 'ap2')}
+    d8 = {'doptics': ('cam222', 'ap0', 'filt0', 'ap2')}
 
     # # d9: 2d + spherical crystal
     # d9 = {'optics': ('c3','cryst0')}
 
     # # d10: 2d + cylindrical crystal + slit
     # d10 = {'optics': ('c3','cryst1', 'slit0')}
 
@@ -477,22 +487,21 @@
 
         # add filters
         for k0, v0 in dfilters.items():
             self.obj.add_filter(key=k0, **v0)
 
         # add cameras
         for k0, v0 in dcameras.items():
-            if k0 in ['cam0', 'cam1']:
+            if 'cam0' in k0 or 'cam1' in k0:
                 self.obj.add_camera_1d(key=k0, **v0)
             else:
                 self.obj.add_camera_2d(key=k0, **v0)
 
         # add diagnostics
         for k0, v0 in ddiag.items():
-            print(k0)
             self.obj.add_diagnostic(
                 key=k0,
                 config=conf,
                 reflections_nb=2,
                 reflections_type='specular',
                 **v0,
             )
@@ -532,15 +541,14 @@
                 if gtype not in ['toroidal']:
                     self.doptics.update({
                         f'{k0}-{ii}': loptics,
                     })
 
         # add crystal optics
         for k0, v0 in self.doptics.items():
-            print(k0, 'spectro')
             self.obj.add_diagnostic(
                 doptics=v0,
                 config=self.conf,
             )
         # add toroidal
         # self.obj.add_diagnostic(optics=['cryst2-cam0', 'cryst3'])
 
@@ -574,11 +582,17 @@
             dout = self.obj.get_optics_outline(k0)
 
         # crystals
         for k0, v0 in self.obj.dobj['crystal'].items():
             dout = self.obj.get_optics_outline(k0)
 
     def test03_plot(self):
-        for k0, v0 in self.obj.dobj['diagnostic'].items():
-            for pp in [None, 'cross', ['cross', 'hor']]:
-                dax = self.obj.plot_diagnostic(k0, proj=pp)
+        for ii, (k0, v0) in enumerate(self.obj.dobj['diagnostic'].items()):
+            dax = self.obj.plot_diagnostic(
+                k0,
+                proj=(
+                    None if ii % 3 == 0
+                    else ('cross' if ii % 3 == 1 else ['cross', 'hor'])
+                ),
+            )
             plt.close('all')
+            del dax
```

### Comparing `tofu-1.6.5/tofu/tests/tests09_tutorials/test_01_runall.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/test_01_runall.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 
 #######################################################
 #
 #     Setup and Teardown
 #
 #######################################################
 
+
 def setup_module(module, here=_HERE):
     print("")   # this is to get a newline after the dots
     lf = os.listdir(here)
     lf = [f for f in lf
           if all([s in f for s in ['.npz']])]
     lF = []
     for f in lf:
@@ -136,16 +137,19 @@
             msg = str(error)
             raise Exception(msg)
         plt.close('all')
 
         # Remove temporary files and saved files
         os.remove(target)
         stdout = out.stdout.decode().split('\n')
-        lf = [stdout[ii].strip() for ii in range(len(stdout))
-              if 'saved' in stdout[ii-1].lower()]
+        lf = [
+            stdout[ii].strip() for ii in range(len(stdout))
+            if 'saved' in stdout[ii-1].lower()
+        ]
+
         for ii in range(len(lf)):
             os.remove(lf[ii])
 
     def test01_plot_basic_tutorial(self):
         self._test_tuto('tuto_plot_basic')
 
     def test02_plot_create_geometry(self):
```

### Comparing `tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_basic.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_basic.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_create_geometry.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_create_geometry.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 """
 
 import numpy as np
 import matplotlib.pyplot as plt
 import tofu.geom as tfg
 
 
-###############################################################################
+####################################################################
 # Creating an empty Vessel
 # ------------------------
 #
 # If a vessel object does not exist yet, you have to create one (otherwise you
 # can just load an existing one).
 # A vessel object is basically defined by a 2D simple polygon
 # (i.e.: non self-intersecting), that is then expanded linearly or toroidally
```

### Comparing `tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_create_geometry_from_svg.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_create_geometry_from_svg.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_custom_emissivity.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_custom_emissivity.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_gallery_fusion_machines.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_gallery_fusion_machines.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tests/tests09_tutorials/tuto_plot_solid_angles.py` & `tofu-1.7.0/tofu/tests/tests09_tutorials/tuto_plot_solid_angles.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/tomotok2tofu/_core.py` & `tofu-1.7.0/tofu/tomotok2tofu/_core.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu/utils.py` & `tofu-1.7.0/tofu/utils.py`

 * *Files identical despite different names*

### Comparing `tofu-1.6.5/tofu.egg-info/PKG-INFO` & `tofu-1.7.0/tofu.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 Metadata-Version: 2.1
 Name: tofu
-Version: 1.6.5
+Version: 1.7.0
 Summary: A python library for Tomography for Fusion
 Home-page: https://github.com/ToFuProject/tofu
 Author: Didier VEZINET and Laura MENDOZA
 Author-email: didier.vezinet@gmail.com
 License: MIT
 Keywords: tomography geometry 3D inversion synthetic fusion
-Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: Topic :: Scientific/Engineering :: Physics
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Natural Language :: English
@@ -164,9 +163,7 @@
 **Warning**
 This Pypi package focuses on tomography for fusion research.
 It uses the same name as a previous package dedicated to a testing framework
 coupling fixtures and tests loosely, now renamed **reahl-tofu** and developped
 by Iwan Vosloo since 2006. If you ended up here looking for a web-oriented
 library, you should probably redirect to the more recent
 [**reahl-tofu**](https://pypi.python.org/pypi/reahl-tofu) page.
-
-
```

### Comparing `tofu-1.6.5/tofu.egg-info/SOURCES.txt` & `tofu-1.7.0/tofu.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -42,70 +42,68 @@
 tofu/data/_DataCollection_interactivity.py
 tofu/data/_DataCollection_plot_as_array.py
 tofu/data/_DataCollection_plot_misc.py
 tofu/data/_DataCollection_plot_text.py
 tofu/data/__init__.py
 tofu/data/_class00_Config.py
 tofu/data/_class01_Plasma2D.py
+tofu/data/_class01_compute.py
 tofu/data/_class02_Rays.py
 tofu/data/_class03_Aperture.py
 tofu/data/_class04_Filter.py
 tofu/data/_class05_Crystal.py
 tofu/data/_class06_Grating.py
+tofu/data/_class06_compute.py
 tofu/data/_class07_Camera.py
 tofu/data/_class08_Diagnostic.py
 tofu/data/_class09_GeometryMatrix.py
 tofu/data/_class10_Inversion.py
 tofu/data/_class10_algos.py
 tofu/data/_class10_checks.py
 tofu/data/_class10_compute.py
 tofu/data/_class10_plot.py
-tofu/data/_class1_bsplines_operators_rect.py
-tofu/data/_class1_bsplines_operators_tri.py
-tofu/data/_class1_bsplines_polar.py
-tofu/data/_class1_bsplines_rect.py
-tofu/data/_class1_bsplines_tri.py
-tofu/data/_class1_checks.py
-tofu/data/_class1_compute.py
-tofu/data/_class1_plot.py
+tofu/data/_class10_refs.py
 tofu/data/_class2_check.py
 tofu/data/_class2_compute.py
 tofu/data/_class2_plot.py
 tofu/data/_class3_check.py
 tofu/data/_class4_check.py
 tofu/data/_class5_check.py
 tofu/data/_class5_compute.py
 tofu/data/_class5_coordinates.py
+tofu/data/_class5_plot.py
 tofu/data/_class5_projections.py
 tofu/data/_class5_reflections_pts2pt.py
 tofu/data/_class5_reflections_ptsvect.py
 tofu/data/_class7_check.py
 tofu/data/_class7_compute.py
 tofu/data/_class8_check.py
 tofu/data/_class8_compute.py
 tofu/data/_class8_compute_signal.py
 tofu/data/_class8_equivalent_apertures.py
 tofu/data/_class8_etendue_los.py
 tofu/data/_class8_los_angles.py
 tofu/data/_class8_los_data.py
 tofu/data/_class8_move.py
 tofu/data/_class8_plot.py
+tofu/data/_class8_vos.py
 tofu/data/_class9_compute.py
 tofu/data/_class9_plot.py
 tofu/data/_comp.py
 tofu/data/_core.py
 tofu/data/_core_plot.py
 tofu/data/_def.py
 tofu/data/_generic_check.py
 tofu/data/_generic_plot.py
 tofu/data/_plot.py
 tofu/data/_spectrallines_checks.py
 tofu/data/_spectrallines_class.py
 tofu/data/_spectrallines_compute.py
 tofu/data/_spectrallines_plot.py
+tofu/data/_spectralunits.py
 tofu/data/_utils_bsplines.py
 tofu/data/_utils_surface3d.py
 tofu/dumpro/__init__.py
 tofu/dumpro/_comp.py
 tofu/dumpro/_comp_clusters.py
 tofu/dumpro/_core.py
 tofu/dumpro/_def.py
@@ -562,11 +560,12 @@
 tofu/tests/tests09_tutorials/test_01_runall.py
 tofu/tests/tests09_tutorials/tuto_plot_basic.py
 tofu/tests/tests09_tutorials/tuto_plot_create_geometry.py
 tofu/tests/tests09_tutorials/tuto_plot_create_geometry_from_svg.py
 tofu/tests/tests09_tutorials/tuto_plot_custom_emissivity.py
 tofu/tests/tests09_tutorials/tuto_plot_gallery_fusion_machines.py
 tofu/tests/tests09_tutorials/tuto_plot_solid_angles.py
+tofu/tests/tests09_tutorials/tuto_real0.py
 tofu/tomotok2tofu/__init__.py
 tofu/tomotok2tofu/_core.py
 tofu_helpers/__init__.py
 tofu_helpers/openmp_helpers.py
```

### Comparing `tofu-1.6.5/tofu_helpers/openmp_helpers.py` & `tofu-1.7.0/tofu_helpers/openmp_helpers.py`

 * *Files identical despite different names*

