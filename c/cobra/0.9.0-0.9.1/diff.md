# Comparing `tmp/cobra-0.9.0.win-amd64-py3.6.exe` & `tmp/cobra-0.9.1.win-amd64-py3.6.exe`

## zipinfo {}

```diff
@@ -1,106 +1,107 @@
-Zip file size: 2528094 bytes, number of entries: 102
+Zip file size: 2529629 bytes, number of entries: 103
 warning: 597290 extra bytes at beginning or within zipfile
   (attempting to process anyway)
--rw-rw-rw-  2.0 fat      161 b- defN 17-Oct-10 16:24 PLATLIB/cobra/config.py
--rw-rw-rw-  2.0 fat     1515 b- defN 17-Oct-10 16:24 PLATLIB/cobra/exceptions.py
--rw-rw-rw-  2.0 fat      943 b- defN 17-Oct-10 16:24 PLATLIB/cobra/__init__.py
--rw-rw-rw-  2.0 fat    16924 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/arraybasedmodel.py
--rw-rw-rw-  2.0 fat    14903 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/dictlist.py
--rw-rw-rw-  2.0 fat     5587 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/formula.py
--rw-rw-rw-  2.0 fat     9762 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/gene.py
--rw-rw-rw-  2.0 fat    10002 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/metabolite.py
--rw-rw-rw-  2.0 fat    42877 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/model.py
--rw-rw-rw-  2.0 fat     1347 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/object.py
--rw-rw-rw-  2.0 fat    41167 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/reaction.py
--rw-rw-rw-  2.0 fat    10636 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/solution.py
--rw-rw-rw-  2.0 fat     1337 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/species.py
--rw-rw-rw-  2.0 fat      407 b- defN 17-Oct-10 16:24 PLATLIB/cobra/core/__init__.py
--rw-rw-rw-  2.0 fat      429 b- defN 17-Oct-10 16:24 PLATLIB/cobra/design/design_algorithms.py
--rw-rw-rw-  2.0 fat      110 b- defN 17-Oct-10 16:24 PLATLIB/cobra/design/__init__.py
--rw-rw-rw-  2.0 fat     6066 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/deletion_worker.py
--rw-rw-rw-  2.0 fat    23220 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/double_deletion.py
--rw-rw-rw-  2.0 fat    14109 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/gapfilling.py
--rw-rw-rw-  2.0 fat    11834 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/loopless.py
--rw-rw-rw-  2.0 fat     8084 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/moma.py
--rw-rw-rw-  2.0 fat     9626 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/parsimonious.py
--rw-rw-rw-  2.0 fat    23273 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/phenotype_phase_plane.py
--rw-rw-rw-  2.0 fat     8246 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/reaction.py
--rw-rw-rw-  2.0 fat    32584 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/sampling.py
--rw-rw-rw-  2.0 fat    13965 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/single_deletion.py
--rw-rw-rw-  2.0 fat    10575 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/summary.py
--rw-rw-rw-  2.0 fat    15319 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/variability.py
--rw-rw-rw-  2.0 fat      822 b- defN 17-Oct-10 16:24 PLATLIB/cobra/flux_analysis/__init__.py
--rw-rw-rw-  2.0 fat     7037 b- defN 17-Oct-10 16:24 PLATLIB/cobra/io/dict.py
--rw-rw-rw-  2.0 fat     6816 b- defN 17-Oct-10 16:24 PLATLIB/cobra/io/json.py
--rw-rw-rw-  2.0 fat    11174 b- defN 17-Oct-10 16:24 PLATLIB/cobra/io/mat.py
--rw-rw-rw-  2.0 fat    32887 b- defN 17-Oct-10 16:24 PLATLIB/cobra/io/sbml.py
--rw-rw-rw-  2.0 fat    30013 b- defN 17-Oct-10 16:24 PLATLIB/cobra/io/sbml3.py
--rw-rw-rw-  2.0 fat     2765 b- defN 17-Oct-10 16:24 PLATLIB/cobra/io/yaml.py
--rw-rw-rw-  2.0 fat      546 b- defN 17-Oct-10 16:24 PLATLIB/cobra/io/__init__.py
--rw-rw-rw-  2.0 fat      872 b- defN 17-Oct-10 16:24 PLATLIB/cobra/manipulation/annotate.py
--rw-rw-rw-  2.0 fat     8365 b- defN 17-Oct-10 16:24 PLATLIB/cobra/manipulation/delete.py
--rw-rw-rw-  2.0 fat     9924 b- defN 17-Oct-10 16:24 PLATLIB/cobra/manipulation/modify.py
--rw-rw-rw-  2.0 fat     2116 b- defN 17-Oct-10 16:24 PLATLIB/cobra/manipulation/validate.py
--rw-rw-rw-  2.0 fat      534 b- defN 17-Oct-10 16:24 PLATLIB/cobra/manipulation/__init__.py
--rw-rw-rw-  2.0 fat   613376 b- defN 17-Oct-10 16:26 PLATLIB/cobra/solvers/cglpk.cp36-win_amd64.pyd
--rw-rw-rw-  2.0 fat     4311 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/coin.py
--rw-rw-rw-  2.0 fat    13312 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/cplex_solver.py
--rw-rw-rw-  2.0 fat    11827 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/cplex_solver_java.py
--rw-rw-rw-  2.0 fat     6418 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/esolver.py
--rw-rw-rw-  2.0 fat     9716 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/glpk_solver.py
--rw-rw-rw-  2.0 fat    14314 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/glpk_solver_java.py
--rw-rw-rw-  2.0 fat    10596 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/gurobi_solver.py
--rw-rw-rw-  2.0 fat    10677 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/gurobi_solver_java.py
--rw-rw-rw-  2.0 fat     8665 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/mosek.py
--rw-rw-rw-  2.0 fat     7806 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/parameters.py
--rw-rw-rw-  2.0 fat     1179 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/wrappers.py
--rw-rw-rw-  2.0 fat     4335 b- defN 17-Oct-10 16:24 PLATLIB/cobra/solvers/__init__.py
--rw-rw-rw-  2.0 fat     3195 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/conftest.py
--rw-rw-rw-  2.0 fat    36752 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_flux_analysis.py
--rw-rw-rw-  2.0 fat     9914 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_io.py
--rw-rw-rw-  2.0 fat    11912 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_manipulation.py
--rw-rw-rw-  2.0 fat    45039 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_model.py
--rw-rw-rw-  2.0 fat    11462 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_solvers.py
--rw-rw-rw-  2.0 fat    35202 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_solver_model.py
--rw-rw-rw-  2.0 fat     5260 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_solver_utils.py
--rw-rw-rw-  2.0 fat    12824 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/test_util.py
--rw-rw-rw-  2.0 fat     1721 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/__init__.py
--rw-rw-rw-  2.0 fat  1810487 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/iJO1366.pickle
--rw-rw-rw-  2.0 fat  2582732 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/iJO1366.xml
--rw-rw-rw-  2.0 fat     2992 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/invalid0.xml
--rw-rw-rw-  2.0 fat     2490 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/invalid1.xml
--rw-rw-rw-  2.0 fat     4097 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/invalid2.xml
--rw-rw-rw-  2.0 fat    40521 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini.json
--rw-rw-rw-  2.0 fat    17688 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini.mat
--rw-rw-rw-  2.0 fat    33312 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini.pickle
--rw-rw-rw-  2.0 fat    24829 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini.yml
--rw-rw-rw-  2.0 fat    26846 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini_cobra.xml
--rw-rw-rw-  2.0 fat    29370 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini_fbc1.xml
--rw-rw-rw-  2.0 fat    92704 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini_fbc2.xml
--rw-rw-rw-  2.0 fat     5016 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini_fbc2.xml.bz2
--rw-rw-rw-  2.0 fat     5729 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/mini_fbc2.xml.gz
--rw-rw-rw-  2.0 fat     2519 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/raven.mat
--rw-rw-rw-  2.0 fat    13310 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/raven.pickle
--rw-rw-rw-  2.0 fat    38666 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/salmonella.genes
--rw-rw-rw-  2.0 fat     4651 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/salmonella.media
--rw-rw-rw-  2.0 fat  2151186 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/salmonella.pickle
--rw-rw-rw-  2.0 fat  3974248 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/salmonella.xml
--rw-rw-rw-  2.0 fat    16890 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/textbook.xml.gz
--rw-rw-rw-  2.0 fat     3231 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/textbook_fva.json
--rw-rw-rw-  2.0 fat     3232 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/textbook_pfba_fva.json
--rw-rw-rw-  2.0 fat     7330 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/textbook_solution.pickle
--rw-rw-rw-  2.0 fat     4077 b- defN 17-Oct-10 16:24 PLATLIB/cobra/test/data/update_pickles.py
--rw-rw-rw-  2.0 fat      217 b- defN 17-Oct-10 16:24 PLATLIB/cobra/topology/reporter_metabolites.py
--rw-rw-rw-  2.0 fat      143 b- defN 17-Oct-10 16:24 PLATLIB/cobra/topology/__init__.py
--rw-rw-rw-  2.0 fat     7168 b- defN 17-Oct-10 16:24 PLATLIB/cobra/util/array.py
--rw-rw-rw-  2.0 fat     1759 b- defN 17-Oct-10 16:24 PLATLIB/cobra/util/context.py
--rw-rw-rw-  2.0 fat    15426 b- defN 17-Oct-10 16:24 PLATLIB/cobra/util/solver.py
--rw-rw-rw-  2.0 fat      568 b- defN 17-Oct-10 16:24 PLATLIB/cobra/util/util.py
--rw-rw-rw-  2.0 fat     1926 b- defN 17-Oct-10 16:24 PLATLIB/cobra/util/version_info.py
--rw-rw-rw-  2.0 fat      191 b- defN 17-Oct-10 16:24 PLATLIB/cobra/util/__init__.py
--rw-rw-rw-  2.0 fat        1 b- defN 17-Oct-10 16:26 PLATLIB/cobra-0.9.0-py3.6.egg-info/dependency_links.txt
--rw-rw-rw-  2.0 fat    12058 b- defN 17-Oct-10 16:26 PLATLIB/cobra-0.9.0-py3.6.egg-info/PKG-INFO
--rw-rw-rw-  2.0 fat      276 b- defN 17-Oct-10 16:26 PLATLIB/cobra-0.9.0-py3.6.egg-info/requires.txt
--rw-rw-rw-  2.0 fat     2978 b- defN 17-Oct-10 16:26 PLATLIB/cobra-0.9.0-py3.6.egg-info/SOURCES.txt
--rw-rw-rw-  2.0 fat       10 b- defN 17-Oct-10 16:26 PLATLIB/cobra-0.9.0-py3.6.egg-info/top_level.txt
-102 files, 12279566 bytes uncompressed, 1915752 bytes compressed:  84.4%
+-rw-rw-rw-  2.0 fat      161 b- defN 17-Oct-30 10:52 PLATLIB/cobra/config.py
+-rw-rw-rw-  2.0 fat     1515 b- defN 17-Oct-30 10:52 PLATLIB/cobra/exceptions.py
+-rw-rw-rw-  2.0 fat      943 b- defN 17-Oct-30 10:52 PLATLIB/cobra/__init__.py
+-rw-rw-rw-  2.0 fat    16924 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/arraybasedmodel.py
+-rw-rw-rw-  2.0 fat    14903 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/dictlist.py
+-rw-rw-rw-  2.0 fat     5587 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/formula.py
+-rw-rw-rw-  2.0 fat     9762 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/gene.py
+-rw-rw-rw-  2.0 fat    10002 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/metabolite.py
+-rw-rw-rw-  2.0 fat    42670 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/model.py
+-rw-rw-rw-  2.0 fat     1347 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/object.py
+-rw-rw-rw-  2.0 fat    41166 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/reaction.py
+-rw-rw-rw-  2.0 fat    10636 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/solution.py
+-rw-rw-rw-  2.0 fat     1337 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/species.py
+-rw-rw-rw-  2.0 fat      407 b- defN 17-Oct-30 10:52 PLATLIB/cobra/core/__init__.py
+-rw-rw-rw-  2.0 fat      429 b- defN 17-Oct-30 10:52 PLATLIB/cobra/design/design_algorithms.py
+-rw-rw-rw-  2.0 fat      110 b- defN 17-Oct-30 10:52 PLATLIB/cobra/design/__init__.py
+-rw-rw-rw-  2.0 fat     6066 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/deletion_worker.py
+-rw-rw-rw-  2.0 fat    23220 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/double_deletion.py
+-rw-rw-rw-  2.0 fat    14121 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/gapfilling.py
+-rw-rw-rw-  2.0 fat    11830 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/loopless.py
+-rw-rw-rw-  2.0 fat     8082 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/moma.py
+-rw-rw-rw-  2.0 fat     9553 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/parsimonious.py
+-rw-rw-rw-  2.0 fat    23273 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/phenotype_phase_plane.py
+-rw-rw-rw-  2.0 fat     8246 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/reaction.py
+-rw-rw-rw-  2.0 fat    32582 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/sampling.py
+-rw-rw-rw-  2.0 fat    13965 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/single_deletion.py
+-rw-rw-rw-  2.0 fat    10575 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/summary.py
+-rw-rw-rw-  2.0 fat    15317 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/variability.py
+-rw-rw-rw-  2.0 fat      822 b- defN 17-Oct-30 10:52 PLATLIB/cobra/flux_analysis/__init__.py
+-rw-rw-rw-  2.0 fat     7287 b- defN 17-Oct-30 10:52 PLATLIB/cobra/io/dict.py
+-rw-rw-rw-  2.0 fat     7142 b- defN 17-Oct-30 10:52 PLATLIB/cobra/io/json.py
+-rw-rw-rw-  2.0 fat    11174 b- defN 17-Oct-30 10:52 PLATLIB/cobra/io/mat.py
+-rw-rw-rw-  2.0 fat    32887 b- defN 17-Oct-30 10:52 PLATLIB/cobra/io/sbml.py
+-rw-rw-rw-  2.0 fat    30025 b- defN 17-Oct-30 10:52 PLATLIB/cobra/io/sbml3.py
+-rw-rw-rw-  2.0 fat     3091 b- defN 17-Oct-30 10:52 PLATLIB/cobra/io/yaml.py
+-rw-rw-rw-  2.0 fat      546 b- defN 17-Oct-30 10:52 PLATLIB/cobra/io/__init__.py
+-rw-rw-rw-  2.0 fat      872 b- defN 17-Oct-30 10:52 PLATLIB/cobra/manipulation/annotate.py
+-rw-rw-rw-  2.0 fat     8365 b- defN 17-Oct-30 10:52 PLATLIB/cobra/manipulation/delete.py
+-rw-rw-rw-  2.0 fat     9924 b- defN 17-Oct-30 10:52 PLATLIB/cobra/manipulation/modify.py
+-rw-rw-rw-  2.0 fat     2116 b- defN 17-Oct-30 10:52 PLATLIB/cobra/manipulation/validate.py
+-rw-rw-rw-  2.0 fat      534 b- defN 17-Oct-30 10:52 PLATLIB/cobra/manipulation/__init__.py
+-rw-rw-rw-  2.0 fat   613376 b- defN 17-Oct-30 10:54 PLATLIB/cobra/solvers/cglpk.cp36-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     4311 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/coin.py
+-rw-rw-rw-  2.0 fat    13324 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/cplex_solver.py
+-rw-rw-rw-  2.0 fat    11827 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/cplex_solver_java.py
+-rw-rw-rw-  2.0 fat     6418 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/esolver.py
+-rw-rw-rw-  2.0 fat     9716 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/glpk_solver.py
+-rw-rw-rw-  2.0 fat    14314 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/glpk_solver_java.py
+-rw-rw-rw-  2.0 fat    10608 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/gurobi_solver.py
+-rw-rw-rw-  2.0 fat    10677 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/gurobi_solver_java.py
+-rw-rw-rw-  2.0 fat     8665 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/mosek.py
+-rw-rw-rw-  2.0 fat     7806 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/parameters.py
+-rw-rw-rw-  2.0 fat     1179 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/wrappers.py
+-rw-rw-rw-  2.0 fat     4335 b- defN 17-Oct-30 10:52 PLATLIB/cobra/solvers/__init__.py
+-rw-rw-rw-  2.0 fat     3195 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/conftest.py
+-rw-rw-rw-  2.0 fat    36752 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_flux_analysis.py
+-rw-rw-rw-  2.0 fat     9976 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_io.py
+-rw-rw-rw-  2.0 fat     3092 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_io_order.py
+-rw-rw-rw-  2.0 fat    11912 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_manipulation.py
+-rw-rw-rw-  2.0 fat    45108 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_model.py
+-rw-rw-rw-  2.0 fat    11462 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_solvers.py
+-rw-rw-rw-  2.0 fat    36616 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_solver_model.py
+-rw-rw-rw-  2.0 fat     5260 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_solver_utils.py
+-rw-rw-rw-  2.0 fat    12824 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/test_util.py
+-rw-rw-rw-  2.0 fat     1721 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/__init__.py
+-rw-rw-rw-  2.0 fat  1810487 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/iJO1366.pickle
+-rw-rw-rw-  2.0 fat  2582732 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/iJO1366.xml
+-rw-rw-rw-  2.0 fat     2992 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/invalid0.xml
+-rw-rw-rw-  2.0 fat     2490 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/invalid1.xml
+-rw-rw-rw-  2.0 fat     4097 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/invalid2.xml
+-rw-rw-rw-  2.0 fat    40521 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini.json
+-rw-rw-rw-  2.0 fat    17688 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini.mat
+-rw-rw-rw-  2.0 fat    33312 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini.pickle
+-rw-rw-rw-  2.0 fat    24829 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini.yml
+-rw-rw-rw-  2.0 fat    26846 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini_cobra.xml
+-rw-rw-rw-  2.0 fat    29370 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini_fbc1.xml
+-rw-rw-rw-  2.0 fat    92704 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini_fbc2.xml
+-rw-rw-rw-  2.0 fat     5016 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini_fbc2.xml.bz2
+-rw-rw-rw-  2.0 fat     5729 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/mini_fbc2.xml.gz
+-rw-rw-rw-  2.0 fat     2519 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/raven.mat
+-rw-rw-rw-  2.0 fat    13310 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/raven.pickle
+-rw-rw-rw-  2.0 fat    38666 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/salmonella.genes
+-rw-rw-rw-  2.0 fat     4651 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/salmonella.media
+-rw-rw-rw-  2.0 fat  2151186 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/salmonella.pickle
+-rw-rw-rw-  2.0 fat  3974248 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/salmonella.xml
+-rw-rw-rw-  2.0 fat    16890 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/textbook.xml.gz
+-rw-rw-rw-  2.0 fat     3231 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/textbook_fva.json
+-rw-rw-rw-  2.0 fat     3232 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/textbook_pfba_fva.json
+-rw-rw-rw-  2.0 fat     7330 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/textbook_solution.pickle
+-rw-rw-rw-  2.0 fat     4077 b- defN 17-Oct-30 10:52 PLATLIB/cobra/test/data/update_pickles.py
+-rw-rw-rw-  2.0 fat      217 b- defN 17-Oct-30 10:52 PLATLIB/cobra/topology/reporter_metabolites.py
+-rw-rw-rw-  2.0 fat      143 b- defN 17-Oct-30 10:52 PLATLIB/cobra/topology/__init__.py
+-rw-rw-rw-  2.0 fat     7168 b- defN 17-Oct-30 10:52 PLATLIB/cobra/util/array.py
+-rw-rw-rw-  2.0 fat     1759 b- defN 17-Oct-30 10:52 PLATLIB/cobra/util/context.py
+-rw-rw-rw-  2.0 fat    15435 b- defN 17-Oct-30 10:52 PLATLIB/cobra/util/solver.py
+-rw-rw-rw-  2.0 fat      568 b- defN 17-Oct-30 10:52 PLATLIB/cobra/util/util.py
+-rw-rw-rw-  2.0 fat     1926 b- defN 17-Oct-30 10:52 PLATLIB/cobra/util/version_info.py
+-rw-rw-rw-  2.0 fat      191 b- defN 17-Oct-30 10:52 PLATLIB/cobra/util/__init__.py
+-rw-rw-rw-  2.0 fat        1 b- defN 17-Oct-30 10:54 PLATLIB/cobra-0.9.1-py3.6.egg-info/dependency_links.txt
+-rw-rw-rw-  2.0 fat    12058 b- defN 17-Oct-30 10:54 PLATLIB/cobra-0.9.1-py3.6.egg-info/PKG-INFO
+-rw-rw-rw-  2.0 fat      276 b- defN 17-Oct-30 10:54 PLATLIB/cobra-0.9.1-py3.6.egg-info/requires.txt
+-rw-rw-rw-  2.0 fat     3006 b- defN 17-Oct-30 10:54 PLATLIB/cobra-0.9.1-py3.6.egg-info/SOURCES.txt
+-rw-rw-rw-  2.0 fat       10 b- defN 17-Oct-30 10:54 PLATLIB/cobra-0.9.1-py3.6.egg-info/top_level.txt
+103 files, 12284899 bytes uncompressed, 1917141 bytes compressed:  84.4%
```

## PLATLIB/cobra/__init__.py

```diff
@@ -9,15 +9,15 @@
 from os.path import dirname as _dirname
 
 from cobra import design, flux_analysis, io
 from cobra.core import (
     DictList, Gene, Metabolite, Model, Object, Reaction, Species)
 from cobra.util.version_info import show_versions
 
-__version__ = "0.9.0"
+__version__ = "0.9.1"
 
 # set the warning format to be prettier and fit on one line
 _cobra_path = _dirname(_abspath(__file__))
 if _name == "posix":
     _warning_base = "%s:%s \x1b[1;31m%s\x1b[0m: %s\n"  # colors
 else:
     _warning_base = "%s:%s %s: %s\n"
```

## PLATLIB/cobra/core/model.py

```diff
@@ -5,18 +5,17 @@
 import types
 import logging
 from copy import copy, deepcopy
 from functools import partial
 from warnings import warn
 
 import optlang
+from optlang.symbolics import Basic, Zero
 import six
-import sympy
 from six import iteritems, string_types
-from sympy import S
 
 from cobra.core.dictlist import DictList
 from cobra.core.object import Object
 from cobra.core.reaction import separate_forward_and_reverse_bounds, Reaction
 from cobra.core.solution import get_solution
 from cobra.solvers import optimize
 from cobra.util.context import HistoryManager, resettable, get_context
@@ -97,15 +96,15 @@
 
             # from cameo ...
 
             # if not hasattr(self, '_solver'):  # backwards compatibility
             # with older cobrapy pickles?
             interface = solvers[get_solver_name()]
             self._solver = interface.Model()
-            self._solver.objective = interface.Objective(S.Zero)
+            self._solver.objective = interface.Objective(Zero)
             self._populate_solver(self.reactions, self.metabolites)
 
     @property
     def solver(self):
         """Get or set the attached solver instance.
 
         The associated the solver object, which manages the interaction with
@@ -364,15 +363,15 @@
         self.metabolites += metabolite_list
 
         # from cameo ...
         to_add = []
         for met in metabolite_list:
             if met.id not in self.constraints:
                 constraint = self.problem.Constraint(
-                    S.Zero, name=met.id, lb=0, ub=0)
+                    Zero, name=met.id, lb=0, ub=0)
                 to_add += [constraint]
 
         self.add_cons_vars(to_add)
 
         context = get_context(self)
         if context:
             context(partial(self.metabolites.__isub__, metabolite_list))
@@ -519,42 +518,38 @@
         The change is reverted upon exit when using the model as a context.
 
         Parameters
         ----------
         reaction_list : list
             A list of `cobra.Reaction` objects
         """
+        def existing_filter(rxn):
+            if rxn.id in self.reactions:
+                LOGGER.warning(
+                    "Ignoring reaction '%s' since it already exists.", rxn.id)
+                return False
+            return True
 
-        try:
-            reaction_list = DictList(reaction_list)
-        except TypeError:
-            reaction_list = DictList([reaction_list])
-
-        # First check whether the metabolites exist in the model
-        existing = [rxn for rxn in reaction_list if rxn.id in self.reactions]
-        for rxn in existing:
-            LOGGER.info('skip adding reaction %s as already existing', rxn.id)
-        reaction_list = [rxn for rxn in reaction_list
-                         if rxn.id not in existing]
+        # First check whether the reactions exist in the model.
+        pruned = DictList(filter(existing_filter, reaction_list))
 
         context = get_context(self)
 
-        # Add reactions. Also take care of genes and metabolites in the loop
-        for reaction in reaction_list:
-            reaction._model = self  # the reaction now points to the model
-            # keys() is necessary because the dict will be modified during
-            # the loop
-            for metabolite in list(reaction._metabolites.keys()):
-                # if the metabolite is not in the model, add it
-                # should we be adding a copy instead.
+        # Add reactions. Also take care of genes and metabolites in the loop.
+        for reaction in pruned:
+            reaction._model = self
+            # Build a `list()` because the dict will be modified in the loop.
+            for metabolite in list(reaction.metabolites):
+                # TODO: Should we add a copy of the metabolite instead?
                 if metabolite not in self.metabolites:
                     self.add_metabolites(metabolite)
                 # A copy of the metabolite exists in the model, the reaction
                 # needs to point to the metabolite in the model.
                 else:
+                    # FIXME: Modifying 'private' attributes is horrible.
                     stoichiometry = reaction._metabolites.pop(metabolite)
                     model_metabolite = self.metabolites.get_by_id(
                         metabolite.id)
                     reaction._metabolites[model_metabolite] = stoichiometry
                     model_metabolite._reaction.add(reaction)
                     if context:
                         context(partial(
@@ -574,21 +569,21 @@
                 # Otherwise, make the gene point to the one in the model
                 else:
                     model_gene = self.genes.get_by_id(gene.id)
                     if model_gene is not gene:
                         reaction._dissociate_gene(gene)
                         reaction._associate_gene(model_gene)
 
-        self.reactions += reaction_list
+        self.reactions += pruned
 
         if context:
-            context(partial(self.reactions.__isub__, reaction_list))
+            context(partial(self.reactions.__isub__, pruned))
 
         # from cameo ...
-        self._populate_solver(reaction_list)
+        self._populate_solver(pruned)
 
     def remove_reactions(self, reactions, remove_orphans=False):
         """Remove reactions from the model.
 
         The change is reverted upon exit when using the model as a context.
 
         Parameters
@@ -743,15 +738,15 @@
         model the provided reactions.
         """
         constraint_terms = AutoVivification()
         to_add = []
         if metabolite_list is not None:
             for met in metabolite_list:
                 to_add += [self.problem.Constraint(
-                    S.Zero, name=met.id, lb=0, ub=0)]
+                    Zero, name=met.id, lb=0, ub=0)]
         self.add_cons_vars(to_add)
 
         for reaction in reaction_list:
 
             reverse_lb, reverse_ub, forward_lb, forward_ub = \
                 separate_forward_and_reverse_bounds(*reaction.bounds)
 
@@ -764,15 +759,15 @@
             self.solver.update()
 
             for metabolite, coeff in six.iteritems(reaction.metabolites):
                 if metabolite.id in self.constraints:
                     constraint = self.constraints[metabolite.id]
                 else:
                     constraint = self.problem.Constraint(
-                        S.Zero,
+                        Zero,
                         name=metabolite.id,
                         lb=0, ub=0)
                     self.add_cons_vars(constraint, sloppy=True)
 
                 constraint_terms[constraint][forward_variable] = coeff
                 constraint_terms[constraint][reverse_variable] = -coeff
 
@@ -943,15 +938,15 @@
         When using a `HistoryManager` context, this attribute can be set
         temporarily, reversed when the exiting the context.
         """
         return self.solver.objective
 
     @objective.setter
     def objective(self, value):
-        if isinstance(value, sympy.Basic):
+        if isinstance(value, Basic):
             value = self.problem.Objective(value, sloppy=False)
         if not isinstance(value, (dict, optlang.interface.Objective)):
             try:
                 reactions = self.reactions.get_by_any(value)
             except KeyError:
                 raise ValueError('invalid objective')
             value = {rxn: 1 for rxn in reactions}
```

## PLATLIB/cobra/core/reaction.py

```diff
@@ -114,15 +114,15 @@
     @property
     def flux_expression(self):
         """Forward flux expression
 
         Returns
         -------
         sympy expression
-            The expression represeenting the the forward flux (if associated
+            The expression representing the the forward flux (if associated
             with model), otherwise None. Representing the net flux if
             model.reversible_encoding == 'unsplit' or None if reaction is
             not associated with a model """
         if self.model is not None:
             return 1. * self.forward_variable - 1. * self.reverse_variable
         else:
             return None
```

## PLATLIB/cobra/flux_analysis/gapfilling.py

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 
 from __future__ import absolute_import
 
-from sympy import Add
+from optlang.symbolics import Add
 from warnings import warn
 
 from optlang.interface import OPTIMAL
 from cobra.core import Model
 from cobra.util import fix_objective_as_constraint
```

## PLATLIB/cobra/flux_analysis/loopless.py

```diff
@@ -2,15 +2,15 @@
 
 """Provides functions to remove thermodynamically infeasible loops."""
 
 from __future__ import absolute_import
 
 import numpy
 from six import iteritems
-from sympy.core.singleton import S
+from optlang.symbolics import Zero
 
 from cobra.core import Metabolite, Reaction, get_solution
 from cobra.util import (linear_reaction_coefficients,
                         create_stoichiometric_matrix, nullspace)
 from cobra.manipulation.modify import convert_to_irreversible
 
 
@@ -68,26 +68,26 @@
         to_add.extend([indicator, on_off_constraint, delta_g, delta_g_range])
 
     model.add_cons_vars(to_add)
 
     # Add nullspace constraints for G_i
     for i, row in enumerate(n_int):
         name = "nullspace_constraint_" + str(i)
-        nullspace_constraint = prob.Constraint(S.Zero, lb=0, ub=0, name=name)
+        nullspace_constraint = prob.Constraint(Zero, lb=0, ub=0, name=name)
         model.add_cons_vars([nullspace_constraint])
         coefs = {model.variables[
                  "delta_g_" + model.reactions[ridx].id]: row[i]
                  for i, ridx in enumerate(internal) if
                  abs(row[i]) > zero_cutoff}
         model.constraints[name].set_linear_coefficients(coefs)
 
 
 def _add_cycle_free(model, fluxes):
     """Add constraints for CycleFreeFlux."""
-    model.objective = S.Zero
+    model.objective = Zero
     for rxn in model.reactions:
         flux = fluxes[rxn.id]
         if rxn.boundary:
             rxn.bounds = (flux, flux)
             continue
         if flux >= 0:
             rxn.lower_bound = max(0, rxn.lower_bound)
```

## PLATLIB/cobra/flux_analysis/moma.py

```diff
@@ -1,15 +1,15 @@
 # -*- coding: utf-8 -*-
 
 """Contains functions to run minimization of metabolic adjustment (MOMA)."""
 
 from __future__ import absolute_import
 
 from scipy.sparse import dok_matrix
-from sympy.core.singleton import S
+from optlang.symbolics import Zero
 
 import cobra.util.solver as sutil
 from cobra.solvers import get_solver_name, solver_dict
 
 
 def add_moma(model, solution=None, linear=False):
     r"""Add constraints and objective representing for MOMA.
@@ -73,15 +73,15 @@
     if solution is None:
         solution = model.optimize()
     prob = model.problem
     v = prob.Variable("moma_old_objective")
     c = prob.Constraint(model.solver.objective.expression - v,
                         lb=0.0, ub=0.0, name="moma_old_objective_constraint")
     to_add = [v, c]
-    new_obj = S.Zero
+    new_obj = Zero
     for r in model.reactions:
         flux = solution.fluxes[r.id]
         if linear:
             components = sutil.add_absolute_expression(
                 model, r.flux_expression, name="moma_dist_" + r.id,
                 difference=flux, add=False)
             to_add.extend(components)
```

## PLATLIB/cobra/flux_analysis/parsimonious.py

```diff
@@ -2,24 +2,22 @@
 
 from __future__ import absolute_import
 
 import logging
 from warnings import warn
 from itertools import chain
 
-import sympy
+from optlang.symbolics import Zero
 
 from cobra.util import solver as sutil
 from cobra.manipulation.modify import (
     convert_to_irreversible, revert_to_reversible)
 from cobra.util import linear_reaction_coefficients, set_objective
 from cobra.core.solution import get_solution
 
-add = sympy.Add._from_args
-mul = sympy.Mul._from_args
 LOGGER = logging.getLogger(__name__)
 
 
 def optimize_minimal_flux(*args, **kwargs):
     warn("optimize_minimal_flux has been renamed to pfba", DeprecationWarning)
     return pfba(*args, **kwargs)
 
@@ -124,19 +122,18 @@
         model.objective = objective
     if model.solver.objective.name == '_pfba_objective':
         raise ValueError('model already has pfba objective')
     sutil.fix_objective_as_constraint(model, fraction=fraction_of_optimum)
     reaction_variables = ((rxn.forward_variable, rxn.reverse_variable)
                           for rxn in model.reactions)
     variables = chain(*reaction_variables)
-    pfba_objective = model.problem.Objective(add(
-        [mul((sympy.singleton.S.One, variable))
-         for variable in variables]), direction='min', sloppy=True,
+    model.objective = model.problem.Objective(
+        Zero, direction='min', sloppy=True,
         name="_pfba_objective")
-    set_objective(model, pfba_objective)
+    model.objective.set_linear_coefficients(dict.fromkeys(variables, 1.0))
 
 
 def _pfba_optlang(model, objective=None, reactions=None,
                   fraction_of_optimum=1.0):
     """Helper function to perform pFBA with the optlang interface
 
     Not meant to be used directly.
```

## PLATLIB/cobra/flux_analysis/sampling.py

```diff
@@ -13,15 +13,15 @@
 from logging import getLogger
 from multiprocessing import Array, Pool
 from time import time
 
 import numpy as np
 import pandas
 from optlang.interface import OPTIMAL
-from sympy.core.singleton import S
+from optlang.symbolics import Zero
 from cobra.util import (create_stoichiometric_matrix, constraint_matrices,
                         nullspace)
 
 LOGGER = getLogger(__name__)
 """The logger for the package."""
 
 bounds_tol = np.finfo(np.float32).eps
@@ -250,15 +250,15 @@
         and minimizing/maximizing it. Also caches the projection of the
         warmup points into the nullspace for non-homogeneous problems (only
         if necessary).
         """
         self.n_warmup = 0
         idx = np.hstack([self.fwd_idx, self.rev_idx])
         self.warmup = np.zeros((len(idx), len(self.model.variables)))
-        self.model.objective = S.Zero
+        self.model.objective = Zero
         self.model.objective.direction = "max"
         variables = self.model.variables
         for i in idx:
             # Omit fixed reactions
             if self.problem.variable_fixed[i]:
                 LOGGER.info("skipping fixed variable %s" %
                             variables[i].name)
```

## PLATLIB/cobra/flux_analysis/variability.py

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 
 from __future__ import absolute_import
 
 import pandas
-from sympy.core.singleton import S
+from optlang.symbolics import Zero
 from warnings import warn
 from itertools import chain
 
 from cobra.flux_analysis.loopless import loopless_fva_iter
 from cobra.flux_analysis.parsimonious import add_pfba
 from cobra.flux_analysis.single_deletion import (single_gene_deletion,
                                                  single_reaction_deletion)
@@ -207,15 +207,15 @@
                 ub = m.slim_optimize(error_value=None)
                 flux_sum = prob.Variable("flux_sum", ub=pfba_factor * ub)
                 flux_sum_constraint = prob.Constraint(
                     m.solver.objective.expression - flux_sum, lb=0, ub=0,
                     name="flux_sum_constraint")
             m.add_cons_vars([flux_sum, flux_sum_constraint])
 
-        m.objective = S.Zero  # This will trigger the reset as well
+        m.objective = Zero  # This will trigger the reset as well
         for what in ("minimum", "maximum"):
             sense = "min" if what == "minimum" else "max"
             for rxn in reaction_list:
                 r_id = rxn.id
                 rxn = m.reactions.get_by_id(r_id)
                 # The previous objective assignment already triggers a reset
                 # so directly update coefs here to not trigger redundant resets
```

## PLATLIB/cobra/io/dict.py

```diff
@@ -61,14 +61,16 @@
         return str(value)
     if isinstance(value, float_):
         return float(value)
     if isinstance(value, bool_):
         return bool(value)
     if isinstance(value, set):
         return list(value)
+    if isinstance(value, dict):
+        return OrderedDict((key, value[key]) for key in sorted(value))
     # handle legacy Formula type
     if value.__class__.__name__ == "Formula":
         return str(value)
     if value is None:
         return ""
     return value
 
@@ -141,46 +143,49 @@
                 (model.metabolites.get_by_id(str(met)), coeff)
                 for met, coeff in iteritems(v)))
         else:
             setattr(new_reaction, k, v)
     return new_reaction
 
 
-def model_to_dict(model):
+def model_to_dict(model, sort=False):
     """Convert model to a dict.
 
     Parameters
     ----------
     model : cobra.Model
-        The model to reformulate as a dict
+        The model to reformulate as a dict.
+    sort : bool, optional
+        Whether to sort the metabolites, reactions, and genes or maintain the
+        order defined in the model.
 
     Returns
     -------
     OrderedDict
         A dictionary with elements, 'genes', 'compartments', 'id',
         'metabolites', 'notes' and 'reactions'; where 'metabolites', 'genes'
         and 'metabolites' are in turn lists with dictionaries holding all
         attributes to form the corresponding object.
 
     See Also
     --------
     cobra.io.model_from_dict
     """
     obj = OrderedDict()
-    obj["reactions"] = sorted(
-        (reaction_to_dict(reaction) for reaction in model.reactions),
-        key=itemgetter("id"))
-    obj["metabolites"] = sorted(
-        (metabolite_to_dict(metabolite) for metabolite in model.metabolites),
-        key=itemgetter("id"))
-    obj["genes"] = sorted(
-        (gene_to_dict(gene) for gene in model.genes), key=itemgetter("id"))
+    obj["metabolites"] = list(map(metabolite_to_dict, model.metabolites))
+    obj["reactions"] = list(map(reaction_to_dict, model.reactions))
+    obj["genes"] = list(map(gene_to_dict, model.genes))
     obj["id"] = model.id
     _update_optional(model, obj, _OPTIONAL_MODEL_ATTRIBUTES,
                      _ORDERED_OPTIONAL_MODEL_KEYS)
+    if sort:
+        get_id = itemgetter("id")
+        obj["metabolites"].sort(key=get_id)
+        obj["reactions"].sort(key=get_id)
+        obj["genes"].sort(key=get_id)
     return obj
 
 
 def model_from_dict(obj):
     """Build a model from a dict.
 
     Models stored in json are first formulated as a dict that can be read to
```

## PLATLIB/cobra/io/json.py

```diff
@@ -11,36 +11,39 @@
 from six import string_types
 
 from cobra.io.dict import model_to_dict, model_from_dict
 
 JSON_SPEC = "1"
 
 
-def to_json(model, **kwargs):
+def to_json(model, sort=False, **kwargs):
     """
     Return the model as a JSON document.
 
     ``kwargs`` are passed on to ``json.dumps``.
 
     Parameters
     ----------
     model : cobra.Model
         The cobra model to represent.
+    sort : bool, optional
+        Whether to sort the metabolites, reactions, and genes or maintain the
+        order defined in the model.
 
     Returns
     -------
     str
         String representation of the cobra model as a JSON document.
 
     See Also
     --------
     save_json_model : Write directly to a file.
     json.dumps : Base function.
     """
-    obj = model_to_dict(model)
+    obj = model_to_dict(model, sort=sort)
     obj[u"version"] = JSON_SPEC
     return json.dumps(obj, allow_nan=False, **kwargs)
 
 
 def from_json(document):
     """
     Load a cobra model from a JSON document.
@@ -58,38 +61,41 @@
     See Also
     --------
     load_json_model : Load directly from a file.
     """
     return model_from_dict(json.loads(document))
 
 
-def save_json_model(model, filename, pretty=False, **kwargs):
+def save_json_model(model, filename, sort=False, pretty=False, **kwargs):
     """
     Write the cobra model to a file in JSON format.
 
     ``kwargs`` are passed on to ``json.dump``.
 
     Parameters
     ----------
     model : cobra.Model
         The cobra model to represent.
     filename : str or file-like
         File path or descriptor that the JSON representation should be
         written to.
+    sort : bool, optional
+        Whether to sort the metabolites, reactions, and genes or maintain the
+        order defined in the model.
     pretty : bool, optional
         Whether to format the JSON more compactly (default) or in a more
         verbose but easier to read fashion. Can be partially overwritten by the
         ``kwargs``.
 
     See Also
     --------
     to_json : Return a string representation.
     json.dump : Base function.
     """
-    obj = model_to_dict(model)
+    obj = model_to_dict(model, sort=sort)
     obj[u"version"] = JSON_SPEC
 
     if pretty:
         dump_opts = {
             "indent": 4, "separators": (",", ": "), "sort_keys": True,
             "allow_nan": False}
     else:
```

## PLATLIB/cobra/io/sbml3.py

```diff
@@ -44,15 +44,15 @@
 except ImportError:
     libsbml = None
 else:
     from cobra.io.sbml import create_cobra_model_from_sbml_file as read_sbml2
     from cobra.io.sbml import write_cobra_model_to_sbml_file as write_sbml2
 
 try:
-    from sympy import Basic
+    from optlang.symbolics import Basic
 except ImportError:
     class Basic:
         pass
 
 # deal with namespaces
 namespaces = {"fbc": "http://www.sbml.org/sbml/level3/version1/fbc/version2",
               "sbml": "http://www.sbml.org/sbml/level3/version1/core",
```

## PLATLIB/cobra/io/yaml.py

```diff
@@ -8,36 +8,39 @@
 from ruamel import yaml
 
 from cobra.io.dict import model_to_dict, model_from_dict
 
 YAML_SPEC = "1"
 
 
-def to_yaml(model, **kwargs):
+def to_yaml(model, sort=False, **kwargs):
     """
     Return the model as a YAML document.
 
     ``kwargs`` are passed on to ``yaml.dump``.
 
     Parameters
     ----------
     model : cobra.Model
         The cobra model to represent.
+    sort : bool, optional
+        Whether to sort the metabolites, reactions, and genes or maintain the
+        order defined in the model.
 
     Returns
     -------
     str
         String representation of the cobra model as a YAML document.
 
     See Also
     --------
     save_yaml_model : Write directly to a file.
     ruamel.yaml.dump : Base function.
     """
-    obj = model_to_dict(model)
+    obj = model_to_dict(model, sort=sort)
     obj["version"] = YAML_SPEC
     return yaml.dump(obj, Dumper=yaml.RoundTripDumper, **kwargs)
 
 
 def from_yaml(document):
     """
     Load a cobra model from a YAML document.
@@ -55,34 +58,37 @@
     See Also
     --------
     load_yaml_model : Load directly from a file.
     """
     return model_from_dict(yaml.load(document, yaml.RoundTripLoader))
 
 
-def save_yaml_model(model, filename, **kwargs):
+def save_yaml_model(model, filename, sort=False, **kwargs):
     """
     Write the cobra model to a file in YAML format.
 
     ``kwargs`` are passed on to ``yaml.dump``.
 
     Parameters
     ----------
     model : cobra.Model
         The cobra model to represent.
     filename : str or file-like
         File path or descriptor that the YAML representation should be
         written to.
+    sort : bool, optional
+        Whether to sort the metabolites, reactions, and genes or maintain the
+        order defined in the model.
 
     See Also
     --------
     to_yaml : Return a string representation.
     ruamel.yaml.dump : Base function.
     """
-    obj = model_to_dict(model)
+    obj = model_to_dict(model, sort=sort)
     obj["version"] = YAML_SPEC
     if isinstance(filename, string_types):
         with io.open(filename, "w") as file_handle:
             yaml.dump(obj, file_handle, Dumper=yaml.RoundTripDumper, **kwargs)
     else:
         yaml.dump(obj, filename, Dumper=yaml.RoundTripDumper, **kwargs)
```

## PLATLIB/cobra/solvers/cplex_solver.py

```diff
@@ -11,15 +11,15 @@
 from cplex.exceptions import CplexError
 from six import iteritems, string_types
 from six.moves import zip
 
 from cobra.core.solution import LegacySolution
 
 try:
-    from sympy import Basic, Number
+    from optlang.symbolics import Basic, Number
 except:
     class Basic:
         pass
 
 def _float(value):
     if isinstance(value, Basic) and not isinstance(value, Number):
         return 0.
```

## PLATLIB/cobra/solvers/gurobi_solver.py

```diff
@@ -36,15 +36,15 @@
         raise RuntimeError("importing gurobi causes a crash (exitcode %d)" %
                            p.exitcode)
 
 
 
 
 try:
-    from sympy import Basic, Number
+    from optlang.symbolics import Basic, Number
 except:
     class Basic:
         pass
     Number = Basic
 
 
 def _float(value):
```

## PLATLIB/cobra/test/test_io.py

```diff
@@ -181,18 +181,20 @@
         assert model2.metabolites[0]._model is model2
         assert model2.reactions[0]._model is model2
         assert model2.genes[0]._model is model2
 
     @classmethod
     def extra_comparisons(cls, name, model1, model2):
         assert model1.compartments == model2.compartments
-        assert model1.metabolites[4].annotation == model2.metabolites[
-            4].annotation
-        assert model1.reactions[4].annotation == model2.reactions[4].annotation
-        assert model1.genes[5].annotation == model2.genes[5].annotation
+        assert dict(model1.metabolites[4].annotation) == dict(
+            model2.metabolites[4].annotation)
+        assert dict(model1.reactions[4].annotation) == dict(
+            model2.reactions[4].annotation)
+        assert dict(model1.genes[5].annotation) == dict(
+            model2.genes[5].annotation)
         for attr in ("id", "name"):
             assert getattr(model1.genes[0], attr) == getattr(model2.genes[0],
                                                              attr)
             assert getattr(model1.genes[10], attr) == getattr(model2.genes[10],
                                                               attr)
             assert getattr(model1.genes[-1], attr) == getattr(model2.genes[-1],
                                                               attr)
```

## PLATLIB/cobra/test/test_model.py

```diff
@@ -4,15 +4,15 @@
 import warnings
 from copy import deepcopy
 
 import numpy
 from math import isnan
 import pytest
 import pandas as pd
-from sympy import S
+from optlang.symbolics import Zero
 
 import cobra.util.solver as su
 from cobra.core import Metabolite, Model, Reaction
 from cobra.solvers import solver_dict
 from cobra.util import create_stoichiometric_matrix
 from cobra.exceptions import OptimizationError
 
@@ -750,16 +750,17 @@
             with model:
                 model.merge(tiny_toy_model, inplace=True, objective='left',
                             prefix_existing='tiny_')
                 assert 'ex1' in model.reactions
                 assert 'constraint' in model.constraints
                 assert 'foo' in model.variables
                 assert 'tiny_EX_glc__D_e' in model.reactions
-                assert model.objective.expression == model.reactions.get_by_id(
-                    'Biomass_Ecoli_core').flux_expression
+                assert (model.objective.expression.simplify() ==
+                        model.reactions.get_by_id(
+                            'Biomass_Ecoli_core').flux_expression.simplify())
             assert 'ex1' not in model.reactions
             assert 'constraint' not in model.constraints
             assert 'foo' not in model.variables
             assert 'tiny_EX_glc__D_e' not in model.reactions
 
         # test the deprecated operator overloading
         with model:
@@ -849,15 +850,15 @@
         model.objective = [model.reactions.index(reaction) for
                            reaction in [atpm, biomass]]
         assert su.linear_reaction_coefficients(model) == {atpm: 1.,
                                                           biomass: 1.}
 
     def test_problem_properties(self, model):
         new_variable = model.problem.Variable("test_variable")
-        new_constraint = model.problem.Constraint(S.Zero,
+        new_constraint = model.problem.Constraint(Zero,
                                                   name="test_constraint")
         model.add_cons_vars([new_variable, new_constraint])
         assert "test_variable" in model.variables.keys()
         assert "test_constraint" in model.constraints.keys()
         model.remove_cons_vars([new_constraint, new_variable])
         assert "test_variable" not in model.variables.keys()
         assert "test_constraint" not in model.variables.keys()
```

## PLATLIB/cobra/test/test_solver_model.py

```diff
@@ -28,14 +28,19 @@
 @pytest.fixture(scope="function", params=solver_trials)
 def solved_model(request, model):
     model.solver = request.param
     solution = model.optimize(solution_type=Solution)
     return solution, model
 
 
+def same_ex(ex1, ex2):
+    """Compare to expressions for mathematical equality."""
+    return ex1.simplify() == ex2.simplify()
+
+
 class TestSolution:
     def test_solution_contains_only_reaction_specific_values(self,
                                                              solved_model):
         solution, model = solved_model
         reaction_ids = set([reaction.id for reaction in model.reactions])
         if isinstance(solution, Solution):
             assert set(solution.fluxes.index) == reaction_ids
@@ -50,30 +55,30 @@
         assert model.reactions[0].__str__().startswith('ACALD')
 
     def test_add_metabolite(self, solved_model):
         solution, model = solved_model
         pgi_reaction = model.reactions.PGI
         test_met = model.metabolites[0]
         pgi_reaction.add_metabolites({test_met: 42}, combine=False)
-        assert pgi_reaction.metabolites[test_met] == 42
+        assert pgi_reaction.metabolites[test_met] == 42.0
         assert model.constraints[
                    test_met.id].expression.as_coefficients_dict()[
-                   pgi_reaction.forward_variable] == 42
+                   pgi_reaction.forward_variable] == 42.0
         assert model.constraints[
                    test_met.id].expression.as_coefficients_dict()[
-                   pgi_reaction.reverse_variable] == -42
+                   pgi_reaction.reverse_variable] == -42.0
 
         pgi_reaction.add_metabolites({test_met: -10}, combine=True)
-        assert pgi_reaction.metabolites[test_met] == 32
+        assert pgi_reaction.metabolites[test_met] == 32.0
         assert model.constraints[
                    test_met.id].expression.as_coefficients_dict()[
-                   pgi_reaction.forward_variable] == 32
+                   pgi_reaction.forward_variable] == 32.0
         assert model.constraints[
                    test_met.id].expression.as_coefficients_dict()[
-                   pgi_reaction.reverse_variable] == -32
+                   pgi_reaction.reverse_variable] == -32.0
 
         pgi_reaction.add_metabolites({test_met: 0}, combine=False)
         with pytest.raises(KeyError):
             pgi_reaction.metabolites[test_met]
         assert model.constraints[
                    test_met.id].expression.as_coefficients_dict()[
                    pgi_reaction.forward_variable] == 0
@@ -416,33 +421,35 @@
             assert reaction.lower_bound == reaction.upper_bound
 
     def test_add_metabolites_combine_true(self, model):
         test_metabolite = Metabolite('test')
         for reaction in model.reactions:
             reaction.add_metabolites({test_metabolite: -66}, combine=True)
             assert reaction.metabolites[test_metabolite] == -66
-            assert model.constraints['test'].expression.has(
-                -66. * reaction.forward_variable)
-            assert model.constraints['test'].expression.has(
-                66. * reaction.reverse_variable)
+            assert model.constraints['test'].get_linear_coefficients(
+                [reaction.forward_variable])[reaction.forward_variable] == -66
+            assert model.constraints['test'].get_linear_coefficients(
+                [reaction.reverse_variable])[reaction.reverse_variable] == 66
             already_included_metabolite = \
                 list(reaction.metabolites.keys())[0]
             previous_coefficient = reaction.get_coefficient(
                 already_included_metabolite.id)
             reaction.add_metabolites({already_included_metabolite: 10},
                                      combine=True)
             new_coefficient = previous_coefficient + 10
             assert reaction.metabolites[
                        already_included_metabolite] == new_coefficient
-            assert model.constraints[
-                already_included_metabolite.id].expression.has(
-                new_coefficient * reaction.forward_variable)
-            assert model.constraints[
-                already_included_metabolite.id].expression.has(
-                -1 * new_coefficient * reaction.reverse_variable)
+            assert (model.constraints[
+                    already_included_metabolite.id].get_linear_coefficients(
+                    [reaction.forward_variable])[reaction.forward_variable] ==
+                    new_coefficient)
+            assert (model.constraints[
+                    already_included_metabolite.id].get_linear_coefficients(
+                    [reaction.reverse_variable])[
+                        reaction.reverse_variable] == -new_coefficient)
 
     @pytest.mark.xfail(reason='non-deterministic test')
     def test_add_metabolites_combine_false(self, model):
         test_metabolite = Metabolite('test')
         for reaction in model.reactions:
             reaction.add_metabolites({test_metabolite: -66}, combine=False)
             assert reaction.metabolites[test_metabolite] == -66
@@ -529,19 +536,19 @@
 
     def test_change_objective_through_objective_coefficient(self, model):
         biomass_r = model.reactions.get_by_id('Biomass_Ecoli_core')
         pgi = model.reactions.PGI
         pgi.objective_coefficient = 2
         coef_dict = model.objective.expression.as_coefficients_dict()
         # Check that objective has been updated
-        assert coef_dict[pgi.forward_variable] == 2
-        assert coef_dict[pgi.reverse_variable] == -2
+        assert coef_dict[pgi.forward_variable] == 2.0
+        assert coef_dict[pgi.reverse_variable] == -2.0
         # Check that original objective is still in there
-        assert coef_dict[biomass_r.forward_variable] == 1
-        assert coef_dict[biomass_r.reverse_variable] == -1
+        assert coef_dict[biomass_r.forward_variable] == 1.0
+        assert coef_dict[biomass_r.reverse_variable] == -1.0
 
     def test_transfer_objective(self, model):
         new_mod = Model("new model")
         new_mod.add_reactions(model.reactions)
         new_mod.objective = model.objective
         assert (set(str(x) for x in model.objective.expression.args) == set(
             str(x) for x in new_mod.objective.expression.args))
@@ -574,14 +581,36 @@
         assert coefficients_dict[biomass_r.forward_variable] == 1.
         assert coefficients_dict[biomass_r.reverse_variable] == -1.
         assert coefficients_dict[
                    model.reactions.r2.forward_variable] == 3.
         assert coefficients_dict[
                    model.reactions.r2.reverse_variable] == -3.
 
+    def test_add_reactions_single_existing(self, model):
+        rxn = model.reactions[0]
+        r1 = Reaction(rxn.id)
+        r1.add_metabolites({Metabolite('A'): -1, Metabolite('B'): 1})
+        r1.lower_bound, r1.upper_bound = -999999., 999999.
+        model.add_reactions([r1])
+        assert rxn in model.reactions
+        assert r1 is not model.reactions.get_by_id(rxn.id)
+
+    def test_add_reactions_duplicate(self, model):
+        rxn = model.reactions[0]
+        r1 = Reaction('r1')
+        r1.add_metabolites({Metabolite('A'): -1, Metabolite('B'): 1})
+        r1.lower_bound, r1.upper_bound = -999999., 999999.
+        r2 = Reaction(rxn.id)
+        r2.add_metabolites(
+            {Metabolite('A'): -1, Metabolite('C'): 1, Metabolite('D'): 1})
+        model.add_reactions([r1, r2])
+        assert r1 in model.reactions
+        assert rxn in model.reactions
+        assert r2 is not model.reactions.get_by_id(rxn.id)
+
     def test_add_cobra_reaction(self, model):
         r = cobra.Reaction(id="c1")
         model.add_reaction(r)
         assert isinstance(model.reactions.c1, Reaction)
 
     def test_all_objects_point_to_all_other_correct_objects(self, model):
         for reaction in model.reactions:
@@ -640,62 +669,61 @@
 
         model.add_reactions(reactions_to_remove)
         for reaction in reactions_to_remove:
             assert reaction in model.reactions
 
     def test_objective(self, model):
         obj = model.objective
-        assert {var.name: coef for var, coef in
-                obj.expression.as_coefficients_dict().items()} == {
-                   'Biomass_Ecoli_core_reverse_2cdba': -1,
-                   'Biomass_Ecoli_core': 1}
+        assert obj.get_linear_coefficients(obj.variables) == {
+                   model.variables["Biomass_Ecoli_core_reverse_2cdba"]: -1,
+                   model.variables["Biomass_Ecoli_core"]: 1}
         assert obj.direction == "max"
 
     def test_change_objective(self, model):
         expression = 1.0 * model.variables['ENO'] + \
                      1.0 * model.variables['PFK']
         model.objective = model.problem.Objective(
             expression)
-        assert model.objective.expression == expression
+        assert same_ex(model.objective.expression, expression)
         model.objective = "ENO"
         eno_obj = model.problem.Objective(
             model.reactions.ENO.flux_expression, direction="max")
         pfk_obj = model.problem.Objective(
             model.reactions.PFK.flux_expression, direction="max")
-        assert model.objective == eno_obj
+        assert same_ex(model.objective.expression, eno_obj.expression)
 
         with model:
             model.objective = "PFK"
-            assert model.objective == pfk_obj
-        assert model.objective == eno_obj
+            assert same_ex(model.objective.expression, pfk_obj.expression)
+        assert same_ex(model.objective.expression, eno_obj.expression)
         expression = model.objective.expression
         atpm = model.reactions.get_by_id("ATPM")
         biomass = model.reactions.get_by_id("Biomass_Ecoli_core")
         with model:
             model.objective = atpm
-        assert model.objective.expression == expression
+        assert same_ex(model.objective.expression, expression)
         with model:
             atpm.objective_coefficient = 1
             biomass.objective_coefficient = 2
-        assert model.objective.expression == expression
+        assert same_ex(model.objective.expression, expression)
 
         with model:
             set_objective(model, model.problem.Objective(
                 atpm.flux_expression))
-            assert model.objective.expression == atpm.flux_expression
-        assert model.objective.expression == expression
+            assert same_ex(model.objective.expression, atpm.flux_expression)
+        assert same_ex(model.objective.expression, expression)
 
         expression = model.objective.expression
         with model:
             with model:  # Test to make sure nested contexts are OK
                 set_objective(model, atpm.flux_expression,
                               additive=True)
-                assert (model.objective.expression ==
-                        expression + atpm.flux_expression)
-        assert model.objective.expression == expression
+                assert same_ex(model.objective.expression,
+                               expression + atpm.flux_expression)
+        assert same_ex(model.objective.expression, expression)
 
     def test_set_reaction_objective(self, model):
         model.objective = model.reactions.ACALD
         assert str(model.objective.expression) == str(
             1.0 * model.reactions.ACALD.forward_variable -
             1.0 * model.reactions.ACALD.reverse_variable)
```

## PLATLIB/cobra/util/solver.py

```diff
@@ -15,15 +15,15 @@
 import re
 from functools import partial
 from collections import namedtuple
 from types import ModuleType
 from warnings import warn
 
 import optlang
-import sympy
+from optlang.symbolics import Basic, Zero
 
 from cobra.exceptions import OptimizationError, OPTLANG_TO_EXCEPTIONS_DICT
 from cobra.util.context import get_context
 
 
 class SolverNotFound(Exception):
     """A simple Exception when a solver can not be found."""
@@ -125,22 +125,22 @@
             raise ValueError('can only update non-linear objectives '
                              'additively using object of class '
                              'model.problem.Objective, not %s' %
                              type(value))
 
         if not additive:
             model.solver.objective = interface.Objective(
-                sympy.S.Zero, direction=model.solver.objective.direction)
+                Zero, direction=model.solver.objective.direction)
         for reaction, coef in value.items():
             model.solver.objective.set_linear_coefficients(
                 {reaction.forward_variable: coef,
                  reaction.reverse_variable: -coef})
 
-    elif isinstance(value, (sympy.Basic, optlang.interface.Objective)):
-        if isinstance(value, sympy.Basic):
+    elif isinstance(value, (Basic, optlang.interface.Objective)):
+        if isinstance(value, Basic):
             value = interface.Objective(
                 value, direction=model.solver.objective.direction,
                 sloppy=False)
         # Check whether expression only uses variables from current model
         # clone the objective if not, faster than cloning without checking
         if not _valid_atoms(model, value.expression):
             value = interface.Objective.clone(value, model=model.solver)
```

## Comparing `PLATLIB/cobra-0.9.0-py3.6.egg-info/PKG-INFO` & `PLATLIB/cobra-0.9.1-py3.6.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.1
 Name: cobra
-Version: 0.9.0
+Version: 0.9.1
 Summary: COBRApy is a package for constraints-based modeling of biological networks
 Home-page: https://opencobra.github.io/cobrapy
 Author: The cobrapy core team
 Author-email: cobra-pie@googlegroups.com
 License: LGPL/GPL v2+
 Download-URL: https://pypi.python.org/pypi/cobra
 Description-Content-Type: UNKNOWN
```

## Comparing `PLATLIB/cobra-0.9.0-py3.6.egg-info/SOURCES.txt` & `PLATLIB/cobra-0.9.1-py3.6.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -66,14 +66,15 @@
 cobra/solvers/mosek.py
 cobra/solvers/parameters.py
 cobra/solvers/wrappers.py
 cobra/test/__init__.py
 cobra/test/conftest.py
 cobra/test/test_flux_analysis.py
 cobra/test/test_io.py
+cobra/test/test_io_order.py
 cobra/test/test_manipulation.py
 cobra/test/test_model.py
 cobra/test/test_solver_model.py
 cobra/test/test_solver_utils.py
 cobra/test/test_solvers.py
 cobra/test/test_util.py
 cobra/test/data/iJO1366.pickle
```

