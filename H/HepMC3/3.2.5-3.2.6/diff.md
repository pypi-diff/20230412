# Comparing `tmp/HepMC3-3.2.5.tar.gz` & `tmp/HepMC3-3.2.6.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "HepMC3-3.2.5.tar", last modified: Mon Feb 21 11:38:11 2022, max compression
+gzip compressed data, was "HepMC3-3.2.6.tar", last modified: Wed Apr 12 15:30:37 2023, max compression
```

## Comparing `HepMC3-3.2.5.tar` & `HepMC3-3.2.6.tar`

### file list

```diff
@@ -1,384 +1,411 @@
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.422034 HepMC3-3.2.5/
--rw-rw-r--   0 root         (0) root         (0)      277 2022-02-21 08:27:58.000000 HepMC3-3.2.5/AUTHORS
--rw-rw-r--   0 root         (0) root         (0)    17190 2022-02-21 08:27:58.000000 HepMC3-3.2.5/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)    35146 2022-02-21 08:27:58.000000 HepMC3-3.2.5/COPYING
--rwxrwxr-x   0 root         (0) root         (0)     3228 2022-02-21 08:27:58.000000 HepMC3-3.2.5/HepMC3-config.in
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.354034 HepMC3-3.2.5/HepMC3.egg-info/
--rw-r--r--   0 root         (0) root         (0)      597 2022-02-21 11:38:10.000000 HepMC3-3.2.5/HepMC3.egg-info/PKG-INFO
--rw-r--r--   0 root         (0) root         (0)    10633 2022-02-21 11:38:11.000000 HepMC3-3.2.5/HepMC3.egg-info/SOURCES.txt
--rw-r--r--   0 root         (0) root         (0)        1 2022-02-21 11:38:10.000000 HepMC3-3.2.5/HepMC3.egg-info/dependency_links.txt
--rw-r--r--   0 root         (0) root         (0)        9 2022-02-21 11:38:11.000000 HepMC3-3.2.5/HepMC3.egg-info/top_level.txt
--rw-rw-r--   0 root         (0) root         (0)     1997 2022-02-21 08:27:58.000000 HepMC3-3.2.5/LICENCE
--rw-r--r--   0 root         (0) root         (0)      804 2022-02-21 11:38:10.000000 HepMC3-3.2.5/MANIFEST.in
--rw-r--r--   0 root         (0) root         (0)      597 2022-02-21 11:38:11.418034 HepMC3-3.2.5/PKG-INFO
--rw-rw-r--   0 root         (0) root         (0)     3166 2022-02-21 08:27:58.000000 HepMC3-3.2.5/README-for-developers
--rw-rw-r--   0 root         (0) root         (0)    19449 2022-02-21 08:27:58.000000 HepMC3-3.2.5/README.md
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.346034 HepMC3-3.2.5/cmake/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.354034 HepMC3-3.2.5/cmake/Modules/
--rw-rw-r--   0 root         (0) root         (0)     1582 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/CMakeFindFrameworks.cmake
--rw-rw-r--   0 root         (0) root         (0)     5891 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/CMakeMacroParseArguments.cmake
--rw-rw-r--   0 root         (0) root         (0)     5324 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/Copyright.txt
--rw-rw-r--   0 root         (0) root         (0)     2322 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindHepMC2.cmake
--rw-rw-r--   0 root         (0) root         (0)     2318 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindMCTester.cmake
--rw-rw-r--   0 root         (0) root         (0)    18252 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPackageHandleStandardArgs.cmake
--rw-rw-r--   0 root         (0) root         (0)     1711 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPackageMessage.cmake
--rw-rw-r--   0 root         (0) root         (0)     3333 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPhotospp.cmake
--rw-rw-r--   0 root         (0) root         (0)     1640 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPyPy.cmake
--rw-rw-r--   0 root         (0) root         (0)     2272 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPythia8.cmake
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.354034 HepMC3-3.2.5/cmake/Modules/FindPython/
--rw-rw-r--   0 root         (0) root         (0)   153123 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPython/Support.cmake
--rw-rw-r--   0 root         (0) root         (0)    14355 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPython2.cmake
--rw-rw-r--   0 root         (0) root         (0)    14650 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindPython3.cmake
--rw-rw-r--   0 root         (0) root         (0)     2584 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/FindTauolapp.cmake
--rw-rw-r--   0 root         (0) root         (0)     3290 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Modules/SelectLibraryConfigurations.cmake
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.354034 HepMC3-3.2.5/cmake/Templates/
--rw-rw-r--   0 root         (0) root         (0)      923 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Templates/HepMC3Config.cmake.in
--rw-rw-r--   0 root         (0) root         (0)     1003 2022-02-21 08:27:58.000000 HepMC3-3.2.5/cmake/Templates/cmake_uninstall.cmake.in
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.354034 HepMC3-3.2.5/doc/
--rw-rw-r--   0 root         (0) root         (0)      816 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/CMakeLists.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.358034 HepMC3-3.2.5/doc/doxygen/
--rw-rw-r--   0 root         (0) root         (0)        6 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/.gitignore
--rw-rw-r--   0 root         (0) root         (0)    80978 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/Doxyfile.in
--rw-rw-r--   0 root         (0) root         (0)     3879 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/DoxygenLayout.xml
--rw-rw-r--   0 root         (0) root         (0)    22902 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/LHEF.txt
--rw-rw-r--   0 root         (0) root         (0)     1805 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/Python.txt
--rw-rw-r--   0 root         (0) root         (0)     2981 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/ReaderFactory.txt
--rw-rw-r--   0 root         (0) root         (0)     1141 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/building.txt
--rw-rw-r--   0 root         (0) root         (0)   240832 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/class_diagram.png
--rw-rw-r--   0 root         (0) root         (0)   189416 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/class_diagram_3.0.png
--rw-rw-r--   0 root         (0) root         (0)    18243 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/differences.txt
--rw-rw-r--   0 root         (0) root         (0)     5904 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/features.txt
--rw-rw-r--   0 root         (0) root         (0)     5829 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/mainpage.txt
--rw-rw-r--   0 root         (0) root         (0)     4900 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/modules.txt
--rw-rw-r--   0 root         (0) root         (0)    11487 2022-02-21 08:27:58.000000 HepMC3-3.2.5/doc/doxygen/search.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.358034 HepMC3-3.2.5/examples/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.358034 HepMC3-3.2.5/examples/BasicExamples/
--rw-rw-r--   0 root         (0) root         (0)     2341 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/BasicExamples/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)     1613 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/BasicExamples/HepMC2_reader_example.cc
--rw-rw-r--   0 root         (0) root         (0)     2411 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/BasicExamples/HepMC3_fileIO_example.cc
--rw-rw-r--   0 root         (0) root         (0)     8067 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/BasicExamples/basic_tree.cc
--rw-rw-r--   0 root         (0) root         (0)     6014 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/BasicExamples/hepevt_wrapper_example_fortran.f
--rw-rw-r--   0 root         (0) root         (0)     6098 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/BasicExamples/hepevt_wrapper_example_main.cc
--rw-rw-r--   0 root         (0) root         (0)     6328 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/CMakeLists.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.362034 HepMC3-3.2.5/examples/ConvertExample/
--rw-rw-r--   0 root         (0) root         (0)     6632 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)    55450 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/cmdline.c
--rw-rw-r--   0 root         (0) root         (0)     1410 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/cmdline.ggo
--rw-rw-r--   0 root         (0) root         (0)    10580 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/cmdline.h
--rw-rw-r--   0 root         (0) root         (0)    12358 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/convert_example.cc
--rw-rw-r--   0 root         (0) root         (0)      474 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/convert_example_env.sh.in
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.362034 HepMC3-3.2.5/examples/ConvertExample/include/
--rw-rw-r--   0 root         (0) root         (0)     1652 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/include/AnalysisExample.h
--rw-rw-r--   0 root         (0) root         (0)     2322 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/include/ReaderuprootTree.h
--rw-rw-r--   0 root         (0) root         (0)     1741 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/include/WriterDOT.h
--rw-rw-r--   0 root         (0) root         (0)      780 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/include/WriterHEPEVTZEUS.h
--rw-rw-r--   0 root         (0) root         (0)     1022 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/include/WriterRootTreeOPAL.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.362034 HepMC3-3.2.5/examples/ConvertExample/src/
--rw-rw-r--   0 root         (0) root         (0)     2557 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/src/AnalysisExample.cc
--rw-rw-r--   0 root         (0) root         (0)    14269 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/src/ReaderuprootTree.cc
--rw-rw-r--   0 root         (0) root         (0)     4754 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/src/WriterDOT.cc
--rw-rw-r--   0 root         (0) root         (0)     1737 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/src/WriterHEPEVTZEUS.cc
--rw-rw-r--   0 root         (0) root         (0)     1007 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ConvertExample/src/WriterRootTreeOPAL.cc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.366034 HepMC3-3.2.5/examples/LHEFExample/
--rw-rw-r--   0 root         (0) root         (0)     1098 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)   104373 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example.lhe
--rw-rw-r--   0 root         (0) root         (0)    80148 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_1.plhe
--rw-rw-r--   0 root         (0) root         (0)    74432 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_1_cmp.plhe
--rw-rw-r--   0 root         (0) root         (0)    74432 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_1_out.plhe
--rw-rw-r--   0 root         (0) root         (0)    76959 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_2.plhe
--rw-rw-r--   0 root         (0) root         (0)    71504 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_2_cmp.plhe
--rw-rw-r--   0 root         (0) root         (0)    71504 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_2_out.plhe
--rw-rw-r--   0 root         (0) root         (0)     8566 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_cat.cc
--rw-rw-r--   0 root         (0) root         (0)    88096 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_cmp.lhe
--rw-rw-r--   0 root         (0) root         (0)      474 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/LHEFExample/LHEF_example_env.sh.in
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.366034 HepMC3-3.2.5/examples/Pythia6Example/
--rw-rw-r--   0 root         (0) root         (0)     1112 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia6Example/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)     7204 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia6Example/main63.f
--rw-rw-r--   0 root         (0) root         (0)  2897708 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia6Example/pythia-6.4.28.f
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.370034 HepMC3-3.2.5/examples/Pythia8Example/
--rw-rw-r--   0 root         (0) root         (0)     2888 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia8Example/CMakeLists.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.346034 HepMC3-3.2.5/examples/Pythia8Example/cmake/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.370034 HepMC3-3.2.5/examples/Pythia8Example/cmake/Modules/
--rw-rw-r--   0 root         (0) root         (0)     2019 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia8Example/cmake/Modules/FindPythia8.cmake
--rw-rw-r--   0 root         (0) root         (0)      505 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia8Example/pythia8_ee_to_Z_to_tautau.conf
--rw-rw-r--   0 root         (0) root         (0)     1915 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia8Example/pythia8_example.cc
--rw-rw-r--   0 root         (0) root         (0)      507 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia8Example/pythia8_example_env.sh.in
--rw-rw-r--   0 root         (0) root         (0)     2726 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/Pythia8Example/pythia8_pp_minbias.conf
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.370034 HepMC3-3.2.5/examples/RootIOExample/
--rw-rw-r--   0 root         (0) root         (0)     1548 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)   189214 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample/example.hepmc3
--rw-rw-r--   0 root         (0) root         (0)      474 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample/rootIO_example_env.sh.in
--rw-rw-r--   0 root         (0) root         (0)     1360 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample/rootIO_example_read.cc
--rw-rw-r--   0 root         (0) root         (0)     1381 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample/rootIO_example_write.cc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/RootIOExample2/
--rw-rw-r--   0 root         (0) root         (0)     2349 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)      474 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/class_example_env.sh.in
--rw-rw-r--   0 root         (0) root         (0)     2123 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/class_example_read.cc
--rw-rw-r--   0 root         (0) root         (0)     2179 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/class_example_write.cc
--rw-rw-r--   0 root         (0) root         (0)   189214 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/example.hepmc3
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/RootIOExample2/include/
--rw-rw-r--   0 root         (0) root         (0)      180 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/include/LinkDef.h
--rw-rw-r--   0 root         (0) root         (0)      547 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/include/MyClass.h
--rw-rw-r--   0 root         (0) root         (0)      574 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/include/MyRunClass.h
--rw-rw-r--   0 root         (0) root         (0)      105 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/include/myclass_Classes.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/RootIOExample2/src/
--rw-rw-r--   0 root         (0) root         (0)      289 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/src/MyClass.cc
--rw-rw-r--   0 root         (0) root         (0)      313 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample2/src/MyRunClass.cc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/RootIOExample3/
--rw-rw-r--   0 root         (0) root         (0)     1531 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample3/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)      474 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample3/rootIOTree_example_env.sh.in
--rw-rw-r--   0 root         (0) root         (0)     1398 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample3/rootIOTree_example_read.cc
--rw-rw-r--   0 root         (0) root         (0)     1409 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/RootIOExample3/rootIOTree_example_write.cc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/SearchExample/
--rw-rw-r--   0 root         (0) root         (0)      705 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/SearchExample/CMakeLists.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/SearchExample/src/
--rw-rw-r--   0 root         (0) root         (0)     5325 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/SearchExample/src/search_example.cc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/ViewerExample/
--rw-rw-r--   0 root         (0) root         (0)     1915 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ViewerExample/CMakeLists.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.346034 HepMC3-3.2.5/examples/ViewerExample/cmake/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/ViewerExample/cmake/Modules/
--rw-rw-r--   0 root         (0) root         (0)     4463 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ViewerExample/cmake/Modules/FindGraphviz.cmake
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/ViewerExample/include/
--rw-rw-r--   0 root         (0) root         (0)     2541 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ViewerExample/include/HepMC3ViewerFrame.h
--rw-rw-r--   0 root         (0) root         (0)      156 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ViewerExample/include/LinkDef.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.374034 HepMC3-3.2.5/examples/ViewerExample/src/
--rw-rw-r--   0 root         (0) root         (0)    11875 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ViewerExample/src/HepMC3ViewerFrame.cc
--rw-rw-r--   0 root         (0) root         (0)      569 2022-02-21 08:27:58.000000 HepMC3-3.2.5/examples/ViewerExample/src/main.cc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/include/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.382034 HepMC3-3.2.5/include/HepMC3/
--rw-rw-r--   0 root         (0) root         (0)     1864 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/AssociatedParticle.h
--rw-rw-r--   0 root         (0) root         (0)    32331 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Attribute.h
--rw-rw-r--   0 root         (0) root         (0)     1449 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/CompressedIO.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.382034 HepMC3-3.2.5/include/HepMC3/Data/
--rw-rw-r--   0 root         (0) root         (0)     1899 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Data/GenEventData.h
--rw-rw-r--   0 root         (0) root         (0)      878 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Data/GenParticleData.h
--rw-rw-r--   0 root         (0) root         (0)      926 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Data/GenRunInfoData.h
--rw-rw-r--   0 root         (0) root         (0)      755 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Data/GenVertexData.h
--rw-rw-r--   0 root         (0) root         (0)     1278 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Errors.h
--rw-rw-r--   0 root         (0) root         (0)    11725 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/FourVector.h
--rw-rw-r--   0 root         (0) root         (0)     4719 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenCrossSection.h
--rw-rw-r--   0 root         (0) root         (0)      511 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenCrossSection_fwd.h
--rw-rw-r--   0 root         (0) root         (0)    15912 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenEvent.h
--rw-rw-r--   0 root         (0) root         (0)     8331 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenHeavyIon.h
--rw-rw-r--   0 root         (0) root         (0)      475 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenHeavyIon_fwd.h
--rw-rw-r--   0 root         (0) root         (0)     5667 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenParticle.h
--rw-rw-r--   0 root         (0) root         (0)      971 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenParticle_fwd.h
--rw-rw-r--   0 root         (0) root         (0)     1974 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenPdfInfo.h
--rw-rw-r--   0 root         (0) root         (0)      466 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenPdfInfo_fwd.h
--rw-rw-r--   0 root         (0) root         (0)     5819 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenRunInfo.h
--rw-rw-r--   0 root         (0) root         (0)     5310 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenVertex.h
--rw-rw-r--   0 root         (0) root         (0)      616 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/GenVertex_fwd.h
--rw-rw-r--   0 root         (0) root         (0)    19025 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/HEPEVT_Helpers.h
--rw-rw-r--   0 root         (0) root         (0)    12151 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper.h
--rw-rw-r--   0 root         (0) root         (0)     6051 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper_Runtime.h
--rw-rw-r--   0 root         (0) root         (0)    11204 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper_Runtime_Static.h
--rw-rw-r--   0 root         (0) root         (0)    12675 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper_Template.h
--rw-rw-r--   0 root         (0) root         (0)      496 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/HepMC3.h
--rw-rw-r--   0 root         (0) root         (0)    87975 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/LHEF.h
--rw-rw-r--   0 root         (0) root         (0)     2653 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/LHEFAttributes.h
--rw-rw-r--   0 root         (0) root         (0)     4652 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Print.h
--rw-rw-r--   0 root         (0) root         (0)     2736 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/PrintStreams.h
--rw-rw-r--   0 root         (0) root         (0)     1761 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Reader.h
--rw-rw-r--   0 root         (0) root         (0)     5689 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderAscii.h
--rw-rw-r--   0 root         (0) root         (0)     4279 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderAsciiHepMC2.h
--rw-rw-r--   0 root         (0) root         (0)    10031 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderFactory.h
--rw-rw-r--   0 root         (0) root         (0)     2110 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderGZ.h
--rw-rw-r--   0 root         (0) root         (0)     2014 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderHEPEVT.h
--rw-rw-r--   0 root         (0) root         (0)     1751 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderLHEF.h
--rw-rw-r--   0 root         (0) root         (0)     3165 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderMT.h
--rw-rw-r--   0 root         (0) root         (0)     1337 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/ReaderPlugin.h
--rw-rw-r--   0 root         (0) root         (0)     1687 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Setup.h
--rw-rw-r--   0 root         (0) root         (0)     2664 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Units.h
--rw-rw-r--   0 root         (0) root         (0)     2389 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Version.h
--rw-rw-r--   0 root         (0) root         (0)     1668 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/Writer.h
--rw-rw-r--   0 root         (0) root         (0)     4032 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/WriterAscii.h
--rw-rw-r--   0 root         (0) root         (0)     3882 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/WriterAsciiHepMC2.h
--rw-rw-r--   0 root         (0) root         (0)     2053 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/WriterGZ.h
--rw-rw-r--   0 root         (0) root         (0)     2727 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/WriterHEPEVT.h
--rw-rw-r--   0 root         (0) root         (0)     1488 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/WriterPlugin.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.386034 HepMC3-3.2.5/include/HepMC3/bxzstr/
--rw-rw-r--   0 root         (0) root         (0)    16724 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/LICENSE
--rw-rw-r--   0 root         (0) root         (0)    11851 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/bxzstr.hpp
--rw-rw-r--   0 root         (0) root         (0)     3726 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/bz_stream_wrapper.hpp
--rw-rw-r--   0 root         (0) root         (0)     3490 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/compression_types.hpp
--rw-rw-r--   0 root         (0) root         (0)      153 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/config.hpp
--rw-rw-r--   0 root         (0) root         (0)     3805 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/lzma_stream_wrapper.hpp
--rw-rw-r--   0 root         (0) root         (0)     1147 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/stream_wrapper.hpp
--rw-rw-r--   0 root         (0) root         (0)     6340 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/strict_fstream.hpp
--rw-rw-r--   0 root         (0) root         (0)     3550 2022-02-21 08:27:58.000000 HepMC3-3.2.5/include/HepMC3/bxzstr/z_stream_wrapper.hpp
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/interfaces/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/interfaces/HepMCCompatibility/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.386034 HepMC3-3.2.5/interfaces/HepMCCompatibility/include/
--rw-rw-r--   0 root         (0) root         (0)    15544 2022-02-21 08:27:58.000000 HepMC3-3.2.5/interfaces/HepMCCompatibility/include/HepMCCompatibility.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/interfaces/pythia6/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/interfaces/pythia6/include/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.386034 HepMC3-3.2.5/interfaces/pythia6/include/Pythia6/
--rw-rw-r--   0 root         (0) root         (0)    12884 2022-02-21 08:27:58.000000 HepMC3-3.2.5/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.cc
--rw-rw-r--   0 root         (0) root         (0)     1704 2022-02-21 08:27:58.000000 HepMC3-3.2.5/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.inc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/interfaces/pythia8/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/interfaces/pythia8/include/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.386034 HepMC3-3.2.5/interfaces/pythia8/include/Pythia8/
--rw-rw-r--   0 root         (0) root         (0)    10997 2022-02-21 08:27:58.000000 HepMC3-3.2.5/interfaces/pythia8/include/Pythia8/Pythia8ToHepMC3.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.386034 HepMC3-3.2.5/python/
--rw-rw-r--   0 root         (0) root         (0)    31928 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/CMakeLists.txt
--rw-rw-r--   0 root         (0) root         (0)     1800 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/all_includes.hpp.in
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.386034 HepMC3-3.2.5/python/include/
--rw-rw-r--   0 root         (0) root         (0)     1676 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/LICENSE
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.390034 HepMC3-3.2.5/python/include/pybind11/
--rw-rw-r--   0 root         (0) root         (0)    21396 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/attr.h
--rw-rw-r--   0 root         (0) root         (0)     6118 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/buffer_info.h
--rw-rw-r--   0 root         (0) root         (0)    93952 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/cast.h
--rw-rw-r--   0 root         (0) root         (0)     8185 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/chrono.h
--rw-rw-r--   0 root         (0) root         (0)      120 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/common.h
--rw-rw-r--   0 root         (0) root         (0)     2037 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/complex.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.394034 HepMC3-3.2.5/python/include/pybind11/detail/
--rw-rw-r--   0 root         (0) root         (0)    27794 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/detail/class.h
--rw-rw-r--   0 root         (0) root         (0)    39912 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/detail/common.h
--rw-rw-r--   0 root         (0) root         (0)     3602 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/detail/descr.h
--rw-rw-r--   0 root         (0) root         (0)    16397 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/detail/init.h
--rw-rw-r--   0 root         (0) root         (0)    16373 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/detail/internals.h
--rw-rw-r--   0 root         (0) root         (0)     1486 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/detail/typeid.h
--rw-rw-r--   0 root         (0) root         (0)    29087 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/eigen.h
--rw-rw-r--   0 root         (0) root         (0)     7843 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/embed.h
--rw-rw-r--   0 root         (0) root         (0)     4384 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/eval.h
--rw-rw-r--   0 root         (0) root         (0)     3709 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/functional.h
--rw-rw-r--   0 root         (0) root         (0)     5991 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/iostream.h
--rw-rw-r--   0 root         (0) root         (0)    69312 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/numpy.h
--rw-rw-r--   0 root         (0) root         (0)     9085 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/operators.h
--rw-rw-r--   0 root         (0) root         (0)     2049 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/options.h
--rw-rw-r--   0 root         (0) root         (0)   107623 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/pybind11.h
--rw-rw-r--   0 root         (0) root         (0)    65764 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/pytypes.h
--rw-rw-r--   0 root         (0) root         (0)    14136 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/stl.h
--rw-rw-r--   0 root         (0) root         (0)    23356 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/include/pybind11/stl_bind.h
--rw-rw-r--   0 root         (0) root         (0)     1367 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/pyHepMC3.egg-info.in
--rw-rw-r--   0 root         (0) root         (0)     1416 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/pyHepMC3.rootIO.egg-info.in
--rw-rw-r--   0 root         (0) root         (0)     1416 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/pyHepMC3.search.egg-info.in
--rw-rw-r--   0 root         (0) root         (0)      232 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/root_includes.hpp.in
--rw-rw-r--   0 root         (0) root         (0)      271 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/search_includes.hpp.in
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.398034 HepMC3-3.2.5/python/src/
--rw-rw-r--   0 root         (0) root         (0)       24 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/__init__.py
--rw-rw-r--   0 root         (0) root         (0)    21826 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/binders.cpp
--rw-rw-r--   0 root         (0) root         (0)     1688 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/binders.h
--rw-rw-r--   0 root         (0) root         (0)     3687 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3.binder
--rw-rw-r--   0 root         (0) root         (0)     3256 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3.cpp
--rw-rw-r--   0 root         (0) root         (0)     2022 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_0.cpp
--rw-rw-r--   0 root         (0) root         (0)    19309 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_1.cpp
--rw-rw-r--   0 root         (0) root         (0)     5459 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_10.cpp
--rw-rw-r--   0 root         (0) root         (0)     4886 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_11.cpp
--rw-rw-r--   0 root         (0) root         (0)    12591 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_12.cpp
--rw-rw-r--   0 root         (0) root         (0)    16394 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_13.cpp
--rw-rw-r--   0 root         (0) root         (0)    21317 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_14.cpp
--rw-rw-r--   0 root         (0) root         (0)    22663 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_15.cpp
--rw-rw-r--   0 root         (0) root         (0)     5969 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_16.cpp
--rw-rw-r--   0 root         (0) root         (0)    10613 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_17.cpp
--rw-rw-r--   0 root         (0) root         (0)    21951 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_18.cpp
--rw-rw-r--   0 root         (0) root         (0)     3212 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_2.cpp
--rw-rw-r--   0 root         (0) root         (0)     3947 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_3.cpp
--rw-rw-r--   0 root         (0) root         (0)    48890 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_4.cpp
--rw-rw-r--   0 root         (0) root         (0)    45398 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_5.cpp
--rw-rw-r--   0 root         (0) root         (0)    38139 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_6.cpp
--rw-rw-r--   0 root         (0) root         (0)    11921 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_7.cpp
--rw-rw-r--   0 root         (0) root         (0)    32751 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_8.cpp
--rw-rw-r--   0 root         (0) root         (0)    24089 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3_9.cpp
--rw-rw-r--   0 root         (0) root         (0)     1003 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3rootIO.binder
--rw-rw-r--   0 root         (0) root         (0)     1431 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3rootIO.cpp
--rw-rw-r--   0 root         (0) root         (0)      999 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3rootIO_0.cpp
--rw-rw-r--   0 root         (0) root         (0)     1129 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3rootIO_1.cpp
--rw-rw-r--   0 root         (0) root         (0)      983 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3rootIO_2.cpp
--rw-rw-r--   0 root         (0) root         (0)     1645 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3search.binder
--rw-rw-r--   0 root         (0) root         (0)     1305 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3search.cpp
--rw-rw-r--   0 root         (0) root         (0)     7668 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3search_0.cpp
--rw-rw-r--   0 root         (0) root         (0)     1626 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/pyHepMC3search_1.cpp
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.398034 HepMC3-3.2.5/python/src/rootIO/
--rw-rw-r--   0 root         (0) root         (0)      180 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/rootIO/__init__.py
--rw-rw-r--   0 root         (0) root         (0)     5784 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/root_binders.cpp
--rw-rw-r--   0 root         (0) root         (0)      480 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/root_binders.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.398034 HepMC3-3.2.5/python/src/search/
--rw-rw-r--   0 root         (0) root         (0)       30 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/search/__init__.py
--rw-rw-r--   0 root         (0) root         (0)     9557 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/search_binders.cpp
--rw-rw-r--   0 root         (0) root         (0)      351 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/search_binders.h
--rw-rw-r--   0 root         (0) root         (0)     2863 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/src/stl_binders.hpp
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.414034 HepMC3-3.2.5/python/test/
--rw-rw-r--   0 root         (0) root         (0)     7234 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/Pythia8ToHepMC3.py
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputDelete.hepmc
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputDelete2.hepmc
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputIO1.hepmc
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputIO2.hepmc
--rw-rw-r--   0 root         (0) root         (0)   324700 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputIO3.hepevt
--rw-rw-r--   0 root         (0) root         (0)  2127856 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputIO4.root
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputIO5.hepmc
--rw-rw-r--   0 root         (0) root         (0)   782070 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputIO6.hepmc
--rw-rw-r--   0 root         (0) root         (0)    95016 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputMass.hepmc
--rw-rw-r--   0 root         (0) root         (0)    95016 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputMultipleCopies1.hepmc
--rw-rw-r--   0 root         (0) root         (0)  1285976 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputMultipleCopies2.hepmc
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputPythonization_Search.hepmc
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputReaderFactory1.hepmc
--rw-rw-r--   0 root         (0) root         (0)   205191 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputReaderFactory2.hepmc
--rw-rw-r--   0 root         (0) root         (0)  2052000 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/inputThreads1.hepmc
--rw-rw-r--   0 root         (0) root         (0)     1412 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/pyHepMC3TestUtils.py
--rw-rw-r--   0 root         (0) root         (0)     2554 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Attribute.py
--rw-rw-r--   0 root         (0) root         (0)     4040 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Boost.py
--rw-rw-r--   0 root         (0) root         (0)     4332 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_HEPEVT.py
--rw-rw-r--   0 root         (0) root         (0)     1439 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_IO1.py
--rw-rw-r--   0 root         (0) root         (0)     1525 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_IO2.py
--rw-rw-r--   0 root         (0) root         (0)     6989 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Polarization.py
--rw-rw-r--   0 root         (0) root         (0)     4376 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Print.py
--rw-rw-r--   0 root         (0) root         (0)     1036 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Pythia8.py
--rw-rw-r--   0 root         (0) root         (0)      552 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Pythonization_FourVector.py
--rw-rw-r--   0 root         (0) root         (0)      503 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Pythonization_GenEvent.py
--rw-rw-r--   0 root         (0) root         (0)      576 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Pythonization_GenRunInfo.py
--rw-rw-r--   0 root         (0) root         (0)      848 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Pythonization_Search.py
--rw-rw-r--   0 root         (0) root         (0)      499 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Pythonization_docs.py
--rw-rw-r--   0 root         (0) root         (0)     2533 2022-02-21 08:27:58.000000 HepMC3-3.2.5/python/test/test_Units.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.414034 HepMC3-3.2.5/rootIO/
--rw-rw-r--   0 root         (0) root         (0)     1897 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/CMakeLists.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.414034 HepMC3-3.2.5/rootIO/include/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.414034 HepMC3-3.2.5/rootIO/include/HepMC3/
--rw-rw-r--   0 root         (0) root         (0)     1435 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/include/HepMC3/ReaderRoot.h
--rw-rw-r--   0 root         (0) root         (0)     2120 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/include/HepMC3/ReaderRootTree.h
--rw-rw-r--   0 root         (0) root         (0)     1673 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/include/HepMC3/WriterRoot.h
--rw-rw-r--   0 root         (0) root         (0)     2451 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/include/HepMC3/WriterRootTree.h
--rw-rw-r--   0 root         (0) root         (0)     1062 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/include/LinkDef.hh
--rw-rw-r--   0 root         (0) root         (0)      447 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/include/rootIO_Classes.hh
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.414034 HepMC3-3.2.5/rootIO/src/
--rw-rw-r--   0 root         (0) root         (0)     2262 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/src/ReaderRoot.cc
--rw-rw-r--   0 root         (0) root         (0)     3606 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/src/ReaderRootTree.cc
--rw-rw-r--   0 root         (0) root         (0)     1288 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/src/Streamers.cc
--rw-rw-r--   0 root         (0) root         (0)     2041 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/src/WriterRoot.cc
--rw-rw-r--   0 root         (0) root         (0)     2906 2022-02-21 08:27:58.000000 HepMC3-3.2.5/rootIO/src/WriterRootTree.cc
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.414034 HepMC3-3.2.5/search/
--rw-rw-r--   0 root         (0) root         (0)     2319 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/CMakeLists.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.350034 HepMC3-3.2.5/search/include/
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.414034 HepMC3-3.2.5/search/include/HepMC3/
--rw-rw-r--   0 root         (0) root         (0)     1888 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/include/HepMC3/AttributeFeature.h
--rw-rw-r--   0 root         (0) root         (0)    12571 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/include/HepMC3/Feature.h
--rw-rw-r--   0 root         (0) root         (0)     2026 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/include/HepMC3/Filter.h
--rw-rw-r--   0 root         (0) root         (0)     2157 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/include/HepMC3/FilterAttribute.h
--rw-rw-r--   0 root         (0) root         (0)    16586 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/include/HepMC3/Relatives.h
--rw-rw-r--   0 root         (0) root         (0)     6516 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/include/HepMC3/Selector.h
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.418034 HepMC3-3.2.5/search/src/
--rw-rw-r--   0 root         (0) root         (0)    12160 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/src/Relatives.cc
--rw-rw-r--   0 root         (0) root         (0)     1791 2022-02-21 08:27:58.000000 HepMC3-3.2.5/search/src/Selector.cc
--rw-r--r--   0 root         (0) root         (0)       38 2022-02-21 11:38:11.422034 HepMC3-3.2.5/setup.cfg
--rw-r--r--   0 root         (0) root         (0)    17403 2022-02-21 11:38:10.000000 HepMC3-3.2.5/setup.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2022-02-21 11:38:11.418034 HepMC3-3.2.5/src/
--rw-rw-r--   0 root         (0) root         (0)     3837 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/GenCrossSection.cc
--rw-rw-r--   0 root         (0) root         (0)    30569 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/GenEvent.cc
--rw-rw-r--   0 root         (0) root         (0)     5199 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/GenHeavyIon.cc
--rw-rw-r--   0 root         (0) root         (0)     3217 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/GenParticle.cc
--rw-rw-r--   0 root         (0) root         (0)     2818 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/GenPdfInfo.cc
--rw-rw-r--   0 root         (0) root         (0)     3768 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/GenRunInfo.cc
--rw-rw-r--   0 root         (0) root         (0)     4012 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/GenVertex.cc
--rw-rw-r--   0 root         (0) root         (0)    10934 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/HEPEVT_Wrapper.cc
--rw-rw-r--   0 root         (0) root         (0)     2303 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/LHEFAttributes.cc
--rw-rw-r--   0 root         (0) root         (0)    10748 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/Print.cc
--rw-rw-r--   0 root         (0) root         (0)    20893 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/ReaderAscii.cc
--rw-rw-r--   0 root         (0) root         (0)    27067 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/ReaderAsciiHepMC2.cc
--rw-rw-r--   0 root         (0) root         (0)     6411 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/ReaderHEPEVT.cc
--rw-rw-r--   0 root         (0) root         (0)     7121 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/ReaderLHEF.cc
--rw-rw-r--   0 root         (0) root         (0)     3903 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/ReaderPlugin.cc
--rw-rw-r--   0 root         (0) root         (0)     1042 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/Setup.cc
--rw-rw-r--   0 root         (0) root         (0)    14273 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/WriterAscii.cc
--rw-rw-r--   0 root         (0) root         (0)    17316 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/WriterAsciiHepMC2.cc
--rw-rw-r--   0 root         (0) root         (0)     4062 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/WriterHEPEVT.cc
--rw-rw-r--   0 root         (0) root         (0)     4126 2022-02-21 08:27:58.000000 HepMC3-3.2.5/src/WriterPlugin.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.201309 HepMC3-3.2.6/
+-rw-rw-r--   0 root         (0) root         (0)      277 2023-04-12 14:19:36.000000 HepMC3-3.2.6/AUTHORS
+-rw-rw-r--   0 root         (0) root         (0)    23018 2023-04-12 14:19:36.000000 HepMC3-3.2.6/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)     7652 2023-04-12 14:19:36.000000 HepMC3-3.2.6/COPYING
+-rwxrwxr-x   0 root         (0) root         (0)     3823 2023-04-12 14:19:36.000000 HepMC3-3.2.6/HepMC3-config.in
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.073309 HepMC3-3.2.6/HepMC3.egg-info/
+-rw-r--r--   0 root         (0) root         (0)      596 2023-04-12 15:30:36.000000 HepMC3-3.2.6/HepMC3.egg-info/PKG-INFO
+-rw-r--r--   0 root         (0) root         (0)    11361 2023-04-12 15:30:37.000000 HepMC3-3.2.6/HepMC3.egg-info/SOURCES.txt
+-rw-r--r--   0 root         (0) root         (0)        1 2023-04-12 15:30:36.000000 HepMC3-3.2.6/HepMC3.egg-info/dependency_links.txt
+-rw-r--r--   0 root         (0) root         (0)        9 2023-04-12 15:30:36.000000 HepMC3-3.2.6/HepMC3.egg-info/top_level.txt
+-rw-rw-r--   0 root         (0) root         (0)     1508 2023-04-12 14:19:36.000000 HepMC3-3.2.6/LICENCE
+-rw-r--r--   0 root         (0) root         (0)      836 2023-04-12 15:30:36.000000 HepMC3-3.2.6/MANIFEST.in
+-rw-r--r--   0 root         (0) root         (0)      596 2023-04-12 15:30:37.201309 HepMC3-3.2.6/PKG-INFO
+-rw-rw-r--   0 root         (0) root         (0)     4242 2023-04-12 14:19:36.000000 HepMC3-3.2.6/README-for-developers
+-rw-rw-r--   0 root         (0) root         (0)    25413 2023-04-12 14:19:36.000000 HepMC3-3.2.6/README.md
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.053309 HepMC3-3.2.6/cmake/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.077309 HepMC3-3.2.6/cmake/Modules/
+-rw-rw-r--   0 root         (0) root         (0)     1582 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/CMakeFindFrameworks.cmake
+-rw-rw-r--   0 root         (0) root         (0)     5891 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/CMakeMacroParseArguments.cmake
+-rw-rw-r--   0 root         (0) root         (0)     5324 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/Copyright.txt
+-rw-rw-r--   0 root         (0) root         (0)     2322 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindHepMC2.cmake
+-rw-rw-r--   0 root         (0) root         (0)     2318 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindMCTester.cmake
+-rw-rw-r--   0 root         (0) root         (0)    18252 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPackageHandleStandardArgs.cmake
+-rw-rw-r--   0 root         (0) root         (0)     1711 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPackageMessage.cmake
+-rw-rw-r--   0 root         (0) root         (0)     3333 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPhotospp.cmake
+-rw-rw-r--   0 root         (0) root         (0)     1640 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPyPy.cmake
+-rw-rw-r--   0 root         (0) root         (0)     2272 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPythia8.cmake
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.081309 HepMC3-3.2.6/cmake/Modules/FindPython/
+-rw-rw-r--   0 root         (0) root         (0)   153133 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPython/Support.cmake
+-rw-rw-r--   0 root         (0) root         (0)    14355 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPython2.cmake
+-rw-rw-r--   0 root         (0) root         (0)    14650 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindPython3.cmake
+-rw-rw-r--   0 root         (0) root         (0)     2584 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/FindTauolapp.cmake
+-rw-rw-r--   0 root         (0) root         (0)     3290 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Modules/SelectLibraryConfigurations.cmake
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.081309 HepMC3-3.2.6/cmake/Templates/
+-rw-rw-r--   0 root         (0) root         (0)     2632 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Templates/HepMC3Config.cmake.in
+-rw-rw-r--   0 root         (0) root         (0)     1003 2023-04-12 14:19:36.000000 HepMC3-3.2.6/cmake/Templates/cmake_uninstall.cmake.in
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.081309 HepMC3-3.2.6/doc/
+-rw-rw-r--   0 root         (0) root         (0)      816 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/CMakeLists.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.085309 HepMC3-3.2.6/doc/doxygen/
+-rw-rw-r--   0 root         (0) root         (0)        6 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/.gitignore
+-rw-rw-r--   0 root         (0) root         (0)    81147 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/Doxyfile.in
+-rw-rw-r--   0 root         (0) root         (0)     3879 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/DoxygenLayout.xml
+-rw-rw-r--   0 root         (0) root         (0)    22902 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/LHEF.txt
+-rw-rw-r--   0 root         (0) root         (0)     1805 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/Python.txt
+-rw-rw-r--   0 root         (0) root         (0)     2981 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/ReaderFactory.txt
+-rw-rw-r--   0 root         (0) root         (0)     1141 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/building.txt
+-rw-rw-r--   0 root         (0) root         (0)   240832 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/class_diagram.png
+-rw-rw-r--   0 root         (0) root         (0)   189416 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/class_diagram_3.0.png
+-rw-rw-r--   0 root         (0) root         (0)    18521 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/differences.txt
+-rw-rw-r--   0 root         (0) root         (0)     5908 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/features.txt
+-rw-rw-r--   0 root         (0) root         (0)     5425 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/mainpage.txt
+-rw-rw-r--   0 root         (0) root         (0)     5491 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/modules.txt
+-rw-rw-r--   0 root         (0) root         (0)    11515 2023-04-12 14:19:36.000000 HepMC3-3.2.6/doc/doxygen/search.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.085309 HepMC3-3.2.6/examples/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.089309 HepMC3-3.2.6/examples/BasicExamples/
+-rw-rw-r--   0 root         (0) root         (0)     2341 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/BasicExamples/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)     1613 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/BasicExamples/HepMC2_reader_example.cc
+-rw-rw-r--   0 root         (0) root         (0)     2411 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/BasicExamples/HepMC3_fileIO_example.cc
+-rw-rw-r--   0 root         (0) root         (0)     8071 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/BasicExamples/basic_tree.cc
+-rw-rw-r--   0 root         (0) root         (0)     6014 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/BasicExamples/hepevt_wrapper_example_fortran.f
+-rw-rw-r--   0 root         (0) root         (0)     6098 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/BasicExamples/hepevt_wrapper_example_main.cc
+-rw-rw-r--   0 root         (0) root         (0)     6450 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/CMakeLists.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.089309 HepMC3-3.2.6/examples/ConvertExample/
+-rw-rw-r--   0 root         (0) root         (0)     6928 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)    56224 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/cmdline.c
+-rw-rw-r--   0 root         (0) root         (0)     1518 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/cmdline.ggo
+-rw-rw-r--   0 root         (0) root         (0)    10975 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/cmdline.h
+-rw-rw-r--   0 root         (0) root         (0)    13165 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/convert_example.cc
+-rw-rw-r--   0 root         (0) root         (0)      474 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/convert_example_env.sh.in
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.093309 HepMC3-3.2.6/examples/ConvertExample/include/
+-rw-rw-r--   0 root         (0) root         (0)     1788 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/include/AnalysisExample.h
+-rw-rw-r--   0 root         (0) root         (0)     2467 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/include/ReaderuprootTree.h
+-rw-rw-r--   0 root         (0) root         (0)     1896 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/include/WriterDOT.h
+-rw-rw-r--   0 root         (0) root         (0)      908 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/include/WriterHEPEVTZEUS.h
+-rw-rw-r--   0 root         (0) root         (0)     1150 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/include/WriterRootTreeOPAL.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.093309 HepMC3-3.2.6/examples/ConvertExample/src/
+-rw-rw-r--   0 root         (0) root         (0)     2664 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/src/AnalysisExample.cc
+-rw-rw-r--   0 root         (0) root         (0)    14286 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/src/ReaderuprootTree.cc
+-rw-rw-r--   0 root         (0) root         (0)     4864 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/src/WriterDOT.cc
+-rw-rw-r--   0 root         (0) root         (0)     1850 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/src/WriterHEPEVTZEUS.cc
+-rw-rw-r--   0 root         (0) root         (0)     1135 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ConvertExample/src/WriterRootTreeOPAL.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.097309 HepMC3-3.2.6/examples/LHEFExample/
+-rw-rw-r--   0 root         (0) root         (0)     1098 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)   104373 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example.lhe
+-rw-rw-r--   0 root         (0) root         (0)    80148 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_1.plhe
+-rw-rw-r--   0 root         (0) root         (0)    74432 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_1_cmp.plhe
+-rw-rw-r--   0 root         (0) root         (0)    74432 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_1_out.plhe
+-rw-rw-r--   0 root         (0) root         (0)    76959 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_2.plhe
+-rw-rw-r--   0 root         (0) root         (0)    71504 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_2_cmp.plhe
+-rw-rw-r--   0 root         (0) root         (0)    71504 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_2_out.plhe
+-rw-rw-r--   0 root         (0) root         (0)     8569 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_cat.cc
+-rw-rw-r--   0 root         (0) root         (0)    88096 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_cmp.lhe
+-rw-rw-r--   0 root         (0) root         (0)      474 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/LHEFExample/LHEF_example_env.sh.in
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.097309 HepMC3-3.2.6/examples/Pythia6Example/
+-rw-rw-r--   0 root         (0) root         (0)     1499 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia6Example/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)     7198 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia6Example/main63.f
+-rw-rw-r--   0 root         (0) root         (0)  2897708 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia6Example/pythia-6.4.28.f
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.105309 HepMC3-3.2.6/examples/Pythia8Example/
+-rw-rw-r--   0 root         (0) root         (0)     2888 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia8Example/CMakeLists.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.057309 HepMC3-3.2.6/examples/Pythia8Example/cmake/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.105309 HepMC3-3.2.6/examples/Pythia8Example/cmake/Modules/
+-rw-rw-r--   0 root         (0) root         (0)     2019 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia8Example/cmake/Modules/FindPythia8.cmake
+-rw-rw-r--   0 root         (0) root         (0)      505 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia8Example/pythia8_ee_to_Z_to_tautau.conf
+-rw-rw-r--   0 root         (0) root         (0)     1918 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia8Example/pythia8_example.cc
+-rw-rw-r--   0 root         (0) root         (0)      507 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia8Example/pythia8_example_env.sh.in
+-rw-rw-r--   0 root         (0) root         (0)     2726 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/Pythia8Example/pythia8_pp_minbias.conf
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.105309 HepMC3-3.2.6/examples/RootIOExample/
+-rw-rw-r--   0 root         (0) root         (0)     1548 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)   189214 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample/example.hepmc3
+-rw-rw-r--   0 root         (0) root         (0)      474 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample/rootIO_example_env.sh.in
+-rw-rw-r--   0 root         (0) root         (0)     1360 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample/rootIO_example_read.cc
+-rw-rw-r--   0 root         (0) root         (0)     1381 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample/rootIO_example_write.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.109309 HepMC3-3.2.6/examples/RootIOExample2/
+-rw-rw-r--   0 root         (0) root         (0)     2349 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)      474 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/class_example_env.sh.in
+-rw-rw-r--   0 root         (0) root         (0)     2137 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/class_example_read.cc
+-rw-rw-r--   0 root         (0) root         (0)     2169 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/class_example_write.cc
+-rw-rw-r--   0 root         (0) root         (0)   189214 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/example.hepmc3
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.109309 HepMC3-3.2.6/examples/RootIOExample2/include/
+-rw-rw-r--   0 root         (0) root         (0)      180 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/include/LinkDef.h
+-rw-rw-r--   0 root         (0) root         (0)      553 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/include/MyClass.h
+-rw-rw-r--   0 root         (0) root         (0)      580 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/include/MyRunClass.h
+-rw-rw-r--   0 root         (0) root         (0)      105 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/include/myclass_Classes.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.109309 HepMC3-3.2.6/examples/RootIOExample2/src/
+-rw-rw-r--   0 root         (0) root         (0)      301 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/src/MyClass.cc
+-rw-rw-r--   0 root         (0) root         (0)      325 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample2/src/MyRunClass.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.113309 HepMC3-3.2.6/examples/RootIOExample3/
+-rw-rw-r--   0 root         (0) root         (0)     1531 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample3/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)      474 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample3/rootIOTree_example_env.sh.in
+-rw-rw-r--   0 root         (0) root         (0)     1398 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample3/rootIOTree_example_read.cc
+-rw-rw-r--   0 root         (0) root         (0)     1409 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/RootIOExample3/rootIOTree_example_write.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.113309 HepMC3-3.2.6/examples/SearchExample/
+-rw-rw-r--   0 root         (0) root         (0)      705 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/SearchExample/CMakeLists.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.113309 HepMC3-3.2.6/examples/SearchExample/src/
+-rw-rw-r--   0 root         (0) root         (0)     5311 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/SearchExample/src/search_example.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.113309 HepMC3-3.2.6/examples/ViewerExample/
+-rw-rw-r--   0 root         (0) root         (0)     1915 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ViewerExample/CMakeLists.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.061308 HepMC3-3.2.6/examples/ViewerExample/cmake/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.113309 HepMC3-3.2.6/examples/ViewerExample/cmake/Modules/
+-rw-rw-r--   0 root         (0) root         (0)     2302 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ViewerExample/cmake/Modules/FindGraphviz.cmake
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.113309 HepMC3-3.2.6/examples/ViewerExample/include/
+-rw-rw-r--   0 root         (0) root         (0)     2541 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ViewerExample/include/HepMC3ViewerFrame.h
+-rw-rw-r--   0 root         (0) root         (0)      157 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ViewerExample/include/LinkDef.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.113309 HepMC3-3.2.6/examples/ViewerExample/src/
+-rw-rw-r--   0 root         (0) root         (0)    11915 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ViewerExample/src/HepMC3ViewerFrame.cc
+-rw-rw-r--   0 root         (0) root         (0)      570 2023-04-12 14:19:36.000000 HepMC3-3.2.6/examples/ViewerExample/src/main.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.061308 HepMC3-3.2.6/include/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.129309 HepMC3-3.2.6/include/HepMC3/
+-rw-rw-r--   0 root         (0) root         (0)     1864 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/AssociatedParticle.h
+-rw-rw-r--   0 root         (0) root         (0)    33745 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Attribute.h
+-rw-rw-r--   0 root         (0) root         (0)     1655 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/CompressedIO.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.129309 HepMC3-3.2.6/include/HepMC3/Data/
+-rw-rw-r--   0 root         (0) root         (0)     1899 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Data/GenEventData.h
+-rw-rw-r--   0 root         (0) root         (0)      878 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Data/GenParticleData.h
+-rw-rw-r--   0 root         (0) root         (0)      926 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Data/GenRunInfoData.h
+-rw-rw-r--   0 root         (0) root         (0)      755 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Data/GenVertexData.h
+-rw-rw-r--   0 root         (0) root         (0)     1278 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Errors.h
+-rw-rw-r--   0 root         (0) root         (0)    11889 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/FourVector.h
+-rw-rw-r--   0 root         (0) root         (0)     6716 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenCrossSection.h
+-rw-rw-r--   0 root         (0) root         (0)      511 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenCrossSection_fwd.h
+-rw-rw-r--   0 root         (0) root         (0)    16063 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenEvent.h
+-rw-rw-r--   0 root         (0) root         (0)     8293 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenHeavyIon.h
+-rw-rw-r--   0 root         (0) root         (0)      475 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenHeavyIon_fwd.h
+-rw-rw-r--   0 root         (0) root         (0)     5604 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenParticle.h
+-rw-rw-r--   0 root         (0) root         (0)      971 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenParticle_fwd.h
+-rw-rw-r--   0 root         (0) root         (0)     1974 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenPdfInfo.h
+-rw-rw-r--   0 root         (0) root         (0)      466 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenPdfInfo_fwd.h
+-rw-rw-r--   0 root         (0) root         (0)     5819 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenRunInfo.h
+-rw-rw-r--   0 root         (0) root         (0)     5271 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenVertex.h
+-rw-rw-r--   0 root         (0) root         (0)      616 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/GenVertex_fwd.h
+-rw-rw-r--   0 root         (0) root         (0)    18896 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/HEPEVT_Helpers.h
+-rw-rw-r--   0 root         (0) root         (0)    12151 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper.h
+-rw-rw-r--   0 root         (0) root         (0)     6050 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper_Runtime.h
+-rw-rw-r--   0 root         (0) root         (0)    11204 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper_Runtime_Static.h
+-rw-rw-r--   0 root         (0) root         (0)    12680 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper_Template.h
+-rw-rw-r--   0 root         (0) root         (0)      496 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/HepMC3.h
+-rw-rw-r--   0 root         (0) root         (0)    88303 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/LHEF.h
+-rw-rw-r--   0 root         (0) root         (0)     2653 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/LHEFAttributes.h
+-rw-rw-r--   0 root         (0) root         (0)     4652 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Print.h
+-rw-rw-r--   0 root         (0) root         (0)     2736 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/PrintStreams.h
+-rw-rw-r--   0 root         (0) root         (0)     1786 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Reader.h
+-rw-rw-r--   0 root         (0) root         (0)     5689 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderAscii.h
+-rw-rw-r--   0 root         (0) root         (0)     4289 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderAsciiHepMC2.h
+-rw-rw-r--   0 root         (0) root         (0)    13001 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderFactory.h
+-rw-rw-r--   0 root         (0) root         (0)     2171 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderGZ.h
+-rw-rw-r--   0 root         (0) root         (0)     2024 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderHEPEVT.h
+-rw-rw-r--   0 root         (0) root         (0)     1763 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderLHEF.h
+-rw-rw-r--   0 root         (0) root         (0)     3370 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderMT.h
+-rw-rw-r--   0 root         (0) root         (0)     2205 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/ReaderPlugin.h
+-rw-rw-r--   0 root         (0) root         (0)     1687 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Setup.h
+-rw-rw-r--   0 root         (0) root         (0)     2664 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Units.h
+-rw-rw-r--   0 root         (0) root         (0)     2389 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Version.h
+-rw-rw-r--   0 root         (0) root         (0)     1647 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/Writer.h
+-rw-rw-r--   0 root         (0) root         (0)     4046 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/WriterAscii.h
+-rw-rw-r--   0 root         (0) root         (0)     3896 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/WriterAsciiHepMC2.h
+-rw-rw-r--   0 root         (0) root         (0)     2053 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/WriterGZ.h
+-rw-rw-r--   0 root         (0) root         (0)     2741 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/WriterHEPEVT.h
+-rw-rw-r--   0 root         (0) root         (0)     2199 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/WriterPlugin.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.133309 HepMC3-3.2.6/include/HepMC3/bxzstr/
+-rw-rw-r--   0 root         (0) root         (0)    16724 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/LICENSE
+-rw-rw-r--   0 root         (0) root         (0)    11851 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/bxzstr.hpp
+-rw-rw-r--   0 root         (0) root         (0)     3762 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/bz_stream_wrapper.hpp
+-rw-rw-r--   0 root         (0) root         (0)     4348 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/compression_types.hpp
+-rw-rw-r--   0 root         (0) root         (0)      185 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/config.hpp
+-rw-rw-r--   0 root         (0) root         (0)     3809 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/lzma_stream_wrapper.hpp
+-rw-rw-r--   0 root         (0) root         (0)     1224 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/stream_wrapper.hpp
+-rw-rw-r--   0 root         (0) root         (0)     6341 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/strict_fstream.hpp
+-rw-rw-r--   0 root         (0) root         (0)     3588 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/z_stream_wrapper.hpp
+-rw-rw-r--   0 root         (0) root         (0)     4136 2023-04-12 14:19:36.000000 HepMC3-3.2.6/include/HepMC3/bxzstr/zstd_stream_wrapper.hpp
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.065309 HepMC3-3.2.6/interfaces/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.065309 HepMC3-3.2.6/interfaces/HepMCCompatibility/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.133309 HepMC3-3.2.6/interfaces/HepMCCompatibility/include/
+-rw-rw-r--   0 root         (0) root         (0)    15544 2023-04-12 14:19:36.000000 HepMC3-3.2.6/interfaces/HepMCCompatibility/include/HepMCCompatibility.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.065309 HepMC3-3.2.6/interfaces/pythia6/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.065309 HepMC3-3.2.6/interfaces/pythia6/include/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.133309 HepMC3-3.2.6/interfaces/pythia6/include/Pythia6/
+-rw-rw-r--   0 root         (0) root         (0)    12911 2023-04-12 14:19:36.000000 HepMC3-3.2.6/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.cc
+-rw-rw-r--   0 root         (0) root         (0)     1704 2023-04-12 14:19:36.000000 HepMC3-3.2.6/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.inc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.065309 HepMC3-3.2.6/interfaces/pythia8/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.065309 HepMC3-3.2.6/interfaces/pythia8/include/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.133309 HepMC3-3.2.6/interfaces/pythia8/include/Pythia8/
+-rw-rw-r--   0 root         (0) root         (0)    10997 2023-04-12 14:19:36.000000 HepMC3-3.2.6/interfaces/pythia8/include/Pythia8/Pythia8ToHepMC3.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.133309 HepMC3-3.2.6/protobufIO/
+-rw-rw-r--   0 root         (0) root         (0)     3361 2023-04-12 14:19:36.000000 HepMC3-3.2.6/protobufIO/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)     2038 2023-04-12 14:19:36.000000 HepMC3-3.2.6/protobufIO/HepMC3.proto
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.065309 HepMC3-3.2.6/protobufIO/include/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.137309 HepMC3-3.2.6/protobufIO/include/HepMC3/
+-rw-rw-r--   0 root         (0) root         (0)     4949 2023-04-12 14:19:36.000000 HepMC3-3.2.6/protobufIO/include/HepMC3/Readerprotobuf.h
+-rw-rw-r--   0 root         (0) root         (0)     2778 2023-04-12 14:19:36.000000 HepMC3-3.2.6/protobufIO/include/HepMC3/Writerprotobuf.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.137309 HepMC3-3.2.6/protobufIO/src/
+-rw-rw-r--   0 root         (0) root         (0)    11083 2023-04-12 14:19:36.000000 HepMC3-3.2.6/protobufIO/src/Readerprotobuf.cc
+-rw-rw-r--   0 root         (0) root         (0)     7834 2023-04-12 14:19:36.000000 HepMC3-3.2.6/protobufIO/src/Writerprotobuf.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.141309 HepMC3-3.2.6/python/
+-rw-rw-r--   0 root         (0) root         (0)    40356 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/CMakeLists.txt
+-rw-rw-r--   0 root         (0) root         (0)     1800 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/all_includes.hpp.in
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.141309 HepMC3-3.2.6/python/include/
+-rw-rw-r--   0 root         (0) root         (0)     1676 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/LICENSE
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.145309 HepMC3-3.2.6/python/include/pybind11/
+-rw-rw-r--   0 root         (0) root         (0)    23920 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/attr.h
+-rw-rw-r--   0 root         (0) root         (0)     7069 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/buffer_info.h
+-rw-rw-r--   0 root         (0) root         (0)    64793 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/cast.h
+-rw-rw-r--   0 root         (0) root         (0)     8907 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/chrono.h
+-rw-rw-r--   0 root         (0) root         (0)      120 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/common.h
+-rw-rw-r--   0 root         (0) root         (0)     2096 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/complex.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.149309 HepMC3-3.2.6/python/include/pybind11/detail/
+-rw-rw-r--   0 root         (0) root         (0)    28923 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/detail/class.h
+-rw-rw-r--   0 root         (0) root         (0)    51655 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/detail/common.h
+-rw-rw-r--   0 root         (0) root         (0)     5491 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/detail/descr.h
+-rw-rw-r--   0 root         (0) root         (0)    17971 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/detail/init.h
+-rw-rw-r--   0 root         (0) root         (0)    24196 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/detail/internals.h
+-rw-rw-r--   0 root         (0) root         (0)    44414 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/detail/type_caster_base.h
+-rw-rw-r--   0 root         (0) root         (0)     1513 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/detail/typeid.h
+-rw-rw-r--   0 root         (0) root         (0)    31441 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/eigen.h
+-rw-rw-r--   0 root         (0) root         (0)    12175 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/embed.h
+-rw-rw-r--   0 root         (0) root         (0)     5589 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/eval.h
+-rw-rw-r--   0 root         (0) root         (0)     4755 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/functional.h
+-rw-rw-r--   0 root         (0) root         (0)     6848 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/gil.h
+-rw-rw-r--   0 root         (0) root         (0)     8851 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/iostream.h
+-rw-rw-r--   0 root         (0) root         (0)    78036 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/numpy.h
+-rw-rw-r--   0 root         (0) root         (0)     9781 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/operators.h
+-rw-rw-r--   0 root         (0) root         (0)     2181 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/options.h
+-rw-rw-r--   0 root         (0) root         (0)   125927 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/pybind11.h
+-rw-rw-r--   0 root         (0) root         (0)    80901 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/pytypes.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.149309 HepMC3-3.2.6/python/include/pybind11/stl/
+-rw-rw-r--   0 root         (0) root         (0)     3551 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/stl/filesystem.h
+-rw-rw-r--   0 root         (0) root         (0)    14438 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/stl.h
+-rw-rw-r--   0 root         (0) root         (0)    26992 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/include/pybind11/stl_bind.h
+-rw-rw-r--   0 root         (0) root         (0)      130 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/protobuf_includes.hpp.in
+-rw-rw-r--   0 root         (0) root         (0)     1521 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/pyHepMC3.egg-info.in
+-rw-rw-r--   0 root         (0) root         (0)     1586 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/pyHepMC3.protobufIO.egg-info.in
+-rw-rw-r--   0 root         (0) root         (0)     1570 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/pyHepMC3.rootIO.egg-info.in
+-rw-rw-r--   0 root         (0) root         (0)     1570 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/pyHepMC3.search.egg-info.in
+-rw-rw-r--   0 root         (0) root         (0)      232 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/root_includes.hpp.in
+-rw-rw-r--   0 root         (0) root         (0)      271 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/search_includes.hpp.in
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.165309 HepMC3-3.2.6/python/src/
+-rw-rw-r--   0 root         (0) root         (0)       24 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/__init__.py
+-rw-rw-r--   0 root         (0) root         (0)    21826 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/binders.cpp
+-rw-rw-r--   0 root         (0) root         (0)     1688 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/binders.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.165309 HepMC3-3.2.6/python/src/protobufIO/
+-rw-rw-r--   0 root         (0) root         (0)       34 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/protobufIO/__init__.py
+-rw-rw-r--   0 root         (0) root         (0)     2589 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/protobuf_binders.cpp
+-rw-rw-r--   0 root         (0) root         (0)      338 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/protobuf_binders.h
+-rw-rw-r--   0 root         (0) root         (0)     3687 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3.binder
+-rw-rw-r--   0 root         (0) root         (0)     3621 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3.cpp
+-rw-rw-r--   0 root         (0) root         (0)     2022 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_0.cpp
+-rw-rw-r--   0 root         (0) root         (0)    19317 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_1.cpp
+-rw-rw-r--   0 root         (0) root         (0)     8574 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_10.cpp
+-rw-rw-r--   0 root         (0) root         (0)     7757 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_11.cpp
+-rw-rw-r--   0 root         (0) root         (0)    21145 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_12.cpp
+-rw-rw-r--   0 root         (0) root         (0)    33866 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_13.cpp
+-rw-rw-r--   0 root         (0) root         (0)    21381 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_14.cpp
+-rw-rw-r--   0 root         (0) root         (0)    22663 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_15.cpp
+-rw-rw-r--   0 root         (0) root         (0)     6452 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_16.cpp
+-rw-rw-r--   0 root         (0) root         (0)    10613 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_17.cpp
+-rw-rw-r--   0 root         (0) root         (0)    32753 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_18.cpp
+-rw-rw-r--   0 root         (0) root         (0)     2943 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_2.cpp
+-rw-rw-r--   0 root         (0) root         (0)     4105 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_3.cpp
+-rw-rw-r--   0 root         (0) root         (0)    48909 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_4.cpp
+-rw-rw-r--   0 root         (0) root         (0)    45388 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_5.cpp
+-rw-rw-r--   0 root         (0) root         (0)    38132 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_6.cpp
+-rw-rw-r--   0 root         (0) root         (0)    13579 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_7.cpp
+-rw-rw-r--   0 root         (0) root         (0)    33181 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_8.cpp
+-rw-rw-r--   0 root         (0) root         (0)    26941 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3_9.cpp
+-rw-rw-r--   0 root         (0) root         (0)      785 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3protobufIO.binder
+-rw-rw-r--   0 root         (0) root         (0)     1195 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3protobufIO.cpp
+-rw-rw-r--   0 root         (0) root         (0)     1165 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3protobufIO_0.cpp
+-rw-rw-r--   0 root         (0) root         (0)     1003 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3rootIO.binder
+-rw-rw-r--   0 root         (0) root         (0)     1796 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3rootIO.cpp
+-rw-rw-r--   0 root         (0) root         (0)      999 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3rootIO_0.cpp
+-rw-rw-r--   0 root         (0) root         (0)     1129 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3rootIO_1.cpp
+-rw-rw-r--   0 root         (0) root         (0)      983 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3rootIO_2.cpp
+-rw-rw-r--   0 root         (0) root         (0)     1645 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3search.binder
+-rw-rw-r--   0 root         (0) root         (0)     1670 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3search.cpp
+-rw-rw-r--   0 root         (0) root         (0)     7633 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3search_0.cpp
+-rw-rw-r--   0 root         (0) root         (0)     1626 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/pyHepMC3search_1.cpp
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.165309 HepMC3-3.2.6/python/src/rootIO/
+-rw-rw-r--   0 root         (0) root         (0)      236 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/rootIO/__init__.py
+-rw-rw-r--   0 root         (0) root         (0)     5784 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/root_binders.cpp
+-rw-rw-r--   0 root         (0) root         (0)      480 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/root_binders.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.165309 HepMC3-3.2.6/python/src/search/
+-rw-rw-r--   0 root         (0) root         (0)       30 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/search/__init__.py
+-rw-rw-r--   0 root         (0) root         (0)     9750 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/search_binders.cpp
+-rw-rw-r--   0 root         (0) root         (0)      351 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/search_binders.h
+-rw-rw-r--   0 root         (0) root         (0)     2863 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/src/stl_binders.hpp
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.185309 HepMC3-3.2.6/python/test/
+-rw-rw-r--   0 root         (0) root         (0)     7234 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/Pythia8ToHepMC3.py
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputDelete.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputDelete2.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO1.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO2.hepmc
+-rw-rw-r--   0 root         (0) root         (0)      464 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO20.proto
+-rw-rw-r--   0 root         (0) root         (0)   205343 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO26.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   324700 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO3.hepevt
+-rw-rw-r--   0 root         (0) root         (0)  2127856 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO4.root
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO5.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   782070 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputIO6.hepmc
+-rw-rw-r--   0 root         (0) root         (0)    95016 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputMass.hepmc
+-rw-rw-r--   0 root         (0) root         (0)    95016 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputMultipleCopies1.hepmc
+-rw-rw-r--   0 root         (0) root         (0)  1285976 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputMultipleCopies2.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputPythonization_Search.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputReaderFactory1.hepmc
+-rw-rw-r--   0 root         (0) root         (0)   205191 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputReaderFactory2.hepmc
+-rw-rw-r--   0 root         (0) root         (0)  2052000 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/inputThreads1.hepmc
+-rw-rw-r--   0 root         (0) root         (0)     1744 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/pyHepMC3TestUtils.py
+-rw-rw-r--   0 root         (0) root         (0)     2554 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Attribute.py
+-rw-rw-r--   0 root         (0) root         (0)     4040 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Boost.py
+-rw-rw-r--   0 root         (0) root         (0)     4332 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_HEPEVT.py
+-rw-rw-r--   0 root         (0) root         (0)     1439 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_IO1.py
+-rw-rw-r--   0 root         (0) root         (0)     1525 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_IO2.py
+-rw-rw-r--   0 root         (0) root         (0)     6989 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Polarization.py
+-rw-rw-r--   0 root         (0) root         (0)     4376 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Print.py
+-rw-rw-r--   0 root         (0) root         (0)     1570 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Protobuf.py
+-rw-rw-r--   0 root         (0) root         (0)     1036 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Pythia8.py
+-rw-rw-r--   0 root         (0) root         (0)      552 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Pythonization_FourVector.py
+-rw-rw-r--   0 root         (0) root         (0)      503 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Pythonization_GenEvent.py
+-rw-rw-r--   0 root         (0) root         (0)      576 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Pythonization_GenRunInfo.py
+-rw-rw-r--   0 root         (0) root         (0)      848 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Pythonization_Search.py
+-rw-rw-r--   0 root         (0) root         (0)      499 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Pythonization_docs.py
+-rw-rw-r--   0 root         (0) root         (0)     2533 2023-04-12 14:19:36.000000 HepMC3-3.2.6/python/test/test_Units.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.185309 HepMC3-3.2.6/rootIO/
+-rw-rw-r--   0 root         (0) root         (0)     2480 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/CMakeLists.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.189309 HepMC3-3.2.6/rootIO/include/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.189309 HepMC3-3.2.6/rootIO/include/HepMC3/
+-rw-rw-r--   0 root         (0) root         (0)     1435 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/include/HepMC3/ReaderRoot.h
+-rw-rw-r--   0 root         (0) root         (0)     2120 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/include/HepMC3/ReaderRootTree.h
+-rw-rw-r--   0 root         (0) root         (0)     1673 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/include/HepMC3/WriterRoot.h
+-rw-rw-r--   0 root         (0) root         (0)     2451 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/include/HepMC3/WriterRootTree.h
+-rw-rw-r--   0 root         (0) root         (0)     1062 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/include/LinkDef.hh
+-rw-rw-r--   0 root         (0) root         (0)      447 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/include/rootIO_Classes.hh
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.189309 HepMC3-3.2.6/rootIO/src/
+-rw-rw-r--   0 root         (0) root         (0)     2219 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/src/ReaderRoot.cc
+-rw-rw-r--   0 root         (0) root         (0)     3565 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/src/ReaderRootTree.cc
+-rw-rw-r--   0 root         (0) root         (0)     1288 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/src/Streamers.cc
+-rw-rw-r--   0 root         (0) root         (0)     2068 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/src/WriterRoot.cc
+-rw-rw-r--   0 root         (0) root         (0)     2871 2023-04-12 14:19:36.000000 HepMC3-3.2.6/rootIO/src/WriterRootTree.cc
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.189309 HepMC3-3.2.6/search/
+-rw-rw-r--   0 root         (0) root         (0)     2737 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/CMakeLists.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.069309 HepMC3-3.2.6/search/include/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.193309 HepMC3-3.2.6/search/include/HepMC3/
+-rw-rw-r--   0 root         (0) root         (0)     1888 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/include/HepMC3/AttributeFeature.h
+-rw-rw-r--   0 root         (0) root         (0)    12821 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/include/HepMC3/Feature.h
+-rw-rw-r--   0 root         (0) root         (0)     2026 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/include/HepMC3/Filter.h
+-rw-rw-r--   0 root         (0) root         (0)     2157 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/include/HepMC3/FilterAttribute.h
+-rw-rw-r--   0 root         (0) root         (0)    16808 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/include/HepMC3/Relatives.h
+-rw-rw-r--   0 root         (0) root         (0)     6516 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/include/HepMC3/Selector.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.193309 HepMC3-3.2.6/search/src/
+-rw-rw-r--   0 root         (0) root         (0)    12414 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/src/Relatives.cc
+-rw-rw-r--   0 root         (0) root         (0)     1775 2023-04-12 14:19:36.000000 HepMC3-3.2.6/search/src/Selector.cc
+-rw-r--r--   0 root         (0) root         (0)       38 2023-04-12 15:30:37.201309 HepMC3-3.2.6/setup.cfg
+-rw-r--r--   0 root         (0) root         (0)    17352 2023-04-12 15:30:36.000000 HepMC3-3.2.6/setup.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-04-12 15:30:37.201309 HepMC3-3.2.6/src/
+-rw-rw-r--   0 root         (0) root         (0)     4686 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/GenCrossSection.cc
+-rw-rw-r--   0 root         (0) root         (0)    30975 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/GenEvent.cc
+-rw-rw-r--   0 root         (0) root         (0)     5164 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/GenHeavyIon.cc
+-rw-rw-r--   0 root         (0) root         (0)     3157 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/GenParticle.cc
+-rw-rw-r--   0 root         (0) root         (0)     2904 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/GenPdfInfo.cc
+-rw-rw-r--   0 root         (0) root         (0)     3729 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/GenRunInfo.cc
+-rw-rw-r--   0 root         (0) root         (0)     3974 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/GenVertex.cc
+-rw-rw-r--   0 root         (0) root         (0)    11414 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/HEPEVT_Wrapper.cc
+-rw-rw-r--   0 root         (0) root         (0)     2367 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/LHEFAttributes.cc
+-rw-rw-r--   0 root         (0) root         (0)    10899 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/Print.cc
+-rw-rw-r--   0 root         (0) root         (0)    21320 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/ReaderAscii.cc
+-rw-rw-r--   0 root         (0) root         (0)    28508 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/ReaderAsciiHepMC2.cc
+-rw-rw-r--   0 root         (0) root         (0)     6263 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/ReaderHEPEVT.cc
+-rw-rw-r--   0 root         (0) root         (0)    10151 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/ReaderLHEF.cc
+-rw-rw-r--   0 root         (0) root         (0)     3765 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/ReaderPlugin.cc
+-rw-rw-r--   0 root         (0) root         (0)     1042 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/Setup.cc
+-rw-rw-r--   0 root         (0) root         (0)    14229 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/WriterAscii.cc
+-rw-rw-r--   0 root         (0) root         (0)    17413 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/WriterAsciiHepMC2.cc
+-rw-rw-r--   0 root         (0) root         (0)     4041 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/WriterHEPEVT.cc
+-rw-rw-r--   0 root         (0) root         (0)     3951 2023-04-12 14:19:36.000000 HepMC3-3.2.6/src/WriterPlugin.cc
```

### Comparing `HepMC3-3.2.5/CMakeLists.txt` & `HepMC3-3.2.6/CMakeLists.txt`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,74 @@
 cmake_minimum_required(VERSION 3.1.0 FATAL_ERROR)
 #----------------------------------------------------------------------------
 project(HepMC3)
-set(PROJECT_VERSION 3.02.05)
-SET(HEPMC3_VERSION 3.02.05)
+set(PROJECT_VERSION 3.02.06)
+SET(HEPMC3_VERSION 3.02.06)
 SET(HEPMC3_VERSION_MAJOR  3)
 SET(HEPMC3_VERSION_MINOR  2)
-SET(HEPMC3_VERSION_PATCH  5)
+SET(HEPMC3_VERSION_PATCH  6)
 
-set(CMAKE_VERBOSE_MAKEFILE ON)
+set(CMAKE_VERBOSE_MAKEFILE OFF)
 #This module respects HFS, e.g. defines lib or lib64 when it is needed.
 include("GNUInstallDirs")
 #---Setting HepMC3 Build type-----------------------------------------------
 if(CMAKE_BUILD_TYPE)
   message(STATUS "HepMC3 Build type: ${CMAKE_BUILD_TYPE}")
 else(CMAKE_BUILD_TYPE)
   set(CMAKE_BUILD_TYPE "Release")
   message(STATUS "HepMC3 Build type not specified, use: ${CMAKE_BUILD_TYPE}")
 endif(CMAKE_BUILD_TYPE)
 
+message(STATUS "HepMC3: CMAKE_VERSION=${CMAKE_VERSION}")
+if (${CMAKE_VERSION} VERSION_GREATER "3.8")
+  cmake_policy(SET CMP0069 NEW)
+endif()
+
 string(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE)
 
 #-------------Options-------------------------------------------------------
 
 option(HEPMC3_ENABLE_SEARCH      "Enables building of search library" ON)
 option(HEPMC3_ENABLE_ROOTIO      "Enables building with ROOT O/I." ON)
+option(HEPMC3_ENABLE_PROTOBUFIO  "Enables building with protobuf O/I." OFF)
 option(HEPMC3_ENABLE_PYTHON      "Enables building of Python  bindings, master switch" ON)
 option(HEPMC3_BUILD_DOCS         "Enables building of documentation" OFF)
 option(HEPMC3_BUILD_EXAMPLES     "Enables building of examples." OFF)
 option(HEPMC3_INSTALL_EXAMPLES   "Enables installation of examples." ON)
 option(HEPMC3_ENABLE_TEST        "Enables building of tests." OFF)
 option(HEPMC3_INSTALL_INTERFACES "Enables installation of HepMC3 interfaces to MC tools." OFF)
 option(HEPMC3_BUILD_STATIC_LIBS  "Enables building of static libraties." ON)
+option(HEPMC3_ENABLE_CLANG_TIDY  "Enables usage of clang-tidy." OFF)
+if (HEPMC3_ENABLE_CLANG_TIDY)
+  set(ctor_1 "-cppcoreguidelines-pro-type-reinterpret-cast,-altera-id-dependent-backward-branch,-readability-function-cognitive-complexity")
+  set(ctor_2 "-google-readability-casting,-cppcoreguidelines-pro-type-vararg,-hicpp-vararg,-altera-unroll-loops,-cppcoreguidelines-avoid-magic-numbers")
+  set(ctor_3 "-fuchsia-default-arguments-calls,-cppcoreguidelines-pro-type-cstyle-cast,-llvmlibc*,-modernize-loop-convert,-fuchsia-overloaded-operator")
+  set(ctor_4 "-readability-braces-around-statements,-readability-identifier-length,-modernize-use-trailing-return-type,-cppcoreguidelines-avoid-non-const-global-variables")
+  set(ctor_5 "-bugprone-easily-swappable-parameters,-cppcoreguidelines-pro-bounds-pointer-arithmetic,-readability-implicit-bool-conversion,-hicpp-braces-around-statements")
+  set(ctor_6 "-google-default-arguments,-readability-redundant-smartptr-get,-cppcoreguidelines-owning-memory,-llvm-include-order,-readability-magic-numbers")
+  set(ctor_7 "-performance-unnecessary-value-param,-performance-for-range-copy,-google-runtime-int,-modernize-pass-by-value,-readability-else-after-return")
+  set(ctor_8 "-cppcoreguidelines-pro-type-member-init,-hicpp-member-init,-bugprone-narrowing-conversions,-cppcoreguidelines-narrowing-conversions")
+  set(ctor_9 "-cppcoreguidelines-prefer-member-initializer,-concurrency-mt-unsafe,-readability-convert-member-functions-to-static,-clang-analyzer-core.NonNullParamChecker")
+  set(ctor_10 "-clang-analyzer-optin.cplusplus.VirtualCall,-cert-err33-c,-cert-err34-c,-cert-err58-cpp,-fuchsia-statically-constructed-objects,-misc-no-recursion")
+  set(ctor_11 "-readability-delete-null-pointer,-clang-analyzer-core.CallAndMessage,-bugprone-implicit-widening-of-multiplication-result,-cert-msc30-c,-cert-msc50-cpp,-clang-diagnostic-unused-command-line-argument,-google-build-using-namespace,-android-cloexec-fopen")
+  set(CMAKE_CXX_CLANG_TIDY "clang-tidy;--checks=*,${ctor_1},${ctor_2},${ctor_3},${ctor_4},${ctor_5},${ctor_6},${ctor_7},${ctor_8},${ctor_9},${ctor_10},${ctor_11}")
+endif()
 
 if (NOT HEPMC3_PYTHON_VERSIONS)
   set(HEPMC3_PYTHON_VERSIONS "2.X,3.X")
 endif()
 
 if (NOT HEPMC3_ROOTIO_INSTALL_LIBDIR)
   set(HEPMC3_ROOTIO_INSTALL_LIBDIR ${CMAKE_INSTALL_LIBDIR})
 endif()
 
+
 message(STATUS "HepMC3: HEPMC3_ENABLE_SEARCH         ${HEPMC3_ENABLE_SEARCH}")
 message(STATUS "HepMC3: HEPMC3_ENABLE_ROOTIO         ${HEPMC3_ENABLE_ROOTIO}")
+message(STATUS "HepMC3: HEPMC3_ENABLE_PROTOBUFIO     ${HEPMC3_ENABLE_PROTOBUFIO}")
 message(STATUS "HepMC3: HEPMC3_ENABLE_PYTHON         ${HEPMC3_ENABLE_PYTHON}")
 message(STATUS "HepMC3: HEPMC3_PYTHON_VERSIONS       ${HEPMC3_PYTHON_VERSIONS}")
 message(STATUS "HepMC3: HEPMC3_ENABLE_TEST           ${HEPMC3_ENABLE_TEST}")
 message(STATUS "HepMC3: HEPMC3_BUILD_DOCS            ${HEPMC3_BUILD_DOCS}")
 message(STATUS "HepMC3: HEPMC3_BUILD_EXAMPLES        ${HEPMC3_BUILD_EXAMPLES}")
 message(STATUS "HepMC3: HEPMC3_INSTALL_INTERFACES    ${HEPMC3_INSTALL_INTERFACES}")
 message(STATUS "HepMC3: HEPMC3_ROOTIO_INSTALL_LIBDIR ${HEPMC3_ROOTIO_INSTALL_LIBDIR}")
@@ -94,14 +117,16 @@
 
 
 #----------------------------------------------------
 include(CheckCXXCompilerFlag)
 if (NOT HEPMC3_CXX_STANDARD)
   set(HEPMC3_CXX_STANDARD 11)
 endif()
+set(HEPMC3_FEATURES "")
+set(HEPMC3_COMPONENTS "")
 if(HEPMC3_ENABLE_ROOTIO)
   set (ROOT_FIND_COMPONENTS Core RIO Tree)
   list(APPEND CMAKE_PREFIX_PATH $ENV{ROOTSYS})
   list(APPEND CMAKE_PREFIX_PATH ${ROOT_DIR})
   set(ROOT_CXX_FLAGS_BEFORE_ROOT "${ROOT_CXX_FLAGS}")
   find_package(ROOT REQUIRED COMPONENTS Core RIO Tree)
   if(ROOT_FOUND)
@@ -149,32 +174,55 @@
   else()
     message(STATUS "HepMC3 warning: ROOT needed for ROOTIO but not found")
     message(STATUS "HepMC3 warning: Skipping HepMC ROOT IO libraries")
     set(HEPMC3_ENABLE_ROOTIO OFF)
   endif()
 endif()
 
+if(HEPMC3_ENABLE_PROTOBUFIO)
+  find_package(Protobuf 2.4 REQUIRED)
+
+  if(Protobuf_PROTOC_EXECUTABLE STREQUAL "Protobuf_PROTOC_EXECUTABLE-NOTFOUND" OR NOT EXISTS ${Protobuf_PROTOC_EXECUTABLE})
+    message(FATAL_ERROR "Found libprotobuf, but cannot find proto compiler, protoc, which is required.")
+  endif()
+  add_definitions(-DHEPMC3_PROTOBUFIO)
+endif()
+
+
 #Workarounds for gcc/clang
 set(CMAKE_CXX_STANDARD ${HEPMC3_CXX_STANDARD})
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 set(CMAKE_CXX_EXTENSIONS OFF)
 CHECK_CXX_COMPILER_FLAG("-Wno-strict-aliasing" COMPILER_SUPPORTS_-Wno-strict-aliasing)
 if (COMPILER_SUPPORTS_-Wno-strict-aliasing)
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-strict-aliasing")
 endif()
+
+CHECK_CXX_COMPILER_FLAG("-Wno-unused-command-line-argument" COMPILER_SUPPORTS_-Wno-unused-command-line-argument)
+if (COMPILER_SUPPORTS_-Wno-unused-command-line-argument)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unused-command-line-argument")
+endif()
+CHECK_CXX_COMPILER_FLAG("-Wno-gnu-zero-variadic-macro-arguments" COMPILER_SUPPORTS_-Wno-gnu-zero-variadic-macro-arguments)
+if (COMPILER_SUPPORTS_-Wno-gnu-zero-variadic-macro-arguments)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-gnu-zero-variadic-macro-arguments")
+endif()
+#Workarounds for Intel
+if (${CMAKE_CXX_COMPILER_ID} MATCHES "Intel")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -diag-disable=2196")
+endif()
 #Workarounds for nvc++
-  if (${CMAKE_CXX_COMPILER_ID} MATCHES "PGI" OR ${CMAKE_CXX_COMPILER_ID} MATCHES "NVHPC")
+if (${CMAKE_CXX_COMPILER_ID} MATCHES "PGI" OR ${CMAKE_CXX_COMPILER_ID} MATCHES "NVHPC")
     set(CMAKE_CXX_EXTENSIONS ON)
     #Workaround for pybind11 templates
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wc,--pending_instantiations=0 ")
 endif()
 #Workarounds for VS
 if (MSVC OR ${CMAKE_CXX_COMPILER_ID} MATCHES "MSVC" )
 #Memory problem and false positive warnings.
-  set(MSVC_CXX_FLAGS_TO_CHECK "/bigobj" "/D_CRT_SECURE_NO_WARNINGS" "/wd4267" "/wd4244" "/wd4477")
+  set(MSVC_CXX_FLAGS_TO_CHECK "/bigobj" "/D_CRT_SECURE_NO_WARNINGS" "/wd4267" "/wd4244" "/wd4477" "/wd4251")
   foreach(fl ${MSVC_CXX_FLAGS_TO_CHECK})
     CHECK_CXX_COMPILER_FLAG(${fl} COMPILER_SUPPORTS_${fl})
     if(COMPILER_SUPPORTS_${fl})
       set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${fl}")
     endif()
   endforeach(fl ${MSVC_CXX_FLAGS_TO_CHECK})
 endif()
@@ -206,127 +254,194 @@
   ${PROJECT_SOURCE_DIR}/src/ReaderAsciiHepMC2.cc
   ${PROJECT_SOURCE_DIR}/src/ReaderLHEF.cc
   ${PROJECT_SOURCE_DIR}/src/WriterAsciiHepMC2.cc
   ${PROJECT_SOURCE_DIR}/src/ReaderPlugin.cc
   ${PROJECT_SOURCE_DIR}/src/WriterPlugin.cc
 )
 
-#We need to export all symbols on WIn to build .lib files
+#We need to export all symbols on Win to build .lib files
 set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
 
 add_library(HepMC3 SHARED ${hepmc3core_sources})
-target_include_directories(HepMC3 PUBLIC ${PROJECT_SOURCE_DIR}/include)
-set_target_properties(HepMC3 PROPERTIES OUTPUT_NAME HepMC3  SOVERSION 3
-                                               ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>)
-if (UNIX)
-  target_link_libraries(HepMC3 PRIVATE dl)
-endif()
+target_include_directories(HepMC3 PUBLIC
+  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+  $<INSTALL_INTERFACE:include>)
+set_target_properties(HepMC3 PROPERTIES OUTPUT_NAME HepMC3 SOVERSION 3
+  ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+  LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+  RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+  EXPORT_NAME HepMC3::HepMC3)
+
+# Alias for packages that include this as a sub-project but
+# want to use the namespaced target names
+add_library(HepMC3::HepMC3 ALIAS HepMC3)
+target_link_libraries(HepMC3 PRIVATE ${CMAKE_DL_LIBS})
 #---Install build products---------------------------------------------------
-install(TARGETS HepMC3 DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT libs)
+install(TARGETS HepMC3
+  EXPORT HepMC3Targets
+  DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  COMPONENT libs)
 
 if (HEPMC3_BUILD_STATIC_LIBS)
-  add_library(HepMC3_static STATIC  ${hepmc3core_sources})
-  target_include_directories(HepMC3_static PUBLIC ${PROJECT_SOURCE_DIR}/include)
+  add_library(HepMC3_static STATIC ${hepmc3core_sources})
+
+  target_include_directories(HepMC3_static PUBLIC
+    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:include>)
   target_compile_definitions(HepMC3_static PRIVATE HEPMC3_NO_EXPORTS)
   set_target_properties(HepMC3_static PROPERTIES OUTPUT_NAME HepMC3-static
-                                               ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>)
-  if (UNIX)
-    target_link_libraries(HepMC3_static PRIVATE dl)
-  endif()
+    ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+    LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+    RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+    EXPORT_NAME HepMC3::HepMC3_static)
+
+  target_link_libraries(HepMC3_static PRIVATE ${CMAKE_DL_LIBS})
 #---Install build products---------------------------------------------------
-  install(TARGETS HepMC3_static DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT libs)
+  install(TARGETS HepMC3_static
+    EXPORT HepMC3Targets
+    DESTINATION ${CMAKE_INSTALL_LIBDIR}
+    COMPONENT libs)
+  # Alias for packages that include this as a sub-project but
+  # want to use the namespaced target names
+  add_library(HepMC3::HepMC3_static ALIAS HepMC3_static)
 endif()
 
 install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT devel)
 
-# Generate config CMake files to be used by other projects
-#
-
-include(CMakePackageConfigHelpers)
-
-set(INTERFACES_INSTALL_DIR ${CMAKE_INSTALL_DATADIR}/HepMC3/interfaces)
-set(CONFIG_INSTALL_DIR ${CMAKE_INSTALL_DATADIR}/HepMC3/cmake)
-
-configure_package_config_file(cmake/Templates/HepMC3Config.cmake.in
-  ${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config.cmake
-  INSTALL_DESTINATION ${CONFIG_INSTALL_DIR}
-  PATH_VARS CMAKE_INSTALL_INCLUDEDIR
-            CMAKE_INSTALL_LIBDIR
-            HEPMC3_ROOTIO_INSTALL_LIBDIR
-            INTERFACES_INSTALL_DIR)
-
-write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config-version.cmake COMPATIBILITY SameMajorVersion VERSION ${PROJECT_VERSION})
-
-configure_package_config_file(HepMC3-config.in
-  ${CMAKE_CURRENT_BINARY_DIR}/outputs/bin/HepMC3-config
-  INSTALL_DESTINATION ${CMAKE_INSTALL_BINDIR}
-  PATH_VARS CMAKE_INSTALL_INCLUDEDIR
-            CMAKE_INSTALL_LIBDIR
-            HEPMC3_ROOTIO_INSTALL_LIBDIR
-            INTERFACES_INSTALL_DIR)
-
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config.cmake
-              ${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config-version.cmake
-        DESTINATION ${CONFIG_INSTALL_DIR} COMPONENT devel)
-
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/outputs/bin/HepMC3-config
-        DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT libs
-        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)
-
 ########################################################################
 ## Optional packages
 ########################################################################
+set(INTERFACES_INSTALL_DIR ${CMAKE_INSTALL_DATADIR}/HepMC3/interfaces)
+
 #Search engine
 if(HEPMC3_ENABLE_SEARCH)
   add_subdirectory(search)
+  list(APPEND HEPMC3_FEATURES "search")
+  list(APPEND HEPMC3_COMPONENTS "search")
 endif()
 
 #Interfaces for some MCEGs
 if (HEPMC3_INSTALL_INTERFACES)
   install(DIRECTORY interfaces/ DESTINATION ${INTERFACES_INSTALL_DIR} COMPONENT devel)
+  list(APPEND HEPMC3_FEATURES "interfaces")
+  list(APPEND HEPMC3_FEATURES "interfaceshepmc2")
+  list(APPEND HEPMC3_FEATURES "interfacespythia6")
+  list(APPEND HEPMC3_FEATURES "interfacespythia8")
 endif()
 
 # ROOT support
 if(ROOT_FOUND)
    add_subdirectory(rootIO)
+   list(APPEND HEPMC3_FEATURES "rootIO")
+   list(APPEND HEPMC3_COMPONENTS "rootIO")
+endif()
+
+if(Protobuf_FOUND)
+  add_subdirectory(protobufIO)
+  list(APPEND HEPMC3_FEATURES "protobufIO")
+  list(APPEND HEPMC3_FEATURES "protobufIO${Protobuf_VERSION}")
+  list(APPEND HEPMC3_COMPONENTS "protobufIO")
 endif()
 
 # Add the examples subdirectories
 if(HEPMC3_BUILD_EXAMPLES)
   set(HepMC_DIR ${CMAKE_BINARY_DIR} CACHE PATH "Current build directory")
   add_subdirectory(examples)
 endif()
 if (HEPMC3_INSTALL_EXAMPLES)
-  install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/examples/ DESTINATION  ${CMAKE_INSTALL_DOCDIR}/examples COMPONENT doc  
-          FILES_MATCHING PATTERN "*"   
-          PATTERN "*CMakeFiles*" EXCLUDE  
-          PATTERN "Makefile" EXCLUDE  
-          PATTERN "*cmake_install.cmake*" EXCLUDE  
+  install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/examples/ DESTINATION  ${CMAKE_INSTALL_DOCDIR}/examples COMPONENT doc
+          FILES_MATCHING PATTERN "*"
+          PATTERN "*CMakeFiles*" EXCLUDE
+          PATTERN "Makefile" EXCLUDE
+          PATTERN "*cmake_install.cmake*" EXCLUDE
           PATTERN "*libAnalysis*" EXCLUDE )
+  list(APPEND HEPMC3_FEATURES "examples")
 endif()
 
 if(HEPMC3_BUILD_DOCS)
   add_subdirectory(doc)
+  list(APPEND HEPMC3_FEATURES "doc")
 endif()
 
 #test suite
 if(HEPMC3_ENABLE_TEST)
   ENABLE_TESTING()
   add_subdirectory(test)
 endif()
 
 #Python bindings
 if(HEPMC3_ENABLE_PYTHON)
   add_subdirectory(python)
+  list(APPEND HEPMC3_FEATURES "python")
 endif()
 
+STRING(REPLACE ";" " " HEPMC3_FEATURES "${HEPMC3_FEATURES}")
+
+# Generate config CMake files to be used by other projects
+#
+
+include(CMakePackageConfigHelpers)
+
+set(CONFIG_INSTALL_DIR ${CMAKE_INSTALL_DATADIR}/HepMC3/cmake)
+
+configure_package_config_file(cmake/Templates/HepMC3Config.cmake.in
+  ${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config.cmake
+  INSTALL_DESTINATION ${CONFIG_INSTALL_DIR}
+  PATH_VARS CMAKE_INSTALL_INCLUDEDIR
+            CMAKE_INSTALL_LIBDIR
+            HEPMC3_ROOTIO_INSTALL_LIBDIR
+            INTERFACES_INSTALL_DIR)
+
+write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config-version.cmake
+  COMPATIBILITY SameMajorVersion VERSION ${PROJECT_VERSION})
+
+configure_package_config_file(HepMC3-config.in
+  ${CMAKE_CURRENT_BINARY_DIR}/outputs/bin/HepMC3-config
+  INSTALL_DESTINATION ${CMAKE_INSTALL_BINDIR}
+  PATH_VARS CMAKE_INSTALL_INCLUDEDIR
+            CMAKE_INSTALL_LIBDIR
+            HEPMC3_ROOTIO_INSTALL_LIBDIR
+            INTERFACES_INSTALL_DIR)
+
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config.cmake
+              ${CMAKE_CURRENT_BINARY_DIR}/outputs/share/HepMC3/cmake/HepMC3Config-version.cmake
+        DESTINATION ${CONFIG_INSTALL_DIR} COMPONENT devel)
+
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/outputs/bin/HepMC3-config
+        DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT libs
+        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)
+
+add_library(HepMC3All INTERFACE)
+target_link_libraries(HepMC3All INTERFACE HepMC3::HepMC3)
+
+if(TARGET HepMC3::HepMC3_static)
+  add_library(HepMC3All_static INTERFACE)
+  target_link_libraries(HepMC3All_static INTERFACE HepMC3::HepMC3_static)
+endif()
+
+foreach(_comp ${HEPMC3_COMPONENTS})
+  target_link_libraries(HepMC3All INTERFACE HepMC3::${_comp})
+  if(TARGET HepMC3::${_comp}_static)
+    target_link_libraries(HepMC3All_static INTERFACE HepMC3::${_comp}_static)
+  endif()
+endforeach()
+
+# Aliases for packages that include this as a sub-project but
+# want to use the namespaced target names
+add_library(HepMC3::All ALIAS HepMC3All)
+get_target_property(_all HepMC3::All INTERFACE_LINK_LIBRARIES)
+message(STATUS "HepMC3::All contains: ${_all}")
+if(TARGET HepMC3All_static)
+  add_library(HepMC3::All_static ALIAS HepMC3All_static)
+  get_target_property(_allstatic HepMC3::All_static INTERFACE_LINK_LIBRARIES)
+  message(STATUS "HepMC3::All_static contains: ${_allstatic}")
+endif()
+
+install(EXPORT HepMC3Targets DESTINATION ${CONFIG_INSTALL_DIR} COMPONENT devel)
+
 # uninstall target
 if(NOT TARGET uninstall)
     configure_file(
         "cmake/Templates/cmake_uninstall.cmake.in"
         "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
         IMMEDIATE @ONLY)
   add_custom_target(uninstall  COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)
@@ -335,26 +450,30 @@
 find_program (ASTYLE NAMES astyle)
 if (ASTYLE)
   message(STATUS "HepMC3: Developers only: astyle found in ${ASTYLE}. Formating of C++ code is possible.")
   ADD_CUSTOM_TARGET(beauty
     COMMAND ${ASTYLE}  --keep-one-line-blocks
     src/*cc
     rootIO/src/*cc
+    protobufIO/src/*cc
     search/src/*cc
     include/HepMC3/Reader*h
     include/HepMC3/Writer*h
     include/HepMC3/*HEPEVT*h
     include/HepMC3/Gen*h
     include/HepMC3/Com*h
+    include/HepMC3/Att*h
     examples/*/src/*cc
+    examples/*/convert_example.cc
     examples/*/include/*h
     test/*cc
     test/*h
     interfaces/*/include/*.h
     interfaces/*/include/*/*.h
+    interfaces/*/include/*/*.cc
     WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
   )
 endif()
 find_program (BLACK NAMES black)
 if (BLACK)
   message(STATUS "HepMC3: Developers only: black found in ${BLACK}. Formating of Python code is possible.")
   ADD_CUSTOM_TARGET(beautypython COMMAND ${BLACK} -l 120  python/src/*py python/test/*py WORKING_DIRECTORY ${PROJECT_SOURCE_DIR} )
@@ -364,14 +483,15 @@
   message(STATUS "HepMC3: Developers only: cppcheck found in ${CPPCHECK}. Static analysis of C++ code is possible.")
   ADD_CUSTOM_TARGET(staticcheck
     COMMAND ${CPPCHECK} --force  --suppress=unusedFunction -v -x c++ --std=c++11 --enable=all
       -I./include -I./search/include -I./rootIO/include -I${ROOT_INCLUDE_DIRS}
       src/*.cc
       search/src/*.cc
       rootIO/src/*.cc
+      protobufIO/src/*.cc
       include/HepMC3/Reader*h
       include/HepMC3/Writer*h
       include/HepMC3/HEPEVT*h
       include/HepMC3/Gen*h
       include/HepMC3/Com*h
       examples/*/src/*cc
       examples/*/include/*h
@@ -387,15 +507,15 @@
 
 set(CPACK_PACKAGE_NAME "HepMC3")
 set(CPACK_PACKAGE_VENDOR "HepMC3 Developers")
 #Should the version be defined above?
 set(CPACK_PACKAGE_VERSION 3)
 set(CPACK_PACKAGE_VERSION_MAJOR 3)
 set(CPACK_PACKAGE_VERSION_MINOR 2)
-set(CPACK_PACKAGE_VERSION_PATCH 5)
+set(CPACK_PACKAGE_VERSION_PATCH 6)
 set(CPACK_PACKAGE_RELEASE 0)
 set(CPACK_PACKAGE_FILE_NAME "HepMC3")
 set(CPACK_PACKAGE_DESCRIPTION "Event record library for high energy physics Monte Carlo")
 
 set(CPACK_PACKAGING_INSTALL_PREFIX "/usr")
 SET(CPACK_INSTALL_PREFIX "/usr")
 SET(CPACK_OUTPUT_FILE_PREFIX binpackages)
@@ -420,8 +540,12 @@
 endif()
 if(ROOT_FOUND)
   list(APPEND CPACK_COMPONENTS_ALL   rootIOdevel rootIOlibs)
   if (HEPMC3_ENABLE_PYTHON)
     list(APPEND CPACK_COMPONENTS_ALL   pythonrootIO)
   endif()
 endif()
+
+if(Protobuf_FOUND)
+  list(APPEND CPACK_COMPONENTS_ALL protobufIOdevel protobufIOlibs)
+endif()
 INCLUDE(CPack)
```

### Comparing `HepMC3-3.2.5/HepMC3-config.in` & `HepMC3-3.2.6/HepMC3-config.in`

 * *Files 7% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 #!/bin/bash
 #Adopted from
 #https://yoda.hepforge.org/trac/browser/bin/yoda-config.in
 #Docs from https://cmake.org/cmake/help/v3.2/command/configure_file.html
 ## @configure_input@
 #The line below assures at least some relocation.
 if [ "$(uname)" == "Darwin" ]; then
-PACKAGE_PREFIX_DIR=$(dirname $(dirname $(greadlink -f $0)))
+PACKAGE_BIN_DIR=$(dirname $(greadlink -f $0))
 else
-PACKAGE_PREFIX_DIR=$(dirname $(dirname $(readlink -f $0)))
+PACKAGE_BIN_DIR=$(dirname $(readlink -f $0))
 fi
+PACKAGE_PREFIX_DIR=$(dirname ${PACKAGE_BIN_DIR})
+
 tmp=$(echo $* | egrep -- '--\<help\>|-\<h\>')
 if test $# -eq 0 || test -n "$tmp"; then
     echo "@PROJECT_NAME@-config: configuration tool for the @PROJECT_NAME@ library"
     echo
     echo "Usage: $( basename $0 ) [--help|-h] | "
     echo "           [--{prefix,libdir,includedir,interfacesdir}] | "
     echo "           [--{cxxflags,ldflags,libs}] | "
@@ -24,17 +26,19 @@
     echo "  --includedir    : show the path to the directory containing the @PROJECT_NAME@ headers"
     echo "  --libdir        : show the path to the directory containing the @PROJECT_NAME@ libraries"
     echo "  --interfacesdir : show the path to the directory containing the interfaces to @PROJECT_NAME@"
     echo
     echo "  --cflags|--cppflags : returns a '-I' string for insertion into CPPFLAGS or CXXFLAGS"
     echo "  --ldflags|--libs    : returns a '-L/-l' string for insertion into LIBS or LIBADD"
     echo "  --rootIO            : returns a '-L/-l' string for insertion into LIBS or LIBADD with rootIO support"
+    echo "  --protobufIO        : returns a '-L/-l' string for insertion into LIBS or LIBADD with protobufIO support"
     echo "  --search            : returns a '-L/-l' string for insertion into LIBS or LIBADD with search support"
     echo "  --static            : returns a string for insertion into LIBS or LIBADD"
     echo
+    echo "  --features          : returns the list of enabled features in this HepMC3 build"
     echo "  --version           : returns the @PROJECT_NAME@ release version number"
     exit 0
 fi
 
 OUT=""
 
 tmp=$( echo "$*" | egrep -- '--\<prefix\>')
@@ -53,29 +57,38 @@
 test -n "$tmp" && OUT="$OUT -I@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@"
 
 
 tmp=$( echo "$*" | egrep -- '--\<static\>')
 if test -n "$tmp"; then
 
 tmp=$( echo "$*" | egrep -- '--\<ldflags|libs\>')
-OUT="$OUT @PACKAGE_CMAKE_INSTALL_LIBDIR@/libHepMC3_static.a"
+OUT="$OUT @PACKAGE_CMAKE_INSTALL_LIBDIR@/libHepMC3-static.a"
 
 tmp=$( echo "$*" | egrep -- '--\<search\>')
-test -n "$tmp" && OUT="$OUT @PACKAGE_CMAKE_INSTALL_LIBDIR@/libHepMC3search_static.a"
+test -n "$tmp" && OUT="$OUT @PACKAGE_CMAKE_INSTALL_LIBDIR@/libHepMC3search-static.a"
+
+tmp=$( echo "$*" | egrep -- '--\<protobufIO\>')
+test -n "$tmp" && OUT="$OUT @PACKAGE_CMAKE_INSTALL_LIBDIR@/libHepMC3protobufIO_static.a"
 
 else
 
 tmp=$( echo "$*" | egrep -- '--\<ldflags|libs\>')
 test -n "$tmp" && OUT="$OUT -L@PACKAGE_CMAKE_INSTALL_LIBDIR@ -lHepMC3"
 
 tmp=$( echo "$*" | egrep -- '--\<search\>')
 test -n "$tmp" && OUT="$OUT -L@PACKAGE_CMAKE_INSTALL_LIBDIR@ -lHepMC3search"
 
+tmp=$( echo "$*" | egrep -- '--\<protobufIO\>')
+test -n "$tmp" && OUT="$OUT -L@PACKAGE_CMAKE_INSTALL_LIBDIR@ -lHepMC3protobufIO"
+
 fi
 
 tmp=$( echo "$*" | egrep -- '--\<rootIO\>')
 test -n "$tmp" && OUT="$OUT -L@PACKAGE_HEPMC3_ROOTIO_INSTALL_LIBDIR@ @HEPMC3_ROOTIO_LIBRARY@"
 
+tmp=$( echo "$*" | egrep -- '--\<features\>')
+test -n "$tmp" && OUT="$OUT @HEPMC3_FEATURES@"
+
 tmp=$( echo "$*" | egrep -- '--\<version\>')
 test -n "$tmp" && echo @PROJECT_VERSION@ && exit 0
 
 echo $OUT
```

### Comparing `HepMC3-3.2.5/HepMC3.egg-info/PKG-INFO` & `HepMC3-3.2.6/HepMC3.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,17 @@
 Metadata-Version: 2.1
 Name: HepMC3
-Version: 3.2.5
+Version: 3.2.6
 Summary: HepMC3 library and Python bindings for HepMC3
 Home-page: https://gitlab.cern.ch/hepmc/HepMC3
 Author: HepMC3 Developers
 Author-email: hepmc-dev@cern.ch
 License: GPLv3
 Platform: any
 Classifier: Programming Language :: Python 
 Classifier: Operating System :: OS Independent
 Description-Content-Type: text/markdown
 License-File: LICENCE
 License-File: COPYING
 License-File: AUTHORS
 
 Official python bindings for the HepMC3 library. Please visit https://hepmc.web.cern.ch/hepmc/ and  https://gitlab.cern.ch/hepmc/HepMC3 for more documentation
-
```

### Comparing `HepMC3-3.2.5/HepMC3.egg-info/SOURCES.txt` & `HepMC3-3.2.6/HepMC3.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -168,21 +168,30 @@
 include/HepMC3/bxzstr/bz_stream_wrapper.hpp
 include/HepMC3/bxzstr/compression_types.hpp
 include/HepMC3/bxzstr/config.hpp
 include/HepMC3/bxzstr/lzma_stream_wrapper.hpp
 include/HepMC3/bxzstr/stream_wrapper.hpp
 include/HepMC3/bxzstr/strict_fstream.hpp
 include/HepMC3/bxzstr/z_stream_wrapper.hpp
+include/HepMC3/bxzstr/zstd_stream_wrapper.hpp
 interfaces/HepMCCompatibility/include/HepMCCompatibility.h
 interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.cc
 interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.inc
 interfaces/pythia8/include/Pythia8/Pythia8ToHepMC3.h
+protobufIO/CMakeLists.txt
+protobufIO/HepMC3.proto
+protobufIO/include/HepMC3/Readerprotobuf.h
+protobufIO/include/HepMC3/Writerprotobuf.h
+protobufIO/src/Readerprotobuf.cc
+protobufIO/src/Writerprotobuf.cc
 python/CMakeLists.txt
 python/all_includes.hpp.in
+python/protobuf_includes.hpp.in
 python/pyHepMC3.egg-info.in
+python/pyHepMC3.protobufIO.egg-info.in
 python/pyHepMC3.rootIO.egg-info.in
 python/pyHepMC3.search.egg-info.in
 python/root_includes.hpp.in
 python/search_includes.hpp.in
 python/include/LICENSE
 python/include/pybind11/attr.h
 python/include/pybind11/buffer_info.h
@@ -190,31 +199,36 @@
 python/include/pybind11/chrono.h
 python/include/pybind11/common.h
 python/include/pybind11/complex.h
 python/include/pybind11/eigen.h
 python/include/pybind11/embed.h
 python/include/pybind11/eval.h
 python/include/pybind11/functional.h
+python/include/pybind11/gil.h
 python/include/pybind11/iostream.h
 python/include/pybind11/numpy.h
 python/include/pybind11/operators.h
 python/include/pybind11/options.h
 python/include/pybind11/pybind11.h
 python/include/pybind11/pytypes.h
 python/include/pybind11/stl.h
 python/include/pybind11/stl_bind.h
 python/include/pybind11/detail/class.h
 python/include/pybind11/detail/common.h
 python/include/pybind11/detail/descr.h
 python/include/pybind11/detail/init.h
 python/include/pybind11/detail/internals.h
+python/include/pybind11/detail/type_caster_base.h
 python/include/pybind11/detail/typeid.h
+python/include/pybind11/stl/filesystem.h
 python/src/__init__.py
 python/src/binders.cpp
 python/src/binders.h
+python/src/protobuf_binders.cpp
+python/src/protobuf_binders.h
 python/src/pyHepMC3.binder
 python/src/pyHepMC3.cpp
 python/src/pyHepMC3_0.cpp
 python/src/pyHepMC3_1.cpp
 python/src/pyHepMC3_10.cpp
 python/src/pyHepMC3_11.cpp
 python/src/pyHepMC3_12.cpp
@@ -228,35 +242,41 @@
 python/src/pyHepMC3_3.cpp
 python/src/pyHepMC3_4.cpp
 python/src/pyHepMC3_5.cpp
 python/src/pyHepMC3_6.cpp
 python/src/pyHepMC3_7.cpp
 python/src/pyHepMC3_8.cpp
 python/src/pyHepMC3_9.cpp
+python/src/pyHepMC3protobufIO.binder
+python/src/pyHepMC3protobufIO.cpp
+python/src/pyHepMC3protobufIO_0.cpp
 python/src/pyHepMC3rootIO.binder
 python/src/pyHepMC3rootIO.cpp
 python/src/pyHepMC3rootIO_0.cpp
 python/src/pyHepMC3rootIO_1.cpp
 python/src/pyHepMC3rootIO_2.cpp
 python/src/pyHepMC3search.binder
 python/src/pyHepMC3search.cpp
 python/src/pyHepMC3search_0.cpp
 python/src/pyHepMC3search_1.cpp
 python/src/root_binders.cpp
 python/src/root_binders.h
 python/src/search_binders.cpp
 python/src/search_binders.h
 python/src/stl_binders.hpp
+python/src/protobufIO/__init__.py
 python/src/rootIO/__init__.py
 python/src/search/__init__.py
 python/test/Pythia8ToHepMC3.py
 python/test/inputDelete.hepmc
 python/test/inputDelete2.hepmc
 python/test/inputIO1.hepmc
 python/test/inputIO2.hepmc
+python/test/inputIO20.proto
+python/test/inputIO26.hepmc
 python/test/inputIO3.hepevt
 python/test/inputIO4.root
 python/test/inputIO5.hepmc
 python/test/inputIO6.hepmc
 python/test/inputMass.hepmc
 python/test/inputMultipleCopies1.hepmc
 python/test/inputMultipleCopies2.hepmc
@@ -268,14 +288,15 @@
 python/test/test_Attribute.py
 python/test/test_Boost.py
 python/test/test_HEPEVT.py
 python/test/test_IO1.py
 python/test/test_IO2.py
 python/test/test_Polarization.py
 python/test/test_Print.py
+python/test/test_Protobuf.py
 python/test/test_Pythia8.py
 python/test/test_Pythonization_FourVector.py
 python/test/test_Pythonization_GenEvent.py
 python/test/test_Pythonization_GenRunInfo.py
 python/test/test_Pythonization_Search.py
 python/test/test_Pythonization_docs.py
 python/test/test_Units.py
```

### Comparing `HepMC3-3.2.5/LICENCE` & `HepMC3-3.2.6/LICENCE`

 * *Files 16% similar despite different names*

```diff
@@ -1,34 +1,24 @@
-This software is released under Version 3 of the GNU Public Licence (see ./COPYING) or any later version.
+This software is released under Version 3 of the GNU Lesser General Public Licence (see ./COPYING) or any later version.
 
-Copyright (C) 2014-2021 HepMC3 Authors
+Copyright (C) 2014-2022 HepMC3 Authors
 
 The third party codes are distributed under their own licenses.
 
 # ./include/HepMC3/bxzstr/LICENSE from  https://www.mozilla.org/en-US/MPL/2.0/
 # Copyright: 2020  Matei David Tommi Mklin
 # Type: Mozilla Public License Version 2.0
  ./include/HepMC3/bxzstr/*
 
-
-# http://www.thep.lu.se/~torbjorn/Pythia.html 
-# Copyright: 2010 Torbjorn Sjostrand et al. 
+# http://www.thep.lu.se/~torbjorn/Pythia.html
+# Copyright: 2010 Torbjorn Sjostrand et al.
 ./examples/Pythia6Example/main63.f
 ./examples/Pythia6Example/pythia-6.4.28.f
 
-# ./COPYING  from https://www.gnu.org/licenses/gpl-3.0.html
-# Type: GPLv3+
-# Copyright: 2009, Adrien Bustany, <madcat@mymadcat.com>
-# Copyright: 2013-2014 Kevin Funk <kevin.funk@kdab.com>
-# Copyright: Allen Winter <allen.winter@kdab.com>
-# Copyright: 2012-2014 Klarlvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
-# Copyright: 2014 University of Southern California
-./examples/ViewerExample/cmake/Modules/FindGraphviz.cmake
-
-# ./cmake/Modules/Copyright.txt from  https://cmake.org/licensing 
+# ./cmake/Modules/Copyright.txt from  https://cmake.org/licensing
 # Type: OSI-approved BSD 3-Clause License
 # Copyright: 2000-2021 Kitware, Inc. and Contributors
 ./cmake/Modules/CMakeFindFrameworks.cmake
 ./cmake/Modules/FindPackageMessage.cmake
 ./cmake/Modules/FindPython2.cmake
 ./cmake/Modules/FindPython3.cmake
 ./cmake/Modules/FindPackageHandleStandardArgs.c
@@ -37,12 +27,11 @@
 ./cmake/Modules/CMakeMacroParseArguments.cmake
 
 # ./python/include/LICENSE from https://github.com/pybind/pybind11
 # Type: BSD 3-Clause like
 # Copyright: 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>, All rights reserved.
 ./python/include/pybind11/*
 
-# ./COPYING  from https://www.gnu.org/licenses/gpl-3.0.html
 # Type: GPLv3+
-# Copyright: 2014-2021 The HepMC collaboration (see AUTHORS for details)
+# Copyright: 2014-2022 The HepMC collaboration (see AUTHORS for details)
 # Part of code was adopted from Pythia8-HepMC interface by Mikhail Kirsanov.
 ./interfaces/pythia8/include/Pythia8/Pythia8ToHepMC3.h
```

### Comparing `HepMC3-3.2.5/MANIFEST.in` & `HepMC3-3.2.6/MANIFEST.in`

 * *Files 3% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 recursive-include doc *
 recursive-include examples *
 recursive-include include  *
 recursive-include interfaces  *
 recursive-include python  *
 recursive-include search  *
 recursive-include rootIO  *
+recursive-include protobufIO  *
 include CMakeLists.txt
 include README-for-developers
 include README.md
 include COPYING
 include HepMC3-config.in
 include *.cmake
 prune CMakeFiles
```

### Comparing `HepMC3-3.2.5/PKG-INFO` & `HepMC3-3.2.6/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,17 @@
 Metadata-Version: 2.1
 Name: HepMC3
-Version: 3.2.5
+Version: 3.2.6
 Summary: HepMC3 library and Python bindings for HepMC3
 Home-page: https://gitlab.cern.ch/hepmc/HepMC3
 Author: HepMC3 Developers
 Author-email: hepmc-dev@cern.ch
 License: GPLv3
 Platform: any
 Classifier: Programming Language :: Python 
 Classifier: Operating System :: OS Independent
 Description-Content-Type: text/markdown
 License-File: LICENCE
 License-File: COPYING
 License-File: AUTHORS
 
 Official python bindings for the HepMC3 library. Please visit https://hepmc.web.cern.ch/hepmc/ and  https://gitlab.cern.ch/hepmc/HepMC3 for more documentation
-
```

### Comparing `HepMC3-3.2.5/README.md` & `HepMC3-3.2.6/README.md`

 * *Files 19% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 # Introduction
 
 HepMC3 is a new version of the HepMC event record. It uses shared pointers for in-memory navigation and the POD concept for persistency.
 Visit the home page of the project http://hepmc.web.cern.ch/hepmc/ or the CERN GitLab repository https://gitlab.cern.ch/hepmc/HepMC3 for more information.
-You can also send bug reports, feature requests and questions about HepMC3 to hepmc-devATcern.ch
+A short information on the compatibility between the HePMC3 versions and deprecation of some functionality see below.
+You can also send bug reports, feature requests and questions about HepMC3 to hepmc-devATcern.ch.
+
 
 
 # Quick-start (applicable to recent versions):
 
 0. On the Linux platform HepMC3 is available from the standard repositories of multiple many
 linux distributions:  Fedora, CentOS(EPEL),  Arch Linux, Mageia, openSUSE Tumbleweed, Debian (outdated) etc.
 It is recommended to use the system package manager to install HepMC3 for these systems.
@@ -48,22 +50,28 @@
   - Arch linux
     The package is available from https://www.archlinux.org/packages/community/x86_64/hepmc/. To install:
     ```
     sudo pacman -Syu hepmc
     ```
     The dependencies can vary.
 
+  - Gentoo linux
+    The package is available in the standard repository https://packages.gentoo.org/packages/sci-physics/hepmc. To install:
+    ```
+    sudo emerge --ask hepmc:3
+    ```
+
   - MacOSX
     The HepMC3 package is available in the ``homebrew-hep`` repository https://davidchall.github.io/homebrew-hep/.
     To install:
     ```
     brew tap davidchall/hep
     brew install hepmc3
     ```
-    The package does not include ROOT interface.
+    The package optionally includes ROOT interface.
 
    - Windows
     The precompilled HepMC3 packages are available in for Windows and other platforms also in PyPi.
     The Windows users can use ``pip`` to install HepMC3.
     ```
     pip install HepMC3
     ```
@@ -83,40 +91,45 @@
 
 It is strongly recommended to read this documentation completely before the installation.
 However, if for some reason that is not possible, here is a  set of commands for the
 instalation that can be copied and pasted into a Unix terminal. In some cases this
 action might result in a fully functional installation.
 
 ```
-  wget http://hepmc.web.cern.ch/hepmc/releases/HepMC3-3.2.2.tar.gz
-  tar -xzf HepMC3-3.2.2.tar.gz
+  wget http://hepmc.web.cern.ch/hepmc/releases/HepMC3-3.2.6.tar.gz
+  tar -xzf HepMC3-3.2.6.tar.gz
   mkdir hepmc3-build
   cd hepmc3-build
-  cmake -DHEPMC3_ENABLE_ROOTIO:BOOL=OFF -DHEPMC3_ENABLE_TEST:BOOL=OFF  \
-      -DHEPMC3_INSTALL_INTERFACES:BOOL=ON -DHEPMC3_ENABLE_PYTHON:BOOL=ON -DHEPMC3_PYTHON_VERSIONS=2.7  \
-      -DHEPMC3_BUILD_STATIC_LIBS:BOOL=OFF -DHEPMC3_BUILD_DOCS:BOOL=OFF  \
-      -DCMAKE_INSTALL_PREFIX=../hepmc3-install   \
-      -DHEPMC3_Python_SITEARCH27=../hepmc3-install/lib/python2.7/site-packages \
-      ../HepMC3-3.2.2
+  cmake -DCMAKE_INSTALL_PREFIX=../hepmc3-install   \
+        -DHEPMC3_ENABLE_ROOTIO:BOOL=OFF            \
+        -DHEPMC3_ENABLE_PROTOBUFIO:BOOL=OFF        \
+        -DHEPMC3_ENABLE_TEST:BOOL=OFF              \
+        -DHEPMC3_INSTALL_INTERFACES:BOOL=ON        \
+        -DHEPMC3_BUILD_STATIC_LIBS:BOOL=OFF        \
+        -DHEPMC3_BUILD_DOCS:BOOL=OFF     \
+        -DHEPMC3_ENABLE_PYTHON:BOOL=ON   \
+        -DHEPMC3_PYTHON_VERSIONS=2.7     \
+        -DHEPMC3_Python_SITEARCH27=../hepmc3-install/lib/python2.7/site-packages \
+        ../HepMC3-3.2.6
   make
   make install
 ```
 The full explanation  for the installation options is given below.
 
 
 1. The first step of the installation is to
   a)Checkout the HepMC from GIT repository:
 
   ```
   git clone https://gitlab.cern.ch/hepmc/HepMC3.git
   ```
   or b) download the tarball with wget or any other tool
   ```
-  wget http://hepmc.web.cern.ch/hepmc/releases/HepMC3-3.2.2.tar.gz
-  tar -xzf HepMC3-3.2.2.tar.gz
+  wget http://hepmc.web.cern.ch/hepmc/releases/HepMC3-3.2.6.tar.gz
+  tar -xzf HepMC3-3.2.6.tar.gz
   ```
 
 
 2. Create a workspace area on which to perform the builds
   ```
   mkdir hepmc3-build
   cd hepmc3-build
@@ -126,15 +139,15 @@
 3. Configure the HepMC3 features to build and install:
   a)
   ```
   cmake -DHEPMC3_ENABLE_ROOTIO=OFF -DCMAKE_INSTALL_PREFIX=../hepmc3-install ../HepMC3
   ```
   or b)
   ```
-  cmake -DHEPMC3_ENABLE_ROOTIO=OFF -DCMAKE_INSTALL_PREFIX=../hepmc3-install ../HepMC3-3.2.2
+  cmake -DHEPMC3_ENABLE_ROOTIO=OFF -DCMAKE_INSTALL_PREFIX=../hepmc3-install ../HepMC3-3.2.6
   ```
 
   To disable compilation of the search engine (enabled by default) add
   ```
   -DHEPMC3_ENABLE_SEARCH=OFF
   ```
   Please note, in case of using the search engine, the easiest way to link against
@@ -162,20 +175,16 @@
   ```
   -DHEPMC3_BUILD_EXAMPLES=ON
   ```
 
   Additional flags control the location installation of Photos, Tauola MC-TESTER, HepMC2
   and Pythia8  that are used for tests. Please note that some examples are disabled  on Windows.
 
-  For tests and for development purposes  HepMC3 uses extra packages, e.g. ZLIB, GrpahViz, binder.
-  On Windows, most extra packages (e.g. ZLIB) have no default location, therefore
-  one should specify their location manually, e.g.
-```
-cmake CMakeLists.txt -DZLIB_ROOT=C:\lib -DZLIB_INCLUDE_DIR=C:\include
-```
+  For tests and for development purposes  HepMC3 uses extra packages, e.g. GrpahViz, binder.
+  On Windows, most extra packages have no default location.
 
 
 6. In order to build and run tests put
   ```
   -DHEPMC3_ENABLE_TEST=ON
   ```
   and run
@@ -276,15 +285,15 @@
 In addition to the standard CPython  modules, it is possible to build HepMC3 modules for PyPy.
 However, the PyPy support is experimental. To build the bindings against the `pypy-c` library use `pypy<version>`
 for the `HEPMC3_PYTHON_VERSIONS` option, e.g.
 ```
 -DHEPMC3_PYTHON_VERSIONS=pypy2
 ```
 
-11
+11.
 
 HepMC3 is shipped with interfaces to some MC event generators/codes located in the interfaces/ directory.
 This is done to allow the usage of HepMC3 with codes that so far don't have HepMC3 interfaces.
 In the future the codes from the interfaces  will be submitted to the
 upstream of corresponding projects and removed from HepMC3.
 
 To enable the installation of interfaces use `-DHEPMC3_INSTALL_INTERFACES:BOOL=ON`  option for the cmake.
@@ -293,14 +302,102 @@
 ```
 -DHEPMC3_USE_INTERFACE_FROM_MCTESTER:BOOL=OFF
 -DHEPMC3_USE_INTERFACE_FROM_PHOTOSPP:BOOL=OFF
 -DHEPMC3_USE_INTERFACE_FROM_TAUOLAPP:BOOL=OFF
 -DHEPMC3_USE_INTERFACE_FROM_PYTHIA8:BOOL=OFF
 ```
 
+12.
+
+ In order to build with PROTOBUFIO put the following flags
+```
+-DHEPMC3_ENABLE_PROTOBUF=ON
+```
+Adjustment of LD_LIBRARY_PATH might be needed.
+
+## Using a binary distribution of HepMC3 in your CMake project
+
+To include an existing build of HepMC3 in your project, you can use find_package as below:
+
+```
+find_package(HepMC3 3.2.0 REQUIRED)
+```
+
+This will set up a number of CMake variables targets depending on the features that were built with the found version of HepMC3. Some useful CMake variables that will be set are included below:
+
+```
+HEPMC3_VERSION
+HEPMC3_VERSION_MAJOR
+HEPMC3_VERSION_MINOR
+HEPMC3_VERSION_PATCH
+HEPMC3_FEATURES
+HEPMC3_INCLUDE_DIR
+HEPMC3_LIB
+HEPMC3_SEARCH_LIB
+HEPMC3_ROOTIO_LIB
+HEPMC3_PROTOBUFIO_LIB
+```
+
+Generally in modern CMake projects you should use exported targets to model dependencies, rather than setting your own compiler and linker options using the values of variables like the above. Modern HepMC3 exports a number of targets, reproduced below:
+
+```
+HepMC3::All
+HepMC3::HepMC3
+HepMC3::search #if -DHEPMC3_ENABLE_SEARCH=ON
+HepMC3::rootIO #if -DHEPMC3_ENABLE_ROOTIO=ON
+HepMC3::protobufIO #if -DHEPMC3_ENABLE_PROTOBUF=ON
+
+HepMC3::All_static #if -DHEPMC3_BUILD_STATIC_LIBS=ON
+HepMC3::HepMC3_static #if -DHEPMC3_BUILD_STATIC_LIBS=ON
+HepMC3::search_static #if -DHEPMC3_BUILD_STATIC_LIBS=ON
+HepMC3::protobufIO_static #if -DHEPMC3_BUILD_STATIC_LIBS=ON
+```
+
+To link a target, `MyLibrary`, from your project to the main HepMC3 library you would include a CMake command like:
+
+```
+target_link_libraries(MyLibrary PUBLIC HepMC3::All)
+```
+
+_N.B._ That these exported targets container their own dependencies, the above _should_ be all that is needed to correctly set up the relevant compiler options, include directories, and link options on `MyLibrary`. This includes, for example, if you need to write out using the rootIO module, `HepMC3::All` links to `HepMC::rootIO`, which depends on a number of ROOT libraries and the ROOT include directory.
+
+### A ROOT Gotcha
+
+The way that the dependency on ROOT is currently included, means that paths to the ROOT include directory and ROOT libraries are hard-coded in the exported targets. This means that if your version of HepMC3 was built against one install of ROOT and other parts of your project pick up a different install of ROOT, you could have conflicts.
+
+## Adding a dependency to HepMC3 with CPM.cmake
+
+[CPM.cmake](https://github.com/cpm-cmake/CPM.cmake) wraps modern CMake builtins to provide an intuitive interface for specifying dependencies within a CMake project that can be fetched and built automatically if they are not found. To include HepMC3 in your CMake project via CPM.cmake include something like:
+
+```
+CPMAddPackage(
+    NAME HepMC3
+    VERSION 3.2.6
+    GIT_REPOSITORY "https://gitlab.cern.ch/hepmc/HepMC3.git"
+    GIT_TAG 3.2.6
+    OPTIONS
+      "HEPMC3_CXX_STANDARD ${CMAKE_CXX_STANDARD}"
+      "HEPMC3_ENABLE_SEARCH OFF"
+      "HEPMC3_ENABLE_ROOTIO OFF"
+      "HEPMC3_ENABLE_PROTOBUFIO OFF"
+      "HEPMC3_ENABLE_PYTHON OFF"
+      "HEPMC3_BUILD_DOCS OFF"
+      "HEPMC3_BUILD_EXAMPLES OFF"
+      "HEPMC3_INSTALL_EXAMPLES OFF"
+      "HEPMC3_ENABLE_TEST OFF"
+      "HEPMC3_INSTALL_INTERFACES OFF"
+      "HEPMC3_BUILD_STATIC_LIBS OFF"
+)
+```
+
+To use this version of HepMC3 in your CMake project, follow the [instructions above](#using-a-binary-distribution-of-hepmc3-in-your-cmake-project).
+
+During the configuration step of your project, the HepMC3 source of the specified version will be fetched and its CMake project run and targets set up and exposed to your project such that the dependent build and installation is automatically run as required by your project targets.
+
+You can optionally try and find an existing HepMC3 installation, rather than build a dependent one, by using `CPMFindPackage` instead of `CPMAddPackage`.
 
 # Installation troubleshooting
 
 The possible problems during the HepMC3 installation can be caused by
 
  - The used C++ compiler that does not support C++11.
    The only solution is to use compiler with C++11 support
@@ -315,21 +412,45 @@
 or after the installation (for HepMC3>3.1.0).
 To compile the examples after the installation  copy the installed directory with examples to desired directory
 and run CMake, e.g.
 
 ```
 mkdir -p myexamples
 cd myexamples
-cp -r /usr/share/doc/HepMC3-3.2.2/examples ./
+cp -r /usr/share/doc/HepMC3-3.2.6/examples ./
 cd examples
 cmake -DUSE_INSTALLED_HEPMC3=ON CMakeLists.txt
 make
 ```
 Please note that in case the HepMC3 installation is not system-wide,
-CMake will require an additional flag  `-DHepMC3_DIR=/where/you/have/it` to point to the HepMC3 installation directory.
+CMake will require an additional flag  `-DHepMC3_DIR=/directory/where/you/have/HepMC3Config.cmake/file` to point to
+the directory containing the installed `HepMC3Config.cmake` file.
+The examples use multiple parts of HepMC3, therefore to use all of them a full installation of HepMC3
+(i.e. including ROOT MC event generator interfaces is needed).
+
+# Compatibility and deprecation notes
+  - The `IO_GenEvent` (HepMC2) and HEPEVT  ASCII files produced by all HepMC3 versions should be readable by all HepMC3
+    versions and latest versions of HepMC2.
+  - The `Asciiv3` (HepMC3) ASCII files produced by all HepMC3>=3.0.0 versions should be readable by all HepMC3>3.0.0 versions.
+  - The ROOT files produced by all HepMC3>=3.0.0 versions should be readable by all HepMC3>3.0.0 versions.
+  - The ROOT files produced by all HepMC3>=3.1.0 versions will not be readable by HepMC3<3.1.0 versions.
+
+  - The HepMC3 versions with the same SOVERSION of library are ABI backwards compatible. I.e. the code compiled with HepMC3=3.2.x
+    will work with HepMC3=3.2.(x+1) if libHepMC3=3.2.(x+1) will have the same SOVERSION as libHepMC3=3.2.x.
+    Please note that `libHepMC3`, `libHepMC3search` and other libraries have different SOVERSION.
+  - The minor versions of HepMC3 are API backward compatible.
+  - The major versions of HepMC3 are almost API backward compatible.
+
+  - For HepMC3>3.2.6 the member functions in `GenEvent/GenVertex` that deal with raw pointers, e.g. `add_particle_in ( GenParticle *p )` will be removed.
+  - The Python2 is not in development anymore, therefore at some point the Python2 support will be removed.
+    As of version HepMC3=3.2.6 it is present `as is`.
+  - The class HepMC3::RelativesInterface are deprecated will be removed in the future.
+    Use HepMC3::children_particles, HepMC3::descendant_particles, etc. instead.
+  - The minimal required version of `cmake` slowly changes from version to version. It is recommented to use the `cmake`
+     released not earlier than 3-4 years ago.
 
 
 # Source package structure
 
 The package sources are organized as follows:
 
 0. The topmost directory contains the
@@ -372,22 +493,24 @@
 ```
 
 and automatically generated binding sources
 
 ```
 python/src/pyHepMC3*.cpp
 python/src/pyHepMC3rootIO*.cpp
+python/src/pyHepMC3protobufIO*.cpp
 python/src/pyHepMC3search*.cpp
 ```
 
 The automatically sources were generated using the binder configurations
 
 ```
 python/src/pyHepMC3.binder
 python/src/pyHepMC3rootIO.binder
+python/src/pyHepMC3protobufIO.binder
 python/src/pyHepMC3search.binder
 ```
 
 and the header files generated from the templates
 
 ```
 python/all_includes.hpp.in
@@ -396,16 +519,18 @@
 ```
 
 The directory contain the files that are used to build a Python package and installation:
 ```
 python/src/__init__.py
 python/src/search/__init__.py
 python/src/rootIO/__init__.py
+python/src/protobufIO/__init__.py
 pyHepMC3.egg-info.in
 pyHepMC3.rootIO.egg-info.in
+pyHepMC3.protobufIO.egg-info.in
 pyHepMC3.search.egg-info.in
 ```
 
 The `python/CMakeLists.txt` file is used by CMake
 to build the binding.
 
 
@@ -446,14 +571,15 @@
 ./test/PhotosValidationTool.cc
 ./test/testMCTester1.cc
 ./test/testPhotos1.cc
 ./test/testPythia3.cc
 ./test/testPythia2.cc
 ./test/testPythia1.cc
 ./test/testTauola1.cc
+...
 ```
 
 
 7. The subdirectory `cmake/Modules` contains files needed for the CMake configuration
 The subdirectory `cmake/Templates` contains templates needed for generation
 of the library CMake configuration files.
 
@@ -483,22 +609,14 @@
 ./examples/ConvertExample/src/WriterRootTreeOPAL.cc
 ./examples/ConvertExample/include/WriterRootTreeOPAL.h
 ```
 contain an implementation of output format that can be used together with data from the OPAL experiment.
 
 The files
 ```
-./examples/ConvertExample/include/ReaderGZ.h
-./examples/ConvertExample/src/gzstream.C
-./examples/ConvertExample/include/gzstream.h
-```
-implement an example of compressed input handling.
-
-The files
-```
 ./examples/ConvertExample/src/AnalysisExample.cc
 ./examples/ConvertExample/include/AnalysisExample.h
 ```
 illustrate an implementation of simple physics analysis using the HepMC3 library.
 
 The files
 ```
```

### Comparing `HepMC3-3.2.5/cmake/Modules/CMakeFindFrameworks.cmake` & `HepMC3-3.2.6/cmake/Modules/CMakeFindFrameworks.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/CMakeMacroParseArguments.cmake` & `HepMC3-3.2.6/cmake/Modules/CMakeMacroParseArguments.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/Copyright.txt` & `HepMC3-3.2.6/cmake/Modules/Copyright.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindHepMC2.cmake` & `HepMC3-3.2.6/cmake/Modules/FindHepMC2.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindMCTester.cmake` & `HepMC3-3.2.6/cmake/Modules/FindMCTester.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPackageHandleStandardArgs.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPackageHandleStandardArgs.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPackageMessage.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPackageMessage.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPhotospp.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPhotospp.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPyPy.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPyPy.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPythia8.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPythia8.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPython/Support.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPython/Support.cmake`

 * *Files 0% similar despite different names*

```diff
@@ -39,15 +39,15 @@
 if (NOT DEFINED _PYTHON_PREFIX)
   message (FATAL_ERROR "FindPython: INTERNAL ERROR")
 endif()
 if (NOT DEFINED _${_PYTHON_PREFIX}_REQUIRED_VERSION_MAJOR)
   message (FATAL_ERROR "FindPython: INTERNAL ERROR")
 endif()
 if (_${_PYTHON_PREFIX}_REQUIRED_VERSION_MAJOR EQUAL "3")
-  set(_${_PYTHON_PREFIX}_VERSIONS 3.12 3.11 3.10 3.9 3.8 3.7 3.6 3.5 3.4 3.3 3.2 3.1 3.0)
+  set(_${_PYTHON_PREFIX}_VERSIONS 3.14 3.13 3.12 3.11 3.10 3.9 3.8 3.7 3.6 3.5 3.4 3.3 3.2 3.1 3.0)
 elseif (_${_PYTHON_PREFIX}_REQUIRED_VERSION_MAJOR EQUAL "2")
   set(_${_PYTHON_PREFIX}_VERSIONS 2.7 2.6 2.5 2.4 2.3 2.2 2.1 2.0)
 else()
   message (FATAL_ERROR "FindPython: INTERNAL ERROR")
 endif()
 
 get_property(_${_PYTHON_PREFIX}_CMAKE_ROLE GLOBAL PROPERTY CMAKE_ROLE)
```

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPython2.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPython2.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindPython3.cmake` & `HepMC3-3.2.6/cmake/Modules/FindPython3.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/FindTauolapp.cmake` & `HepMC3-3.2.6/cmake/Modules/FindTauolapp.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Modules/SelectLibraryConfigurations.cmake` & `HepMC3-3.2.6/cmake/Modules/SelectLibraryConfigurations.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/cmake/Templates/cmake_uninstall.cmake.in` & `HepMC3-3.2.6/cmake/Templates/cmake_uninstall.cmake.in`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/CMakeLists.txt` & `HepMC3-3.2.6/doc/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/Doxyfile.in` & `HepMC3-3.2.6/doc/doxygen/Doxyfile.in`

 * *Files 1% similar despite different names*

```diff
@@ -611,15 +611,15 @@
 #---------------------------------------------------------------------------
 # configuration options related to warning and progress messages
 #---------------------------------------------------------------------------
 
 # The QUIET tag can be used to turn on/off the messages that are generated
 # by doxygen. Possible values are YES and NO. If left blank NO is used.
 
-QUIET                  = NO
+QUIET                  = YES
 
 # The WARNINGS tag can be used to turn on/off the warning messages that are
 # generated by doxygen. Possible values are YES and NO. If left blank
 # NO is used.
 
 WARNINGS               = YES
 
@@ -705,43 +705,43 @@
 
 # The EXCLUDE tag can be used to specify files and/or directories that should be
 # excluded from the INPUT source files. This way you can easily exclude a
 # subdirectory from a directory tree whose root is specified with the INPUT tag.
 # Note that relative paths are relative to the directory from which doxygen is
 # run.
 
-EXCLUDE                = ../../outputs ../../validation ../../interfaces ../../_CPack_Packages ../../python
+EXCLUDE                =  @PROJECT_BINARY_DIR@  @PROJECT_SOURCE_DIR@/test  @PROJECT_SOURCE_DIR@/python  @PROJECT_SOURCE_DIR@/protobufIO/HepMC3.pb.h @PROJECT_SOURCE_DIR@/protobufIO/HepMC3.pb.cc
 
 # The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
 # directories that are symbolic links (a Unix file system feature) are excluded
 # from the input.
 
 EXCLUDE_SYMLINKS       = NO
 
 # If the value of the INPUT tag contains directories, you can use the
 # EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
 # certain files from those directories. Note that the wildcards are matched
 # against the file with absolute path, so to exclude all test directories
 # for example use the pattern */test/*
 
-EXCLUDE_PATTERNS       = *cmdline.h* *gzstream* *_fwd.h  */pybind11/*
+EXCLUDE_PATTERNS       = *Pythia8ToHepMC3* *cmdline.h* *gzstream* *_fwd.h  */pybind11/* *HepMC3.pb.h* *HepMC3.pb.cc* *CMakeFiles*  *BUILD* *CMakeCache* *-cache-*
 
 # The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
 # (namespaces, classes, functions, etc.) that should be excluded from the
 # output. The symbol name can be a fully qualified name, a word, or if the
 # wildcard * is used, a substring. Examples: ANamespace, AClass,
 # AClass::ANamespace, ANamespace::*Test
 
 EXCLUDE_SYMBOLS        =
 
 # The EXAMPLE_PATH tag can be used to specify one or more files or
 # directories that contain example code fragments that are included (see
 # the \include command).
 
-EXAMPLE_PATH           = @CMAKE_CURRENT_SOURCE_DIR@/../examples
+EXAMPLE_PATH           = @PROJECT_SOURCE_DIR@/examples
 
 # If the value of the EXAMPLE_PATH tag contains directories, you can use the
 # EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
 # and *.h) to filter out the source-files in the directories. If left
 # blank all files are included.
 
 EXAMPLE_PATTERNS       =
```

### Comparing `HepMC3-3.2.5/doc/doxygen/DoxygenLayout.xml` & `HepMC3-3.2.6/doc/doxygen/DoxygenLayout.xml`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/LHEF.txt` & `HepMC3-3.2.6/doc/doxygen/LHEF.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/Python.txt` & `HepMC3-3.2.6/doc/doxygen/Python.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/ReaderFactory.txt` & `HepMC3-3.2.6/doc/doxygen/ReaderFactory.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/building.txt` & `HepMC3-3.2.6/doc/doxygen/building.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/class_diagram.png` & `HepMC3-3.2.6/doc/doxygen/class_diagram.png`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/class_diagram_3.0.png` & `HepMC3-3.2.6/doc/doxygen/class_diagram_3.0.png`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/doc/doxygen/differences.txt` & `HepMC3-3.2.6/doc/doxygen/differences.txt`

 * *Files 2% similar despite different names*

```diff
@@ -97,19 +97,19 @@
 
     Implementation of custom Reader and Writer objects is possible as well.
 
     Please, note the difference in the behavior of default Readers with respect to HepMC2.
     when reading files with multiple headers. The ASCII files with multiple headers ( e.g. obtained with
     cat 1.hepmc 2.hepmc > 12.hepmc) will be processed by the readers only till the
     first occurrence of END_EVENT_LISTING.
-    
+
     In addition to the standard readers, starting for the version 3.2.5 HepMC3 provides as set of
     templated readers/writers to handle the zip-,lzma-,bz2-compressed files (ReaderGZ and WriterGZ) and to perform multithread
-    reading (ReaderMT). 
-    
+    reading (ReaderMT).
+
     ###########################################################################
     @subsection memory Memory managed by shared pointers
     ###########################################################################
     Particles and vertices are managed using shared pointers,
     so they should not be created through the call to 'new'.
 
     @code{.cpp}
@@ -156,15 +156,15 @@
     @code{.cpp}
     for (GenEvent::particle_const_iterator p = evt->particles_begin(); p != evt->particles_end(); ++p ) {
     ...
     }
     @endcode
     one should use
     @code{.cpp}
-    for (auto p: evt->particles()) {
+    for (const auto& p: evt->particles()) {
     ...
     }
     @endcode
     or alternatively
     @code{.cpp}
     for (size_t i=0;i<evt->particles().size();++i) {
     ...
@@ -397,14 +397,28 @@
         HepMC::GenParticle::set_flow(int code_index, int code = 0)
         HepMC::GenParticle::set_polarization( Polarization(theta,phi))
         // Replace with:
         HepMC3::GenParticle::add_attribute("flow"+to_string(code_index),make_shared<IntAttribute>(code));
         HepMC3::GenParticle::add_attribute("theta",make_shared<DoubleAttribute>(theta));
         HepMC3::GenParticle::add_attribute("phi",make_shared<DoubleAttribute>(phi));
     @endcode
+
+    @code{.cpp}
+        // HepMC2 code:
+        GenCrossSection* XS;
+        double xs, xs_err;
+        XS->set_cross_section(xs,xs_err)
+        // Replace with:
+        GenCrossSectionPtr XS;
+        ....
+        std::vector<double> xs, xs_err;
+        ....
+        XS->set_cross_section(xs,xs_err)
+    @endcode
+
     ###########################################################################
     @subsection attributes Standard attributes
     ###########################################################################
 
     For the user convenience and backward compatibility the following standard attributes are
     supported for the
 
@@ -438,34 +452,31 @@
 
      Note that attributes belong to the event, therefore these can be set only for particles and vertices
      that belong to a GenEvent object.
 
     ###########################################################################
     @subsection hepevt Interface to HEPEVT block
     ###########################################################################
-    The most recent versions of HepMC3 has multiple implementations of the interfaces to HEPEVT Fortran common 
-    block. These are 
+    The most recent versions of HepMC3 has multiple implementations of the interfaces to HEPEVT Fortran common
+    block. These are
 
-    include/HepMC3/HEPEVT_Wrapper.h -- the default implementation. The size of common block is defined in 
-    compile time via appropriate #define. The block can hold float/double precision momenta. 
+    include/HepMC3/HEPEVT_Wrapper.h -- the default implementation. The size of common block is defined in
+    compile time via appropriate #define. The block can hold float/double precision momenta.
     This implementation is not compiled into any library. All functions and variables are static,
     so only one instance of the interface can exists.
 
-    include/HepMC3/HEPEVT_Wrapper_Runtime.h -- The size of common block is defined in runtime. 
+    include/HepMC3/HEPEVT_Wrapper_Runtime.h -- The size of common block is defined in runtime.
     The block can be held in the object. Multiple instances can exists.
     The interface is compiled into the library. This interface is also available in Python.
 
-    include/HepMC3/HEPEVT_Wrapper_Runtime_Static.h -- The size of common block is defined in runtime. 
+    include/HepMC3/HEPEVT_Wrapper_Runtime_Static.h -- The size of common block is defined in runtime.
     All functions and variables are static,
     so only one instance of the interface can exists. The interface is compiled into the library.
 
-    include/HepMC3/HEPEVT_Wrapper_Template.h --  The size of common block is defined in compile 
-    time as a parameter of template. The block can hold float/double precision momenta. 
+    include/HepMC3/HEPEVT_Wrapper_Template.h --  The size of common block is defined in compile
+    time as a parameter of template. The block can hold float/double precision momenta.
     The block can be held in the object. Multiple instances can exists.
 
-    @endcode
-    
-        
     <hr>
 
  Last update 28 Dec 2021
 */
```

### Comparing `HepMC3-3.2.5/doc/doxygen/features.txt` & `HepMC3-3.2.6/doc/doxygen/features.txt`

 * *Files 2% similar despite different names*

```diff
@@ -66,34 +66,34 @@
         }
     @endcode
 
 
 
 
     ###########################################################################
-    @subsection links Links
+    @subsection links_mem Links
     ###########################################################################
 
     The relations between vertices and particles in GenEventData are encoded via
-     members links1 and links2, wich are std::vector<int> containing object ids.
+    members links1 and links2, wich are std::vector<int> containing object ids.
     Direct manipulations with links1 and links2 can be useful. For instance,
     when the events are saved in ROOT format, one can extract the information
     from links1 and links2 without reading whole event.
     In case links1[i] is particle, links2[i] is end vertex. In case links1[i] is
     vertex, links2[i] is outgoing particle. An example of usage is given below.
     @code{.cpp}
         // Andrii Verbytskyi, 2017, MPI fuer Physik
         // Here is a code to look for a scattered DIS electron  in HepMC3 event record using links.
-        // The implementation is extended to provide example of links1,lins2 usage.
+        // The implementation is extended to provide example of links1, links2 usage.
         // Dummy code.
         GenEventData*  A=...
         ...
         int i;
         int j;
-        int current_l=0;                             // If the  incoming electron is the first particle in the list
+        int current_l=0;                             // If the incoming electron is the first particle in the list
         int vertex_l=0;                              // We set final vertex to some nonsense value.
         bool found_next_vertex=true;
         while(found_next_vertex)                     // Looking for the electron end vertex
         {
             found_next_vertex=false;
             for (i=0; i<A->links1.size(); i++)       // Points from to ...
                 if (A->links1[i]>0 &&                // The link1 should be particle, i.e. >0
```

#### html2text {}

```diff
@@ -34,28 +34,28 @@
 @subsection newiterators Iterators
 ###########################################################################
 GenEvent and GenVertex containers are now of std::vector type. This greatly
 simplifies iteration over them e.g. (c++11): @code{.cpp} for
 ( ConstGenParticlePtr p : event.particles() ) { { ... } for
 ( ConstGenParticlePtr p : vertex.particles_in() ) { { ... } @endcode
 ###########################################################################
-@subsection links Links
+@subsection links_mem Links
 ########################################################################### The
 relations between vertices and particles in GenEventData are encoded via
 members links1 and links2, wich are std::vector containing object ids. Direct
 manipulations with links1 and links2 can be useful. For instance, when the
 events are saved in ROOT format, one can extract the information from links1
 and links2 without reading whole event. In case links1[i] is particle, links2
 [i] is end vertex. In case links1[i] is vertex, links2[i] is outgoing particle.
 An example of usage is given below. @code{.cpp} // Andrii Verbytskyi, 2017, MPI
 fuer Physik // Here is a code to look for a scattered DIS electron in HepMC3
 event record using links. // The implementation is extended to provide example
-of links1,lins2 usage. // Dummy code. GenEventData* A=... ... int i; int j; int
-current_l=0; // If the incoming electron is the first particle in the list int
-vertex_l=0; // We set final vertex to some nonsense value. bool
+of links1, links2 usage. // Dummy code. GenEventData* A=... ... int i; int j;
+int current_l=0; // If the incoming electron is the first particle in the list
+int vertex_l=0; // We set final vertex to some nonsense value. bool
 found_next_vertex=true; while(found_next_vertex) // Looking for the electron
 end vertex { found_next_vertex=false; for (i=0; ilinks1.size(); i++) // Points
 from to ... if (A->links1[i]>0 && // The link1 should be particle, i.e. >0 A-
 >links1[i]==current_l+1) // The link1 should be our electron { vertex_l=A-
 >links2[i]; // The end vertex of this electron is found found_next_vertex=true;
 } std::vector out; // Here we will save the outgoing particles if
 (found_next_vertex) { for (j=0; jlinks1.size(); j++) // Points from to ... if
```

### Comparing `HepMC3-3.2.5/doc/doxygen/mainpage.txt` & `HepMC3-3.2.6/doc/doxygen/mainpage.txt`

 * *Files 20% similar despite different names*

```diff
@@ -10,14 +10,21 @@
 
     The original code was written by <a href="https://doi.org/10.1016/S0010-4655(00)00189-2">M. Dobbs and J.B. Hansen,
     The HepMC C++ Monte Carlo event record for High Energy Physics (Comput. Phys. Commun. 134 (2001) 41).</a>
     Since the first implementation, the package has undergone several modifications and in particular,
     the latest HepMC3 series is a completely new re-write using currently available C++11 techniques,
     and have out-of-the-box interfaces for the widely used in HEP community ROOT and Python.
 
+    Further documentation that might be useful for the users of HepMC3 can be found in the following documents:
+
+     - <a href="https://arxiv.org/pdf/2203.08230.pdf">E.Bothmann et al., A standard convention for particle-level Monte Carlo event-variation weights</a>
+    <a href="https://inspirehep.net/literature/2053416"> InSpire record</a>
+
+     - <a href="https://doi.org/10.1016/j.cpc.2006.11.010">J. Alwall et al., A standard format for Les Houches Event Files</a>
+    <a href="https://inspirehep.net/literature/725284"> InSpire record</a>
 
     @section releases Status of releases
     The current development effort is concentrated on the HepMC3 series. Users
     are encouraged to integrate that version in their applications and to provide
     any feedback they may have. Visit the CERN GitLab repository https://gitlab.cern.ch/hepmc/HepMC3 for more information.
 
 
@@ -31,31 +38,22 @@
 
     @section tarfiles Available tarfiles
 
     Development version (updated daily at 3AM): <a href="releases/hepmc3-dev.tgz">hepmc3-dev.tgz</a>
 
     @subsection hepmc3_releases HepMC3 releases
     <a href="https://gitlab.cern.ch/hepmc/HepMC3/blob/master/ChangeLog">ChangeLog</a>
-      - <a href="releases/HepMC3-3.2.5.tar.gz">HepMC-3.2.5.tar.gz</a> HepMC3-3.2.5 <b> XX.Jan.2022</b>
+      - <a href="releases/HepMC3-3.2.6.tar.gz">HepMC-3.2.6.tar.gz</a> HepMC3-3.2.6 <b> Mar.2023</b>
+      - <a href="releases/HepMC3-3.2.5.tar.gz">HepMC-3.2.5.tar.gz</a> HepMC3-3.2.5 <b> 22.Feb.2022</b>
       - <a href="releases/HepMC3-3.2.4.tar.gz">HepMC-3.2.4.tar.gz</a> HepMC3-3.2.4 <b> 07.Jul.2021</b>
       - <a href="releases/HepMC3-3.2.3.tar.gz">HepMC-3.2.3.tar.gz</a> HepMC3-3.2.3 <b> 14.Dec.2020</b>
       - <a href="releases/HepMC3-3.2.2.tar.gz">HepMC-3.2.2.tar.gz</a> HepMC3-3.2.2 <b> 10.Jun.2020</b>
       - <a href="releases/HepMC3-3.2.1.tar.gz">HepMC-3.2.1.tar.gz</a> HepMC3-3.2.1 <b> 17.Mar.2020</b>
       - <a href="releases/HepMC3-3.2.0.tar.gz">HepMC-3.2.0.tar.gz</a> HepMC3-3.2.0 <b> 27.Nov.2019</b>
       - <a href="releases/HepMC3-3.1.2.tar.gz">HepMC-3.1.2.tar.gz</a> HepMC3-3.1.2 <b> 23.Aug.2019</b>
-      - <a href="releases/HepMC3-3.1.1.tar.gz">HepMC-3.1.1.tar.gz</a> HepMC3-3.1.1 <b> 29.Mar.2019</b>
-      - <a href="releases/HepMC3-3.1.0.tar.gz">HepMC-3.1.0.tar.gz</a> HepMC3-3.1.0 <b> 08.Feb.2019</b>
-      - <a href="releases/hepmc3.0.0.tgz">hepmc3.0.0.tgz</a> HepMC3-3.0.0 <b> 20.Mar.2017</b>
-      - <a href="releases/hepmc3-beta2.0.tgz">hepmc3-beta2.0.tgz</a> HepMC3-beta2.0 <b> 25.Apr.2016</b>
-      - <a href="releases/hepmc3-beta1.0.tgz">hepmc3-beta1.0.tgz</a> HepMC3-beta1.0 <b> 13.Jan.2016</b>
-      - <a href="releases/hepmc3-alpha5.tgz">hepmc3-alpha5.tgz</a> HepMC3-alpha5 <b> 29.Apr.2015</b>
-      - <a href="releases/hepmc3-alpha4.tgz">hepmc3-alpha4.tgz</a> HepMC3-alpha4 <b> 7.Apr.2015</b>
-      - <a href="releases/hepmc3-alpha3.tgz">hepmc3-alpha3.tgz</a> HepMC3-alpha3 <b>10.Mar.2015</b>
-      - <a href="releases/hepmc3-alpha2.tgz">hepmc3-alpha2.tgz</a> HepMC3-alpha2 <b>15.Dec.2014</b>
-      - <a href="releases/hepmc3-alpha1.tgz">hepmc3-alpha1.tgz</a> First alpha release of HepMC3 <b>6.Nov.2014</b>
 
     @subsection hepmc2_releases HepMC2 releases
     <a href="https://gitlab.cern.ch/hepmc/HepMC/blob/master/ChangeLog">ChangeLog</a>
 
       - <a href="releases/hepmc2.06.11.tgz">hepmc2.06.11.tgz</a> HepMC2.06.11 <b> 10.June.2020</b>
       - <a href="releases/hepmc2.06.10.tgz">hepmc2.06.10.tgz</a> HepMC2.06.10 <b> 26.July.2019</b>
       - <a href="releases/hepmc2.07-beta00.tgz">hepmc2.07-beta00.tgz</a> HepMC2.07.beta00 <b> 19.August.2016</b>
@@ -71,25 +69,24 @@
 
     @section documentation Documentation
     - @subpage building
     - @subpage features
     - @subpage differences
     - HepMC2.06 <a href="releases/HepMC2_user_manual.pdf">user manual</a> and <a href="releases/HepMC2_reference_manual.pdf">reference manual</a> (old documents NOT covering HepMC3)
 
-    @subsection linksx  Links to project-related web-pages
+    @subsection links  Links to project-related web-pages
      - <a href="https://gitlab.cern.ch/hepmc/HepMC3">       <b>HepMC3 GitLab repository </b></a>
      - <a href="https://gitlab.cern.ch/hepmc/HepMC">        <b>HepMC2 GitLab repository </b></a>
      - <a href="https://sft.its.cern.ch/jira/browse/HEPMC"> <b>HepMC project JIRA instance </b></a>
      - <a href="resources/docs">                            <b>Slides from developers meetings </b></a>
 
     @subsection diagram HepMC3 class diagram
 
     @note Some of the classes and less significant relations omitted for clarity
     @note The classes related to rootIO, Search engine and LHEF are not shown.
 
     <img src="class_diagram.png">
 
     <hr>
 
- Last update 27 Oct 2020
 */
```

#### html2text {}

```diff
@@ -4,46 +4,44 @@
 Record_Library_for_Monte_Carlo_Event_Generators_(Comput._Phys._Commun._(2020),
 in_press) InSpire_record The original code was written by M._Dobbs_and_J.B.
 Hansen,_The_HepMC_C++_Monte_Carlo_event_record_for_High_Energy_Physics_(Comput.
 Phys._Commun._134_(2001)_41). Since the first implementation, the package has
 undergone several modifications and in particular, the latest HepMC3 series is
 a completely new re-write using currently available C++11 techniques, and have
 out-of-the-box interfaces for the widely used in HEP community ROOT and Python.
-@section releases Status of releases The current development effort is
-concentrated on the HepMC3 series. Users are encouraged to integrate that
-version in their applications and to provide any feedback they may have. Visit
-the CERN GitLab repository https://gitlab.cern.ch/hepmc/HepMC3 for more
-information. The HepMC2 series development has been essentially stopped and in
-particular HepMC2.06.x (with the latest being 2.06.11) versions are frozen.
-Some of the new features of HepMC3 series are now also available in HepMC2.07.x
-versions, but this should be regarded (for those who need it) as an
-intermediate step before migrating to HepMC3. Since HepMC3 version 3.1 both
-HepMC2 and HepMC3 can be installed in the same prefix simultaneously. Finally,
-HepMC1 series is by now fully deprecated. @section tarfiles Available tarfiles
-Development version (updated daily at 3AM): hepmc3-dev.tgz @subsection
-hepmc3_releases HepMC3 releases ChangeLog - HepMC-3.2.5.tar.gz HepMC3-3.2.5
-XX.Jan.2022 - HepMC-3.2.4.tar.gz HepMC3-3.2.4 07.Jul.2021 - HepMC-3.2.3.tar.gz
-HepMC3-3.2.3 14.Dec.2020 - HepMC-3.2.2.tar.gz HepMC3-3.2.2 10.Jun.2020 - HepMC-
-3.2.1.tar.gz HepMC3-3.2.1 17.Mar.2020 - HepMC-3.2.0.tar.gz HepMC3-3.2.0
-27.Nov.2019 - HepMC-3.1.2.tar.gz HepMC3-3.1.2 23.Aug.2019 - HepMC-3.1.1.tar.gz
-HepMC3-3.1.1 29.Mar.2019 - HepMC-3.1.0.tar.gz HepMC3-3.1.0 08.Feb.2019 -
-hepmc3.0.0.tgz HepMC3-3.0.0 20.Mar.2017 - hepmc3-beta2.0.tgz HepMC3-beta2.0
-25.Apr.2016 - hepmc3-beta1.0.tgz HepMC3-beta1.0 13.Jan.2016 - hepmc3-alpha5.tgz
-HepMC3-alpha5 29.Apr.2015 - hepmc3-alpha4.tgz HepMC3-alpha4 7.Apr.2015 -
-hepmc3-alpha3.tgz HepMC3-alpha3 10.Mar.2015 - hepmc3-alpha2.tgz HepMC3-alpha2
-15.Dec.2014 - hepmc3-alpha1.tgz First alpha release of HepMC3 6.Nov.2014
-@subsection hepmc2_releases HepMC2 releases ChangeLog - hepmc2.06.11.tgz
-HepMC2.06.11 10.June.2020 - hepmc2.06.10.tgz HepMC2.06.10 26.July.2019 -
-hepmc2.07-beta00.tgz HepMC2.07.beta00 19.August.2016 - hepmc2.06.09.tgz
-HepMC2.06.09 05.June.2012 @subsection heppdt_releases HepPDT releases - HepPDT-
-3.04.01.tar.gz HepPDT-3.04.01 @subsection contact Contact information: - hepmc-
-dev@NOSPAM.cern.ch_mailing_list - CERN_GitLab_issues_tracker @section
-documentation Documentation - @subpage building - @subpage features - @subpage
-differences - HepMC2.06 user_manual and reference_manual (old documents NOT
-covering HepMC3) @subsection linksx Links to project-related web-pages - HepMC3
-GitLab_repository - HepMC2_GitLab_repository - HepMC_project_JIRA_instance -
-Slides_from_developers_meetings @subsection diagram HepMC3 class diagram @note
-Some of the classes and less significant relations omitted for clarity @note
-The classes related to rootIO, Search engine and LHEF are not shown.
-[class_diagram.png]
+Further documentation that might be useful for the users of HepMC3 can be found
+in the following documents: - E.Bothmann_et_al.,_A_standard_convention_for
+particle-level_Monte_Carlo_event-variation_weights InSpire_record - J._Alwall
+et_al.,_A_standard_format_for_Les_Houches_Event_Files InSpire_record @section
+releases Status of releases The current development effort is concentrated on
+the HepMC3 series. Users are encouraged to integrate that version in their
+applications and to provide any feedback they may have. Visit the CERN GitLab
+repository https://gitlab.cern.ch/hepmc/HepMC3 for more information. The HepMC2
+series development has been essentially stopped and in particular HepMC2.06.x
+(with the latest being 2.06.11) versions are frozen. Some of the new features
+of HepMC3 series are now also available in HepMC2.07.x versions, but this
+should be regarded (for those who need it) as an intermediate step before
+migrating to HepMC3. Since HepMC3 version 3.1 both HepMC2 and HepMC3 can be
+installed in the same prefix simultaneously. Finally, HepMC1 series is by now
+fully deprecated. @section tarfiles Available tarfiles Development version
+(updated daily at 3AM): hepmc3-dev.tgz @subsection hepmc3_releases HepMC3
+releases ChangeLog - HepMC-3.2.6.tar.gz HepMC3-3.2.6 Mar.2023 - HepMC-
+3.2.5.tar.gz HepMC3-3.2.5 22.Feb.2022 - HepMC-3.2.4.tar.gz HepMC3-3.2.4
+07.Jul.2021 - HepMC-3.2.3.tar.gz HepMC3-3.2.3 14.Dec.2020 - HepMC-3.2.2.tar.gz
+HepMC3-3.2.2 10.Jun.2020 - HepMC-3.2.1.tar.gz HepMC3-3.2.1 17.Mar.2020 - HepMC-
+3.2.0.tar.gz HepMC3-3.2.0 27.Nov.2019 - HepMC-3.1.2.tar.gz HepMC3-3.1.2
+23.Aug.2019 @subsection hepmc2_releases HepMC2 releases ChangeLog -
+hepmc2.06.11.tgz HepMC2.06.11 10.June.2020 - hepmc2.06.10.tgz HepMC2.06.10
+26.July.2019 - hepmc2.07-beta00.tgz HepMC2.07.beta00 19.August.2016 -
+hepmc2.06.09.tgz HepMC2.06.09 05.June.2012 @subsection heppdt_releases HepPDT
+releases - HepPDT-3.04.01.tar.gz HepPDT-3.04.01 @subsection contact Contact
+information: - hepmc-dev@NOSPAM.cern.ch_mailing_list - CERN_GitLab_issues
+tracker @section documentation Documentation - @subpage building - @subpage
+features - @subpage differences - HepMC2.06 user_manual and reference_manual
+(old documents NOT covering HepMC3) @subsection links Links to project-related
+web-pages - HepMC3_GitLab_repository - HepMC2_GitLab_repository - HepMC_project
+JIRA_instance - Slides_from_developers_meetings @subsection diagram HepMC3
+class diagram @note Some of the classes and less significant relations omitted
+for clarity @note The classes related to rootIO, Search engine and LHEF are not
+shown. [class_diagram.png]
 ===============================================================================
-Last update 27 Oct 2020 */
+*/
```

### Comparing `HepMC3-3.2.5/doc/doxygen/modules.txt` & `HepMC3-3.2.6/doc/doxygen/modules.txt`

 * *Files 12% similar despite different names*

```diff
@@ -30,20 +30,28 @@
     @code{.cpp}
            void Reader::set_options(const std::map<std::string, std::string>& options)
 
            std::map<std::string, std::string> Reader::get_options() const
     @endcode
 
     The options for ReaderAsciiHepMC2
+      "disable_pad_cross_sections"
+      "pad_cross_section_value"/"pad_cross_section_error"
+     If "disable_pad_cross_sections" is present the reader will keep a single cross-section per event, just
+     in the HepMC2 style. This is pre-3.2.6 default behaviour. 
+     Otherwise, the cross-section vector will be expanded to the size  of event weights. This is 3.2.6+ default behaviour.
+     If present, "pad_cross_section_value"/"pad_cross_section_error" values will be inserted into the cross-section vector.
+     Otherwise, the cross-sections and errors will be filled with zeros.
+     
 
       "particle_flows_are_separated"
       "event_random_states_are_separated"
       "vertex_weights_are_separated"
       "particle_flows_are_separated"
-     regulate if the corresponding information from IO_GenEvent would be stored into multiple attributes as
+     Regulate if the corresponding information from IO_GenEvent would be stored into multiple attributes as
      individual numbers, i.e. "separated" or as a single std::vector. The former behavior is used if
      the corresponding option name is present in the list of options, regardless of the option value.
      The later behavior is the default one.
 
     The option for WriterAscii and WriterAsciiHepMC2
 
      "float_printf_specifier"
```

### Comparing `HepMC3-3.2.5/doc/doxygen/search.txt` & `HepMC3-3.2.6/doc/doxygen/search.txt`

 * *Files 7% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 /**
     @defgroup Search Search-related classes and interfaces
 
     HepMC3 comes with an optional "Search" library for finding particles
     related to other particles or vertices.
     It provides a set of functions to perform simple search operations e.g.
     @code
-    std::vector<HepMC3::GenParticlePtr>      children_particles(HepMC3::GenVertexPtr O);   ///< Return children particles
-    std::vector<HepMC3::ConstGenVertexPtr>   grandchildren_vertices(HepMC3::ConstGenVertexPtr O); ///< Return grandchildren vertices
-    std::vector<HepMC3::GenParticlePtr>      parent_particles(HepMC3::GenVertexPtr O);  ///< Return parent particles
-    std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(HepMC3::GenVertexPtr obj);      ///< Return ancestor vertices
+    std::vector<HepMC3::GenParticlePtr>      children_particles(const HepMC3::GenVertexPtr& O);   ///< Return children particles
+    std::vector<HepMC3::ConstGenVertexPtr>   grandchildren_vertices(const HepMC3::ConstGenVertexPtr& O); ///< Return grandchildren vertices
+    std::vector<HepMC3::GenParticlePtr>      parent_particles(const HepMC3::GenVertexPtr& O);  ///< Return parent particles
+    std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(const HepMC3::GenVertexPtr& obj);      ///< Return ancestor vertices
     @code
     and interfaces for a more advanced usage. For the latter two main interfaces are defined:
     Relatives, for finding a particular type of relative, and Feature, for
     generating filters based on Features extracted from particles.
     In addition, operator on Filters are also defined.
 
     ###########################################################################
```

### Comparing `HepMC3-3.2.5/examples/BasicExamples/CMakeLists.txt` & `HepMC3-3.2.6/examples/BasicExamples/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/BasicExamples/HepMC2_reader_example.cc` & `HepMC3-3.2.6/examples/BasicExamples/HepMC2_reader_example.cc`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @example HepMC2_reader_example.cc
  *  @brief Example of use of HepMC2 adapter
  *
  *  Converts selected HepMC2 file to HepMC3 file
  *
```

### Comparing `HepMC3-3.2.5/examples/BasicExamples/HepMC3_fileIO_example.cc` & `HepMC3-3.2.6/examples/BasicExamples/HepMC3_fileIO_example.cc`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @example HepMC3_fileIO_example.cc
  *  @brief Test of file I/O
  *
  *  Parses HepMC3 file and saves it as a new HepMC3 file.
  *  The resulting file should be an exact copy of the input file
```

### Comparing `HepMC3-3.2.5/examples/BasicExamples/basic_tree.cc` & `HepMC3-3.2.6/examples/BasicExamples/basic_tree.cc`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /// @example basic_tree.cc
 /// @brief Basic example of building HepMC3 tree by hand
 ///
 ///  Based on HepMC2/examples/example_BuildEventFromScratch.cc
 
 #include "HepMC3/GenEvent.h"
@@ -122,16 +122,16 @@
     // remove attribute
     evt.remove_attribute("GenCrossSection");
     evt.remove_attribute("GenCrossSection"); // This call will do nothing
 
     // now this should be null
     cs = evt.attribute<GenCrossSection>("GenCrossSection");
 
-    if(!cs)std::cout << "Successfully removed attribute" <<std::endl;
-    else   std::cout << "Problem removing attribute!" <<std::endl;
+    if(!cs){std::cout << "Successfully removed attribute" <<std::endl;}
+    else   {std::cout << "Problem removing attribute!" <<std::endl;}
 
     //
     // Example of adding attributes and finding particles with attributes
     //
 
     std::shared_ptr<Attribute> tool1           = std::make_shared<IntAttribute>(1);
     std::shared_ptr<Attribute> tool999         = std::make_shared<IntAttribute>(999);
```

### Comparing `HepMC3-3.2.5/examples/BasicExamples/hepevt_wrapper_example_fortran.f` & `HepMC3-3.2.6/examples/BasicExamples/hepevt_wrapper_example_fortran.f`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/BasicExamples/hepevt_wrapper_example_main.cc` & `HepMC3-3.2.6/examples/BasicExamples/hepevt_wrapper_example_main.cc`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @example hepevt_wrapper_example_main.cc
  *  @brief Basic example of HEPEVT interface use
  *
  *  Fills HEPEVT twice - once using FORTRAN and second time using C++
  *  Tests that both times printouts from FORTRAN and C++ match
```

### Comparing `HepMC3-3.2.5/examples/CMakeLists.txt` & `HepMC3-3.2.6/examples/CMakeLists.txt`

 * *Files 2% similar despite different names*

```diff
@@ -59,15 +59,17 @@
       set(HEPMC3_ROOTIO_LIBRARY "-lHepMC3rootIO" )
     else()
       message(STATUS "HepMC3 warning: ROOT needed for ROOTIO but not found")
       message(STATUS "HepMC3 warning: Skipping HepMC ROOT IO libraries")
       set(HEPMC3_ENABLE_ROOTIO OFF)
     endif()
   endif()
-
+  if (HEPMC3_PROTOBUFIO_LIB)
+      find_package(Protobuf 2.4 REQUIRED)
+  endif()
   if (NOT HEPMC3_CXX_STANDARD)
     set(HEPMC3_CXX_STANDARD 11)
   endif()
   set(CMAKE_CXX_STANDARD ${HEPMC3_CXX_STANDARD})
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_CXX_EXTENSIONS OFF)
   if (MSVC)
@@ -77,14 +79,15 @@
       CHECK_CXX_COMPILER_FLAG(${fl} COMPILER_SUPPORTS_${fl})
       if(COMPILER_SUPPORTS_${fl})
         set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${fl}")
       endif()
     endforeach(fl ${MSVC_CXX_FLAGS_TO_CHECK})
   endif()
 else()
+  set(HEPMC3_PROTOBUFIO_LIB HepMC3protobufIO)
   set(HEPMC3_ROOTIO_LIB HepMC3rootIO)
   set(HEPMC3_SEARCH_LIB HepMC3search)
   set(HEPMC3_LIB HepMC3)
 endif()
 #<-This is needed for standalone compilation
 
 
@@ -99,15 +102,15 @@
   enable_language(Fortran)
   get_filename_component (Fortran_COMPILER_NAME ${CMAKE_Fortran_COMPILER} NAME)
   message(STATUS "HepMC3 examples: Fortran compiler found, Pythia6 example enabled. Fortran_COMPILER_NAME=${Fortran_COMPILER_NAME}  CMAKE_Fortran_COMPILER_ID=${CMAKE_Fortran_COMPILER_ID}")
   if (CMAKE_Fortran_COMPILER_ID STREQUAL "GNU")
     set( CMAKE_Fortran_FLAGS  "${CMAKE_Fortran_FLAGS} -fno-automatic -fno-backslash -ffixed-line-length-132 -std=legacy")
   elseif (CMAKE_Fortran_COMPILER_ID STREQUAL "Intel")
     if (WIN32)
-      set( CMAKE_Fortran_FLAGS  "${CMAKE_Fortran_FLAGS} /noauto /extend-source:132")    
+      set( CMAKE_Fortran_FLAGS  "${CMAKE_Fortran_FLAGS} /noauto /extend-source:132")
     else()
       set( CMAKE_Fortran_FLAGS  "${CMAKE_Fortran_FLAGS} -noauto -extend-source 132")
     endif()
   elseif (${CMAKE_CXX_COMPILER_ID} MATCHES "PGI" OR ${CMAKE_CXX_COMPILER_ID} MATCHES "NVHPC")
     set( CMAKE_Fortran_FLAGS  "${CMAKE_Fortran_FLAGS} -Mpreprocess -Mextend -Mnosave -Mnofree")
   elseif (CMAKE_Fortran_COMPILER_ID STREQUAL "SunPro")
     set( CMAKE_Fortran_FLAGS  "${CMAKE_Fortran_FLAGS}  ")
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/CMakeLists.txt` & `HepMC3-3.2.6/examples/ConvertExample/CMakeLists.txt`

 * *Files 3% similar despite different names*

```diff
@@ -45,14 +45,21 @@
   list(APPEND basic_sources ${CMAKE_CURRENT_SOURCE_DIR}/src/WriterRootTreeOPAL.cc )
   list(APPEND basic_libraries ${ROOT_LIBRARIES} ${HEPMC3_ROOTIO_LIB})
   list(APPEND basic_defines HEPMCCONVERT_EXTENSION_ROOTTREEOPAL=1)
   list(APPEND basic_dependencies dictionary)
   # create environment scripts
   set(basic_libdir "${basic_libdir}:${ROOT_LIBRARY_DIR}")
 endif()
+if(Protobuf_FOUND)
+  list(APPEND basic_includes ${PROJECT_SOURCE_DIR}/protobufIO/include  ${Protobuf_INCLUDE_DIRS})
+  list(APPEND basic_libraries ${Protobuf_LIBRARIES} ${HEPMC3_PROTOBUFIO_LIB})
+  # create environment scripts
+  set(basic_libdir "${basic_libdir}:${Protobuf_LIBRARY_DIR}")
+endif()
+
 
 if(${CMAKE_VERSION} VERSION_GREATER "3.8")
 ########################################################################
 #FindPython is not reenterant, so we have to hack the cache.
 ########################################################################
   unset(_Python3_LIBRARY_RELEASE CACHE) # Attempt to make FindPython reenterant
   unset(_Python3_NumPy_INCLUDE_DIR CACHE) # Attempt to make FindPython reenterant
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/cmdline.c` & `HepMC3-3.2.6/examples/ConvertExample/cmdline.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 /*
   File autogenerated by gengetopt version 2.23
   generated with the following command:
-  /usr/local/bin/gengetopt -N --no-version --input=/Volumes/Work/HM3/HepMC3/examples/ConvertExample/cmdline.ggo --file-name cmdline --output-dir=/Volumes/Work/HM3/HepMC3/examples/ConvertExample --include-getopt --show-required --unnamed-opts=inputfile outputfile 
+  /usr/bin/gengetopt -N --no-version --input=/home/andriish/Projects/HepMC3/examples/ConvertExample/cmdline.ggo --file-name cmdline --output-dir=/home/andriish/Projects/HepMC3/examples/ConvertExample --include-getopt --show-required --unnamed-opts=inputfile outputfile
 
   The developers of gengetopt consider the fixed text that goes in all
   gengetopt output files to be in the public domain:
   we make no copyright claims on it.
 */
 
 /* If we use autoconf.  */
@@ -30,17 +30,18 @@
 
 const char *gengetopt_args_info_versiontext = "";
 
 const char *gengetopt_args_info_description = "";
 
 const char *gengetopt_args_info_help[] = {
   "  -h, --help                    Print help and exit",
-  "  -i, --input-format=STRING     Input format  (possible values=\"hepmc2\",\n                                  \"auto\", \"hepmc3\", \"hpe\", \"root\",\n                                  \"treeroot\", \"lhef\", \"uproot\",\n                                  \"plugin\") (mandatory)",
-  "  -o, --output-format=STRING    Output format  (possible values=\"hepmc2\",\n                                  \"hepmc3\", \"hpe\", \"root\", \"treeroot\",\n                                  \"treerootopal\", \"hpezeus\", \"dump\",\n                                  \"plugin\", \"dot\", \"none\") (mandatory)",
+  "  -i, --input-format=STRING     Input format  (possible values=\"hepmc2\",\n                                  \"auto\", \"hepmc3\", \"hpe\", \"root\",\n                                  \"treeroot\", \"lhef\", \"uproot\",\n                                  \"plugin\", \"proto\") (mandatory)",
+  "  -o, --output-format=STRING    Output format  (possible values=\"hepmc2\",\n                                  \"hepmc3\", \"hpe\", \"root\", \"treeroot\",\n                                  \"treerootopal\", \"hpezeus\", \"dump\",\n                                  \"plugin\", \"dot\", \"none\", \"proto\")\n                                  (mandatory)",
   "  -e, --extensions=STRING       Extensions, in a form extension=value, could be\n                                  passed to readers/writers",
+  "      --strict-read=LONG        Exit in case of reading broken event.\n                                  (default=`0')",
   "      --events-limit=LONG       Limit of events to read from input\n                                  (default=`100000000')",
   "      --first-event-number=LONG Lowest allowed event number\n                                  (default=`-100000000')",
   "      --last-event-number=LONG  Highest allowed event number\n                                  (default=`100000000')",
   "      --print-every-events-parsed=LONG\n                                Frequency of parsing information printouts\n                                  (default=`100')",
   "      --compressed-input        Assume compressed input for expicitely\n                                  specified formats. Requires linkage with\n                                  zlib/lzma/bz2.  (default=off)",
   "      --compressed-output=STRING\n                                Write compressed output for expicitely\n                                  specified formats. Requires linkage with\n                                  zlib/lzma/bz2.  (possible values=\"z\",\n                                  \"lzma\", \"bz2\", \"plaintext\"\n                                  default=`plaintext')",
     0
@@ -60,28 +61,29 @@
 static int
 cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                         struct cmdline_parser_params *params, const char *additional_error);
 
 static int
 cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);
 
-const char *cmdline_parser_input_format_values[] = {"hepmc2", "auto", "hepmc3", "hpe", "root", "treeroot", "lhef", "uproot", "plugin", 0}; /*< Possible values for input-format. */
-const char *cmdline_parser_output_format_values[] = {"hepmc2", "hepmc3", "hpe", "root", "treeroot", "treerootopal", "hpezeus", "dump", "plugin", "dot", "none", 0}; /*< Possible values for output-format. */
+const char *cmdline_parser_input_format_values[] = {"hepmc2", "auto", "hepmc3", "hpe", "root", "treeroot", "lhef", "uproot", "plugin", "proto", 0}; /*< Possible values for input-format. */
+const char *cmdline_parser_output_format_values[] = {"hepmc2", "hepmc3", "hpe", "root", "treeroot", "treerootopal", "hpezeus", "dump", "plugin", "dot", "none", "proto", 0}; /*< Possible values for output-format. */
 const char *cmdline_parser_compressed_output_values[] = {"z", "lzma", "bz2", "plaintext", 0}; /*< Possible values for compressed-output. */
 
 static char *
 gengetopt_strdup (const char *s);
 
 static
 void clear_given (struct gengetopt_args_info *args_info)
 {
   args_info->help_given = 0 ;
   args_info->input_format_given = 0 ;
   args_info->output_format_given = 0 ;
   args_info->extensions_given = 0 ;
+  args_info->strict_read_given = 0 ;
   args_info->events_limit_given = 0 ;
   args_info->first_event_number_given = 0 ;
   args_info->last_event_number_given = 0 ;
   args_info->print_every_events_parsed_given = 0 ;
   args_info->compressed_input_given = 0 ;
   args_info->compressed_output_given = 0 ;
 }
@@ -92,46 +94,49 @@
   FIX_UNUSED (args_info);
   args_info->input_format_arg = NULL;
   args_info->input_format_orig = NULL;
   args_info->output_format_arg = NULL;
   args_info->output_format_orig = NULL;
   args_info->extensions_arg = NULL;
   args_info->extensions_orig = NULL;
+  args_info->strict_read_arg = 0;
+  args_info->strict_read_orig = NULL;
   args_info->events_limit_arg = 100000000;
   args_info->events_limit_orig = NULL;
   args_info->first_event_number_arg = -100000000;
   args_info->first_event_number_orig = NULL;
   args_info->last_event_number_arg = 100000000;
   args_info->last_event_number_orig = NULL;
   args_info->print_every_events_parsed_arg = 100;
   args_info->print_every_events_parsed_orig = NULL;
   args_info->compressed_input_flag = 0;
   args_info->compressed_output_arg = gengetopt_strdup ("plaintext");
   args_info->compressed_output_orig = NULL;
-  
+
 }
 
 static
 void init_args_info(struct gengetopt_args_info *args_info)
 {
 
 
   args_info->help_help = gengetopt_args_info_help[0] ;
   args_info->input_format_help = gengetopt_args_info_help[1] ;
   args_info->output_format_help = gengetopt_args_info_help[2] ;
   args_info->extensions_help = gengetopt_args_info_help[3] ;
   args_info->extensions_min = 0;
   args_info->extensions_max = 0;
-  args_info->events_limit_help = gengetopt_args_info_help[4] ;
-  args_info->first_event_number_help = gengetopt_args_info_help[5] ;
-  args_info->last_event_number_help = gengetopt_args_info_help[6] ;
-  args_info->print_every_events_parsed_help = gengetopt_args_info_help[7] ;
-  args_info->compressed_input_help = gengetopt_args_info_help[8] ;
-  args_info->compressed_output_help = gengetopt_args_info_help[9] ;
-  
+  args_info->strict_read_help = gengetopt_args_info_help[4] ;
+  args_info->events_limit_help = gengetopt_args_info_help[5] ;
+  args_info->first_event_number_help = gengetopt_args_info_help[6] ;
+  args_info->last_event_number_help = gengetopt_args_info_help[7] ;
+  args_info->print_every_events_parsed_help = gengetopt_args_info_help[8] ;
+  args_info->compressed_input_help = gengetopt_args_info_help[9] ;
+  args_info->compressed_output_help = gengetopt_args_info_help[10] ;
+
 }
 
 void
 cmdline_parser_print_version (void)
 {
   printf ("%s %s\n",
      (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
@@ -182,29 +187,29 @@
   args_info->inputs_num = 0;
 }
 
 void
 cmdline_parser_params_init(struct cmdline_parser_params *params)
 {
   if (params)
-    { 
+    {
       params->override = 0;
       params->initialize = 1;
       params->check_required = 1;
       params->check_ambiguity = 0;
       params->print_errors = 1;
     }
 }
 
 struct cmdline_parser_params *
 cmdline_parser_params_create(void)
 {
-  struct cmdline_parser_params *params = 
+  struct cmdline_parser_params *params =
     (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
-  cmdline_parser_params_init(params);  
+  cmdline_parser_params_init(params);
   return params;
 }
 
 static void
 free_string_field (char **s)
 {
   if (*s)
@@ -226,15 +231,15 @@
 {
   union generic_value arg;
   char *orig;
   struct generic_list *next;
 };
 
 /**
- * @brief add a node at the head of the list 
+ * @brief add a node at the head of the list
  */
 static void add_node(struct generic_list **list) {
   struct generic_list *new_node = (struct generic_list *) malloc (sizeof (struct generic_list));
   new_node->next = *list;
   *list = new_node;
   new_node->arg.string_arg = 0;
   new_node->orig = 0;
@@ -265,22 +270,23 @@
 {
   unsigned int i;
   free_string_field (&(args_info->input_format_arg));
   free_string_field (&(args_info->input_format_orig));
   free_string_field (&(args_info->output_format_arg));
   free_string_field (&(args_info->output_format_orig));
   free_multiple_string_field (args_info->extensions_given, &(args_info->extensions_arg), &(args_info->extensions_orig));
+  free_string_field (&(args_info->strict_read_orig));
   free_string_field (&(args_info->events_limit_orig));
   free_string_field (&(args_info->first_event_number_orig));
   free_string_field (&(args_info->last_event_number_orig));
   free_string_field (&(args_info->print_every_events_parsed_orig));
   free_string_field (&(args_info->compressed_output_arg));
   free_string_field (&(args_info->compressed_output_orig));
-  
-  
+
+
   for (i = 0; i < args_info->inputs_num; ++i)
     free (args_info->inputs [i]);
 
   if (args_info->inputs_num)
     free (args_info->inputs);
 
   clear_given (args_info);
@@ -324,30 +330,30 @@
 
 static void
 write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
 {
   int found = -1;
   if (arg) {
     if (values) {
-      found = check_possible_values(arg, values);      
+      found = check_possible_values(arg, values);
     }
     if (found >= 0)
       fprintf(outfile, "%s=\"%s\" # %s\n", opt, arg, values[found]);
     else
       fprintf(outfile, "%s=\"%s\"\n", opt, arg);
   } else {
     fprintf(outfile, "%s\n", opt);
   }
 }
 
 static void
 write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])
 {
   int i;
-  
+
   for (i = 0; i < len; ++i)
     write_into_file(outfile, opt, (arg ? arg[i] : 0), values);
 }
 
 int
 cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
 {
@@ -362,27 +368,29 @@
   if (args_info->help_given)
     write_into_file(outfile, "help", 0, 0 );
   if (args_info->input_format_given)
     write_into_file(outfile, "input-format", args_info->input_format_orig, cmdline_parser_input_format_values);
   if (args_info->output_format_given)
     write_into_file(outfile, "output-format", args_info->output_format_orig, cmdline_parser_output_format_values);
   write_multiple_into_file(outfile, args_info->extensions_given, "extensions", args_info->extensions_orig, 0);
+  if (args_info->strict_read_given)
+    write_into_file(outfile, "strict-read", args_info->strict_read_orig, 0);
   if (args_info->events_limit_given)
     write_into_file(outfile, "events-limit", args_info->events_limit_orig, 0);
   if (args_info->first_event_number_given)
     write_into_file(outfile, "first-event-number", args_info->first_event_number_orig, 0);
   if (args_info->last_event_number_given)
     write_into_file(outfile, "last-event-number", args_info->last_event_number_orig, 0);
   if (args_info->print_every_events_parsed_given)
     write_into_file(outfile, "print-every-events-parsed", args_info->print_every_events_parsed_orig, 0);
   if (args_info->compressed_input_given)
     write_into_file(outfile, "compressed-input", 0, 0 );
   if (args_info->compressed_output_given)
     write_into_file(outfile, "compressed-output", args_info->compressed_output_orig, cmdline_parser_compressed_output_values);
-  
+
 
   i = EXIT_SUCCESS;
   return i;
 }
 
 int
 cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
@@ -460,16 +468,16 @@
 
   ret = (char *) malloc (len);
 
   i = 0;
   j = 0;
   while (arg[i] && (j < len-1))
     {
-      if (arg[i] == '\\' && 
-	  arg[ i + 1 ] && 
+      if (arg[i] == '\\' &&
+	  arg[ i + 1 ] &&
 	  arg[ i + 1 ] == ',')
         ++i;
 
       ret[j++] = arg[i++];
     }
 
   ret[len-1] = '\0';
@@ -553,15 +561,15 @@
             {
               fprintf (stderr, "%s: %s option occurrences must be at most %d\n",
                 prog_name, option_desc, max);
               error_occurred = 1;
             }
         }
     }
-    
+
   return error_occurred;
 }
 int
 cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
 {
   return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
 }
@@ -574,38 +582,38 @@
   result = cmdline_parser_internal (argc, argv, args_info, params, 0);
 
   if (result == EXIT_FAILURE)
     {
       cmdline_parser_free (args_info);
       exit (EXIT_FAILURE);
     }
-  
+
   return result;
 }
 
 int
 cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
 {
   int result;
   struct cmdline_parser_params params;
-  
+
   params.override = override;
   params.initialize = initialize;
   params.check_required = check_required;
   params.check_ambiguity = 0;
   params.print_errors = 1;
 
   result = cmdline_parser_internal (argc, argv, args_info, &params, 0);
 
   if (result == EXIT_FAILURE)
     {
       cmdline_parser_free (args_info);
       exit (EXIT_FAILURE);
     }
-  
+
   return result;
 }
 
 int
 cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
 {
   int result = EXIT_SUCCESS;
@@ -614,15 +622,15 @@
     result = EXIT_FAILURE;
 
   if (result == EXIT_FAILURE)
     {
       cmdline_parser_free (args_info);
       exit (EXIT_FAILURE);
     }
-  
+
   return result;
 }
 
 int
 cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
 {
   int error_occurred = 0;
@@ -630,25 +638,25 @@
 
   /* checks for required options */
   if (! args_info->input_format_given)
     {
       fprintf (stderr, "%s: '--input-format' ('-i') option required%s\n", prog_name, (additional_error ? additional_error : ""));
       error_occurred = 1;
     }
-  
+
   if (! args_info->output_format_given)
     {
       fprintf (stderr, "%s: '--output-format' ('-o') option required%s\n", prog_name, (additional_error ? additional_error : ""));
       error_occurred = 1;
     }
-  
+
   if (check_multiple_option_occurrences(prog_name, args_info->extensions_given, args_info->extensions_min, args_info->extensions_max, "'--extensions' ('-e')"))
      error_occurred = 1;
-  
-  
+
+
   /* checks for dependences among options */
 
   return error_occurred;
 }
 
 /*
  * Extracted from the glibc source tree, version 2.3.6
@@ -659,15 +667,15 @@
  * many times without risking previous memory to be spoiled.
  *
  * Modified by Andre Noll and Lorenzo Bettini for use in
  * GNU gengetopt generated files.
  *
  */
 
-/* 
+/*
  * we must include anything we need since this file is not thought to be
  * inserted in a file already using getopt.h
  *
  * Lorenzo
  */
 
 struct option
@@ -1194,15 +1202,15 @@
 
 	if (optstring[0] == ':')
 		print_errors = 0;
 	if (argc < 1)
 		return -1;
 	d->custom_optarg = NULL;
 
-	/* 
+	/*
 	 * This is a big difference with GNU getopt, since optind == 0
 	 * means initialization while here 1 means first call.
 	 */
 	if (d->custom_optind == 0 || !d->initialized) {
 		if (d->custom_optind == 0)
 			d->custom_optind = 1;	/* Don't scan ARGV[0], the program name.  */
 		custom_getopt_initialize(d);
@@ -1261,15 +1269,15 @@
  * @param multiple_option whether this is a multiple option
  * @param long_opt the corresponding long option
  * @param short_opt the corresponding short option (or '-' if none)
  * @param additional_error possible further error specification
  */
 static
 int update_arg(void *field, char **orig_field,
-               unsigned int *field_given, unsigned int *prev_given, 
+               unsigned int *field_given, unsigned int *prev_given,
                char *value, const char *possible_values[],
                const char *default_value,
                cmdline_parser_arg_type arg_type,
                int check_ambiguity, int override,
                int no_free, int multiple_option,
                const char *long_opt, char short_opt,
                const char *additional_error)
@@ -1282,37 +1290,37 @@
 
   stop_char = 0;
   found = 0;
 
   if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
     {
       if (short_opt != '-')
-        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
+        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n",
                package_name, long_opt, short_opt,
                (additional_error ? additional_error : ""));
       else
-        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
+        fprintf (stderr, "%s: `--%s' option given more than once%s\n",
                package_name, long_opt,
                (additional_error ? additional_error : ""));
       return 1; /* failure */
     }
 
   if (possible_values && (found = check_possible_values((value ? value : default_value), possible_values)) < 0)
     {
       if (short_opt != '-')
-        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n", 
+        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n",
           package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt, short_opt,
           (additional_error ? additional_error : ""));
       else
-        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n", 
+        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n",
           package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt,
           (additional_error ? additional_error : ""));
       return 1; /* failure */
     }
-    
+
   if (field_given && *field_given && ! override)
     return 0;
   if (prev_given)
     (*prev_given)++;
   if (field_given)
     (*field_given)++;
   if (possible_values)
@@ -1393,15 +1401,15 @@
   multi_token = get_multiple_arg_token(val);
   multi_next = get_multiple_arg_token_next (val);
 
   while (1)
     {
       add_node (list);
       if (update_arg((void *)&((*list)->arg), &((*list)->orig), 0,
-          prev_given, multi_token, possible_values, default_value, 
+          prev_given, multi_token, possible_values, default_value,
           arg_type, 0, 1, 1, 1, long_opt, short_opt, additional_error)) {
         if (multi_token) free(multi_token);
         return 1; /* failure */
       }
 
       if (multi_next)
         {
@@ -1455,27 +1463,27 @@
     case ARG_LONG:
       *((long **)field) = (long *)realloc (*((long **)field), (field_given + prev_given) * sizeof (long)); break;
     case ARG_STRING:
       *((char ***)field) = (char **)realloc (*((char ***)field), (field_given + prev_given) * sizeof (char *)); break;
     default:
       break;
     };
-    
+
     for (i = (prev_given - 1); i >= 0; --i)
       {
         tmp = list;
-        
+
         switch(arg_type) {
         case ARG_LONG:
           (*((long **)field))[i + field_given] = tmp->arg.long_arg; break;
         case ARG_STRING:
           (*((char ***)field))[i + field_given] = tmp->arg.string_arg; break;
         default:
           break;
-        }        
+        }
         (*orig_field) [i + field_given] = list->orig;
         list = list->next;
         free (tmp);
       }
   } else { /* set the default value */
     if (default_value && ! field_given) {
       switch(arg_type) {
@@ -1507,27 +1515,27 @@
                         struct cmdline_parser_params *params, const char *additional_error)
 {
   int c;	/* Character of the parsed option.  */
 
   struct generic_list * extensions_list = NULL;
   int error_occurred = 0;
   struct gengetopt_args_info local_args_info;
-  
+
   int override;
   int initialize;
   int check_required;
   int check_ambiguity;
 
   char *optarg;
   int optind;
   int opterr;
   int optopt;
-  
+
   package_name = argv[0];
-  
+
   /* TODO: Why is this here? It is not used anywhere. */
   override = params->override;
   FIX_UNUSED(override);
 
   initialize = params->initialize;
   check_required = params->check_required;
 
@@ -1550,14 +1558,15 @@
       int option_index = 0;
 
       static struct option long_options[] = {
         { "help",	0, NULL, 'h' },
         { "input-format",	1, NULL, 'i' },
         { "output-format",	1, NULL, 'o' },
         { "extensions",	1, NULL, 'e' },
+        { "strict-read",	1, NULL, 0 },
         { "events-limit",	1, NULL, 0 },
         { "first-event-number",	1, NULL, 0 },
         { "last-event-number",	1, NULL, 0 },
         { "print-every-events-parsed",	1, NULL, 0 },
         { "compressed-input",	0, NULL, 0 },
         { "compressed-output",	1, NULL, 0 },
         { 0,  0, 0, 0 }
@@ -1581,131 +1590,145 @@
         {
         case 'h':	/* Print help and exit.  */
           cmdline_parser_print_help ();
           cmdline_parser_free (&local_args_info);
           exit (EXIT_SUCCESS);
 
         case 'i':	/* Input format.  */
-        
-        
-          if (update_arg( (void *)&(args_info->input_format_arg), 
+
+
+          if (update_arg( (void *)&(args_info->input_format_arg),
                &(args_info->input_format_orig), &(args_info->input_format_given),
               &(local_args_info.input_format_given), optarg, cmdline_parser_input_format_values, 0, ARG_STRING,
               check_ambiguity, override, 0, 0,
               "input-format", 'i',
               additional_error))
             goto failure;
-        
+
           break;
         case 'o':	/* Output format.  */
-        
-        
-          if (update_arg( (void *)&(args_info->output_format_arg), 
+
+
+          if (update_arg( (void *)&(args_info->output_format_arg),
                &(args_info->output_format_orig), &(args_info->output_format_given),
               &(local_args_info.output_format_given), optarg, cmdline_parser_output_format_values, 0, ARG_STRING,
               check_ambiguity, override, 0, 0,
               "output-format", 'o',
               additional_error))
             goto failure;
-        
+
           break;
         case 'e':	/* Extensions, in a form extension=value, could be passed to readers/writers.  */
-        
-          if (update_multiple_arg_temp(&extensions_list, 
+
+          if (update_multiple_arg_temp(&extensions_list,
               &(local_args_info.extensions_given), optarg, 0, 0, ARG_STRING,
               "extensions", 'e',
               additional_error))
             goto failure;
-        
+
           break;
 
         case 0:	/* Long option with no short option */
+          /* Exit in case of reading broken event..  */
+          if (strcmp (long_options[option_index].name, "strict-read") == 0)
+          {
+
+
+            if (update_arg( (void *)&(args_info->strict_read_arg),
+                 &(args_info->strict_read_orig), &(args_info->strict_read_given),
+                &(local_args_info.strict_read_given), optarg, 0, "0", ARG_LONG,
+                check_ambiguity, override, 0, 0,
+                "strict-read", '-',
+                additional_error))
+              goto failure;
+
+          }
           /* Limit of events to read from input.  */
-          if (strcmp (long_options[option_index].name, "events-limit") == 0)
+          else if (strcmp (long_options[option_index].name, "events-limit") == 0)
           {
-          
-          
-            if (update_arg( (void *)&(args_info->events_limit_arg), 
+
+
+            if (update_arg( (void *)&(args_info->events_limit_arg),
                  &(args_info->events_limit_orig), &(args_info->events_limit_given),
                 &(local_args_info.events_limit_given), optarg, 0, "100000000", ARG_LONG,
                 check_ambiguity, override, 0, 0,
                 "events-limit", '-',
                 additional_error))
               goto failure;
-          
+
           }
           /* Lowest allowed event number.  */
           else if (strcmp (long_options[option_index].name, "first-event-number") == 0)
           {
-          
-          
-            if (update_arg( (void *)&(args_info->first_event_number_arg), 
+
+
+            if (update_arg( (void *)&(args_info->first_event_number_arg),
                  &(args_info->first_event_number_orig), &(args_info->first_event_number_given),
                 &(local_args_info.first_event_number_given), optarg, 0, "-100000000", ARG_LONG,
                 check_ambiguity, override, 0, 0,
                 "first-event-number", '-',
                 additional_error))
               goto failure;
-          
+
           }
           /* Highest allowed event number.  */
           else if (strcmp (long_options[option_index].name, "last-event-number") == 0)
           {
-          
-          
-            if (update_arg( (void *)&(args_info->last_event_number_arg), 
+
+
+            if (update_arg( (void *)&(args_info->last_event_number_arg),
                  &(args_info->last_event_number_orig), &(args_info->last_event_number_given),
                 &(local_args_info.last_event_number_given), optarg, 0, "100000000", ARG_LONG,
                 check_ambiguity, override, 0, 0,
                 "last-event-number", '-',
                 additional_error))
               goto failure;
-          
+
           }
           /* Frequency of parsing information printouts.  */
           else if (strcmp (long_options[option_index].name, "print-every-events-parsed") == 0)
           {
-          
-          
-            if (update_arg( (void *)&(args_info->print_every_events_parsed_arg), 
+
+
+            if (update_arg( (void *)&(args_info->print_every_events_parsed_arg),
                  &(args_info->print_every_events_parsed_orig), &(args_info->print_every_events_parsed_given),
                 &(local_args_info.print_every_events_parsed_given), optarg, 0, "100", ARG_LONG,
                 check_ambiguity, override, 0, 0,
                 "print-every-events-parsed", '-',
                 additional_error))
               goto failure;
-          
+
           }
           /* Assume compressed input for expicitely specified formats. Requires linkage with zlib/lzma/bz2..  */
           else if (strcmp (long_options[option_index].name, "compressed-input") == 0)
           {
-          
-          
+
+
             if (update_arg((void *)&(args_info->compressed_input_flag), 0, &(args_info->compressed_input_given),
                 &(local_args_info.compressed_input_given), optarg, 0, 0, ARG_FLAG,
                 check_ambiguity, override, 1, 0, "compressed-input", '-',
                 additional_error))
               goto failure;
-          
+
           }
           /* Write compressed output for expicitely specified formats. Requires linkage with zlib/lzma/bz2..  */
           else if (strcmp (long_options[option_index].name, "compressed-output") == 0)
           {
-          
-          
-            if (update_arg( (void *)&(args_info->compressed_output_arg), 
+
+
+            if (update_arg( (void *)&(args_info->compressed_output_arg),
                  &(args_info->compressed_output_orig), &(args_info->compressed_output_given),
                 &(local_args_info.compressed_output_given), optarg, cmdline_parser_compressed_output_values, "plaintext", ARG_STRING,
                 check_ambiguity, override, 0, 0,
                 "compressed-output", '-',
                 additional_error))
               goto failure;
-          
+
           }
-          
+
           break;
         case '?':	/* Invalid option.  */
           /* `getopt_long' already printed an error message.  */
           goto failure;
 
         default:	/* bug: option not considered.  */
           fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
@@ -1717,15 +1740,15 @@
   update_multiple_arg((void *)&(args_info->extensions_arg),
     &(args_info->extensions_orig), args_info->extensions_given,
     local_args_info.extensions_given, 0,
     ARG_STRING, extensions_list);
 
   args_info->extensions_given += local_args_info.extensions_given;
   local_args_info.extensions_given = 0;
-  
+
   if (check_required)
     {
       error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
     }
 
   cmdline_parser_release (&local_args_info);
 
@@ -1748,12 +1771,12 @@
         args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind++]) ;
     }
 
   return 0;
 
 failure:
   free_list (extensions_list, 1 );
-  
+
   cmdline_parser_release (&local_args_info);
   return (EXIT_FAILURE);
 }
 /* vim: set ft=c noet ts=8 sts=8 sw=8 tw=80 nojs spell : */
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/cmdline.ggo` & `HepMC3-3.2.6/examples/ConvertExample/cmdline.ggo`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 version "3.2.5"
 package "convert_example"
 purpose "Convert between different file formats of Monte Carlo event record.
 Example:
         convert_example -i hepmc2 -o treeroot input.hepmc output.root
 "
-option "input-format" i "Input format" string required values= "hepmc2", "auto", "hepmc3", "hpe", "root", "treeroot", "lhef" ,  "uproot", "plugin"
-option "output-format" o "Output format" string required values="hepmc2", "hepmc3", "hpe" ,"root", "treeroot", "treerootopal", "hpezeus", "dump","plugin", "dot", "none"
+option "input-format" i "Input format" string required values= "hepmc2", "auto", "hepmc3", "hpe", "root", "treeroot", "lhef" ,  "uproot", "plugin", "proto"
+option "output-format" o "Output format" string required values="hepmc2", "hepmc3", "hpe" ,"root", "treeroot", "treerootopal", "hpezeus", "dump","plugin", "dot", "none", "proto"
 option "extensions" e "Extensions, in a form extension=value, could be passed to readers/writers" multiple optional string
+option "strict-read" -  "Exit in case of reading broken event." optional long default="0"
 option "events-limit" - "Limit of events to read from input" optional long default="100000000"
 option "first-event-number" -       "Lowest allowed event number" optional long default="-100000000"
 option "last-event-number" -        "Highest allowed event number" optional long default="100000000"
 option "print-every-events-parsed" - "Frequency of parsing information printouts" optional long default="100"
 option "compressed-input"        - "Assume compressed input for expicitely specified formats. Requires linkage with zlib/lzma/bz2."        flag       off
 option "compressed-output"        - "Write compressed output for expicitely specified formats. Requires linkage with zlib/lzma/bz2."  string optional values="z", "lzma", "bz2", "plaintext" default="plaintext"
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/cmdline.h` & `HepMC3-3.2.6/examples/ConvertExample/cmdline.h`

 * *Files 5% similar despite different names*

```diff
@@ -45,14 +45,17 @@
   char * output_format_orig;	/**< @brief Output format original value given at command line.  */
   const char *output_format_help; /**< @brief Output format help description.  */
   char ** extensions_arg;	/**< @brief Extensions, in a form extension=value, could be passed to readers/writers.  */
   char ** extensions_orig;	/**< @brief Extensions, in a form extension=value, could be passed to readers/writers original value given at command line.  */
   unsigned int extensions_min; /**< @brief Extensions, in a form extension=value, could be passed to readers/writers's minimum occurreces */
   unsigned int extensions_max; /**< @brief Extensions, in a form extension=value, could be passed to readers/writers's maximum occurreces */
   const char *extensions_help; /**< @brief Extensions, in a form extension=value, could be passed to readers/writers help description.  */
+  long strict_read_arg;	/**< @brief Exit in case of reading broken event. (default='0').  */
+  char * strict_read_orig;	/**< @brief Exit in case of reading broken event. original value given at command line.  */
+  const char *strict_read_help; /**< @brief Exit in case of reading broken event. help description.  */
   long events_limit_arg;	/**< @brief Limit of events to read from input (default='100000000').  */
   char * events_limit_orig;	/**< @brief Limit of events to read from input original value given at command line.  */
   const char *events_limit_help; /**< @brief Limit of events to read from input help description.  */
   long first_event_number_arg;	/**< @brief Lowest allowed event number (default='-100000000').  */
   char * first_event_number_orig;	/**< @brief Lowest allowed event number original value given at command line.  */
   const char *first_event_number_help; /**< @brief Lowest allowed event number help description.  */
   long last_event_number_arg;	/**< @brief Highest allowed event number (default='100000000').  */
@@ -62,19 +65,20 @@
   char * print_every_events_parsed_orig;	/**< @brief Frequency of parsing information printouts original value given at command line.  */
   const char *print_every_events_parsed_help; /**< @brief Frequency of parsing information printouts help description.  */
   int compressed_input_flag;	/**< @brief Assume compressed input for expicitely specified formats. Requires linkage with zlib/lzma/bz2. (default=off).  */
   const char *compressed_input_help; /**< @brief Assume compressed input for expicitely specified formats. Requires linkage with zlib/lzma/bz2. help description.  */
   char * compressed_output_arg;	/**< @brief Write compressed output for expicitely specified formats. Requires linkage with zlib/lzma/bz2. (default='plaintext').  */
   char * compressed_output_orig;	/**< @brief Write compressed output for expicitely specified formats. Requires linkage with zlib/lzma/bz2. original value given at command line.  */
   const char *compressed_output_help; /**< @brief Write compressed output for expicitely specified formats. Requires linkage with zlib/lzma/bz2. help description.  */
-  
+
   unsigned int help_given ;	/**< @brief Whether help was given.  */
   unsigned int input_format_given ;	/**< @brief Whether input-format was given.  */
   unsigned int output_format_given ;	/**< @brief Whether output-format was given.  */
   unsigned int extensions_given ;	/**< @brief Whether extensions was given.  */
+  unsigned int strict_read_given ;	/**< @brief Whether strict-read was given.  */
   unsigned int events_limit_given ;	/**< @brief Whether events-limit was given.  */
   unsigned int first_event_number_given ;	/**< @brief Whether first-event-number was given.  */
   unsigned int last_event_number_given ;	/**< @brief Whether last-event-number was given.  */
   unsigned int print_every_events_parsed_given ;	/**< @brief Whether print-every-events-parsed was given.  */
   unsigned int compressed_input_given ;	/**< @brief Whether compressed-input was given.  */
   unsigned int compressed_output_given ;	/**< @brief Whether compressed-output was given.  */
 
@@ -163,15 +167,15 @@
 void cmdline_parser_print_help(void);
 /**
  * Print the version
  */
 void cmdline_parser_print_version(void);
 
 /**
- * Initializes all the fields a cmdline_parser_params structure 
+ * Initializes all the fields a cmdline_parser_params structure
  * to their default values
  * @param params the structure to initialize
  */
 void cmdline_parser_params_init(struct cmdline_parser_params *params);
 
 /**
  * Allocates dynamically a cmdline_parser_params structure and initializes
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/convert_example.cc` & `HepMC3-3.2.6/examples/ConvertExample/convert_example.cc`

 * *Files 8% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /// @example convert_example.cc
 /// @brief Utility to convert between different types of event records
 ///
 #include "HepMC3/Print.h"
 #include "HepMC3/GenEvent.h"
 #include "HepMC3/Reader.h"
@@ -26,14 +26,18 @@
 #include "HepMC3/ReaderRootTree.h"
 #include "HepMC3/WriterRootTree.h"
 #endif
 #if HEPMC3_USE_COMPRESSION
 #include "HepMC3/ReaderGZ.h"
 #include "HepMC3/WriterGZ.h"
 #endif
+#ifdef HEPMC3_PROTOBUFIO
+#include "HepMC3/Readerprotobuf.h"
+#include "HepMC3/Writerprotobuf.h"
+#endif
 
 /* Extension example*/
 #ifdef HEPMCCONVERT_EXTENSION_ROOTTREEOPAL
 #ifndef HEPMC3_ROOTIO
 #warning "HEPMCCONVERT_EXTENSION_ROOTTREEOPAL requires  compilation with of HepMC with ROOT, i.e. HEPMC3_ROOTIO.This extension will be disabled."
 #undef HEPMCCONVERT_EXTENSION_ROOTTREEOPAL
 #else
@@ -49,15 +53,15 @@
 #ifdef HEPMCCONVERT_EXTENSION_UPROOTTREEREADER
 #include "ReaderuprootTree.h"
 #endif
 
 
 #include "cmdline.h"
 using namespace HepMC3;
-enum formats {autodetect, hepmc2, hepmc3, hpe,root, treeroot, treerootopal, hpezeus, lhef, dump, dot, uproot, plugin, none};
+enum formats {autodetect, hepmc2, hepmc3, hpe,root, treeroot, treerootopal, hpezeus, lhef, dump, dot, uproot, plugin, none, proto};
 
 template <class T>
 std::shared_ptr<Reader> get_input_file(const char* name, const bool input_is_stdin, const bool use_compression) {
     std::string n(name);
 #if  HEPMC3_USE_COMPRESSION
     if (use_compression) {
         return (input_is_stdin?std::make_shared<ReaderGZ<T> >(std::cin):std::make_shared<ReaderGZ<T> >(n));
@@ -99,21 +103,23 @@
     format_map.insert(std::pair<std::string,formats> ( "hpezeus", hpezeus ));
     format_map.insert(std::pair<std::string,formats> ( "lhef", lhef ));
     format_map.insert(std::pair<std::string,formats> ( "dump", dump ));
     format_map.insert(std::pair<std::string,formats> ( "dot", dot ));
     format_map.insert(std::pair<std::string,formats> ( "uproot", uproot ));
     format_map.insert(std::pair<std::string,formats> ( "plugin", plugin ));
     format_map.insert(std::pair<std::string,formats> ( "none", none ));
+    format_map.insert(std::pair<std::string,formats> ( "proto", proto ));
     std::map<std::string, std::string> options;
     for (size_t i=0; i<ai.extensions_given; i++)
     {
         std::string optarg=std::string(ai.extensions_arg[i]);
         size_t pos = optarg.find_first_of('=');
-        if ( pos < optarg.length() )
+        if ( pos < optarg.length() ) {
             options[std::string(optarg,0,pos)] = std::string(optarg, pos+1, optarg.length());
+        }
     }
     long int  events_parsed = 0;
     long int  events_limit = ai.events_limit_arg;
     long int  first_event_number = ai.first_event_number_arg;
     long int  last_event_number = ai.last_event_number_arg;
     long int  print_each_events_parsed = ai.print_every_events_parsed_arg;
     std::string InputPluginLibrary;
@@ -168,14 +174,22 @@
 #ifdef HEPMC3_ROOTIO
         input_file = std::make_shared<ReaderRoot>(ai.inputs[0]);
         break;
 #else
         printf("Input format %s  is not supported\n", ai.input_format_arg);
         exit(2);
 #endif
+    case proto:
+#ifdef HEPMC3_PROTOBUFIO
+        input_file = std::make_shared<Readerprotobuf>(ai.inputs[0]);
+        break;
+#else
+        printf("Input format %s  is not supported\n", ai.input_format_arg);
+        exit(2);
+#endif
     case plugin:
         if (options.find("InputPluginLibrary") == options.end())         {
             printf("InputPluginLibrary option required\n");
             exit(2);
         }
         else InputPluginLibrary = options.at("InputPluginLibrary");
         if (options.find("InputPluginName") == options.end())            {
@@ -210,14 +224,22 @@
 #ifdef HEPMC3_ROOTIO
         output_file = std::make_shared<WriterRoot>(ai.inputs[1]);
         break;
 #else
         printf("Output format %s  is not supported\n", ai.output_format_arg);
         exit(2);
 #endif
+    case proto:
+#ifdef HEPMC3_PROTOBUFIO
+        output_file = std::make_shared<Writerprotobuf>(ai.inputs[1]);
+        break;
+#else
+        printf("Output format %s  is not supported\n", ai.output_format_arg);
+        exit(2);
+#endif
     case treeroot:
 #ifdef HEPMC3_ROOTIO
         output_file = std::make_shared<WriterRootTree>(ai.inputs[1]);
         break;
 #else
         printf("Output format %s  is not supported\n",ai.output_format_arg);
         exit(2);
@@ -266,33 +288,38 @@
         output_file = std::make_shared<WriterPlugin>(std::string(ai.inputs[1]), OutputPluginLibrary, OutputPluginName);
         if (output_file->failed()) {
             printf("Plugin initialization failed\n");
             exit(2);
         }
         break;
     case dump:
-        output_file = NULL;
+        output_file = nullptr;
         break;
     case none:
-        output_file = NULL;
+        output_file = nullptr;
         ignore_writer = true;
         break;
     default:
         printf("Output format %s  is not known\n", ai.output_format_arg);
         exit(2);
         break;
     }
     while( !input_file->failed() )
     {
         GenEvent evt(Units::GEV, Units::MM);
-        input_file->read_event(evt);
+        bool res_read = input_file->read_event(evt);
+
         if( input_file->failed() )  {
             printf("End of file reached. Exit.\n");
             break;
         }
+        if ( !res_read && ai.strict_read_arg) {
+            printf("Broken event. Exit.\n");
+            exit(3);
+        }
         if (evt.event_number() < first_event_number) continue;
         if (evt.event_number() > last_event_number) continue;
         evt.set_run_info(input_file->run_info());
         //Note the difference between ROOT and Ascii readers. The former read GenRunInfo before first event and the later at the same time as first event.
         if (!ignore_writer)
         {
             if (output_file)
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/include/AnalysisExample.h` & `HepMC3-3.2.6/examples/ConvertExample/include/AnalysisExample.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,7 +1,12 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #ifndef HEPMC3_ANALYSISEXAMPLE_H
 #define HEPMC3_ANALYSISEXAMPLE_H
 ///
 /// @file  AnalysisExample.h
 /// @brief Definition of class \b AnalysisExample
 ///
 /// @class HepMC3::AnalysisExample
@@ -41,11 +46,11 @@
     double m_sum_of_weights=0;  //!< Sum of event weights
     double m_sum_of_weights2=0; //!< Sum of event weights**2
     std::map<std::string, std::vector<double> > m_bins;  //!< Binings
     std::map<std::string, std::vector<double> > m_vals;  //!< Values
     std::map<std::string, std::vector<double> > m_errs;  //!< Uncertainties
 private:
     std::ofstream m_file; //!< Output file
-    std::ostream* m_stream; //!< Output stream
+    std::ostream* m_stream=nullptr; //!< Output stream
 };
 }
 #endif
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/include/ReaderuprootTree.h` & `HepMC3-3.2.6/examples/ConvertExample/include/ReaderuprootTree.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,22 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #ifndef READERUPROOTTREE_H
 #define READERUPROOTTREE_H
 #include "HepMC3/GenEvent.h"
 #include "HepMC3/FourVector.h"
 #include "HepMC3/Print.h"
 #include "HepMC3/Reader.h"
 #include "HepMC3/Data/GenEventData.h"
 #include "HepMC3/Data/GenRunInfoData.h"
 #include <iostream>
+#include <array>
 #include "HepMC3/Units.h"
 #include "HepMC3/Version.h"
 #include "Python.h"
 #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
 #include "numpy/arrayobject.h"
 
 namespace HepMC3
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/include/WriterDOT.h` & `HepMC3-3.2.6/include/HepMC3/WriterGZ.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,56 +1,66 @@
-#ifndef HEPMC3_WRITERDOT_H
-#define HEPMC3_WRITERDOT_H
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
+#ifndef HEPMC3_WRITERGZ_H
+#define HEPMC3_WRITERGZ_H
 ///
-/// @file  WriterDOT.h
-/// @brief Definition of class \b WriterDOT
+/// @file  WriterGZ.h
+/// @brief Definition of class \b WriterGZ
 ///
-/// @class HepMC3::WriterDOT
-/// @brief GenEvent I/O output to dot files that should be processed by graphviz or other software
+/// @class HepMC3::WriterGZ
+/// @brief GenEvent I/O serialization for compressed files
 ///
-/// @ingroup Examples
+/// @ingroup IO
 ///
 #include <string>
 #include <fstream>
 #include "HepMC3/Writer.h"
 #include "HepMC3/GenEvent.h"
-#include "HepMC3/GenParticle.h"
-#include "HepMC3/GenVertex.h"
-#include "HepMC3/Data/GenEventData.h"
-namespace HepMC3
-{
-class WriterDOT : public Writer
-{
+#include "HepMC3/GenRunInfo.h"
+#include "HepMC3/CompressedIO.h"
+namespace HepMC3 {
+
+template <class T, Compression C = Compression::z> class WriterGZ : public Writer  {
 public:
+
     /// @brief Constructor
     /// @warning If file already exists, it will be cleared before writing
-    WriterDOT(const std::string &filename,std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>());
+    WriterGZ(const std::string& filename, std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>()) {
+        m_zstr = std::shared_ptr< std::ostream >(new ofstream(filename.c_str(), C));
+        m_writer = std::make_shared<T>(*(m_zstr.get()), run);
+    }
+
     /// @brief Constructor from ostream
-    WriterDOT(std::ostream& stream,std::shared_ptr<GenRunInfo> run =std:: shared_ptr<GenRunInfo>());
+    WriterGZ(std::ostream& stream, std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>()) {
+        m_zstr = std::shared_ptr< std::ostream >(new ostream(stream, C));
+        m_writer = std::make_shared<T>(*(m_zstr.get()), run);
+    }
+
+    /// @brief Destructor
+    ~WriterGZ() {};
+
     /// @brief Write event to file
     ///
     /// @param[in] evt Event to be serialized
-    void write_event(const GenEvent &evt);
+    void write_event(const GenEvent& evt) override { if (m_writer) m_writer->write_event(evt); };
+
     /// @brief Return status of the stream
-    bool failed() {
-        return (bool)m_file.rdstate();
-    }
-    /// @brief Close file stream
-    void close();
+    bool failed() override { if (m_writer) return  m_writer->failed(); return true; };
+
     /// @brief Close file stream
-    void set_style(const int& istyle) {
-        m_style=istyle;
-    };
+    void close() override {
+        if (m_writer)  m_writer->close();
+        m_zstr->flush();
+        if(dynamic_pointer_cast<ofstream>(m_zstr)) dynamic_pointer_cast<ofstream>(m_zstr)->close();
+    }
 
 private:
-    void allocate_buffer(); //!< allocates buffer for output
-    void flush(); //!< flushes output buffer
-    void forced_flush(); //!< flushes output buffer
-    std::ofstream m_file; //!< Output file
-    std::ostream* m_stream; //!< Output stream
-    int m_style; //!< style of dot file
-    char* m_buffer;  //!< Stream buffer
-    char* m_cursor;  //!< Cursor inside stream buffer
-    unsigned long m_buffer_size; //!< Buffer size
+    std::shared_ptr< std::ostream > m_zstr;  ///< Stream to write
+    std::shared_ptr<Writer> m_writer; //!< actual writter
+
 };
-}
+
+} // namespace HepMC3
 #endif
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/include/WriterHEPEVTZEUS.h` & `HepMC3-3.2.6/examples/ConvertExample/include/WriterHEPEVTZEUS.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,7 +1,12 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #ifndef HEPMC3_WRITERHEPEVTZEUS_H
 #define HEPMC3_WRITERHEPEVTZEUS_H
 ///
 /// @file  WriterHEPEVTZEUS.h
 /// @brief Definition of class \b WriterHEPEVTZEUS
 ///
 /// @class HepMC3::WriterHEPEVTZEUS
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/include/WriterRootTreeOPAL.h` & `HepMC3-3.2.6/examples/ConvertExample/include/WriterRootTreeOPAL.h`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,12 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #ifndef HEPMC3_WRITERROOTTREEOPAL_H
 #define HEPMC3_WRITERROOTTREEOPAL_H
 ///
 /// @file  WriterRootTreeOPAL.h
 /// @brief Definition of class \b WriterRootTreeOPAL
 ///
 /// @class HepMC3::WriterRootTreeOPAL
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/src/AnalysisExample.cc` & `HepMC3-3.2.6/examples/ConvertExample/src/AnalysisExample.cc`

 * *Files 15% similar despite different names*

```diff
@@ -1,7 +1,12 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #include "AnalysisExample.h"
 #include <limits>
 namespace HepMC3
 {
 HEPMC3_DECLARE_WRITER_FILE(AnalysisExample)
 HEPMC3_DECLARE_WRITER_STREAM(AnalysisExample)
 
@@ -14,17 +19,16 @@
     m_sum_of_weights=0;
     m_sum_of_weights2=0;
     m_bins["rapidity"]=std::vector<double> {-std::numeric_limits<double>::infinity(), -5.0,-4.5,-4.0,-3.5,-3.0,-2.5,-2.0,-1.5,-1.0,-0.5,0.0,0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,std::numeric_limits<double>::infinity()};
     m_vals["rapidity"]=std::vector<double>(m_bins.at("rapidity").size()-1,0.0);
     m_errs["rapidity"]=std::vector<double>(m_bins.at("rapidity").size()-1,0.0);
 }
 
-AnalysisExample::AnalysisExample(std::ostream &stream, std::shared_ptr<GenRunInfo> run)
-    : m_file(),
-      m_stream(&stream)
+AnalysisExample::AnalysisExample(std::ostream &stream, std::shared_ptr<GenRunInfo> /*run*/)
+    : m_stream(&stream)
 {
     m_sum_of_weights=0;
     m_sum_of_weights2=0;
     m_bins["rapidity"]=std::vector<double> {-std::numeric_limits<double>::infinity(), -5.0,-4.5,-4.0,-3.5,-3.0,-2.5,-2.0,-1.5,-1.0,-0.5,0.0,0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,std::numeric_limits<double>::infinity()};
     m_vals["rapidity"]=std::vector<double>(m_bins.at("rapidity").size()-1,0.0);
     m_errs["rapidity"]=std::vector<double>(m_bins.at("rapidity").size()-1,0.0);
 
@@ -44,15 +48,15 @@
         m_vals["rapidity"][bin]+=w;
         m_errs["rapidity"][bin]+=w*w;
     }
 }
 
 void AnalysisExample::close() {
     if (!m_stream) return;
-    std::ofstream* ofs = dynamic_cast<std::ofstream*>(m_stream);
+    auto* ofs = dynamic_cast<std::ofstream*>(m_stream);
     for (size_t i=1; i<m_vals["rapidity"].size()-1; i++)
     {
         double val=m_vals["rapidity"][i]/m_sum_of_weights/(m_bins["rapidity"][i+1]-m_bins["rapidity"][i]);
         double err=sqrt(m_errs["rapidity"][i])/m_sum_of_weights/(m_bins["rapidity"][i+1]-m_bins["rapidity"][i]);
         (*ofs)<< std::fixed  << std::setprecision( 6 )<<m_bins["rapidity"][i]<<" "<<m_bins["rapidity"][i+1]<<" "<<val<<" "<<err<<std::endl;
     }
     if (ofs && !ofs->is_open()) return;
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/src/ReaderuprootTree.cc` & `HepMC3-3.2.6/examples/ConvertExample/src/ReaderuprootTree.cc`

 * *Files 5% similar despite different names*

```diff
@@ -1,7 +1,12 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #include "ReaderuprootTree.h"
 namespace HepMC3
 {
 
 HEPMC3_DECLARE_READER_FILE(ReaderuprootTree)
 
 /// @brief obtain vector of objects using name and type
@@ -11,15 +16,15 @@
     PyObject *pFunc = m_access_function;
     PyObject * pArgs = PyTuple_New(4);
     PyTuple_SetItem(pArgs, 0, file_name);
     PyTuple_SetItem(pArgs, 1, Py_BuildValue("s#", array_name.c_str(), array_name.length()));
     PyTuple_SetItem(pArgs, 2, Py_BuildValue("i", i));
     PyTuple_SetItem(pArgs, 3, Py_BuildValue("s#", desired_type.c_str(), desired_type.length()));
     PyObject *pReturn = PyObject_CallObject(pFunc, pArgs);
-    PyArrayObject *np_ret = reinterpret_cast<PyArrayObject*>(pReturn);
+    auto *np_ret = reinterpret_cast<PyArrayObject*>(pReturn);
     std::vector<T> out;
     int len0 = 0;
     if (np_ret) len0 = PyArray_SHAPE(np_ret)[0];
     if (len0 > 0) {
         int len = PyArray_SHAPE(np_ret)[1];
         T*  c_out = reinterpret_cast<T*>(PyArray_DATA(np_ret));
         for (int i = 0; i < len; i++) out.push_back(c_out[i]);
@@ -39,22 +44,22 @@
     PyObject * pArgs = PyTuple_New(4);
     PyTuple_SetItem(pArgs, 0, file_name);
     PyTuple_SetItem(pArgs, 1, Py_BuildValue("s#", array_name.c_str(), array_name.length()));
     PyTuple_SetItem(pArgs, 2, Py_BuildValue("i", i));
     PyTuple_SetItem(pArgs, 3, Py_BuildValue("s#", desired_type.c_str(), desired_type.length()));
 
     PyObject *pReturn = PyObject_CallObject(pFunc, pArgs);
-    PyArrayObject *np_ret = reinterpret_cast<PyArrayObject*>(pReturn);
+    auto *np_ret = reinterpret_cast<PyArrayObject*>(pReturn);
     std::vector<std::string> out;
     int len0 = 0;
     if (np_ret) len0 = PyArray_SHAPE(np_ret)[0];
     if (len0>0) {
         int len = PyArray_SHAPE(np_ret)[1];
-        typedef wchar_t wc500[500];
-        wc500* c_out = reinterpret_cast<wc500*>(PyArray_DATA(np_ret));
+        using  wc500 = wchar_t[500];
+        auto* c_out = reinterpret_cast<wc500*>(PyArray_DATA(np_ret));
 
         for (int i = 0; i < len; i++) {
             std::wstring wa((c_out[i]));
             std::string ret(wa.begin(), wa.end() );
             out.push_back(ret);
         }
     }
@@ -86,38 +91,35 @@
     PyObject *builtins = PyEval_GetBuiltins();
     PyDict_SetItemString(localDict, "__builtins__", builtins);
 
     PyObject *pyValue = PyRun_String(SomeModuleCode, Py_file_input, localDict, localDict);
     if (pyValue == nullptr) {
         return nullptr;
     }
-    else
-    {
-        Py_DECREF(pyValue);
-    }
+    Py_DECREF(pyValue);
     return m_python_module;
 }
 
 ReaderuprootTree::ReaderuprootTree(const std::string &filename,const std::string &treename,const std::string &branchname):
-    m_events_count(0),m_tree_name(treename.c_str()), m_branch_name(branchname.c_str()),m_tree(nullptr)
+    m_events_count(0),m_tree_name(treename), m_branch_name(branchname),m_tree(nullptr)
 {
     if (!init(filename)) return;
 }
 
 bool ReaderuprootTree::init(const std::string &filename)
 {
 
     m_event_data = new GenEventData();
 
     m_run_info_data = new GenRunInfoData();
 
     set_run_info(std::make_shared<GenRunInfo>());
 
     Py_Initialize();
-    import_array()
+    import_array();
 
     m_python_module = init_python_module(
 
                           R"EOT(
 import uproot
 import numpy
 def init_file(filename):
@@ -213,16 +215,15 @@
     Py_DECREF(pArgsFile);
     return result;
 }
 
 bool ReaderuprootTree::skip(const int n)
 {
     m_events_count+=n;
-    if (m_events_count>m_tree_getEntries) return false;
-    return true;
+    return m_events_count <= m_tree_getEntries;
 }
 
 
 
 bool ReaderuprootTree::read_event(GenEvent& evt)
 {
     if (!m_python_module) return false;
@@ -232,28 +233,28 @@
     m_event_data->links1.clear();
     m_event_data->links2.clear();
     m_event_data->attribute_id.clear();
     m_event_data->attribute_name.clear();
     m_event_data->attribute_string.clear();
 
     auto event_number_v  = get_vector<int>(m_tree, "event_number");
-    if (event_number_v.size() == 0) { m_events_count++; return false;}
+    if (event_number_v.empty()) { m_events_count++; return false;}
     auto weights = get_vector<double>(m_tree, "weights");
     auto event_pos_1_v = get_vector<double>(m_tree, "event_pos/event_pos.m_v1");
-    if (event_pos_1_v.size() == 0) { m_events_count++; return false;}
+    if (event_pos_1_v.empty()) { m_events_count++; return false;}
     auto event_pos_2_v = get_vector<double>(m_tree,"event_pos/event_pos.m_v2");
-    if (event_pos_2_v.size() == 0) { m_events_count++; return false;}
+    if (event_pos_2_v.empty()) { m_events_count++; return false;}
     auto event_pos_3_v = get_vector<double>(m_tree, "event_pos/event_pos.m_v3");
-    if (event_pos_3_v.size() == 0) { m_events_count++; return false;}
+    if (event_pos_3_v.empty()) { m_events_count++; return false;}
     auto event_pos_4_v = get_vector<double>(m_tree, "event_pos/event_pos.m_v4");
-    if (event_pos_4_v.size() == 0) { m_events_count++; return false;}
+    if (event_pos_4_v.empty()) { m_events_count++; return false;}
     auto momentum_unit_v = get_vector<int>(m_tree, "momentum_unit");
-    if (momentum_unit_v.size() == 0) { m_events_count++; return false;}
+    if (momentum_unit_v.empty()) { m_events_count++; return false;}
     auto length_unit_v = get_vector<int>(m_tree, "length_unit");
-    if (length_unit_v.size() == 0) { m_events_count++; return false;}
+    if (length_unit_v.empty()) { m_events_count++; return false;}
 
     auto event_number    = event_number_v.at(0);
     auto event_pos_1     = event_pos_1_v.at(0);
     auto event_pos_2     = event_pos_2_v.at(0);
     auto event_pos_3     = event_pos_3_v.at(0);
     auto event_pos_4     = event_pos_4_v.at(0);
     auto momentum_unit   = momentum_unit_v.at(0);
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/src/WriterDOT.cc` & `HepMC3-3.2.6/examples/ConvertExample/src/WriterDOT.cc`

 * *Files 10% similar despite different names*

```diff
@@ -1,7 +1,12 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #include "WriterDOT.h"
 namespace HepMC3
 {
 WriterDOT::WriterDOT(const std::string &filename,std::shared_ptr<GenRunInfo> /*run*/): m_file(filename),
     m_stream(&m_file),
     m_style(0),
     m_buffer(nullptr),
@@ -10,25 +15,24 @@
 {
     if ( !m_file.is_open() ) {
         HEPMC3_ERROR( "WriterDOT: could not open output file: "<<filename )
     }
 }
 
 WriterDOT::WriterDOT(std::ostream &stream, std::shared_ptr<GenRunInfo> /*run*/)
-    : m_file(),
-      m_stream(&stream),
+    : m_stream(&stream),
       m_style(0),
       m_buffer(nullptr),
       m_cursor(nullptr),
       m_buffer_size( 256*1024 )
 {}
 
 
 void WriterDOT::close() {
-    std::ofstream* ofs = dynamic_cast<std::ofstream*>(m_stream);
+    auto* ofs = dynamic_cast<std::ofstream*>(m_stream);
     if (ofs && !ofs->is_open()) return;
     forced_flush();
     if (ofs) ofs->close();
 }
 /// @brief Detects if particle is parton. Might be used to draw partons different from hadrons
 bool is_parton(const int& pd )
 {
@@ -36,31 +40,31 @@
 
     if (pd==81||pd==82||pd<25) parton=true;
     if (
         (pd/1000==1||pd/1000==2||pd/1000==3||pd/1000==4||pd/1000==5)
         &&(pd%1000/100==1||pd%1000/100==2||pd%1000/100==3||pd%1000/100==4)
         &&(pd%100==1||pd%100==3)
     )
-        parton = true;
+    { parton = true;}
     return parton;
 }
 void WriterDOT::write_event(const GenEvent &evt)
 {
     allocate_buffer();
     if ( !m_buffer ) return;
     flush();
     m_cursor += sprintf(m_cursor, "digraph graphname%d {\n",evt.event_number());
     m_cursor += sprintf(m_cursor, "v0[label=\"Machine\"];\n");
     for(auto v: evt.vertices() ) {
         if (m_style != 0)
         {
             if (m_style == 1) //paint decay and fragmentation vertices in green
             {
-                if (v->status() == 2) m_cursor += sprintf(m_cursor, "node [color=\"green\"];\n");
-                else  m_cursor += sprintf(m_cursor, "node [color=\"black\"];\n");
+                if (v->status() == 2) {m_cursor += sprintf(m_cursor, "node [color=\"green\"];\n");}
+                else  {m_cursor += sprintf(m_cursor, "node [color=\"black\"];\n");}
             }
         }
         m_cursor += sprintf(m_cursor, "node [shape=ellipse];\n");
         m_cursor += sprintf(m_cursor, "v%d[label=\"%d\"];\n", -v->id(),v->id());
         flush();
     }
     for(auto p: evt.beams() ) {
@@ -72,16 +76,16 @@
     for(auto v: evt.vertices() ) {
         for(auto p: v->particles_out() ) {
             {
                 if (m_style != 0)
                 {
                     if (m_style == 1) //paint suspected partons and 81/82 in red
                     {
-                        if (is_parton(std::abs(p->pid()))&&p->status()!=1) m_cursor += sprintf(m_cursor, "edge [color=\"red\"];\n");
-                        else        m_cursor +=sprintf(m_cursor, "edge [color=\"black\"];\n");
+                        if (is_parton(std::abs(p->pid()))&&p->status()!=1) {m_cursor += sprintf(m_cursor, "edge [color=\"red\"];\n");}
+                        else      {  m_cursor +=sprintf(m_cursor, "edge [color=\"black\"];\n");}
                     }
                 }
                 if (!p->end_vertex())
                 {
                     m_cursor += sprintf(m_cursor, "node [shape=point];\n");
                     m_cursor += sprintf(m_cursor, "v%d -> o%d [label=\"%d(%d)\"];\n", -v->id(), p->id(), p->id(), p->pid());
                     flush();
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/src/WriterHEPEVTZEUS.cc` & `HepMC3-3.2.6/examples/ConvertExample/src/WriterHEPEVTZEUS.cc`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,31 @@
+// -*- C++ -*-
+//
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #include "WriterHEPEVTZEUS.h"
 #include "HepMC3/HEPEVT_Wrapper.h"
+#include <array>
 namespace HepMC3
 {
 WriterHEPEVTZEUS::WriterHEPEVTZEUS(const std::string &filename):WriterHEPEVT(filename) {}
 void WriterHEPEVTZEUS::write_hepevt_event_header()
 {
-    char buf[512];//Note: the format is fixed, so no reason for complicatied tratment
-    char* cursor = &(buf[0]);
+    std::array<char,512> buf;//Note: the format is fixed, so no reason for complicatied tratment
+    char* cursor = buf.data();
     cursor += sprintf(cursor, " E % 12i% 12i% 12i\n", m_hepevt_interface.event_number(), 0, m_hepevt_interface.number_entries());
-    unsigned long length = cursor - &(buf[0]);
-    m_stream->write( buf, length );
+    m_stream->write( buf.data(), cursor - buf.data());
 }
 void WriterHEPEVTZEUS::write_hepevt_particle( int index, bool iflong)
 {
     if (!iflong) printf("INFO: the parameter is ignored as HEPEVTZEUS always uses long format\n");
-    char buf[512];//Note: the format is fixed, so no reason for complicatied tratment
-    char* cursor = &(buf[0]);
+    std::array<char,512> buf;//Note: the format is fixed, so no reason for complicatied tratment
+    char* cursor = buf.data();
     cursor += sprintf(cursor,"% 12i% 8i", m_hepevt_interface.status(index), m_hepevt_interface.id(index));
     cursor += sprintf(cursor,"% 8i% 8i", m_hepevt_interface.first_parent(index), m_hepevt_interface.last_parent(index));
     cursor += sprintf(cursor,"% 8i% 8i", m_hepevt_interface.first_child(index), m_hepevt_interface.last_child(index));
     cursor += sprintf(cursor,      "% 19.11E% 19.11E% 19.11E% 19.11E% 19.11E\n", m_hepevt_interface.px(index), m_hepevt_interface.py(index), m_hepevt_interface.pz(index), m_hepevt_interface.e(index), m_hepevt_interface.m(index));
     cursor += sprintf(cursor, "%-52s% 19.11E% 19.11E% 19.11E% 19.11E% 19.11E\n", " ", m_hepevt_interface.x(index), m_hepevt_interface.y(index), m_hepevt_interface.z(index), m_hepevt_interface.t(index), 0.0);
-    std::ptrdiff_t length = cursor - &(buf[0]);
-    m_stream->write( buf, length );
+    m_stream->write( buf.data(), cursor - buf.data() );
 }
 }// namespace HepMC3
```

### Comparing `HepMC3-3.2.5/examples/ConvertExample/src/WriterRootTreeOPAL.cc` & `HepMC3-3.2.6/examples/ConvertExample/src/WriterRootTreeOPAL.cc`

 * *Files 18% similar despite different names*

```diff
@@ -1,9 +1,12 @@
 // -*- C++ -*-
 //
+// This file is part of HepMC
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
+//
 #include "WriterRootTreeOPAL.h"
 #include "TTree.h"
 namespace HepMC3
 {
 WriterRootTreeOPAL::WriterRootTreeOPAL(const std::string &filename,std::shared_ptr<GenRunInfo> run):WriterRootTree::WriterRootTree(filename,"h10","h10",run) {}
 void WriterRootTreeOPAL::init_branches()
 {
@@ -11,19 +14,20 @@
     m_tree->Branch("Ievnt", &m_Ievnt);
     m_tree->Branch("Ebeam",&m_Ebeam);
 }
 void WriterRootTreeOPAL::write_event(const GenEvent &evt)
 {
     m_Ievnt=evt.event_number();
     std::vector<size_t> beams;
-    for (size_t i=0; i<evt.particles().size(); i++)
+    for (size_t i=0; i<evt.particles().size(); i++) {
         if (evt.particles().at(i)->status()==4&&std::abs(evt.particles().at(i)->pid())==11)
-            beams.push_back(i);
-
-    if (beams.size()==2)
+        { beams.push_back(i);}
+    }
+    if (beams.size()==2) {
         m_Ebeam=std::abs(evt.particles().at(beams[0])->momentum().e());
-    else
+    } else {
         m_Ebeam=std::abs(evt.particles().at(0)->momentum().e());
+    }
     WriterRootTree::write_event(evt);
 }
 void WriterRootTreeOPAL::set_run_number(const int nr) {m_Irun=nr;}
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/examples/LHEFExample/CMakeLists.txt` & `HepMC3-3.2.6/examples/LHEFExample/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example.lhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example.lhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_1.plhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_1.plhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_1_cmp.plhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_1_cmp.plhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_1_out.plhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_1_out.plhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_2.plhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_2.plhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_2_cmp.plhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_2_cmp.plhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_2_out.plhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_2_out.plhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_cat.cc` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_cat.cc`

 * *Files 4% similar despite different names*

```diff
@@ -36,18 +36,18 @@
     runinfo->add_attribute("NPRUP",
                            std::make_shared<FloatAttribute>(hepr->heprup.NPRUP));
 
     // We want to be able to convey the different event weights to
     // HepMC. In particular we need to add the names of the weights to
     // the GenRunInfo object.
     std::vector<std::string> weightnames;
-    weightnames.push_back("0"); // The first weight is always the
+    weightnames.emplace_back("0"); // The first weight is always the
                                 // default weight with name "0".
-    for ( int i = 0, N = hepr->heprup.weightinfo.size(); i < N; ++i )
-        weightnames.push_back(hepr->heprup.weightNameHepMC(i));
+    for ( int i = 0, N = hepr->heprup.weightinfo.size(); i < N; ++i ){
+        weightnames.push_back(hepr->heprup.weightNameHepMC(i));}
     runinfo->set_weight_names(weightnames);
 
     // We also want to convey the information about which generators was
     // used to HepMC.
     for ( int i = 0, N = hepr->heprup.generators.size(); i < N; ++i ) {
         GenRunInfo::ToolInfo tool;
         tool.name =  hepr->heprup.generators[i].name;
@@ -64,16 +64,17 @@
         ++neve;
 
         // To each GenEvent we want to add an attribute corresponding to
         // the HEPEUP. Also here there may be additional non-standard
         // information outside the LHEF <event> tags, which we may want to
         // add.
         std::shared_ptr<HEPEUPAttribute> hepe = std::make_shared<HEPEUPAttribute>();
-        if ( reader.outsideBlock.length() )
+        if ( reader.outsideBlock.length() ){
             hepe->tags = LHEF:: XMLTag::findXMLTags(reader.outsideBlock);
+		}
         hepe->hepeup = reader.hepeup;
         GenEvent ev(runinfo, Units::GEV, Units::MM);
         ev.set_event_number(neve);
 
         // This is just a text to check that we can add additional
         // attributes to each event.
         ev.add_attribute("HEPEUP", hepe);
@@ -90,29 +91,30 @@
         std::vector<GenParticlePtr> particles;
         std::map< std::pair<int,int>, GenVertexPtr> vertices;
         for ( int i = 0; i < hepe->hepeup.NUP; ++i )
         {
             particles.push_back(std::make_shared<GenParticle>(hepe->momentum(i),hepe->hepeup.IDUP[i],hepe->hepeup.ISTUP[i]));
             if (i<2) continue;
             std::pair<int,int> vertex_index(hepe->hepeup.MOTHUP[i].first,hepe->hepeup.MOTHUP[i].second);
-            if (vertices.find(vertex_index)==vertices.end())vertices[vertex_index]=std::make_shared<GenVertex>();
+            if (vertices.find(vertex_index)==vertices.end()) {vertices[vertex_index]=std::make_shared<GenVertex>();}
             vertices[vertex_index]->add_particle_out(particles.back());
         }
         for ( auto v: vertices )
         {
             std::pair<int,int> vertex_index=v.first;
             GenVertexPtr          vertex=v.second;
-            for (int i=vertex_index.first-1; i<vertex_index.second; i++) if (i>=0&&i<(int)particles.size()) vertex->add_particle_in(particles[i]);
+            for (int i=vertex_index.first-1; i<vertex_index.second; i++) {if (i>=0&&i<(int)particles.size()) vertex->add_particle_in(particles[i]);}
         }
-        for ( auto v: vertices ) ev.add_vertex(v.second);
+        for ( auto v: vertices ) {ev.add_vertex(v.second);}
 
         // And we also want to add the weights.
         std::vector<double> wts;
-        for ( int i = 0, N = hepe->hepeup.weights.size(); i < N; ++i )
+        for ( int i = 0, N = hepe->hepeup.weights.size(); i < N; ++i ){
             wts.push_back(hepe->hepeup.weights[i].first);
+		}
         ev.weights() = wts;
 
         // Let's see if we can associate p1 and p2.
         ev.add_attribute("OtherIncoming",
                          std::make_shared<AssociatedParticle>(particles[1]), particles[0]->id());
 
 
@@ -149,45 +151,45 @@
         // For the first event we also go in and reconstruct the HEPRUP
         // information, and write it out to the new LHE file.
         if ( !hepr ) {
             hepr = ev.attribute<HEPRUPAttribute>("HEPRUP");
 
             // Here we also keep track of the additional non-standard info
             // we found in the original LHE file.
-            for ( int i = 0, N = hepr->tags.size(); i < N; ++i )
-                if ( hepr->tags[i]->name != "init" )
+            for ( int i = 0, N = hepr->tags.size(); i < N; ++i ){
+                if ( hepr->tags[i]->name != "init" ){
                     hepr->tags[i]->print(writer.headerBlock());
-
+				}
+}
             // This is just a test that we can access other attributes
             // included in the GenRunInfo.
             hepr->heprup.NPRUP =
-                int(input.run_info()->
-                    attribute<FloatAttribute>("NPRUP")->value());
+                int(input.run_info()->attribute<FloatAttribute>("NPRUP")->value());
 
             // Then we write out the HEPRUP object.
             writer.heprup = hepr->heprup;
             if ( writer.heprup.eventfiles.size() >= 2 ) {
               writer.heprup.eventfiles[0].filename = "LHEF_example_1_out.plhe";
               writer.heprup.eventfiles[1].filename = "LHEF_example_2_out.plhe";
             }
             writer.init();
 
         }
 
         // Now we can access the HEPEUP attribute of the current event.
-        std::shared_ptr<HEPEUPAttribute> hepe =
-            ev.attribute<HEPEUPAttribute>("HEPEUP");
+        std::shared_ptr<HEPEUPAttribute> hepe = ev.attribute<HEPEUPAttribute>("HEPEUP");
 
         // Again, there may be addisional non-standard information we want
         // to keep.
-        for ( int i = 0, N = hepe->tags.size(); i < N; ++i )
+        for ( int i = 0, N = hepe->tags.size(); i < N; ++i ){
             if ( hepe->tags[i]->name != "event" &&
-                 hepe->tags[i]->name != "eventgroup" )
+                 hepe->tags[i]->name != "eventgroup" ){
                 hepe->tags[i]->print(writer.eventComments());
-
+}
+}
         // This is just a test that we can access other attributes
         // included in the GenRunInfo.
         hepe->hepeup.AQCDUP =
             ev.attribute<DoubleAttribute>("AlphaQCD")->value();
         hepe->hepeup.AQEDUP =
             ev.attribute<DoubleAttribute>("AlphaEM")->value();
         hepe->hepeup.NUP =
```

### Comparing `HepMC3-3.2.5/examples/LHEFExample/LHEF_example_cmp.lhe` & `HepMC3-3.2.6/examples/LHEFExample/LHEF_example_cmp.lhe`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/Pythia6Example/CMakeLists.txt` & `HepMC3-3.2.6/examples/Pythia6Example/CMakeLists.txt`

 * *Files 27% similar despite different names*

```diff
@@ -1,16 +1,22 @@
 if (USE_INSTALLED_HEPMC3)
   include_directories(${HEPMC3_INCLUDE_DIR} ${HEPMC3_INTERFACES_DIR}/pythia6/include/Pythia6/)
   set (ptoh3 ${HEPMC3_INTERFACES_DIR}/pythia6/include/Pythia6/Pythia6ToHepMC3.cc)
+  if (NOT HEPMC3_INTERFACES_DIR)
+    message(STATUS "HepMC3 Examples: The used installation of HepMC3 does not have interfaces installed. Follow the documentation to install the interfaces.")
+    message(STATUS "HepMC3 Examples: Pythia6Example will be disabled.")
+  endif()
 else()
   include_directories(${PROJECT_SOURCE_DIR}/include  ${PROJECT_SOURCE_DIR}/interfaces/pythia6/include/Pythia6/)
   set (ptoh3 ${PROJECT_SOURCE_DIR}/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.cc)
 endif()
-add_executable(pythia6_example.exe ${CMAKE_CURRENT_SOURCE_DIR}/main63.f ${CMAKE_CURRENT_SOURCE_DIR}/pythia-6.4.28.f ${ptoh3})
-LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../outputs/lib64/  ${CMAKE_CURRENT_SOURCE_DIR}/../outputs/lib/ )
-target_link_libraries(pythia6_example.exe ${HEPMC3_LIB})
-target_compile_definitions(pythia6_example.exe PRIVATE PYTHIA6HEPEVTSIZE=4000)
-set_target_properties(pythia6_example.exe PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_BINDIR})
-set_target_properties(pythia6_example.exe PROPERTIES LINKER_LANGUAGE Fortran)
-if (USE_INSTALLED_HEPMC3)
-  install(TARGETS pythia6_example.exe DESTINATION ${CMAKE_INSTALL_BINDIR})
+if ( (USE_INSTALLED_HEPMC3 AND HEPMC3_INTERFACES_DIR) OR (NOT  USE_INSTALLED_HEPMC3) )
+  add_executable(pythia6_example.exe ${CMAKE_CURRENT_SOURCE_DIR}/main63.f ${CMAKE_CURRENT_SOURCE_DIR}/pythia-6.4.28.f ${ptoh3})
+  LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../outputs/lib64/  ${CMAKE_CURRENT_SOURCE_DIR}/../outputs/lib/ )
+  target_link_libraries(pythia6_example.exe ${HEPMC3_LIB})
+  target_compile_definitions(pythia6_example.exe PRIVATE PYTHIA6HEPEVTSIZE=4000)
+  set_target_properties(pythia6_example.exe PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_BINDIR})
+  set_target_properties(pythia6_example.exe PROPERTIES LINKER_LANGUAGE Fortran)
+  if (USE_INSTALLED_HEPMC3)
+    install(TARGETS pythia6_example.exe DESTINATION ${CMAKE_INSTALL_BINDIR})
+  endif()
 endif()
```

### Comparing `HepMC3-3.2.5/examples/Pythia6Example/main63.f` & `HepMC3-3.2.6/examples/Pythia6Example/main63.f`

 * *Files 0% similar despite different names*

```diff
@@ -80,15 +80,15 @@
       HEPMC3STATUS=hepmc3_new_weight(OUTID(1),'weme2'//char(0))
       OUTID(2)=hepmc3_new_writer(0,1,'PS.hepmc'//char(0))
       HEPMC3STATUS=hepmc3_new_weight(OUTID(2),'Default'//char(0))
       HEPMC3STATUS=hepmc3_new_weight(OUTID(2),'weps1'//char(0))
       HEPMC3STATUS=hepmc3_new_weight(OUTID(2),'weps2'//char(0))
       NEVHEP=-123456
       HEPMC3STATUS=hepmc3_set_hepevt_address(NEVHEP)
-C...Or one can set the pointer to some predefined block size      
+C...Or one can set the pointer to some predefined block size
 C      HEPMC3STATUS=hepmc3_set_hepevt_address(NEVHEPL)
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C-----------------------------------------------------------------
 
 C...Second section: event loop.
 
 C...Outer loop over ME and PS options.
```

### Comparing `HepMC3-3.2.5/examples/Pythia6Example/pythia-6.4.28.f` & `HepMC3-3.2.6/examples/Pythia6Example/pythia-6.4.28.f`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/Pythia8Example/CMakeLists.txt` & `HepMC3-3.2.6/examples/Pythia8Example/CMakeLists.txt`

 * *Files 3% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 if (USE_INSTALLED_HEPMC3)
 #This version is for standalone compilation of examples.
   set(CMAKE_MODULE_PATH    ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules    ${CMAKE_MODULE_PATH})
   find_package(Pythia8 8.220)
   if(Pythia8_FOUND)
     message(STATUS "HepMC3 Pythia8Example: Pythia8 package found. pythia8_example enabled")
     add_executable(pythia8_example.exe ${CMAKE_CURRENT_SOURCE_DIR}/pythia8_example.cc )
-    if (Pythia8_VERSION VERSION_GREATER "8.300")
+    if (PYTHIA8_VERSION VERSION_GREATER "8.300")
       target_compile_definitions(pythia8_example.exe PRIVATE "-DHEPMC3_USE_INTERFACE_FROM_PYTHIA8")
       target_include_directories(pythia8_example.exe PRIVATE ${PYTHIA8_INCLUDE_DIR})
     else()
       target_include_directories(pythia8_example.exe PRIVATE ${HEPMC3_INTERFACES_DIR}/pythia8/include/Pythia8 ${PYTHIA8_INCLUDE_DIR})
     endif()
   endif()
 else()
 #This version is for compilation during installation. Should be consistent with Pythia used in tests
   set(PYTHIA8_ROOT_DIR "" CACHE PATH "Location of Pythia8 installation.")
   find_package(Pythia8 8.220)
   if(Pythia8_FOUND)
     message(STATUS "HepMC3 Pythia8Example: Pythia8 package found. pythia8_example enabled")
     add_executable(pythia8_example.exe ${CMAKE_CURRENT_SOURCE_DIR}/pythia8_example.cc )
-    if (Pythia8_VERSION VERSION_GREATER "8.300")
+    if (PYTHIA8_VERSION VERSION_GREATER "8.300")
       target_compile_definitions(pythia8_example.exe PRIVATE "-DHEPMC3_USE_INTERFACE_FROM_PYTHIA8")
       target_include_directories(pythia8_example.exe PRIVATE ${PYTHIA8_INCLUDE_DIR})
     else()
       target_include_directories(pythia8_example.exe PRIVATE ${PROJECT_SOURCE_DIR}/interfaces/pythia8/include/Pythia8  ${PYTHIA8_INCLUDE_DIR})
     endif()
    endif()
 endif()
```

### Comparing `HepMC3-3.2.5/examples/Pythia8Example/cmake/Modules/FindPythia8.cmake` & `HepMC3-3.2.6/examples/Pythia8Example/cmake/Modules/FindPythia8.cmake`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/Pythia8Example/pythia8_example.cc` & `HepMC3-3.2.6/examples/Pythia8Example/pythia8_example.cc`

 * *Files 10% similar despite different names*

```diff
@@ -34,15 +34,15 @@
     run->tools().push_back(config);
     std::vector<std::string> names;
     for (int iWeight=0; iWeight < pythia.info.nWeights(); ++iWeight) {
      std::string s=pythia.info.weightLabel(iWeight);
      if (!s.length()) s=std::to_string((long long int)iWeight);
      names.push_back(s);
     }
-    if (!names.size()) names.push_back("default");
+    if (names.empty()) names.emplace_back("default");
     run->set_weight_names(names);
     WriterAscii file(argv[2],run);
 
     int nEvent = pythia.mode("Main:numberOfEvents");
 
     for( int i = 0; i< nEvent; ++i ) {
         if( !pythia.next() ) continue;
```

### Comparing `HepMC3-3.2.5/examples/Pythia8Example/pythia8_pp_minbias.conf` & `HepMC3-3.2.6/examples/Pythia8Example/pythia8_pp_minbias.conf`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/RootIOExample/CMakeLists.txt` & `HepMC3-3.2.6/examples/RootIOExample/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/RootIOExample/example.hepmc3` & `HepMC3-3.2.6/examples/RootIOExample/example.hepmc3`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/RootIOExample/rootIO_example_read.cc` & `HepMC3-3.2.6/examples/RootIOExample/rootIO_example_read.cc`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @example rootIO_example_read.cc
  *  @brief Basic example of use of root I/O: reading events from file
  *
  *  @author Witold Pokorski
  *  @date   16/10/14
```

### Comparing `HepMC3-3.2.5/examples/RootIOExample/rootIO_example_write.cc` & `HepMC3-3.2.6/examples/RootIOExample/rootIO_example_write.cc`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @example rootIO_example_write.cc
  *  @brief Basic example of use of root I/O: writing events to file
  *
  *  @author Witold Pokorski
  *  @date   16/10/14
```

### Comparing `HepMC3-3.2.5/examples/RootIOExample2/CMakeLists.txt` & `HepMC3-3.2.6/examples/RootIOExample2/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/RootIOExample2/class_example_read.cc` & `HepMC3-3.2.6/examples/RootIOExample2/class_example_read.cc`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @example class_example_read.cc
  *  @brief Basic example of use of root I/O: reading events from file
  *
  *  @author Witold Pokorski
  *  @date   16/10/14
@@ -35,28 +35,28 @@
         exit(-1);
     }
 
 
     TFile fo(argv[1]);
     WriterAscii text_output(argv[2]);
 
-    MyClass* myevent;
+    MyClass* myevent = nullptr;
     int events_parsed = 0;
 
     // Get GenRunInfo, if available
-    MyRunClass *my_run = (MyRunClass*)fo.Get("MyRunClass");
+    auto *my_run = (MyRunClass*)fo.Get("MyRunClass");
     std::shared_ptr<GenRunInfo> run_info;
 
     if( my_run ) run_info.reset(my_run->GetRunInfo());
 
 
     fo.GetListOfKeys()->Print();
 
     TIter next(fo.GetListOfKeys());
-    TKey *key;
+    TKey *key = nullptr;
 
     while ((key=(TKey*)next()))
     {
         const char *cl = key->GetClassName();
 
         if( strncmp(cl,"MyClass",7) != 0 ) continue;
```

### Comparing `HepMC3-3.2.5/examples/RootIOExample2/class_example_write.cc` & `HepMC3-3.2.6/examples/RootIOExample2/class_example_write.cc`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @example class_example_write.cc
  *  @brief Basic example of use of root I/O: writing events to file
  *
  *  @author Witold Pokorski
  *  @date   16/10/14
@@ -31,15 +31,15 @@
     if( argc<3 ) {
         std::cout << "Usage: " << argv[0] << " <input_hepmc3_file> <output_root_file>" <<std:: endl;
         exit(-1);
     }
 
     ReaderAscii text_input(argv[1]);
 
-    TFile* fFile = new TFile(argv[2],"RECREATE");
+    auto* fFile = new TFile(argv[2],"RECREATE");
 
     int events_parsed = 0;
 
     bool is_gen_run_info_written = false;
 
     while( !text_input.failed() ) {
 
@@ -54,25 +54,25 @@
             Print::listing(evt);
         }
 
         if(!is_gen_run_info_written) {
             if(evt.run_info()) {
                 GenRunInfo run_info(*evt.run_info());
 
-                MyRunClass *my_run = new MyRunClass();
+                auto *my_run = new MyRunClass();
 
                 my_run->SetRunInfo(&run_info);
 
                 fFile->WriteObject(my_run,"MyRunClass");
 
                 is_gen_run_info_written = true;
             }
         }
 
-        MyClass* myclass = new MyClass();
+        auto* myclass = new MyClass();
 
         myclass->SetEvent(&evt);
         //
         std::ostringstream os;
         os << events_parsed;
         std::string stevt = "Event_" + os.str();
         const char* chevt = stevt.c_str();
```

### Comparing `HepMC3-3.2.5/examples/RootIOExample2/example.hepmc3` & `HepMC3-3.2.6/examples/RootIOExample2/example.hepmc3`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/RootIOExample2/include/MyClass.h` & `HepMC3-3.2.6/examples/RootIOExample2/include/MyClass.h`

 * *Files 22% similar despite different names*

```diff
@@ -18,15 +18,15 @@
     /// @brief Get HepMC event
     GenEvent* GetEvent();
 
     /// @brief Set someint
     void SetInt(int);
 
     /// @brief Get someint
-    int GetInt();
+    int GetInt() const;
 
 
 private:
     int someint;            ///< Test int
     GenEvent* event; ///< Test event
 };
```

### Comparing `HepMC3-3.2.5/examples/RootIOExample2/include/MyRunClass.h` & `HepMC3-3.2.6/examples/RootIOExample2/include/MyRunClass.h`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
     /// @brief Get HepMC event
     GenRunInfo* GetRunInfo();
 
     /// @brief Set someint
     void SetInt(int);
 
     /// @brief Get someint
-    int GetInt();
+    int GetInt() const;
 
 private:
     int someint;            ///< Test int
     GenRunInfo* run; ///< Test run info
 };
 
 #endif
```

### Comparing `HepMC3-3.2.5/examples/RootIOExample3/CMakeLists.txt` & `HepMC3-3.2.6/examples/RootIOExample3/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/RootIOExample3/rootIOTree_example_read.cc` & `HepMC3-3.2.6/examples/RootIOExample3/rootIOTree_example_read.cc`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file rootIOTree_example_read.cc
  *  @brief Basic example of use of root I/O with tree: reading events from file
  *
  *  @author Witold Pokorski/Andrii Verbytskyi
  *  @date   29/10/15
```

### Comparing `HepMC3-3.2.5/examples/RootIOExample3/rootIOTree_example_write.cc` & `HepMC3-3.2.6/examples/RootIOExample3/rootIOTree_example_write.cc`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file rootIOTree_example_write.cc
  *  @brief Basic example of use of root I/O: writing events to file
  *
  *  @author Witold Pokorski/Andrii Verbytskyi
  *  @date   29/10/15
```

### Comparing `HepMC3-3.2.5/examples/SearchExample/CMakeLists.txt` & `HepMC3-3.2.6/examples/SearchExample/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/examples/SearchExample/src/search_example.cc` & `HepMC3-3.2.6/examples/SearchExample/src/search_example.cc`

 * *Files 2% similar despite different names*

```diff
@@ -1,39 +1,39 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #include "HepMC3/GenEvent.h"
 #include "HepMC3/Print.h"
 #include "HepMC3/GenParticle.h"
 #include "HepMC3/GenVertex.h"
 #include "HepMC3/Relatives.h"
 
 HepMC3::GenEvent* generate_event(const size_t  n,const  size_t  iterations)
 {
-    HepMC3::GenEvent* e=new HepMC3::GenEvent();
+    auto* e=new HepMC3::GenEvent();
     HepMC3::GenVertexPtr v0=std::make_shared<HepMC3::GenVertex>();
     e->add_vertex(v0);
     size_t it=0;
     for (;;)
     {
         if (it>iterations)
         {
             for (auto v: e->vertices())
             {
-                if (v->particles_out().size()!=0) continue;
+                if (!v->particles_out().empty()) continue;
                 for (size_t i=0; i<n; i++) v->add_particle_out(std::make_shared<HepMC3::GenParticle>());
             }
             break;
         }
         auto vertices=e->vertices();
         for (auto v: vertices)
         {
-            if (v->particles_out().size()!=0) continue;
+            if (!v->particles_out().empty()) continue;
             for (size_t i=0; i<n; i++) v->add_particle_out(std::make_shared<HepMC3::GenParticle>());
             for (auto p: v->particles_out())
             {
                 HepMC3::GenVertexPtr vx=std::make_shared<HepMC3::GenVertex>();
                 vx->add_particle_in(p);
                 e->add_vertex(vx);
             }
```

### Comparing `HepMC3-3.2.5/examples/ViewerExample/CMakeLists.txt` & `HepMC3-3.2.6/examples/ViewerExample/CMakeLists.txt`

 * *Files 20% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 set(CMAKE_MODULE_PATH    ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules    ${CMAKE_MODULE_PATH})
 find_package(Graphviz)
 find_package(ROOT REQUIRED COMPONENTS Core RIO Tree Gui Graf Hist Gpad )
-if(GRAPHVIZ_FOUND AND ROOT_FOUND)
-  message(STATUS "HepMC3 ViewerExample: GrpahViz and ROOT found. GUI Browser example enabled. ${ROOT_LIBRARIES}  ${GRAPHVIZ_GRAPH_LIBRARY}  ${GRAPHVIZ_CGRAPH_LIBRARY} ${GRAPHVIZ_GVC_LIBRARY}")
-  include_directories(${PROJECT_SOURCE_DIR}/rootIO/include ${CMAKE_CURRENT_SOURCE_DIR}/include ${CMAKE_CURRENT_SOURCE_DIR}  ${ROOT_INCLUDE_DIRS} ${GRAPHVIZ_INCLUDE_DIRS} ./)
+if(Graphviz_FOUND AND ROOT_FOUND)
+  message(STATUS "HepMC3 ViewerExample: GrpahViz and ROOT found. GUI Browser example enabled. ${ROOT_LIBRARIES}  ${Graphviz_GRAPH_LIBRARY}  ${Graphviz_CGRAPH_LIBRARY} ${Graphviz_GVC_LIBRARY}")
+  include_directories(${PROJECT_SOURCE_DIR}/rootIO/include ${CMAKE_CURRENT_SOURCE_DIR}/include ${CMAKE_CURRENT_SOURCE_DIR}  ${ROOT_INCLUDE_DIRS} ${Graphviz_INCLUDE_DIRS} ./)
   ROOT_GENERATE_DICTIONARY(HepMC3ViewerFrameDict include/HepMC3ViewerFrame.h LINKDEF include/LinkDef.h OPTIONS -inlineInputHeader)
   ADD_EXECUTABLE(HepMC3Viewer.exe  src/main.cc  src/HepMC3ViewerFrame.cc HepMC3ViewerFrameDict.cxx  )
   set_target_properties(HepMC3Viewer.exe PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_BINDIR})
-  target_compile_definitions(HepMC3Viewer.exe PRIVATE ${GRAPHVIZ_DEFINES} )
+  target_compile_definitions(HepMC3Viewer.exe PRIVATE ${Graphviz_DEFINES} )
   include_directories( include  )
 
-  SET(linklibraties ${ROOT_LIBRARIES}  ${GRAPHVIZ_CGRAPH_LIBRARY}  ${GRAPHVIZ_GVC_LIBRARY}  ${HEPMC3_LIB} ${HEPMC3_ROOTIO_LIB} )
-  if (GRAPHVIZ_GRAPH_LIBRARY)
-    list(APPEND linklibraties  ${GRAPHVIZ_GRAPH_LIBRARY}  )
+  SET(linklibraties ${ROOT_LIBRARIES}  ${Graphviz_CGRAPH_LIBRARY}  ${Graphviz_GVC_LIBRARY}  ${HEPMC3_LIB} ${HEPMC3_ROOTIO_LIB} )
+  if (Graphviz_GRAPH_LIBRARY)
+    list(APPEND linklibraties  ${Graphviz_GRAPH_LIBRARY}  )
   endif()
   TARGET_LINK_LIBRARIES(HepMC3Viewer.exe   ${linklibraties})
   if (USE_INSTALLED_HEPMC3)
     install(TARGETS HepMC3Viewer.exe DESTINATION ${CMAKE_INSTALL_BINDIR})
     install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} DESTINATION ${CMAKE_INSTALL_BINDIR} FILES_MATCHING PATTERN "*.pcm" PATTERN "*config"  PATTERN "CMakeFiles" EXCLUDE )
     install(DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_BINDIR}/ DESTINATION ${CMAKE_INSTALL_BINDIR}
         FILES_MATCHING PATTERN "*env.sh*")
```

### Comparing `HepMC3-3.2.5/examples/ViewerExample/include/HepMC3ViewerFrame.h` & `HepMC3-3.2.6/examples/ViewerExample/include/HepMC3ViewerFrame.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @class HepMC3ViewerFrame
 /// @brief Definition of \b class HepMC3ViewerFrame used for simple GUI viewer
 ///
 #include <TGClient.h>
 #include <TBuffer.h>
```

### Comparing `HepMC3-3.2.5/examples/ViewerExample/src/HepMC3ViewerFrame.cc` & `HepMC3-3.2.6/examples/ViewerExample/src/HepMC3ViewerFrame.cc`

 * *Files 2% similar despite different names*

```diff
@@ -11,30 +11,31 @@
 // #define _PACKAGE_ast 1
 
 #include <graphviz/gvc.h>
 #define CONSERVATION_TOLERANCE 1e-5
 
 static  char*  create_image_from_dot(char* m_buffer)
 {
-    GVC_t * gvc=gvContext();
-    Agraph_t *g= agmemread(m_buffer);
-    gvLayout(gvc,g,"dot");
+    GVC_t *gvc = gvContext();
+    Agraph_t *g = agmemread(m_buffer);
+    gvLayout(gvc, g, "dot");
 
     int err;
     char *data;
     unsigned int length;
 
     if (!g)
         return NULL;
     err = gvRenderData(gvc, g, "png", &data, &length);
     if (err)
         return NULL;
     data = (char*)realloc(data, length + 1);
-    delete g;
-    delete gvc;
+    gvFreeLayout(gvc, g);
+    agclose(g);
+    gvFreeContext(gvc);
     return data;
 }
 
 static bool show_as_parton(HepMC3::ConstGenParticlePtr p )
 {
     const int pd=std::abs(p->pid());
     bool parton=false;
```

### Comparing `HepMC3-3.2.5/examples/ViewerExample/src/main.cc` & `HepMC3-3.2.6/examples/ViewerExample/src/main.cc`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -13,8 +13,8 @@
     {
         fprintf(stderr, "%s: cannot run in batch mode\n", argv[0]);
         return 1;
     }
     HepMC3ViewerFrame *G=new HepMC3ViewerFrame(gClient->GetRoot(), 350, 80);
     if (theApp.Argc()>1) G->ReadFile(theApp.Argv()[1]);
     theApp.Run();
-}
+}
```

### Comparing `HepMC3-3.2.5/include/HepMC3/AssociatedParticle.h` & `HepMC3-3.2.6/include/HepMC3/AssociatedParticle.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_AssociatedParticle_H
 #define HEPMC3_AssociatedParticle_H
 /**
  *  @file AssociatedParticle.h
  *  @brief Definition of \b class AssociatedParticle,
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Attribute.h` & `HepMC3-3.2.6/include/HepMC3/Attribute.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_ATTRIBUTE_H
 #define HEPMC3_ATTRIBUTE_H
 /**
  *  @file Attribute.h
  *  @brief Definition of \b class Attribute, \b class IntAttribute and \b class StringAttribute
  *
@@ -162,72 +162,76 @@
 
     /** @brief Constructor initializing attribute value */
     IntAttribute(int val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         m_val = atoi( att.c_str() );
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att = std::to_string(m_val);
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     int value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const int& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     int m_val; ///< Attribute value
 };
 
 /**
  *  @class HepMC3::LongAttribute
- *  @brief Attribute that holds an Integer implemented as an int
+ *  @brief Attribute that holds an Integer implemented as a long int
  *
  *  @ingroup attributes
  */
 class LongAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
     LongAttribute(): Attribute(), m_val(0) {}
 
     /** @brief Constructor initializing attribute value */
     LongAttribute(long val): Attribute(), m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         m_val = atol( att.c_str() );
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att = std::to_string(m_val);
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     long value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const long& l) {
         m_val = l;
+        set_is_parsed(true);
     }
 
 private:
 
     long m_val; ///< Attribute value
 
 };
@@ -244,21 +248,22 @@
     /** @brief Default constructor */
     DoubleAttribute(): Attribute(), m_val(0.0) {}
 
     /** @brief Constructor initializing attribute value */
     DoubleAttribute(double val): Attribute(), m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         m_val = atof( att.c_str() );
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         std::ostringstream oss;
         oss << std::setprecision(std::numeric_limits<double>::digits10)
             << m_val;
         att = oss.str();
         return true;
     }
 
@@ -266,14 +271,15 @@
     double value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const double& d) {
         m_val = d;
+        set_is_parsed(true);
     }
 
 private:
 
     double m_val; ///< Attribute value
 };
 
@@ -289,21 +295,22 @@
     /** @brief Default constructor */
     FloatAttribute(): Attribute(), m_val(0.0) {}
 
     /** @brief Constructor initializing attribute value */
     FloatAttribute(float val): Attribute(), m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         m_val = float(atof( att.c_str() ));
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         std::ostringstream oss;
         oss << std::setprecision(std::numeric_limits<float>::digits10)
             << m_val;
         att = oss.str();
         return true;
     }
 
@@ -311,14 +318,15 @@
     float value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const float& f) {
         m_val = f;
+        set_is_parsed(true);
     }
 
 private:
 
     float m_val; ///< Attribute value
 };
 
@@ -343,21 +351,21 @@
      *  The Attribute constructor used here marks that this is an unparsed
      *  string that can be (but does not have to be) parsed
      *
      */
     StringAttribute(const std::string &st):Attribute(st) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         set_unparsed_string(att);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att = unparsed_string();
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::string value() const {
         return unparsed_string();
@@ -368,29 +376,30 @@
         set_unparsed_string(s);
     }
 
 };
 
 /**
  *  @class HepMC3::CharAttribute
- *  @brief Attribute that holds an Chareger implemented as an int
+ *  @brief Attribute that holds an Character implemented as an int
  *
  *  @ingroup attributes
  */
 class CharAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
     CharAttribute():Attribute(),m_val(0) {}
 
     /** @brief Constructor initializing attribute value */
     CharAttribute(char val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
+        set_is_parsed(true);
         if (att.size())
         {
             m_val = att.at(0);
             return true;
         }
         return false;
     }
@@ -405,66 +414,69 @@
     char value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const char& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     char m_val; ///< Attribute value
 };
 
 /**
  *  @class HepMC3::LongLongAttribute
- *  @brief Attribute that holds an Integer implemented as an int
+ *  @brief Attribute that holds an Integer implemented as a long long int
  *
  *  @ingroup attributes
  */
 class LongLongAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
     LongLongAttribute(): Attribute(), m_val(0) {}
 
     /** @brief Constructor initializing attribute value */
     LongLongAttribute(long long val): Attribute(), m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         m_val = atoll( att.c_str() );
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att = std::to_string(m_val);
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     long long value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const long long& l) {
         m_val = l;
+        set_is_parsed(true);
     }
 
 private:
 
-    long  long m_val; ///< Attribute value
+    long long m_val; ///< Attribute value
 
 };
 
 /**
  *  @class HepMC3::LongDoubleAttribute
- *  @brief Attribute that holds a real number as a double.
+ *  @brief Attribute that holds a real number as a long double.
  *
  *  @ingroup attributes
  */
 class LongDoubleAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -472,19 +484,20 @@
 
     /** @brief Constructor initializing attribute value */
     LongDoubleAttribute(long double val): Attribute(), m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         m_val = strtold( att.c_str(),NULL);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         std::ostringstream oss;
         oss << std::setprecision(std::numeric_limits<long double>::digits10)
             << m_val;
         att = oss.str();
         return true;
     }
 
@@ -492,14 +505,15 @@
     long double value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const long double& d) {
         m_val = d;
+        set_is_parsed(true);
     }
 
 private:
 
     long double m_val; ///< Attribute value
 };
 
@@ -517,33 +531,35 @@
     /** @brief Default constructor */
     UIntAttribute():Attribute(),m_val(0) {}
 
     /** @brief Constructor initializing attribute value */
     UIntAttribute(unsigned int val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         m_val = strtoul(att.c_str(), NULL, 0);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att = std::to_string(m_val);
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     unsigned int value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const unsigned int& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     unsigned int m_val; ///< Attribute value
 };
 
 
@@ -560,33 +576,35 @@
     /** @brief Default constructor */
     ULongAttribute():Attribute(),m_val(0) {}
 
     /** @brief Constructor initializing attribute value */
     ULongAttribute(unsigned long val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         m_val = strtoul(att.c_str(), NULL, 0);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att = std::to_string(m_val);
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     unsigned long value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const unsigned long& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     unsigned long m_val; ///< Attribute value
 };
 
 
@@ -602,84 +620,89 @@
     /** @brief Default constructor */
     ULongLongAttribute():Attribute(),m_val(0) {}
 
     /** @brief Constructor initializing attribute value */
     ULongLongAttribute(unsigned long long val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         m_val = strtoull(att.c_str(), NULL, 0);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att = std::to_string(m_val);
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     unsigned long long value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const unsigned long long& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     unsigned long long m_val; ///< Attribute value
 };
+
 /**
- *  @class HepMC3::BoolAttribute
- *  @brief Attribute that holds an Booleger implemented as an int
- *
- *  @ingroup attributes
- */
+*  @class HepMC3::BoolAttribute
+*  @brief Attribute that holds an Booleger implemented as an int
+*
+*  @ingroup attributes
+*/
 class BoolAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
     BoolAttribute():Attribute(),m_val(false) {}
 
     /** @brief Constructor initializing attribute value */
     BoolAttribute(bool val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
-    bool from_string(const std::string &att)  override{
+    bool from_string(const std::string &att)  override {
         if (att.size()!=1) return false;
         if (att==std::string("1")) {m_val = true;  return true;}
         if (att==std::string("0")) {m_val = false; return true;}
+        set_is_parsed(true);
         return false;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const override{
+    bool to_string(std::string &att) const override {
         att = std::to_string(m_val);
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     bool value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const bool& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     bool m_val; ///< Attribute value
 };
 
 /**
  *  @class HepMC3::VectorCharAttribute
- *  @brief Attribute that holds a vector of charegers of type  char
+ *  @brief Attribute that holds a vector of characters of type  char
  *
  *  @ingroup attributes
  */
 class VectorCharAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -689,42 +712,45 @@
     VectorCharAttribute(std::vector<char> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         char  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<char> value() const {
         return m_val;
+
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<char>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<char> m_val; ///< Attribute value
 };
 
 /**
  *  @class HepMC3::VectorFloatAttribute
- *  @brief Attribute that holds a vector of floategers of type  float
+ *  @brief Attribute that holds a vector of real numbers of type float
  *
  *  @ingroup attributes
  */
 class VectorFloatAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -734,43 +760,45 @@
     VectorFloatAttribute(std::vector<float> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         float  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<float> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<float>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<float> m_val; ///< Attribute value
 };
 
 
 /**
  *  @class HepMC3::VectorLongDoubleAttribute
- *  @brief Attribute that holds a vector of long doubleegers of type  long double
+ *  @brief Attribute that holds a vector of real numbers of type long double
  *
  *  @ingroup attributes
  */
 class VectorLongDoubleAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -780,44 +808,46 @@
     VectorLongDoubleAttribute(std::vector<long double> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         long double  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<long double> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<long double>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<long double> m_val; ///< Attribute value
 };
 
 
 
 /**
  *  @class HepMC3::VectorLongLongAttribute
- *  @brief Attribute that holds a vector of long longegers of type  long long
+ *  @brief Attribute that holds a vector of integers of type  long long
  *
  *  @ingroup attributes
  */
 class VectorLongLongAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -827,33 +857,35 @@
     VectorLongLongAttribute(std::vector<long long> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         long long  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<long long> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<long long>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<long long> m_val; ///< Attribute value
 };
 
 /**
@@ -872,42 +904,44 @@
     VectorUIntAttribute(std::vector<unsigned int> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         unsigned int  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<unsigned int> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<unsigned int>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<unsigned int> m_val; ///< Attribute value
 };
 
 /**
  *  @class HepMC3::VectorULongAttribute
- *  @brief Attribute that holds a vector of unsigned longegers of type  unsigned long
+ *  @brief Attribute that holds a vector of unsigned integers of type  unsigned long
  *
  *  @ingroup attributes
  */
 class VectorULongAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -917,43 +951,45 @@
     VectorULongAttribute(std::vector<unsigned long> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         unsigned long  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<unsigned long> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<unsigned long>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<unsigned long> m_val; ///< Attribute value
 };
 
 
 /**
  *  @class HepMC3::VectorULongLongAttribute
- *  @brief Attribute that holds a vector of unsigned long longegers of type  unsigned long long
+ *  @brief Attribute that holds a vector of integers of type  unsigned long long
  *
  *  @ingroup attributes
  */
 class VectorULongLongAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -963,33 +999,35 @@
     VectorULongLongAttribute(std::vector<unsigned long long> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         unsigned long long  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<unsigned long long> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<unsigned long long>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<unsigned long long> m_val; ///< Attribute value
 };
 
 /**
@@ -1008,42 +1046,45 @@
     VectorIntAttribute(std::vector<int> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         int  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<int> value() const {
         return m_val;
+
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<int>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<int> m_val; ///< Attribute value
 };
 
 /**
  *  @class HepMC3::VectorLongIntAttribute
- *  @brief Attribute that holds a vector of integers of type  int
+ *  @brief Attribute that holds a vector of integers of type long int
  *
  *  @ingroup attributes
  */
 class VectorLongIntAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -1053,42 +1094,44 @@
     VectorLongIntAttribute(std::vector<long int> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         long int  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<long int> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<long int>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<long int> m_val; ///< Attribute value
 };
 
 /**
  *  @class HepMC3::VectorDoubleAttribute
- *  @brief Attribute that holds a vector of FPs of type  double
+ *  @brief Attribute that holds a vector of real numbers of type  double
  *
  *  @ingroup attributes
  */
 class VectorDoubleAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -1098,43 +1141,45 @@
     VectorDoubleAttribute(std::vector<double> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const std::string &att) override {
         double  datafoo;
         m_val.clear();
         std::stringstream datastream(att);
-        while (datastream >> datafoo) m_val.push_back(datafoo);
+        while (datastream >> datafoo) m_val.emplace_back(datafoo);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=std::to_string(a);}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<double> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<double>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<double> m_val; ///< Attribute value
 };
 
 
 /**
  *  @class HepMC3::VectorStringAttribute
- *  @brief Attribute that holds a vector of FPs of type  string
+ *  @brief Attribute that holds a vector of type  string
  *
  *  @ingroup attributes
  */
 class VectorStringAttribute : public Attribute {
 public:
 
     /** @brief Default constructor */
@@ -1143,36 +1188,38 @@
     /** @brief Constructor initializing attribute value */
     VectorStringAttribute(std::vector<std::string> val):Attribute(),m_val(val) {}
 
     /** @brief Implementation of Attribute::from_string */
     bool from_string(const string &att) override {
         size_t posb = att.find_first_not_of(' ');
         do {
-           size_t pose = att.find_first_of(' ', posb);
-           m_val.push_back(att.substr(posb, pose - posb));
-           posb = att.find_first_not_of(' ', pose);
+            size_t pose = att.find_first_of(' ', posb);
+            m_val.push_back(att.substr(posb, pose - posb));
+            posb = att.find_first_not_of(' ', pose);
         } while (posb != std::string::npos);
+        set_is_parsed(true);
         return true;
     }
 
     /** @brief Implementation of Attribute::to_string */
-    bool to_string(std::string &att) const  override{
+    bool to_string(std::string &att) const  override {
         att.clear();
-        for (auto a:  m_val) {if (att.length()) att+=" ";  att+=a;}
+        for (const auto& a:  m_val) {if (att.length()) att+=" ";  att+=a;}
         return true;
     }
 
     /** @brief get the value associated to this Attribute. */
     std::vector<std::string> value() const {
         return m_val;
     }
 
     /** @brief set the value associated to this Attribute. */
     void set_value(const std::vector<std::string>& i) {
         m_val = i;
+        set_is_parsed(true);
     }
 
 private:
     std::vector<std::string> m_val; ///< Attribute value
 };
```

### Comparing `HepMC3-3.2.5/include/HepMC3/CompressedIO.h` & `HepMC3-3.2.6/include/HepMC3/CompressedIO.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,24 +1,27 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2020 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_COMPRESSEDIO_H
 #define HEPMC3_COMPRESSEDIO_H
 #if HEPMC3_USE_COMPRESSION
 #if HEPMC3_Z_SUPPORT
 #define BXZSTR_Z_SUPPORT 1
 #endif
 #if HEPMC3_LZMA_SUPPORT
 #define BXZSTR_LZMA_SUPPORT 1
 #endif
 #if HEPMC3_BZ2_SUPPORT
 #define BXZSTR_BZ2_SUPPORT 1
 #endif
+#if HEPMC3_ZSTD_SUPPORT
+#define BXZSTR_ZSTD_SUPPORT 1
+#endif
 #include "HepMC3/bxzstr/bxzstr.hpp"
 namespace HepMC3
 {
 using ofstream = bxz::ofstream;
 using ostream = bxz::ostream;
 using ifstream = bxz::ifstream;
 using istream = bxz::istream;
@@ -33,31 +36,37 @@
 #endif
 #if HEPMC3_LZMA_SUPPORT
     Compression::lzma,
 #endif
 #if HEPMC3_BZ2_SUPPORT
     Compression::bz2,
 #endif
+#if HEPMC3_ZSTD_SUPPORT
+    Compression::zstd,
+#endif
 };
 std::vector<Compression> known_compression_types = {
     Compression::z,
     Compression::lzma,
-    Compression::bz2
+    Compression::bz2,
+    Compression::zstd,
 };
 }
 namespace std
 {
 string to_string(HepMC3::Compression & c) {
     switch (c) {
     case HepMC3::Compression::z:
         return string("z");
     case HepMC3::Compression::lzma:
         return string("lzma");
     case HepMC3::Compression::bz2:
         return string("bz2");
+    case HepMC3::Compression::zstd:
+        return string("zstd");
     default:
         break;
     }
     return string("plaintext");
 }
 }
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Data/GenEventData.h` & `HepMC3-3.2.6/include/HepMC3/Data/GenEventData.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_DATA_GENEVENTDATA_H
 #define HEPMC3_DATA_GENEVENTDATA_H
 /**
  *  @file GenEventData.h
  *  @brief Definition of \b struct GenEventData
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Data/GenParticleData.h` & `HepMC3-3.2.6/include/HepMC3/Data/GenParticleData.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_DATA_GENPARTICLEDATA_H
 #define HEPMC3_DATA_GENPARTICLEDATA_H
 /**
  *  @file GenParticleData.h
  *  @brief Definition of \b class GenParticleData
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Data/GenRunInfoData.h` & `HepMC3-3.2.6/include/HepMC3/Data/GenRunInfoData.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_DATA_GENRUNINFODATA_H
 #define HEPMC3_DATA_GENRUNINFODATA_H
 /**
  *  @file GenRunInfoData.h
  *  @brief Definition of \b struct GenRunInfoData
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Data/GenVertexData.h` & `HepMC3-3.2.6/include/HepMC3/Data/GenVertexData.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_DATA_GENVERTEXDATA_H
 #define HEPMC3_DATA_GENVERTEXDATA_H
 /**
  *  @file GenVertexData.h
  *  @brief Definition of \b class GenVertexData
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Errors.h` & `HepMC3-3.2.6/include/HepMC3/Errors.h`

 * *Files 18% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file Errors.h
  *  @brief Implementation of  error and HEPMC3_HEPMC3_WARNING macros
  *
  */
 #ifndef HEPMC3_ERRORS_H
```

### Comparing `HepMC3-3.2.5/include/HepMC3/FourVector.h` & `HepMC3-3.2.6/include/HepMC3/FourVector.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_FOURVECTOR_H
 #define HEPMC3_FOURVECTOR_H
 /**
  *  @file FourVector.h
  *  @brief Definition of \b class FourVector
  */
@@ -39,17 +39,21 @@
     /** @brief Default constructor */
     FourVector()
         : m_v1(0.0),   m_v2(0.0), m_v3(0.0),    m_v4(0.0)  {}
     /** @brief Sets all FourVector fields */
     FourVector(double xx, double yy, double zz, double ee)
         : m_v1(xx),     m_v2(yy),   m_v3(zz),      m_v4(ee)    {}
     /** @brief Copy constructor */
-    FourVector(const FourVector & v)
-        : m_v1(v.m_v1), m_v2(v.m_v2), m_v3(v.m_v3), m_v4(v.m_v4) {}
-
+    FourVector(const FourVector &) = default;
+    /** @brief Move constructor */
+    FourVector(FourVector && ) = default;
+    /** @brief = */
+    FourVector& operator=(const FourVector&) = default;
+    /** @brief = */
+    FourVector& operator=(FourVector&&) = default;
 
     /// @name Component accessors
     /// @{
 
     /** @brief Set all FourVector fields, in order x,y,z,t */
     void set(double x1, double x2, double x3, double x4) {
         m_v1 = x1;
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenEvent.h` & `HepMC3-3.2.6/include/HepMC3/GenEvent.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file GenEvent.h
 /// @brief Definition of \b class GenEvent
 ///
 #ifndef HEPMC3_GENEVENT_H
 #define HEPMC3_GENEVENT_H
@@ -39,23 +39,23 @@
 /// Manages event-related information.
 /// Contains lists of GenParticle and GenVertex objects
 class GenEvent {
 
 public:
 
     /// @brief Event constructor without a run
-    GenEvent(Units::MomentumUnit momentum_unit = Units::GEV,
-             Units::LengthUnit length_unit = Units::MM);
+    GenEvent(Units::MomentumUnit mu = Units::GEV,
+             Units::LengthUnit lu = Units::MM);
 
 #if !defined(__CINT__)
 
     /// @brief Constructor with associated run
     GenEvent(std::shared_ptr<GenRunInfo> run,
-             Units::MomentumUnit momentum_unit = Units::GEV,
-             Units::LengthUnit length_unit = Units::MM);
+             Units::MomentumUnit mu = Units::GEV,
+             Units::LengthUnit lu = Units::MM);
 
     /// @brief Copy constructor
     GenEvent(const GenEvent&);
 
     /// @brief Destructor
     ~GenEvent();
 
@@ -66,34 +66,34 @@
     /// @{
 
     /// @brief Get list of particles (const)
     const std::vector<ConstGenParticlePtr>& particles() const;
     /// @brief Get list of vertices (const)
     const std::vector<ConstGenVertexPtr>& vertices() const;
 
-
     /// @brief Get/set list of particles (non-const)
     const std::vector<GenParticlePtr>& particles() { return m_particles; }
     /// @brief Get/set list of vertices (non-const)
     const std::vector<GenVertexPtr>& vertices() { return m_vertices; }
 
     /// @}
 
 
     /// @name Particle and vertex access
-    //@{
-    ///Particles size, HepMC2 compatiility
+    /// @{
+    /// Particles size, HepMC2 compatibility
     inline int particles_size() const { return m_particles.size(); }
-    ///Particles empty, HepMC2 compatiility
+    /// Particles empty, HepMC2 compatibility
     inline bool particles_empty() const { return m_particles.empty(); }
-    ///Vertices size, HepMC2 compatiility
+    /// Vertices size, HepMC2 compatibility
     inline int vertices_size() const { return m_vertices.size(); }
-    ///Vertices empty, HepMC2 compatiility
+    /// Vertices empty, HepMC2 compatibility
     inline bool vertices_empty() const { return m_vertices.empty(); }
-    //@}
+    /// @}
+
 
     /// @name Event weights
     /// @{
 
     /// Get event weight values as a vector
     const std::vector<double>& weights() const { return m_weights; }
     /// Get event weights as a vector (non-const)
@@ -187,29 +187,33 @@
     /// Vertex representing the overall event position
     const FourVector& event_pos() const;
 
     /// @brief Vector of beam particles
     std::vector<ConstGenParticlePtr> beams() const;
 
     /// @brief Vector of beam particles
+    std::vector<ConstGenParticlePtr> beams(const int status) const;
+
+
+    /// @brief Vector of beam particles
     const std::vector<GenParticlePtr> & beams();
 
     /// @brief Shift position of all vertices in the event by @a delta
     void shift_position_by( const FourVector & delta );
 
     /// @brief Shift position of all vertices in the event to @a op
     void shift_position_to( const FourVector & newpos ) {
         const FourVector delta = newpos - event_pos();
         shift_position_by(delta);
     }
 
-    /// @brief Boost event using x,y,z components of @a v as velocities
-    bool boost( const FourVector&  v );
-    /// @brief Rotate event using x,y,z components of @a v as rotation angles
-    bool rotate( const FourVector&  v );
+    /// @brief Boost event using x,y,z components of @a delta as velocities
+    bool boost( const FourVector&  delta );
+    /// @brief Rotate event using x,y,z components of @a delta as rotation angles
+    bool rotate( const FourVector&  delta );
     /// @brief Change sign of @a axis
     bool reflect(const int axis);
 
     /// @}
 
 
     /// @name Additional attributes
@@ -273,15 +277,15 @@
 
     /// @brief Remove particle from the event
     ///
     /// This function  will remove whole sub-tree starting from this particle
     /// if it is the only incoming particle of this vertex.
     /// It will also production vertex of this particle if this vertex
     /// has no more outgoing particles
-    void remove_particle( GenParticlePtr v );
+    void remove_particle( GenParticlePtr p );
 
     /// @brief Remove a set of particles
     ///
     /// This function follows rules of GenEvent::remove_particle to remove
     /// a list of particles from the event.
     void remove_particles( std::vector<GenParticlePtr> v );
 
@@ -295,34 +299,36 @@
     /// This function will find the beam particles (particles
     /// that have no production vertices or their production vertices
     /// have no particles) and will add the whole decay tree starting from
     /// these particles.
     ///
     /// @note Any particles on this list that do not belong to the tree
     ///       will be ignored.
-    void add_tree( const std::vector<GenParticlePtr> &particles );
+    void add_tree( const std::vector<GenParticlePtr> &parts );
 
     /// @brief Reserve memory for particles and vertices
     ///
     /// Helps optimize event creation when size of the event is known beforehand
-    void reserve(const size_t& particles, const size_t& vertices = 0);
+    void reserve(const size_t& parts, const size_t& verts = 0);
 
     /// @brief Remove contents of this event
     void clear();
 
     /// @}
 
     /// @name Deprecated functionality
     /// @{
 
     /// @brief Add particle by raw pointer
+    ///
     /// @deprecated Use GenEvent::add_particle( const GenParticlePtr& ) instead
     void add_particle( GenParticle *p );
 
     /// @brief Add vertex by raw pointer
+    ///
     /// @deprecated Use GenEvent::add_vertex( const GenVertexPtr& ) instead
     void add_vertex  ( GenVertex *v );
 
 
     /// @brief Set incoming beam particles
     /// @deprecated Backward compatibility
     void set_beam_particles(GenParticlePtr p1, GenParticlePtr p2);
@@ -362,23 +368,23 @@
 
     /// List of particles
     std::vector<GenParticlePtr> m_particles;
     /// List of vertices
     std::vector<GenVertexPtr> m_vertices;
 
     /// Event number
-    int m_event_number;
+    int m_event_number = 0;
 
     /// Event weights
     std::vector<double> m_weights;
 
     /// Momentum unit
-    Units::MomentumUnit m_momentum_unit;
+    Units::MomentumUnit m_momentum_unit = Units::GEV;
     /// Length unit
-    Units::LengthUnit m_length_unit;
+    Units::LengthUnit m_length_unit = Units::MM;
 
     /// The root vertex is stored outside the normal vertices list to block user access to it
     GenVertexPtr m_rootvertex;
 
     /// Global run information.
     std::shared_ptr<GenRunInfo> m_run_info;
 
@@ -397,23 +403,24 @@
     mutable std::recursive_mutex m_lock_attributes;
 #endif // __CINT__
 
     /// @}
 
 };
 
+
+
 #if !defined(__CINT__)
 //
 // Template methods
 //
 template<class T>
 std::shared_ptr<T> GenEvent::attribute(const std::string &name,  const int& id) const {
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    std::map< std::string, std::map<int, std::shared_ptr<Attribute> > >::iterator i1 =
-        m_attributes.find(name);
+    std::map< std::string, std::map<int, std::shared_ptr<Attribute> > >::iterator i1 = m_attributes.find(name);
     if ( i1 == m_attributes.end() ) {
         if ( id == 0 && run_info() ) {
             return run_info()->attribute<T>(name);
         }
         return std::shared_ptr<T>();
     }
 
@@ -421,26 +428,29 @@
     if (i2 == i1->second.end() ) return std::shared_ptr<T>();
 
     if (!i2->second->is_parsed() ) {
 
         std::shared_ptr<T> att = std::make_shared<T>();
         att->m_event = this;
 
-        if ( id > 0 && id <= int(particles().size()) )
+        if ( id > 0 && id <= int(particles().size()) ) {
             att->m_particle = m_particles[id - 1];
-        if ( id < 0 && -id <= int(vertices().size()) )
+        }
+        if ( id < 0 && -id <= int(vertices().size()) ) {
             att->m_vertex = m_vertices[-id - 1];
+        }
         if ( att->from_string(i2->second->unparsed_string()) &&
                 att->init() ) {
             // update map with new pointer
             i2->second = att;
             return att;
         } else {
             return std::shared_ptr<T>();
         }
     }
     else return std::dynamic_pointer_cast<T>(i2->second);
 }
 #endif // __CINT__
 
+
 } // namespace HepMC3
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenHeavyIon.h` & `HepMC3-3.2.6/include/HepMC3/GenHeavyIon.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_HEAVYION_H
 #define HEPMC3_HEAVYION_H
 /**
  *  @file GenHeavyIon.h
  *  @brief Definition of attribute \b class GenHeavyIon
  *
@@ -18,16 +18,14 @@
  *
  */
 #include <iostream>
 #include <map>
 #include "HepMC3/Attribute.h"
 
 namespace HepMC3 {
-/** Deprecated */
-using namespace std;
 
 class GenHeavyIon : public Attribute {
 
 public:
 
     /// Empty default constructor.
     GenHeavyIon()
@@ -222,16 +220,15 @@
 
     /// @brief Set all fields.
     ///
     /// HEPMC3_DEPRECATED("Set individual fields directly instead.")
     /** @brief Set all fields */
     void set( const int&nh, const int&np, const int&nt, const int&nc, const int&ns, const int&nsp,
               const int&nnw=0, const int&nwn=0, const int&nwnw=0,
-              const double& im=0., const double& pl=0., const double& ec=0., const double& s=0., const double& cent=0., const double& ucent=0. );
-
+              const double& im=0., const double& pl=0., const double& ec=0., const double& s=0., const double& cent=0., const double& usrcent=0. );
     /// @brief Verify that the instance contains non-zero information.
     ///
     /// HEPMC3_DEPRECATED("Each filed now have default values meaning
     /// that they have not been set")
     bool is_valid() const;
 
     /// @brief force writing in old format for compatibility purposes.
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenParticle.h` & `HepMC3-3.2.6/include/HepMC3/GenParticle.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_GENPARTICLE_H
 #define HEPMC3_GENPARTICLE_H
 /**
  *  @file GenParticle.h
  *  @brief Definition of \b class GenParticle
  *
@@ -18,52 +18,49 @@
 #include "HepMC3/FourVector.h"
 
 #include "HepMC3/GenParticle_fwd.h"
 #include "HepMC3/GenVertex_fwd.h"
 
 namespace HepMC3 {
 
-/** Deprecated */
-using namespace std;
-
 class GenEvent;
 class Attribute;
 
 class GenParticle : public std::enable_shared_from_this<GenParticle> {
 
     friend class GenVertex;
     friend class GenEvent;
 
 //
 // Constructors
 //
 public:
-    /** @brief Default constructor */
+
+    /// @brief Default constructor
     GenParticle( const FourVector &momentum = FourVector::ZERO_VECTOR(), int pid = 0, int status = 0 );
 
-    /** @brief Constructor based on particle data */
+    /// @brief Constructor based on particle data
     GenParticle( const GenParticleData &data );
 
 //
 // Functions
 //
 public:
-    /** @brief Check if this particle belongs to an event */
-    bool in_event() const { return (bool)(m_event); }
+    /// @brief Check if this particle belongs to an event
+    bool in_event() const { return (bool) (m_event); }
 
-//
-// Accessors
-//
-public:
+    /// @brief Get the parent event
+    GenEvent* parent_event() { return m_event; }
+    /// @brief Get the parent event (const)
+    const GenEvent* parent_event() const { return m_event; }
 
-    GenEvent*              parent_event() { return m_event; } //!< Get parent event
-    const GenEvent*              parent_event() const { return m_event; } //!< Get parent event
-    int                    id()           const { return m_id;    } //!< Get particle id
-    const GenParticleData& data()         const { return m_data;  } //!< Get particle data
+    /// @brief Get the particle ID number (*not* PDG ID)
+    int id() const { return m_id; }
 
+    const GenParticleData& data()         const { return m_data;  } //!< Get particle data
 
     ConstGenVertexPtr production_vertex() const;        //!< Get production vertex (const version)
     ConstGenVertexPtr end_vertex() const;               //!< Get end vertex (const version)
 
     GenVertexPtr production_vertex();        //!< Get production vertex
     GenVertexPtr end_vertex();               //!< Get end vertex
 
@@ -98,20 +95,19 @@
 
     void set_pid(int pid);                         //!< Set PDG ID
     void set_status(int status);                   //!< Set status code
     void set_momentum(const FourVector& momentum); //!< Set momentum
     void set_generated_mass(double m);             //!< Set generated mass
     void unset_generated_mass();                   //!< Declare that generated mass is not set
 
-    /** @brief Add an attribute to this particle
-     *
-     *  This will overwrite existing attribute if an attribute with
-     *  the same name is present. The attribute will be stored in the
-     *  parent_event(). @return false if there is no parent_event();
-     */
+    /// @brief Add an attribute to this particle
+    ///
+    ///  This will overwrite existing attribute if an attribute with
+    ///  the same name is present. The attribute will be stored in the
+    ///  parent_event(). @return false if there is no parent_event();
     bool add_attribute(const std::string& name, std::shared_ptr<Attribute> att);
 
     /// @brief Get list of names of attributes assigned to this particle
     std::vector<std::string> attribute_names() const;
 
     /// @brief Remove attribute
     void remove_attribute(const std::string& name);
@@ -131,15 +127,14 @@
     /// @deprecated Use pid() instead
     int pdg_id() const { return pid(); }
 
     /// @brief Set PDG ID
     /// @deprecated Use set_pid() instead
     void set_pdg_id(const int& pidin) { set_pid(pidin); }
 
-
     /// @}
 //
 // Fields
 //
 private:
     GenEvent        *m_event; //!< Parent event
     int              m_id;    //!< Index
@@ -147,14 +142,16 @@
 
     std::weak_ptr<GenVertex>    m_production_vertex; //!< Production vertex
     std::weak_ptr<GenVertex>    m_end_vertex;        //!< End vertex
 };
 
 } // namespace HepMC3
 
+
+
 #include "HepMC3/GenEvent.h"
 namespace HepMC3 {
 /// @brief Get attribute of type T
 template<class T> std::shared_ptr<T> GenParticle::attribute(const std::string& name) const {
     return parent_event()?
            parent_event()->attribute<T>(name, id()): std::shared_ptr<T>();
 }
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenParticle_fwd.h` & `HepMC3-3.2.6/include/HepMC3/GenParticle_fwd.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file GenParticle_fwd.h
 /// @brief Minimal forward declarations for GenParticle
 ///
 
 #ifndef HEPMC3_GENPARTICLE_FWD_H
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenPdfInfo.h` & `HepMC3-3.2.6/include/HepMC3/GenPdfInfo.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_GENPDFINFO_H
 #define HEPMC3_GENPDFINFO_H
 /**
  *  @file GenPdfInfo.h
  *  @brief Definition of event attribute \b class GenPdfInfo
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenRunInfo.h` & `HepMC3-3.2.6/include/HepMC3/GenRunInfo.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file GenRunInfo.h
 /// @brief Definition of \b class GenRunInfo
 ///
 #ifndef HEPMC3_GENRUNINFO_H
 #define HEPMC3_GENRUNINFO_H
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenVertex.h` & `HepMC3-3.2.6/include/HepMC3/GenVertex.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,27 +1,25 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /// @file GenVertex.h
 /// @brief Definition of \b class GenVertex
 //
 #ifndef HEPMC3_GENVERTEX_H
 #define HEPMC3_GENVERTEX_H
 #include <string>
 #include "HepMC3/GenParticle_fwd.h"
 #include "HepMC3/GenVertex_fwd.h"
 #include "HepMC3/Data/GenVertexData.h"
 #include "HepMC3/FourVector.h"
 
 namespace HepMC3 {
 
-/** Deprecated */
-using namespace std;
 
 class Attribute;
 class GenEvent;
 
 /// Stores vertex-related information
 class GenVertex : public std::enable_shared_from_this<GenVertex> {
```

### Comparing `HepMC3-3.2.5/include/HepMC3/GenVertex_fwd.h` & `HepMC3-3.2.6/include/HepMC3/GenVertex_fwd.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file GenVertex_fwd.h
 /// @brief Minimal forward declarations for GenVertex
 ///
 
 #ifndef HEPMC3_GENVERTEX_FWD_H
```

### Comparing `HepMC3-3.2.5/include/HepMC3/HEPEVT_Helpers.h` & `HepMC3-3.2.6/include/HepMC3/HEPEVT_Helpers.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPEVT_HELPERS_H
 #define HEPEVT_HELPERS_H
 /**
  *  @file HEPEVT_Helpers.h
  *  @brief Helper functions used to manipulate with HEPEVT block
  *
@@ -290,18 +290,18 @@
     for (std::map<GenVertexPtr, std::pair<std::set<int>, std::set<int> > >:: iterator it = final_vertices_map.begin(); it != final_vertices_map.end(); ++it)
     {
         GenVertexPtr v = it->first;
         std::set<int> in = it->second.first;
         std::set<int> out = it->second.second;
         used.insert(in.begin(), in.end());
         used.insert(out.begin(), out.end());
-        for (std::set<int>::iterator el = in.begin(); el != in.end(); ++el) v->add_particle_in(particles_index[*el]);
-        if (in.size() !=0 ) for (std::set<int>::iterator el = out.begin(); el != out.end(); ++el) v->add_particle_out(particles_index[*el]);
+        for (const auto&  el: in) v->add_particle_in(particles_index[el]);
+        if (in.size() !=0 ) for (const auto&  el: out) v->add_particle_out(particles_index[el]);
     }
-    for (std::set<int>::iterator el = used.begin(); el != used.end(); ++el) final_particles.push_back(particles_index[*el]);
+    for (const auto&  el: used) final_particles.emplace_back(particles_index[el]);
     /* One can put here a check on the number of particles/vertices*/
 
     evt->add_tree(final_particles);
 
     return true;
 }
```

### Comparing `HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper.h` & `HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_HEPEVT_WRAPPER_H
 #define HEPMC3_HEPEVT_WRAPPER_H
 /**
  *  @file HEPEVT_Wrapper.h
  *  @brief Definition of \b class HEPEVT_Wrapper
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper_Runtime.h` & `HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper_Runtime.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_HEPEVT_WRAPPER_RUNTIME_H
 #define HEPMC3_HEPEVT_WRAPPER_RUNTIME_H
 #include <iostream>
 #include <cstdio>
 #include <set>
 #include <map>
@@ -55,16 +55,16 @@
     int m_max_particles;
     /** @brief  Internalstorage storage. Optional.*/
     std::vector<char> m_internal_storage;
 //
 // Accessors
 //
 public:
-    void   allocate_internal_storage(); ///!< Allocates m_internal_storage storage in smart pointer to hold HEPEVT of fixed size
-    void   copy_to_internal_storage(char *c, int N); ///!< Copies the content of foreight common block into the internal storage
+    void   allocate_internal_storage(); //!< Allocates m_internal_storage storage in smart pointer to hold HEPEVT of fixed size
+    void   copy_to_internal_storage( char *c, int N ); //!< Copies the content of foreign common block into the internal storage
     void   set_max_number_entries( unsigned int size ) { m_max_particles = size; }//!< Set block size
     void   set_hepevt_address(char *c); //!< Set Fortran block address
     int    max_number_entries()  const     { return m_max_particles;                              } //!< Block size
     int    event_number()     const        { return *(m_hepevtptr->nevhep);             } //!< Get event number
     int    number_entries()  const         { return *(m_hepevtptr->nhep);               } //!< Get number of entries
     int    status(const int index )   const     { return m_hepevtptr->isthep[index-1];    } //!< Get status code
     int    id(const int index )     const       { return m_hepevtptr->idhep[index-1];     } //!< Get PDG particle id
```

### Comparing `HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper_Runtime_Static.h` & `HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper_Runtime_Static.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_HEPEVT_WRAPPER_RUNTIME_STATIC_H
 #define HEPMC3_HEPEVT_WRAPPER_RUNTIME_STATIC_H
 #include <iostream>
 #include <cstdio>
 #include <set>
 #include <map>
```

### Comparing `HepMC3-3.2.5/include/HepMC3/HEPEVT_Wrapper_Template.h` & `HepMC3-3.2.6/include/HepMC3/HEPEVT_Wrapper_Template.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_HEPEVT_WRAPPER_TEMPLATE_H
 #define HEPMC3_HEPEVT_WRAPPER_TEMPLATE_H
 #include <iostream>
 #include <cstdio>
 #include <set>
 #include <map>
@@ -55,16 +55,16 @@
 private:
     /** @brief  Internalstorage storage. Optional.*/
     std::shared_ptr<struct HEPEVT_Templated<max_particles, momentum_type> > m_internal_storage;
 //
 // Accessors
 //
 public:
-    void   allocate_internal_storage(); ///!< Allocates m_internal_storage storage in smart pointer to hold HEPEVT of fixed size
-    void   copy_to_internal_storage(char *c, int N); ///!< Copies the content of foreight common block into the internal storage
+    void   allocate_internal_storage(); //!< Allocates m_internal_storage storage in smart pointer to hold HEPEVT of fixed size
+    void   copy_to_internal_storage( char *c, int N ); //!< Copies the content of foreign common block into the internal storage
     void   set_max_number_entries( unsigned int size ) { if (size != max_particles) printf("This implementation does not support change of the block size.\n"); assert(size == max_particles); }//!< Set block size
     void   set_hepevt_address(char *c) { m_hepevtptr = (struct HEPEVT_Templated<max_particles, momentum_type>*)c;          } //!< Set Fortran block address
     int    max_number_entries()   const    { return max_particles;                              } //!< Block size
     int    event_number()       const      { return m_hepevtptr->nevhep;             } //!< Get event number
     int    number_entries()     const      { return m_hepevtptr->nhep;               } //!< Get number of entries
     int    status(const int index )  const      { return m_hepevtptr->isthep[index-1];    } //!< Get status code
     int    id(const int index )     const       { return m_hepevtptr->idhep[index-1];     } //!< Get PDG particle id
@@ -133,17 +133,17 @@
 template <int max_particles, typename momentum_type>
 void HEPEVT_Wrapper_Template<max_particles, momentum_type>::copy_to_internal_storage(char *c, int N)
 {
     if ( N < 1 || N > max_particles) return;
     m_internal_storage = std::make_shared<struct HEPEVT_Templated<max_particles, momentum_type>>();
     m_hepevtptr = m_internal_storage.get();
     char* x = c;
-    m_hepevtptr->nevhep=(int)(*x);
+    m_hepevtptr->nevhep = *((int*)x);
     x += sizeof(int);
-    m_hepevtptr->nhep=(int)(*x);
+    m_hepevtptr->nhep = *((int*)x);
     x += sizeof(int);
     memcpy(m_hepevtptr->isthep, x, N*sizeof(int));
     x += sizeof(int)*N;
     memcpy(m_hepevtptr->idhep, x, N*sizeof(int));
     x += sizeof(int)*N;
     memcpy(m_hepevtptr->jmohep, x, 2*N*sizeof(int));
     x += sizeof(int)*N*2;
```

### Comparing `HepMC3-3.2.5/include/HepMC3/LHEF.h` & `HepMC3-3.2.6/include/HepMC3/LHEF.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 // -*- C++ -*-
 #ifndef HEPMC3_LHEF_H
 #define HEPMC3_LHEF_H
 //
 // This is the declaration of the Les Houches Event File classes,
 // implementing a simple C++ parser/writer for Les Houches Event files.
-// Copyright (C) 2009-2013 Leif Lonnblad
+// Copyright (C) 2009-2023 Leif Lonnblad
 //
-// The code is licenced under version 2 of the GPL, see COPYING for details.
+// The code is licenced under LGPLv3+, see COPYING for details.
 // Please respect the MCnet academic guidelines, see GUIDELINES for details.
 //
 
 #include <iostream>
 #include <iomanip>
 #include <sstream>
 #include <fstream>
@@ -2912,14 +2912,15 @@
     return true;
       }
     }
 
     if ( !heprup.eventfiles.empty() &&
          ++curreventfile < int(heprup.eventfiles.size()) ) {
       openeventfile(curreventfile);
+      XMLTag::deleteAll(tags);
       return readEvent();
     }
 
     XMLTag::deleteAll(tags);
     return false;
 
   }
@@ -2985,14 +2986,22 @@
 
   /**
    * The last line read in from the stream in getline().
    */
   std::string currentLine;
 
 public:
+  /**
+   *  initfile rdstate
+   */
+   std::ios_base::iostate initfile_rdstate() const { if (initfile) return initfile->rdstate(); return std::ifstream::goodbit; }
+  /**
+   *  file rdstate
+   */
+   std::ios_base::iostate file_rdstate() const { if (file) return file->rdstate(); return std::ifstream::goodbit; }
 
   /**
    * XML file version
    */
   int version;
 
   /**
```

### Comparing `HepMC3-3.2.5/include/HepMC3/LHEFAttributes.h` & `HepMC3-3.2.6/include/HepMC3/LHEFAttributes.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_LHEFATTRIBUTES_H
 #define HEPMC3_LHEFATTRIBUTES_H
 /**
  *  @file LHEFAttributes.h
  *  @brief Definition of \b class HEPRUPAttribute and \b class HEPEUAttribute
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Print.h` & `HepMC3-3.2.6/include/HepMC3/Print.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_PRINT_H
 #define HEPMC3_PRINT_H
 ///
 /// @file Print.h
 /// @brief Definition of static \b class Print
 ///
```

### Comparing `HepMC3-3.2.5/include/HepMC3/PrintStreams.h` & `HepMC3-3.2.6/include/HepMC3/PrintStreams.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_PRINTSTREAMS_H
 #define HEPMC3_PRINTSTREAMS_H
 ///
 /// @file PrintStreams.h
 /// @brief Implementation of ostreams for the objects
 ///
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Reader.h` & `HepMC3-3.2.6/include/HepMC3/Reader.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READER_H
 #define HEPMC3_READER_H
 ///
 /// @file  Reader.h
 /// @brief Definition of interface \b Reader
 ///
@@ -36,39 +36,31 @@
     /// Fill next event from input into @a evt
     virtual bool read_event(GenEvent& evt) = 0;
     /** @brief Get file and/or stream error state */
     virtual bool failed()=0;
     /** @brief Close file and/or stream */
     virtual void close()=0;
 
-    /// Get the global GenRunInfo object.
-    std::shared_ptr<GenRunInfo> run_info() const {
-        return m_run_info;
-    }
+    /** @brief Get the global GenRunInfo object. */
+    virtual std::shared_ptr<GenRunInfo> run_info() const { return m_run_info; }
 
 ///deleted copy constructor
     Reader(const Reader&) = delete;
 ///deleted copy assignment operator
     Reader& operator = (const Reader &) = delete;
-    /// Set options
-    void set_options(const std::map<std::string, std::string>& options)
-    {
-        m_options=options;
-    }
-    /// Set options
-    std::map<std::string, std::string> get_options() const
-    {
-        return m_options;
-    }
-protected:
+    /** @brief  Set options */
+    virtual void set_options(const std::map<std::string, std::string>& options) { m_options = options; }
+    /** @brief  Get options  */
+    virtual std::map<std::string, std::string> get_options() const { return m_options; }
+//protected:
     /// Set the global GenRunInfo object.
-    void set_run_info(std::shared_ptr<GenRunInfo> run) {
-        m_run_info = run;
-    }
-    /// options
+    virtual void set_run_info(std::shared_ptr<GenRunInfo> run) { m_run_info = run; }
+
+protected:
+    /// Options
     std::map<std::string, std::string> m_options;
 private:
     /// The global GenRunInfo object.
     std::shared_ptr<GenRunInfo> m_run_info;
 };
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderAscii.h` & `HepMC3-3.2.6/include/HepMC3/ReaderAscii.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERASCII_H
 #define HEPMC3_READERASCII_H
 ///
 /// @file  ReaderAscii.h
 /// @brief Definition of class \b ReaderAscii
 ///
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderAsciiHepMC2.h` & `HepMC3-3.2.6/include/HepMC3/ReaderAsciiHepMC2.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READER_ASCII_HEPMC2_H
 #define HEPMC3_READER_ASCII_HEPMC2_H
 /**
  *  @file  ReaderAsciiHepMC2.h
  *  @brief Definition of \b class ReaderAsciiHepMC2
  *
@@ -135,15 +135,15 @@
 
     std::vector<GenVertexPtr>   m_vertex_cache;        //!< Vertex cache
     std::vector<int>            m_vertex_barcodes;     //!< Old vertex barcodes
 
     std::vector<GenParticlePtr> m_particle_cache;      //!< Particle cache
     std::vector<int>            m_end_vertex_barcodes; //!< Old end vertex barcodes
 
-    GenEvent*              m_event_ghost;                      //!< To save particle and verstex attributes.
+    GenEvent*              m_event_ghost = nullptr;                      //!< To save particle and verstex attributes.
     std::vector<GenParticlePtr> m_particle_cache_ghost;//!< Particle cache for attributes
     std::vector<GenVertexPtr>   m_vertex_cache_ghost;        //!< Vertex cache for attributes
 };
 
 } // namespace HepMC3
 
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderFactory.h` & `HepMC3-3.2.6/include/HepMC3/ReaderFactory.h`

 * *Files 20% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERFACTORY_H
 #define HEPMC3_READERFACTORY_H
 
 #include <memory>
 #include <string>
 #include <sys/stat.h>
@@ -31,20 +31,24 @@
  *
  * @todo Too big for inlining: move into a .cc implementation file?
  * @todo Need a DEBUG verbosity flag
  */
 std::shared_ptr<Reader> deduce_reader(const std::string &filename)
 {
     std::string libHepMC3rootIO = "libHepMC3rootIO.so.3";
+    std::string libHepMC3protobufIO = "libHepMC3protobufIO.so.3";
 #if defined(__darwin__) || defined(__APPLE__)
     libHepMC3rootIO = "libHepMC3rootIO.dylib";
+    libHepMC3protobufIO = "libHepMC3protobufIO.dylib";
 #endif
 #if (defined(WIN32) || defined(_WIN32) || defined(__WIN32)) && !defined(__CYGWIN__)
+    libHepMC3protobufIO = "HepMC3protobufIO.dll";
     libHepMC3rootIO = "HepMC3rootIO.dll";
 #endif
+
     bool remote = false;
     bool pipe = false;
     if (filename.find("http://") != std::string::npos)    remote = true;
     if (filename.find("https://") != std::string::npos)   remote = true;
     if (filename.find("root://") != std::string::npos)    remote = true;
     if (filename.find("gsidcap://") != std::string::npos) remote = true;
 
@@ -58,72 +62,74 @@
         if (!(stat (filename.c_str(), &buffer) == 0 && (S_ISFIFO(buffer.st_mode) || S_ISREG(buffer.st_mode) || S_ISLNK(buffer.st_mode))))
 #endif
         {
             HEPMC3_ERROR("deduce_reader: file " << filename << " does not exist or is not a regular file/FIFO/link");
             return std::shared_ptr<Reader> (nullptr);
         }
 
-        std::ifstream* file= new std::ifstream(filename);
+        std::shared_ptr< std::ifstream > file = std::make_shared< std::ifstream >(filename);
         if (!file)
         {
             HEPMC3_ERROR("deduce_reader could not open file for testing HepMC version: " << filename);
             return std::shared_ptr<Reader>(nullptr);
         }
         if (!file->is_open()) {
             HEPMC3_ERROR("deduce_reader could not open file for testing HepMC version: " << filename);
             file->close();
             return std::shared_ptr<Reader>(nullptr);
         }
 
 #if defined(__linux__) || defined(__darwin__)|| defined(__APPLE__) || defined(__FreeBSD__) || defined(__sun)
         pipe = S_ISFIFO(buffer.st_mode);
         if (pipe) {
-            HEPMC3_DEBUG(0, "deduce_reader: the file " << filename << " is a pipe");
-            return deduce_reader(*file);
+            HEPMC3_DEBUG(10, "deduce_reader: the file " << filename << " is a pipe");
+            return deduce_reader(file);
         }
 #endif
 
         std::string line;
         size_t nonempty = 0;
-        while (std::getline(*file, line) && nonempty < 3) {
+        while (std::getline( *(file.get()), line) && nonempty < 3) {
             if (line.empty()) continue;
             nonempty++;
             head.push_back(line);
         }
         file->close();
-        delete file;
     }
     // Assure there are at least two elements in the vector:
     head.push_back("");
     head.push_back("");
-    HEPMC3_DEBUG(0, "deduce_reader: Attempt ReaderRootTree for " << filename);
+    HEPMC3_DEBUG(10, "deduce_reader: Attempt ReaderRootTree for " << filename);
     if ( strncmp(head.at(0).c_str(), "root", 4) == 0 || remote)
         return   std::make_shared<ReaderPlugin>(filename,libHepMC3rootIO,std::string("newReaderRootTreefile"));
     if (!remote)
     {
+        HEPMC3_DEBUG(10, "deduce_reader: Attempt ProtobufIO for " << filename);
+        if ( strncmp(head.at(0).c_str(),"hmpb",4) == 0 )
+            return std::make_shared<ReaderPlugin>(filename,libHepMC3protobufIO,std::string("newReaderprotobuffile"));
 #if HEPMC3_USE_COMPRESSION
-        HEPMC3_DEBUG(0, "Attempt ReaderGZ for " << filename);
+        HEPMC3_DEBUG(10, "Attempt ReaderGZ for " << filename);
         char buf[6];
         snprintf(buf,6,"%s",head.at(0).c_str());
         Compression det = detect_compression_type(buf, buf + 6);
         if ( det != Compression::plaintext ) {
-            HEPMC3_DEBUG(0, "Detected supported compression " << std::to_string(det));
+            HEPMC3_DEBUG(10, "Detected supported compression " << std::to_string(det));
             return deduce_reader(std::shared_ptr< std::istream >(new ifstream(filename.c_str())));
         }
 #endif
-        HEPMC3_DEBUG(0, "Attempt ReaderAscii for " << filename);
+        HEPMC3_DEBUG(10, "Attempt ReaderAscii for " << filename);
         if ( strncmp(head.at(0).c_str(),"HepMC::Version",14) == 0 && strncmp(head.at(1).c_str(), "HepMC::Asciiv3", 14) == 0 )
             return std::shared_ptr<Reader>((Reader*) ( new ReaderAscii(filename)));
-        HEPMC3_DEBUG(0, "Attempt ReaderAsciiHepMC2 for " << filename);
+        HEPMC3_DEBUG(10, "Attempt ReaderAsciiHepMC2 for " << filename);
         if ( strncmp(head.at(0).c_str(),"HepMC::Version",14) == 0 && strncmp(head.at(1).c_str(), "HepMC::IO_GenEvent", 18) == 0 )
             return std::shared_ptr<Reader>((Reader*) ( new ReaderAsciiHepMC2(filename)));
-        HEPMC3_DEBUG(0, "Attempt ReaderLHEF for " << filename);
+        HEPMC3_DEBUG(10, "Attempt ReaderLHEF for " << filename);
         if ( strncmp(head.at(0).c_str(), "<LesHouchesEvents", 17) == 0)
             return std::shared_ptr<Reader>((Reader*) ( new ReaderLHEF(filename)));
-        HEPMC3_DEBUG(0, "Attempt ReaderHEPEVT for " << filename);
+        HEPMC3_DEBUG(10, "Attempt ReaderHEPEVT for " << filename);
         std::stringstream st_e(head.at(0).c_str());
         char attr = ' ';
         bool HEPEVT = true;
         int m_i,m_p;
         while (true)
         {
             if (!(st_e >> attr)) {
@@ -136,62 +142,88 @@
                 break;
             }
             HEPEVT=static_cast<bool>(st_e >> m_i >> m_p);
             break;
         }
         if (HEPEVT) return std::shared_ptr<Reader>((Reader*) ( new ReaderHEPEVT(filename)));
     }
-    HEPMC3_DEBUG(0, "deduce_reader: all attempts failed for " << filename);
+    HEPMC3_DEBUG(10, "deduce_reader: all attempts failed for " << filename);
     return std::shared_ptr<Reader>(nullptr);
 }
 
 
 /** @brief This function will deduce the type of input stream based on its content and will return appropriate Reader*/
 std::shared_ptr<Reader> deduce_reader(std::istream &stream)
 {
+    const size_t raw_header_size = 100;
+    std::string raw_header(raw_header_size + 1,'\0');
+    auto fstream = dynamic_cast<std::ifstream*>(&stream);
+    if (fstream) {
+        fstream->read(&(raw_header[0]), raw_header_size);
+    } else {
+        stream.read(&(raw_header[0]), raw_header_size);
+    }
     std::vector<std::string> head;
     head.push_back("");
-    size_t back = 0;
-    size_t backnonempty = 0;
-    while ( (back < 200 && backnonempty < 100) && stream) {
-        char c = stream.get();
-        back++;
+    for ( size_t i = 0; i < raw_header_size; ++i) {
+        const char c = raw_header[i];
+        if (c == '\0') break;
         if (c == '\n') {
-            if (head.back().length() != 0) head.push_back("");
+            if (head.back().length() != 0) {
+                head.push_back("");
+            }
         } else {
             head.back() += c;
-            backnonempty++;
         }
     }
+    head.push_back("");
+    if (fstream)  {
+        for (size_t i = 0; i < raw_header_size; ++i)  { static_cast<std::filebuf*>(fstream->rdbuf())->sungetc(); }
+        HEPMC3_DEBUG(10, "After sungetc() fstream->good()=" + std::to_string(fstream->good()));
+    } else {
+        for (size_t i = 0; i < raw_header_size; ++i)  { stream.rdbuf()->sungetc(); }
+        HEPMC3_DEBUG(10, "After sungetc() stream.good()=" + std::to_string(stream.good()));
+    }
     if (!stream)
     {
         HEPMC3_WARNING("Input stream is too short or invalid.");
         return std::shared_ptr<Reader>(nullptr);
     }
 
-    for (size_t i = 0; i < back; i++)  stream.unget();
+    if ( strncmp(head.at(0).c_str(),"hmpb",4) == 0 )
+    {
+        std::string libHepMC3protobufIO = "libHepMC3protobufIO.so.3";
+#if defined(__darwin__) || defined(__APPLE__)
+        libHepMC3protobufIO = "libHepMC3protobufIO.dylib";
+#endif
+#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32)) && !defined(__CYGWIN__)
+        libHepMC3protobufIO = "HepMC3protobufIO.dll";
+#endif
+
+        return std::make_shared<ReaderPlugin>(stream,libHepMC3protobufIO,std::string("newReaderprotobufstream"));
+    }
 
     if ( strncmp(head.at(0).c_str(), "HepMC::Version", 14) == 0 && strncmp(head.at(1).c_str(), "HepMC::Asciiv3", 14) == 0 )
     {
-        HEPMC3_DEBUG(0, "Attempt ReaderAscii");
+        HEPMC3_DEBUG(10, "Attempt ReaderAscii");
         return std::shared_ptr<Reader>((Reader*) ( new ReaderAscii(stream)));
     }
 
     if ( strncmp(head.at(0).c_str(), "HepMC::Version", 14) == 0 && strncmp(head.at(1).c_str(), "HepMC::IO_GenEvent", 18) == 0 )
     {
-        HEPMC3_DEBUG(0, "Attempt ReaderAsciiHepMC2");
+        HEPMC3_DEBUG(10, "Attempt ReaderAsciiHepMC2");
         return std::shared_ptr<Reader>((Reader*) ( new ReaderAsciiHepMC2(stream)));
     }
 
     if ( strncmp(head.at(0).c_str(), "<LesHouchesEvents", 17) == 0)
     {
-        HEPMC3_DEBUG(0, "Attempt ReaderLHEF");
+        HEPMC3_DEBUG(10, "Attempt ReaderLHEF");
         return std::shared_ptr<Reader>((Reader*) ( new ReaderLHEF(stream)));
     }
-    HEPMC3_DEBUG(0, "Attempt ReaderHEPEVT");
+    HEPMC3_DEBUG(10, "Attempt ReaderHEPEVT");
     std::stringstream st_e(head.at(0).c_str());
     char attr = ' ';
     bool HEPEVT = true;
     int m_i, m_p;
     while (true)
     {
         if (!(st_e >> attr)) {
@@ -203,60 +235,92 @@
             HEPEVT = false;
             break;
         }
         HEPEVT = static_cast<bool>(st_e >> m_i >> m_p);
         break;
     }
     if (HEPEVT) return std::shared_ptr<Reader>((Reader*) ( new ReaderHEPEVT(stream)));
-    HEPMC3_DEBUG(0, "deduce_reader: all attempts failed");
+    HEPMC3_DEBUG(10, "deduce_reader: all attempts failed");
     return std::shared_ptr<Reader>(nullptr);
 }
 /** @brief This function will deduce the type of input stream based on its content and will return appropriate Reader*/
 std::shared_ptr<Reader> deduce_reader(std::shared_ptr<std::istream> stream)
 {
+    if (!stream)
+    {
+        HEPMC3_WARNING("Input stream is too short or invalid.");
+        return std::shared_ptr<Reader>(nullptr);
+    }
+    const size_t raw_header_size = 100;
+    std::string raw_header(raw_header_size + 1,'\0');
+    auto fstream = std::dynamic_pointer_cast<std::ifstream>(stream);
+    if (fstream) {
+        fstream->read(&(raw_header[0]), raw_header_size);
+    } else {
+        stream->read(&(raw_header[0]), raw_header_size);
+    }
     std::vector<std::string> head;
     head.push_back("");
-    size_t back = 0;
-    size_t backnonempty = 0;
-    while ( (back < 200 && backnonempty < 100) && stream) {
-        char c = stream->get();
-        back++;
+    for ( size_t i = 0; i < raw_header_size; ++i) {
+        const char c = raw_header[i];
+        if (c == '\0') break;
         if (c == '\n') {
-            if (head.back().length() != 0) head.push_back("");
+            if (head.back().length() != 0) {
+                head.push_back("");
+            }
         } else {
             head.back() += c;
-            backnonempty++;
         }
     }
+    head.push_back("");
+    if (fstream)  {
+        for (size_t i = 0; i < raw_header_size; ++i)  { static_cast<std::filebuf*>(fstream->rdbuf())->sungetc(); }
+        HEPMC3_DEBUG(10, "After sungetc() fstream->good()="+std::to_string(fstream->good()));
+    } else {
+        for (size_t i = 0; i < raw_header_size; ++i)  { stream->rdbuf()->sungetc(); }
+        HEPMC3_DEBUG(10, "After sungetc() stream->good()="+std::to_string(stream->good()));
+    }
+
     if (!stream)
     {
         HEPMC3_WARNING("Input stream is too short or invalid.");
         return std::shared_ptr<Reader>(nullptr);
     }
 
-    for (size_t i = 0; i < back; i++)  stream->unget();
+    if ( strncmp(head.at(0).c_str(),"hmpb",4) == 0 )
+    {
+        std::string libHepMC3protobufIO = "libHepMC3protobufIO.so.3";
+#if defined(__darwin__) || defined(__APPLE__)
+        libHepMC3protobufIO = "libHepMC3protobufIO.dylib";
+#endif
+#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32)) && !defined(__CYGWIN__)
+        libHepMC3protobufIO = "HepMC3protobufIO.dll";
+#endif
+
+        return std::make_shared<ReaderPlugin>(*stream,libHepMC3protobufIO,std::string("newReaderprotobufstream"));
+    }
 
     if ( strncmp(head.at(0).c_str(), "HepMC::Version", 14) == 0 && strncmp(head.at(1).c_str(), "HepMC::Asciiv3", 14) == 0 )
     {
-        HEPMC3_DEBUG(0, "Attempt ReaderAscii");
+        HEPMC3_DEBUG(10, "Attempt ReaderAscii");
         return std::shared_ptr<Reader>((Reader*) ( new ReaderAscii(stream)));
     }
 
     if ( strncmp(head.at(0).c_str(), "HepMC::Version",14) == 0 && strncmp(head.at(1).c_str(), "HepMC::IO_GenEvent", 18) == 0 )
     {
-        HEPMC3_DEBUG(0, "Attempt ReaderAsciiHepMC2");
+        HEPMC3_DEBUG(10, "Attempt ReaderAsciiHepMC2");
         return std::shared_ptr<Reader>((Reader*) ( new ReaderAsciiHepMC2(stream)));
     }
 
     if ( strncmp(head.at(0).c_str(), "<LesHouchesEvents", 17) == 0)
     {
-        HEPMC3_DEBUG(0, "Attempt ReaderLHEF");
+        HEPMC3_DEBUG(10, "Attempt ReaderLHEF");
         return std::shared_ptr<Reader>((Reader*) ( new ReaderLHEF(stream)));
     }
-    HEPMC3_DEBUG(0, "Attempt ReaderHEPEVT");
+    HEPMC3_DEBUG(10, "Attempt ReaderHEPEVT");
     std::stringstream st_e(head.at(0).c_str());
     char attr = ' ';
     bool HEPEVT = true;
     int m_i,m_p;
     while (true)
     {
         if (!(st_e >> attr)) {
@@ -268,12 +332,12 @@
             HEPEVT = false;
             break;
         }
         HEPEVT = static_cast<bool>(st_e >> m_i >> m_p);
         break;
     }
     if (HEPEVT) return std::shared_ptr<Reader>((Reader*) ( new ReaderHEPEVT(stream)));
-    HEPMC3_DEBUG(0, "deduce_reader: all attempts failed");
+    HEPMC3_DEBUG(10, "deduce_reader: all attempts failed");
     return std::shared_ptr<Reader>(nullptr);
 }
 }
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderGZ.h` & `HepMC3-3.2.6/include/HepMC3/ReaderGZ.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2020 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERGZ_H
 #define HEPMC3_READERGZ_H
 ///
 /// @file  ReaderGZ.h
 /// @brief Definition of class \b ReaderGZ
 ///
@@ -33,15 +33,15 @@
         m_reader = std::make_shared<T>(*(m_zstr.get()));
     }
     /// @brief The ctor to read from stdin
     ReaderGZ(std::istream & is) {
         m_zstr = std::shared_ptr< std::istream >(new istream(is));
         m_reader = std::make_shared<T>(*(m_zstr.get()));
     }
-
+    /// @brief The ctor to read from shared pointer to stream
     ReaderGZ(std::shared_ptr<std::istream> s_stream) {
         m_zstr = s_stream;
         m_reader = std::make_shared<T>(*(m_zstr.get()));
     }
 
     /// @brief Destructor
     ~ReaderGZ() { close(); }
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderHEPEVT.h` & `HepMC3-3.2.6/include/HepMC3/ReaderHEPEVT.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERHEPEVT_H
 #define HEPMC3_READERHEPEVT_H
 /**
  *  @file  ReaderHEPEVT.h
  *  @brief Definition of \b class ReaderHEPEVT
  *
@@ -65,15 +65,15 @@
 
     /** @brief Close file stream */
     void close()  override;
 
     /** @brief Get stream error state */
     bool failed()  override;
 
-    char* hepevtbuffer; //!< Pointer to HEPEVT Fortran common block/C struct
+    char* hepevtbuffer = nullptr; //!< Pointer to HEPEVT Fortran common block/C struct
 private:
     std::ifstream m_file; //!< Input file
     std::shared_ptr<std::istream> m_shared_stream; //!< For ctor when reading from temp stream
     std::istream* m_stream; //!< For ctor when reading from stream
     bool m_isstream; //!< toggles usage of m_file or m_stream
     HEPEVT_Wrapper_Template<100000> m_hepevt_interface; //!< Templated HEPEVT interface
 };
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderLHEF.h` & `HepMC3-3.2.6/include/HepMC3/ReaderLHEF.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERLHEF_H
 #define HEPMC3_READERLHEF_H
 /**
  *  @file  ReaderLHEF.h
  *  @brief Definition of \b class ReaderLHEF
  *
@@ -51,13 +51,13 @@
     /** @brief Destructor */
     ~ReaderLHEF() ;
 private:
     void init();                       ///< Init helper
     std::shared_ptr<std::istream> m_shared_stream; ///< Holds temporary stream
     std::shared_ptr<LHEF::Reader> m_reader;            ///< The actual reader
     std::shared_ptr<HEPRUPAttribute> m_hepr; ///< Holder of attributes
-    int m_neve;                         ///< Event counter
-    bool m_failed;                      ///< State of reader
+    int m_neve = 0;                         ///< Event counter
+    bool m_failed = false;                      ///< State of reader
     std::deque<GenEvent> m_storage; ///<storage used for subevents.
 };
 }
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderMT.h` & `HepMC3-3.2.6/include/HepMC3/ReaderMT.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2020 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERMT_H
 #define HEPMC3_READERMT_H
 ///
 /// @file  ReaderMT.h
 /// @brief Definition of class \b ReaderMT
 ///
@@ -25,39 +25,44 @@
 namespace HepMC3 {
 template <class T, size_t m_number_of_threads>  class ReaderMT : public Reader
 {
 private:
     bool m_go_try_cache; //!< Flag to trigger using the cached event
     std::vector< std::shared_ptr<T> > m_readers; //!< Vector of all active readers
     std::vector< std::pair<GenEvent, bool> > m_events; //!< Vector of events
-    std::vector< std::thread > m_threads;
+    std::vector< std::thread > m_threads;  //!< Vector of threads
+    /// @brief The reading function
     static void read_function(std::pair<GenEvent,bool>& e, std::shared_ptr<T> r)
     {
         e.second = r->read_event(e.first);
         r->skip(m_number_of_threads-1);
         if (r->failed()) r->close();
     }
 public:
+    /// @brief Constructor
     ReaderMT(const std::string& filename): m_go_try_cache(true) {
         m_events.reserve(m_number_of_threads);
         m_readers.reserve(m_number_of_threads);
         m_threads.reserve(m_number_of_threads);
         for (size_t i = 0; i < m_number_of_threads; ++i) {
             m_readers.push_back(std::make_shared<T>(filename));
             m_readers.back()->skip(m_number_of_threads-1-i);
         }
     }
+    /// @brief Destructor
     ~ReaderMT() {
         m_readers.clear();
         m_events.clear();
         m_threads.clear();
     }
+    /// @brief skip
     bool skip(const int) override  {
         return false;///Not implemented
     }
+    /// @brief event reading
     bool read_event(GenEvent& evt)  override {
         if ( !m_events.empty() ) {
             evt = m_events.back().first;
             m_events.pop_back();
             return true;
         }
         m_events.clear();
@@ -82,19 +87,21 @@
             m_go_try_cache = false;
             return false;
         }
         evt = m_events.back().first;
         m_events.pop_back();
         return true;
     }
+    /// @brief failed
     bool failed()  override {
         for (auto& reader: m_readers)    if (reader && !reader->failed()) return false;
         if ( !m_events.empty() ) return false;
         if ( m_go_try_cache ) return false;
         return true;
     }
+    /// @brief close
     void close()   override {
         for (auto& reader: m_readers) if (reader) reader->close();
     }
 };
 }
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/ReaderPlugin.h` & `HepMC3-3.2.6/include/HepMC3/ReaderPlugin.h`

 * *Files 20% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERPLUGIN_H
 #define HEPMC3_READERPLUGIN_H
 /**
  *  @file  ReaderPlugin.h
  *  @brief Definition of \b class ReaderPlugin
  *
@@ -23,21 +23,31 @@
 class ReaderPlugin : public Reader
 {
 public:
     /** @brief Constructor  to read from stream*/
     ReaderPlugin(std::istream & stream,const std::string &libname, const std::string &newreader);
     /** @brief Constructor to read from file*/
     ReaderPlugin(const std::string& filename,const std::string &libname, const std::string &newreader);
+    /** @brief Skip or fast forward reading of some events*/
+    bool skip(const int n) override { if (!m_reader) return false; return m_reader->skip(n); }
     /** @brief Reading event */
     bool read_event(GenEvent& ev)  override {if (!m_reader) return false; return m_reader->read_event(ev);};
     /** @brief Close */
     void close() override { if (!m_reader) return; m_reader->close(); };
     /** @brief State */
     bool failed() override {if (!m_reader) return true; return m_reader->failed();};
+    /** @brief Get the global GenRunInfo object. */
+    std::shared_ptr<GenRunInfo> run_info() const  override  { return m_reader?m_reader->run_info():nullptr; }
+    /** @brief  Set options */
+    void set_options(const std::map<std::string, std::string>& options)  override { if (!m_reader) return; else m_reader->set_options(options); }
+    /** @brief  Get options  */
+    std::map<std::string, std::string> get_options()  const  override { return m_reader?m_reader->get_options(): std::map<std::string, std::string>();  }
     /** @brief Destructor */
     ~ReaderPlugin()  override;
+    /// Set the global GenRunInfo object.
+    void set_run_info(std::shared_ptr<GenRunInfo> run) override { if (!m_reader) return; else m_reader->set_run_info(run); }
 private:
-    Reader* m_reader; ///< The actual reader
-    void*  dll_handle; ///< library handler
+    Reader* m_reader = nullptr; ///< The actual reader
+    void*  dll_handle = nullptr; ///< library handler
 };
 }
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Setup.h` & `HepMC3-3.2.6/include/HepMC3/Setup.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /// @file Setup.h
 /// @brief Definition of \b class Setup
 
 #ifndef HEPMC3_SETUP_H
 #define HEPMC3_SETUP_H
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Units.h` & `HepMC3-3.2.6/include/HepMC3/Units.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_UNITS_H
 #define HEPMC3_UNITS_H
 /**
  *  @file Units.h
  *  @brief Definition of \b class Units
  *
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Version.h` & `HepMC3-3.2.6/include/HepMC3/Version.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_VERSION_H
 #define HEPMC3_VERSION_H
 
 #include <string>
 
 /// HepMC version string
-#define HEPMC3_VERSION "3.02.05"
+#define HEPMC3_VERSION "3.02.06"
 
 /// @brief HepMC version as an integer, HepMC X.Y.Z = 1000000*X + 1000*Y + Z
 ///
 /// Use like "#if HEPMC3_VERSION_CODE < 3001004" for < 3.01.04
-#define HEPMC3_VERSION_CODE 3002005
+#define HEPMC3_VERSION_CODE 3002006
 namespace HepMC3 {
 /// Get the HepMC library version string
 inline std::string version() {
     return HEPMC3_VERSION;
 }
 }
```

### Comparing `HepMC3-3.2.5/include/HepMC3/Writer.h` & `HepMC3-3.2.6/include/HepMC3/Writer.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_WRITER_H
 #define HEPMC3_WRITER_H
 ///
 /// @file  Writer.h
 /// @brief Definition of interface \b Writer
 ///
@@ -35,37 +35,28 @@
     virtual void write_event(const GenEvent &evt) = 0;
     /** @brief Get file and/or stream error state */
     virtual bool failed() = 0;
     /** @brief Close file and/or stream */
     virtual void close() = 0;
 
     /// Set the global GenRunInfo object.
-    void set_run_info(std::shared_ptr<GenRunInfo> run) {
-        m_run_info = run;
-    }
+    virtual void set_run_info(std::shared_ptr<GenRunInfo> run) { m_run_info = run; }
 
     /// Get the global GenRunInfo object.
-    std::shared_ptr<GenRunInfo> run_info() const {
-        return m_run_info;
-    }
+    virtual std::shared_ptr<GenRunInfo> run_info() const { return m_run_info; }
 
 ///deleted copy constructor
     Writer(const Writer&) = delete;
 ///deleted copy assignment operator
     Writer& operator = (const Writer &) = delete;
     /// Set options
-    void set_options(const std::map<std::string, std::string>& options)
-    {
-        m_options=options;
-    }
+    virtual void set_options(const std::map<std::string, std::string>& options) { m_options = options; }
     /// Set options
-    std::map<std::string, std::string> get_options() const
-    {
-        return m_options;
-    }
+    virtual std::map<std::string, std::string> get_options() const { return m_options; }
+
 protected:
 
     /// options
     std::map<std::string, std::string> m_options;
 
 private:
```

### Comparing `HepMC3-3.2.5/include/HepMC3/WriterAscii.h` & `HepMC3-3.2.6/include/HepMC3/WriterAscii.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_WRITERASCII_H
 #define HEPMC3_WRITERASCII_H
 ///
 /// @file  WriterAscii.h
 /// @brief Definition of class \b WriterAscii
 ///
@@ -100,20 +100,20 @@
     /// Since strings can be long (maybe even longer than buffer) they have to be dealt
     /// with separately.
     void write_string( const std::string &str );
 
     /// @brief Write vertex
     ///
     /// Helper routine for writing single vertex to file
-    void write_vertex(ConstGenVertexPtr v);
+    void write_vertex(const ConstGenVertexPtr& v);
 
     /// @brief Write particle
     ///
     /// Helper routine for writing single particle to file
-    void write_particle(ConstGenParticlePtr p, int second_field);
+    void write_particle(const ConstGenParticlePtr& p, int second_field);
 
     /// @}
 
 private:
 
     std::ofstream m_file; //!< Output file
     std::shared_ptr<std::ostream> m_shared_stream;///< Output temp. stream
```

### Comparing `HepMC3-3.2.5/include/HepMC3/WriterAsciiHepMC2.h` & `HepMC3-3.2.6/include/HepMC3/WriterAsciiHepMC2.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_WRITERASCIIHEPMC2_H
 #define HEPMC3_WRITERASCIIHEPMC2_H
 ///
 /// @file  WriterAsciiHepMC2.h
 /// @brief Definition of class \b WriterAsciiHepMC2
 ///
@@ -103,20 +103,20 @@
     /// Since strings can be long (maybe even longer than buffer) they have to be dealt
     /// with separately.
     void write_string(const std::string &str );
 
     /// @brief Write vertex
     ///
     /// Helper routine for writing single vertex to file
-    void write_vertex(ConstGenVertexPtr v);
+    void write_vertex(const ConstGenVertexPtr& v);
 
     /// @brief Write particle
     ///
     /// Helper routine for writing single particle to file
-    void write_particle(ConstGenParticlePtr p, int second_field);
+    void write_particle(const ConstGenParticlePtr& p, int second_field);
 
     /// @}
 
 private:
 
     std::ofstream m_file; //!< Output file
     std::shared_ptr<std::ostream> m_shared_stream;///< Output temp. stream
```

### Comparing `HepMC3-3.2.5/include/HepMC3/WriterGZ.h` & `HepMC3-3.2.6/rootIO/include/HepMC3/WriterRoot.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,66 +1,76 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2020 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
-#ifndef HEPMC3_WRITERGZ_H
-#define HEPMC3_WRITERGZ_H
-///
-/// @file  WriterGZ.h
-/// @brief Definition of class \b WriterGZ
-///
-/// @class HepMC3::WriterGZ
-/// @brief GenEvent I/O serialization for compressed files
-///
-/// @ingroup IO
-///
+#ifndef HEPMC3_WRITERROOT_H
+#define HEPMC3_WRITERROOT_H
+/**
+ *  @file  WriterRoot.h
+ *  @brief Definition of \b class WriterRoot
+ *
+ *  @class HepMC3::WriterRoot
+ *  @brief GenEvent I/O serialization for root files
+ *
+ *  If HepMC was compiled with path to ROOT available, this class can be used
+ *  for root writing in the same manner as with HepMC::WriterAscii class.
+ *
+ *  @ingroup IO
+ *
+ */
 #include <string>
-#include <fstream>
+#include <memory>
 #include "HepMC3/Writer.h"
 #include "HepMC3/GenEvent.h"
-#include "HepMC3/GenRunInfo.h"
-#include "HepMC3/CompressedIO.h"
+#include "HepMC3/Data/GenEventData.h"
+#include "HepMC3/Data/GenRunInfoData.h"
+
+// ROOT header files
+#ifdef __CINT__
+#include "TFile.h"
+#else
+class TFile;
+#endif
+
 namespace HepMC3 {
 
-template <class T, Compression C = Compression::z> class WriterGZ : public Writer  {
+class WriterRoot : public Writer {
+//
+// Constructors
+//
+public:
+    /** @brief Default constructor
+     *  @warning If file exists, it will be overwritten
+     */
+    WriterRoot(const std::string& filename,
+               std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>());
+
+//
+// Functions
+//
 public:
+    /** @brief Write event to file
+     *
+     *  @param[in] evt Event to be serialized
+     */
+    void write_event(const GenEvent &evt) override;
 
-    /// @brief Constructor
-    /// @warning If file already exists, it will be cleared before writing
-    WriterGZ(const std::string& filename, std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>()) {
-        m_zstr = std::shared_ptr< std::ostream >(new ofstream(filename.c_str(), C));
-        m_writer = std::make_shared<T>(*(m_zstr.get()), run);
-    }
-
-    /// @brief Constructor from ostream
-    WriterGZ(std::ostream& stream, std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>()) {
-        m_zstr = std::shared_ptr< std::ostream >(new ostream(stream, C));
-        m_writer = std::make_shared<T>(*(m_zstr.get()), run);
-    }
-
-    /// @brief Destructor
-    ~WriterGZ() {};
-
-    /// @brief Write event to file
-    ///
-    /// @param[in] evt Event to be serialized
-    void write_event(const GenEvent& evt) override { if (m_writer) m_writer->write_event(evt); };
-
-    /// @brief Return status of the stream
-    bool failed() override { if (m_writer) return  m_writer->failed(); return true; };
-
-    /// @brief Close file stream
-    void close() override {
-        if (m_writer)  m_writer->close();
-        m_zstr->flush();
-        if(dynamic_pointer_cast<ofstream>(m_zstr)) dynamic_pointer_cast<ofstream>(m_zstr)->close();
-    }
+    /** @brief Write the GenRunInfo object to file. */
+    void write_run_info();
 
-private:
-    std::shared_ptr< std::ostream > m_zstr;  ///< Stream to write
-    std::shared_ptr<Writer> m_writer; //!< actual writter
+    /** @brief Close file stream */
+    void close() override;
 
+    /** @brief Get stream error state flag */
+    bool failed() override;
+//
+// Fields
+//
+private:
+    TFile* m_file;         //!< File handler
+    int    m_events_count; //!< Events count. Needed to generate unique object name
 };
 
 } // namespace HepMC3
+
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/WriterHEPEVT.h` & `HepMC3-3.2.6/include/HepMC3/WriterHEPEVT.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_WRITERHEPEVT_H
 #define HEPMC3_WRITERHEPEVT_H
 /**
  *  @file  WriterHEPEVT.h
  *  @brief Definition of \b class WriterHEPEVT
  *
@@ -80,14 +80,14 @@
      * "vertices_positions_are_absent" the result if false. True otherwise. */
     bool get_vertices_positions_present() const;
 
 protected:
     std::ofstream m_file; //!< Output file
     std::shared_ptr<std::ostream> m_shared_stream;///< Output temp. stream
     std::ostream* m_stream; //!< Output stream
-    char* hepevtbuffer;   //!< Pointer to HEPEVT Fortran common block/C struct
-    int   m_events_count; //!< Events count. Needed to generate unique object name
+    char* hepevtbuffer = nullptr;   //!< Pointer to HEPEVT Fortran common block/C struct
+    int   m_events_count = 0; //!< Events count. Needed to generate unique object name
     HEPEVT_Wrapper_Template<100000> m_hepevt_interface; //!< Templated HEPEVT interface
 };
 
 } // namespace HepMC3
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/WriterPlugin.h` & `HepMC3-3.2.6/include/HepMC3/WriterPlugin.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_WRITERPLUGIN_H
 #define HEPMC3_WRITERPLUGIN_H
 /**
  *  @file  WriterPlugin.h
  *  @brief Definition of \b class WriterPlugin
  *
@@ -32,15 +32,23 @@
 
     /** @brief Reading event */
     void write_event(const GenEvent& ev)  override {if (!m_writer) return; return m_writer->write_event(ev);};
     /** @brief Close */
     void close() override { if (!m_writer) return; m_writer->close();};
     /** @brief State */
     bool failed() override {if (!m_writer) return true; return m_writer->failed();};
+    /** @brief Get the global GenRunInfo object. */
+    std::shared_ptr<GenRunInfo> run_info()  const override { return m_writer?m_writer->run_info():nullptr; }
+    /** @brief  Set options */
+    void set_options(const std::map<std::string, std::string>& options)  override { if (!m_writer) return; else m_writer->set_options(options); }
+    /** @brief  Get options  */
+    std::map<std::string, std::string> get_options()  const  override { return m_writer?m_writer->get_options(): std::map<std::string, std::string>();  }
+    /// Set the global GenRunInfo object.
+    void set_run_info(std::shared_ptr<GenRunInfo> run) override { if (!m_writer) return; else m_writer->set_run_info(run); }
     /** @brief Destructor */
     ~WriterPlugin()  override;
 private:
-    Writer* m_writer; ///< The actual writer
-    void* dll_handle; ///< library handler
+    Writer* m_writer = nullptr; ///< The actual writer
+    void* dll_handle = nullptr; ///< library handler
 };
 }
 #endif
```

### Comparing `HepMC3-3.2.5/include/HepMC3/bxzstr/LICENSE` & `HepMC3-3.2.6/include/HepMC3/bxzstr/LICENSE`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/include/HepMC3/bxzstr/bxzstr.hpp` & `HepMC3-3.2.6/include/HepMC3/bxzstr/bxzstr.hpp`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/include/HepMC3/bxzstr/bz_stream_wrapper.hpp` & `HepMC3-3.2.6/include/HepMC3/bxzstr/bz_stream_wrapper.hpp`

 * *Files 5% similar despite different names*

```diff
@@ -75,14 +75,15 @@
 	bz_stream::next_out = NULL;//AV new char();
 	bz_stream::next_in = NULL;//AV new char();
 	this->bzalloc = NULL;
 	this->bzfree = NULL;
 	this->opaque = NULL;
 	if (is_input) {
 	    bz_stream::avail_in = 0;
+	    bz_stream::next_in = NULL;
 	    ret = BZ2_bzDecompressInit(this, 0, 0);
 	} else {
 	    //AV bz_stream::next_in = new char();
 	    ret = BZ2_bzCompressInit(this, _level, 0, _wf);
 	}
 	if (ret != BZ_OK) throw bzException(ret);
     }
@@ -90,15 +91,15 @@
 	if (is_input) {
 	    BZ2_bzDecompressEnd(this);
 	} else {
 	    BZ2_bzCompressEnd(this);
 	}
     }
 
-    int decompress(const int) override {
+    int decompress(const int = 0) override {
 	ret = BZ2_bzDecompress(this);
 	if (ret != BZ_OK && ret != BZ_STREAM_END) throw bzException(ret);
 	return ret;
     }
     int compress(const int _flags = BZ_RUN) override {
 	ret = BZ2_bzCompress(this, _flags);
 	if (!ret) throw bzException(ret);
```

### Comparing `HepMC3-3.2.5/include/HepMC3/bxzstr/lzma_stream_wrapper.hpp` & `HepMC3-3.2.6/include/HepMC3/bxzstr/lzma_stream_wrapper.hpp`

 * *Files 0% similar despite different names*

```diff
@@ -82,15 +82,15 @@
 	} else {
 	    ret = lzma_easy_encoder(this, _level, LZMA_CHECK_CRC64);
 	}
 	if (ret != LZMA_OK) throw lzmaException(ret);
     }
     ~lzma_stream_wrapper() { lzma_end(this); }
 
-    int decompress(const int) override {
+    int decompress(const int = 0) override {
 	ret = lzma_code(this, LZMA_RUN);
 	if (ret != LZMA_OK && ret != LZMA_STREAM_END && ret) throw lzmaException(ret);
 	return (int)ret;
     }
     int compress(const int _flags = LZMA_RUN) override {
 	ret = lzma_code(this, (lzma_action)_flags);
 	if (ret != LZMA_OK && ret != LZMA_STREAM_END && ret != LZMA_BUF_ERROR)
```

### Comparing `HepMC3-3.2.5/include/HepMC3/bxzstr/stream_wrapper.hpp` & `HepMC3-3.2.6/include/HepMC3/bxzstr/stream_wrapper.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 
 namespace bxz {
 namespace detail {
 class stream_wrapper {
   private:
   public:
     stream_wrapper() {};
+    stream_wrapper(const bool _isInput, const int _level, const int _flags);
     virtual ~stream_wrapper() = default;
     virtual int decompress(const int _flags = 0) =0;
     virtual int compress(const int _flags = 0) =0;
     virtual bool stream_end() const =0;
     virtual bool done() const =0;
 
     virtual const uint8_t* next_in() const =0;
```

### Comparing `HepMC3-3.2.5/include/HepMC3/bxzstr/strict_fstream.hpp` & `HepMC3-3.2.6/include/HepMC3/bxzstr/strict_fstream.hpp`

 * *Files 0% similar despite different names*

```diff
@@ -129,15 +129,15 @@
     {
         bool peek_failed = true;
         try
         {
             is_p->peek();
             peek_failed = is_p->fail();
         }
-        catch (std::ios_base::failure e) {}
+        catch (std::ios_base::failure &e) {}
         if (peek_failed)
         {
 	    is_p->setstate(std::ios::failbit);
         } else {
 	    is_p->clear();
 	}
     }
```

### Comparing `HepMC3-3.2.5/include/HepMC3/bxzstr/z_stream_wrapper.hpp` & `HepMC3-3.2.6/include/HepMC3/bxzstr/z_stream_wrapper.hpp`

 * *Files 11% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 
 #include "stream_wrapper.hpp"
 
 namespace bxz {
 /// Exception class thrown by failed zlib operations.
 class zException : public std::exception {
   public:
-    zException(const z_stream* zstrm_p, const int ret) : _msg("zlib: ") {
+    zException(const std::string &msg, const int ret) : _msg("zlib: ") {
         switch (ret) {
             case Z_STREAM_ERROR:
 		_msg += "Z_STREAM_ERROR: ";
 		break;
             case Z_DATA_ERROR:
 		_msg += "Z_DATA_ERROR: ";
 		break;
@@ -41,15 +41,15 @@
 		break;
             default:
 		std::ostringstream oss;
 		oss << ret;
 		_msg += "[" + oss.str() + "]: ";
 		break;
         }
-        _msg += zstrm_p->msg;
+        _msg += msg;
     }
     zException(const std::string msg) : _msg(msg) {}
 
     const char * what() const noexcept { return _msg.c_str(); }
 
   private:
     std::string _msg;
@@ -64,38 +64,39 @@
 	z_stream::next_out = Z_NULL;//AV new uint8_t();
 	z_stream::next_in = Z_NULL;//AV new uint8_t();
 	this->zalloc = Z_NULL;
 	this->zfree = Z_NULL;
 	this->opaque = Z_NULL;
 	if (is_input) {
 	    z_stream::avail_in = 0;
+	    z_stream::next_in = Z_NULL;
 	    ret = inflateInit2(this, 15+32);
 	} else {
 	     //AV z_stream::next_in = new uint8_t();
 	    ret = deflateInit2(this, _level, Z_DEFLATED, 15+16, 8, Z_DEFAULT_STRATEGY);
 	}
-	if (ret != Z_OK) throw zException(this, ret);
+	if (ret != Z_OK) throw zException(this->msg, ret);
     }
     ~z_stream_wrapper() {
 	if (is_input) {
 	    inflateEnd(this);
 	} else {
 	    deflateEnd(this);
 	}
     }
 
     int decompress(const int _flags = Z_NO_FLUSH) override {
 	ret = inflate(this, _flags);
-	if (ret != Z_OK && ret != Z_STREAM_END) throw zException(this, ret);
+	if (ret != Z_OK && ret != Z_STREAM_END) throw zException(this->msg, ret);
 	return ret;
     }
     int compress(const int _flags = Z_NO_FLUSH) override {
 	ret = deflate(this, _flags);
 	if (ret != Z_OK && ret != Z_STREAM_END && ret != Z_BUF_ERROR)
-	    throw zException(this, ret);
+	    throw zException(this->msg, ret);
 	return ret;
     }
     bool stream_end() const override { return this->ret == Z_STREAM_END; }
     bool done() const override { return (this->ret == Z_BUF_ERROR || this->stream_end()); }
 
     const uint8_t* next_in() const override { return z_stream::next_in; }
     long avail_in() const override { return z_stream::avail_in; }
```

### Comparing `HepMC3-3.2.5/interfaces/HepMCCompatibility/include/HepMCCompatibility.h` & `HepMC3-3.2.6/interfaces/HepMCCompatibility/include/HepMCCompatibility.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 ///
 /// @file HepMCCompatibility.h
 /// @brief Implementation of compatibility layer (in-memory conversion functions) between HepMC2 and HepMC3
 ///
 #ifndef HEPMCCOMPATIBILITY_H
 #define HEPMCCOMPATIBILITY_H
```

### Comparing `HepMC3-3.2.5/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.cc` & `HepMC3-3.2.6/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.cc`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC3
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
-#ifndef Pythia6_Pythia6ToHepMC3_H
-#define Pythia6_Pythia6ToHepMC3_H
+#ifndef PYTHIA6_PYTHIA6TOHEPMC3_CC
+#define PYTHIA6_PYTHIA6TOHEPMC3_CC
 #if (defined(WIN32) || defined(_WIN32) || defined(__WIN32)) && !defined(__CYGWIN__)
 #define  hepmc3_delete_writer_ HEPMC3_DELETE_WRITER
 #define  hepmc3_convert_event_ HEPMC3_CONVERT_EVENT
 #define  hepmc3_clear_event_ HEPMC3_CLEAR_EVENT
 #define  hepmc3_write_event_ HEPMC3_WRITE_EVENT
 #define  hepmc3_set_cross_section_ HEPMC3_SET_CROSS_SECTION
 #define  hepmc3_set_pdf_info_ HEPMC3_SET_PDF_INFO
@@ -88,15 +88,14 @@
 #include "HepMC3/Writer.h"
 #include "HepMC3/WriterHEPEVT.h"
 #include "HepMC3/WriterAscii.h"
 #include "HepMC3/WriterAsciiHepMC2.h"
 #include "HepMC3/WriterPlugin.h"
 #include "HepMC3/Print.h"
 #include "HepMC3/Attribute.h"
-#include "HepMC3/GenEvent.h"
 #include "HepMC3/GenRunInfo.h"
 using namespace HepMC3;
 #ifndef PYTHIA6HEPEVTSIZE
 #define PYTHIA6HEPEVTSIZE 10000
 #endif
 /** The conversion interface, templated version */
 HEPEVT_Wrapper_Template<PYTHIA6HEPEVTSIZE> hepmc3_gInterface;
@@ -105,15 +104,15 @@
 /** Storage for the GenRunInfo objects associated with the outputs */
 std::map<int, std::shared_ptr<GenRunInfo> >  hepmc3_gGenRunInfos;
 /** Interface to acces the enets from C++, e.g. Rivet */
 GenEvent* hepmc3_gWriters_get_event(const int & position)
 {
     if (hepmc3_gWriters.count(position) == 0) {
         printf("Warning in %s: Writer at position %i does not exist\n", __FUNCTION__, position);
-        return NULL;
+        return nullptr;
     }
     return    hepmc3_gWriters[position].second;
 }
 /** Interfaces for C/Fortran */
 extern "C" {
 
     int hepmc3_delete_writer_(const int & position)
@@ -135,16 +134,19 @@
         }
         if (!hepmc3_gInterface.m_hepevtptr)
         {
             printf("Error in %s: HEPEVT block does not exist\n", __FUNCTION__);
             return 1;
         }
         hepmc3_gWriters[position].second = new GenEvent(Units::GEV, Units::MM);
-        for( int i = 1; i <= hepmc3_gInterface.number_entries(); i++ )
-            if (hepmc3_gInterface.m_hepevtptr->jmohep[i-1][1]<hepmc3_gInterface.m_hepevtptr->jmohep[i-1][0])  hepmc3_gInterface.m_hepevtptr->jmohep[i-1][1] = hepmc3_gInterface.m_hepevtptr->jmohep[i-1][0];
+        for( int i = 1; i <= hepmc3_gInterface.number_entries(); i++ ) {
+            if (hepmc3_gInterface.m_hepevtptr->jmohep[i-1][1]<hepmc3_gInterface.m_hepevtptr->jmohep[i-1][0])  {
+                hepmc3_gInterface.m_hepevtptr->jmohep[i-1][1] = hepmc3_gInterface.m_hepevtptr->jmohep[i-1][0];
+            }
+        }
         hepmc3_gInterface.HEPEVT_to_GenEvent(hepmc3_gWriters[position].second);
         if (hepmc3_gGenRunInfos.count(position)  ==  0) hepmc3_gGenRunInfos[position] = std::make_shared<GenRunInfo>();
         hepmc3_gWriters[position].second->set_run_info(hepmc3_gGenRunInfos[position]);
         hepmc3_gWriters[position].second->weights() = std::vector<double>(hepmc3_gGenRunInfos[position]->weight_names().size(), 1.0);
         return 0;
     }
     int hepmc3_write_event_(const int & position)
@@ -188,17 +190,17 @@
         GenPdfInfoPtr pdf=std::make_shared< GenPdfInfo>();
         pdf->set(parton_id1, parton_id2, x1, x2, scale_in, xf1, xf2, pdf_id1, pdf_id2);
         hepmc3_gWriters[position].second->set_pdf_info(pdf);
         return 0;
     }
     int hepmc3_set_hepevt_address_(int* a)
     {
-      printf("Info in %s: setting /hepevt/ block adress\n", __FUNCTION__);
-      hepmc3_gInterface.set_hepevt_address((char*)a);
-      return 0;
+        printf("Info in %s: setting /hepevt/ block adress\n", __FUNCTION__);
+        hepmc3_gInterface.set_hepevt_address((char*)a);
+        return 0;
     }
     int hepmc3_set_attribute_int_(const int & position, const int & attval, const char* attname)
     {
         if (hepmc3_gWriters.count(position) == 0) {
             printf("Warning in %s: Writer at position %i does not exist\n", __FUNCTION__, position);
             return 1;
         }
@@ -224,16 +226,16 @@
 #ifdef WIN32
         libHepMC3rootIO="HepMC3rootIO.dll";
 #endif
         std::string filename=std::string(ffilename);
         int r_position=position;
         if (r_position == 0)
         {
-            if (hepmc3_gWriters.size() == 0) r_position = 1;
-            if (hepmc3_gWriters.size()  !=  0) r_position = hepmc3_gWriters.rend()->first+1;
+            if (!hepmc3_gWriters.empty()) r_position = 1;
+            if (!hepmc3_gWriters.empty()) r_position = hepmc3_gWriters.rend()->first+1;
         }
         if (hepmc3_gWriters.count(r_position) != 0) {
             printf("Error in %s: Writer at position %i already exists\n", __FUNCTION__, r_position);
             exit(1);
         }
         if (hepmc3_gGenRunInfos.count(r_position) != 0) {
             printf("Warning in %s: RunInfo at position %i already exists\n", __FUNCTION__, r_position);
@@ -271,26 +273,26 @@
     {
         if (hepmc3_gGenRunInfos.count(position) == 0) {
             printf("Warning in %s: RunInfo at position %i does not exist\n", __FUNCTION__, position);
             return 1;
         }
         if (hepmc3_gGenRunInfos[position]->weight_index(std::string(name)) >= 0) return 0;
         std::vector<std::string> weight_names = hepmc3_gGenRunInfos[position]->weight_names();
-        weight_names.push_back(std::string(name));
+        weight_names.emplace_back(name);
         hepmc3_gWriters[position].second->weights().push_back(1.0);
         hepmc3_gGenRunInfos[position]->set_weight_names(weight_names);
         return 0;
     }
     int hepmc3_set_weight_by_index_(const int & position, const double& val, const int & index)
     {
         if (hepmc3_gWriters.count(position) == 0) {
             printf("Warning in %s: Writer at position %i does not exist\n", __FUNCTION__, position);
             return 1;
         }
-        if (hepmc3_gWriters[position].second->weights().size() < index) {
+        if (hepmc3_gWriters[position].second->weights().size() < (unsigned long int)index) {
             printf("Warning in %s: Event has no weight with index %i\n", __FUNCTION__, index);
             return 2;
         }
         hepmc3_gWriters[position].second->weights()[index] = val;
         return 0;
     }
     int hepmc3_set_weight_by_name_(const int & position, const double& val, const char* name)
```

### Comparing `HepMC3-3.2.5/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.inc` & `HepMC3-3.2.6/interfaces/pythia6/include/Pythia6/Pythia6ToHepMC3.inc`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
-C...Copyright (C) 2014-2020 The HepMC collaboration
+C...Copyright (C) 2014-2023 The HepMC collaboration
 C...These variables will be used for conversion. Block size is different
 C...in Pythia6 and in HepMC3, so the most simple portable way is to have
 C... a second block of same size as in HepMC3 and  copy the content of
 C...block directly.
       INTEGER NMXHEPL
       PARAMETER (NMXHEPL=10000)
       COMMON /HEPEVTL/  NEVHEPL,NHEPL,ISTHEPL(NMXHEPL),IDHEPL(NMXHEPL),
```

### Comparing `HepMC3-3.2.5/interfaces/pythia8/include/Pythia8/Pythia8ToHepMC3.h` & `HepMC3-3.2.6/interfaces/pythia8/include/Pythia8/Pythia8ToHepMC3.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 // Part of code was adopted from Pythia8-HepMC interface by Mikhail Kirsanov.
 #ifndef Pythia8_Pythia8ToHepMC3_H
 #define Pythia8_Pythia8ToHepMC3_H
 #ifdef  _MSC_VER
 #pragma message("HepMC3 interface is available in the latest versions of Pythia8, see https://pythia.org. This interface will be removed in the future HepMC3 versions.")
 #else
 #warning "HepMC3 interface is available in the latest versions of Pythia8, see https://pythia.org. This interface will be removed in the future HepMC3 versions."
```

### Comparing `HepMC3-3.2.5/python/CMakeLists.txt` & `HepMC3-3.2.6/python/CMakeLists.txt`

 * *Files 10% similar despite different names*

```diff
@@ -5,17 +5,17 @@
 SET_PROPERTY (GLOBAL PROPERTY CMAKE_ROLE "PROJECT")
 endif()
 set(CMAKE_VERBOSE_MAKEFILE ON)
 
 option(USE_INSTALLED_HEPMC3 "Use HepMC3 bindings as a standalone package" OFF)
 option(RERUN_BINDER "Rerun binder" OFF)
 if (USE_INSTALLED_HEPMC3)
-  set(${PROJECT_NAME}_VERSION 3.2.3)
+  set(${PROJECT_NAME}_VERSION 3.2.6)
   set(THIS_PROJECT_NAME ${PROJECT_NAME})
-  set(THIS_PROJECT_NAME_VERSION 3.2.3)
+  set(THIS_PROJECT_NAME_VERSION 3.2.6)
   option(HEPMC3_ENABLE_TEST "Enable tests" ON)
 
   find_package(HepMC3  REQUIRED  )
   include(CheckCXXCompilerFlag)
 
   include_directories(${HEPMC3_INCLUDE_DIR})
   message(STATUS "HEPMC3_INCLUDE DIR: ${HEPMC3_INCLUDE_DIR}")
@@ -50,15 +50,18 @@
           endif()
           set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${fl}")
         endif()
       endforeach(fl ${ROOT_CXX_FLAGS})
       set(HEPMC3_ROOTIO_LIBRARY ${HEPMC3_ROOTIO_LIB} )
     endif()
   endif()
-
+  if (HEPMC3_PROTOBUFIO_LIB)
+    find_package(Protobuf 2.4 REQUIRED)
+    add_definitions(-DHEPMC3_PROTOBUFIO)
+  endif()
   if (NOT HEPMC3_CXX_STANDARD)
     set(HEPMC3_CXX_STANDARD 11)
   endif()
   set(CMAKE_CXX_STANDARD ${HEPMC3_CXX_STANDARD})
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_CXX_EXTENSIONS OFF)
 #Workarounds for gcc/clang
@@ -107,23 +110,27 @@
   CHECK_CXX_COMPILER_FLAG("-Wno-unused-value" COMPILER_SUPPORTS_-Wno-unused-value)
   if (COMPILER_SUPPORTS_-Wno-unused-value)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unused-value")
   endif()
   set(THIS_PROJECT_NAME pyHepMC3)
   set(THIS_PROJECT_NAME_VERSION ${HEPMC3_VERSION_MAJOR}.${HEPMC3_VERSION_MINOR}.${HEPMC3_VERSION_PATCH})
   set (HEPMC3_LOADABLE_LIBRARIES_DIR ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/)
-  set (HEPMC3_INCLUDE_FLAGS -I${PROJECT_SOURCE_DIR}/include   -I${PROJECT_SOURCE_DIR}/rootIO/include  -I${PROJECT_SOURCE_DIR}/search/include)
-  set (HEPMC3_INCLUDE_DIRECTORIES  ${PROJECT_SOURCE_DIR}/include   ${PROJECT_SOURCE_DIR}/rootIO/include  ${PROJECT_SOURCE_DIR}/search/include)
+  set (HEPMC3_INCLUDE_FLAGS -I${PROJECT_SOURCE_DIR}/include   -I${PROJECT_SOURCE_DIR}/rootIO/include  -I${PROJECT_SOURCE_DIR}/search/include -I${PROJECT_SOURCE_DIR}/protobufIO/include)
+  set (HEPMC3_INCLUDE_DIRECTORIES  ${PROJECT_SOURCE_DIR}/include   ${PROJECT_SOURCE_DIR}/rootIO/include  ${PROJECT_SOURCE_DIR}/search/include ${PROJECT_SOURCE_DIR}/protobufIO/include)
   set ( HEPMC3_LIB HepMC3)
   set ( HEPMC3_SEARCH_LIB HepMC3search)
+  set ( HEPMC3_PROTOBUFIO_LIB HepMC3protobufIO)
   #CMAKE_POSITION_INDEPENDENT_CODE should be ON or the static libraries should be compilled with -fPIC
   #This option should be documented
   if (HEPMC3_USE_STATIC_LIBS_FOR_PYTHON AND HEPMC3_BUILD_STATIC_LIBS)
    set ( HEPMC3_LIB HepMC3_static)
    set ( HEPMC3_SEARCH_LIB HepMC3search_static)
+   if(Protobuf_FOUND)
+     set ( HEPMC3_PROTOBUFIO_LIB HepMC3protobufIO_static)
+   endif()
   endif()
   if(ROOT_FOUND)
     set (HEPMC3_ROOTIO_LIBRARY HepMC3rootIO)
   endif()
 endif()
 
 if (${CMAKE_CXX_COMPILER_ID} MATCHES "Sun*")
@@ -155,72 +162,118 @@
 if(HEPMC3_ENABLE_SEARCH)
   add_definitions(-DHEPMC3_ENABLE_SEARCH)
   configure_file("pyHepMC3.search.egg-info.in" "pyHepMC3.search.egg-info" IMMEDIATE @ONLY)
 endif()
 if(ROOT_FOUND)
   configure_file("pyHepMC3.rootIO.egg-info.in" "pyHepMC3.rootIO.egg-info" IMMEDIATE @ONLY)
 endif()
+if(HEPMC3_ENABLE_PROTOBUFIO)
+  configure_file("pyHepMC3.protobufIO.egg-info.in" "pyHepMC3.protobufIO.egg-info" IMMEDIATE @ONLY)
+endif()
 
 set(autoBN       ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_0.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_1.cpp
                  ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_2.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_3.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_4.cpp
                  ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_5.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_6.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_7.cpp
                  ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_8.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_9.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_10.cpp
                  ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_11.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_12.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_13.cpp
                  ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_14.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_15.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_16.cpp
                  ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_17.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3_18.cpp
 )
 set(autoBNrootIO ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3rootIO.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3rootIO_0.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3rootIO_1.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3rootIO_2.cpp)
 set(autoBNsearch ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3search.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3search_0.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3search_1.cpp)
+set(autoBNprotobufIO ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3protobufIO.cpp ${CMAKE_CURRENT_SOURCE_DIR}/src/pyHepMC3protobufIO_0.cpp )
 set(BN       ${autoBN}       ${CMAKE_CURRENT_SOURCE_DIR}/src/binders.cpp)
 set(BNrootIO ${autoBNrootIO} ${CMAKE_CURRENT_SOURCE_DIR}/src/root_binders.cpp)
 set(BNsearch ${autoBNsearch} ${CMAKE_CURRENT_SOURCE_DIR}/src/search_binders.cpp)
+set(BNprotobufIO ${autoBNprotobufIO} ${CMAKE_CURRENT_SOURCE_DIR}/src/protobuf_binders.cpp)
 if (RERUN_BINDER)
   find_program (BINDER binder HINTS $ENV{HOME}/bin /usr/bin)
   if(BINDER)
     message(STATUS "HepMC3 python: binder found in ${BINDER}. Automatic generatin of code for python bindings is possible.")
 
     configure_file("all_includes.hpp.in" "all_includes.hpp" IMMEDIATE @ONLY)
     add_custom_command(
       OUTPUT  ${autoBN}
       DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/all_includes.hpp src/pyHepMC3.binder
       COMMAND ${BINDER} --flat --max-file-size=20000
                         --root-module pyHepMC3
                         --prefix "${CMAKE_CURRENT_SOURCE_DIR}/src/"
                         --config src/pyHepMC3.binder   ${CMAKE_CURRENT_BINARY_DIR}/all_includes.hpp
-                        --  -std=c++${HEPMC3_CXX_STANDARD} -I. -I${CMAKE_CURRENT_SOURCE_DIR} -I${CMAKE_CURRENT_SOURCE_DIR}/include ${HEPMC3_INCLUDE_FLAGS}
+                        --  -std=c++${HEPMC3_CXX_STANDARD}
+                             -I.
+                             -I${CMAKE_CURRENT_SOURCE_DIR}
+                             -I${CMAKE_CURRENT_SOURCE_DIR}/include
+                             ${HEPMC3_INCLUDE_FLAGS}
+                             -I/usr/lib/gcc/x86_64-redhat-linux/8/include/
+                             -I/usr/lib/gcc/x86_64-redhat-linux/12/include/
       WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
       VERBATIM
     )
     if(ROOT_FOUND)
       configure_file("root_includes.hpp.in" "root_includes.hpp" IMMEDIATE @ONLY)
       add_custom_command(
         OUTPUT  ${autoBNrootIO}
         DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/root_includes.hpp src/pyHepMC3rootIO.binder
         COMMAND ${BINDER} --flat --max-file-size=5000
                           --root-module pyHepMC3rootIO
                           --prefix "${CMAKE_CURRENT_SOURCE_DIR}/src/"
                           --config src/pyHepMC3rootIO.binder   ${CMAKE_CURRENT_BINARY_DIR}/root_includes.hpp
-                          --  -std=c++${HEPMC3_CXX_STANDARD} -I. -I${CMAKE_CURRENT_SOURCE_DIR} -I${CMAKE_CURRENT_SOURCE_DIR}/include ${HEPMC3_INCLUDE_FLAGS} -I${ROOT_INCLUDE_DIRS}
+                          --  -std=c++${HEPMC3_CXX_STANDARD}
+                          -I.
+                          -I${CMAKE_CURRENT_SOURCE_DIR}
+                          -I${CMAKE_CURRENT_SOURCE_DIR}/include
+                          ${HEPMC3_INCLUDE_FLAGS}
+                          -I${ROOT_INCLUDE_DIRS}
+                          -I/usr/lib/gcc/x86_64-redhat-linux/8/include/
+                          -I/usr/lib/gcc/x86_64-redhat-linux/12/include/
         WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
         VERBATIM
       )
     endif()
     if(HEPMC3_ENABLE_SEARCH)
       configure_file("search_includes.hpp.in" "search_includes.hpp" IMMEDIATE @ONLY)
       add_custom_command(
         OUTPUT  ${autoBNsearch}
         DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/search_includes.hpp src/pyHepMC3search.binder
         COMMAND ${BINDER} --flat --max-file-size=5000
                           --root-module pyHepMC3search
                           --prefix "${CMAKE_CURRENT_SOURCE_DIR}/src/"
                           --config src/pyHepMC3search.binder   ${CMAKE_CURRENT_BINARY_DIR}/search_includes.hpp
-                          -- -std=c++${HEPMC3_CXX_STANDARD} -I. -I${CMAKE_CURRENT_SOURCE_DIR} -I${CMAKE_CURRENT_SOURCE_DIR}/include ${HEPMC3_INCLUDE_FLAGS}
+                          -- -std=c++${HEPMC3_CXX_STANDARD}
+                          -I.
+                          -I${CMAKE_CURRENT_SOURCE_DIR}
+                          -I${CMAKE_CURRENT_SOURCE_DIR}/include
+                          ${HEPMC3_INCLUDE_FLAGS}
+                          -I/usr/lib/gcc/x86_64-redhat-linux/8/include/
+                          -I/usr/lib/gcc/x86_64-redhat-linux/12/include/
         WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
         VERBATIM)
     endif()
+    if(HEPMC3_ENABLE_PROTOBUFIO)
+      configure_file("protobuf_includes.hpp.in" "protobuf_includes.hpp" IMMEDIATE @ONLY)
+      add_custom_command(
+        OUTPUT  ${autoBNprotobufIO}
+        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/protobuf_includes.hpp src/pyHepMC3protobufIO.binder
+        COMMAND ${BINDER} --flat --max-file-size=5000
+                          --root-module pyHepMC3protobufIO
+                          --prefix "${CMAKE_CURRENT_SOURCE_DIR}/src/"
+                          --config src/pyHepMC3protobufIO.binder   ${CMAKE_CURRENT_BINARY_DIR}/protobuf_includes.hpp
+                          -- -std=c++${HEPMC3_CXX_STANDARD}
+                          -I.
+                          -I${CMAKE_CURRENT_SOURCE_DIR}
+                          -I${CMAKE_CURRENT_SOURCE_DIR}/include
+                          -I${CMAKE_CURRENT_SOURCE_DIR}/../protobufIO/include
+                          ${HEPMC3_INCLUDE_FLAGS}
+                          -I${CMAKE_CURRENT_BINARY_DIR}
+                          -I/usr/lib/gcc/x86_64-redhat-linux/8/include/
+                          -I/usr/lib/gcc/x86_64-redhat-linux/12/include/
+        WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
+        VERBATIM)
+    endif()
+
   else()
     message(FATAL_ERROR "HepMC3  python: binder not found!  Automatic generatin of code for python bindings is not possible.")
   endif()
 endif()
 
 macro(bindings ver verminor)
 SET( Python_VERSION_MAJOR "0")
@@ -246,14 +299,15 @@
   set(Python_LIBRARIES         ${PyPy_LIBRARIES})
   set(Python_INCLUDE_DIRS      ${PyPy_INCLUDE_DIRS})
   set(Python_SITEARCH          ${PyPy_SITEARCH})
 endif()
 
 #Compilation with CPython2
 if (${ver} STREQUAL 2)
+  message(STATUS "HepMC3 python: WARNING: The support of Python2 is deprecated and might be removed in the future!")
   unset(Python2_FOUND CACHE)
   unset(Python2_VERSION CACHE)
   unset(Python2_Interpreter_FOUND CACHE)
   unset(Python2_EXECUTABLE CACHE)
   unset(Python2_INCLUDE_DIR CACHE)
   unset(Python2_INCLUDE_DIRS CACHE)
   unset(Python2_LIBRARIES CACHE)
@@ -329,14 +383,21 @@
     if(HEPMC3_ENABLE_SEARCH)
       add_library(pyHepMC3search${Python_VERSION} MODULE  ${BNsearch} )
       set_target_properties(pyHepMC3search${Python_VERSION}
         PROPERTIES
           PREFIX ""
           OUTPUT_NAME pyHepMC3search.pypy-${PyPy_PyPy_VERSION_MAJOR}${PyPy_PyPy_VERSION_MINOR})
     endif()
+    if(HEPMC3_ENABLE_PROTOBUFIO)
+      add_library(pyHepMC3protobufIO${Python_VERSION} MODULE  ${BNprotobufIO} )
+      set_target_properties(pyHepMC3protobufIO${Python_VERSION}
+        PROPERTIES
+          PREFIX ""
+          OUTPUT_NAME pyHepMC3protobufIO.pypy-${PyPy_PyPy_VERSION_MAJOR}${PyPy_PyPy_VERSION_MINOR})
+    endif()
   endif()
 
 #Compilation with CPython2
   if (${ver} STREQUAL 2)
     Python2_add_library(pyHepMC3${Python_VERSION} MODULE  ${BN}   )
     set_target_properties(pyHepMC3${Python_VERSION}
       PROPERTIES  OUTPUT_NAME pyHepMC3  )
@@ -346,14 +407,19 @@
         PROPERTIES  OUTPUT_NAME pyHepMC3rootIO  )
     endif()
     if(HEPMC3_ENABLE_SEARCH)
       Python2_add_library(pyHepMC3search${Python_VERSION} MODULE  ${BNsearch}   )
       set_target_properties(pyHepMC3search${Python_VERSION}
         PROPERTIES  OUTPUT_NAME pyHepMC3search  )
     endif()
+    if(HEPMC3_ENABLE_PROTOBUFIO)
+      Python2_add_library(pyHepMC3protobufIO${Python_VERSION} MODULE  ${BNprotobufIO}   )
+      set_target_properties(pyHepMC3protobufIO${Python_VERSION}
+        PROPERTIES  OUTPUT_NAME pyHepMC3protobufIO  )
+    endif()
   endif()
 
 #Compilation with CPython3
   if (${ver} STREQUAL 3)
     Python3_add_library(pyHepMC3${Python_VERSION} MODULE  ${BN} )
     set_target_properties(pyHepMC3${Python_VERSION}
       PROPERTIES  OUTPUT_NAME pyHepMC3  )
@@ -363,14 +429,19 @@
         PROPERTIES  OUTPUT_NAME pyHepMC3rootIO  )
     endif()
     if(HEPMC3_ENABLE_SEARCH)
       Python3_add_library(pyHepMC3search${Python_VERSION} MODULE  ${BNsearch})
       set_target_properties(pyHepMC3search${Python_VERSION}
         PROPERTIES  OUTPUT_NAME pyHepMC3search  )
     endif()
+    if(HEPMC3_ENABLE_PROTOBUFIO)
+      Python3_add_library(pyHepMC3protobufIO${Python_VERSION} MODULE  ${BNprotobufIO})
+      set_target_properties(pyHepMC3protobufIO${Python_VERSION}
+        PROPERTIES  OUTPUT_NAME pyHepMC3protobufIO  )
+    endif()
   endif()
   set_target_properties(pyHepMC3${Python_VERSION}
     PROPERTIES
       LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/$<0:>
       MODULE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/$<0:>
       ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/$<0:>)
   target_link_libraries(pyHepMC3${Python_VERSION}
@@ -397,15 +468,25 @@
         MODULE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/search/$<0:>
         ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/search/$<0:>)
     target_link_libraries(pyHepMC3search${Python_VERSION}
       PUBLIC  ${HEPMC3_LIB} ${HEPMC3_SEARCH_LIB} )
     target_include_directories(pyHepMC3search${Python_VERSION}
       PUBLIC ${Python_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/include ${HEPMC3_INCLUDE_DIRECTORIES} ${CMAKE_CURRENT_SOURCE_DIR} )
   endif()
-
+  if(HEPMC3_ENABLE_PROTOBUFIO)
+    set_target_properties(pyHepMC3protobufIO${Python_VERSION}
+      PROPERTIES
+        LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/$<0:>
+        MODULE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/$<0:>
+        ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/$<0:>)
+    target_link_libraries(pyHepMC3protobufIO${Python_VERSION}
+      PUBLIC  ${HEPMC3_LIB} ${HEPMC3_PROTOBUFIO_LIB} )
+    target_include_directories(pyHepMC3protobufIO${Python_VERSION}
+      PUBLIC ${Python_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/include ${HEPMC3_INCLUDE_DIRECTORIES} ${CMAKE_CURRENT_SOURCE_DIR} )
+  endif()
   add_custom_target(
         foo${Python_VERSION} ALL
         COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/
         COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_CURRENT_SOURCE_DIR}/src/__init__.py ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/__init__.py
                 )
   if(ROOT_FOUND)
     add_custom_target(
@@ -417,15 +498,22 @@
   if(HEPMC3_ENABLE_SEARCH)
     add_custom_target(
         foosearch${Python_VERSION} ALL
         COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/search/
         COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_CURRENT_SOURCE_DIR}/src/search/__init__.py ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/search/__init__.py
                 )
   endif()
-  message(STATUS "HepMC3 python: For this platforrm CMAKE_SHARED_LIBRARY_PREFIX=${CMAKE_SHARED_LIBRARY_PREFIX}, CMAKE_SHARED_LIBRARY_SUFFIX=${CMAKE_SHARED_LIBRARY_SUFFIX}") 
+  if(HEPMC3_ENABLE_PROTOBUFIO)
+    add_custom_target(
+        fooprotobufIO${Python_VERSION} ALL
+        COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/
+        COMMAND ${CMAKE_COMMAND} -E copy  ${CMAKE_CURRENT_SOURCE_DIR}/src/protobufIO/__init__.py ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/__init__.py
+                )
+  endif()
+  message(STATUS "HepMC3 python: For this platforrm CMAKE_SHARED_LIBRARY_PREFIX=${CMAKE_SHARED_LIBRARY_PREFIX}, CMAKE_SHARED_LIBRARY_SUFFIX=${CMAKE_SHARED_LIBRARY_SUFFIX}")
   message(STATUS "HepMC3 python: For this platforrm CMAKE_IMPORT_LIBRARY_PREFIX=${CMAKE_IMPORT_LIBRARY_PREFIX}, CMAKE_IMPORT_LIBRARY_SUFFIX=${CMAKE_IMPORT_LIBRARY_SUFFIX}")
 
   if (WIN32)
 #Python is insane
     if(HEPMC3_ENABLE_TEST)
         message(STATUS "HepMC3 python: copying ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3${CMAKE_SHARED_LIBRARY_SUFFIX}")
         message(STATUS "HepMC3 python: copying ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/test/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3${CMAKE_SHARED_LIBRARY_SUFFIX}")
@@ -448,14 +536,27 @@
         copysearch${Python_VERSION} ALL
         COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3search${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/search/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3search${CMAKE_SHARED_LIBRARY_SUFFIX}
         COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3search${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/test/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3search${CMAKE_SHARED_LIBRARY_SUFFIX}
         COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3search${CMAKE_IMPORT_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/search/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3search${CMAKE_IMPORT_LIBRARY_SUFFIX}
         COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3search${CMAKE_IMPORT_LIBRARY_SUFFIX} ${CMAKE_CURRENT_SBINARY_DIR}/test/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3search${CMAKE_IMPORT_LIBRARY_SUFFIX}        DEPENDS HepMC3search
                 )
       endif()
+      if(HEPMC3_ENABLE_PROTOBUFIO)
+        message(STATUS "HepMC3 python: copying ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX}")
+        message(STATUS "HepMC3 python: copying ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/test/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX}")
+        message(STATUS "HepMC3 python: copying ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX}")
+        message(STATUS "HepMC3 python: copying ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/test/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX}")
+        add_custom_target(
+        copyprotobufIO${Python_VERSION} ALL
+        COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX}
+        COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/test/${CMAKE_SHARED_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_SHARED_LIBRARY_SUFFIX}
+        COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX} ${CMAKE_CURRENT_BINARY_DIR}/${Python_VERSION}/pyHepMC3/protobufIO/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX}
+        COMMAND ${CMAKE_COMMAND}  -E copy  ${HEPMC3_LOADABLE_LIBRARIES_DIR}/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX} ${CMAKE_CURRENT_SBINARY_DIR}/test/${CMAKE_IMPORT_LIBRARY_PREFIX}HepMC3protobufIO${CMAKE_IMPORT_LIBRARY_SUFFIX}        DEPENDS HepMC3protobufIO
+                )
+      endif()
     endif()
   endif()
   message(STATUS "HepMC3 python: Tweak HEPMC3_Python_SITEARCH${Python_VERSION_MAJOR}${Python_VERSION_MINOR} option to set the installation path for the python${Python_VERSION_MAJOR}${Python_VERSION_MINOR} bindings.")
   if (WIN32)
     if (NOT HEPMC3_Python_SITEARCH${Python_VERSION_MAJOR}${Python_VERSION_MINOR})
       set (HEPMC3_Python_SITEARCH ${CMAKE_INSTALL_LIBDIR}/${Python_VERSION})
       message(STATUS "HepMC3 python: HEPMC3_Python_SITEARCH${Python_VERSION_MAJOR}${Python_VERSION_MINOR} defaults to ${HEPMC3_Python_SITEARCH}")
@@ -509,15 +610,26 @@
       DESTINATION  ${HEPMC3_Python_SITEARCH}/pyHepMC3/search
       COMPONENT pythonsearch)
     install(FILES ${CMAKE_CURRENT_BINARY_DIR}/pyHepMC3.search.egg-info
       DESTINATION  ${HEPMC3_Python_SITEARCH}
       RENAME pyHepMC3.search-${THIS_PROJECT_NAME_VERSION}-py${Python_VERSION_MAJOR}.${Python_VERSION_MINOR}.egg-info
       COMPONENT pythonsearch)
   endif()
-
+  if(HEPMC3_ENABLE_PROTOBUFIO)
+    install(TARGETS pyHepMC3protobufIO${Python_VERSION}
+      DESTINATION ${HEPMC3_Python_SITEARCH}/pyHepMC3/protobufIO
+      COMPONENT pythonprotobufIO)
+    install(FILES src/protobufIO/__init__.py
+      DESTINATION  ${HEPMC3_Python_SITEARCH}/pyHepMC3/protobufIO
+      COMPONENT pythonprotobufIO)
+    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/pyHepMC3.protobufIO.egg-info
+      DESTINATION  ${HEPMC3_Python_SITEARCH}
+      RENAME pyHepMC3.protobufIO-${THIS_PROJECT_NAME_VERSION}-py${Python_VERSION_MAJOR}.${Python_VERSION_MINOR}.egg-info
+      COMPONENT pythonprotobufIO)
+  endif()
   set( HepMC_python_tests
         test_IO1
         test_Boost
         test_Print
         test_Polarization
         test_Pythonization_docs
         test_Pythonization_FourVector
@@ -533,28 +645,39 @@
   endif()
   if(ROOT_FOUND)
     list( APPEND HepMC_python_tests test_IO2)
   endif()
   if(HEPMC3_ENABLE_SEARCH)
     list( APPEND HepMC_python_tests test_Pythonization_Search)
   endif()
+  if(HEPMC3_ENABLE_PROTOBUFIO AND Protobuf_FOUND AND NOT WIN32)
+    list( APPEND HepMC_python_tests test_Protobuf)
+  endif()
   if(HEPMC3_ENABLE_TEST)
     if(USE_INSTALLED_HEPMC3)
       ENABLE_TESTING()
     endif()
     file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/test/Pythia8ToHepMC3.py" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/test/")
     file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/test/pyHepMC3TestUtils.py" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/test/")
     foreach ( ptest ${HepMC_python_tests} )
       file(GLOB INPUT${ptest}  "${CMAKE_CURRENT_SOURCE_DIR}/test/input${testname}*" )
       file(COPY ${INPUT${ptest}} DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/test")
       file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/test/${ptest}.py" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/test/")
       add_test(NAME python${Python_VERSION}_${ptest}
         COMMAND ${Python_EXECUTABLE} ${ptest}.py
         WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/test"
       )
+      if(HEPMC3_ENABLE_PROTOBUFIO AND Protobuf_FOUND AND NOT WIN32)
+        get_filename_component(pcdir ${Protobuf_PROTOC_EXECUTABLE} DIRECTORY)
+        SET_TESTS_PROPERTIES(  python${Python_VERSION}_${ptest}
+                  PROPERTIES
+                  ENVIRONMENT
+                  "PATH=${pcdir};${Protobuf_INCLUDE_DIR}/../lib;${Protobuf_INCLUDE_DIR}/../lib64;${Protobuf_INCLUDE_DIR}/../bin;$ENV{PATH}"
+                  )
+      endif()
     endforeach ( ptest ${HepMC_python_tests} )
   endif()
 else()
   message(STATUS "HepMC3 python: Python version ${ver}.${verminor} not found. Python bindings for version ${ver}.${verminor} disabled.")
 endif()
 unset(HEPMC3_Python_SITEARCH)
 endmacro(bindings)
```

### Comparing `HepMC3-3.2.5/python/all_includes.hpp.in` & `HepMC3-3.2.6/python/all_includes.hpp.in`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/include/LICENSE` & `HepMC3-3.2.6/python/include/LICENSE`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/include/pybind11/attr.h` & `HepMC3-3.2.6/python/include/pybind11/attr.h`

 * *Files 5% similar despite different names*

```diff
@@ -8,78 +8,119 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "cast.h"
 
+#include <functional>
+
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /// \addtogroup annotations
 /// @{
 
 /// Annotation for methods
-struct is_method { handle class_; is_method(const handle &c) : class_(c) { } };
+struct is_method {
+    handle class_;
+    explicit is_method(const handle &c) : class_(c) {}
+};
 
 /// Annotation for operators
-struct is_operator { };
+struct is_operator {};
 
 /// Annotation for classes that cannot be subclassed
-struct is_final { };
+struct is_final {};
 
 /// Annotation for parent scope
-struct scope { handle value; scope(const handle &s) : value(s) { } };
+struct scope {
+    handle value;
+    explicit scope(const handle &s) : value(s) {}
+};
 
 /// Annotation for documentation
-struct doc { const char *value; doc(const char *value) : value(value) { } };
+struct doc {
+    const char *value;
+    explicit doc(const char *value) : value(value) {}
+};
 
 /// Annotation for function names
-struct name { const char *value; name(const char *value) : value(value) { } };
+struct name {
+    const char *value;
+    explicit name(const char *value) : value(value) {}
+};
 
 /// Annotation indicating that a function is an overload associated with a given "sibling"
-struct sibling { handle value; sibling(const handle &value) : value(value.ptr()) { } };
+struct sibling {
+    handle value;
+    explicit sibling(const handle &value) : value(value.ptr()) {}
+};
 
 /// Annotation indicating that a class derives from another given type
-template <typename T> struct base {
+template <typename T>
+struct base {
 
-    PYBIND11_DEPRECATED("base<T>() was deprecated in favor of specifying 'T' as a template argument to class_")
-    base() { } // NOLINT(modernize-use-equals-default): breaks MSVC 2015 when adding an attribute
+    PYBIND11_DEPRECATED(
+        "base<T>() was deprecated in favor of specifying 'T' as a template argument to class_")
+    base() {} // NOLINT(modernize-use-equals-default): breaks MSVC 2015 when adding an attribute
 };
 
 /// Keep patient alive while nurse lives
-template <size_t Nurse, size_t Patient> struct keep_alive { };
+template <size_t Nurse, size_t Patient>
+struct keep_alive {};
 
 /// Annotation indicating that a class is involved in a multiple inheritance relationship
-struct multiple_inheritance { };
+struct multiple_inheritance {};
 
 /// Annotation which enables dynamic attributes, i.e. adds `__dict__` to a class
-struct dynamic_attr { };
+struct dynamic_attr {};
 
 /// Annotation which enables the buffer protocol for a type
-struct buffer_protocol { };
+struct buffer_protocol {};
 
 /// Annotation which requests that a special metaclass is created for a type
 struct metaclass {
     handle value;
 
     PYBIND11_DEPRECATED("py::metaclass() is no longer required. It's turned on by default now.")
-    metaclass() { } // NOLINT(modernize-use-equals-default): breaks MSVC 2015 when adding an attribute
+    // NOLINTNEXTLINE(modernize-use-equals-default): breaks MSVC 2015 when adding an attribute
+    metaclass() {}
 
     /// Override pybind11's default metaclass
-    explicit metaclass(handle value) : value(value) { }
+    explicit metaclass(handle value) : value(value) {}
+};
+
+/// Specifies a custom callback with signature `void (PyHeapTypeObject*)` that
+/// may be used to customize the Python type.
+///
+/// The callback is invoked immediately before `PyType_Ready`.
+///
+/// Note: This is an advanced interface, and uses of it may require changes to
+/// work with later versions of pybind11.  You may wish to consult the
+/// implementation of `make_new_python_type` in `detail/classes.h` to understand
+/// the context in which the callback will be run.
+struct custom_type_setup {
+    using callback = std::function<void(PyHeapTypeObject *heap_type)>;
+
+    explicit custom_type_setup(callback value) : value(std::move(value)) {}
+
+    callback value;
 };
 
 /// Annotation that marks a class as local to the module:
-struct module_local { const bool value; constexpr module_local(bool v = true) : value(v) { } };
+struct module_local {
+    const bool value;
+    constexpr explicit module_local(bool v = true) : value(v) {}
+};
 
 /// Annotation to mark enums as an arithmetic type
-struct arithmetic { };
+struct arithmetic {};
 
 /// Mark a function for addition at the beginning of the existing overload chain instead of the end
-struct prepend { };
+struct prepend {};
 
 /** \rst
     A call policy which places one or more guard variables (``Ts...``) around the function call.
 
     For example, this definition:
 
     .. code-block:: cpp
@@ -91,17 +132,21 @@
     .. code-block:: cpp
 
         m.def("foo", [](args...) {
             T scope_guard;
             return foo(args...); // forwarded arguments
         });
  \endrst */
-template <typename... Ts> struct call_guard;
+template <typename... Ts>
+struct call_guard;
 
-template <> struct call_guard<> { using type = detail::void_type; };
+template <>
+struct call_guard<> {
+    using type = detail::void_type;
+};
 
 template <typename T>
 struct call_guard<T> {
     static_assert(std::is_default_constructible<T>::value,
                   "The guard type must be default constructible");
 
     using type = T;
@@ -118,56 +163,58 @@
 /// @} annotations
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 /* Forward declarations */
 enum op_id : int;
 enum op_type : int;
 struct undefined_t;
-template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t> struct op_;
-inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);
+template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t>
+struct op_;
+void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret);
 
 /// Internal data structure which holds metadata about a keyword argument
 struct argument_record {
     const char *name;  ///< Argument name
     const char *descr; ///< Human-readable version of the argument value
     handle value;      ///< Associated Python object
     bool convert : 1;  ///< True if the argument is allowed to convert when loading
     bool none : 1;     ///< True if None is allowed when loading
 
     argument_record(const char *name, const char *descr, handle value, bool convert, bool none)
-        : name(name), descr(descr), value(value), convert(convert), none(none) { }
+        : name(name), descr(descr), value(value), convert(convert), none(none) {}
 };
 
-/// Internal data structure which holds metadata about a bound function (signature, overloads, etc.)
+/// Internal data structure which holds metadata about a bound function (signature, overloads,
+/// etc.)
 struct function_record {
     function_record()
         : is_constructor(false), is_new_style_constructor(false), is_stateless(false),
-          is_operator(false), is_method(false), has_args(false),
-          has_kwargs(false), has_kw_only_args(false), prepend(false) { }
+          is_operator(false), is_method(false), has_args(false), has_kwargs(false),
+          prepend(false) {}
 
     /// Function name
     char *name = nullptr; /* why no C++ strings? They generate heavier code.. */
 
     // User-specified documentation string
     char *doc = nullptr;
 
     /// Human-readable version of the function signature
     char *signature = nullptr;
 
     /// List of registered keyword arguments
     std::vector<argument_record> args;
 
     /// Pointer to lambda function which converts arguments and performs the actual call
-    handle (*impl) (function_call &) = nullptr;
+    handle (*impl)(function_call &) = nullptr;
 
     /// Storage for the wrapped function pointer and captured data, if any
-    void *data[3] = { };
+    void *data[3] = {};
 
     /// Pointer to custom destructor for 'data' (if needed)
-    void (*free_data) (function_record *ptr) = nullptr;
+    void (*free_data)(function_record *ptr) = nullptr;
 
     /// Return value policy associated with this function
     return_value_policy policy = return_value_policy::automatic;
 
     /// True if name == '__init__'
     bool is_constructor : 1;
 
@@ -185,25 +232,23 @@
 
     /// True if the function has a '*args' argument
     bool has_args : 1;
 
     /// True if the function has a '**kwargs' argument
     bool has_kwargs : 1;
 
-    /// True once a 'py::kw_only' is encountered (any following args are keyword-only)
-    bool has_kw_only_args : 1;
-
     /// True if this function is to be inserted at the beginning of the overload resolution chain
     bool prepend : 1;
 
     /// Number of arguments (including py::args and/or py::kwargs, if present)
     std::uint16_t nargs;
 
-    /// Number of trailing arguments (counted in `nargs`) that are keyword-only
-    std::uint16_t nargs_kw_only = 0;
+    /// Number of leading positional arguments, which are terminated by a py::args or py::kwargs
+    /// argument or by a py::kw_only annotation.
+    std::uint16_t nargs_pos = 0;
 
     /// Number of leading arguments (counted in `nargs`) that are positional-only
     std::uint16_t nargs_pos_only = 0;
 
     /// Python method object
     PyMethodDef *def = nullptr;
 
@@ -217,15 +262,15 @@
     function_record *next = nullptr;
 };
 
 /// Special data structure which (temporarily) holds metadata about a bound class
 struct type_record {
     PYBIND11_NOINLINE type_record()
         : multiple_inheritance(false), dynamic_attr(false), buffer_protocol(false),
-          default_holder(true), module_local(false), is_final(false) { }
+          default_holder(true), module_local(false), is_final(false) {}
 
     /// Handle to the parent scope
     handle scope;
 
     /// Name of the class
     const char *name = nullptr;
 
@@ -255,14 +300,17 @@
 
     /// Optional docstring
     const char *doc = nullptr;
 
     /// Custom metaclass (optional)
     handle metaclass;
 
+    /// Custom type setup.
+    custom_type_setup::callback custom_type_setup_callback;
+
     /// Multiple inheritance marker
     bool multiple_inheritance : 1;
 
     /// Does the class manage a __dict__?
     bool dynamic_attr : 1;
 
     /// Does the class implement the buffer protocol?
@@ -273,201 +321,258 @@
 
     /// Is the class definition local to the module shared object?
     bool module_local : 1;
 
     /// Is the class inheritable from python classes?
     bool is_final : 1;
 
-    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *)) {
-        auto base_info = detail::get_type_info(base, false);
+    PYBIND11_NOINLINE void add_base(const std::type_info &base, void *(*caster)(void *) ) {
+        auto *base_info = detail::get_type_info(base, false);
         if (!base_info) {
             std::string tname(base.name());
             detail::clean_type_id(tname);
-            pybind11_fail("generic_type: type \"" + std::string(name) +
-                          "\" referenced unknown base type \"" + tname + "\"");
+            pybind11_fail("generic_type: type \"" + std::string(name)
+                          + "\" referenced unknown base type \"" + tname + "\"");
         }
 
         if (default_holder != base_info->default_holder) {
             std::string tname(base.name());
             detail::clean_type_id(tname);
-            pybind11_fail("generic_type: type \"" + std::string(name) + "\" " +
-                    (default_holder ? "does not have" : "has") +
-                    " a non-default holder type while its base \"" + tname + "\" " +
-                    (base_info->default_holder ? "does not" : "does"));
+            pybind11_fail("generic_type: type \"" + std::string(name) + "\" "
+                          + (default_holder ? "does not have" : "has")
+                          + " a non-default holder type while its base \"" + tname + "\" "
+                          + (base_info->default_holder ? "does not" : "does"));
         }
 
         bases.append((PyObject *) base_info->type);
 
-        if (base_info->type->tp_dictoffset != 0)
+        if (base_info->type->tp_dictoffset != 0) {
             dynamic_attr = true;
+        }
 
-        if (caster)
+        if (caster) {
             base_info->implicit_casts.emplace_back(type, caster);
+        }
     }
 };
 
-inline function_call::function_call(const function_record &f, handle p) :
-        func(f), parent(p) {
+inline function_call::function_call(const function_record &f, handle p) : func(f), parent(p) {
     args.reserve(f.nargs);
     args_convert.reserve(f.nargs);
 }
 
 /// Tag for a new-style `__init__` defined in `detail/init.h`
-struct is_new_style_constructor { };
+struct is_new_style_constructor {};
 
 /**
  * Partial template specializations to process custom attributes provided to
  * cpp_function_ and class_. These are either used to initialize the respective
  * fields in the type_record and function_record data structures or executed at
  * runtime to deal with custom call policies (e.g. keep_alive).
  */
-template <typename T, typename SFINAE = void> struct process_attribute;
+template <typename T, typename SFINAE = void>
+struct process_attribute;
 
-template <typename T> struct process_attribute_default {
+template <typename T>
+struct process_attribute_default {
     /// Default implementation: do nothing
-    static void init(const T &, function_record *) { }
-    static void init(const T &, type_record *) { }
-    static void precall(function_call &) { }
-    static void postcall(function_call &, handle) { }
+    static void init(const T &, function_record *) {}
+    static void init(const T &, type_record *) {}
+    static void precall(function_call &) {}
+    static void postcall(function_call &, handle) {}
 };
 
 /// Process an attribute specifying the function's name
-template <> struct process_attribute<name> : process_attribute_default<name> {
+template <>
+struct process_attribute<name> : process_attribute_default<name> {
     static void init(const name &n, function_record *r) { r->name = const_cast<char *>(n.value); }
 };
 
 /// Process an attribute specifying the function's docstring
-template <> struct process_attribute<doc> : process_attribute_default<doc> {
+template <>
+struct process_attribute<doc> : process_attribute_default<doc> {
     static void init(const doc &n, function_record *r) { r->doc = const_cast<char *>(n.value); }
 };
 
 /// Process an attribute specifying the function's docstring (provided as a C-style string)
-template <> struct process_attribute<const char *> : process_attribute_default<const char *> {
+template <>
+struct process_attribute<const char *> : process_attribute_default<const char *> {
     static void init(const char *d, function_record *r) { r->doc = const_cast<char *>(d); }
     static void init(const char *d, type_record *r) { r->doc = const_cast<char *>(d); }
 };
-template <> struct process_attribute<char *> : process_attribute<const char *> { };
+template <>
+struct process_attribute<char *> : process_attribute<const char *> {};
 
 /// Process an attribute indicating the function's return value policy
-template <> struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {
+template <>
+struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {
     static void init(const return_value_policy &p, function_record *r) { r->policy = p; }
 };
 
-/// Process an attribute which indicates that this is an overloaded function associated with a given sibling
-template <> struct process_attribute<sibling> : process_attribute_default<sibling> {
+/// Process an attribute which indicates that this is an overloaded function associated with a
+/// given sibling
+template <>
+struct process_attribute<sibling> : process_attribute_default<sibling> {
     static void init(const sibling &s, function_record *r) { r->sibling = s.value; }
 };
 
 /// Process an attribute which indicates that this function is a method
-template <> struct process_attribute<is_method> : process_attribute_default<is_method> {
-    static void init(const is_method &s, function_record *r) { r->is_method = true; r->scope = s.class_; }
+template <>
+struct process_attribute<is_method> : process_attribute_default<is_method> {
+    static void init(const is_method &s, function_record *r) {
+        r->is_method = true;
+        r->scope = s.class_;
+    }
 };
 
 /// Process an attribute which indicates the parent scope of a method
-template <> struct process_attribute<scope> : process_attribute_default<scope> {
+template <>
+struct process_attribute<scope> : process_attribute_default<scope> {
     static void init(const scope &s, function_record *r) { r->scope = s.value; }
 };
 
 /// Process an attribute which indicates that this function is an operator
-template <> struct process_attribute<is_operator> : process_attribute_default<is_operator> {
+template <>
+struct process_attribute<is_operator> : process_attribute_default<is_operator> {
     static void init(const is_operator &, function_record *r) { r->is_operator = true; }
 };
 
-template <> struct process_attribute<is_new_style_constructor> : process_attribute_default<is_new_style_constructor> {
-    static void init(const is_new_style_constructor &, function_record *r) { r->is_new_style_constructor = true; }
+template <>
+struct process_attribute<is_new_style_constructor>
+    : process_attribute_default<is_new_style_constructor> {
+    static void init(const is_new_style_constructor &, function_record *r) {
+        r->is_new_style_constructor = true;
+    }
 };
 
-inline void process_kw_only_arg(const arg &a, function_record *r) {
-    if (!a.name || strlen(a.name) == 0)
-        pybind11_fail("arg(): cannot specify an unnamed argument after an kw_only() annotation");
-    ++r->nargs_kw_only;
+inline void check_kw_only_arg(const arg &a, function_record *r) {
+    if (r->args.size() > r->nargs_pos && (!a.name || a.name[0] == '\0')) {
+        pybind11_fail("arg(): cannot specify an unnamed argument after a kw_only() annotation or "
+                      "args() argument");
+    }
+}
+
+inline void append_self_arg_if_needed(function_record *r) {
+    if (r->is_method && r->args.empty()) {
+        r->args.emplace_back("self", nullptr, handle(), /*convert=*/true, /*none=*/false);
+    }
 }
 
 /// Process a keyword argument attribute (*without* a default value)
-template <> struct process_attribute<arg> : process_attribute_default<arg> {
+template <>
+struct process_attribute<arg> : process_attribute_default<arg> {
     static void init(const arg &a, function_record *r) {
-        if (r->is_method && r->args.empty())
-            r->args.emplace_back("self", nullptr, handle(), true /*convert*/, false /*none not allowed*/);
+        append_self_arg_if_needed(r);
         r->args.emplace_back(a.name, nullptr, handle(), !a.flag_noconvert, a.flag_none);
 
-        if (r->has_kw_only_args) process_kw_only_arg(a, r);
+        check_kw_only_arg(a, r);
     }
 };
 
 /// Process a keyword argument attribute (*with* a default value)
-template <> struct process_attribute<arg_v> : process_attribute_default<arg_v> {
+template <>
+struct process_attribute<arg_v> : process_attribute_default<arg_v> {
     static void init(const arg_v &a, function_record *r) {
-        if (r->is_method && r->args.empty())
-            r->args.emplace_back("self", nullptr /*descr*/, handle() /*parent*/, true /*convert*/, false /*none not allowed*/);
+        if (r->is_method && r->args.empty()) {
+            r->args.emplace_back(
+                "self", /*descr=*/nullptr, /*parent=*/handle(), /*convert=*/true, /*none=*/false);
+        }
 
         if (!a.value) {
 #if !defined(NDEBUG)
             std::string descr("'");
-            if (a.name) descr += std::string(a.name) + ": ";
+            if (a.name) {
+                descr += std::string(a.name) + ": ";
+            }
             descr += a.type + "'";
             if (r->is_method) {
-                if (r->name)
-                    descr += " in method '" + (std::string) str(r->scope) + "." + (std::string) r->name + "'";
-                else
+                if (r->name) {
+                    descr += " in method '" + (std::string) str(r->scope) + "."
+                             + (std::string) r->name + "'";
+                } else {
                     descr += " in method of '" + (std::string) str(r->scope) + "'";
+                }
             } else if (r->name) {
                 descr += " in function '" + (std::string) r->name + "'";
             }
-            pybind11_fail("arg(): could not convert default argument "
-                          + descr + " into a Python object (type not registered yet?)");
+            pybind11_fail("arg(): could not convert default argument " + descr
+                          + " into a Python object (type not registered yet?)");
 #else
             pybind11_fail("arg(): could not convert default argument "
                           "into a Python object (type not registered yet?). "
                           "Compile in debug mode for more information.");
 #endif
         }
         r->args.emplace_back(a.name, a.descr, a.value.inc_ref(), !a.flag_noconvert, a.flag_none);
 
-        if (r->has_kw_only_args) process_kw_only_arg(a, r);
+        check_kw_only_arg(a, r);
     }
 };
 
 /// Process a keyword-only-arguments-follow pseudo argument
-template <> struct process_attribute<kw_only> : process_attribute_default<kw_only> {
+template <>
+struct process_attribute<kw_only> : process_attribute_default<kw_only> {
     static void init(const kw_only &, function_record *r) {
-        r->has_kw_only_args = true;
+        append_self_arg_if_needed(r);
+        if (r->has_args && r->nargs_pos != static_cast<std::uint16_t>(r->args.size())) {
+            pybind11_fail("Mismatched args() and kw_only(): they must occur at the same relative "
+                          "argument location (or omit kw_only() entirely)");
+        }
+        r->nargs_pos = static_cast<std::uint16_t>(r->args.size());
     }
 };
 
 /// Process a positional-only-argument maker
-template <> struct process_attribute<pos_only> : process_attribute_default<pos_only> {
+template <>
+struct process_attribute<pos_only> : process_attribute_default<pos_only> {
     static void init(const pos_only &, function_record *r) {
+        append_self_arg_if_needed(r);
         r->nargs_pos_only = static_cast<std::uint16_t>(r->args.size());
+        if (r->nargs_pos_only > r->nargs_pos) {
+            pybind11_fail("pos_only(): cannot follow a py::args() argument");
+        }
+        // It also can't follow a kw_only, but a static_assert in pybind11.h checks that
     }
 };
 
-/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees that)
+/// Process a parent class attribute.  Single inheritance only (class_ itself already guarantees
+/// that)
 template <typename T>
-struct process_attribute<T, enable_if_t<is_pyobject<T>::value>> : process_attribute_default<handle> {
+struct process_attribute<T, enable_if_t<is_pyobject<T>::value>>
+    : process_attribute_default<handle> {
     static void init(const handle &h, type_record *r) { r->bases.append(h); }
 };
 
 /// Process a parent class attribute (deprecated, does not support multiple inheritance)
 template <typename T>
 struct process_attribute<base<T>> : process_attribute_default<base<T>> {
     static void init(const base<T> &, type_record *r) { r->add_base(typeid(T), nullptr); }
 };
 
 /// Process a multiple inheritance attribute
 template <>
 struct process_attribute<multiple_inheritance> : process_attribute_default<multiple_inheritance> {
-    static void init(const multiple_inheritance &, type_record *r) { r->multiple_inheritance = true; }
+    static void init(const multiple_inheritance &, type_record *r) {
+        r->multiple_inheritance = true;
+    }
 };
 
 template <>
 struct process_attribute<dynamic_attr> : process_attribute_default<dynamic_attr> {
     static void init(const dynamic_attr &, type_record *r) { r->dynamic_attr = true; }
 };
 
 template <>
+struct process_attribute<custom_type_setup> {
+    static void init(const custom_type_setup &value, type_record *r) {
+        r->custom_type_setup_callback = value.value;
+    }
+};
+
+template <>
 struct process_attribute<is_final> : process_attribute_default<is_final> {
     static void init(const is_final &, type_record *r) { r->is_final = true; }
 };
 
 template <>
 struct process_attribute<buffer_protocol> : process_attribute_default<buffer_protocol> {
     static void init(const buffer_protocol &, type_record *r) { r->buffer_protocol = true; }
@@ -490,62 +595,81 @@
 };
 
 /// Process an 'arithmetic' attribute for enums (does nothing here)
 template <>
 struct process_attribute<arithmetic> : process_attribute_default<arithmetic> {};
 
 template <typename... Ts>
-struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> { };
+struct process_attribute<call_guard<Ts...>> : process_attribute_default<call_guard<Ts...>> {};
 
 /**
  * Process a keep_alive call policy -- invokes keep_alive_impl during the
  * pre-call handler if both Nurse, Patient != 0 and use the post-call handler
  * otherwise
  */
-template <size_t Nurse, size_t Patient> struct process_attribute<keep_alive<Nurse, Patient>> : public process_attribute_default<keep_alive<Nurse, Patient>> {
+template <size_t Nurse, size_t Patient>
+struct process_attribute<keep_alive<Nurse, Patient>>
+    : public process_attribute_default<keep_alive<Nurse, Patient>> {
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>
-    static void precall(function_call &call) { keep_alive_impl(Nurse, Patient, call, handle()); }
+    static void precall(function_call &call) {
+        keep_alive_impl(Nurse, Patient, call, handle());
+    }
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N != 0 && P != 0, int> = 0>
-    static void postcall(function_call &, handle) { }
+    static void postcall(function_call &, handle) {}
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>
-    static void precall(function_call &) { }
+    static void precall(function_call &) {}
     template <size_t N = Nurse, size_t P = Patient, enable_if_t<N == 0 || P == 0, int> = 0>
-    static void postcall(function_call &call, handle ret) { keep_alive_impl(Nurse, Patient, call, ret); }
+    static void postcall(function_call &call, handle ret) {
+        keep_alive_impl(Nurse, Patient, call, ret);
+    }
 };
 
 /// Recursively iterate over variadic template arguments
-template <typename... Args> struct process_attributes {
-    static void init(const Args&... args, function_record *r) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };
-        ignore_unused(unused);
-    }
-    static void init(const Args&... args, type_record *r) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::init(args, r), 0) ... };
-        ignore_unused(unused);
+template <typename... Args>
+struct process_attributes {
+    static void init(const Args &...args, function_record *r) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);
+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);
+        using expander = int[];
+        (void) expander{
+            0, ((void) process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};
+    }
+    static void init(const Args &...args, type_record *r) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(r);
+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(r);
+        using expander = int[];
+        (void) expander{0,
+                        (process_attribute<typename std::decay<Args>::type>::init(args, r), 0)...};
     }
     static void precall(function_call &call) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::precall(call), 0) ... };
-        ignore_unused(unused);
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call);
+        using expander = int[];
+        (void) expander{0,
+                        (process_attribute<typename std::decay<Args>::type>::precall(call), 0)...};
     }
     static void postcall(function_call &call, handle fn_ret) {
-        int unused[] = { 0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0) ... };
-        ignore_unused(unused);
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(call, fn_ret);
+        PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(fn_ret);
+        using expander = int[];
+        (void) expander{
+            0, (process_attribute<typename std::decay<Args>::type>::postcall(call, fn_ret), 0)...};
     }
 };
 
 template <typename T>
 using is_call_guard = is_instantiation<call_guard, T>;
 
 /// Extract the ``type`` from the first `call_guard` in `Extras...` (or `void_type` if none found)
 template <typename... Extra>
 using extract_guard_t = typename exactly_one_t<is_call_guard, call_guard<>, Extra...>::type;
 
 /// Check the number of named arguments at compile time
 template <typename... Extra,
           size_t named = constexpr_sum(std::is_base_of<arg, Extra>::value...),
-          size_t self  = constexpr_sum(std::is_same<is_method, Extra>::value...)>
+          size_t self = constexpr_sum(std::is_same<is_method, Extra>::value...)>
 constexpr bool expected_num_args(size_t nargs, bool has_args, bool has_kwargs) {
-    return named == 0 || (self + named + has_args + has_kwargs) == nargs;
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(nargs, has_args, has_kwargs);
+    return named == 0 || (self + named + size_t(has_args) + size_t(has_kwargs)) == nargs;
 }
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/buffer_info.h` & `HepMC3-3.2.6/python/include/pybind11/buffer_info.h`

 * *Files 15% similar despite different names*

```diff
@@ -15,132 +15,179 @@
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 // Default, C-style strides
 inline std::vector<ssize_t> c_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {
     auto ndim = shape.size();
     std::vector<ssize_t> strides(ndim, itemsize);
-    if (ndim > 0)
-        for (size_t i = ndim - 1; i > 0; --i)
+    if (ndim > 0) {
+        for (size_t i = ndim - 1; i > 0; --i) {
             strides[i - 1] = strides[i] * shape[i];
+        }
+    }
     return strides;
 }
 
 // F-style strides; default when constructing an array_t with `ExtraFlags & f_style`
 inline std::vector<ssize_t> f_strides(const std::vector<ssize_t> &shape, ssize_t itemsize) {
     auto ndim = shape.size();
     std::vector<ssize_t> strides(ndim, itemsize);
-    for (size_t i = 1; i < ndim; ++i)
+    for (size_t i = 1; i < ndim; ++i) {
         strides[i] = strides[i - 1] * shape[i - 1];
+    }
     return strides;
 }
 
 PYBIND11_NAMESPACE_END(detail)
 
 /// Information record describing a Python buffer object
 struct buffer_info {
     void *ptr = nullptr;          // Pointer to the underlying storage
     ssize_t itemsize = 0;         // Size of individual items in bytes
     ssize_t size = 0;             // Total number of entries
-    std::string format;           // For homogeneous buffers, this should be set to format_descriptor<T>::format()
+    std::string format;           // For homogeneous buffers, this should be set to
+                                  // format_descriptor<T>::format()
     ssize_t ndim = 0;             // Number of dimensions
     std::vector<ssize_t> shape;   // Shape of the tensor (1 entry per dimension)
-    std::vector<ssize_t> strides; // Number of bytes between adjacent entries (for each per dimension)
+    std::vector<ssize_t> strides; // Number of bytes between adjacent entries
+                                  // (for each per dimension)
     bool readonly = false;        // flag to indicate if the underlying storage may be written to
 
     buffer_info() = default;
 
-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in, bool readonly=false)
-    : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),
-      shape(std::move(shape_in)), strides(std::move(strides_in)), readonly(readonly) {
-        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size())
+    buffer_info(void *ptr,
+                ssize_t itemsize,
+                const std::string &format,
+                ssize_t ndim,
+                detail::any_container<ssize_t> shape_in,
+                detail::any_container<ssize_t> strides_in,
+                bool readonly = false)
+        : ptr(ptr), itemsize(itemsize), size(1), format(format), ndim(ndim),
+          shape(std::move(shape_in)), strides(std::move(strides_in)), readonly(readonly) {
+        if (ndim != (ssize_t) shape.size() || ndim != (ssize_t) strides.size()) {
             pybind11_fail("buffer_info: ndim doesn't match shape and/or strides length");
-        for (size_t i = 0; i < (size_t) ndim; ++i)
+        }
+        for (size_t i = 0; i < (size_t) ndim; ++i) {
             size *= shape[i];
+        }
     }
 
     template <typename T>
-    buffer_info(T *ptr, detail::any_container<ssize_t> shape_in, detail::any_container<ssize_t> strides_in, bool readonly=false)
-    : buffer_info(private_ctr_tag(), ptr, sizeof(T), format_descriptor<T>::format(), static_cast<ssize_t>(shape_in->size()), std::move(shape_in), std::move(strides_in), readonly) { }
-
-    buffer_info(void *ptr, ssize_t itemsize, const std::string &format, ssize_t size, bool readonly=false)
-    : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}, readonly) { }
+    buffer_info(T *ptr,
+                detail::any_container<ssize_t> shape_in,
+                detail::any_container<ssize_t> strides_in,
+                bool readonly = false)
+        : buffer_info(private_ctr_tag(),
+                      ptr,
+                      sizeof(T),
+                      format_descriptor<T>::format(),
+                      static_cast<ssize_t>(shape_in->size()),
+                      std::move(shape_in),
+                      std::move(strides_in),
+                      readonly) {}
+
+    buffer_info(void *ptr,
+                ssize_t itemsize,
+                const std::string &format,
+                ssize_t size,
+                bool readonly = false)
+        : buffer_info(ptr, itemsize, format, 1, {size}, {itemsize}, readonly) {}
 
     template <typename T>
-    buffer_info(T *ptr, ssize_t size, bool readonly=false)
-    : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size, readonly) { }
+    buffer_info(T *ptr, ssize_t size, bool readonly = false)
+        : buffer_info(ptr, sizeof(T), format_descriptor<T>::format(), size, readonly) {}
 
     template <typename T>
-    buffer_info(const T *ptr, ssize_t size, bool readonly=true)
-    : buffer_info(const_cast<T*>(ptr), sizeof(T), format_descriptor<T>::format(), size, readonly) { }
+    buffer_info(const T *ptr, ssize_t size, bool readonly = true)
+        : buffer_info(
+            const_cast<T *>(ptr), sizeof(T), format_descriptor<T>::format(), size, readonly) {}
 
     explicit buffer_info(Py_buffer *view, bool ownview = true)
-    : buffer_info(view->buf, view->itemsize, view->format, view->ndim,
+        : buffer_info(
+            view->buf,
+            view->itemsize,
+            view->format,
+            view->ndim,
             {view->shape, view->shape + view->ndim},
             /* Though buffer::request() requests PyBUF_STRIDES, ctypes objects
              * ignore this flag and return a view with NULL strides.
              * When strides are NULL, build them manually.  */
             view->strides
-            ? std::vector<ssize_t>(view->strides, view->strides + view->ndim)
-            : detail::c_strides({view->shape, view->shape + view->ndim}, view->itemsize),
-            view->readonly) {
+                ? std::vector<ssize_t>(view->strides, view->strides + view->ndim)
+                : detail::c_strides({view->shape, view->shape + view->ndim}, view->itemsize),
+            (view->readonly != 0)) {
+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)
         this->m_view = view;
+        // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)
         this->ownview = ownview;
     }
 
     buffer_info(const buffer_info &) = delete;
-    buffer_info& operator=(const buffer_info &) = delete;
+    buffer_info &operator=(const buffer_info &) = delete;
 
-    buffer_info(buffer_info &&other) {
-        (*this) = std::move(other);
-    }
+    buffer_info(buffer_info &&other) noexcept { (*this) = std::move(other); }
 
-    buffer_info& operator=(buffer_info &&rhs) {
+    buffer_info &operator=(buffer_info &&rhs) noexcept {
         ptr = rhs.ptr;
         itemsize = rhs.itemsize;
         size = rhs.size;
         format = std::move(rhs.format);
         ndim = rhs.ndim;
         shape = std::move(rhs.shape);
         strides = std::move(rhs.strides);
         std::swap(m_view, rhs.m_view);
         std::swap(ownview, rhs.ownview);
         readonly = rhs.readonly;
         return *this;
     }
 
     ~buffer_info() {
-        if (m_view && ownview) { PyBuffer_Release(m_view); delete m_view; }
+        if (m_view && ownview) {
+            PyBuffer_Release(m_view);
+            delete m_view;
+        }
     }
 
     Py_buffer *view() const { return m_view; }
     Py_buffer *&view() { return m_view; }
+
 private:
-    struct private_ctr_tag { };
+    struct private_ctr_tag {};
 
-    buffer_info(private_ctr_tag, void *ptr, ssize_t itemsize, const std::string &format, ssize_t ndim,
-                detail::any_container<ssize_t> &&shape_in, detail::any_container<ssize_t> &&strides_in, bool readonly)
-    : buffer_info(ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in), readonly) { }
+    buffer_info(private_ctr_tag,
+                void *ptr,
+                ssize_t itemsize,
+                const std::string &format,
+                ssize_t ndim,
+                detail::any_container<ssize_t> &&shape_in,
+                detail::any_container<ssize_t> &&strides_in,
+                bool readonly)
+        : buffer_info(
+            ptr, itemsize, format, ndim, std::move(shape_in), std::move(strides_in), readonly) {}
 
     Py_buffer *m_view = nullptr;
     bool ownview = false;
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <typename T, typename SFINAE = void> struct compare_buffer_info {
-    static bool compare(const buffer_info& b) {
+template <typename T, typename SFINAE = void>
+struct compare_buffer_info {
+    static bool compare(const buffer_info &b) {
         return b.format == format_descriptor<T>::format() && b.itemsize == (ssize_t) sizeof(T);
     }
 };
 
-template <typename T> struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {
-    static bool compare(const buffer_info& b) {
-        return (size_t) b.itemsize == sizeof(T) && (b.format == format_descriptor<T>::value ||
-            ((sizeof(T) == sizeof(long)) && b.format == (std::is_unsigned<T>::value ? "L" : "l")) ||
-            ((sizeof(T) == sizeof(size_t)) && b.format == (std::is_unsigned<T>::value ? "N" : "n")));
+template <typename T>
+struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {
+    static bool compare(const buffer_info &b) {
+        return (size_t) b.itemsize == sizeof(T)
+               && (b.format == format_descriptor<T>::value
+                   || ((sizeof(T) == sizeof(long))
+                       && b.format == (std::is_unsigned<T>::value ? "L" : "l"))
+                   || ((sizeof(T) == sizeof(size_t))
+                       && b.format == (std::is_unsigned<T>::value ? "N" : "n")));
     }
 };
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/chrono.h` & `HepMC3-3.2.6/python/include/pybind11/chrono.h`

 * *Files 14% similar despite different names*

```diff
@@ -7,185 +7,230 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
+
+#include <chrono>
 #include <cmath>
 #include <ctime>
-#include <chrono>
 #include <datetime.h>
+#include <mutex>
 
 // Backport the PyDateTime_DELTA functions from Python3.3 if required
 #ifndef PyDateTime_DELTA_GET_DAYS
-#define PyDateTime_DELTA_GET_DAYS(o)         (((PyDateTime_Delta*)o)->days)
+#    define PyDateTime_DELTA_GET_DAYS(o) (((PyDateTime_Delta *) o)->days)
 #endif
 #ifndef PyDateTime_DELTA_GET_SECONDS
-#define PyDateTime_DELTA_GET_SECONDS(o)      (((PyDateTime_Delta*)o)->seconds)
+#    define PyDateTime_DELTA_GET_SECONDS(o) (((PyDateTime_Delta *) o)->seconds)
 #endif
 #ifndef PyDateTime_DELTA_GET_MICROSECONDS
-#define PyDateTime_DELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta*)o)->microseconds)
+#    define PyDateTime_DELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta *) o)->microseconds)
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <typename type> class duration_caster {
+template <typename type>
+class duration_caster {
 public:
-    typedef typename type::rep rep;
+    using rep = typename type::rep;
     using period = typename type::period;
 
-    using days = std::chrono::duration<uint_fast32_t, std::ratio<86400>>;
+    // signed 25 bits required by the standard.
+    using days = std::chrono::duration<int_least32_t, std::ratio<86400>>;
 
     bool load(handle src, bool) {
         using namespace std::chrono;
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        if (!src) return false;
+        if (!src) {
+            return false;
+        }
         // If invoked with datetime.delta object
         if (PyDelta_Check(src.ptr())) {
             value = type(duration_cast<duration<rep, period>>(
-                  days(PyDateTime_DELTA_GET_DAYS(src.ptr()))
+                days(PyDateTime_DELTA_GET_DAYS(src.ptr()))
                 + seconds(PyDateTime_DELTA_GET_SECONDS(src.ptr()))
                 + microseconds(PyDateTime_DELTA_GET_MICROSECONDS(src.ptr()))));
             return true;
         }
         // If invoked with a float we assume it is seconds and convert
-        else if (PyFloat_Check(src.ptr())) {
-            value = type(duration_cast<duration<rep, period>>(duration<double>(PyFloat_AsDouble(src.ptr()))));
+        if (PyFloat_Check(src.ptr())) {
+            value = type(duration_cast<duration<rep, period>>(
+                duration<double>(PyFloat_AsDouble(src.ptr()))));
             return true;
         }
-        else return false;
+        return false;
     }
 
     // If this is a duration just return it back
-    static const std::chrono::duration<rep, period>& get_duration(const std::chrono::duration<rep, period> &src) {
+    static const std::chrono::duration<rep, period> &
+    get_duration(const std::chrono::duration<rep, period> &src) {
         return src;
     }
 
     // If this is a time_point get the time_since_epoch
-    template <typename Clock> static std::chrono::duration<rep, period> get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {
+    template <typename Clock>
+    static std::chrono::duration<rep, period>
+    get_duration(const std::chrono::time_point<Clock, std::chrono::duration<rep, period>> &src) {
         return src.time_since_epoch();
     }
 
     static handle cast(const type &src, return_value_policy /* policy */, handle /* parent */) {
         using namespace std::chrono;
 
         // Use overloaded function to get our duration from our source
         // Works out if it is a duration or time_point and get the duration
         auto d = get_duration(src);
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        // Declare these special duration types so the conversions happen with the correct primitive types (int)
+        // Declare these special duration types so the conversions happen with the correct
+        // primitive types (int)
         using dd_t = duration<int, std::ratio<86400>>;
         using ss_t = duration<int, std::ratio<1>>;
         using us_t = duration<int, std::micro>;
 
         auto dd = duration_cast<dd_t>(d);
         auto subd = d - dd;
         auto ss = duration_cast<ss_t>(subd);
         auto us = duration_cast<us_t>(subd - ss);
         return PyDelta_FromDSU(dd.count(), ss.count(), us.count());
     }
 
-    PYBIND11_TYPE_CASTER(type, _("datetime.timedelta"));
+    PYBIND11_TYPE_CASTER(type, const_name("datetime.timedelta"));
 };
 
+inline std::tm *localtime_thread_safe(const std::time_t *time, std::tm *buf) {
+#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || defined(_MSC_VER)
+    if (localtime_s(buf, time))
+        return nullptr;
+    return buf;
+#else
+    static std::mutex mtx;
+    std::lock_guard<std::mutex> lock(mtx);
+    std::tm *tm_ptr = std::localtime(time);
+    if (tm_ptr != nullptr) {
+        *buf = *tm_ptr;
+    }
+    return tm_ptr;
+#endif
+}
+
 // This is for casting times on the system clock into datetime.datetime instances
-template <typename Duration> class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {
+template <typename Duration>
+class type_caster<std::chrono::time_point<std::chrono::system_clock, Duration>> {
 public:
     using type = std::chrono::time_point<std::chrono::system_clock, Duration>;
     bool load(handle src, bool) {
         using namespace std::chrono;
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        if (!src) return false;
+        if (!src) {
+            return false;
+        }
 
         std::tm cal;
         microseconds msecs;
 
         if (PyDateTime_Check(src.ptr())) {
-            cal.tm_sec   = PyDateTime_DATE_GET_SECOND(src.ptr());
-            cal.tm_min   = PyDateTime_DATE_GET_MINUTE(src.ptr());
-            cal.tm_hour  = PyDateTime_DATE_GET_HOUR(src.ptr());
-            cal.tm_mday  = PyDateTime_GET_DAY(src.ptr());
-            cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;
-            cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;
+            cal.tm_sec = PyDateTime_DATE_GET_SECOND(src.ptr());
+            cal.tm_min = PyDateTime_DATE_GET_MINUTE(src.ptr());
+            cal.tm_hour = PyDateTime_DATE_GET_HOUR(src.ptr());
+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());
+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;
+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;
             cal.tm_isdst = -1;
-            msecs        = microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));
+            msecs = microseconds(PyDateTime_DATE_GET_MICROSECOND(src.ptr()));
         } else if (PyDate_Check(src.ptr())) {
-            cal.tm_sec   = 0;
-            cal.tm_min   = 0;
-            cal.tm_hour  = 0;
-            cal.tm_mday  = PyDateTime_GET_DAY(src.ptr());
-            cal.tm_mon   = PyDateTime_GET_MONTH(src.ptr()) - 1;
-            cal.tm_year  = PyDateTime_GET_YEAR(src.ptr()) - 1900;
+            cal.tm_sec = 0;
+            cal.tm_min = 0;
+            cal.tm_hour = 0;
+            cal.tm_mday = PyDateTime_GET_DAY(src.ptr());
+            cal.tm_mon = PyDateTime_GET_MONTH(src.ptr()) - 1;
+            cal.tm_year = PyDateTime_GET_YEAR(src.ptr()) - 1900;
             cal.tm_isdst = -1;
-            msecs        = microseconds(0);
+            msecs = microseconds(0);
         } else if (PyTime_Check(src.ptr())) {
-            cal.tm_sec   = PyDateTime_TIME_GET_SECOND(src.ptr());
-            cal.tm_min   = PyDateTime_TIME_GET_MINUTE(src.ptr());
-            cal.tm_hour  = PyDateTime_TIME_GET_HOUR(src.ptr());
-            cal.tm_mday  = 1;   // This date (day, month, year) = (1, 0, 70)
-            cal.tm_mon   = 0;   // represents 1-Jan-1970, which is the first
-            cal.tm_year  = 70;  // earliest available date for Python's datetime
+            cal.tm_sec = PyDateTime_TIME_GET_SECOND(src.ptr());
+            cal.tm_min = PyDateTime_TIME_GET_MINUTE(src.ptr());
+            cal.tm_hour = PyDateTime_TIME_GET_HOUR(src.ptr());
+            cal.tm_mday = 1;  // This date (day, month, year) = (1, 0, 70)
+            cal.tm_mon = 0;   // represents 1-Jan-1970, which is the first
+            cal.tm_year = 70; // earliest available date for Python's datetime
             cal.tm_isdst = -1;
-            msecs        = microseconds(PyDateTime_TIME_GET_MICROSECOND(src.ptr()));
+            msecs = microseconds(PyDateTime_TIME_GET_MICROSECOND(src.ptr()));
+        } else {
+            return false;
         }
-        else return false;
 
         value = time_point_cast<Duration>(system_clock::from_time_t(std::mktime(&cal)) + msecs);
         return true;
     }
 
-    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src, return_value_policy /* policy */, handle /* parent */) {
+    static handle cast(const std::chrono::time_point<std::chrono::system_clock, Duration> &src,
+                       return_value_policy /* policy */,
+                       handle /* parent */) {
         using namespace std::chrono;
 
         // Lazy initialise the PyDateTime import
-        if (!PyDateTimeAPI) { PyDateTime_IMPORT; }
+        if (!PyDateTimeAPI) {
+            PyDateTime_IMPORT;
+        }
 
-        // Get out microseconds, and make sure they are positive, to avoid bug in eastern hemisphere time zones
-        // (cfr. https://github.com/pybind/pybind11/issues/2417)
+        // Get out microseconds, and make sure they are positive, to avoid bug in eastern
+        // hemisphere time zones (cfr. https://github.com/pybind/pybind11/issues/2417)
         using us_t = duration<int, std::micro>;
         auto us = duration_cast<us_t>(src.time_since_epoch() % seconds(1));
-        if (us.count() < 0)
+        if (us.count() < 0) {
             us += seconds(1);
+        }
 
         // Subtract microseconds BEFORE `system_clock::to_time_t`, because:
-        // > If std::time_t has lower precision, it is implementation-defined whether the value is rounded or truncated.
-        // (https://en.cppreference.com/w/cpp/chrono/system_clock/to_time_t)
-        std::time_t tt = system_clock::to_time_t(time_point_cast<system_clock::duration>(src - us));
-        // this function uses static memory so it's best to copy it out asap just in case
-        // otherwise other code that is using localtime may break this (not just python code)
-        std::tm localtime = *std::localtime(&tt);
-
+        // > If std::time_t has lower precision, it is implementation-defined whether the value is
+        // rounded or truncated. (https://en.cppreference.com/w/cpp/chrono/system_clock/to_time_t)
+        std::time_t tt
+            = system_clock::to_time_t(time_point_cast<system_clock::duration>(src - us));
+
+        std::tm localtime;
+        std::tm *localtime_ptr = localtime_thread_safe(&tt, &localtime);
+        if (!localtime_ptr) {
+            throw cast_error("Unable to represent system_clock in local time");
+        }
         return PyDateTime_FromDateAndTime(localtime.tm_year + 1900,
                                           localtime.tm_mon + 1,
                                           localtime.tm_mday,
                                           localtime.tm_hour,
                                           localtime.tm_min,
                                           localtime.tm_sec,
                                           us.count());
     }
-    PYBIND11_TYPE_CASTER(type, _("datetime.datetime"));
+    PYBIND11_TYPE_CASTER(type, const_name("datetime.datetime"));
 };
 
 // Other clocks that are not the system clock are not measured as datetime.datetime objects
 // since they are not measured on calendar time. So instead we just make them timedeltas
 // Or if they have passed us a time as a float we convert that
-template <typename Clock, typename Duration> class type_caster<std::chrono::time_point<Clock, Duration>>
-: public duration_caster<std::chrono::time_point<Clock, Duration>> {
-};
-
-template <typename Rep, typename Period> class type_caster<std::chrono::duration<Rep, Period>>
-: public duration_caster<std::chrono::duration<Rep, Period>> {
-};
+template <typename Clock, typename Duration>
+class type_caster<std::chrono::time_point<Clock, Duration>>
+    : public duration_caster<std::chrono::time_point<Clock, Duration>> {};
+
+template <typename Rep, typename Period>
+class type_caster<std::chrono::duration<Rep, Period>>
+    : public duration_caster<std::chrono::duration<Rep, Period>> {};
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/complex.h` & `HepMC3-3.2.6/python/include/pybind11/complex.h`

 * *Files 8% similar despite different names*

```diff
@@ -6,60 +6,69 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
+
 #include <complex>
 
 /// glibc defines I as a macro which breaks things, e.g., boost template names
 #ifdef I
-#  undef I
+#    undef I
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
-template <typename T> struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
+template <typename T>
+struct format_descriptor<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
     static constexpr const char c = format_descriptor<T>::c;
-    static constexpr const char value[3] = { 'Z', c, '\0' };
+    static constexpr const char value[3] = {'Z', c, '\0'};
     static std::string format() { return std::string(value); }
 };
 
 #ifndef PYBIND11_CPP17
 
-template <typename T> constexpr const char format_descriptor<
-    std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];
+template <typename T>
+constexpr const char
+    format_descriptor<std::complex<T>,
+                      detail::enable_if_t<std::is_floating_point<T>::value>>::value[3];
 
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <typename T> struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
+template <typename T>
+struct is_fmt_numeric<std::complex<T>, detail::enable_if_t<std::is_floating_point<T>::value>> {
     static constexpr bool value = true;
     static constexpr int index = is_fmt_numeric<T>::index + 3;
 };
 
-template <typename T> class type_caster<std::complex<T>> {
+template <typename T>
+class type_caster<std::complex<T>> {
 public:
     bool load(handle src, bool convert) {
-        if (!src)
+        if (!src) {
             return false;
-        if (!convert && !PyComplex_Check(src.ptr()))
+        }
+        if (!convert && !PyComplex_Check(src.ptr())) {
             return false;
+        }
         Py_complex result = PyComplex_AsCComplex(src.ptr());
         if (result.real == -1.0 && PyErr_Occurred()) {
             PyErr_Clear();
             return false;
         }
         value = std::complex<T>((T) result.real, (T) result.imag);
         return true;
     }
 
-    static handle cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {
+    static handle
+    cast(const std::complex<T> &src, return_value_policy /* policy */, handle /* parent */) {
         return PyComplex_FromDoubles((double) src.real(), (double) src.imag());
     }
 
-    PYBIND11_TYPE_CASTER(std::complex<T>, _("complex"));
+    PYBIND11_TYPE_CASTER(std::complex<T>, const_name("complex"));
 };
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/detail/class.h` & `HepMC3-3.2.6/python/include/pybind11/detail/class.h`

 * *Files 6% similar despite different names*

```diff
@@ -12,20 +12,21 @@
 #include "../attr.h"
 #include "../options.h"
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 #if PY_VERSION_HEX >= 0x03030000 && !defined(PYPY_VERSION)
-#  define PYBIND11_BUILTIN_QUALNAME
-#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)
+#    define PYBIND11_BUILTIN_QUALNAME
+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)
 #else
 // In pre-3.3 Python, we still set __qualname__ so that we can produce reliable function type
 // signatures; in 3.3+ this macro expands to nothing:
-#  define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj) setattr((PyObject *) obj, "__qualname__", nameobj)
+#    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)                                             \
+        setattr((PyObject *) obj, "__qualname__", nameobj)
 #endif
 
 inline std::string get_fully_qualified_tp_name(PyTypeObject *type) {
 #if !defined(PYPY_VERSION)
     return type->tp_name;
 #else
     auto module_name = handle((PyObject *) type).attr("__module__").cast<std::string>();
@@ -50,43 +51,55 @@
 
 /// `pybind11_static_property.__set__()`: Just like the above `__get__()`.
 extern "C" inline int pybind11_static_set(PyObject *self, PyObject *obj, PyObject *value) {
     PyObject *cls = PyType_Check(obj) ? obj : (PyObject *) Py_TYPE(obj);
     return PyProperty_Type.tp_descr_set(self, cls, value);
 }
 
+// Forward declaration to use in `make_static_property_type()`
+inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type);
+
 /** A `static_property` is the same as a `property` but the `__get__()` and `__set__()`
     methods are modified to always use the object type instead of a concrete instance.
     Return value: New reference. */
 inline PyTypeObject *make_static_property_type() {
     constexpr auto *name = "pybind11_static_property";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
+    if (!heap_type) {
         pybind11_fail("make_static_property_type(): error allocating type!");
+    }
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
-#ifdef PYBIND11_BUILTIN_QUALNAME
+#    ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
-#endif
+#    endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = name;
     type->tp_base = type_incref(&PyProperty_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
     type->tp_descr_get = pybind11_static_get;
     type->tp_descr_set = pybind11_static_set;
 
-    if (PyType_Ready(type) < 0)
+    if (PyType_Ready(type) < 0) {
         pybind11_fail("make_static_property_type(): failure in PyType_Ready()!");
+    }
+
+#    if PY_VERSION_HEX >= 0x030C0000
+    // PRE 3.12 FEATURE FREEZE. PLEASE REVIEW AFTER FREEZE.
+    // Since Python-3.12 property-derived types are required to
+    // have dynamic attributes (to set `__doc__`)
+    enable_dynamic_attributes(heap_type);
+#    endif
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     return type;
 }
 
@@ -94,47 +107,50 @@
 
 /** PyPy has some issues with the above C API, so we evaluate Python code instead.
     This function will only be called once so performance isn't really a concern.
     Return value: New reference. */
 inline PyTypeObject *make_static_property_type() {
     auto d = dict();
     PyObject *result = PyRun_String(R"(\
-        class pybind11_static_property(property):
-            def __get__(self, obj, cls):
-                return property.__get__(self, cls, cls)
-
-            def __set__(self, obj, value):
-                cls = obj if isinstance(obj, type) else type(obj)
-                property.__set__(self, cls, value)
-        )", Py_file_input, d.ptr(), d.ptr()
-    );
+class pybind11_static_property(property):
+    def __get__(self, obj, cls):
+        return property.__get__(self, cls, cls)
+
+    def __set__(self, obj, value):
+        cls = obj if isinstance(obj, type) else type(obj)
+        property.__set__(self, cls, value)
+)",
+                                    Py_file_input,
+                                    d.ptr(),
+                                    d.ptr());
     if (result == nullptr)
         throw error_already_set();
     Py_DECREF(result);
     return (PyTypeObject *) d["pybind11_static_property"].cast<object>().release().ptr();
 }
 
 #endif // PYPY
 
 /** Types with static properties need to handle `Type.static_prop = x` in a specific way.
     By default, Python replaces the `static_property` itself, but for wrapped C++ types
     we need to call `static_property.__set__()` in order to propagate the new value to
     the underlying C++ data structure. */
-extern "C" inline int pybind11_meta_setattro(PyObject* obj, PyObject* name, PyObject* value) {
+extern "C" inline int pybind11_meta_setattro(PyObject *obj, PyObject *name, PyObject *value) {
     // Use `_PyType_Lookup()` instead of `PyObject_GetAttr()` in order to get the raw
     // descriptor (`property`) instead of calling `tp_descr_get` (`property.__get__()`).
     PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);
 
     // The following assignment combinations are possible:
     //   1. `Type.static_prop = value`             --> descr_set: `Type.static_prop.__set__(value)`
     //   2. `Type.static_prop = other_static_prop` --> setattro:  replace existing `static_prop`
     //   3. `Type.regular_attribute = value`       --> setattro:  regular attribute assignment
-    const auto static_prop = (PyObject *) get_internals().static_property_type;
-    const auto call_descr_set = descr && PyObject_IsInstance(descr, static_prop)
-                                && !PyObject_IsInstance(value, static_prop);
+    auto *const static_prop = (PyObject *) get_internals().static_property_type;
+    const auto call_descr_set = (descr != nullptr) && (value != nullptr)
+                                && (PyObject_IsInstance(descr, static_prop) != 0)
+                                && (PyObject_IsInstance(value, static_prop) == 0);
     if (call_descr_set) {
         // Call `static_property.__set__()` instead of replacing the `static_property`.
 #if !defined(PYPY_VERSION)
         return Py_TYPE(descr)->tp_descr_set(descr, obj, value);
 #else
         if (PyObject *result = PyObject_CallMethod(descr, "__set__", "OO", obj, value)) {
             Py_DECREF(result);
@@ -158,36 +174,35 @@
  */
 extern "C" inline PyObject *pybind11_meta_getattro(PyObject *obj, PyObject *name) {
     PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);
     if (descr && PyInstanceMethod_Check(descr)) {
         Py_INCREF(descr);
         return descr;
     }
-    else {
-        return PyType_Type.tp_getattro(obj, name);
-    }
+    return PyType_Type.tp_getattro(obj, name);
 }
 #endif
 
 /// metaclass `__call__` function that is used to create all pybind11 objects.
 extern "C" inline PyObject *pybind11_meta_call(PyObject *type, PyObject *args, PyObject *kwargs) {
 
     // use the default metaclass call to create/initialize the object
     PyObject *self = PyType_Type.tp_call(type, args, kwargs);
     if (self == nullptr) {
         return nullptr;
     }
 
     // This must be a pybind11 instance
-    auto instance = reinterpret_cast<detail::instance *>(self);
+    auto *instance = reinterpret_cast<detail::instance *>(self);
 
     // Ensure that the base __init__ function(s) were called
     for (const auto &vh : values_and_holders(instance)) {
         if (!vh.holder_constructed()) {
-            PyErr_Format(PyExc_TypeError, "%.200s.__init__() must be called when overriding __init__",
+            PyErr_Format(PyExc_TypeError,
+                         "%.200s.__init__() must be called when overriding __init__",
                          get_fully_qualified_tp_name(vh.type->type).c_str());
             Py_DECREF(self);
             return nullptr;
         }
     }
 
     return self;
@@ -198,98 +213,105 @@
     auto *type = (PyTypeObject *) obj;
     auto &internals = get_internals();
 
     // A pybind11-registered type will:
     // 1) be found in internals.registered_types_py
     // 2) have exactly one associated `detail::type_info`
     auto found_type = internals.registered_types_py.find(type);
-    if (found_type != internals.registered_types_py.end() &&
-        found_type->second.size() == 1 &&
-        found_type->second[0]->type == type) {
+    if (found_type != internals.registered_types_py.end() && found_type->second.size() == 1
+        && found_type->second[0]->type == type) {
 
         auto *tinfo = found_type->second[0];
         auto tindex = std::type_index(*tinfo->cpptype);
         internals.direct_conversions.erase(tindex);
 
-        if (tinfo->module_local)
-            registered_local_types_cpp().erase(tindex);
-        else
+        if (tinfo->module_local) {
+            get_local_internals().registered_types_cpp.erase(tindex);
+        } else {
             internals.registered_types_cpp.erase(tindex);
+        }
         internals.registered_types_py.erase(tinfo->type);
 
         // Actually just `std::erase_if`, but that's only available in C++20
         auto &cache = internals.inactive_override_cache;
-        for (auto it = cache.begin(), last = cache.end(); it != last; ) {
-            if (it->first == (PyObject *) tinfo->type)
+        for (auto it = cache.begin(), last = cache.end(); it != last;) {
+            if (it->first == (PyObject *) tinfo->type) {
                 it = cache.erase(it);
-            else
+            } else {
                 ++it;
+            }
         }
 
         delete tinfo;
     }
 
     PyType_Type.tp_dealloc(obj);
 }
 
 /** This metaclass is assigned by default to all pybind11 types and is required in order
     for static properties to function correctly. Users may override this using `py::metaclass`.
     Return value: New reference. */
-inline PyTypeObject* make_default_metaclass() {
+inline PyTypeObject *make_default_metaclass() {
     constexpr auto *name = "pybind11_type";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) PyType_Type.tp_alloc(&PyType_Type, 0);
+    if (!heap_type) {
         pybind11_fail("make_default_metaclass(): error allocating metaclass!");
+    }
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
 #ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
 #endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = name;
     type->tp_base = type_incref(&PyType_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
 
     type->tp_call = pybind11_meta_call;
 
     type->tp_setattro = pybind11_meta_setattro;
 #if PY_MAJOR_VERSION >= 3
     type->tp_getattro = pybind11_meta_getattro;
 #endif
 
     type->tp_dealloc = pybind11_meta_dealloc;
 
-    if (PyType_Ready(type) < 0)
+    if (PyType_Ready(type) < 0) {
         pybind11_fail("make_default_metaclass(): failure in PyType_Ready()!");
+    }
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     return type;
 }
 
 /// For multiple inheritance types we need to recursively register/deregister base pointers for any
 /// base classes with pointers that are difference from the instance value pointer so that we can
-/// correctly recognize an offset base class pointer. This calls a function with any offset base ptrs.
-inline void traverse_offset_bases(void *valueptr, const detail::type_info *tinfo, instance *self,
-        bool (*f)(void * /*parentptr*/, instance * /*self*/)) {
+/// correctly recognize an offset base class pointer. This calls a function with any offset base
+/// ptrs.
+inline void traverse_offset_bases(void *valueptr,
+                                  const detail::type_info *tinfo,
+                                  instance *self,
+                                  bool (*f)(void * /*parentptr*/, instance * /*self*/)) {
     for (handle h : reinterpret_borrow<tuple>(tinfo->type->tp_bases)) {
-        if (auto parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {
+        if (auto *parent_tinfo = get_type_info((PyTypeObject *) h.ptr())) {
             for (auto &c : parent_tinfo->implicit_casts) {
                 if (c.first == tinfo->cpptype) {
                     auto *parentptr = c.second(valueptr);
-                    if (parentptr != valueptr)
+                    if (parentptr != valueptr) {
                         f(parentptr, self);
+                    }
                     traverse_offset_bases(parentptr, parent_tinfo, self, f);
                     break;
                 }
             }
         }
     }
 }
@@ -308,44 +330,44 @@
         }
     }
     return false;
 }
 
 inline void register_instance(instance *self, void *valptr, const type_info *tinfo) {
     register_instance_impl(valptr, self);
-    if (!tinfo->simple_ancestors)
+    if (!tinfo->simple_ancestors) {
         traverse_offset_bases(valptr, tinfo, self, register_instance_impl);
+    }
 }
 
 inline bool deregister_instance(instance *self, void *valptr, const type_info *tinfo) {
     bool ret = deregister_instance_impl(valptr, self);
-    if (!tinfo->simple_ancestors)
+    if (!tinfo->simple_ancestors) {
         traverse_offset_bases(valptr, tinfo, self, deregister_instance_impl);
+    }
     return ret;
 }
 
-/// Instance creation function for all pybind11 types. It allocates the internal instance layout for
-/// holding C++ objects and holders.  Allocation is done lazily (the first time the instance is cast
-/// to a reference or pointer), and initialization is done by an `__init__` function.
+/// Instance creation function for all pybind11 types. It allocates the internal instance layout
+/// for holding C++ objects and holders.  Allocation is done lazily (the first time the instance is
+/// cast to a reference or pointer), and initialization is done by an `__init__` function.
 inline PyObject *make_new_instance(PyTypeObject *type) {
 #if defined(PYPY_VERSION)
-    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first inherited
-    // object is a a plain Python type (i.e. not derived from an extension type).  Fix it.
+    // PyPy gets tp_basicsize wrong (issue 2482) under multiple inheritance when the first
+    // inherited object is a plain Python type (i.e. not derived from an extension type).  Fix it.
     ssize_t instance_size = static_cast<ssize_t>(sizeof(instance));
     if (type->tp_basicsize < instance_size) {
         type->tp_basicsize = instance_size;
     }
 #endif
     PyObject *self = type->tp_alloc(type, 0);
-    auto inst = reinterpret_cast<instance *>(self);
+    auto *inst = reinterpret_cast<instance *>(self);
     // Allocate the value/holder internals:
     inst->allocate_layout();
 
-    inst->owned = true;
-
     return self;
 }
 
 /// Instance creation function for all pybind11 types. It only allocates space for the
 /// C++ object, but doesn't call the constructor -- an `__init__` function must do that.
 extern "C" inline PyObject *pybind11_object_new(PyTypeObject *type, PyObject *, PyObject *) {
     return make_new_instance(type);
@@ -359,73 +381,81 @@
     std::string msg = get_fully_qualified_tp_name(type) + ": No constructor defined!";
     PyErr_SetString(PyExc_TypeError, msg.c_str());
     return -1;
 }
 
 inline void add_patient(PyObject *nurse, PyObject *patient) {
     auto &internals = get_internals();
-    auto instance = reinterpret_cast<detail::instance *>(nurse);
+    auto *instance = reinterpret_cast<detail::instance *>(nurse);
     instance->has_patients = true;
     Py_INCREF(patient);
     internals.patients[nurse].push_back(patient);
 }
 
 inline void clear_patients(PyObject *self) {
-    auto instance = reinterpret_cast<detail::instance *>(self);
+    auto *instance = reinterpret_cast<detail::instance *>(self);
     auto &internals = get_internals();
     auto pos = internals.patients.find(self);
     assert(pos != internals.patients.end());
     // Clearing the patients can cause more Python code to run, which
     // can invalidate the iterator. Extract the vector of patients
     // from the unordered_map first.
     auto patients = std::move(pos->second);
     internals.patients.erase(pos);
     instance->has_patients = false;
-    for (PyObject *&patient : patients)
+    for (PyObject *&patient : patients) {
         Py_CLEAR(patient);
+    }
 }
 
 /// Clears all internal data from the instance and removes it from registered instances in
 /// preparation for deallocation.
 inline void clear_instance(PyObject *self) {
-    auto instance = reinterpret_cast<detail::instance *>(self);
+    auto *instance = reinterpret_cast<detail::instance *>(self);
 
     // Deallocate any values/holders, if present:
     for (auto &v_h : values_and_holders(instance)) {
         if (v_h) {
 
             // We have to deregister before we call dealloc because, for virtual MI types, we still
             // need to be able to get the parent pointers.
-            if (v_h.instance_registered() && !deregister_instance(instance, v_h.value_ptr(), v_h.type))
-                pybind11_fail("pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
+            if (v_h.instance_registered()
+                && !deregister_instance(instance, v_h.value_ptr(), v_h.type)) {
+                pybind11_fail(
+                    "pybind11_object_dealloc(): Tried to deallocate unregistered instance!");
+            }
 
-            if (instance->owned || v_h.holder_constructed())
+            if (instance->owned || v_h.holder_constructed()) {
                 v_h.type->dealloc(v_h);
+            }
         }
     }
     // Deallocate the value/holder layout internals:
     instance->deallocate_layout();
 
-    if (instance->weakrefs)
+    if (instance->weakrefs) {
         PyObject_ClearWeakRefs(self);
+    }
 
     PyObject **dict_ptr = _PyObject_GetDictPtr(self);
-    if (dict_ptr)
+    if (dict_ptr) {
         Py_CLEAR(*dict_ptr);
+    }
 
-    if (instance->has_patients)
+    if (instance->has_patients) {
         clear_patients(self);
+    }
 }
 
 /// Instance destructor function for all pybind11 types. It calls `type_info.dealloc`
 /// to destroy the C++ object itself, while the rest is Python bookkeeping.
 extern "C" inline void pybind11_object_dealloc(PyObject *self) {
     clear_instance(self);
 
-    auto type = Py_TYPE(self);
+    auto *type = Py_TYPE(self);
     type->tp_free(self);
 
 #if PY_VERSION_HEX < 0x03080000
     // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called
     // as part of a derived type's dealloc, in which case we're not allowed to decref
     // the type here. For cross-module compatibility, we shouldn't compare directly
     // with `pybind11_object_dealloc`, but with the common one stashed in internals.
@@ -446,59 +476,63 @@
     constexpr auto *name = "pybind11_object";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
+    if (!heap_type) {
         pybind11_fail("make_object_base_type(): error allocating type!");
+    }
 
     heap_type->ht_name = name_obj.inc_ref().ptr();
 #ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = name_obj.inc_ref().ptr();
 #endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = name;
     type->tp_base = type_incref(&PyBaseObject_Type);
     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
 
     type->tp_new = pybind11_object_new;
     type->tp_init = pybind11_object_init;
     type->tp_dealloc = pybind11_object_dealloc;
 
     /* Support weak references (needed for the keep_alive feature) */
     type->tp_weaklistoffset = offsetof(instance, weakrefs);
 
-    if (PyType_Ready(type) < 0)
+    if (PyType_Ready(type) < 0) {
         pybind11_fail("PyType_Ready failed in make_object_base_type():" + error_string());
+    }
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     assert(!PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
     return (PyObject *) heap_type;
 }
 
 /// dynamic_attr: Support for `d = instance.__dict__`.
 extern "C" inline PyObject *pybind11_get_dict(PyObject *self, void *) {
     PyObject *&dict = *_PyObject_GetDictPtr(self);
-    if (!dict)
+    if (!dict) {
         dict = PyDict_New();
+    }
     Py_XINCREF(dict);
     return dict;
 }
 
 /// dynamic_attr: Support for `instance.__dict__ = dict()`.
 extern "C" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict, void *) {
     if (!PyDict_Check(new_dict)) {
-        PyErr_Format(PyExc_TypeError, "__dict__ must be set to a dictionary, not a '%.200s'",
+        PyErr_Format(PyExc_TypeError,
+                     "__dict__ must be set to a dictionary, not a '%.200s'",
                      get_fully_qualified_tp_name(Py_TYPE(new_dict)).c_str());
         return -1;
     }
     PyObject *&dict = *_PyObject_GetDictPtr(self);
     Py_INCREF(new_dict);
     Py_CLEAR(dict);
     dict = new_dict;
@@ -517,66 +551,69 @@
     PyObject *&dict = *_PyObject_GetDictPtr(self);
     Py_CLEAR(dict);
     return 0;
 }
 
 /// Give instances of this type a `__dict__` and opt into garbage collection.
 inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type) {
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_flags |= Py_TPFLAGS_HAVE_GC;
-    type->tp_dictoffset = type->tp_basicsize; // place dict at the end
-    type->tp_basicsize += (ssize_t)sizeof(PyObject *); // and allocate enough space for it
+    type->tp_dictoffset = type->tp_basicsize;           // place dict at the end
+    type->tp_basicsize += (ssize_t) sizeof(PyObject *); // and allocate enough space for it
     type->tp_traverse = pybind11_traverse;
     type->tp_clear = pybind11_clear;
 
     static PyGetSetDef getset[] = {
-        {const_cast<char*>("__dict__"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},
-        {nullptr, nullptr, nullptr, nullptr, nullptr}
-    };
+        {const_cast<char *>("__dict__"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},
+        {nullptr, nullptr, nullptr, nullptr, nullptr}};
     type->tp_getset = getset;
 }
 
 /// buffer_protocol: Fill in the view as specified by flags.
 extern "C" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int flags) {
     // Look for a `get_buffer` implementation in this type's info or any bases (following MRO).
     type_info *tinfo = nullptr;
     for (auto type : reinterpret_borrow<tuple>(Py_TYPE(obj)->tp_mro)) {
         tinfo = get_type_info((PyTypeObject *) type.ptr());
-        if (tinfo && tinfo->get_buffer)
+        if (tinfo && tinfo->get_buffer) {
             break;
+        }
     }
     if (view == nullptr || !tinfo || !tinfo->get_buffer) {
-        if (view)
+        if (view) {
             view->obj = nullptr;
+        }
         PyErr_SetString(PyExc_BufferError, "pybind11_getbuffer(): Internal error");
         return -1;
     }
     std::memset(view, 0, sizeof(Py_buffer));
     buffer_info *info = tinfo->get_buffer(obj, tinfo->get_buffer_data);
+    if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {
+        delete info;
+        // view->obj = nullptr;  // Was just memset to 0, so not necessary
+        PyErr_SetString(PyExc_BufferError, "Writable buffer requested for readonly storage");
+        return -1;
+    }
     view->obj = obj;
     view->ndim = 1;
     view->internal = info;
     view->buf = info->ptr;
     view->itemsize = info->itemsize;
     view->len = view->itemsize;
-    for (auto s : info->shape)
+    for (auto s : info->shape) {
         view->len *= s;
-    view->readonly = info->readonly;
-    if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {
-        if (view)
-            view->obj = nullptr;
-        PyErr_SetString(PyExc_BufferError, "Writable buffer requested for readonly storage");
-        return -1;
     }
-    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)
+    view->readonly = static_cast<int>(info->readonly);
+    if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT) {
         view->format = const_cast<char *>(info->format.c_str());
+    }
     if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {
         view->ndim = (int) info->ndim;
-        view->strides = &info->strides[0];
-        view->shape = &info->shape[0];
+        view->strides = info->strides.data();
+        view->shape = info->shape.data();
     }
     Py_INCREF(view->obj);
     return 0;
 }
 
 /// buffer_protocol: Release the resources of the buffer.
 extern "C" inline void pybind11_releasebuffer(PyObject *, Py_buffer *view) {
@@ -592,78 +629,80 @@
 
     heap_type->as_buffer.bf_getbuffer = pybind11_getbuffer;
     heap_type->as_buffer.bf_releasebuffer = pybind11_releasebuffer;
 }
 
 /** Create a brand new Python type according to the `type_record` specification.
     Return value: New reference. */
-inline PyObject* make_new_python_type(const type_record &rec) {
+inline PyObject *make_new_python_type(const type_record &rec) {
     auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));
 
     auto qualname = name;
     if (rec.scope && !PyModule_Check(rec.scope.ptr()) && hasattr(rec.scope, "__qualname__")) {
 #if PY_MAJOR_VERSION >= 3
         qualname = reinterpret_steal<object>(
             PyUnicode_FromFormat("%U.%U", rec.scope.attr("__qualname__").ptr(), name.ptr()));
 #else
         qualname = str(rec.scope.attr("__qualname__").cast<std::string>() + "." + rec.name);
 #endif
     }
 
     object module_;
     if (rec.scope) {
-        if (hasattr(rec.scope, "__module__"))
+        if (hasattr(rec.scope, "__module__")) {
             module_ = rec.scope.attr("__module__");
-        else if (hasattr(rec.scope, "__name__"))
+        } else if (hasattr(rec.scope, "__name__")) {
             module_ = rec.scope.attr("__name__");
+        }
     }
 
-    auto full_name = c_str(
+    const auto *full_name = c_str(
 #if !defined(PYPY_VERSION)
         module_ ? str(module_).cast<std::string>() + "." + rec.name :
 #endif
-        rec.name);
+                rec.name);
 
     char *tp_doc = nullptr;
     if (rec.doc && options::show_user_defined_docstrings()) {
         /* Allocate memory for docstring (using PyObject_MALLOC, since
            Python will free this later on) */
-        size_t size = strlen(rec.doc) + 1;
+        size_t size = std::strlen(rec.doc) + 1;
         tp_doc = (char *) PyObject_MALLOC(size);
-        memcpy((void *) tp_doc, rec.doc, size);
+        std::memcpy((void *) tp_doc, rec.doc, size);
     }
 
     auto &internals = get_internals();
     auto bases = tuple(rec.bases);
-    auto base = (bases.empty()) ? internals.instance_base
-                                    : bases[0].ptr();
+    auto *base = (bases.empty()) ? internals.instance_base : bases[0].ptr();
 
     /* Danger zone: from now (and until PyType_Ready), make sure to
        issue no Python C API calls which could potentially invoke the
        garbage collector (the GC will call type_traverse(), which will in
        turn find the newly constructed type in an invalid state) */
-    auto metaclass = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr()
-                                         : internals.default_metaclass;
+    auto *metaclass
+        = rec.metaclass.ptr() ? (PyTypeObject *) rec.metaclass.ptr() : internals.default_metaclass;
 
-    auto heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
-    if (!heap_type)
+    auto *heap_type = (PyHeapTypeObject *) metaclass->tp_alloc(metaclass, 0);
+    if (!heap_type) {
         pybind11_fail(std::string(rec.name) + ": Unable to create type object!");
+    }
 
     heap_type->ht_name = name.release().ptr();
 #ifdef PYBIND11_BUILTIN_QUALNAME
     heap_type->ht_qualname = qualname.inc_ref().ptr();
 #endif
 
-    auto type = &heap_type->ht_type;
+    auto *type = &heap_type->ht_type;
     type->tp_name = full_name;
     type->tp_doc = tp_doc;
-    type->tp_base = type_incref((PyTypeObject *)base);
+    type->tp_base = type_incref((PyTypeObject *) base);
     type->tp_basicsize = static_cast<ssize_t>(sizeof(instance));
-    if (!bases.empty())
+    if (!bases.empty()) {
         type->tp_bases = bases.release().ptr();
+    }
 
     /* Don't inherit base __init__ */
     type->tp_init = pybind11_object_init;
 
     /* Supported protocols */
     type->tp_as_number = &heap_type->as_number;
     type->tp_as_sequence = &heap_type->as_sequence;
@@ -673,37 +712,46 @@
 #endif
 
     /* Flags */
     type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE;
 #if PY_MAJOR_VERSION < 3
     type->tp_flags |= Py_TPFLAGS_CHECKTYPES;
 #endif
-    if (!rec.is_final)
+    if (!rec.is_final) {
         type->tp_flags |= Py_TPFLAGS_BASETYPE;
+    }
 
-    if (rec.dynamic_attr)
+    if (rec.dynamic_attr) {
         enable_dynamic_attributes(heap_type);
+    }
 
-    if (rec.buffer_protocol)
+    if (rec.buffer_protocol) {
         enable_buffer_protocol(heap_type);
+    }
+
+    if (rec.custom_type_setup_callback) {
+        rec.custom_type_setup_callback(heap_type);
+    }
 
-    if (PyType_Ready(type) < 0)
+    if (PyType_Ready(type) < 0) {
         pybind11_fail(std::string(rec.name) + ": PyType_Ready failed (" + error_string() + ")!");
+    }
 
-    assert(rec.dynamic_attr ? PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC)
-                            : !PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
+    assert(!rec.dynamic_attr || PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
 
     /* Register type with the parent scope */
-    if (rec.scope)
+    if (rec.scope) {
         setattr(rec.scope, rec.name, (PyObject *) type);
-    else
+    } else {
         Py_INCREF(type); // Keep it alive forever (reference leak)
+    }
 
-    if (module_) // Needed by pydoc
+    if (module_) { // Needed by pydoc
         setattr((PyObject *) type, "__module__", module_);
+    }
 
     PYBIND11_SET_OLDPY_QUALNAME(type, qualname);
 
     return (PyObject *) type;
 }
 
 PYBIND11_NAMESPACE_END(detail)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/detail/common.h` & `HepMC3-3.2.6/python/include/pybind11/detail/common.h`

 * *Files 17% similar despite different names*

```diff
@@ -6,264 +6,391 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #define PYBIND11_VERSION_MAJOR 2
-#define PYBIND11_VERSION_MINOR 6
-#define PYBIND11_VERSION_PATCH 0
+#define PYBIND11_VERSION_MINOR 9
+#define PYBIND11_VERSION_PATCH 2
+
+// Similar to Python's convention: https://docs.python.org/3/c-api/apiabiversion.html
+// Additional convention: 0xD = dev
+#define PYBIND11_VERSION_HEX 0x02090200
 
 #define PYBIND11_NAMESPACE_BEGIN(name) namespace name {
 #define PYBIND11_NAMESPACE_END(name) }
 
 // Robust support for some features and loading modules compiled against different pybind versions
-// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute on
-// the main `pybind11` namespace.
+// requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute
+// on the main `pybind11` namespace.
 #if !defined(PYBIND11_NAMESPACE)
-#  ifdef __GNUG__
-#    define PYBIND11_NAMESPACE pybind11 __attribute__((visibility("hidden")))
-#  else
-#    define PYBIND11_NAMESPACE pybind11
-#  endif
+#    ifdef __GNUG__
+#        define PYBIND11_NAMESPACE pybind11 __attribute__((visibility("hidden")))
+#    else
+#        define PYBIND11_NAMESPACE pybind11
+#    endif
 #endif
 
-#if !(defined(_MSC_VER) && __cplusplus == 199711L) && !defined(__INTEL_COMPILER)
-#  if __cplusplus >= 201402L
-#    define PYBIND11_CPP14
-#    if __cplusplus >= 201703L
-#      define PYBIND11_CPP17
+#if !(defined(_MSC_VER) && __cplusplus == 199711L)
+#    if __cplusplus >= 201402L
+#        define PYBIND11_CPP14
+#        if __cplusplus >= 201703L
+#            define PYBIND11_CPP17
+#            if __cplusplus >= 202002L
+#                define PYBIND11_CPP20
+#            endif
+#        endif
 #    endif
-#  endif
 #elif defined(_MSC_VER) && __cplusplus == 199711L
-// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully implemented)
-// Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3 or newer
-#  if _MSVC_LANG >= 201402L
-#    define PYBIND11_CPP14
-#    if _MSVC_LANG > 201402L && _MSC_VER >= 1910
-#      define PYBIND11_CPP17
+// MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully
+// implemented). Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3
+// or newer.
+#    if _MSVC_LANG >= 201402L
+#        define PYBIND11_CPP14
+#        if _MSVC_LANG > 201402L && _MSC_VER >= 1910
+#            define PYBIND11_CPP17
+#            if _MSVC_LANG >= 202002L
+#                define PYBIND11_CPP20
+#            endif
+#        endif
 #    endif
-#  endif
 #endif
 
 // Compiler version assertions
 #if defined(__INTEL_COMPILER)
-#  if __INTEL_COMPILER < 1800
-#    error pybind11 requires Intel C++ compiler v18 or newer
-#  endif
+#    if __INTEL_COMPILER < 1800
+#        error pybind11 requires Intel C++ compiler v18 or newer
+#    elif __INTEL_COMPILER < 1900 && defined(PYBIND11_CPP14)
+#        error pybind11 supports only C++11 with Intel C++ compiler v18. Use v19 or newer for C++14.
+#    endif
+/* The following pragma cannot be pop'ed:
+   https://community.intel.com/t5/Intel-C-Compiler/Inline-and-no-inline-warning/td-p/1216764 */
+#    pragma warning disable 2196 // warning #2196: routine is both "inline" and "noinline"
 #elif defined(__clang__) && !defined(__apple_build_version__)
-#  if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)
-#    error pybind11 requires clang 3.3 or newer
-#  endif
+#    if __clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ < 3)
+#        error pybind11 requires clang 3.3 or newer
+#    endif
 #elif defined(__clang__)
 // Apple changes clang version macros to its Xcode version; the first Xcode release based on
 // (upstream) clang 3.3 was Xcode 5:
-#  if __clang_major__ < 5
-#    error pybind11 requires Xcode/clang 5.0 or newer
-#  endif
+#    if __clang_major__ < 5
+#        error pybind11 requires Xcode/clang 5.0 or newer
+#    endif
 #elif defined(__GNUG__)
-#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
-#    error pybind11 requires gcc 4.8 or newer
-#  endif
+#    if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
+#        error pybind11 requires gcc 4.8 or newer
+#    endif
 #elif defined(_MSC_VER)
 // Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features
 // (e.g. std::negation) added in 2015u3:
-#  if _MSC_FULL_VER < 190024210
-#    error pybind11 requires MSVC 2015 update 3 or newer
-#  endif
+#    if _MSC_FULL_VER < 190024210
+#        error pybind11 requires MSVC 2015 update 3 or newer
+#    endif
 #endif
 
 #if !defined(PYBIND11_EXPORT)
-#  if defined(WIN32) || defined(_WIN32)
-#    define PYBIND11_EXPORT __declspec(dllexport)
-#  else
-#    define PYBIND11_EXPORT __attribute__ ((visibility("default")))
-#  endif
+#    if defined(WIN32) || defined(_WIN32)
+#        define PYBIND11_EXPORT __declspec(dllexport)
+#    else
+#        define PYBIND11_EXPORT __attribute__((visibility("default")))
+#    endif
 #endif
 
-#if defined(_MSC_VER)
-#  define PYBIND11_NOINLINE __declspec(noinline)
+#if !defined(PYBIND11_EXPORT_EXCEPTION)
+#    ifdef __MINGW32__
+// workaround for:
+// error: 'dllexport' implies default visibility, but xxx has already been declared with a
+// different visibility
+#        define PYBIND11_EXPORT_EXCEPTION
+#    else
+#        define PYBIND11_EXPORT_EXCEPTION PYBIND11_EXPORT
+#    endif
+#endif
+
+// For CUDA, GCC7, GCC8:
+// PYBIND11_NOINLINE_FORCED is incompatible with `-Wattributes -Werror`.
+// When defining PYBIND11_NOINLINE_FORCED, it is best to also use `-Wno-attributes`.
+// However, the measured shared-library size saving when using noinline are only
+// 1.7% for CUDA, -0.2% for GCC7, and 0.0% for GCC8 (using -DCMAKE_BUILD_TYPE=MinSizeRel,
+// the default under pybind11/tests).
+#if !defined(PYBIND11_NOINLINE_FORCED)                                                            \
+    && (defined(__CUDACC__) || (defined(__GNUC__) && (__GNUC__ == 7 || __GNUC__ == 8)))
+#    define PYBIND11_NOINLINE_DISABLED
+#endif
+
+// The PYBIND11_NOINLINE macro is for function DEFINITIONS.
+// In contrast, FORWARD DECLARATIONS should never use this macro:
+// https://stackoverflow.com/questions/9317473/forward-declaration-of-inline-functions
+#if defined(PYBIND11_NOINLINE_DISABLED) // Option for maximum portability and experimentation.
+#    define PYBIND11_NOINLINE inline
+#elif defined(_MSC_VER)
+#    define PYBIND11_NOINLINE __declspec(noinline) inline
 #else
-#  define PYBIND11_NOINLINE __attribute__ ((noinline))
+#    define PYBIND11_NOINLINE __attribute__((noinline)) inline
 #endif
 
-#if defined(PYBIND11_CPP14)
-#  define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]
+#if defined(__MINGW32__)
+// For unknown reasons all PYBIND11_DEPRECATED member trigger a warning when declared
+// whether it is used or not
+#    define PYBIND11_DEPRECATED(reason)
+#elif defined(PYBIND11_CPP14)
+#    define PYBIND11_DEPRECATED(reason) [[deprecated(reason)]]
 #else
-#  define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))
+#    define PYBIND11_DEPRECATED(reason) __attribute__((deprecated(reason)))
 #endif
 
 #if defined(PYBIND11_CPP17)
-#  define PYBIND11_MAYBE_UNUSED [[maybe_unused]]
+#    define PYBIND11_MAYBE_UNUSED [[maybe_unused]]
 #elif defined(_MSC_VER) && !defined(__clang__)
-#  define PYBIND11_MAYBE_UNUSED
+#    define PYBIND11_MAYBE_UNUSED
 #else
-#  define PYBIND11_MAYBE_UNUSED __attribute__ ((__unused__))
+#    define PYBIND11_MAYBE_UNUSED __attribute__((__unused__))
 #endif
 
 /* Don't let Python.h #define (v)snprintf as macro because they are implemented
    properly in Visual Studio since 2015. */
 #if defined(_MSC_VER) && _MSC_VER >= 1900
-#  define HAVE_SNPRINTF 1
+#    define HAVE_SNPRINTF 1
 #endif
 
 /// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
 #if defined(_MSC_VER)
-#  if (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION < 4)
-#    define HAVE_ROUND 1
-#  endif
-#  pragma warning(push)
-#  pragma warning(disable: 4510 4610 4512 4005)
-#  if defined(_DEBUG) && !defined(Py_DEBUG)
-#    define PYBIND11_DEBUG_MARKER
-#    undef _DEBUG
-#  endif
+#    pragma warning(push)
+// C4505: 'PySlice_GetIndicesEx': unreferenced local function has been removed (PyPy only)
+#    pragma warning(disable : 4505)
+#    if defined(_DEBUG) && !defined(Py_DEBUG)
+// Workaround for a VS 2022 issue.
+// NOTE: This workaround knowingly violates the Python.h include order requirement:
+// https://docs.python.org/3/c-api/intro.html#include-files
+// See https://github.com/pybind/pybind11/pull/3497 for full context.
+#        include <yvals.h>
+#        if _MSVC_STL_VERSION >= 143
+#            include <crtdefs.h>
+#        endif
+#        define PYBIND11_DEBUG_MARKER
+#        undef _DEBUG
+#    endif
+#endif
+
+// https://en.cppreference.com/w/c/chrono/localtime
+#if defined(__STDC_LIB_EXT1__) && !defined(__STDC_WANT_LIB_EXT1__)
+#    define __STDC_WANT_LIB_EXT1__
+#endif
+
+#ifdef __has_include
+// std::optional (but including it in c++14 mode isn't allowed)
+#    if defined(PYBIND11_CPP17) && __has_include(<optional>)
+#        define PYBIND11_HAS_OPTIONAL 1
+#    endif
+// std::experimental::optional (but not allowed in c++11 mode)
+#    if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \
+                                 !__has_include(<optional>))
+#        define PYBIND11_HAS_EXP_OPTIONAL 1
+#    endif
+// std::variant
+#    if defined(PYBIND11_CPP17) && __has_include(<variant>)
+#        define PYBIND11_HAS_VARIANT 1
+#    endif
+#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)
+#    define PYBIND11_HAS_OPTIONAL 1
+#    define PYBIND11_HAS_VARIANT 1
+#endif
+
+#if defined(PYBIND11_CPP17)
+#    if defined(__has_include)
+#        if __has_include(<string_view>)
+#            define PYBIND11_HAS_STRING_VIEW
+#        endif
+#    elif defined(_MSC_VER)
+#        define PYBIND11_HAS_STRING_VIEW
+#    endif
+#endif
+
+#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
+#    define PYBIND11_HAS_U8STRING
 #endif
 
 #include <Python.h>
 #include <frameobject.h>
 #include <pythread.h>
 
 /* Python #defines overrides on all sorts of core functions, which
    tends to weak havok in C++ codebases that expect these to work
    like regular functions (potentially with several overloads) */
 #if defined(isalnum)
-#  undef isalnum
-#  undef isalpha
-#  undef islower
-#  undef isspace
-#  undef isupper
-#  undef tolower
-#  undef toupper
+#    undef isalnum
+#    undef isalpha
+#    undef islower
+#    undef isspace
+#    undef isupper
+#    undef tolower
+#    undef toupper
 #endif
 
 #if defined(copysign)
-#  undef copysign
+#    undef copysign
 #endif
 
 #if defined(_MSC_VER)
-#  if defined(PYBIND11_DEBUG_MARKER)
-#    define _DEBUG
-#    undef PYBIND11_DEBUG_MARKER
-#  endif
-#  pragma warning(pop)
+#    if defined(PYBIND11_DEBUG_MARKER)
+#        define _DEBUG
+#        undef PYBIND11_DEBUG_MARKER
+#    endif
+#    pragma warning(pop)
 #endif
 
 #include <cstddef>
 #include <cstring>
-#include <forward_list>
-#include <vector>
-#include <string>
-#include <stdexcept>
 #include <exception>
-#include <unordered_set>
-#include <unordered_map>
+#include <forward_list>
 #include <memory>
-#include <typeindex>
+#include <stdexcept>
+#include <string>
 #include <type_traits>
+#include <typeindex>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+#if defined(__has_include)
+#    if __has_include(<version>)
+#        include <version>
+#    endif
+#endif
+
+// #define PYBIND11_STR_LEGACY_PERMISSIVE
+// If DEFINED, pybind11::str can hold PyUnicodeObject or PyBytesObject
+//             (probably surprising and never documented, but this was the
+//             legacy behavior until and including v2.6.x). As a side-effect,
+//             pybind11::isinstance<str>() is true for both pybind11::str and
+//             pybind11::bytes.
+// If UNDEFINED, pybind11::str can only hold PyUnicodeObject, and
+//               pybind11::isinstance<str>() is true only for pybind11::str.
+//               However, for Python 2 only (!), the pybind11::str caster
+//               implicitly decodes bytes to PyUnicodeObject. This is to ease
+//               the transition from the legacy behavior to the non-permissive
+//               behavior.
 
 #if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions
-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
-#define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
-#define PYBIND11_BYTES_CHECK PyBytes_Check
-#define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
-#define PYBIND11_BYTES_AS_STRING PyBytes_AsString
-#define PYBIND11_BYTES_SIZE PyBytes_Size
-#define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
-#define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
-#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) o)
-#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) o)
-#define PYBIND11_BYTES_NAME "bytes"
-#define PYBIND11_STRING_NAME "str"
-#define PYBIND11_SLICE_OBJECT PyObject
-#define PYBIND11_FROM_STRING PyUnicode_FromString
-#define PYBIND11_STR_TYPE ::pybind11::str
-#define PYBIND11_BOOL_ATTR "__bool__"
-#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)
-#define PYBIND11_BUILTINS_MODULE "builtins"
+#    define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
+#    define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
+#    define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
+#    define PYBIND11_BYTES_CHECK PyBytes_Check
+#    define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
+#    define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
+#    define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
+#    define PYBIND11_BYTES_AS_STRING PyBytes_AsString
+#    define PYBIND11_BYTES_SIZE PyBytes_Size
+#    define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
+#    define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
+#    define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) (o))
+#    define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) (o))
+#    define PYBIND11_BYTES_NAME "bytes"
+#    define PYBIND11_STRING_NAME "str"
+#    define PYBIND11_SLICE_OBJECT PyObject
+#    define PYBIND11_FROM_STRING PyUnicode_FromString
+#    define PYBIND11_STR_TYPE ::pybind11::str
+#    define PYBIND11_BOOL_ATTR "__bool__"
+#    define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)
+#    define PYBIND11_BUILTINS_MODULE "builtins"
 // Providing a separate declaration to make Clang's -Wmissing-prototypes happy.
 // See comment for PYBIND11_MODULE below for why this is marked "maybe unused".
-#define PYBIND11_PLUGIN_IMPL(name) \
-    extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT PyObject *PyInit_##name(); \
-    extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
-
-#else
-#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)
-#define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
-#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
-#define PYBIND11_BYTES_CHECK PyString_Check
-#define PYBIND11_BYTES_FROM_STRING PyString_FromString
-#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
-#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
-#define PYBIND11_BYTES_AS_STRING PyString_AsString
-#define PYBIND11_BYTES_SIZE PyString_Size
-#define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
-#define PYBIND11_LONG_AS_LONGLONG(o) (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
-#define PYBIND11_LONG_FROM_SIGNED(o) PyInt_FromSsize_t((ssize_t) o) // Returns long if needed.
-#define PYBIND11_LONG_FROM_UNSIGNED(o) PyInt_FromSize_t((size_t) o) // Returns long if needed.
-#define PYBIND11_BYTES_NAME "str"
-#define PYBIND11_STRING_NAME "unicode"
-#define PYBIND11_SLICE_OBJECT PySliceObject
-#define PYBIND11_FROM_STRING PyString_FromString
-#define PYBIND11_STR_TYPE ::pybind11::bytes
-#define PYBIND11_BOOL_ATTR "__nonzero__"
-#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)
-#define PYBIND11_BUILTINS_MODULE "__builtin__"
+#    define PYBIND11_PLUGIN_IMPL(name)                                                            \
+        extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT PyObject *PyInit_##name();               \
+        extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
+
+#else
+#    define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)
+#    define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
+#    define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
+#    define PYBIND11_BYTES_CHECK PyString_Check
+#    define PYBIND11_BYTES_FROM_STRING PyString_FromString
+#    define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
+#    define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
+#    define PYBIND11_BYTES_AS_STRING PyString_AsString
+#    define PYBIND11_BYTES_SIZE PyString_Size
+#    define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
+#    define PYBIND11_LONG_AS_LONGLONG(o)                                                          \
+        (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
+#    define PYBIND11_LONG_FROM_SIGNED(o) PyInt_FromSsize_t((ssize_t) o) // Returns long if needed.
+#    define PYBIND11_LONG_FROM_UNSIGNED(o) PyInt_FromSize_t((size_t) o) // Returns long if needed.
+#    define PYBIND11_BYTES_NAME "str"
+#    define PYBIND11_STRING_NAME "unicode"
+#    define PYBIND11_SLICE_OBJECT PySliceObject
+#    define PYBIND11_FROM_STRING PyString_FromString
+#    define PYBIND11_STR_TYPE ::pybind11::bytes
+#    define PYBIND11_BOOL_ATTR "__nonzero__"
+#    define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)
+#    define PYBIND11_BUILTINS_MODULE "__builtin__"
 // Providing a separate PyInit decl to make Clang's -Wmissing-prototypes happy.
 // See comment for PYBIND11_MODULE below for why this is marked "maybe unused".
-#define PYBIND11_PLUGIN_IMPL(name) \
-    static PyObject *pybind11_init_wrapper();                           \
-    extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT void init##name(); \
-    extern "C" PYBIND11_EXPORT void init##name() {                      \
-        (void)pybind11_init_wrapper();                                  \
-    }                                                                   \
-    PyObject *pybind11_init_wrapper()
+#    define PYBIND11_PLUGIN_IMPL(name)                                                            \
+        static PyObject *pybind11_init_wrapper();                                                 \
+        extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT void init##name();                       \
+        extern "C" PYBIND11_EXPORT void init##name() { (void) pybind11_init_wrapper(); }          \
+        PyObject *pybind11_init_wrapper()
 #endif
 
 #if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200
 extern "C" {
-    struct _Py_atomic_address { void *value; };
-    PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;
+struct _Py_atomic_address {
+    void *value;
+};
+PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;
 }
 #endif
 
 #define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code
 #define PYBIND11_STRINGIFY(x) #x
 #define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)
 #define PYBIND11_CONCAT(first, second) first##second
-#define PYBIND11_ENSURE_INTERNALS_READY \
-    pybind11::detail::get_internals();
+#define PYBIND11_ENSURE_INTERNALS_READY pybind11::detail::get_internals();
 
-#define PYBIND11_CHECK_PYTHON_VERSION \
-    {                                                                          \
-        const char *compiled_ver = PYBIND11_TOSTRING(PY_MAJOR_VERSION)         \
-            "." PYBIND11_TOSTRING(PY_MINOR_VERSION);                           \
-        const char *runtime_ver = Py_GetVersion();                             \
-        size_t len = std::strlen(compiled_ver);                                \
-        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                  \
-                || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {     \
-            PyErr_Format(PyExc_ImportError,                                    \
-                "Python version mismatch: module was compiled for Python %s, " \
-                "but the interpreter version is incompatible: %s.",            \
-                compiled_ver, runtime_ver);                                    \
-            return nullptr;                                                    \
-        }                                                                      \
+#define PYBIND11_CHECK_PYTHON_VERSION                                                             \
+    {                                                                                             \
+        const char *compiled_ver                                                                  \
+            = PYBIND11_TOSTRING(PY_MAJOR_VERSION) "." PYBIND11_TOSTRING(PY_MINOR_VERSION);        \
+        const char *runtime_ver = Py_GetVersion();                                                \
+        size_t len = std::strlen(compiled_ver);                                                   \
+        if (std::strncmp(runtime_ver, compiled_ver, len) != 0                                     \
+            || (runtime_ver[len] >= '0' && runtime_ver[len] <= '9')) {                            \
+            PyErr_Format(PyExc_ImportError,                                                       \
+                         "Python version mismatch: module was compiled for Python %s, "           \
+                         "but the interpreter version is incompatible: %s.",                      \
+                         compiled_ver,                                                            \
+                         runtime_ver);                                                            \
+            return nullptr;                                                                       \
+        }                                                                                         \
     }
 
-#define PYBIND11_CATCH_INIT_EXCEPTIONS \
-        catch (pybind11::error_already_set &e) {                               \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        } catch (const std::exception &e) {                                    \
-            PyErr_SetString(PyExc_ImportError, e.what());                      \
-            return nullptr;                                                    \
-        }                                                                      \
+#if PY_VERSION_HEX >= 0x03030000
+
+#    define PYBIND11_CATCH_INIT_EXCEPTIONS                                                        \
+        catch (pybind11::error_already_set & e) {                                                 \
+            pybind11::raise_from(e, PyExc_ImportError, "initialization failed");                  \
+            return nullptr;                                                                       \
+        }                                                                                         \
+        catch (const std::exception &e) {                                                         \
+            PyErr_SetString(PyExc_ImportError, e.what());                                         \
+            return nullptr;                                                                       \
+        }
+
+#else
+
+#    define PYBIND11_CATCH_INIT_EXCEPTIONS                                                        \
+        catch (pybind11::error_already_set & e) {                                                 \
+            PyErr_SetString(PyExc_ImportError, e.what());                                         \
+            return nullptr;                                                                       \
+        }                                                                                         \
+        catch (const std::exception &e) {                                                         \
+            PyErr_SetString(PyExc_ImportError, e.what());                                         \
+            return nullptr;                                                                       \
+        }
+
+#endif
 
 /** \rst
     ***Deprecated in favor of PYBIND11_MODULE***
 
     This macro creates the entry point that will be invoked when the Python interpreter
     imports a plugin library. Please create a `module_` in the function body and return
     the pointer to its underlying Python object at the end.
@@ -272,24 +399,25 @@
 
         PYBIND11_PLUGIN(example) {
             pybind11::module_ m("example", "pybind11 example plugin");
             /// Set up bindings here
             return m.ptr();
         }
 \endrst */
-#define PYBIND11_PLUGIN(name)                                                  \
-    PYBIND11_DEPRECATED("PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE")  \
-    static PyObject *pybind11_init();                                          \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        PYBIND11_CHECK_PYTHON_VERSION                                          \
-        PYBIND11_ENSURE_INTERNALS_READY                                        \
-        try {                                                                  \
-            return pybind11_init();                                            \
-        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \
-    }                                                                          \
+#define PYBIND11_PLUGIN(name)                                                                     \
+    PYBIND11_DEPRECATED("PYBIND11_PLUGIN is deprecated, use PYBIND11_MODULE")                     \
+    static PyObject *pybind11_init();                                                             \
+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \
+        PYBIND11_CHECK_PYTHON_VERSION                                                             \
+        PYBIND11_ENSURE_INTERNALS_READY                                                           \
+        try {                                                                                     \
+            return pybind11_init();                                                               \
+        }                                                                                         \
+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \
+    }                                                                                             \
     PyObject *pybind11_init()
 
 /** \rst
     This macro creates the entry point that will be invoked when the Python interpreter
     imports an extension module. The module name is given as the fist argument and it
     should not be in quotes. The second macro argument defines a variable of type
     `py::module_` which can be used to initialize the module.
@@ -305,37 +433,42 @@
 
             // Add bindings here
             m.def("foo", []() {
                 return "Hello, World!";
             });
         }
 \endrst */
-#define PYBIND11_MODULE(name, variable)                                        \
-    static ::pybind11::module_::module_def                                     \
-        PYBIND11_CONCAT(pybind11_module_def_, name);                           \
-    PYBIND11_MAYBE_UNUSED                                                      \
-    static void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &);  \
-    PYBIND11_PLUGIN_IMPL(name) {                                               \
-        PYBIND11_CHECK_PYTHON_VERSION                                          \
-        PYBIND11_ENSURE_INTERNALS_READY                                        \
-        auto m = ::pybind11::module_::create_extension_module(                 \
-            PYBIND11_TOSTRING(name), nullptr,                                  \
-            &PYBIND11_CONCAT(pybind11_module_def_, name));                     \
-        try {                                                                  \
-            PYBIND11_CONCAT(pybind11_init_, name)(m);                          \
-            return m.ptr();                                                    \
-        } PYBIND11_CATCH_INIT_EXCEPTIONS                                       \
-    }                                                                          \
-    void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &variable)
-
+#define PYBIND11_MODULE(name, variable)                                                           \
+    static ::pybind11::module_::module_def PYBIND11_CONCAT(pybind11_module_def_, name)            \
+        PYBIND11_MAYBE_UNUSED;                                                                    \
+    PYBIND11_MAYBE_UNUSED                                                                         \
+    static void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ &);                     \
+    PYBIND11_PLUGIN_IMPL(name) {                                                                  \
+        PYBIND11_CHECK_PYTHON_VERSION                                                             \
+        PYBIND11_ENSURE_INTERNALS_READY                                                           \
+        auto m = ::pybind11::module_::create_extension_module(                                    \
+            PYBIND11_TOSTRING(name), nullptr, &PYBIND11_CONCAT(pybind11_module_def_, name));      \
+        try {                                                                                     \
+            PYBIND11_CONCAT(pybind11_init_, name)(m);                                             \
+            return m.ptr();                                                                       \
+        }                                                                                         \
+        PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \
+    }                                                                                             \
+    void PYBIND11_CONCAT(pybind11_init_, name)(::pybind11::module_ & (variable))
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 using ssize_t = Py_ssize_t;
-using size_t  = std::size_t;
+using size_t = std::size_t;
+
+template <typename IntType>
+inline ssize_t ssize_t_cast(const IntType &val) {
+    static_assert(sizeof(IntType) <= sizeof(ssize_t), "Implicit narrowing is not permitted.");
+    return static_cast<ssize_t>(val);
+}
 
 /// Approach used to cast a previously unknown C++ instance into a Python object
 enum class return_value_policy : uint8_t {
     /** This is the default return value policy, which falls back to the policy
         return_value_policy::take_ownership when the return value is a pointer.
         Otherwise, it uses return_value::move or return_value::copy for rvalue
         and lvalue references, respectively. See below for a description of what
@@ -383,28 +516,32 @@
         variations of this scheme are also possible using combinations of
         return_value_policy::reference and the keep_alive call policy */
     reference_internal
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-inline static constexpr int log2(size_t n, int k = 0) { return (n <= 1) ? k : log2(n >> 1, k + 1); }
+inline static constexpr int log2(size_t n, int k = 0) {
+    return (n <= 1) ? k : log2(n >> 1, k + 1);
+}
 
 // Returns the size as a multiple of sizeof(void *), rounded up.
-inline static constexpr size_t size_in_ptrs(size_t s) { return 1 + ((s - 1) >> log2(sizeof(void *))); }
+inline static constexpr size_t size_in_ptrs(size_t s) {
+    return 1 + ((s - 1) >> log2(sizeof(void *)));
+}
 
 /**
  * The space to allocate for simple layout instance holders (see below) in multiple of the size of
  * a pointer (e.g.  2 means 16 bytes on 64-bit architectures).  The default is the minimum required
  * to holder either a std::unique_ptr or std::shared_ptr (which is almost always
  * sizeof(std::shared_ptr<T>)).
  */
 constexpr size_t instance_simple_holder_in_ptrs() {
     static_assert(sizeof(std::shared_ptr<int>) >= sizeof(std::unique_ptr<int>),
-            "pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs");
+                  "pybind assumes std::shared_ptrs are at least as big as std::unique_ptrs");
     return size_in_ptrs(sizeof(std::shared_ptr<int>));
 }
 
 // Forward declarations
 struct type_info;
 struct value_and_holder;
 
@@ -424,430 +561,650 @@
     /// Weak references
     PyObject *weakrefs;
     /// If true, the pointer is owned which means we're free to manage it with a holder.
     bool owned : 1;
     /**
      * An instance has two possible value/holder layouts.
      *
-     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a pointer
-     * and the holder object governing that pointer, i.e. [val1*][holder].  This layout is applied
-     * whenever there is no python-side multiple inheritance of bound C++ types *and* the type's
-     * holder will fit in the default space (which is large enough to hold either a std::unique_ptr
-     * or std::shared_ptr).
+     * Simple layout (when this flag is true), means the `simple_value_holder` is set with a
+     * pointer and the holder object governing that pointer, i.e. [val1*][holder].  This layout is
+     * applied whenever there is no python-side multiple inheritance of bound C++ types *and* the
+     * type's holder will fit in the default space (which is large enough to hold either a
+     * std::unique_ptr or std::shared_ptr).
      *
-     * Non-simple layout applies when using custom holders that require more space than `shared_ptr`
-     * (which is typically the size of two pointers), or when multiple inheritance is used on the
-     * python side.  Non-simple layout allocates the required amount of memory to have multiple
-     * bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is set to a
-     * pointer to allocated space of the required space to hold a sequence of value pointers and
-     * holders followed `status`, a set of bit flags (1 byte each), i.e.
-     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple of
-     * `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the
-     * beginning of the [bb...] block (but not independently allocated).
+     * Non-simple layout applies when using custom holders that require more space than
+     * `shared_ptr` (which is typically the size of two pointers), or when multiple inheritance is
+     * used on the python side.  Non-simple layout allocates the required amount of memory to have
+     * multiple bound C++ classes as parents.  Under this layout, `nonsimple.values_and_holders` is
+     * set to a pointer to allocated space of the required space to hold a sequence of value
+     * pointers and holders followed `status`, a set of bit flags (1 byte each), i.e.
+     * [val1*][holder1][val2*][holder2]...[bb...]  where each [block] is rounded up to a multiple
+     * of `sizeof(void *)`.  `nonsimple.status` is, for convenience, a pointer to the beginning of
+     * the [bb...] block (but not independently allocated).
      *
      * Status bits indicate whether the associated holder is constructed (&
      * status_holder_constructed) and whether the value pointer is registered (&
      * status_instance_registered) in `registered_instances`.
      */
     bool simple_layout : 1;
     /// For simple layout, tracks whether the holder has been constructed
     bool simple_holder_constructed : 1;
     /// For simple layout, tracks whether the instance is registered in `registered_instances`
     bool simple_instance_registered : 1;
     /// If true, get_internals().patients has an entry for this object
     bool has_patients : 1;
 
-    /// Initializes all of the above type/values/holders data (but not the instance values themselves)
+    /// Initializes all of the above type/values/holders data (but not the instance values
+    /// themselves)
     void allocate_layout();
 
     /// Destroys/deallocates all of the above
     void deallocate_layout();
 
     /// Returns the value_and_holder wrapper for the given type (or the first, if `find_type`
     /// omitted).  Returns a default-constructed (with `.inst = nullptr`) object on failure if
     /// `throw_if_missing` is false.
-    value_and_holder get_value_and_holder(const type_info *find_type = nullptr, bool throw_if_missing = true);
+    value_and_holder get_value_and_holder(const type_info *find_type = nullptr,
+                                          bool throw_if_missing = true);
 
     /// Bit values for the non-simple status flags
-    static constexpr uint8_t status_holder_constructed  = 1;
+    static constexpr uint8_t status_holder_constructed = 1;
     static constexpr uint8_t status_instance_registered = 2;
 };
 
-static_assert(std::is_standard_layout<instance>::value, "Internal error: `pybind11::detail::instance` is not standard layout!");
+static_assert(std::is_standard_layout<instance>::value,
+              "Internal error: `pybind11::detail::instance` is not standard layout!");
 
 /// from __cpp_future__ import (convenient aliases from C++14/17)
 #if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
-using std::enable_if_t;
 using std::conditional_t;
+using std::enable_if_t;
 using std::remove_cv_t;
 using std::remove_reference_t;
 #else
-template <bool B, typename T = void> using enable_if_t = typename std::enable_if<B, T>::type;
-template <bool B, typename T, typename F> using conditional_t = typename std::conditional<B, T, F>::type;
-template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;
-template <typename T> using remove_reference_t = typename std::remove_reference<T>::type;
+template <bool B, typename T = void>
+using enable_if_t = typename std::enable_if<B, T>::type;
+template <bool B, typename T, typename F>
+using conditional_t = typename std::conditional<B, T, F>::type;
+template <typename T>
+using remove_cv_t = typename std::remove_cv<T>::type;
+template <typename T>
+using remove_reference_t = typename std::remove_reference<T>::type;
+#endif
+
+#if defined(PYBIND11_CPP20)
+using std::remove_cvref;
+using std::remove_cvref_t;
+#else
+template <class T>
+struct remove_cvref {
+    using type = remove_cv_t<remove_reference_t<T>>;
+};
+template <class T>
+using remove_cvref_t = typename remove_cvref<T>::type;
 #endif
 
 /// Index sequences
 #if defined(PYBIND11_CPP14)
 using std::index_sequence;
 using std::make_index_sequence;
 #else
-template<size_t ...> struct index_sequence  { };
-template<size_t N, size_t ...S> struct make_index_sequence_impl : make_index_sequence_impl <N - 1, N - 1, S...> { };
-template<size_t ...S> struct make_index_sequence_impl <0, S...> { typedef index_sequence<S...> type; };
-template<size_t N> using make_index_sequence = typename make_index_sequence_impl<N>::type;
+template <size_t...>
+struct index_sequence {};
+template <size_t N, size_t... S>
+struct make_index_sequence_impl : make_index_sequence_impl<N - 1, N - 1, S...> {};
+template <size_t... S>
+struct make_index_sequence_impl<0, S...> {
+    using type = index_sequence<S...>;
+};
+template <size_t N>
+using make_index_sequence = typename make_index_sequence_impl<N>::type;
 #endif
 
 /// Make an index sequence of the indices of true arguments
-template <typename ISeq, size_t, bool...> struct select_indices_impl { using type = ISeq; };
-template <size_t... IPrev, size_t I, bool B, bool... Bs> struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>
-    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>, I + 1, Bs...> {};
-template <bool... Bs> using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;
+template <typename ISeq, size_t, bool...>
+struct select_indices_impl {
+    using type = ISeq;
+};
+template <size_t... IPrev, size_t I, bool B, bool... Bs>
+struct select_indices_impl<index_sequence<IPrev...>, I, B, Bs...>
+    : select_indices_impl<conditional_t<B, index_sequence<IPrev..., I>, index_sequence<IPrev...>>,
+                          I + 1,
+                          Bs...> {};
+template <bool... Bs>
+using select_indices = typename select_indices_impl<index_sequence<>, 0, Bs...>::type;
 
 /// Backports of std::bool_constant and std::negation to accommodate older compilers
-template <bool B> using bool_constant = std::integral_constant<bool, B>;
-template <typename T> struct negation : bool_constant<!T::value> { };
+template <bool B>
+using bool_constant = std::integral_constant<bool, B>;
+template <typename T>
+struct negation : bool_constant<!T::value> {};
 
 // PGI/Intel cannot detect operator delete with the "compatible" void_t impl, so
 // using the new one (C++14 defect, so generally works on newer compilers, even
 // if not in C++17 mode)
 #if defined(__PGIC__) || defined(__INTEL_COMPILER)
-template<typename... > using void_t = void;
+template <typename...>
+using void_t = void;
 #else
-template <typename...> struct void_t_impl { using type = void; };
-template <typename... Ts> using void_t = typename void_t_impl<Ts...>::type;
+template <typename...>
+struct void_t_impl {
+    using type = void;
+};
+template <typename... Ts>
+using void_t = typename void_t_impl<Ts...>::type;
 #endif
 
-
 /// Compile-time all/any/none of that check the boolean value of all template types
 #if defined(__cpp_fold_expressions) && !(defined(_MSC_VER) && (_MSC_VER < 1916))
-template <class... Ts> using all_of = bool_constant<(Ts::value && ...)>;
-template <class... Ts> using any_of = bool_constant<(Ts::value || ...)>;
+template <class... Ts>
+using all_of = bool_constant<(Ts::value && ...)>;
+template <class... Ts>
+using any_of = bool_constant<(Ts::value || ...)>;
 #elif !defined(_MSC_VER)
-template <bool...> struct bools {};
-template <class... Ts> using all_of = std::is_same<
-    bools<Ts::value..., true>,
-    bools<true, Ts::value...>>;
-template <class... Ts> using any_of = negation<all_of<negation<Ts>...>>;
+template <bool...>
+struct bools {};
+template <class... Ts>
+using all_of = std::is_same<bools<Ts::value..., true>, bools<true, Ts::value...>>;
+template <class... Ts>
+using any_of = negation<all_of<negation<Ts>...>>;
 #else
 // MSVC has trouble with the above, but supports std::conjunction, which we can use instead (albeit
 // at a slight loss of compilation efficiency).
-template <class... Ts> using all_of = std::conjunction<Ts...>;
-template <class... Ts> using any_of = std::disjunction<Ts...>;
-#endif
-template <class... Ts> using none_of = negation<any_of<Ts...>>;
-
-template <class T, template<class> class... Predicates> using satisfies_all_of = all_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_any_of = any_of<Predicates<T>...>;
-template <class T, template<class> class... Predicates> using satisfies_none_of = none_of<Predicates<T>...>;
+template <class... Ts>
+using all_of = std::conjunction<Ts...>;
+template <class... Ts>
+using any_of = std::disjunction<Ts...>;
+#endif
+template <class... Ts>
+using none_of = negation<any_of<Ts...>>;
+
+template <class T, template <class> class... Predicates>
+using satisfies_all_of = all_of<Predicates<T>...>;
+template <class T, template <class> class... Predicates>
+using satisfies_any_of = any_of<Predicates<T>...>;
+template <class T, template <class> class... Predicates>
+using satisfies_none_of = none_of<Predicates<T>...>;
 
 /// Strip the class from a method type
-template <typename T> struct remove_class { };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...)> { using type = R (A...); };
-template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...) const> { using type = R (A...); };
+template <typename T>
+struct remove_class {};
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...)> {
+    using type = R(A...);
+};
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...) const> {
+    using type = R(A...);
+};
 
 /// Helper template to strip away type modifiers
-template <typename T> struct intrinsic_type                       { using type = T; };
-template <typename T> struct intrinsic_type<const T>              { using type = typename intrinsic_type<T>::type; };
-template <typename T> struct intrinsic_type<T*>                   { using type = typename intrinsic_type<T>::type; };
-template <typename T> struct intrinsic_type<T&>                   { using type = typename intrinsic_type<T>::type; };
-template <typename T> struct intrinsic_type<T&&>                  { using type = typename intrinsic_type<T>::type; };
-template <typename T, size_t N> struct intrinsic_type<const T[N]> { using type = typename intrinsic_type<T>::type; };
-template <typename T, size_t N> struct intrinsic_type<T[N]>       { using type = typename intrinsic_type<T>::type; };
-template <typename T> using intrinsic_t = typename intrinsic_type<T>::type;
+template <typename T>
+struct intrinsic_type {
+    using type = T;
+};
+template <typename T>
+struct intrinsic_type<const T> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+struct intrinsic_type<T *> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+struct intrinsic_type<T &> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+struct intrinsic_type<T &&> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T, size_t N>
+struct intrinsic_type<const T[N]> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T, size_t N>
+struct intrinsic_type<T[N]> {
+    using type = typename intrinsic_type<T>::type;
+};
+template <typename T>
+using intrinsic_t = typename intrinsic_type<T>::type;
 
 /// Helper type to replace 'void' in some expressions
-struct void_type { };
+struct void_type {};
 
 /// Helper template which holds a list of types
-template <typename...> struct type_list { };
+template <typename...>
+struct type_list {};
 
 /// Compile-time integer sum
 #ifdef __cpp_fold_expressions
-template <typename... Ts> constexpr size_t constexpr_sum(Ts... ns) { return (0 + ... + size_t{ns}); }
+template <typename... Ts>
+constexpr size_t constexpr_sum(Ts... ns) {
+    return (0 + ... + size_t{ns});
+}
 #else
 constexpr size_t constexpr_sum() { return 0; }
 template <typename T, typename... Ts>
-constexpr size_t constexpr_sum(T n, Ts... ns) { return size_t{n} + constexpr_sum(ns...); }
+constexpr size_t constexpr_sum(T n, Ts... ns) {
+    return size_t{n} + constexpr_sum(ns...);
+}
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(constexpr_impl)
 /// Implementation details for constexpr functions
 constexpr int first(int i) { return i; }
 template <typename T, typename... Ts>
-constexpr int first(int i, T v, Ts... vs) { return v ? i : first(i + 1, vs...); }
+constexpr int first(int i, T v, Ts... vs) {
+    return v ? i : first(i + 1, vs...);
+}
 
 constexpr int last(int /*i*/, int result) { return result; }
 template <typename T, typename... Ts>
-constexpr int last(int i, int result, T v, Ts... vs) { return last(i + 1, v ? i : result, vs...); }
+constexpr int last(int i, int result, T v, Ts... vs) {
+    return last(i + 1, v ? i : result, vs...);
+}
 PYBIND11_NAMESPACE_END(constexpr_impl)
 
-/// Return the index of the first type in Ts which satisfies Predicate<T>.  Returns sizeof...(Ts) if
-/// none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_first() { return constexpr_impl::first(0, Predicate<Ts>::value...); }
+/// Return the index of the first type in Ts which satisfies Predicate<T>.
+/// Returns sizeof...(Ts) if none match.
+template <template <typename> class Predicate, typename... Ts>
+constexpr int constexpr_first() {
+    return constexpr_impl::first(0, Predicate<Ts>::value...);
+}
 
 /// Return the index of the last type in Ts which satisfies Predicate<T>, or -1 if none match.
-template <template<typename> class Predicate, typename... Ts>
-constexpr int constexpr_last() { return constexpr_impl::last(0, -1, Predicate<Ts>::value...); }
+template <template <typename> class Predicate, typename... Ts>
+constexpr int constexpr_last() {
+    return constexpr_impl::last(0, -1, Predicate<Ts>::value...);
+}
 
 /// Return the Nth element from the parameter pack
 template <size_t N, typename T, typename... Ts>
-struct pack_element { using type = typename pack_element<N - 1, Ts...>::type; };
+struct pack_element {
+    using type = typename pack_element<N - 1, Ts...>::type;
+};
 template <typename T, typename... Ts>
-struct pack_element<0, T, Ts...> { using type = T; };
+struct pack_element<0, T, Ts...> {
+    using type = T;
+};
 
 /// Return the one and only type which matches the predicate, or Default if none match.
 /// If more than one type matches the predicate, fail at compile-time.
-template <template<typename> class Predicate, typename Default, typename... Ts>
+template <template <typename> class Predicate, typename Default, typename... Ts>
 struct exactly_one {
     static constexpr auto found = constexpr_sum(Predicate<Ts>::value...);
     static_assert(found <= 1, "Found more than one type matching the predicate");
 
     static constexpr auto index = found ? constexpr_first<Predicate, Ts...>() : 0;
     using type = conditional_t<found, typename pack_element<index, Ts...>::type, Default>;
 };
-template <template<typename> class P, typename Default>
-struct exactly_one<P, Default> { using type = Default; };
+template <template <typename> class P, typename Default>
+struct exactly_one<P, Default> {
+    using type = Default;
+};
 
-template <template<typename> class Predicate, typename Default, typename... Ts>
+template <template <typename> class Predicate, typename Default, typename... Ts>
 using exactly_one_t = typename exactly_one<Predicate, Default, Ts...>::type;
 
 /// Defer the evaluation of type T until types Us are instantiated
-template <typename T, typename... /*Us*/> struct deferred_type { using type = T; };
-template <typename T, typename... Us> using deferred_t = typename deferred_type<T, Us...>::type;
+template <typename T, typename... /*Us*/>
+struct deferred_type {
+    using type = T;
+};
+template <typename T, typename... Us>
+using deferred_t = typename deferred_type<T, Us...>::type;
 
 /// Like is_base_of, but requires a strict base (i.e. `is_strict_base_of<T, T>::value == false`,
 /// unlike `std::is_base_of`)
-template <typename Base, typename Derived> using is_strict_base_of = bool_constant<
-    std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;
+template <typename Base, typename Derived>
+using is_strict_base_of
+    = bool_constant<std::is_base_of<Base, Derived>::value && !std::is_same<Base, Derived>::value>;
+
+/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived
+/// pointer can be converted to a Base pointer) For unions, `is_base_of<T, T>::value` is False, so
+/// we need to check `is_same` as well.
+template <typename Base, typename Derived>
+using is_accessible_base_of
+    = bool_constant<(std::is_same<Base, Derived>::value || std::is_base_of<Base, Derived>::value)
+                    && std::is_convertible<Derived *, Base *>::value>;
 
-/// Like is_base_of, but also requires that the base type is accessible (i.e. that a Derived pointer
-/// can be converted to a Base pointer)
-/// For unions, `is_base_of<T, T>::value` is False, so we need to check `is_same` as well.
-template <typename Base, typename Derived> using is_accessible_base_of = bool_constant<
-    (std::is_same<Base, Derived>::value || std::is_base_of<Base, Derived>::value) && std::is_convertible<Derived *, Base *>::value>;
-
-template <template<typename...> class Base>
+template <template <typename...> class Base>
 struct is_template_base_of_impl {
-    template <typename... Us> static std::true_type check(Base<Us...> *);
+    template <typename... Us>
+    static std::true_type check(Base<Us...> *);
     static std::false_type check(...);
 };
 
 /// Check if a template is the base of a type. For example:
 /// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything
-template <template<typename...> class Base, typename T>
+template <template <typename...> class Base, typename T>
 #if !defined(_MSC_VER)
-using is_template_base_of = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr));
+using is_template_base_of
+    = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr));
 #else // MSVC2015 has trouble with decltype in template aliases
-struct is_template_base_of : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T>*)nullptr)) { };
+struct is_template_base_of
+    : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr)) {
+};
 #endif
 
 /// Check if T is an instantiation of the template `Class`. For example:
 /// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.
-template <template<typename...> class Class, typename T>
-struct is_instantiation : std::false_type { };
-template <template<typename...> class Class, typename... Us>
-struct is_instantiation<Class, Class<Us...>> : std::true_type { };
+template <template <typename...> class Class, typename T>
+struct is_instantiation : std::false_type {};
+template <template <typename...> class Class, typename... Us>
+struct is_instantiation<Class, Class<Us...>> : std::true_type {};
 
 /// Check if T is std::shared_ptr<U> where U can be anything
-template <typename T> using is_shared_ptr = is_instantiation<std::shared_ptr, T>;
+template <typename T>
+using is_shared_ptr = is_instantiation<std::shared_ptr, T>;
 
 /// Check if T looks like an input iterator
-template <typename T, typename = void> struct is_input_iterator : std::false_type {};
+template <typename T, typename = void>
+struct is_input_iterator : std::false_type {};
 template <typename T>
-struct is_input_iterator<T, void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>
+struct is_input_iterator<T,
+                         void_t<decltype(*std::declval<T &>()), decltype(++std::declval<T &>())>>
     : std::true_type {};
 
-template <typename T> using is_function_pointer = bool_constant<
-    std::is_pointer<T>::value && std::is_function<typename std::remove_pointer<T>::type>::value>;
-
-template <typename F> struct strip_function_object {
+template <typename T>
+using is_function_pointer
+    = bool_constant<std::is_pointer<T>::value
+                    && std::is_function<typename std::remove_pointer<T>::type>::value>;
+
+template <typename F>
+struct strip_function_object {
+    // If you are encountering an
+    // 'error: name followed by "::" must be a class or namespace name'
+    // with the Intel compiler and a noexcept function here,
+    // try to use noexcept(true) instead of plain noexcept.
     using type = typename remove_class<decltype(&F::operator())>::type;
 };
 
 // Extracts the function signature from a function, function pointer or lambda.
 template <typename Function, typename F = remove_reference_t<Function>>
 using function_signature_t = conditional_t<
     std::is_function<F>::value,
     F,
-    typename conditional_t<
-        std::is_pointer<F>::value || std::is_member_pointer<F>::value,
-        std::remove_pointer<F>,
-        strip_function_object<F>
-    >::type
->;
+    typename conditional_t<std::is_pointer<F>::value || std::is_member_pointer<F>::value,
+                           std::remove_pointer<F>,
+                           strip_function_object<F>>::type>;
 
 /// Returns true if the type looks like a lambda: that is, isn't a function, pointer or member
 /// pointer.  Note that this can catch all sorts of other things, too; this is intended to be used
 /// in a place where passing a lambda makes sense.
-template <typename T> using is_lambda = satisfies_none_of<remove_reference_t<T>,
-        std::is_function, std::is_pointer, std::is_member_pointer>;
-
-/// Ignore that a variable is unused in compiler warnings
-inline void ignore_unused(const int *) { }
+template <typename T>
+using is_lambda = satisfies_none_of<remove_reference_t<T>,
+                                    std::is_function,
+                                    std::is_pointer,
+                                    std::is_member_pointer>;
 
+// [workaround(intel)] Internal error on fold expression
 /// Apply a function over each element of a parameter pack
-#ifdef __cpp_fold_expressions
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)
+#if defined(__cpp_fold_expressions) && !defined(__INTEL_COMPILER)
+// Intel compiler produces an internal error on this fold expression (tested with ICC 19.0.2)
+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (((PATTERN), void()), ...)
 #else
 using expand_side_effects = bool[];
-#define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN) (void)pybind11::detail::expand_side_effects{ ((PATTERN), void(), false)..., false }
+#    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN)                                                 \
+        (void) pybind11::detail::expand_side_effects { ((PATTERN), void(), false)..., false }
 #endif
 
 PYBIND11_NAMESPACE_END(detail)
 
+#if defined(_MSC_VER)
+#    pragma warning(push)
+#    pragma warning(disable : 4275)
+//     warning C4275: An exported class was derived from a class that wasn't exported.
+//     Can be ignored when derived from a STL class.
+#endif
 /// C++ bindings of builtin Python exceptions
-class builtin_exception : public std::runtime_error {
+class PYBIND11_EXPORT_EXCEPTION builtin_exception : public std::runtime_error {
 public:
     using std::runtime_error::runtime_error;
     /// Set the error using the Python C API
     virtual void set_error() const = 0;
 };
+#if defined(_MSC_VER)
+#    pragma warning(pop)
+#endif
 
-#define PYBIND11_RUNTIME_EXCEPTION(name, type) \
-    class name : public builtin_exception { public: \
-        using builtin_exception::builtin_exception; \
-        name() : name("") { } \
-        void set_error() const override { PyErr_SetString(type, what()); } \
+#define PYBIND11_RUNTIME_EXCEPTION(name, type)                                                    \
+    class PYBIND11_EXPORT_EXCEPTION name : public builtin_exception {                             \
+    public:                                                                                       \
+        using builtin_exception::builtin_exception;                                               \
+        name() : name("") {}                                                                      \
+        void set_error() const override { PyErr_SetString(type, what()); }                        \
     };
 
 PYBIND11_RUNTIME_EXCEPTION(stop_iteration, PyExc_StopIteration)
 PYBIND11_RUNTIME_EXCEPTION(index_error, PyExc_IndexError)
 PYBIND11_RUNTIME_EXCEPTION(key_error, PyExc_KeyError)
 PYBIND11_RUNTIME_EXCEPTION(value_error, PyExc_ValueError)
 PYBIND11_RUNTIME_EXCEPTION(type_error, PyExc_TypeError)
 PYBIND11_RUNTIME_EXCEPTION(buffer_error, PyExc_BufferError)
 PYBIND11_RUNTIME_EXCEPTION(import_error, PyExc_ImportError)
-PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or handle::call fail due to a type casting error
+PYBIND11_RUNTIME_EXCEPTION(attribute_error, PyExc_AttributeError)
+PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or
+                                                           /// handle::call fail due to a type
+                                                           /// casting error
 PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally
 
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }
-[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }
+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const char *reason) {
+    throw std::runtime_error(reason);
+}
+[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const std::string &reason) {
+    throw std::runtime_error(reason);
+}
 
-template <typename T, typename SFINAE = void> struct format_descriptor { };
+template <typename T, typename SFINAE = void>
+struct format_descriptor {};
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 // Returns the index of the given type in the type char array below, and in the list in numpy.h
 // The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;
 // complex float,double,long double.  Note that the long double types only participate when long
 // double is actually longer than double (it isn't under MSVC).
 // NB: not only the string below but also complex.h and numpy.h rely on this order.
-template <typename T, typename SFINAE = void> struct is_fmt_numeric { static constexpr bool value = false; };
-template <typename T> struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {
+template <typename T, typename SFINAE = void>
+struct is_fmt_numeric {
+    static constexpr bool value = false;
+};
+template <typename T>
+struct is_fmt_numeric<T, enable_if_t<std::is_arithmetic<T>::value>> {
     static constexpr bool value = true;
-    static constexpr int index = std::is_same<T, bool>::value ? 0 : 1 + (
-        std::is_integral<T>::value ? detail::log2(sizeof(T))*2 + std::is_unsigned<T>::value : 8 + (
-        std::is_same<T, double>::value ? 1 : std::is_same<T, long double>::value ? 2 : 0));
+    static constexpr int index
+        = std::is_same<T, bool>::value
+              ? 0
+              : 1
+                    + (std::is_integral<T>::value
+                           ? detail::log2(sizeof(T)) * 2 + std::is_unsigned<T>::value
+                           : 8
+                                 + (std::is_same<T, double>::value        ? 1
+                                    : std::is_same<T, long double>::value ? 2
+                                                                          : 0));
 };
 PYBIND11_NAMESPACE_END(detail)
 
-template <typename T> struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {
+template <typename T>
+struct format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>> {
     static constexpr const char c = "?bBhHiIqQfdg"[detail::is_fmt_numeric<T>::index];
-    static constexpr const char value[2] = { c, '\0' };
+    static constexpr const char value[2] = {c, '\0'};
     static std::string format() { return std::string(1, c); }
 };
 
 #if !defined(PYBIND11_CPP17)
 
-template <typename T> constexpr const char format_descriptor<
-    T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];
+template <typename T>
+constexpr const char
+    format_descriptor<T, detail::enable_if_t<std::is_arithmetic<T>::value>>::value[2];
 
 #endif
 
 /// RAII wrapper that temporarily clears any Python error state
 struct error_scope {
     PyObject *type, *value, *trace;
     error_scope() { PyErr_Fetch(&type, &value, &trace); }
     ~error_scope() { PyErr_Restore(type, value, trace); }
 };
 
 /// Dummy destructor wrapper that can be used to expose classes with a private destructor
-struct nodelete { template <typename T> void operator()(T*) { } };
+struct nodelete {
+    template <typename T>
+    void operator()(T *) {}
+};
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 template <typename... Args>
 struct overload_cast_impl {
-    constexpr overload_cast_impl() {}; // NOLINT(modernize-use-equals-default):  MSVC 2015 needs this
+    // NOLINTNEXTLINE(modernize-use-equals-default):  MSVC 2015 needs this
+    constexpr overload_cast_impl() {}
 
     template <typename Return>
-    constexpr auto operator()(Return (*pf)(Args...)) const noexcept
-                              -> decltype(pf) { return pf; }
+    constexpr auto operator()(Return (*pf)(Args...)) const noexcept -> decltype(pf) {
+        return pf;
+    }
 
     template <typename Return, typename Class>
     constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept
-                              -> decltype(pmf) { return pmf; }
+        -> decltype(pmf) {
+        return pmf;
+    }
 
     template <typename Return, typename Class>
     constexpr auto operator()(Return (Class::*pmf)(Args...) const, std::true_type) const noexcept
-                              -> decltype(pmf) { return pmf; }
+        -> decltype(pmf) {
+        return pmf;
+    }
 };
 PYBIND11_NAMESPACE_END(detail)
 
 // overload_cast requires variable templates: C++14
 #if defined(PYBIND11_CPP14)
-#define PYBIND11_OVERLOAD_CAST 1
+#    define PYBIND11_OVERLOAD_CAST 1
 /// Syntax sugar for resolving overloaded function pointers:
 ///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)
 ///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)
 template <typename... Args>
 static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
 // MSVC 2015 only accepts this particular initialization syntax for this variable template.
 #endif
 
 /// Const member function selector for overload_cast
 ///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)
 ///  - sweet:   overload_cast<Arg>(&Class::func, const_)
 static constexpr auto const_ = std::true_type{};
 
 #if !defined(PYBIND11_CPP14) // no overload_cast: providing something that static_assert-fails:
-template <typename... Args> struct overload_cast {
+template <typename... Args>
+struct overload_cast {
     static_assert(detail::deferred_t<std::false_type, Args...>::value,
                   "pybind11::overload_cast<...> requires compiling in C++14 mode");
 };
 #endif // overload_cast
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 // Adaptor for converting arbitrary container arguments into a vector; implicitly convertible from
 // any standard container (or C-style array) supporting std::begin/std::end, any singleton
 // arithmetic type (if T is arithmetic), or explicitly constructible from an iterator pair.
 template <typename T>
 class any_container {
     std::vector<T> v;
+
 public:
     any_container() = default;
 
     // Can construct from a pair of iterators
     template <typename It, typename = enable_if_t<is_input_iterator<It>::value>>
-    any_container(It first, It last) : v(first, last) { }
+    any_container(It first, It last) : v(first, last) {}
 
-    // Implicit conversion constructor from any arbitrary container type with values convertible to T
-    template <typename Container, typename = enable_if_t<std::is_convertible<decltype(*std::begin(std::declval<const Container &>())), T>::value>>
-    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) { }
+    // Implicit conversion constructor from any arbitrary container type
+    // with values convertible to T
+    template <typename Container,
+              typename = enable_if_t<
+                  std::is_convertible<decltype(*std::begin(std::declval<const Container &>())),
+                                      T>::value>>
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    any_container(const Container &c) : any_container(std::begin(c), std::end(c)) {}
 
-    // initializer_list's aren't deducible, so don't get matched by the above template; we need this
-    // to explicitly allow implicit conversion from one:
+    // initializer_list's aren't deducible, so don't get matched by the above template;
+    // we need this to explicitly allow implicit conversion from one:
     template <typename TIn, typename = enable_if_t<std::is_convertible<TIn, T>::value>>
-    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) { }
+    any_container(const std::initializer_list<TIn> &c) : any_container(c.begin(), c.end()) {}
 
     // Avoid copying if given an rvalue vector of the correct type.
-    any_container(std::vector<T> &&v) : v(std::move(v)) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    any_container(std::vector<T> &&v) : v(std::move(v)) {}
 
     // Moves the vector out of an rvalue any_container
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator std::vector<T> &&() && { return std::move(v); }
 
     // Dereferencing obtains a reference to the underlying vector
     std::vector<T> &operator*() { return v; }
     const std::vector<T> &operator*() const { return v; }
 
     // -> lets you call methods on the underlying vector
     std::vector<T> *operator->() { return &v; }
     const std::vector<T> *operator->() const { return &v; }
 };
 
 // Forward-declaration; see detail/class.h
-std::string get_fully_qualified_tp_name(PyTypeObject*);
+std::string get_fully_qualified_tp_name(PyTypeObject *);
+
+template <typename T>
+inline static std::shared_ptr<T>
+try_get_shared_from_this(std::enable_shared_from_this<T> *holder_value_ptr) {
+// Pre C++17, this code path exploits undefined behavior, but is known to work on many platforms.
+// Use at your own risk!
+// See also https://en.cppreference.com/w/cpp/memory/enable_shared_from_this, and in particular
+// the `std::shared_ptr<Good> gp1 = not_so_good.getptr();` and `try`-`catch` parts of the example.
+#if defined(__cpp_lib_enable_shared_from_this) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
+    return holder_value_ptr->weak_from_this().lock();
+#else
+    try {
+        return holder_value_ptr->shared_from_this();
+    } catch (const std::bad_weak_ptr &) {
+        return nullptr;
+    }
+#endif
+}
+
+// For silencing "unused" compiler warnings in special situations.
+template <typename... Args>
+#if defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER < 1920 // MSVC 2017
+constexpr
+#endif
+    inline void
+    silence_unused_warnings(Args &&...) {
+}
+
+// MSVC warning C4100: Unreferenced formal parameter
+#if defined(_MSC_VER) && _MSC_VER <= 1916
+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)                                         \
+        detail::silence_unused_warnings(__VA_ARGS__)
+#else
+#    define PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(...)
+#endif
+
+// GCC -Wunused-but-set-parameter  All GCC versions (as of July 2021).
+#if defined(__GNUG__) && !defined(__clang__) && !defined(__INTEL_COMPILER)
+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)                       \
+        detail::silence_unused_warnings(__VA_ARGS__)
+#else
+#    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)
+#endif
+
+#if defined(_MSC_VER) // All versions (as of July 2021).
+
+// warning C4127: Conditional expression is constant
+constexpr inline bool silence_msvc_c4127(bool cond) { return cond; }
+
+#    define PYBIND11_SILENCE_MSVC_C4127(...) ::pybind11::detail::silence_msvc_c4127(__VA_ARGS__)
+
+#else
+#    define PYBIND11_SILENCE_MSVC_C4127(...) __VA_ARGS__
+#endif
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/detail/init.h` & `HepMC3-3.2.6/python/include/pybind11/detail/init.h`

 * *Files 8% similar despite different names*

```diff
@@ -18,98 +18,118 @@
 class type_caster<value_and_holder> {
 public:
     bool load(handle h, bool) {
         value = reinterpret_cast<value_and_holder *>(h.ptr());
         return true;
     }
 
-    template <typename> using cast_op_type = value_and_holder &;
-    operator value_and_holder &() { return *value; }
-    static constexpr auto name = _<value_and_holder>();
+    template <typename>
+    using cast_op_type = value_and_holder &;
+    explicit operator value_and_holder &() { return *value; }
+    static constexpr auto name = const_name<value_and_holder>();
 
 private:
     value_and_holder *value = nullptr;
 };
 
 PYBIND11_NAMESPACE_BEGIN(initimpl)
 
 inline void no_nullptr(void *ptr) {
-    if (!ptr) throw type_error("pybind11::init(): factory function returned nullptr");
+    if (!ptr) {
+        throw type_error("pybind11::init(): factory function returned nullptr");
+    }
 }
 
 // Implementing functions for all forms of py::init<...> and py::init(...)
-template <typename Class> using Cpp = typename Class::type;
-template <typename Class> using Alias = typename Class::type_alias;
-template <typename Class> using Holder = typename Class::holder_type;
+template <typename Class>
+using Cpp = typename Class::type;
+template <typename Class>
+using Alias = typename Class::type_alias;
+template <typename Class>
+using Holder = typename Class::holder_type;
 
-template <typename Class> using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;
+template <typename Class>
+using is_alias_constructible = std::is_constructible<Alias<Class>, Cpp<Class> &&>;
 
 // Takes a Cpp pointer and returns true if it actually is a polymorphic Alias instance.
 template <typename Class, enable_if_t<Class::has_alias, int> = 0>
 bool is_alias(Cpp<Class> *ptr) {
     return dynamic_cast<Alias<Class> *>(ptr) != nullptr;
 }
 // Failing fallback version of the above for a no-alias class (always returns false)
 template <typename /*Class*/>
-constexpr bool is_alias(void *) { return false; }
+constexpr bool is_alias(void *) {
+    return false;
+}
 
 // Constructs and returns a new object; if the given arguments don't map to a constructor, we fall
 // back to brace aggregate initiailization so that for aggregate initialization can be used with
 // py::init, e.g.  `py::init<int, int>` to initialize a `struct T { int a; int b; }`.  For
 // non-aggregate types, we need to use an ordinary T(...) constructor (invoking as `T{...}` usually
 // works, but will not do the expected thing when `T` has an `initializer_list<T>` constructor).
-template <typename Class, typename... Args, detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>
-inline Class *construct_or_initialize(Args &&...args) { return new Class(std::forward<Args>(args)...); }
-template <typename Class, typename... Args, detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>
-inline Class *construct_or_initialize(Args &&...args) { return new Class{std::forward<Args>(args)...}; }
+template <typename Class,
+          typename... Args,
+          detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>
+inline Class *construct_or_initialize(Args &&...args) {
+    return new Class(std::forward<Args>(args)...);
+}
+template <typename Class,
+          typename... Args,
+          detail::enable_if_t<!std::is_constructible<Class, Args...>::value, int> = 0>
+inline Class *construct_or_initialize(Args &&...args) {
+    return new Class{std::forward<Args>(args)...};
+}
 
 // Attempts to constructs an alias using a `Alias(Cpp &&)` constructor.  This allows types with
 // an alias to provide only a single Cpp factory function as long as the Alias can be
 // constructed from an rvalue reference of the base Cpp type.  This means that Alias classes
 // can, when appropriate, simply define a `Alias(Cpp &&)` constructor rather than needing to
 // inherit all the base class constructors.
 template <typename Class>
 void construct_alias_from_cpp(std::true_type /*is_alias_constructible*/,
-                              value_and_holder &v_h, Cpp<Class> &&base) {
+                              value_and_holder &v_h,
+                              Cpp<Class> &&base) {
     v_h.value_ptr() = new Alias<Class>(std::move(base));
 }
 template <typename Class>
 [[noreturn]] void construct_alias_from_cpp(std::false_type /*!is_alias_constructible*/,
-                                           value_and_holder &, Cpp<Class> &&) {
+                                           value_and_holder &,
+                                           Cpp<Class> &&) {
     throw type_error("pybind11::init(): unable to convert returned instance to required "
                      "alias class: no `Alias<Class>(Class &&)` constructor available");
 }
 
 // Error-generating fallback for factories that don't match one of the below construction
 // mechanisms.
 template <typename Class>
 void construct(...) {
     static_assert(!std::is_same<Class, Class>::value /* always false */,
-            "pybind11::init(): init function must return a compatible pointer, "
-            "holder, or value");
+                  "pybind11::init(): init function must return a compatible pointer, "
+                  "holder, or value");
 }
 
 // Pointer return v1: the factory function returns a class pointer for a registered class.
 // If we don't need an alias (because this class doesn't have one, or because the final type is
 // inherited on the Python side) we can simply take over ownership.  Otherwise we need to try to
 // construct an Alias from the returned base instance.
 template <typename Class>
 void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
     no_nullptr(ptr);
-    if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {
+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {
         // We're going to try to construct an alias by moving the cpp type.  Whether or not
         // that succeeds, we still need to destroy the original cpp pointer (either the
         // moved away leftover, if the alias construction works, or the value itself if we
         // throw an error), but we can't just call `delete ptr`: it might have a special
         // deleter, or might be shared_from_this.  So we construct a holder around it as if
         // it was a normal instance, then steal the holder away into a local variable; thus
         // the holder and destruction happens when we leave the C++ scope, and the holder
         // class gets to handle the destruction however it likes.
         v_h.value_ptr() = ptr;
-        v_h.set_instance_registered(true); // To prevent init_instance from registering it
+        v_h.set_instance_registered(true);          // To prevent init_instance from registering it
         v_h.type->init_instance(v_h.inst, nullptr); // Set up the holder
         Holder<Class> temp_holder(std::move(v_h.holder<Holder<Class>>())); // Steal the holder
         v_h.type->dealloc(v_h); // Destroys the moved-out holder remains, resets value ptr to null
         v_h.set_instance_registered(false);
 
         construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(*ptr));
     } else {
@@ -124,213 +144,285 @@
 void construct(value_and_holder &v_h, Alias<Class> *alias_ptr, bool) {
     no_nullptr(alias_ptr);
     v_h.value_ptr() = static_cast<Cpp<Class> *>(alias_ptr);
 }
 
 // Holder return: copy its pointer, and move or copy the returned holder into the new instance's
 // holder.  This also handles types like std::shared_ptr<T> and std::unique_ptr<T> where T is a
-// derived type (through those holder's implicit conversion from derived class holder constructors).
+// derived type (through those holder's implicit conversion from derived class holder
+// constructors).
 template <typename Class>
 void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
     auto *ptr = holder_helper<Holder<Class>>::get(holder);
     no_nullptr(ptr);
     // If we need an alias, check that the held pointer is actually an alias instance
-    if (Class::has_alias && need_alias && !is_alias<Class>(ptr))
+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {
         throw type_error("pybind11::init(): construction failed: returned holder-wrapped instance "
                          "is not an alias instance");
+    }
 
     v_h.value_ptr() = ptr;
     v_h.type->init_instance(v_h.inst, &holder);
 }
 
 // return-by-value version 1: returning a cpp class by value.  If the class has an alias and an
 // alias is required the alias must have an `Alias(Cpp &&)` constructor so that we can construct
 // the alias from the base when needed (i.e. because of Python-side inheritance).  When we don't
 // need it, we simply move-construct the cpp value into a new instance.
 template <typename Class>
 void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {
+    PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
     static_assert(std::is_move_constructible<Cpp<Class>>::value,
-        "pybind11::init() return-by-value factory function requires a movable class");
-    if (Class::has_alias && need_alias)
+                  "pybind11::init() return-by-value factory function requires a movable class");
+    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias) {
         construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(result));
-    else
+    } else {
         v_h.value_ptr() = new Cpp<Class>(std::move(result));
+    }
 }
 
 // return-by-value version 2: returning a value of the alias type itself.  We move-construct an
 // Alias instance (even if no the python-side inheritance is involved).  The is intended for
 // cases where Alias initialization is always desired.
 template <typename Class>
 void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {
-    static_assert(std::is_move_constructible<Alias<Class>>::value,
+    static_assert(
+        std::is_move_constructible<Alias<Class>>::value,
         "pybind11::init() return-by-alias-value factory function requires a movable alias class");
     v_h.value_ptr() = new Alias<Class>(std::move(result));
 }
 
 // Implementing class for py::init<...>()
 template <typename... Args>
 struct constructor {
     template <typename Class, typename... Extra, enable_if_t<!Class::has_alias, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            if (Py_TYPE(v_h.inst) == v_h.type->type)
-                v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
-            else
-                v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+    template <typename Class,
+              typename... Extra,
+              enable_if_t<Class::has_alias && std::is_constructible<Cpp<Class>, Args...>::value,
+                          int> = 0>
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                if (Py_TYPE(v_h.inst) == v_h.type->type) {
+                    v_h.value_ptr()
+                        = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
+                } else {
+                    v_h.value_ptr()
+                        = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+                }
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias &&
-                          !std::is_constructible<Cpp<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+    template <typename Class,
+              typename... Extra,
+              enable_if_t<Class::has_alias && !std::is_constructible<Cpp<Class>, Args...>::value,
+                          int> = 0>
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                v_h.value_ptr()
+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 // Implementing class for py::init_alias<...>()
-template <typename... Args> struct alias_constructor {
-    template <typename Class, typename... Extra,
-              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value, int> = 0>
-    static void execute(Class &cl, const Extra&... extra) {
-        cl.def("__init__", [](value_and_holder &v_h, Args... args) {
-            v_h.value_ptr() = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
-        }, is_new_style_constructor(), extra...);
+template <typename... Args>
+struct alias_constructor {
+    template <typename Class,
+              typename... Extra,
+              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value,
+                          int> = 0>
+    static void execute(Class &cl, const Extra &...extra) {
+        cl.def(
+            "__init__",
+            [](value_and_holder &v_h, Args... args) {
+                v_h.value_ptr()
+                    = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 // Implementation class for py::init(Func) and py::init(Func, AliasFunc)
-template <typename CFunc, typename AFunc = void_type (*)(),
-          typename = function_signature_t<CFunc>, typename = function_signature_t<AFunc>>
+template <typename CFunc,
+          typename AFunc = void_type (*)(),
+          typename = function_signature_t<CFunc>,
+          typename = function_signature_t<AFunc>>
 struct factory;
 
 // Specialization for py::init(Func)
 template <typename Func, typename Return, typename... Args>
 struct factory<Func, void_type (*)(), Return(Args...)> {
     remove_reference_t<Func> class_factory;
 
-    factory(Func &&f) : class_factory(std::forward<Func>(f)) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    factory(Func &&f) : class_factory(std::forward<Func>(f)) {}
 
     // The given class either has no alias or has no separate alias factory;
     // this always constructs the class itself.  If the class is registered with an alias
     // type and an alias instance is needed (i.e. because the final type is a Python class
     // inheriting from the C++ type) the returned value needs to either already be an alias
     // instance, or the alias needs to be constructible from a `Class &&` argument.
     template <typename Class, typename... Extra>
     void execute(Class &cl, const Extra &...extra) && {
-        #if defined(PYBIND11_CPP14)
-        cl.def("__init__", [func = std::move(class_factory)]
-        #else
+#if defined(PYBIND11_CPP14)
+        cl.def(
+            "__init__",
+            [func = std::move(class_factory)]
+#else
         auto &func = class_factory;
-        cl.def("__init__", [func]
-        #endif
-        (value_and_holder &v_h, Args... args) {
-            construct<Class>(v_h, func(std::forward<Args>(args)...),
-                             Py_TYPE(v_h.inst) != v_h.type->type);
-        }, is_new_style_constructor(), extra...);
+        cl.def(
+            "__init__",
+            [func]
+#endif
+            (value_and_holder &v_h, Args... args) {
+                construct<Class>(
+                    v_h, func(std::forward<Args>(args)...), Py_TYPE(v_h.inst) != v_h.type->type);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 // Specialization for py::init(Func, AliasFunc)
-template <typename CFunc, typename AFunc,
-          typename CReturn, typename... CArgs, typename AReturn, typename... AArgs>
+template <typename CFunc,
+          typename AFunc,
+          typename CReturn,
+          typename... CArgs,
+          typename AReturn,
+          typename... AArgs>
 struct factory<CFunc, AFunc, CReturn(CArgs...), AReturn(AArgs...)> {
     static_assert(sizeof...(CArgs) == sizeof...(AArgs),
                   "pybind11::init(class_factory, alias_factory): class and alias factories "
                   "must have identical argument signatures");
     static_assert(all_of<std::is_same<CArgs, AArgs>...>::value,
                   "pybind11::init(class_factory, alias_factory): class and alias factories "
                   "must have identical argument signatures");
 
     remove_reference_t<CFunc> class_factory;
     remove_reference_t<AFunc> alias_factory;
 
     factory(CFunc &&c, AFunc &&a)
-        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) { }
+        : class_factory(std::forward<CFunc>(c)), alias_factory(std::forward<AFunc>(a)) {}
 
     // The class factory is called when the `self` type passed to `__init__` is the direct
     // class (i.e. not inherited), the alias factory when `self` is a Python-side subtype.
     template <typename Class, typename... Extra>
-    void execute(Class &cl, const Extra&... extra) && {
-        static_assert(Class::has_alias, "The two-argument version of `py::init()` can "
-                                        "only be used if the class has an alias");
-        #if defined(PYBIND11_CPP14)
-        cl.def("__init__", [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]
-        #else
+    void execute(Class &cl, const Extra &...extra) && {
+        static_assert(Class::has_alias,
+                      "The two-argument version of `py::init()` can "
+                      "only be used if the class has an alias");
+#if defined(PYBIND11_CPP14)
+        cl.def(
+            "__init__",
+            [class_func = std::move(class_factory), alias_func = std::move(alias_factory)]
+#else
         auto &class_func = class_factory;
         auto &alias_func = alias_factory;
-        cl.def("__init__", [class_func, alias_func]
-        #endif
-        (value_and_holder &v_h, CArgs... args) {
-            if (Py_TYPE(v_h.inst) == v_h.type->type)
-                // If the instance type equals the registered type we don't have inheritance, so
-                // don't need the alias and can construct using the class function:
-                construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);
-            else
-                construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);
-        }, is_new_style_constructor(), extra...);
+        cl.def(
+            "__init__",
+            [class_func, alias_func]
+#endif
+            (value_and_holder &v_h, CArgs... args) {
+                if (Py_TYPE(v_h.inst) == v_h.type->type) {
+                    // If the instance type equals the registered type we don't have inheritance,
+                    // so don't need the alias and can construct using the class function:
+                    construct<Class>(v_h, class_func(std::forward<CArgs>(args)...), false);
+                } else {
+                    construct<Class>(v_h, alias_func(std::forward<CArgs>(args)...), true);
+                }
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 /// Set just the C++ state. Same as `__init__`.
 template <typename Class, typename T>
 void setstate(value_and_holder &v_h, T &&result, bool need_alias) {
     construct<Class>(v_h, std::forward<T>(result), need_alias);
 }
 
 /// Set both the C++ and Python states
-template <typename Class, typename T, typename O,
+template <typename Class,
+          typename T,
+          typename O,
           enable_if_t<std::is_convertible<O, handle>::value, int> = 0>
 void setstate(value_and_holder &v_h, std::pair<T, O> &&result, bool need_alias) {
     construct<Class>(v_h, std::move(result.first), need_alias);
-    setattr((PyObject *) v_h.inst, "__dict__", result.second);
+    auto d = handle(result.second);
+    if (PyDict_Check(d.ptr()) && PyDict_Size(d.ptr()) == 0) {
+        // Skipping setattr below, to not force use of py::dynamic_attr() for Class unnecessarily.
+        // See PR #2972 for details.
+        return;
+    }
+    setattr((PyObject *) v_h.inst, "__dict__", d);
 }
 
 /// Implementation for py::pickle(GetState, SetState)
-template <typename Get, typename Set,
-          typename = function_signature_t<Get>, typename = function_signature_t<Set>>
+template <typename Get,
+          typename Set,
+          typename = function_signature_t<Get>,
+          typename = function_signature_t<Set>>
 struct pickle_factory;
 
-template <typename Get, typename Set,
-          typename RetState, typename Self, typename NewInstance, typename ArgState>
+template <typename Get,
+          typename Set,
+          typename RetState,
+          typename Self,
+          typename NewInstance,
+          typename ArgState>
 struct pickle_factory<Get, Set, RetState(Self), NewInstance(ArgState)> {
     static_assert(std::is_same<intrinsic_t<RetState>, intrinsic_t<ArgState>>::value,
                   "The type returned by `__getstate__` must be the same "
                   "as the argument accepted by `__setstate__`");
 
     remove_reference_t<Get> get;
     remove_reference_t<Set> set;
 
-    pickle_factory(Get get, Set set)
-        : get(std::forward<Get>(get)), set(std::forward<Set>(set)) { }
+    pickle_factory(Get get, Set set) : get(std::forward<Get>(get)), set(std::forward<Set>(set)) {}
 
     template <typename Class, typename... Extra>
     void execute(Class &cl, const Extra &...extra) && {
         cl.def("__getstate__", std::move(get));
 
 #if defined(PYBIND11_CPP14)
-        cl.def("__setstate__", [func = std::move(set)]
+        cl.def(
+            "__setstate__",
+            [func = std::move(set)]
 #else
         auto &func = set;
-        cl.def("__setstate__", [func]
+        cl.def(
+            "__setstate__",
+            [func]
 #endif
-        (value_and_holder &v_h, ArgState state) {
-            setstate<Class>(v_h, func(std::forward<ArgState>(state)),
-                            Py_TYPE(v_h.inst) != v_h.type->type);
-        }, is_new_style_constructor(), extra...);
+            (value_and_holder &v_h, ArgState state) {
+                setstate<Class>(
+                    v_h, func(std::forward<ArgState>(state)), Py_TYPE(v_h.inst) != v_h.type->type);
+            },
+            is_new_style_constructor(),
+            extra...);
     }
 };
 
 PYBIND11_NAMESPACE_END(initimpl)
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(pybind11)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/detail/internals.h` & `HepMC3-3.2.6/python/include/pybind11/detail/internals.h`

 * *Files 19% similar despite different names*

```diff
@@ -7,48 +7,101 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "../pytypes.h"
 
+#include <exception>
+
+/// Tracks the `internals` and `type_info` ABI version independent of the main library version.
+///
+/// Some portions of the code use an ABI that is conditional depending on this
+/// version number.  That allows ABI-breaking changes to be "pre-implemented".
+/// Once the default version number is incremented, the conditional logic that
+/// no longer applies can be removed.  Additionally, users that need not
+/// maintain ABI compatibility can increase the version number in order to take
+/// advantage of any functionality/efficiency improvements that depend on the
+/// newer ABI.
+///
+/// WARNING: If you choose to manually increase the ABI version, note that
+/// pybind11 may not be tested as thoroughly with a non-default ABI version, and
+/// further ABI-incompatible changes may be made before the ABI is officially
+/// changed to the new version.
+#ifndef PYBIND11_INTERNALS_VERSION
+#    define PYBIND11_INTERNALS_VERSION 4
+#endif
+
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+using ExceptionTranslator = void (*)(std::exception_ptr);
+
 PYBIND11_NAMESPACE_BEGIN(detail)
+
 // Forward declarations
 inline PyTypeObject *make_static_property_type();
 inline PyTypeObject *make_default_metaclass();
 inline PyObject *make_object_base_type(PyTypeObject *metaclass);
 
 // The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new
 // Thread Specific Storage (TSS) API.
 #if PY_VERSION_HEX >= 0x03070000
-#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr
-#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))
-#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))
-#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)
-#    define PYBIND11_TLS_FREE(key) PyThread_tss_free(key)
+// Avoid unnecessary allocation of `Py_tss_t`, since we cannot use
+// `Py_LIMITED_API` anyway.
+#    if PYBIND11_INTERNALS_VERSION > 4
+#        define PYBIND11_TLS_KEY_REF Py_tss_t &
+#        ifdef __GNUC__
+// Clang on macOS warns due to `Py_tss_NEEDS_INIT` not specifying an initializer
+// for every field.
+#            define PYBIND11_TLS_KEY_INIT(var)                                                    \
+                _Pragma("GCC diagnostic push")                                         /**/       \
+                    _Pragma("GCC diagnostic ignored \"-Wmissing-field-initializers\"") /**/       \
+                    Py_tss_t var                                                                  \
+                    = Py_tss_NEEDS_INIT;                                                          \
+                _Pragma("GCC diagnostic pop")
+#        else
+#            define PYBIND11_TLS_KEY_INIT(var) Py_tss_t var = Py_tss_NEEDS_INIT;
+#        endif
+#        define PYBIND11_TLS_KEY_CREATE(var) (PyThread_tss_create(&(var)) == 0)
+#        define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get(&(key))
+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set(&(key), (value))
+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set(&(key), nullptr)
+#        define PYBIND11_TLS_FREE(key) PyThread_tss_delete(&(key))
+#    else
+#        define PYBIND11_TLS_KEY_REF Py_tss_t *
+#        define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr;
+#        define PYBIND11_TLS_KEY_CREATE(var)                                                      \
+            (((var) = PyThread_tss_alloc()) != nullptr && (PyThread_tss_create((var)) == 0))
+#        define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))
+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))
+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)
+#        define PYBIND11_TLS_FREE(key) PyThread_tss_free(key)
+#    endif
 #else
-    // Usually an int but a long on Cygwin64 with Python 3.x
-#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0
+// Usually an int but a long on Cygwin64 with Python 3.x
+#    define PYBIND11_TLS_KEY_REF decltype(PyThread_create_key())
+#    define PYBIND11_TLS_KEY_INIT(var) PYBIND11_TLS_KEY_REF var = 0;
+#    define PYBIND11_TLS_KEY_CREATE(var) (((var) = PyThread_create_key()) != -1)
 #    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))
-#    if PY_MAJOR_VERSION < 3
-#        define PYBIND11_TLS_DELETE_VALUE(key)                               \
-             PyThread_delete_key_value(key)
-#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \
-             do {                                                            \
-                 PyThread_delete_key_value((key));                           \
-                 PyThread_set_key_value((key), (value));                     \
-             } while (false)
+#    if PY_MAJOR_VERSION < 3 || defined(PYPY_VERSION)
+// On CPython < 3.4 and on PyPy, `PyThread_set_key_value` strangely does not set
+// the value if it has already been set.  Instead, it must first be deleted and
+// then set again.
+inline void tls_replace_value(PYBIND11_TLS_KEY_REF key, void *value) {
+    PyThread_delete_key_value(key);
+    PyThread_set_key_value(key, value);
+}
+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_delete_key_value(key)
+#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                                            \
+            ::pybind11::detail::tls_replace_value((key), (value))
 #    else
-#        define PYBIND11_TLS_DELETE_VALUE(key)                               \
-             PyThread_set_key_value((key), nullptr)
-#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \
-             PyThread_set_key_value((key), (value))
+#        define PYBIND11_TLS_DELETE_VALUE(key) PyThread_set_key_value((key), nullptr)
+#        define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_set_key_value((key), (value))
 #    endif
-#    define PYBIND11_TLS_FREE(key) (void)key
+#    define PYBIND11_TLS_FREE(key) (void) key
 #endif
 
 // Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly
 // other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module
 // even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under
 // libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,
 // which works.  If not under a known-good stl, provide our own name-based hash and equality
@@ -62,16 +115,17 @@
     return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;
 }
 
 struct type_hash {
     size_t operator()(const std::type_index &t) const {
         size_t hash = 5381;
         const char *ptr = t.name();
-        while (auto c = static_cast<unsigned char>(*ptr++))
+        while (auto c = static_cast<unsigned char>(*ptr++)) {
             hash = (hash * 33) ^ c;
+        }
         return hash;
     }
 };
 
 struct type_equal_to {
     bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {
         return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;
@@ -79,245 +133,400 @@
 };
 #endif
 
 template <typename value_type>
 using type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;
 
 struct override_hash {
-    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {
+    inline size_t operator()(const std::pair<const PyObject *, const char *> &v) const {
         size_t value = std::hash<const void *>()(v.first);
-        value ^= std::hash<const void *>()(v.second) + 0x9e3779b9 + (value<<6) + (value>>2);
+        value ^= std::hash<const void *>()(v.second) + 0x9e3779b9 + (value << 6) + (value >> 2);
         return value;
     }
 };
 
 /// Internal data structure used to track registered instances and types.
 /// Whenever binary incompatible changes are made to this structure,
 /// `PYBIND11_INTERNALS_VERSION` must be incremented.
 struct internals {
-    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information
-    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)
-    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*
-    std::unordered_set<std::pair<const PyObject *, const char *>, override_hash> inactive_override_cache;
+    // std::type_index -> pybind11's type information
+    type_map<type_info *> registered_types_cpp;
+    // PyTypeObject* -> base type_info(s)
+    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py;
+    std::unordered_multimap<const void *, instance *> registered_instances; // void * -> instance*
+    std::unordered_set<std::pair<const PyObject *, const char *>, override_hash>
+        inactive_override_cache;
     type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;
     std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;
-    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;
-    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions
-    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`
-    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()
+    std::forward_list<ExceptionTranslator> registered_exception_translators;
+    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across
+                                                         // extensions
+#if PYBIND11_INTERNALS_VERSION == 4
+    std::vector<PyObject *> unused_loader_patient_stack_remove_at_v5;
+#endif
+    std::forward_list<std::string> static_strings; // Stores the std::strings backing
+                                                   // detail::c_str()
     PyTypeObject *static_property_type;
     PyTypeObject *default_metaclass;
     PyObject *instance_base;
 #if defined(WITH_THREAD)
-    PYBIND11_TLS_KEY_INIT(tstate);
+    PYBIND11_TLS_KEY_INIT(tstate)
+#    if PYBIND11_INTERNALS_VERSION > 4
+    PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)
+#    endif // PYBIND11_INTERNALS_VERSION > 4
     PyInterpreterState *istate = nullptr;
     ~internals() {
+#    if PYBIND11_INTERNALS_VERSION > 4
+        PYBIND11_TLS_FREE(loader_life_support_tls_key);
+#    endif // PYBIND11_INTERNALS_VERSION > 4
+
         // This destructor is called *after* Py_Finalize() in finalize_interpreter().
-        // That *SHOULD BE* fine. The following details what happens whe PyThread_tss_free is called.
-        // PYBIND11_TLS_FREE is PyThread_tss_free on python 3.7+. On older python, it does nothing.
-        // PyThread_tss_free calls PyThread_tss_delete and PyMem_RawFree.
-        // PyThread_tss_delete just calls TlsFree (on Windows) or pthread_key_delete (on *NIX). Neither
-        // of those have anything to do with CPython internals.
-        // PyMem_RawFree *requires* that the `tstate` be allocated with the CPython allocator.
+        // That *SHOULD BE* fine. The following details what happens when PyThread_tss_free is
+        // called. PYBIND11_TLS_FREE is PyThread_tss_free on python 3.7+. On older python, it does
+        // nothing. PyThread_tss_free calls PyThread_tss_delete and PyMem_RawFree.
+        // PyThread_tss_delete just calls TlsFree (on Windows) or pthread_key_delete (on *NIX).
+        // Neither of those have anything to do with CPython internals. PyMem_RawFree *requires*
+        // that the `tstate` be allocated with the CPython allocator.
         PYBIND11_TLS_FREE(tstate);
     }
 #endif
 };
 
 /// Additional type information which does not fit into the PyTypeObject.
 /// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.
 struct type_info {
     PyTypeObject *type;
     const std::type_info *cpptype;
     size_t type_size, type_align, holder_size_in_ptrs;
     void *(*operator_new)(size_t);
     void (*init_instance)(instance *, const void *);
     void (*dealloc)(value_and_holder &v_h);
-    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;
-    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;
+    std::vector<PyObject *(*) (PyObject *, PyTypeObject *)> implicit_conversions;
+    std::vector<std::pair<const std::type_info *, void *(*) (void *)>> implicit_casts;
     std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;
     buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;
     void *get_buffer_data = nullptr;
     void *(*module_local_load)(PyObject *, const type_info *) = nullptr;
     /* A simple type never occurs as a (direct or indirect) parent
-     * of a class that makes use of multiple inheritance */
+     * of a class that makes use of multiple inheritance.
+     * A type can be simple even if it has non-simple ancestors as long as it has no descendants.
+     */
     bool simple_type : 1;
     /* True if there is no multiple inheritance in this type's inheritance tree */
     bool simple_ancestors : 1;
     /* for base vs derived holder_type checks */
     bool default_holder : 1;
     /* true if this is a type registered with py::module_local */
     bool module_local : 1;
 };
 
-/// Tracks the `internals` and `type_info` ABI version independent of the main library version
-#define PYBIND11_INTERNALS_VERSION 4
-
 /// On MSVC, debug and release builds are not ABI-compatible!
 #if defined(_MSC_VER) && defined(_DEBUG)
-#  define PYBIND11_BUILD_TYPE "_debug"
+#    define PYBIND11_BUILD_TYPE "_debug"
 #else
-#  define PYBIND11_BUILD_TYPE ""
+#    define PYBIND11_BUILD_TYPE ""
 #endif
 
 /// Let's assume that different compilers are ABI-incompatible.
 /// A user can manually set this string if they know their
 /// compiler is compatible.
 #ifndef PYBIND11_COMPILER_TYPE
-#  if defined(_MSC_VER)
-#    define PYBIND11_COMPILER_TYPE "_msvc"
-#  elif defined(__INTEL_COMPILER)
-#    define PYBIND11_COMPILER_TYPE "_icc"
-#  elif defined(__clang__)
-#    define PYBIND11_COMPILER_TYPE "_clang"
-#  elif defined(__PGI)
-#    define PYBIND11_COMPILER_TYPE "_pgi"
-#  elif defined(__MINGW32__)
-#    define PYBIND11_COMPILER_TYPE "_mingw"
-#  elif defined(__CYGWIN__)
-#    define PYBIND11_COMPILER_TYPE "_gcc_cygwin"
-#  elif defined(__GNUC__)
-#    define PYBIND11_COMPILER_TYPE "_gcc"
-#  else
-#    define PYBIND11_COMPILER_TYPE "_unknown"
-#  endif
+#    if defined(_MSC_VER)
+#        define PYBIND11_COMPILER_TYPE "_msvc"
+#    elif defined(__INTEL_COMPILER)
+#        define PYBIND11_COMPILER_TYPE "_icc"
+#    elif defined(__clang__)
+#        define PYBIND11_COMPILER_TYPE "_clang"
+#    elif defined(__PGI)
+#        define PYBIND11_COMPILER_TYPE "_pgi"
+#    elif defined(__MINGW32__)
+#        define PYBIND11_COMPILER_TYPE "_mingw"
+#    elif defined(__CYGWIN__)
+#        define PYBIND11_COMPILER_TYPE "_gcc_cygwin"
+#    elif defined(__GNUC__)
+#        define PYBIND11_COMPILER_TYPE "_gcc"
+#    else
+#        define PYBIND11_COMPILER_TYPE "_unknown"
+#    endif
 #endif
 
 /// Also standard libs
 #ifndef PYBIND11_STDLIB
-#  if defined(_LIBCPP_VERSION)
-#    define PYBIND11_STDLIB "_libcpp"
-#  elif defined(__GLIBCXX__) || defined(__GLIBCPP__)
-#    define PYBIND11_STDLIB "_libstdcpp"
-#  else
-#    define PYBIND11_STDLIB ""
-#  endif
+#    if defined(_LIBCPP_VERSION)
+#        define PYBIND11_STDLIB "_libcpp"
+#    elif defined(__GLIBCXX__) || defined(__GLIBCPP__)
+#        define PYBIND11_STDLIB "_libstdcpp"
+#    else
+#        define PYBIND11_STDLIB ""
+#    endif
 #endif
 
 /// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.
 #ifndef PYBIND11_BUILD_ABI
-#  if defined(__GXX_ABI_VERSION)
-#    define PYBIND11_BUILD_ABI "_cxxabi" PYBIND11_TOSTRING(__GXX_ABI_VERSION)
-#  else
-#    define PYBIND11_BUILD_ABI ""
-#  endif
+#    if defined(__GXX_ABI_VERSION)
+#        define PYBIND11_BUILD_ABI "_cxxabi" PYBIND11_TOSTRING(__GXX_ABI_VERSION)
+#    else
+#        define PYBIND11_BUILD_ABI ""
+#    endif
 #endif
 
 #ifndef PYBIND11_INTERNALS_KIND
-#  if defined(WITH_THREAD)
-#    define PYBIND11_INTERNALS_KIND ""
-#  else
-#    define PYBIND11_INTERNALS_KIND "_without_thread"
-#  endif
+#    if defined(WITH_THREAD)
+#        define PYBIND11_INTERNALS_KIND ""
+#    else
+#        define PYBIND11_INTERNALS_KIND "_without_thread"
+#    endif
 #endif
 
-#define PYBIND11_INTERNALS_ID "__pybind11_internals_v" \
-    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE "__"
-
-#define PYBIND11_MODULE_LOCAL_ID "__pybind11_module_local_v" \
-    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE "__"
+#define PYBIND11_INTERNALS_ID                                                                     \
+    "__pybind11_internals_v" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)                        \
+        PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI         \
+            PYBIND11_BUILD_TYPE "__"
+
+#define PYBIND11_MODULE_LOCAL_ID                                                                  \
+    "__pybind11_module_local_v" PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION)                     \
+        PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI         \
+            PYBIND11_BUILD_TYPE "__"
 
 /// Each module locally stores a pointer to the `internals` data. The data
 /// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.
 inline internals **&get_internals_pp() {
     static internals **internals_pp = nullptr;
     return internals_pp;
 }
 
+#if PY_VERSION_HEX >= 0x03030000
+// forward decl
+inline void translate_exception(std::exception_ptr);
+
+template <class T,
+          enable_if_t<std::is_same<std::nested_exception, remove_cvref_t<T>>::value, int> = 0>
+bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {
+    std::exception_ptr nested = exc.nested_ptr();
+    if (nested != nullptr && nested != p) {
+        translate_exception(nested);
+        return true;
+    }
+    return false;
+}
+
+template <class T,
+          enable_if_t<!std::is_same<std::nested_exception, remove_cvref_t<T>>::value, int> = 0>
+bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {
+    if (const auto *nep = dynamic_cast<const std::nested_exception *>(std::addressof(exc))) {
+        return handle_nested_exception(*nep, p);
+    }
+    return false;
+}
+
+#else
+
+template <class T>
+bool handle_nested_exception(const T &, std::exception_ptr &) {
+    return false;
+}
+#endif
+
+inline bool raise_err(PyObject *exc_type, const char *msg) {
+#if PY_VERSION_HEX >= 0x03030000
+    if (PyErr_Occurred()) {
+        raise_from(exc_type, msg);
+        return true;
+    }
+#endif
+    PyErr_SetString(exc_type, msg);
+    return false;
+}
+
 inline void translate_exception(std::exception_ptr p) {
+    if (!p) {
+        return;
+    }
     try {
-        if (p) std::rethrow_exception(p);
-    } catch (error_already_set &e)           { e.restore();                                    return;
-    } catch (const builtin_exception &e)     { e.set_error();                                  return;
-    } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;
-    } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-    } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-    } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-    } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;
-    } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;
-    } catch (const std::overflow_error &e)   { PyErr_SetString(PyExc_OverflowError, e.what()); return;
-    } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;
+        std::rethrow_exception(p);
+    } catch (error_already_set &e) {
+        handle_nested_exception(e, p);
+        e.restore();
+        return;
+    } catch (const builtin_exception &e) {
+        // Could not use template since it's an abstract class.
+        if (const auto *nep = dynamic_cast<const std::nested_exception *>(std::addressof(e))) {
+            handle_nested_exception(*nep, p);
+        }
+        e.set_error();
+        return;
+    } catch (const std::bad_alloc &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_MemoryError, e.what());
+        return;
+    } catch (const std::domain_error &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_ValueError, e.what());
+        return;
+    } catch (const std::invalid_argument &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_ValueError, e.what());
+        return;
+    } catch (const std::length_error &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_ValueError, e.what());
+        return;
+    } catch (const std::out_of_range &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_IndexError, e.what());
+        return;
+    } catch (const std::range_error &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_ValueError, e.what());
+        return;
+    } catch (const std::overflow_error &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_OverflowError, e.what());
+        return;
+    } catch (const std::exception &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_RuntimeError, e.what());
+        return;
+    } catch (const std::nested_exception &e) {
+        handle_nested_exception(e, p);
+        raise_err(PyExc_RuntimeError, "Caught an unknown nested exception!");
+        return;
     } catch (...) {
-        PyErr_SetString(PyExc_RuntimeError, "Caught an unknown exception!");
+        raise_err(PyExc_RuntimeError, "Caught an unknown exception!");
         return;
     }
 }
 
 #if !defined(__GLIBCXX__)
 inline void translate_local_exception(std::exception_ptr p) {
     try {
-        if (p) std::rethrow_exception(p);
-    } catch (error_already_set &e)       { e.restore();   return;
-    } catch (const builtin_exception &e) { e.set_error(); return;
+        if (p) {
+            std::rethrow_exception(p);
+        }
+    } catch (error_already_set &e) {
+        e.restore();
+        return;
+    } catch (const builtin_exception &e) {
+        e.set_error();
+        return;
     }
 }
 #endif
 
 /// Return a reference to the current `internals` data
-PYBIND11_NOINLINE inline internals &get_internals() {
+PYBIND11_NOINLINE internals &get_internals() {
     auto **&internals_pp = get_internals_pp();
-    if (internals_pp && *internals_pp)
+    if (internals_pp && *internals_pp) {
         return **internals_pp;
+    }
 
     // Ensure that the GIL is held since we will need to make Python calls.
     // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.
     struct gil_scoped_acquire_local {
-        gil_scoped_acquire_local() : state (PyGILState_Ensure()) {}
+        gil_scoped_acquire_local() : state(PyGILState_Ensure()) {}
         ~gil_scoped_acquire_local() { PyGILState_Release(state); }
         const PyGILState_STATE state;
     } gil;
 
-    constexpr auto *id = PYBIND11_INTERNALS_ID;
+    PYBIND11_STR_TYPE id(PYBIND11_INTERNALS_ID);
     auto builtins = handle(PyEval_GetBuiltins());
     if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {
         internals_pp = static_cast<internals **>(capsule(builtins[id]));
 
         // We loaded builtins through python's builtins, which means that our `error_already_set`
         // and `builtin_exception` may be different local classes than the ones set up in the
         // initial exception translator, below, so add another for our local exception classes.
         //
         // libstdc++ doesn't require this (types there are identified only by name)
+        // libc++ with CPython doesn't require this (types are explicitly exported)
+        // libc++ with PyPy still need it, awaiting further investigation
 #if !defined(__GLIBCXX__)
         (*internals_pp)->registered_exception_translators.push_front(&translate_local_exception);
 #endif
     } else {
-        if (!internals_pp) internals_pp = new internals*();
+        if (!internals_pp) {
+            internals_pp = new internals *();
+        }
         auto *&internals_ptr = *internals_pp;
         internals_ptr = new internals();
 #if defined(WITH_THREAD)
 
-        #if PY_VERSION_HEX < 0x03090000
-                PyEval_InitThreads();
-        #endif
+#    if PY_VERSION_HEX < 0x03090000
+        PyEval_InitThreads();
+#    endif
         PyThreadState *tstate = PyThreadState_Get();
-        #if PY_VERSION_HEX >= 0x03070000
-            internals_ptr->tstate = PyThread_tss_alloc();
-            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))
-                pybind11_fail("get_internals: could not successfully initialize the TSS key!");
-            PyThread_tss_set(internals_ptr->tstate, tstate);
-        #else
-            internals_ptr->tstate = PyThread_create_key();
-            if (internals_ptr->tstate == -1)
-                pybind11_fail("get_internals: could not successfully initialize the TLS key!");
-            PyThread_set_key_value(internals_ptr->tstate, tstate);
-        #endif
+        if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->tstate)) {
+            pybind11_fail("get_internals: could not successfully initialize the tstate TSS key!");
+        }
+        PYBIND11_TLS_REPLACE_VALUE(internals_ptr->tstate, tstate);
+
+#    if PYBIND11_INTERNALS_VERSION > 4
+        if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->loader_life_support_tls_key)) {
+            pybind11_fail("get_internals: could not successfully initialize the "
+                          "loader_life_support TSS key!");
+        }
+#    endif
         internals_ptr->istate = tstate->interp;
 #endif
         builtins[id] = capsule(internals_pp);
         internals_ptr->registered_exception_translators.push_front(&translate_exception);
         internals_ptr->static_property_type = make_static_property_type();
         internals_ptr->default_metaclass = make_default_metaclass();
         internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);
     }
     return **internals_pp;
 }
 
-/// Works like `internals.registered_types_cpp`, but for module-local registered types:
-inline type_map<type_info *> &registered_local_types_cpp() {
-    static type_map<type_info *> locals{};
+// the internals struct (above) is shared between all the modules. local_internals are only
+// for a single module. Any changes made to internals may require an update to
+// PYBIND11_INTERNALS_VERSION, breaking backwards compatibility. local_internals is, by design,
+// restricted to a single module. Whether a module has local internals or not should not
+// impact any other modules, because the only things accessing the local internals is the
+// module that contains them.
+struct local_internals {
+    type_map<type_info *> registered_types_cpp;
+    std::forward_list<ExceptionTranslator> registered_exception_translators;
+#if defined(WITH_THREAD) && PYBIND11_INTERNALS_VERSION == 4
+
+    // For ABI compatibility, we can't store the loader_life_support TLS key in
+    // the `internals` struct directly.  Instead, we store it in `shared_data` and
+    // cache a copy in `local_internals`.  If we allocated a separate TLS key for
+    // each instance of `local_internals`, we could end up allocating hundreds of
+    // TLS keys if hundreds of different pybind11 modules are loaded (which is a
+    // plausible number).
+    PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)
+
+    // Holds the shared TLS key for the loader_life_support stack.
+    struct shared_loader_life_support_data {
+        PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)
+        shared_loader_life_support_data() {
+            if (!PYBIND11_TLS_KEY_CREATE(loader_life_support_tls_key)) {
+                pybind11_fail("local_internals: could not successfully initialize the "
+                              "loader_life_support TLS key!");
+            }
+        }
+        // We can't help but leak the TLS key, because Python never unloads extension modules.
+    };
+
+    local_internals() {
+        auto &internals = get_internals();
+        // Get or create the `loader_life_support_stack_key`.
+        auto &ptr = internals.shared_data["_life_support"];
+        if (!ptr) {
+            ptr = new shared_loader_life_support_data;
+        }
+        loader_life_support_tls_key
+            = static_cast<shared_loader_life_support_data *>(ptr)->loader_life_support_tls_key;
+    }
+#endif //  defined(WITH_THREAD) && PYBIND11_INTERNALS_VERSION == 4
+};
+
+/// Works like `get_internals`, but for things which are locally registered.
+inline local_internals &get_local_internals() {
+    static local_internals locals;
     return locals;
 }
 
 /// Constructs a std::string with the given arguments, stores it in `internals`, and returns its
 /// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only
 /// cleared when the program exits or after interpreter shutdown (when embedding), and so are
 /// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).
@@ -329,30 +538,30 @@
 }
 
 PYBIND11_NAMESPACE_END(detail)
 
 /// Returns a named pointer that is shared among all extension modules (using the same
 /// pybind11 version) running in the current interpreter. Names starting with underscores
 /// are reserved for internal usage. Returns `nullptr` if no matching entry was found.
-inline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {
+PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {
     auto &internals = detail::get_internals();
     auto it = internals.shared_data.find(name);
     return it != internals.shared_data.end() ? it->second : nullptr;
 }
 
 /// Set the shared data that can be later recovered by `get_shared_data()`.
-inline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {
+PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {
     detail::get_internals().shared_data[name] = data;
     return data;
 }
 
 /// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if
 /// such entry exists. Otherwise, a new object of default-constructible type `T` is
 /// added to the shared data under the given name and a reference to it is returned.
-template<typename T>
+template <typename T>
 T &get_or_create_shared_data(const std::string &name) {
     auto &internals = detail::get_internals();
     auto it = internals.shared_data.find(name);
     T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);
     if (!ptr) {
         ptr = new T();
         internals.shared_data[name] = ptr;
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/detail/typeid.h` & `HepMC3-3.2.6/python/include/pybind11/detail/typeid.h`

 * *Files 12% similar despite different names*

```diff
@@ -9,47 +9,51 @@
 
 #pragma once
 
 #include <cstdio>
 #include <cstdlib>
 
 #if defined(__GNUG__)
-#include <cxxabi.h>
+#    include <cxxabi.h>
 #endif
 
 #include "common.h"
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 /// Erase all occurrences of a substring
 inline void erase_all(std::string &string, const std::string &search) {
     for (size_t pos = 0;;) {
         pos = string.find(search, pos);
-        if (pos == std::string::npos) break;
+        if (pos == std::string::npos) {
+            break;
+        }
         string.erase(pos, search.length());
     }
 }
 
-PYBIND11_NOINLINE inline void clean_type_id(std::string &name) {
+PYBIND11_NOINLINE void clean_type_id(std::string &name) {
 #if defined(__GNUG__)
     int status = 0;
-    std::unique_ptr<char, void (*)(void *)> res {
-        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free };
-    if (status == 0)
+    std::unique_ptr<char, void (*)(void *)> res{
+        abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status), std::free};
+    if (status == 0) {
         name = res.get();
+    }
 #else
     detail::erase_all(name, "class ");
     detail::erase_all(name, "struct ");
     detail::erase_all(name, "enum ");
 #endif
     detail::erase_all(name, "pybind11::");
 }
 PYBIND11_NAMESPACE_END(detail)
 
 /// Return a string representation of a C++ type
-template <typename T> static std::string type_id() {
+template <typename T>
+static std::string type_id() {
     std::string name(typeid(T).name());
     detail::clean_type_id(name);
     return name;
 }
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/eigen.h` & `HepMC3-3.2.6/python/include/pybind11/eigen.h`

 * *Files 11% similar despite different names*

```diff
@@ -5,226 +5,261 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
-#include "numpy.h"
+/* HINT: To suppress warnings originating from the Eigen headers, use -isystem.
+   See also:
+       https://stackoverflow.com/questions/2579576/i-dir-vs-isystem-dir
+       https://stackoverflow.com/questions/1741816/isystem-for-ms-visual-studio-c-compiler
+*/
 
-#if defined(__INTEL_COMPILER)
-#  pragma warning(disable: 1682) // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
-#elif defined(__GNUG__) || defined(__clang__)
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wconversion"
-#  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-#  ifdef __clang__
-//   Eigen generates a bunch of implicit-copy-constructor-is-deprecated warnings with -Wdeprecated
-//   under Clang, so disable that warning here:
-#    pragma GCC diagnostic ignored "-Wdeprecated"
-#  endif
-#  if __GNUC__ >= 7
-#    pragma GCC diagnostic ignored "-Wint-in-bool-context"
-#  endif
-#endif
+#include "numpy.h"
 
+// The C4127 suppression was introduced for Eigen 3.4.0. In theory we could
+// make it version specific, or even remove it later, but considering that
+// 1. C4127 is generally far more distracting than useful for modern template code, and
+// 2. we definitely want to ignore any MSVC warnings originating from Eigen code,
+// it is probably best to keep this around indefinitely.
 #if defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#  pragma warning(disable: 4996) // warning C4996: std::unary_negate is deprecated in C++17
+#    pragma warning(push)
+#    pragma warning(disable : 4127) // C4127: conditional expression is constant
 #endif
 
 #include <Eigen/Core>
 #include <Eigen/SparseCore>
 
+#if defined(_MSC_VER)
+#    pragma warning(pop)
+#endif
+
 // Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit
 // move constructors that break things.  We could detect this an explicitly copy, but an extra copy
 // of matrices seems highly undesirable.
-static_assert(EIGEN_VERSION_AT_LEAST(3,2,7), "Eigen support in pybind11 requires Eigen >= 3.2.7");
+static_assert(EIGEN_VERSION_AT_LEAST(3, 2, 7),
+              "Eigen support in pybind11 requires Eigen >= 3.2.7");
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 // Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:
 using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;
-template <typename MatrixType> using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;
-template <typename MatrixType> using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;
+template <typename MatrixType>
+using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;
+template <typename MatrixType>
+using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-#if EIGEN_VERSION_AT_LEAST(3,3,0)
+#if EIGEN_VERSION_AT_LEAST(3, 3, 0)
 using EigenIndex = Eigen::Index;
+template <typename Scalar, int Flags, typename StorageIndex>
+using EigenMapSparseMatrix = Eigen::Map<Eigen::SparseMatrix<Scalar, Flags, StorageIndex>>;
 #else
 using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;
+template <typename Scalar, int Flags, typename StorageIndex>
+using EigenMapSparseMatrix = Eigen::MappedSparseMatrix<Scalar, Flags, StorageIndex>;
 #endif
 
 // Matches Eigen::Map, Eigen::Ref, blocks, etc:
-template <typename T> using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>, std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;
-template <typename T> using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;
-template <typename T> using is_eigen_dense_plain = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;
-template <typename T> using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;
+template <typename T>
+using is_eigen_dense_map = all_of<is_template_base_of<Eigen::DenseBase, T>,
+                                  std::is_base_of<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>>;
+template <typename T>
+using is_eigen_mutable_map = std::is_base_of<Eigen::MapBase<T, Eigen::WriteAccessors>, T>;
+template <typename T>
+using is_eigen_dense_plain
+    = all_of<negation<is_eigen_dense_map<T>>, is_template_base_of<Eigen::PlainObjectBase, T>>;
+template <typename T>
+using is_eigen_sparse = is_template_base_of<Eigen::SparseMatrixBase, T>;
 // Test for objects inheriting from EigenBase<Derived> that aren't captured by the above.  This
 // basically covers anything that can be assigned to a dense matrix but that don't have a typical
 // matrix data layout that can be copied from their .data().  For example, DiagonalMatrix and
 // SelfAdjointView fall into this category.
-template <typename T> using is_eigen_other = all_of<
-    is_template_base_of<Eigen::EigenBase, T>,
-    negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>
->;
+template <typename T>
+using is_eigen_other
+    = all_of<is_template_base_of<Eigen::EigenBase, T>,
+             negation<any_of<is_eigen_dense_map<T>, is_eigen_dense_plain<T>, is_eigen_sparse<T>>>>;
 
 // Captures numpy/eigen conformability status (returned by EigenProps::conformable()):
-template <bool EigenRowMajor> struct EigenConformable {
+template <bool EigenRowMajor>
+struct EigenConformable {
     bool conformable = false;
     EigenIndex rows = 0, cols = 0;
-    EigenDStride stride{0, 0};      // Only valid if negativestrides is false!
-    bool negativestrides = false;   // If true, do not use stride!
+    EigenDStride stride{0, 0};    // Only valid if negativestrides is false!
+    bool negativestrides = false; // If true, do not use stride!
 
+    // NOLINTNEXTLINE(google-explicit-constructor)
     EigenConformable(bool fits = false) : conformable{fits} {}
     // Matrix type:
-    EigenConformable(EigenIndex r, EigenIndex c,
-            EigenIndex rstride, EigenIndex cstride) :
-        conformable{true}, rows{r}, cols{c} {
-        // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity. http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747
-        if (rstride < 0 || cstride < 0) {
-            negativestrides = true;
-        } else {
-            stride = {EigenRowMajor ? rstride : cstride /* outer stride */,
-                      EigenRowMajor ? cstride : rstride /* inner stride */ };
-        }
-    }
+    EigenConformable(EigenIndex r, EigenIndex c, EigenIndex rstride, EigenIndex cstride)
+        : conformable{true}, rows{r}, cols{c},
+          // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity.
+          // http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747
+          stride{EigenRowMajor ? (rstride > 0 ? rstride : 0)
+                               : (cstride > 0 ? cstride : 0) /* outer stride */,
+                 EigenRowMajor ? (cstride > 0 ? cstride : 0)
+                               : (rstride > 0 ? rstride : 0) /* inner stride */},
+          negativestrides{rstride < 0 || cstride < 0} {}
     // Vector type:
     EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)
-        : EigenConformable(r, c, r == 1 ? c*stride : stride, c == 1 ? r : r*stride) {}
+        : EigenConformable(r, c, r == 1 ? c * stride : stride, c == 1 ? r : r * stride) {}
 
-    template <typename props> bool stride_compatible() const {
+    template <typename props>
+    bool stride_compatible() const {
         // To have compatible strides, we need (on both dimensions) one of fully dynamic strides,
-        // matching strides, or a dimension size of 1 (in which case the stride value is irrelevant)
-        return
-            !negativestrides &&
-            (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner() ||
-                (EigenRowMajor ? cols : rows) == 1) &&
-            (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer() ||
-                (EigenRowMajor ? rows : cols) == 1);
+        // matching strides, or a dimension size of 1 (in which case the stride value is
+        // irrelevant)
+        return !negativestrides
+               && (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner()
+                   || (EigenRowMajor ? cols : rows) == 1)
+               && (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer()
+                   || (EigenRowMajor ? rows : cols) == 1);
     }
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator bool() const { return conformable; }
 };
 
-template <typename Type> struct eigen_extract_stride { using type = Type; };
+template <typename Type>
+struct eigen_extract_stride {
+    using type = Type;
+};
 template <typename PlainObjectType, int MapOptions, typename StrideType>
-struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> { using type = StrideType; };
+struct eigen_extract_stride<Eigen::Map<PlainObjectType, MapOptions, StrideType>> {
+    using type = StrideType;
+};
 template <typename PlainObjectType, int Options, typename StrideType>
-struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> { using type = StrideType; };
+struct eigen_extract_stride<Eigen::Ref<PlainObjectType, Options, StrideType>> {
+    using type = StrideType;
+};
 
 // Helper struct for extracting information from an Eigen type
-template <typename Type_> struct EigenProps {
+template <typename Type_>
+struct EigenProps {
     using Type = Type_;
     using Scalar = typename Type::Scalar;
     using StrideType = typename eigen_extract_stride<Type>::type;
-    static constexpr EigenIndex
-        rows = Type::RowsAtCompileTime,
-        cols = Type::ColsAtCompileTime,
-        size = Type::SizeAtCompileTime;
-    static constexpr bool
-        row_major = Type::IsRowMajor,
-        vector = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1
-        fixed_rows = rows != Eigen::Dynamic,
-        fixed_cols = cols != Eigen::Dynamic,
-        fixed = size != Eigen::Dynamic, // Fully-fixed size
-        dynamic = !fixed_rows && !fixed_cols; // Fully-dynamic size
-
-    template <EigenIndex i, EigenIndex ifzero> using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;
-    static constexpr EigenIndex inner_stride = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,
-                                outer_stride = if_zero<StrideType::OuterStrideAtCompileTime,
-                                                       vector ? size : row_major ? cols : rows>::value;
-    static constexpr bool dynamic_stride = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;
-    static constexpr bool requires_row_major = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;
-    static constexpr bool requires_col_major = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;
+    static constexpr EigenIndex rows = Type::RowsAtCompileTime, cols = Type::ColsAtCompileTime,
+                                size = Type::SizeAtCompileTime;
+    static constexpr bool row_major = Type::IsRowMajor,
+                          vector
+                          = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1
+        fixed_rows = rows != Eigen::Dynamic, fixed_cols = cols != Eigen::Dynamic,
+                          fixed = size != Eigen::Dynamic, // Fully-fixed size
+        dynamic = !fixed_rows && !fixed_cols;             // Fully-dynamic size
+
+    template <EigenIndex i, EigenIndex ifzero>
+    using if_zero = std::integral_constant<EigenIndex, i == 0 ? ifzero : i>;
+    static constexpr EigenIndex inner_stride
+        = if_zero<StrideType::InnerStrideAtCompileTime, 1>::value,
+        outer_stride = if_zero < StrideType::OuterStrideAtCompileTime,
+        vector      ? size
+        : row_major ? cols
+                    : rows > ::value;
+    static constexpr bool dynamic_stride
+        = inner_stride == Eigen::Dynamic && outer_stride == Eigen::Dynamic;
+    static constexpr bool requires_row_major
+        = !dynamic_stride && !vector && (row_major ? inner_stride : outer_stride) == 1;
+    static constexpr bool requires_col_major
+        = !dynamic_stride && !vector && (row_major ? outer_stride : inner_stride) == 1;
 
     // Takes an input array and determines whether we can make it fit into the Eigen type.  If
     // the array is a vector, we attempt to fit it into either an Eigen 1xN or Nx1 vector
     // (preferring the latter if it will fit in either, i.e. for a fully dynamic matrix type).
     static EigenConformable<row_major> conformable(const array &a) {
         const auto dims = a.ndim();
-        if (dims < 1 || dims > 2)
+        if (dims < 1 || dims > 2) {
             return false;
+        }
 
         if (dims == 2) { // Matrix type: require exact match (or dynamic)
 
-            EigenIndex
-                np_rows = a.shape(0),
-                np_cols = a.shape(1),
-                np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),
-                np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));
-            if ((fixed_rows && np_rows != rows) || (fixed_cols && np_cols != cols))
+            EigenIndex np_rows = a.shape(0), np_cols = a.shape(1),
+                       np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),
+                       np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));
+            if ((PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && np_rows != rows)
+                || (PYBIND11_SILENCE_MSVC_C4127(fixed_cols) && np_cols != cols)) {
                 return false;
+            }
 
             return {np_rows, np_cols, np_rstride, np_cstride};
         }
 
-        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but whichever
-        // is used, we want the (single) numpy stride value.
+        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but
+        // whichever is used, we want the (single) numpy stride value.
         const EigenIndex n = a.shape(0),
-              stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));
+                         stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));
 
         if (vector) { // Eigen type is a compile-time vector
-            if (fixed && size != n)
+            if (PYBIND11_SILENCE_MSVC_C4127(fixed) && size != n) {
                 return false; // Vector size mismatch
+            }
             return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};
         }
-        else if (fixed) {
+        if (fixed) {
             // The type has a fixed size, but is not a vector: abort
             return false;
         }
-        else if (fixed_cols) {
+        if (fixed_cols) {
             // Since this isn't a vector, cols must be != 1.  We allow this only if it exactly
             // equals the number of elements (rows is Dynamic, and so 1 row is allowed).
-            if (cols != n) return false;
+            if (cols != n) {
+                return false;
+            }
             return {1, n, stride};
+        } // Otherwise it's either fully dynamic, or column dynamic; both become a column vector
+        if (PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && rows != n) {
+            return false;
         }
-        else {
-            // Otherwise it's either fully dynamic, or column dynamic; both become a column vector
-            if (fixed_rows && rows != n) return false;
-            return {n, 1, stride};
-        }
+        return {n, 1, stride};
     }
 
-    static constexpr bool show_writeable = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
+    static constexpr bool show_writeable
+        = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
     static constexpr bool show_order = is_eigen_dense_map<Type>::value;
     static constexpr bool show_c_contiguous = show_order && requires_row_major;
-    static constexpr bool show_f_contiguous = !show_c_contiguous && show_order && requires_col_major;
+    static constexpr bool show_f_contiguous
+        = !show_c_contiguous && show_order && requires_col_major;
 
-    static constexpr auto descriptor =
-        _("numpy.ndarray[") + npy_format_descriptor<Scalar>::name +
-        _("[")  + _<fixed_rows>(_<(size_t) rows>(), _("m")) +
-        _(", ") + _<fixed_cols>(_<(size_t) cols>(), _("n")) +
-        _("]") +
-        // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to be
-        // satisfied: writeable=True (for a mutable reference), and, depending on the map's stride
-        // options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output
-        // to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to
-        // see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you
-        // *gave* a numpy.ndarray of the right type and dimensions.
-        _<show_writeable>(", flags.writeable", "") +
-        _<show_c_contiguous>(", flags.c_contiguous", "") +
-        _<show_f_contiguous>(", flags.f_contiguous", "") +
-        _("]");
+    static constexpr auto descriptor
+        = const_name("numpy.ndarray[") + npy_format_descriptor<Scalar>::name + const_name("[")
+          + const_name<fixed_rows>(const_name<(size_t) rows>(), const_name("m")) + const_name(", ")
+          + const_name<fixed_cols>(const_name<(size_t) cols>(), const_name("n")) + const_name("]")
+          +
+          // For a reference type (e.g. Ref<MatrixXd>) we have other constraints that might need to
+          // be satisfied: writeable=True (for a mutable reference), and, depending on the map's
+          // stride options, possibly f_contiguous or c_contiguous.  We include them in the
+          // descriptor output to provide some hint as to why a TypeError is occurring (otherwise
+          // it can be confusing to see that a function accepts a 'numpy.ndarray[float64[3,2]]' and
+          // an error message that you *gave* a numpy.ndarray of the right type and dimensions.
+          const_name<show_writeable>(", flags.writeable", "")
+          + const_name<show_c_contiguous>(", flags.c_contiguous", "")
+          + const_name<show_f_contiguous>(", flags.f_contiguous", "") + const_name("]");
 };
 
 // Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,
 // otherwise it'll make a copy.  writeable lets you turn off the writeable flag for the array.
-template <typename props> handle eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {
+template <typename props>
+handle
+eigen_array_cast(typename props::Type const &src, handle base = handle(), bool writeable = true) {
     constexpr ssize_t elem_size = sizeof(typename props::Scalar);
     array a;
-    if (props::vector)
-        a = array({ src.size() }, { elem_size * src.innerStride() }, src.data(), base);
-    else
-        a = array({ src.rows(), src.cols() }, { elem_size * src.rowStride(), elem_size * src.colStride() },
-                  src.data(), base);
+    if (props::vector) {
+        a = array({src.size()}, {elem_size * src.innerStride()}, src.data(), base);
+    } else {
+        a = array({src.rows(), src.cols()},
+                  {elem_size * src.rowStride(), elem_size * src.colStride()},
+                  src.data(),
+                  base);
+    }
 
-    if (!writeable)
+    if (!writeable) {
         array_proxy(a.ptr())->flags &= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;
+    }
 
     return a.release();
 }
 
 // Takes an lvalue ref to some Eigen type and a (python) base object, creating a numpy array that
 // reference the Eigen object's data with `base` as the python-registered base class (if omitted,
 // the base will be set to None, and lifetime management is up to the caller).  The numpy array is
@@ -232,68 +267,74 @@
 template <typename props, typename Type>
 handle eigen_ref_array(Type &src, handle parent = none()) {
     // none here is to get past array's should-we-copy detection, which currently always
     // copies when there is no base.  Setting the base to None should be harmless.
     return eigen_array_cast<props>(src, parent, !std::is_const<Type>::value);
 }
 
-// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a numpy
-// array that references the encapsulated data with a python-side reference to the capsule to tie
-// its destruction to that of any dependent python objects.  Const-ness is determined by whether or
-// not the Type of the pointer given is const.
+// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a
+// numpy array that references the encapsulated data with a python-side reference to the capsule to
+// tie its destruction to that of any dependent python objects.  Const-ness is determined by
+// whether or not the Type of the pointer given is const.
 template <typename props, typename Type, typename = enable_if_t<is_eigen_dense_plain<Type>::value>>
 handle eigen_encapsulate(Type *src) {
     capsule base(src, [](void *o) { delete static_cast<Type *>(o); });
     return eigen_ref_array<props>(*src, base);
 }
 
 // Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense
 // types.
-template<typename Type>
+template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {
     using Scalar = typename Type::Scalar;
     using props = EigenProps<Type>;
 
     bool load(handle src, bool convert) {
         // If we're in no-convert mode, only load if given an array of the correct type
-        if (!convert && !isinstance<array_t<Scalar>>(src))
+        if (!convert && !isinstance<array_t<Scalar>>(src)) {
             return false;
+        }
 
         // Coerce into an array, but don't do type conversion yet; the copy below handles it.
         auto buf = array::ensure(src);
 
-        if (!buf)
+        if (!buf) {
             return false;
+        }
 
         auto dims = buf.ndim();
-        if (dims < 1 || dims > 2)
+        if (dims < 1 || dims > 2) {
             return false;
+        }
 
         auto fits = props::conformable(buf);
-        if (!fits)
+        if (!fits) {
             return false;
+        }
 
         // Allocate the new type, then build a numpy reference into it
         value = Type(fits.rows, fits.cols);
         auto ref = reinterpret_steal<array>(eigen_ref_array<props>(value));
-        if (dims == 1) ref = ref.squeeze();
-        else if (ref.ndim() == 1) buf = buf.squeeze();
+        if (dims == 1) {
+            ref = ref.squeeze();
+        } else if (ref.ndim() == 1) {
+            buf = buf.squeeze();
+        }
 
         int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());
 
         if (result < 0) { // Copy failed!
             PyErr_Clear();
             return false;
         }
 
         return true;
     }
 
 private:
-
     // Cast implementation
     template <typename CType>
     static handle cast_impl(CType *src, return_value_policy policy, handle parent) {
         switch (policy) {
             case return_value_policy::take_ownership:
             case return_value_policy::automatic:
                 return eigen_encapsulate<props>(src);
@@ -308,68 +349,75 @@
                 return eigen_ref_array<props>(*src, parent);
             default:
                 throw cast_error("unhandled return_value_policy: should not happen!");
         };
     }
 
 public:
-
     // Normal returned non-reference, non-const value:
     static handle cast(Type &&src, return_value_policy /* policy */, handle parent) {
         return cast_impl(&src, return_value_policy::move, parent);
     }
     // If you return a non-reference const, we mark the numpy array readonly:
     static handle cast(const Type &&src, return_value_policy /* policy */, handle parent) {
         return cast_impl(&src, return_value_policy::move, parent);
     }
     // lvalue reference return; default (automatic) becomes copy
     static handle cast(Type &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
+        if (policy == return_value_policy::automatic
+            || policy == return_value_policy::automatic_reference) {
             policy = return_value_policy::copy;
+        }
         return cast_impl(&src, policy, parent);
     }
     // const lvalue reference return; default (automatic) becomes copy
     static handle cast(const Type &src, return_value_policy policy, handle parent) {
-        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
+        if (policy == return_value_policy::automatic
+            || policy == return_value_policy::automatic_reference) {
             policy = return_value_policy::copy;
+        }
         return cast(&src, policy, parent);
     }
     // non-const pointer return
     static handle cast(Type *src, return_value_policy policy, handle parent) {
         return cast_impl(src, policy, parent);
     }
     // const pointer return
     static handle cast(const Type *src, return_value_policy policy, handle parent) {
         return cast_impl(src, policy, parent);
     }
 
     static constexpr auto name = props::descriptor;
 
-    operator Type*() { return &value; }
-    operator Type&() { return value; }
-    operator Type&&() && { return std::move(value); }
-    template <typename T> using cast_op_type = movable_cast_op_type<T>;
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type *() { return &value; }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type &() { return value; }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type &&() && { return std::move(value); }
+    template <typename T>
+    using cast_op_type = movable_cast_op_type<T>;
 
 private:
     Type value;
 };
 
 // Base class for casting reference/map/block/etc. objects back to python.
-template <typename MapType> struct eigen_map_caster {
+template <typename MapType>
+struct eigen_map_caster {
 private:
     using props = EigenProps<MapType>;
 
 public:
-
     // Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has
-    // to stay around), but we'll allow it under the assumption that you know what you're doing (and
-    // have an appropriate keep_alive in place).  We return a numpy array pointing directly at the
-    // ref's data (The numpy array ends up read-only if the ref was to a const matrix type.) Note
-    // that this means you need to ensure you don't destroy the object in some other way (e.g. with
-    // an appropriate keep_alive, or with a reference to a statically allocated matrix).
+    // to stay around), but we'll allow it under the assumption that you know what you're doing
+    // (and have an appropriate keep_alive in place).  We return a numpy array pointing directly at
+    // the ref's data (The numpy array ends up read-only if the ref was to a const matrix type.)
+    // Note that this means you need to ensure you don't destroy the object in some other way (e.g.
+    // with an appropriate keep_alive, or with a reference to a statically allocated matrix).
     static handle cast(const MapType &src, return_value_policy policy, handle parent) {
         switch (policy) {
             case return_value_policy::copy:
                 return eigen_array_cast<props>(src);
             case return_value_policy::reference_internal:
                 return eigen_array_cast<props>(src, parent, is_eigen_mutable_map<MapType>::value);
             case return_value_policy::reference:
@@ -385,177 +433,220 @@
     static constexpr auto name = props::descriptor;
 
     // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
     // types but not bound arguments).  We still provide them (with an explicitly delete) so that
     // you end up here if you try anyway.
     bool load(handle, bool) = delete;
     operator MapType() = delete;
-    template <typename> using cast_op_type = MapType;
+    template <typename>
+    using cast_op_type = MapType;
 };
 
 // We can return any map-like object (but can only load Refs, specialized next):
-template <typename Type> struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>>
-    : eigen_map_caster<Type> {};
+template <typename Type>
+struct type_caster<Type, enable_if_t<is_eigen_dense_map<Type>::value>> : eigen_map_caster<Type> {};
 
 // Loader for Ref<...> arguments.  See the documentation for info on how to make this work without
 // copying (it requires some extra effort in many cases).
 template <typename PlainObjectType, typename StrideType>
 struct type_caster<
     Eigen::Ref<PlainObjectType, 0, StrideType>,
-    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>
-> : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {
+    enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>>
+    : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {
 private:
     using Type = Eigen::Ref<PlainObjectType, 0, StrideType>;
     using props = EigenProps<Type>;
     using Scalar = typename props::Scalar;
     using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;
-    using Array = array_t<Scalar, array::forcecast |
-                ((props::row_major ? props::inner_stride : props::outer_stride) == 1 ? array::c_style :
-                 (props::row_major ? props::outer_stride : props::inner_stride) == 1 ? array::f_style : 0)>;
+    using Array
+        = array_t<Scalar,
+                  array::forcecast
+                      | ((props::row_major ? props::inner_stride : props::outer_stride) == 1
+                             ? array::c_style
+                         : (props::row_major ? props::outer_stride : props::inner_stride) == 1
+                             ? array::f_style
+                             : 0)>;
     static constexpr bool need_writeable = is_eigen_mutable_map<Type>::value;
     // Delay construction (these have no default constructor)
     std::unique_ptr<MapType> map;
     std::unique_ptr<Type> ref;
     // Our array.  When possible, this is just a numpy array pointing to the source data, but
-    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an incompatible
-    // layout, or is an array of a type that needs to be converted).  Using a numpy temporary
-    // (rather than an Eigen temporary) saves an extra copy when we need both type conversion and
-    // storage order conversion.  (Note that we refuse to use this temporary copy when loading an
-    // argument for a Ref<M> with M non-const, i.e. a read-write reference).
+    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an
+    // incompatible layout, or is an array of a type that needs to be converted).  Using a numpy
+    // temporary (rather than an Eigen temporary) saves an extra copy when we need both type
+    // conversion and storage order conversion.  (Note that we refuse to use this temporary copy
+    // when loading an argument for a Ref<M> with M non-const, i.e. a read-write reference).
     Array copy_or_ref;
+
 public:
     bool load(handle src, bool convert) {
-        // First check whether what we have is already an array of the right type.  If not, we can't
-        // avoid a copy (because the copy is also going to do type conversion).
+        // First check whether what we have is already an array of the right type.  If not, we
+        // can't avoid a copy (because the copy is also going to do type conversion).
         bool need_copy = !isinstance<Array>(src);
 
         EigenConformable<props::row_major> fits;
         if (!need_copy) {
             // We don't need a converting copy, but we also need to check whether the strides are
             // compatible with the Ref's stride requirements
-            Array aref = reinterpret_borrow<Array>(src);
+            auto aref = reinterpret_borrow<Array>(src);
 
             if (aref && (!need_writeable || aref.writeable())) {
                 fits = props::conformable(aref);
-                if (!fits) return false; // Incompatible dimensions
-                if (!fits.template stride_compatible<props>())
+                if (!fits) {
+                    return false; // Incompatible dimensions
+                }
+                if (!fits.template stride_compatible<props>()) {
                     need_copy = true;
-                else
+                } else {
                     copy_or_ref = std::move(aref);
-            }
-            else {
+                }
+            } else {
                 need_copy = true;
             }
         }
 
         if (need_copy) {
             // We need to copy: If we need a mutable reference, or we're not supposed to convert
             // (either because we're in the no-convert overload pass, or because we're explicitly
             // instructed not to copy (via `py::arg().noconvert()`) we have to fail loading.
-            if (!convert || need_writeable) return false;
+            if (!convert || need_writeable) {
+                return false;
+            }
 
             Array copy = Array::ensure(src);
-            if (!copy) return false;
+            if (!copy) {
+                return false;
+            }
             fits = props::conformable(copy);
-            if (!fits || !fits.template stride_compatible<props>())
+            if (!fits || !fits.template stride_compatible<props>()) {
                 return false;
+            }
             copy_or_ref = std::move(copy);
             loader_life_support::add_patient(copy_or_ref);
         }
 
         ref.reset();
-        map.reset(new MapType(data(copy_or_ref), fits.rows, fits.cols, make_stride(fits.stride.outer(), fits.stride.inner())));
+        map.reset(new MapType(data(copy_or_ref),
+                              fits.rows,
+                              fits.cols,
+                              make_stride(fits.stride.outer(), fits.stride.inner())));
         ref.reset(new Type(*map));
 
         return true;
     }
 
-    operator Type*() { return ref.get(); }
-    operator Type&() { return *ref; }
-    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type *() { return ref.get(); }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator Type &() { return *ref; }
+    template <typename _T>
+    using cast_op_type = pybind11::detail::cast_op_type<_T>;
 
 private:
     template <typename T = Type, enable_if_t<is_eigen_mutable_map<T>::value, int> = 0>
-    Scalar *data(Array &a) { return a.mutable_data(); }
+    Scalar *data(Array &a) {
+        return a.mutable_data();
+    }
 
     template <typename T = Type, enable_if_t<!is_eigen_mutable_map<T>::value, int> = 0>
-    const Scalar *data(Array &a) { return a.data(); }
+    const Scalar *data(Array &a) {
+        return a.data();
+    }
 
     // Attempt to figure out a constructor of `Stride` that will work.
     // If both strides are fixed, use a default constructor:
-    template <typename S> using stride_ctor_default = bool_constant<
-        S::InnerStrideAtCompileTime != Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_default_constructible<S>::value>;
+    template <typename S>
+    using stride_ctor_default = bool_constant<S::InnerStrideAtCompileTime != Eigen::Dynamic
+                                              && S::OuterStrideAtCompileTime != Eigen::Dynamic
+                                              && std::is_default_constructible<S>::value>;
     // Otherwise, if there is a two-index constructor, assume it is (outer,inner) like
     // Eigen::Stride, and use it:
-    template <typename S> using stride_ctor_dual = bool_constant<
-        !stride_ctor_default<S>::value && std::is_constructible<S, EigenIndex, EigenIndex>::value>;
+    template <typename S>
+    using stride_ctor_dual
+        = bool_constant<!stride_ctor_default<S>::value
+                        && std::is_constructible<S, EigenIndex, EigenIndex>::value>;
     // Otherwise, if there is a one-index constructor, and just one of the strides is dynamic, use
     // it (passing whichever stride is dynamic).
-    template <typename S> using stride_ctor_outer = bool_constant<
-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&
-        S::OuterStrideAtCompileTime == Eigen::Dynamic && S::InnerStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_constructible<S, EigenIndex>::value>;
-    template <typename S> using stride_ctor_inner = bool_constant<
-        !any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value &&
-        S::InnerStrideAtCompileTime == Eigen::Dynamic && S::OuterStrideAtCompileTime != Eigen::Dynamic &&
-        std::is_constructible<S, EigenIndex>::value>;
+    template <typename S>
+    using stride_ctor_outer
+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value
+                        && S::OuterStrideAtCompileTime == Eigen::Dynamic
+                        && S::InnerStrideAtCompileTime != Eigen::Dynamic
+                        && std::is_constructible<S, EigenIndex>::value>;
+    template <typename S>
+    using stride_ctor_inner
+        = bool_constant<!any_of<stride_ctor_default<S>, stride_ctor_dual<S>>::value
+                        && S::InnerStrideAtCompileTime == Eigen::Dynamic
+                        && S::OuterStrideAtCompileTime != Eigen::Dynamic
+                        && std::is_constructible<S, EigenIndex>::value>;
 
     template <typename S = StrideType, enable_if_t<stride_ctor_default<S>::value, int> = 0>
-    static S make_stride(EigenIndex, EigenIndex) { return S(); }
+    static S make_stride(EigenIndex, EigenIndex) {
+        return S();
+    }
     template <typename S = StrideType, enable_if_t<stride_ctor_dual<S>::value, int> = 0>
-    static S make_stride(EigenIndex outer, EigenIndex inner) { return S(outer, inner); }
+    static S make_stride(EigenIndex outer, EigenIndex inner) {
+        return S(outer, inner);
+    }
     template <typename S = StrideType, enable_if_t<stride_ctor_outer<S>::value, int> = 0>
-    static S make_stride(EigenIndex outer, EigenIndex) { return S(outer); }
+    static S make_stride(EigenIndex outer, EigenIndex) {
+        return S(outer);
+    }
     template <typename S = StrideType, enable_if_t<stride_ctor_inner<S>::value, int> = 0>
-    static S make_stride(EigenIndex, EigenIndex inner) { return S(inner); }
-
+    static S make_stride(EigenIndex, EigenIndex inner) {
+        return S(inner);
+    }
 };
 
 // type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not
 // EigenDense (i.e. they don't have a data(), at least not with the usual matrix layout).
 // load() is not supported, but we can cast them into the python domain by first copying to a
 // regular Eigen::Matrix, then casting that.
 template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {
 protected:
-    using Matrix = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;
+    using Matrix
+        = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;
     using props = EigenProps<Matrix>;
+
 public:
     static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
         handle h = eigen_encapsulate<props>(new Matrix(src));
         return h;
     }
-    static handle cast(const Type *src, return_value_policy policy, handle parent) { return cast(*src, policy, parent); }
+    static handle cast(const Type *src, return_value_policy policy, handle parent) {
+        return cast(*src, policy, parent);
+    }
 
     static constexpr auto name = props::descriptor;
 
     // Explicitly delete these: support python -> C++ conversion on these (i.e. these can be return
     // types but not bound arguments).  We still provide them (with an explicitly delete) so that
     // you end up here if you try anyway.
     bool load(handle, bool) = delete;
     operator Type() = delete;
-    template <typename> using cast_op_type = Type;
+    template <typename>
+    using cast_op_type = Type;
 };
 
-template<typename Type>
+template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {
-    typedef typename Type::Scalar Scalar;
-    typedef remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())> StorageIndex;
-    typedef typename Type::Index Index;
+    using Scalar = typename Type::Scalar;
+    using StorageIndex = remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())>;
+    using Index = typename Type::Index;
     static constexpr bool rowMajor = Type::IsRowMajor;
 
     bool load(handle src, bool) {
-        if (!src)
+        if (!src) {
             return false;
+        }
 
         auto obj = reinterpret_borrow<object>(src);
         object sparse_module = module_::import("scipy.sparse");
-        object matrix_type = sparse_module.attr(
-            rowMajor ? "csr_matrix" : "csc_matrix");
+        object matrix_type = sparse_module.attr(rowMajor ? "csr_matrix" : "csc_matrix");
 
         if (!type::handle_of(obj).is(matrix_type)) {
             try {
                 obj = matrix_type(obj);
             } catch (const error_already_set &) {
                 return false;
             }
@@ -563,45 +654,46 @@
 
         auto values = array_t<Scalar>((object) obj.attr("data"));
         auto innerIndices = array_t<StorageIndex>((object) obj.attr("indices"));
         auto outerIndices = array_t<StorageIndex>((object) obj.attr("indptr"));
         auto shape = pybind11::tuple((pybind11::object) obj.attr("shape"));
         auto nnz = obj.attr("nnz").cast<Index>();
 
-        if (!values || !innerIndices || !outerIndices)
+        if (!values || !innerIndices || !outerIndices) {
             return false;
+        }
 
-        value = Eigen::MappedSparseMatrix<Scalar, Type::Flags, StorageIndex>(
-            shape[0].cast<Index>(), shape[1].cast<Index>(), nnz,
-            outerIndices.mutable_data(), innerIndices.mutable_data(), values.mutable_data());
+        value = EigenMapSparseMatrix<Scalar,
+                                     Type::Flags &(Eigen::RowMajor | Eigen::ColMajor),
+                                     StorageIndex>(shape[0].cast<Index>(),
+                                                   shape[1].cast<Index>(),
+                                                   nnz,
+                                                   outerIndices.mutable_data(),
+                                                   innerIndices.mutable_data(),
+                                                   values.mutable_data());
 
         return true;
     }
 
     static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
-        const_cast<Type&>(src).makeCompressed();
+        const_cast<Type &>(src).makeCompressed();
 
-        object matrix_type = module_::import("scipy.sparse").attr(
-            rowMajor ? "csr_matrix" : "csc_matrix");
+        object matrix_type
+            = module_::import("scipy.sparse").attr(rowMajor ? "csr_matrix" : "csc_matrix");
 
         array data(src.nonZeros(), src.valuePtr());
         array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());
         array innerIndices(src.nonZeros(), src.innerIndexPtr());
 
-        return matrix_type(
-            std::make_tuple(data, innerIndices, outerIndices),
-            std::make_pair(src.rows(), src.cols())
-        ).release();
+        return matrix_type(std::make_tuple(data, innerIndices, outerIndices),
+                           std::make_pair(src.rows(), src.cols()))
+            .release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _<(Type::IsRowMajor) != 0>("scipy.sparse.csr_matrix[", "scipy.sparse.csc_matrix[")
-            + npy_format_descriptor<Scalar>::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type,
+                         const_name<(Type::IsRowMajor) != 0>("scipy.sparse.csr_matrix[",
+                                                             "scipy.sparse.csc_matrix[")
+                             + npy_format_descriptor<Scalar>::name + const_name("]"));
 };
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(__GNUG__) || defined(__clang__)
-#  pragma GCC diagnostic pop
-#elif defined(_MSC_VER)
-#  pragma warning(pop)
-#endif
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/functional.h` & `HepMC3-3.2.6/python/include/pybind11/functional.h`

 * *Files 17% similar despite different names*

```diff
@@ -6,99 +6,126 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
+
 #include <functional>
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <typename Return, typename... Args>
 struct type_caster<std::function<Return(Args...)>> {
     using type = std::function<Return(Args...)>;
     using retval_type = conditional_t<std::is_same<Return, void>::value, void_type, Return>;
-    using function_type = Return (*) (Args...);
+    using function_type = Return (*)(Args...);
 
 public:
     bool load(handle src, bool convert) {
         if (src.is_none()) {
             // Defer accepting None to other overloads (if we aren't in convert mode):
-            if (!convert) return false;
+            if (!convert) {
+                return false;
+            }
             return true;
         }
 
-        if (!isinstance<function>(src))
+        if (!isinstance<function>(src)) {
             return false;
+        }
 
         auto func = reinterpret_borrow<function>(src);
 
         /*
            When passing a C++ function as an argument to another C++
            function via Python, every function call would normally involve
            a full C++ -> Python -> C++ roundtrip, which can be prohibitive.
            Here, we try to at least detect the case where the function is
            stateless (i.e. function pointer or lambda function without
            captured variables), in which case the roundtrip can be avoided.
          */
         if (auto cfunc = func.cpp_function()) {
-            auto c = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(cfunc.ptr()));
-            auto rec = (function_record *) c;
-
-            if (rec && rec->is_stateless &&
-                    same_type(typeid(function_type), *reinterpret_cast<const std::type_info *>(rec->data[1]))) {
-                struct capture { function_type f; };
-                value = ((capture *) &rec->data)->f;
-                return true;
+            auto *cfunc_self = PyCFunction_GET_SELF(cfunc.ptr());
+            if (isinstance<capsule>(cfunc_self)) {
+                auto c = reinterpret_borrow<capsule>(cfunc_self);
+                auto *rec = (function_record *) c;
+
+                while (rec != nullptr) {
+                    if (rec->is_stateless
+                        && same_type(typeid(function_type),
+                                     *reinterpret_cast<const std::type_info *>(rec->data[1]))) {
+                        struct capture {
+                            function_type f;
+                        };
+                        value = ((capture *) &rec->data)->f;
+                        return true;
+                    }
+                    rec = rec->next;
+                }
             }
+            // PYPY segfaults here when passing builtin function like sum.
+            // Raising an fail exception here works to prevent the segfault, but only on gcc.
+            // See PR #1413 for full details
         }
 
         // ensure GIL is held during functor destruction
         struct func_handle {
             function f;
-            func_handle(function&& f_) : f(std::move(f_)) {}
-            func_handle(const func_handle& f_) {
+#if !(defined(_MSC_VER) && _MSC_VER == 1916 && defined(PYBIND11_CPP17))
+            // This triggers a syntax error under very special conditions (very weird indeed).
+            explicit
+#endif
+                func_handle(function &&f_) noexcept
+                : f(std::move(f_)) {
+            }
+            func_handle(const func_handle &f_) { operator=(f_); }
+            func_handle &operator=(const func_handle &f_) {
                 gil_scoped_acquire acq;
                 f = f_.f;
+                return *this;
             }
             ~func_handle() {
                 gil_scoped_acquire acq;
                 function kill_f(std::move(f));
             }
         };
 
         // to emulate 'move initialization capture' in C++11
         struct func_wrapper {
             func_handle hfunc;
-            func_wrapper(func_handle&& hf): hfunc(std::move(hf)) {}
+            explicit func_wrapper(func_handle &&hf) noexcept : hfunc(std::move(hf)) {}
             Return operator()(Args... args) const {
                 gil_scoped_acquire acq;
                 object retval(hfunc.f(std::forward<Args>(args)...));
                 /* Visual studio 2015 parser issue: need parentheses around this expression */
                 return (retval.template cast<Return>());
             }
         };
 
         value = func_wrapper(func_handle(std::move(func)));
         return true;
     }
 
     template <typename Func>
     static handle cast(Func &&f_, return_value_policy policy, handle /* parent */) {
-        if (!f_)
+        if (!f_) {
             return none().inc_ref();
+        }
 
         auto result = f_.template target<function_type>();
-        if (result)
+        if (result) {
             return cpp_function(*result, policy).release();
-        else
-            return cpp_function(std::forward<Func>(f_), policy).release();
+        }
+        return cpp_function(std::forward<Func>(f_), policy).release();
     }
 
-    PYBIND11_TYPE_CASTER(type, _("Callable[[") + concat(make_caster<Args>::name...) + _("], ")
-                               + make_caster<retval_type>::name + _("]"));
+    PYBIND11_TYPE_CASTER(type,
+                         const_name("Callable[[") + concat(make_caster<Args>::name...)
+                             + const_name("], ") + make_caster<retval_type>::name
+                             + const_name("]"));
 };
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/numpy.h` & `HepMC3-3.2.6/python/include/pybind11/numpy.h`

 * *Files 4% similar despite different names*

```diff
@@ -7,32 +7,28 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
 #include "complex.h"
-#include <numeric>
+
 #include <algorithm>
 #include <array>
 #include <cstdint>
 #include <cstdlib>
 #include <cstring>
+#include <functional>
+#include <numeric>
 #include <sstream>
 #include <string>
-#include <functional>
 #include <type_traits>
+#include <typeindex>
 #include <utility>
 #include <vector>
-#include <typeindex>
-
-#if defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
 
 /* This will be true on all flat address space platforms and allows us to reduce the
    whole npy_intp / ssize_t / Py_intptr_t business down to just ssize_t for all size
    and dimension types (e.g. shape, strides, indexing), instead of inflicting this
    upon the library user. */
 static_assert(sizeof(::pybind11::ssize_t) == sizeof(Py_intptr_t), "ssize_t != Py_intptr_t");
 static_assert(std::is_signed<Py_intptr_t>::value, "Py_intptr_t must be signed");
@@ -40,17 +36,21 @@
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 class array; // Forward declaration
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <> struct handle_type_name<array> { static constexpr auto name = _("numpy.ndarray"); };
+template <>
+struct handle_type_name<array> {
+    static constexpr auto name = const_name("numpy.ndarray");
+};
 
-template <typename type, typename SFINAE = void> struct npy_format_descriptor;
+template <typename type, typename SFINAE = void>
+struct npy_format_descriptor;
 
 struct PyArrayDescr_Proxy {
     PyObject_HEAD
     PyObject *typeobj;
     char kind;
     char type;
     char byteorder;
@@ -71,59 +71,67 @@
     ssize_t *strides;
     PyObject *base;
     PyObject *descr;
     int flags;
 };
 
 struct PyVoidScalarObject_Proxy {
-    PyObject_VAR_HEAD
-    char *obval;
+    PyObject_VAR_HEAD char *obval;
     PyArrayDescr_Proxy *descr;
     int flags;
     PyObject *base;
 };
 
 struct numpy_type_info {
-    PyObject* dtype_ptr;
+    PyObject *dtype_ptr;
     std::string format_str;
 };
 
 struct numpy_internals {
     std::unordered_map<std::type_index, numpy_type_info> registered_dtypes;
 
-    numpy_type_info *get_type_info(const std::type_info& tinfo, bool throw_if_missing = true) {
+    numpy_type_info *get_type_info(const std::type_info &tinfo, bool throw_if_missing = true) {
         auto it = registered_dtypes.find(std::type_index(tinfo));
-        if (it != registered_dtypes.end())
+        if (it != registered_dtypes.end()) {
             return &(it->second);
-        if (throw_if_missing)
+        }
+        if (throw_if_missing) {
             pybind11_fail(std::string("NumPy type info missing for ") + tinfo.name());
+        }
         return nullptr;
     }
 
-    template<typename T> numpy_type_info *get_type_info(bool throw_if_missing = true) {
+    template <typename T>
+    numpy_type_info *get_type_info(bool throw_if_missing = true) {
         return get_type_info(typeid(typename std::remove_cv<T>::type), throw_if_missing);
     }
 };
 
-inline PYBIND11_NOINLINE void load_numpy_internals(numpy_internals* &ptr) {
+PYBIND11_NOINLINE void load_numpy_internals(numpy_internals *&ptr) {
     ptr = &get_or_create_shared_data<numpy_internals>("_numpy_internals");
 }
 
-inline numpy_internals& get_numpy_internals() {
-    static numpy_internals* ptr = nullptr;
-    if (!ptr)
+inline numpy_internals &get_numpy_internals() {
+    static numpy_internals *ptr = nullptr;
+    if (!ptr) {
         load_numpy_internals(ptr);
+    }
     return *ptr;
 }
 
-template <typename T> struct same_size {
-    template <typename U> using as = bool_constant<sizeof(T) == sizeof(U)>;
+template <typename T>
+struct same_size {
+    template <typename U>
+    using as = bool_constant<sizeof(T) == sizeof(U)>;
 };
 
-template <typename Concrete> constexpr int platform_lookup() { return -1; }
+template <typename Concrete>
+constexpr int platform_lookup() {
+    return -1;
+}
 
 // Lookup a type according to its size, and return a value corresponding to the NumPy typenum.
 template <typename Concrete, typename T, typename... Ts, typename... Ints>
 constexpr int platform_lookup(int I, Ints... Is) {
     return sizeof(Concrete) == sizeof(T) ? I : platform_lookup<Concrete, Ts...>(Is...);
 }
 
@@ -133,427 +141,518 @@
         NPY_ARRAY_F_CONTIGUOUS_ = 0x0002,
         NPY_ARRAY_OWNDATA_ = 0x0004,
         NPY_ARRAY_FORCECAST_ = 0x0010,
         NPY_ARRAY_ENSUREARRAY_ = 0x0040,
         NPY_ARRAY_ALIGNED_ = 0x0100,
         NPY_ARRAY_WRITEABLE_ = 0x0400,
         NPY_BOOL_ = 0,
-        NPY_BYTE_, NPY_UBYTE_,
-        NPY_SHORT_, NPY_USHORT_,
-        NPY_INT_, NPY_UINT_,
-        NPY_LONG_, NPY_ULONG_,
-        NPY_LONGLONG_, NPY_ULONGLONG_,
-        NPY_FLOAT_, NPY_DOUBLE_, NPY_LONGDOUBLE_,
-        NPY_CFLOAT_, NPY_CDOUBLE_, NPY_CLONGDOUBLE_,
+        NPY_BYTE_,
+        NPY_UBYTE_,
+        NPY_SHORT_,
+        NPY_USHORT_,
+        NPY_INT_,
+        NPY_UINT_,
+        NPY_LONG_,
+        NPY_ULONG_,
+        NPY_LONGLONG_,
+        NPY_ULONGLONG_,
+        NPY_FLOAT_,
+        NPY_DOUBLE_,
+        NPY_LONGDOUBLE_,
+        NPY_CFLOAT_,
+        NPY_CDOUBLE_,
+        NPY_CLONGDOUBLE_,
         NPY_OBJECT_ = 17,
-        NPY_STRING_, NPY_UNICODE_, NPY_VOID_,
+        NPY_STRING_,
+        NPY_UNICODE_,
+        NPY_VOID_,
         // Platform-dependent normalization
         NPY_INT8_ = NPY_BYTE_,
         NPY_UINT8_ = NPY_UBYTE_,
         NPY_INT16_ = NPY_SHORT_,
         NPY_UINT16_ = NPY_USHORT_,
         // `npy_common.h` defines the integer aliases. In order, it checks:
         // NPY_BITSOF_LONG, NPY_BITSOF_LONGLONG, NPY_BITSOF_INT, NPY_BITSOF_SHORT, NPY_BITSOF_CHAR
         // and assigns the alias to the first matching size, so we should check in this order.
-        NPY_INT32_ = platform_lookup<std::int32_t, long, int, short>(
-            NPY_LONG_, NPY_INT_, NPY_SHORT_),
+        NPY_INT32_
+        = platform_lookup<std::int32_t, long, int, short>(NPY_LONG_, NPY_INT_, NPY_SHORT_),
         NPY_UINT32_ = platform_lookup<std::uint32_t, unsigned long, unsigned int, unsigned short>(
             NPY_ULONG_, NPY_UINT_, NPY_USHORT_),
-        NPY_INT64_ = platform_lookup<std::int64_t, long, long long, int>(
-            NPY_LONG_, NPY_LONGLONG_, NPY_INT_),
-        NPY_UINT64_ = platform_lookup<std::uint64_t, unsigned long, unsigned long long, unsigned int>(
+        NPY_INT64_
+        = platform_lookup<std::int64_t, long, long long, int>(NPY_LONG_, NPY_LONGLONG_, NPY_INT_),
+        NPY_UINT64_
+        = platform_lookup<std::uint64_t, unsigned long, unsigned long long, unsigned int>(
             NPY_ULONG_, NPY_ULONGLONG_, NPY_UINT_),
     };
 
-    typedef struct {
+    struct PyArray_Dims {
         Py_intptr_t *ptr;
         int len;
-    } PyArray_Dims;
+    };
 
-    static npy_api& get() {
+    static npy_api &get() {
         static npy_api api = lookup();
         return api;
     }
 
     bool PyArray_Check_(PyObject *obj) const {
-        return (bool) PyObject_TypeCheck(obj, PyArray_Type_);
+        return PyObject_TypeCheck(obj, PyArray_Type_) != 0;
     }
     bool PyArrayDescr_Check_(PyObject *obj) const {
-        return (bool) PyObject_TypeCheck(obj, PyArrayDescr_Type_);
+        return PyObject_TypeCheck(obj, PyArrayDescr_Type_) != 0;
     }
 
     unsigned int (*PyArray_GetNDArrayCFeatureVersion_)();
     PyObject *(*PyArray_DescrFromType_)(int);
-    PyObject *(*PyArray_NewFromDescr_)
-        (PyTypeObject *, PyObject *, int, Py_intptr_t const *,
-         Py_intptr_t const *, void *, int, PyObject *);
+    PyObject *(*PyArray_NewFromDescr_)(PyTypeObject *,
+                                       PyObject *,
+                                       int,
+                                       Py_intptr_t const *,
+                                       Py_intptr_t const *,
+                                       void *,
+                                       int,
+                                       PyObject *);
     // Unused. Not removed because that affects ABI of the class.
     PyObject *(*PyArray_DescrNewFromType_)(int);
     int (*PyArray_CopyInto_)(PyObject *, PyObject *);
     PyObject *(*PyArray_NewCopy_)(PyObject *, int);
     PyTypeObject *PyArray_Type_;
     PyTypeObject *PyVoidArrType_Type_;
     PyTypeObject *PyArrayDescr_Type_;
     PyObject *(*PyArray_DescrFromScalar_)(PyObject *);
-    PyObject *(*PyArray_FromAny_) (PyObject *, PyObject *, int, int, int, PyObject *);
-    int (*PyArray_DescrConverter_) (PyObject *, PyObject **);
-    bool (*PyArray_EquivTypes_) (PyObject *, PyObject *);
-    int (*PyArray_GetArrayParamsFromObject_)(PyObject *, PyObject *, unsigned char, PyObject **, int *,
-                                             Py_intptr_t *, PyObject **, PyObject *);
+    PyObject *(*PyArray_FromAny_)(PyObject *, PyObject *, int, int, int, PyObject *);
+    int (*PyArray_DescrConverter_)(PyObject *, PyObject **);
+    bool (*PyArray_EquivTypes_)(PyObject *, PyObject *);
+    int (*PyArray_GetArrayParamsFromObject_)(PyObject *,
+                                             PyObject *,
+                                             unsigned char,
+                                             PyObject **,
+                                             int *,
+                                             Py_intptr_t *,
+                                             PyObject **,
+                                             PyObject *);
     PyObject *(*PyArray_Squeeze_)(PyObject *);
     // Unused. Not removed because that affects ABI of the class.
     int (*PyArray_SetBaseObject_)(PyObject *, PyObject *);
-    PyObject* (*PyArray_Resize_)(PyObject*, PyArray_Dims*, int, int);
+    PyObject *(*PyArray_Resize_)(PyObject *, PyArray_Dims *, int, int);
+    PyObject *(*PyArray_Newshape_)(PyObject *, PyArray_Dims *, int);
+    PyObject *(*PyArray_View_)(PyObject *, PyObject *, PyObject *);
+
 private:
     enum functions {
         API_PyArray_GetNDArrayCFeatureVersion = 211,
         API_PyArray_Type = 2,
         API_PyArrayDescr_Type = 3,
         API_PyVoidArrType_Type = 39,
         API_PyArray_DescrFromType = 45,
         API_PyArray_DescrFromScalar = 57,
         API_PyArray_FromAny = 69,
         API_PyArray_Resize = 80,
         API_PyArray_CopyInto = 82,
         API_PyArray_NewCopy = 85,
         API_PyArray_NewFromDescr = 94,
         API_PyArray_DescrNewFromType = 96,
+        API_PyArray_Newshape = 135,
+        API_PyArray_Squeeze = 136,
+        API_PyArray_View = 137,
         API_PyArray_DescrConverter = 174,
         API_PyArray_EquivTypes = 182,
         API_PyArray_GetArrayParamsFromObject = 278,
-        API_PyArray_Squeeze = 136,
         API_PyArray_SetBaseObject = 282
     };
 
     static npy_api lookup() {
         module_ m = module_::import("numpy.core.multiarray");
         auto c = m.attr("_ARRAY_API");
 #if PY_MAJOR_VERSION >= 3
         void **api_ptr = (void **) PyCapsule_GetPointer(c.ptr(), NULL);
 #else
         void **api_ptr = (void **) PyCObject_AsVoidPtr(c.ptr());
 #endif
         npy_api api;
 #define DECL_NPY_API(Func) api.Func##_ = (decltype(api.Func##_)) api_ptr[API_##Func];
         DECL_NPY_API(PyArray_GetNDArrayCFeatureVersion);
-        if (api.PyArray_GetNDArrayCFeatureVersion_() < 0x7)
+        if (api.PyArray_GetNDArrayCFeatureVersion_() < 0x7) {
             pybind11_fail("pybind11 numpy support requires numpy >= 1.7.0");
+        }
         DECL_NPY_API(PyArray_Type);
         DECL_NPY_API(PyVoidArrType_Type);
         DECL_NPY_API(PyArrayDescr_Type);
         DECL_NPY_API(PyArray_DescrFromType);
         DECL_NPY_API(PyArray_DescrFromScalar);
         DECL_NPY_API(PyArray_FromAny);
         DECL_NPY_API(PyArray_Resize);
         DECL_NPY_API(PyArray_CopyInto);
         DECL_NPY_API(PyArray_NewCopy);
         DECL_NPY_API(PyArray_NewFromDescr);
         DECL_NPY_API(PyArray_DescrNewFromType);
+        DECL_NPY_API(PyArray_Newshape);
+        DECL_NPY_API(PyArray_Squeeze);
+        DECL_NPY_API(PyArray_View);
         DECL_NPY_API(PyArray_DescrConverter);
         DECL_NPY_API(PyArray_EquivTypes);
         DECL_NPY_API(PyArray_GetArrayParamsFromObject);
-        DECL_NPY_API(PyArray_Squeeze);
         DECL_NPY_API(PyArray_SetBaseObject);
+
 #undef DECL_NPY_API
         return api;
     }
 };
 
-inline PyArray_Proxy* array_proxy(void* ptr) {
-    return reinterpret_cast<PyArray_Proxy*>(ptr);
-}
+inline PyArray_Proxy *array_proxy(void *ptr) { return reinterpret_cast<PyArray_Proxy *>(ptr); }
 
-inline const PyArray_Proxy* array_proxy(const void* ptr) {
-    return reinterpret_cast<const PyArray_Proxy*>(ptr);
+inline const PyArray_Proxy *array_proxy(const void *ptr) {
+    return reinterpret_cast<const PyArray_Proxy *>(ptr);
 }
 
-inline PyArrayDescr_Proxy* array_descriptor_proxy(PyObject* ptr) {
-   return reinterpret_cast<PyArrayDescr_Proxy*>(ptr);
+inline PyArrayDescr_Proxy *array_descriptor_proxy(PyObject *ptr) {
+    return reinterpret_cast<PyArrayDescr_Proxy *>(ptr);
 }
 
-inline const PyArrayDescr_Proxy* array_descriptor_proxy(const PyObject* ptr) {
-   return reinterpret_cast<const PyArrayDescr_Proxy*>(ptr);
+inline const PyArrayDescr_Proxy *array_descriptor_proxy(const PyObject *ptr) {
+    return reinterpret_cast<const PyArrayDescr_Proxy *>(ptr);
 }
 
-inline bool check_flags(const void* ptr, int flag) {
+inline bool check_flags(const void *ptr, int flag) {
     return (flag == (array_proxy(ptr)->flags & flag));
 }
 
-template <typename T> struct is_std_array : std::false_type { };
-template <typename T, size_t N> struct is_std_array<std::array<T, N>> : std::true_type { };
-template <typename T> struct is_complex : std::false_type { };
-template <typename T> struct is_complex<std::complex<T>> : std::true_type { };
+template <typename T>
+struct is_std_array : std::false_type {};
+template <typename T, size_t N>
+struct is_std_array<std::array<T, N>> : std::true_type {};
+template <typename T>
+struct is_complex : std::false_type {};
+template <typename T>
+struct is_complex<std::complex<T>> : std::true_type {};
 
-template <typename T> struct array_info_scalar {
+template <typename T>
+struct array_info_scalar {
     using type = T;
     static constexpr bool is_array = false;
     static constexpr bool is_empty = false;
-    static constexpr auto extents = _("");
-    static void append_extents(list& /* shape */) { }
+    static constexpr auto extents = const_name("");
+    static void append_extents(list & /* shape */) {}
 };
 // Computes underlying type and a comma-separated list of extents for array
 // types (any mix of std::array and built-in arrays). An array of char is
 // treated as scalar because it gets special handling.
-template <typename T> struct array_info : array_info_scalar<T> { };
-template <typename T, size_t N> struct array_info<std::array<T, N>> {
+template <typename T>
+struct array_info : array_info_scalar<T> {};
+template <typename T, size_t N>
+struct array_info<std::array<T, N>> {
     using type = typename array_info<T>::type;
     static constexpr bool is_array = true;
     static constexpr bool is_empty = (N == 0) || array_info<T>::is_empty;
     static constexpr size_t extent = N;
 
     // appends the extents to shape
-    static void append_extents(list& shape) {
+    static void append_extents(list &shape) {
         shape.append(N);
         array_info<T>::append_extents(shape);
     }
 
-    static constexpr auto extents = _<array_info<T>::is_array>(
-        concat(_<N>(), array_info<T>::extents), _<N>()
-    );
+    static constexpr auto extents = const_name<array_info<T>::is_array>(
+        concat(const_name<N>(), array_info<T>::extents), const_name<N>());
 };
 // For numpy we have special handling for arrays of characters, so we don't include
 // the size in the array extents.
-template <size_t N> struct array_info<char[N]> : array_info_scalar<char[N]> { };
-template <size_t N> struct array_info<std::array<char, N>> : array_info_scalar<std::array<char, N>> { };
-template <typename T, size_t N> struct array_info<T[N]> : array_info<std::array<T, N>> { };
-template <typename T> using remove_all_extents_t = typename array_info<T>::type;
-
-template <typename T> using is_pod_struct = all_of<
-    std::is_standard_layout<T>,     // since we're accessing directly in memory we need a standard layout type
-#if !defined(__GNUG__) || defined(_LIBCPP_VERSION) || defined(_GLIBCXX_USE_CXX11_ABI)
-    // _GLIBCXX_USE_CXX11_ABI indicates that we're using libstdc++ from GCC 5 or newer, independent
-    // of the actual compiler (Clang can also use libstdc++, but it always defines __GNUC__ == 4).
-    std::is_trivially_copyable<T>,
+template <size_t N>
+struct array_info<char[N]> : array_info_scalar<char[N]> {};
+template <size_t N>
+struct array_info<std::array<char, N>> : array_info_scalar<std::array<char, N>> {};
+template <typename T, size_t N>
+struct array_info<T[N]> : array_info<std::array<T, N>> {};
+template <typename T>
+using remove_all_extents_t = typename array_info<T>::type;
+
+template <typename T>
+using is_pod_struct
+    = all_of<std::is_standard_layout<T>, // since we're accessing directly in memory
+                                         // we need a standard layout type
+#if defined(__GLIBCXX__)                                                                          \
+    && (__GLIBCXX__ < 20150422 || __GLIBCXX__ == 20150426 || __GLIBCXX__ == 20150623              \
+        || __GLIBCXX__ == 20150626 || __GLIBCXX__ == 20160803)
+             // libstdc++ < 5 (including versions 4.8.5, 4.9.3 and 4.9.4 which were released after
+             // 5) don't implement is_trivially_copyable, so approximate it
+             std::is_trivially_destructible<T>,
+             satisfies_any_of<T, std::has_trivial_copy_constructor, std::has_trivial_copy_assign>,
 #else
-    // GCC 4 doesn't implement is_trivially_copyable, so approximate it
-    std::is_trivially_destructible<T>,
-    satisfies_any_of<T, std::has_trivial_copy_constructor, std::has_trivial_copy_assign>,
+             std::is_trivially_copyable<T>,
 #endif
-    satisfies_none_of<T, std::is_reference, std::is_array, is_std_array, std::is_arithmetic, is_complex, std::is_enum>
->;
+             satisfies_none_of<T,
+                               std::is_reference,
+                               std::is_array,
+                               is_std_array,
+                               std::is_arithmetic,
+                               is_complex,
+                               std::is_enum>>;
 
 // Replacement for std::is_pod (deprecated in C++20)
-template <typename T> using is_pod = all_of<
-    std::is_standard_layout<T>,
-    std::is_trivial<T>
->;
+template <typename T>
+using is_pod = all_of<std::is_standard_layout<T>, std::is_trivial<T>>;
 
-template <ssize_t Dim = 0, typename Strides> ssize_t byte_offset_unsafe(const Strides &) { return 0; }
+template <ssize_t Dim = 0, typename Strides>
+ssize_t byte_offset_unsafe(const Strides &) {
+    return 0;
+}
 template <ssize_t Dim = 0, typename Strides, typename... Ix>
 ssize_t byte_offset_unsafe(const Strides &strides, ssize_t i, Ix... index) {
     return i * strides[Dim] + byte_offset_unsafe<Dim + 1>(strides, index...);
 }
 
 /**
  * Proxy class providing unsafe, unchecked const access to array data.  This is constructed through
- * the `unchecked<T, N>()` method of `array` or the `unchecked<N>()` method of `array_t<T>`.  `Dims`
+ * the `unchecked<T, N>()` method of `array` or the `unchecked<N>()` method of `array_t<T>`. `Dims`
  * will be -1 for dimensions determined at runtime.
  */
 template <typename T, ssize_t Dims>
 class unchecked_reference {
 protected:
     static constexpr bool Dynamic = Dims < 0;
     const unsigned char *data_;
     // Storing the shape & strides in local variables (i.e. these arrays) allows the compiler to
     // make large performance gains on big, nested loops, but requires compile-time dimensions
-    conditional_t<Dynamic, const ssize_t *, std::array<ssize_t, (size_t) Dims>>
-            shape_, strides_;
+    conditional_t<Dynamic, const ssize_t *, std::array<ssize_t, (size_t) Dims>> shape_, strides_;
     const ssize_t dims_;
 
     friend class pybind11::array;
     // Constructor for compile-time dimensions:
     template <bool Dyn = Dynamic>
-    unchecked_reference(const void *data, const ssize_t *shape, const ssize_t *strides, enable_if_t<!Dyn, ssize_t>)
-    : data_{reinterpret_cast<const unsigned char *>(data)}, dims_{Dims} {
+    unchecked_reference(const void *data,
+                        const ssize_t *shape,
+                        const ssize_t *strides,
+                        enable_if_t<!Dyn, ssize_t>)
+        : data_{reinterpret_cast<const unsigned char *>(data)}, dims_{Dims} {
         for (size_t i = 0; i < (size_t) dims_; i++) {
             shape_[i] = shape[i];
             strides_[i] = strides[i];
         }
     }
     // Constructor for runtime dimensions:
     template <bool Dyn = Dynamic>
-    unchecked_reference(const void *data, const ssize_t *shape, const ssize_t *strides, enable_if_t<Dyn, ssize_t> dims)
-    : data_{reinterpret_cast<const unsigned char *>(data)}, shape_{shape}, strides_{strides}, dims_{dims} {}
+    unchecked_reference(const void *data,
+                        const ssize_t *shape,
+                        const ssize_t *strides,
+                        enable_if_t<Dyn, ssize_t> dims)
+        : data_{reinterpret_cast<const unsigned char *>(data)}, shape_{shape}, strides_{strides},
+          dims_{dims} {}
 
 public:
     /**
      * Unchecked const reference access to data at the given indices.  For a compile-time known
      * number of dimensions, this requires the correct number of arguments; for run-time
      * dimensionality, this is not checked (and so is up to the caller to use safely).
      */
-    template <typename... Ix> const T &operator()(Ix... index) const {
+    template <typename... Ix>
+    const T &operator()(Ix... index) const {
         static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
-                "Invalid number of indices for unchecked array reference");
-        return *reinterpret_cast<const T *>(data_ + byte_offset_unsafe(strides_, ssize_t(index)...));
+                      "Invalid number of indices for unchecked array reference");
+        return *reinterpret_cast<const T *>(data_
+                                            + byte_offset_unsafe(strides_, ssize_t(index)...));
     }
     /**
      * Unchecked const reference access to data; this operator only participates if the reference
      * is to a 1-dimensional array.  When present, this is exactly equivalent to `obj(index)`.
      */
     template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>
-    const T &operator[](ssize_t index) const { return operator()(index); }
+    const T &operator[](ssize_t index) const {
+        return operator()(index);
+    }
 
     /// Pointer access to the data at the given indices.
-    template <typename... Ix> const T *data(Ix... ix) const { return &operator()(ssize_t(ix)...); }
+    template <typename... Ix>
+    const T *data(Ix... ix) const {
+        return &operator()(ssize_t(ix)...);
+    }
 
     /// Returns the item size, i.e. sizeof(T)
     constexpr static ssize_t itemsize() { return sizeof(T); }
 
     /// Returns the shape (i.e. size) of dimension `dim`
     ssize_t shape(ssize_t dim) const { return shape_[(size_t) dim]; }
 
     /// Returns the number of dimensions of the array
     ssize_t ndim() const { return dims_; }
 
-    /// Returns the total number of elements in the referenced array, i.e. the product of the shapes
+    /// Returns the total number of elements in the referenced array, i.e. the product of the
+    /// shapes
     template <bool Dyn = Dynamic>
     enable_if_t<!Dyn, ssize_t> size() const {
-        return std::accumulate(shape_.begin(), shape_.end(), (ssize_t) 1, std::multiplies<ssize_t>());
+        return std::accumulate(
+            shape_.begin(), shape_.end(), (ssize_t) 1, std::multiplies<ssize_t>());
     }
     template <bool Dyn = Dynamic>
     enable_if_t<Dyn, ssize_t> size() const {
         return std::accumulate(shape_, shape_ + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());
     }
 
-    /// Returns the total number of bytes used by the referenced data.  Note that the actual span in
-    /// memory may be larger if the referenced array has non-contiguous strides (e.g. for a slice).
-    ssize_t nbytes() const {
-        return size() * itemsize();
-    }
+    /// Returns the total number of bytes used by the referenced data.  Note that the actual span
+    /// in memory may be larger if the referenced array has non-contiguous strides (e.g. for a
+    /// slice).
+    ssize_t nbytes() const { return size() * itemsize(); }
 };
 
 template <typename T, ssize_t Dims>
 class unchecked_mutable_reference : public unchecked_reference<T, Dims> {
     friend class pybind11::array;
     using ConstBase = unchecked_reference<T, Dims>;
     using ConstBase::ConstBase;
     using ConstBase::Dynamic;
+
 public:
     // Bring in const-qualified versions from base class
     using ConstBase::operator();
     using ConstBase::operator[];
 
     /// Mutable, unchecked access to data at the given indices.
-    template <typename... Ix> T& operator()(Ix... index) {
+    template <typename... Ix>
+    T &operator()(Ix... index) {
         static_assert(ssize_t{sizeof...(Ix)} == Dims || Dynamic,
-                "Invalid number of indices for unchecked array reference");
+                      "Invalid number of indices for unchecked array reference");
         return const_cast<T &>(ConstBase::operator()(index...));
     }
     /**
      * Mutable, unchecked access data at the given index; this operator only participates if the
      * reference is to a 1-dimensional array (or has runtime dimensions).  When present, this is
      * exactly equivalent to `obj(index)`.
      */
     template <ssize_t D = Dims, typename = enable_if_t<D == 1 || Dynamic>>
-    T &operator[](ssize_t index) { return operator()(index); }
+    T &operator[](ssize_t index) {
+        return operator()(index);
+    }
 
     /// Mutable pointer access to the data at the given indices.
-    template <typename... Ix> T *mutable_data(Ix... ix) { return &operator()(ssize_t(ix)...); }
+    template <typename... Ix>
+    T *mutable_data(Ix... ix) {
+        return &operator()(ssize_t(ix)...);
+    }
 };
 
 template <typename T, ssize_t Dim>
 struct type_caster<unchecked_reference<T, Dim>> {
-    static_assert(Dim == 0 && Dim > 0 /* always fail */, "unchecked array proxy object is not castable");
+    static_assert(Dim == 0 && Dim > 0 /* always fail */,
+                  "unchecked array proxy object is not castable");
 };
 template <typename T, ssize_t Dim>
-struct type_caster<unchecked_mutable_reference<T, Dim>> : type_caster<unchecked_reference<T, Dim>> {};
+struct type_caster<unchecked_mutable_reference<T, Dim>>
+    : type_caster<unchecked_reference<T, Dim>> {};
 
 PYBIND11_NAMESPACE_END(detail)
 
 class dtype : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(dtype, object, detail::npy_api::get().PyArrayDescr_Check_);
 
     explicit dtype(const buffer_info &info) {
         dtype descr(_dtype_from_pep3118()(PYBIND11_STR_TYPE(info.format)));
         // If info.itemsize == 0, use the value calculated from the format string
-        m_ptr = descr.strip_padding(info.itemsize ? info.itemsize : descr.itemsize()).release().ptr();
+        m_ptr = descr.strip_padding(info.itemsize != 0 ? info.itemsize : descr.itemsize())
+                    .release()
+                    .ptr();
     }
 
     explicit dtype(const std::string &format) {
         m_ptr = from_args(pybind11::str(format)).release().ptr();
     }
 
-    dtype(const char *format) : dtype(std::string(format)) { }
+    explicit dtype(const char *format) : dtype(std::string(format)) {}
 
     dtype(list names, list formats, list offsets, ssize_t itemsize) {
         dict args;
-        args["names"] = names;
-        args["formats"] = formats;
-        args["offsets"] = offsets;
+        args["names"] = std::move(names);
+        args["formats"] = std::move(formats);
+        args["offsets"] = std::move(offsets);
         args["itemsize"] = pybind11::int_(itemsize);
-        m_ptr = from_args(args).release().ptr();
+        m_ptr = from_args(std::move(args)).release().ptr();
     }
 
     /// This is essentially the same as calling numpy.dtype(args) in Python.
     static dtype from_args(object args) {
         PyObject *ptr = nullptr;
-        if (!detail::npy_api::get().PyArray_DescrConverter_(args.ptr(), &ptr) || !ptr)
+        if ((detail::npy_api::get().PyArray_DescrConverter_(args.ptr(), &ptr) == 0) || !ptr) {
             throw error_already_set();
+        }
         return reinterpret_steal<dtype>(ptr);
     }
 
     /// Return dtype associated with a C++ type.
-    template <typename T> static dtype of() {
+    template <typename T>
+    static dtype of() {
         return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::dtype();
     }
 
     /// Size of the data type in bytes.
-    ssize_t itemsize() const {
-        return detail::array_descriptor_proxy(m_ptr)->elsize;
-    }
+    ssize_t itemsize() const { return detail::array_descriptor_proxy(m_ptr)->elsize; }
 
     /// Returns true for structured data types.
-    bool has_fields() const {
-        return detail::array_descriptor_proxy(m_ptr)->names != nullptr;
-    }
+    bool has_fields() const { return detail::array_descriptor_proxy(m_ptr)->names != nullptr; }
 
-    /// Single-character type code.
-    char kind() const {
-        return detail::array_descriptor_proxy(m_ptr)->kind;
+    /// Single-character code for dtype's kind.
+    /// For example, floating point types are 'f' and integral types are 'i'.
+    char kind() const { return detail::array_descriptor_proxy(m_ptr)->kind; }
+
+    /// Single-character for dtype's type.
+    /// For example, ``float`` is 'f', ``double`` 'd', ``int`` 'i', and ``long`` 'l'.
+    char char_() const {
+        // Note: The signature, `dtype::char_` follows the naming of NumPy's
+        // public Python API (i.e., ``dtype.char``), rather than its internal
+        // C API (``PyArray_Descr::type``).
+        return detail::array_descriptor_proxy(m_ptr)->type;
     }
 
 private:
     static object _dtype_from_pep3118() {
         static PyObject *obj = module_::import("numpy.core._internal")
-            .attr("_dtype_from_pep3118").cast<object>().release().ptr();
+                                   .attr("_dtype_from_pep3118")
+                                   .cast<object>()
+                                   .release()
+                                   .ptr();
         return reinterpret_borrow<object>(obj);
     }
 
     dtype strip_padding(ssize_t itemsize) {
         // Recursively strip all void fields with empty names that are generated for
         // padding fields (as of NumPy v1.11).
-        if (!has_fields())
+        if (!has_fields()) {
             return *this;
+        }
 
-        struct field_descr { PYBIND11_STR_TYPE name; object format; pybind11::int_ offset; };
+        struct field_descr {
+            PYBIND11_STR_TYPE name;
+            object format;
+            pybind11::int_ offset;
+        };
         std::vector<field_descr> field_descriptors;
 
         for (auto field : attr("fields").attr("items")()) {
             auto spec = field.cast<tuple>();
             auto name = spec[0].cast<pybind11::str>();
             auto format = spec[1].cast<tuple>()[0].cast<dtype>();
             auto offset = spec[1].cast<tuple>()[1].cast<pybind11::int_>();
-            if (!len(name) && format.kind() == 'V')
+            if ((len(name) == 0u) && format.kind() == 'V') {
                 continue;
-            field_descriptors.push_back({(PYBIND11_STR_TYPE) name, format.strip_padding(format.itemsize()), offset});
+            }
+            field_descriptors.push_back(
+                {(PYBIND11_STR_TYPE) name, format.strip_padding(format.itemsize()), offset});
         }
 
-        std::sort(field_descriptors.begin(), field_descriptors.end(),
-                  [](const field_descr& a, const field_descr& b) {
+        std::sort(field_descriptors.begin(),
+                  field_descriptors.end(),
+                  [](const field_descr &a, const field_descr &b) {
                       return a.offset.cast<int>() < b.offset.cast<int>();
                   });
 
         list names, formats, offsets;
-        for (auto& descr : field_descriptors) {
+        for (auto &descr : field_descriptors) {
             names.append(descr.name);
             formats.append(descr.format);
             offsets.append(descr.offset);
         }
-        return dtype(names, formats, offsets, itemsize);
+        return dtype(std::move(names), std::move(formats), std::move(offsets), itemsize);
     }
 };
 
 class array : public buffer {
 public:
     PYBIND11_OBJECT_CVT(array, buffer, detail::npy_api::get().PyArray_Check_, raw_array)
 
@@ -565,74 +664,93 @@
 
     array() : array(0, static_cast<const double *>(nullptr)) {}
 
     using ShapeContainer = detail::any_container<ssize_t>;
     using StridesContainer = detail::any_container<ssize_t>;
 
     // Constructs an array taking shape/strides from arbitrary container types
-    array(const pybind11::dtype &dt, ShapeContainer shape, StridesContainer strides,
-          const void *ptr = nullptr, handle base = handle()) {
+    array(const pybind11::dtype &dt,
+          ShapeContainer shape,
+          StridesContainer strides,
+          const void *ptr = nullptr,
+          handle base = handle()) {
 
-        if (strides->empty())
+        if (strides->empty()) {
             *strides = detail::c_strides(*shape, dt.itemsize());
+        }
 
         auto ndim = shape->size();
-        if (ndim != strides->size())
+        if (ndim != strides->size()) {
             pybind11_fail("NumPy: shape ndim doesn't match strides ndim");
+        }
         auto descr = dt;
 
         int flags = 0;
         if (base && ptr) {
-            if (isinstance<array>(base))
+            if (isinstance<array>(base)) {
                 /* Copy flags from base (except ownership bit) */
-                flags = reinterpret_borrow<array>(base).flags() & ~detail::npy_api::NPY_ARRAY_OWNDATA_;
-            else
+                flags = reinterpret_borrow<array>(base).flags()
+                        & ~detail::npy_api::NPY_ARRAY_OWNDATA_;
+            } else {
                 /* Writable by default, easy to downgrade later on if needed */
                 flags = detail::npy_api::NPY_ARRAY_WRITEABLE_;
+            }
         }
 
         auto &api = detail::npy_api::get();
         auto tmp = reinterpret_steal<object>(api.PyArray_NewFromDescr_(
-            api.PyArray_Type_, descr.release().ptr(), (int) ndim,
+            api.PyArray_Type_,
+            descr.release().ptr(),
+            (int) ndim,
             // Use reinterpret_cast for PyPy on Windows (remove if fixed, checked on 7.3.1)
-            reinterpret_cast<Py_intptr_t*>(shape->data()),
-            reinterpret_cast<Py_intptr_t*>(strides->data()),
-            const_cast<void *>(ptr), flags, nullptr));
-        if (!tmp)
+            reinterpret_cast<Py_intptr_t *>(shape->data()),
+            reinterpret_cast<Py_intptr_t *>(strides->data()),
+            const_cast<void *>(ptr),
+            flags,
+            nullptr));
+        if (!tmp) {
             throw error_already_set();
+        }
         if (ptr) {
             if (base) {
                 api.PyArray_SetBaseObject_(tmp.ptr(), base.inc_ref().ptr());
             } else {
-                tmp = reinterpret_steal<object>(api.PyArray_NewCopy_(tmp.ptr(), -1 /* any order */));
+                tmp = reinterpret_steal<object>(
+                    api.PyArray_NewCopy_(tmp.ptr(), -1 /* any order */));
             }
         }
         m_ptr = tmp.release().ptr();
     }
 
-    array(const pybind11::dtype &dt, ShapeContainer shape, const void *ptr = nullptr, handle base = handle())
-        : array(dt, std::move(shape), {}, ptr, base) { }
-
-    template <typename T, typename = detail::enable_if_t<std::is_integral<T>::value && !std::is_same<bool, T>::value>>
+    array(const pybind11::dtype &dt,
+          ShapeContainer shape,
+          const void *ptr = nullptr,
+          handle base = handle())
+        : array(dt, std::move(shape), {}, ptr, base) {}
+
+    template <typename T,
+              typename
+              = detail::enable_if_t<std::is_integral<T>::value && !std::is_same<bool, T>::value>>
     array(const pybind11::dtype &dt, T count, const void *ptr = nullptr, handle base = handle())
-        : array(dt, {{count}}, ptr, base) { }
+        : array(dt, {{count}}, ptr, base) {}
 
     template <typename T>
     array(ShapeContainer shape, StridesContainer strides, const T *ptr, handle base = handle())
-        : array(pybind11::dtype::of<T>(), std::move(shape), std::move(strides), ptr, base) { }
+        : array(pybind11::dtype::of<T>(), std::move(shape), std::move(strides), ptr, base) {}
 
     template <typename T>
     array(ShapeContainer shape, const T *ptr, handle base = handle())
-        : array(std::move(shape), {}, ptr, base) { }
+        : array(std::move(shape), {}, ptr, base) {}
 
     template <typename T>
-    explicit array(ssize_t count, const T *ptr, handle base = handle()) : array({count}, {}, ptr, base) { }
+    explicit array(ssize_t count, const T *ptr, handle base = handle())
+        : array({count}, {}, ptr, base) {}
 
     explicit array(const buffer_info &info, handle base = handle())
-    : array(pybind11::dtype(info), info.shape, info.strides, info.ptr, base) { }
+        : array(pybind11::dtype(info), info.shape, info.strides, info.ptr, base) {}
 
     /// Array descriptor (dtype)
     pybind11::dtype dtype() const {
         return reinterpret_borrow<pybind11::dtype>(detail::array_proxy(m_ptr)->descr);
     }
 
     /// Total number of elements
@@ -642,185 +760,222 @@
 
     /// Byte size of a single element
     ssize_t itemsize() const {
         return detail::array_descriptor_proxy(detail::array_proxy(m_ptr)->descr)->elsize;
     }
 
     /// Total number of bytes
-    ssize_t nbytes() const {
-        return size() * itemsize();
-    }
+    ssize_t nbytes() const { return size() * itemsize(); }
 
     /// Number of dimensions
-    ssize_t ndim() const {
-        return detail::array_proxy(m_ptr)->nd;
-    }
+    ssize_t ndim() const { return detail::array_proxy(m_ptr)->nd; }
 
     /// Base object
-    object base() const {
-        return reinterpret_borrow<object>(detail::array_proxy(m_ptr)->base);
-    }
+    object base() const { return reinterpret_borrow<object>(detail::array_proxy(m_ptr)->base); }
 
     /// Dimensions of the array
-    const ssize_t* shape() const {
-        return detail::array_proxy(m_ptr)->dimensions;
-    }
+    const ssize_t *shape() const { return detail::array_proxy(m_ptr)->dimensions; }
 
     /// Dimension along a given axis
     ssize_t shape(ssize_t dim) const {
-        if (dim >= ndim())
+        if (dim >= ndim()) {
             fail_dim_check(dim, "invalid axis");
+        }
         return shape()[dim];
     }
 
     /// Strides of the array
-    const ssize_t* strides() const {
-        return detail::array_proxy(m_ptr)->strides;
-    }
+    const ssize_t *strides() const { return detail::array_proxy(m_ptr)->strides; }
 
     /// Stride along a given axis
     ssize_t strides(ssize_t dim) const {
-        if (dim >= ndim())
+        if (dim >= ndim()) {
             fail_dim_check(dim, "invalid axis");
+        }
         return strides()[dim];
     }
 
     /// Return the NumPy array flags
-    int flags() const {
-        return detail::array_proxy(m_ptr)->flags;
-    }
+    int flags() const { return detail::array_proxy(m_ptr)->flags; }
 
     /// If set, the array is writeable (otherwise the buffer is read-only)
     bool writeable() const {
         return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_WRITEABLE_);
     }
 
     /// If set, the array owns the data (will be freed when the array is deleted)
     bool owndata() const {
         return detail::check_flags(m_ptr, detail::npy_api::NPY_ARRAY_OWNDATA_);
     }
 
     /// Pointer to the contained data. If index is not provided, points to the
     /// beginning of the buffer. May throw if the index would lead to out of bounds access.
-    template<typename... Ix> const void* data(Ix... index) const {
+    template <typename... Ix>
+    const void *data(Ix... index) const {
         return static_cast<const void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));
     }
 
     /// Mutable pointer to the contained data. If index is not provided, points to the
     /// beginning of the buffer. May throw if the index would lead to out of bounds access.
     /// May throw if the array is not writeable.
-    template<typename... Ix> void* mutable_data(Ix... index) {
+    template <typename... Ix>
+    void *mutable_data(Ix... index) {
         check_writeable();
         return static_cast<void *>(detail::array_proxy(m_ptr)->data + offset_at(index...));
     }
 
     /// Byte offset from beginning of the array to a given index (full or partial).
     /// May throw if the index would lead to out of bounds access.
-    template<typename... Ix> ssize_t offset_at(Ix... index) const {
-        if ((ssize_t) sizeof...(index) > ndim())
+    template <typename... Ix>
+    ssize_t offset_at(Ix... index) const {
+        if ((ssize_t) sizeof...(index) > ndim()) {
             fail_dim_check(sizeof...(index), "too many indices for an array");
+        }
         return byte_offset(ssize_t(index)...);
     }
 
     ssize_t offset_at() const { return 0; }
 
     /// Item count from beginning of the array to a given index (full or partial).
     /// May throw if the index would lead to out of bounds access.
-    template<typename... Ix> ssize_t index_at(Ix... index) const {
+    template <typename... Ix>
+    ssize_t index_at(Ix... index) const {
         return offset_at(index...) / itemsize();
     }
 
     /**
      * Returns a proxy object that provides access to the array's data without bounds or
      * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with
      * care: the array must not be destroyed or reshaped for the duration of the returned object,
      * and the caller must take care not to access invalid dimensions or dimension indices.
      */
-    template <typename T, ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
-        if (Dims >= 0 && ndim() != Dims)
-            throw std::domain_error("array has incorrect number of dimensions: " + std::to_string(ndim()) +
-                    "; expected " + std::to_string(Dims));
-        return detail::unchecked_mutable_reference<T, Dims>(mutable_data(), shape(), strides(), ndim());
+    template <typename T, ssize_t Dims = -1>
+    detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
+        if (PYBIND11_SILENCE_MSVC_C4127(Dims >= 0) && ndim() != Dims) {
+            throw std::domain_error("array has incorrect number of dimensions: "
+                                    + std::to_string(ndim()) + "; expected "
+                                    + std::to_string(Dims));
+        }
+        return detail::unchecked_mutable_reference<T, Dims>(
+            mutable_data(), shape(), strides(), ndim());
     }
 
     /**
      * Returns a proxy object that provides const access to the array's data without bounds or
      * dimensionality checking.  Unlike `mutable_unchecked()`, this does not require that the
-     * underlying array have the `writable` flag.  Use with care: the array must not be destroyed or
-     * reshaped for the duration of the returned object, and the caller must take care not to access
-     * invalid dimensions or dimension indices.
+     * underlying array have the `writable` flag.  Use with care: the array must not be destroyed
+     * or reshaped for the duration of the returned object, and the caller must take care not to
+     * access invalid dimensions or dimension indices.
      */
-    template <typename T, ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const & {
-        if (Dims >= 0 && ndim() != Dims)
-            throw std::domain_error("array has incorrect number of dimensions: " + std::to_string(ndim()) +
-                    "; expected " + std::to_string(Dims));
+    template <typename T, ssize_t Dims = -1>
+    detail::unchecked_reference<T, Dims> unchecked() const & {
+        if (PYBIND11_SILENCE_MSVC_C4127(Dims >= 0) && ndim() != Dims) {
+            throw std::domain_error("array has incorrect number of dimensions: "
+                                    + std::to_string(ndim()) + "; expected "
+                                    + std::to_string(Dims));
+        }
         return detail::unchecked_reference<T, Dims>(data(), shape(), strides(), ndim());
     }
 
     /// Return a new view with all of the dimensions of length 1 removed
     array squeeze() {
-        auto& api = detail::npy_api::get();
+        auto &api = detail::npy_api::get();
         return reinterpret_steal<array>(api.PyArray_Squeeze_(m_ptr));
     }
 
     /// Resize array to given shape
     /// If refcheck is true and more that one reference exist to this array
     /// then resize will succeed only if it makes a reshape, i.e. original size doesn't change
     void resize(ShapeContainer new_shape, bool refcheck = true) {
-        detail::npy_api::PyArray_Dims d = {
-            // Use reinterpret_cast for PyPy on Windows (remove if fixed, checked on 7.3.1)
-            reinterpret_cast<Py_intptr_t*>(new_shape->data()),
-            int(new_shape->size())
-        };
+        detail::npy_api::PyArray_Dims d
+            = {// Use reinterpret_cast for PyPy on Windows (remove if fixed, checked on 7.3.1)
+               reinterpret_cast<Py_intptr_t *>(new_shape->data()),
+               int(new_shape->size())};
         // try to resize, set ordering param to -1 cause it's not used anyway
-        object new_array = reinterpret_steal<object>(
-            detail::npy_api::get().PyArray_Resize_(m_ptr, &d, int(refcheck), -1)
-        );
-        if (!new_array) throw error_already_set();
-        if (isinstance<array>(new_array)) { *this = std::move(new_array); }
+        auto new_array = reinterpret_steal<object>(
+            detail::npy_api::get().PyArray_Resize_(m_ptr, &d, int(refcheck), -1));
+        if (!new_array) {
+            throw error_already_set();
+        }
+        if (isinstance<array>(new_array)) {
+            *this = std::move(new_array);
+        }
+    }
+
+    /// Optional `order` parameter omitted, to be added as needed.
+    array reshape(ShapeContainer new_shape) {
+        detail::npy_api::PyArray_Dims d
+            = {reinterpret_cast<Py_intptr_t *>(new_shape->data()), int(new_shape->size())};
+        auto new_array
+            = reinterpret_steal<array>(detail::npy_api::get().PyArray_Newshape_(m_ptr, &d, 0));
+        if (!new_array) {
+            throw error_already_set();
+        }
+        return new_array;
+    }
+
+    /// Create a view of an array in a different data type.
+    /// This function may fundamentally reinterpret the data in the array.
+    /// It is the responsibility of the caller to ensure that this is safe.
+    /// Only supports the `dtype` argument, the `type` argument is omitted,
+    /// to be added as needed.
+    array view(const std::string &dtype) {
+        auto &api = detail::npy_api::get();
+        auto new_view = reinterpret_steal<array>(api.PyArray_View_(
+            m_ptr, dtype::from_args(pybind11::str(dtype)).release().ptr(), nullptr));
+        if (!new_view) {
+            throw error_already_set();
+        }
+        return new_view;
     }
 
     /// Ensure that the argument is a NumPy array
     /// In case of an error, nullptr is returned and the Python error is cleared.
     static array ensure(handle h, int ExtraFlags = 0) {
         auto result = reinterpret_steal<array>(raw_array(h.ptr(), ExtraFlags));
-        if (!result)
+        if (!result) {
             PyErr_Clear();
+        }
         return result;
     }
 
 protected:
-    template<typename, typename> friend struct detail::npy_format_descriptor;
+    template <typename, typename>
+    friend struct detail::npy_format_descriptor;
 
-    void fail_dim_check(ssize_t dim, const std::string& msg) const {
-        throw index_error(msg + ": " + std::to_string(dim) +
-                          " (ndim = " + std::to_string(ndim()) + ")");
+    void fail_dim_check(ssize_t dim, const std::string &msg) const {
+        throw index_error(msg + ": " + std::to_string(dim) + " (ndim = " + std::to_string(ndim())
+                          + ")");
     }
 
-    template<typename... Ix> ssize_t byte_offset(Ix... index) const {
+    template <typename... Ix>
+    ssize_t byte_offset(Ix... index) const {
         check_dimensions(index...);
         return detail::byte_offset_unsafe(strides(), ssize_t(index)...);
     }
 
     void check_writeable() const {
-        if (!writeable())
+        if (!writeable()) {
             throw std::domain_error("array is not writeable");
+        }
     }
 
-    template<typename... Ix> void check_dimensions(Ix... index) const {
+    template <typename... Ix>
+    void check_dimensions(Ix... index) const {
         check_dimensions_impl(ssize_t(0), shape(), ssize_t(index)...);
     }
 
-    void check_dimensions_impl(ssize_t, const ssize_t*) const { }
+    void check_dimensions_impl(ssize_t, const ssize_t *) const {}
 
-    template<typename... Ix> void check_dimensions_impl(ssize_t axis, const ssize_t* shape, ssize_t i, Ix... index) const {
+    template <typename... Ix>
+    void check_dimensions_impl(ssize_t axis, const ssize_t *shape, ssize_t i, Ix... index) const {
         if (i >= *shape) {
-            throw index_error(std::string("index ") + std::to_string(i) +
-                              " is out of bounds for axis " + std::to_string(axis) +
-                              " with size " + std::to_string(*shape));
+            throw index_error(std::string("index ") + std::to_string(i)
+                              + " is out of bounds for axis " + std::to_string(axis)
+                              + " with size " + std::to_string(*shape));
         }
         check_dimensions_impl(axis + 1, shape + 1, index...);
     }
 
     /// Create array from any object -- always returns a new reference
     static PyObject *raw_array(PyObject *ptr, int ExtraFlags = 0) {
         if (ptr == nullptr) {
@@ -828,145 +983,179 @@
             return nullptr;
         }
         return detail::npy_api::get().PyArray_FromAny_(
             ptr, nullptr, 0, 0, detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);
     }
 };
 
-template <typename T, int ExtraFlags = array::forcecast> class array_t : public array {
+template <typename T, int ExtraFlags = array::forcecast>
+class array_t : public array {
 private:
     struct private_ctor {};
     // Delegating constructor needed when both moving and accessing in the same constructor
-    array_t(private_ctor, ShapeContainer &&shape, StridesContainer &&strides, const T *ptr, handle base)
+    array_t(private_ctor,
+            ShapeContainer &&shape,
+            StridesContainer &&strides,
+            const T *ptr,
+            handle base)
         : array(std::move(shape), std::move(strides), ptr, base) {}
+
 public:
     static_assert(!detail::array_info<T>::is_array, "Array types cannot be used with array_t");
 
     using value_type = T;
 
     array_t() : array(0, static_cast<const T *>(nullptr)) {}
-    array_t(handle h, borrowed_t) : array(h, borrowed_t{}) { }
-    array_t(handle h, stolen_t) : array(h, stolen_t{}) { }
+    array_t(handle h, borrowed_t) : array(h, borrowed_t{}) {}
+    array_t(handle h, stolen_t) : array(h, stolen_t{}) {}
 
     PYBIND11_DEPRECATED("Use array_t<T>::ensure() instead")
     array_t(handle h, bool is_borrowed) : array(raw_array_t(h.ptr()), stolen_t{}) {
-        if (!m_ptr) PyErr_Clear();
-        if (!is_borrowed) Py_XDECREF(h.ptr());
+        if (!m_ptr) {
+            PyErr_Clear();
+        }
+        if (!is_borrowed) {
+            Py_XDECREF(h.ptr());
+        }
     }
 
+    // NOLINTNEXTLINE(google-explicit-constructor)
     array_t(const object &o) : array(raw_array_t(o.ptr()), stolen_t{}) {
-        if (!m_ptr) throw error_already_set();
+        if (!m_ptr) {
+            throw error_already_set();
+        }
     }
 
-    explicit array_t(const buffer_info& info, handle base = handle()) : array(info, base) { }
+    explicit array_t(const buffer_info &info, handle base = handle()) : array(info, base) {}
 
-    array_t(ShapeContainer shape, StridesContainer strides, const T *ptr = nullptr, handle base = handle())
-        : array(std::move(shape), std::move(strides), ptr, base) { }
+    array_t(ShapeContainer shape,
+            StridesContainer strides,
+            const T *ptr = nullptr,
+            handle base = handle())
+        : array(std::move(shape), std::move(strides), ptr, base) {}
 
     explicit array_t(ShapeContainer shape, const T *ptr = nullptr, handle base = handle())
-        : array_t(private_ctor{}, std::move(shape),
-                ExtraFlags & f_style
-                ? detail::f_strides(*shape, itemsize())
-                : detail::c_strides(*shape, itemsize()),
-                ptr, base) { }
+        : array_t(private_ctor{},
+                  std::move(shape),
+                  (ExtraFlags & f_style) != 0 ? detail::f_strides(*shape, itemsize())
+                                              : detail::c_strides(*shape, itemsize()),
+                  ptr,
+                  base) {}
 
     explicit array_t(ssize_t count, const T *ptr = nullptr, handle base = handle())
-        : array({count}, {}, ptr, base) { }
+        : array({count}, {}, ptr, base) {}
 
-    constexpr ssize_t itemsize() const {
-        return sizeof(T);
-    }
+    constexpr ssize_t itemsize() const { return sizeof(T); }
 
-    template<typename... Ix> ssize_t index_at(Ix... index) const {
+    template <typename... Ix>
+    ssize_t index_at(Ix... index) const {
         return offset_at(index...) / itemsize();
     }
 
-    template<typename... Ix> const T* data(Ix... index) const {
-        return static_cast<const T*>(array::data(index...));
+    template <typename... Ix>
+    const T *data(Ix... index) const {
+        return static_cast<const T *>(array::data(index...));
     }
 
-    template<typename... Ix> T* mutable_data(Ix... index) {
-        return static_cast<T*>(array::mutable_data(index...));
+    template <typename... Ix>
+    T *mutable_data(Ix... index) {
+        return static_cast<T *>(array::mutable_data(index...));
     }
 
     // Reference to element at a given index
-    template<typename... Ix> const T& at(Ix... index) const {
-        if ((ssize_t) sizeof...(index) != ndim())
+    template <typename... Ix>
+    const T &at(Ix... index) const {
+        if ((ssize_t) sizeof...(index) != ndim()) {
             fail_dim_check(sizeof...(index), "index dimension mismatch");
-        return *(static_cast<const T*>(array::data()) + byte_offset(ssize_t(index)...) / itemsize());
+        }
+        return *(static_cast<const T *>(array::data())
+                 + byte_offset(ssize_t(index)...) / itemsize());
     }
 
     // Mutable reference to element at a given index
-    template<typename... Ix> T& mutable_at(Ix... index) {
-        if ((ssize_t) sizeof...(index) != ndim())
+    template <typename... Ix>
+    T &mutable_at(Ix... index) {
+        if ((ssize_t) sizeof...(index) != ndim()) {
             fail_dim_check(sizeof...(index), "index dimension mismatch");
-        return *(static_cast<T*>(array::mutable_data()) + byte_offset(ssize_t(index)...) / itemsize());
+        }
+        return *(static_cast<T *>(array::mutable_data())
+                 + byte_offset(ssize_t(index)...) / itemsize());
     }
 
     /**
      * Returns a proxy object that provides access to the array's data without bounds or
      * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with
      * care: the array must not be destroyed or reshaped for the duration of the returned object,
      * and the caller must take care not to access invalid dimensions or dimension indices.
      */
-    template <ssize_t Dims = -1> detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
+    template <ssize_t Dims = -1>
+    detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
         return array::mutable_unchecked<T, Dims>();
     }
 
     /**
      * Returns a proxy object that provides const access to the array's data without bounds or
      * dimensionality checking.  Unlike `unchecked()`, this does not require that the underlying
      * array have the `writable` flag.  Use with care: the array must not be destroyed or reshaped
      * for the duration of the returned object, and the caller must take care not to access invalid
      * dimensions or dimension indices.
      */
-    template <ssize_t Dims = -1> detail::unchecked_reference<T, Dims> unchecked() const & {
+    template <ssize_t Dims = -1>
+    detail::unchecked_reference<T, Dims> unchecked() const & {
         return array::unchecked<T, Dims>();
     }
 
     /// Ensure that the argument is a NumPy array of the correct dtype (and if not, try to convert
     /// it).  In case of an error, nullptr is returned and the Python error is cleared.
     static array_t ensure(handle h) {
         auto result = reinterpret_steal<array_t>(raw_array_t(h.ptr()));
-        if (!result)
+        if (!result) {
             PyErr_Clear();
+        }
         return result;
     }
 
     static bool check_(handle h) {
         const auto &api = detail::npy_api::get();
         return api.PyArray_Check_(h.ptr())
-               && api.PyArray_EquivTypes_(detail::array_proxy(h.ptr())->descr, dtype::of<T>().ptr())
+               && api.PyArray_EquivTypes_(detail::array_proxy(h.ptr())->descr,
+                                          dtype::of<T>().ptr())
                && detail::check_flags(h.ptr(), ExtraFlags & (array::c_style | array::f_style));
     }
 
 protected:
     /// Create array from any object -- always returns a new reference
     static PyObject *raw_array_t(PyObject *ptr) {
         if (ptr == nullptr) {
             PyErr_SetString(PyExc_ValueError, "cannot create a pybind11::array_t from a nullptr");
             return nullptr;
         }
-        return detail::npy_api::get().PyArray_FromAny_(
-            ptr, dtype::of<T>().release().ptr(), 0, 0,
-            detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);
+        return detail::npy_api::get().PyArray_FromAny_(ptr,
+                                                       dtype::of<T>().release().ptr(),
+                                                       0,
+                                                       0,
+                                                       detail::npy_api::NPY_ARRAY_ENSUREARRAY_
+                                                           | ExtraFlags,
+                                                       nullptr);
     }
 };
 
 template <typename T>
 struct format_descriptor<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {
     static std::string format() {
         return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::format();
     }
 };
 
-template <size_t N> struct format_descriptor<char[N]> {
+template <size_t N>
+struct format_descriptor<char[N]> {
     static std::string format() { return std::to_string(N) + "s"; }
 };
-template <size_t N> struct format_descriptor<std::array<char, N>> {
+template <size_t N>
+struct format_descriptor<std::array<char, N>> {
     static std::string format() { return std::to_string(N) + "s"; }
 };
 
 template <typename T>
 struct format_descriptor<T, detail::enable_if_t<std::is_enum<T>::value>> {
     static std::string format() {
         return format_descriptor<
@@ -974,154 +1163,193 @@
     }
 };
 
 template <typename T>
 struct format_descriptor<T, detail::enable_if_t<detail::array_info<T>::is_array>> {
     static std::string format() {
         using namespace detail;
-        static constexpr auto extents = _("(") + array_info<T>::extents + _(")");
+        static constexpr auto extents = const_name("(") + array_info<T>::extents + const_name(")");
         return extents.text + format_descriptor<remove_all_extents_t<T>>::format();
     }
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 template <typename T, int ExtraFlags>
 struct pyobject_caster<array_t<T, ExtraFlags>> {
     using type = array_t<T, ExtraFlags>;
 
     bool load(handle src, bool convert) {
-        if (!convert && !type::check_(src))
+        if (!convert && !type::check_(src)) {
             return false;
+        }
         value = type::ensure(src);
         return static_cast<bool>(value);
     }
 
     static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {
         return src.inc_ref();
     }
     PYBIND11_TYPE_CASTER(type, handle_type_name<type>::name);
 };
 
 template <typename T>
 struct compare_buffer_info<T, detail::enable_if_t<detail::is_pod_struct<T>::value>> {
-    static bool compare(const buffer_info& b) {
+    static bool compare(const buffer_info &b) {
         return npy_api::get().PyArray_EquivTypes_(dtype::of<T>().ptr(), dtype(b).ptr());
     }
 };
 
 template <typename T, typename = void>
 struct npy_format_descriptor_name;
 
 template <typename T>
 struct npy_format_descriptor_name<T, enable_if_t<std::is_integral<T>::value>> {
-    static constexpr auto name = _<std::is_same<T, bool>::value>(
-        _("bool"), _<std::is_signed<T>::value>("numpy.int", "numpy.uint") + _<sizeof(T)*8>()
-    );
+    static constexpr auto name = const_name<std::is_same<T, bool>::value>(
+        const_name("bool"),
+        const_name<std::is_signed<T>::value>("numpy.int", "numpy.uint")
+            + const_name<sizeof(T) * 8>());
 };
 
 template <typename T>
 struct npy_format_descriptor_name<T, enable_if_t<std::is_floating_point<T>::value>> {
-    static constexpr auto name = _<std::is_same<T, float>::value || std::is_same<T, double>::value>(
-        _("numpy.float") + _<sizeof(T)*8>(), _("numpy.longdouble")
-    );
+    static constexpr auto name = const_name < std::is_same<T, float>::value
+                                 || std::is_same<T, const float>::value
+                                 || std::is_same<T, double>::value
+                                 || std::is_same<T, const double>::value
+                                        > (const_name("numpy.float") + const_name<sizeof(T) * 8>(),
+                                           const_name("numpy.longdouble"));
 };
 
 template <typename T>
 struct npy_format_descriptor_name<T, enable_if_t<is_complex<T>::value>> {
-    static constexpr auto name = _<std::is_same<typename T::value_type, float>::value
-                                   || std::is_same<typename T::value_type, double>::value>(
-        _("numpy.complex") + _<sizeof(typename T::value_type)*16>(), _("numpy.longcomplex")
-    );
+    static constexpr auto name = const_name < std::is_same<typename T::value_type, float>::value
+                                 || std::is_same<typename T::value_type, const float>::value
+                                 || std::is_same<typename T::value_type, double>::value
+                                 || std::is_same<typename T::value_type, const double>::value
+                                        > (const_name("numpy.complex")
+                                               + const_name<sizeof(typename T::value_type) * 16>(),
+                                           const_name("numpy.longcomplex"));
 };
 
 template <typename T>
-struct npy_format_descriptor<T, enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>>
+struct npy_format_descriptor<
+    T,
+    enable_if_t<satisfies_any_of<T, std::is_arithmetic, is_complex>::value>>
     : npy_format_descriptor_name<T> {
 private:
     // NB: the order here must match the one in common.h
-    constexpr static const int values[15] = {
-        npy_api::NPY_BOOL_,
-        npy_api::NPY_BYTE_,   npy_api::NPY_UBYTE_,   npy_api::NPY_INT16_,    npy_api::NPY_UINT16_,
-        npy_api::NPY_INT32_,  npy_api::NPY_UINT32_,  npy_api::NPY_INT64_,    npy_api::NPY_UINT64_,
-        npy_api::NPY_FLOAT_,  npy_api::NPY_DOUBLE_,  npy_api::NPY_LONGDOUBLE_,
-        npy_api::NPY_CFLOAT_, npy_api::NPY_CDOUBLE_, npy_api::NPY_CLONGDOUBLE_
-    };
+    constexpr static const int values[15] = {npy_api::NPY_BOOL_,
+                                             npy_api::NPY_BYTE_,
+                                             npy_api::NPY_UBYTE_,
+                                             npy_api::NPY_INT16_,
+                                             npy_api::NPY_UINT16_,
+                                             npy_api::NPY_INT32_,
+                                             npy_api::NPY_UINT32_,
+                                             npy_api::NPY_INT64_,
+                                             npy_api::NPY_UINT64_,
+                                             npy_api::NPY_FLOAT_,
+                                             npy_api::NPY_DOUBLE_,
+                                             npy_api::NPY_LONGDOUBLE_,
+                                             npy_api::NPY_CFLOAT_,
+                                             npy_api::NPY_CDOUBLE_,
+                                             npy_api::NPY_CLONGDOUBLE_};
 
 public:
     static constexpr int value = values[detail::is_fmt_numeric<T>::index];
 
     static pybind11::dtype dtype() {
-        if (auto ptr = npy_api::get().PyArray_DescrFromType_(value))
+        if (auto *ptr = npy_api::get().PyArray_DescrFromType_(value)) {
             return reinterpret_steal<pybind11::dtype>(ptr);
+        }
         pybind11_fail("Unsupported buffer format!");
     }
 };
 
-#define PYBIND11_DECL_CHAR_FMT \
-    static constexpr auto name = _("S") + _<N>(); \
-    static pybind11::dtype dtype() { return pybind11::dtype(std::string("S") + std::to_string(N)); }
-template <size_t N> struct npy_format_descriptor<char[N]> { PYBIND11_DECL_CHAR_FMT };
-template <size_t N> struct npy_format_descriptor<std::array<char, N>> { PYBIND11_DECL_CHAR_FMT };
+#define PYBIND11_DECL_CHAR_FMT                                                                    \
+    static constexpr auto name = const_name("S") + const_name<N>();                               \
+    static pybind11::dtype dtype() {                                                              \
+        return pybind11::dtype(std::string("S") + std::to_string(N));                             \
+    }
+template <size_t N>
+struct npy_format_descriptor<char[N]> {
+    PYBIND11_DECL_CHAR_FMT
+};
+template <size_t N>
+struct npy_format_descriptor<std::array<char, N>> {
+    PYBIND11_DECL_CHAR_FMT
+};
 #undef PYBIND11_DECL_CHAR_FMT
 
-template<typename T> struct npy_format_descriptor<T, enable_if_t<array_info<T>::is_array>> {
+template <typename T>
+struct npy_format_descriptor<T, enable_if_t<array_info<T>::is_array>> {
 private:
     using base_descr = npy_format_descriptor<typename array_info<T>::type>;
+
 public:
     static_assert(!array_info<T>::is_empty, "Zero-sized arrays are not supported");
 
-    static constexpr auto name = _("(") + array_info<T>::extents + _(")") + base_descr::name;
+    static constexpr auto name
+        = const_name("(") + array_info<T>::extents + const_name(")") + base_descr::name;
     static pybind11::dtype dtype() {
         list shape;
         array_info<T>::append_extents(shape);
         return pybind11::dtype::from_args(pybind11::make_tuple(base_descr::dtype(), shape));
     }
 };
 
-template<typename T> struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>::value>> {
+template <typename T>
+struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>::value>> {
 private:
     using base_descr = npy_format_descriptor<typename std::underlying_type<T>::type>;
+
 public:
     static constexpr auto name = base_descr::name;
     static pybind11::dtype dtype() { return base_descr::dtype(); }
 };
 
 struct field_descriptor {
     const char *name;
     ssize_t offset;
     ssize_t size;
     std::string format;
     dtype descr;
 };
 
-inline PYBIND11_NOINLINE void register_structured_dtype(
-    any_container<field_descriptor> fields,
-    const std::type_info& tinfo, ssize_t itemsize,
-    bool (*direct_converter)(PyObject *, void *&)) {
+PYBIND11_NOINLINE void register_structured_dtype(any_container<field_descriptor> fields,
+                                                 const std::type_info &tinfo,
+                                                 ssize_t itemsize,
+                                                 bool (*direct_converter)(PyObject *, void *&)) {
 
-    auto& numpy_internals = get_numpy_internals();
-    if (numpy_internals.get_type_info(tinfo, false))
+    auto &numpy_internals = get_numpy_internals();
+    if (numpy_internals.get_type_info(tinfo, false)) {
         pybind11_fail("NumPy: dtype is already registered");
+    }
 
     // Use ordered fields because order matters as of NumPy 1.14:
     // https://docs.scipy.org/doc/numpy/release.html#multiple-field-indexing-assignment-of-structured-arrays
     std::vector<field_descriptor> ordered_fields(std::move(fields));
-    std::sort(ordered_fields.begin(), ordered_fields.end(),
+    std::sort(
+        ordered_fields.begin(),
+        ordered_fields.end(),
         [](const field_descriptor &a, const field_descriptor &b) { return a.offset < b.offset; });
 
     list names, formats, offsets;
-    for (auto& field : ordered_fields) {
-        if (!field.descr)
-            pybind11_fail(std::string("NumPy: unsupported field dtype: `") +
-                            field.name + "` @ " + tinfo.name());
+    for (auto &field : ordered_fields) {
+        if (!field.descr) {
+            pybind11_fail(std::string("NumPy: unsupported field dtype: `") + field.name + "` @ "
+                          + tinfo.name());
+        }
         names.append(PYBIND11_STR_TYPE(field.name));
         formats.append(field.descr);
         offsets.append(pybind11::int_(field.offset));
     }
-    auto dtype_ptr = pybind11::dtype(names, formats, offsets, itemsize).release().ptr();
+    auto *dtype_ptr
+        = pybind11::dtype(std::move(names), std::move(formats), std::move(offsets), itemsize)
+              .release()
+              .ptr();
 
     // There is an existing bug in NumPy (as of v1.11): trailing bytes are
     // not encoded explicitly into the format string. This will supposedly
     // get fixed in v1.12; for further details, see these:
     // - https://github.com/numpy/numpy/issues/7797
     // - https://github.com/numpy/numpy/pull/7798
     // Because of this, we won't use numpy's logic to generate buffer format
@@ -1130,564 +1358,601 @@
     std::ostringstream oss;
     // mark the structure as unaligned with '^', because numpy and C++ don't
     // always agree about alignment (particularly for complex), and we're
     // explicitly listing all our padding. This depends on none of the fields
     // overriding the endianness. Putting the ^ in front of individual fields
     // isn't guaranteed to work due to https://github.com/numpy/numpy/issues/9049
     oss << "^T{";
-    for (auto& field : ordered_fields) {
-        if (field.offset > offset)
+    for (auto &field : ordered_fields) {
+        if (field.offset > offset) {
             oss << (field.offset - offset) << 'x';
+        }
         oss << field.format << ':' << field.name << ':';
         offset = field.offset + field.size;
     }
-    if (itemsize > offset)
+    if (itemsize > offset) {
         oss << (itemsize - offset) << 'x';
+    }
     oss << '}';
     auto format_str = oss.str();
 
     // Sanity check: verify that NumPy properly parses our buffer format string
-    auto& api = npy_api::get();
-    auto arr =  array(buffer_info(nullptr, itemsize, format_str, 1));
-    if (!api.PyArray_EquivTypes_(dtype_ptr, arr.dtype().ptr()))
+    auto &api = npy_api::get();
+    auto arr = array(buffer_info(nullptr, itemsize, format_str, 1));
+    if (!api.PyArray_EquivTypes_(dtype_ptr, arr.dtype().ptr())) {
         pybind11_fail("NumPy: invalid buffer descriptor!");
+    }
 
     auto tindex = std::type_index(tinfo);
-    numpy_internals.registered_dtypes[tindex] = { dtype_ptr, format_str };
+    numpy_internals.registered_dtypes[tindex] = {dtype_ptr, format_str};
     get_internals().direct_conversions[tindex].push_back(direct_converter);
 }
 
-template <typename T, typename SFINAE> struct npy_format_descriptor {
-    static_assert(is_pod_struct<T>::value, "Attempt to use a non-POD or unimplemented POD type as a numpy dtype");
+template <typename T, typename SFINAE>
+struct npy_format_descriptor {
+    static_assert(is_pod_struct<T>::value,
+                  "Attempt to use a non-POD or unimplemented POD type as a numpy dtype");
 
     static constexpr auto name = make_caster<T>::name;
 
-    static pybind11::dtype dtype() {
-        return reinterpret_borrow<pybind11::dtype>(dtype_ptr());
-    }
+    static pybind11::dtype dtype() { return reinterpret_borrow<pybind11::dtype>(dtype_ptr()); }
 
     static std::string format() {
         static auto format_str = get_numpy_internals().get_type_info<T>(true)->format_str;
         return format_str;
     }
 
     static void register_dtype(any_container<field_descriptor> fields) {
-        register_structured_dtype(std::move(fields), typeid(typename std::remove_cv<T>::type),
-                                  sizeof(T), &direct_converter);
+        register_structured_dtype(std::move(fields),
+                                  typeid(typename std::remove_cv<T>::type),
+                                  sizeof(T),
+                                  &direct_converter);
     }
 
 private:
-    static PyObject* dtype_ptr() {
-        static PyObject* ptr = get_numpy_internals().get_type_info<T>(true)->dtype_ptr;
+    static PyObject *dtype_ptr() {
+        static PyObject *ptr = get_numpy_internals().get_type_info<T>(true)->dtype_ptr;
         return ptr;
     }
 
-    static bool direct_converter(PyObject *obj, void*& value) {
-        auto& api = npy_api::get();
-        if (!PyObject_TypeCheck(obj, api.PyVoidArrType_Type_))
+    static bool direct_converter(PyObject *obj, void *&value) {
+        auto &api = npy_api::get();
+        if (!PyObject_TypeCheck(obj, api.PyVoidArrType_Type_)) {
             return false;
+        }
         if (auto descr = reinterpret_steal<object>(api.PyArray_DescrFromScalar_(obj))) {
             if (api.PyArray_EquivTypes_(dtype_ptr(), descr.ptr())) {
                 value = ((PyVoidScalarObject_Proxy *) obj)->obval;
                 return true;
             }
         }
         return false;
     }
 };
 
 #ifdef __CLION_IDE__ // replace heavy macro with dummy code for the IDE (doesn't affect code)
-# define PYBIND11_NUMPY_DTYPE(Type, ...) ((void)0)
-# define PYBIND11_NUMPY_DTYPE_EX(Type, ...) ((void)0)
+#    define PYBIND11_NUMPY_DTYPE(Type, ...) ((void) 0)
+#    define PYBIND11_NUMPY_DTYPE_EX(Type, ...) ((void) 0)
 #else
 
-#define PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, Name)                                          \
-    ::pybind11::detail::field_descriptor {                                                    \
-        Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),                  \
-        ::pybind11::format_descriptor<decltype(std::declval<T>().Field)>::format(),           \
-        ::pybind11::detail::npy_format_descriptor<decltype(std::declval<T>().Field)>::dtype() \
-    }
+#    define PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, Name)                                          \
+        ::pybind11::detail::field_descriptor {                                                    \
+            Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),                  \
+                ::pybind11::format_descriptor<decltype(std::declval<T>().Field)>::format(),       \
+                ::pybind11::detail::npy_format_descriptor<                                        \
+                    decltype(std::declval<T>().Field)>::dtype()                                   \
+        }
 
 // Extract name, offset and format descriptor for a struct field
-#define PYBIND11_FIELD_DESCRIPTOR(T, Field) PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #Field)
+#    define PYBIND11_FIELD_DESCRIPTOR(T, Field) PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #    Field)
 
 // The main idea of this macro is borrowed from https://github.com/swansontec/map-macro
 // (C) William Swanson, Paul Fultz
-#define PYBIND11_EVAL0(...) __VA_ARGS__
-#define PYBIND11_EVAL1(...) PYBIND11_EVAL0 (PYBIND11_EVAL0 (PYBIND11_EVAL0 (__VA_ARGS__)))
-#define PYBIND11_EVAL2(...) PYBIND11_EVAL1 (PYBIND11_EVAL1 (PYBIND11_EVAL1 (__VA_ARGS__)))
-#define PYBIND11_EVAL3(...) PYBIND11_EVAL2 (PYBIND11_EVAL2 (PYBIND11_EVAL2 (__VA_ARGS__)))
-#define PYBIND11_EVAL4(...) PYBIND11_EVAL3 (PYBIND11_EVAL3 (PYBIND11_EVAL3 (__VA_ARGS__)))
-#define PYBIND11_EVAL(...)  PYBIND11_EVAL4 (PYBIND11_EVAL4 (PYBIND11_EVAL4 (__VA_ARGS__)))
-#define PYBIND11_MAP_END(...)
-#define PYBIND11_MAP_OUT
-#define PYBIND11_MAP_COMMA ,
-#define PYBIND11_MAP_GET_END() 0, PYBIND11_MAP_END
-#define PYBIND11_MAP_NEXT0(test, next, ...) next PYBIND11_MAP_OUT
-#define PYBIND11_MAP_NEXT1(test, next) PYBIND11_MAP_NEXT0 (test, next, 0)
-#define PYBIND11_MAP_NEXT(test, next)  PYBIND11_MAP_NEXT1 (PYBIND11_MAP_GET_END test, next)
-#if defined(_MSC_VER) && !defined(__clang__) // MSVC is not as eager to expand macros, hence this workaround
-#define PYBIND11_MAP_LIST_NEXT1(test, next) \
-    PYBIND11_EVAL0 (PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0))
-#else
-#define PYBIND11_MAP_LIST_NEXT1(test, next) \
-    PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0)
-#endif
-#define PYBIND11_MAP_LIST_NEXT(test, next) \
-    PYBIND11_MAP_LIST_NEXT1 (PYBIND11_MAP_GET_END test, next)
-#define PYBIND11_MAP_LIST0(f, t, x, peek, ...) \
-    f(t, x) PYBIND11_MAP_LIST_NEXT (peek, PYBIND11_MAP_LIST1) (f, t, peek, __VA_ARGS__)
-#define PYBIND11_MAP_LIST1(f, t, x, peek, ...) \
-    f(t, x) PYBIND11_MAP_LIST_NEXT (peek, PYBIND11_MAP_LIST0) (f, t, peek, __VA_ARGS__)
+#    define PYBIND11_EVAL0(...) __VA_ARGS__
+#    define PYBIND11_EVAL1(...) PYBIND11_EVAL0(PYBIND11_EVAL0(PYBIND11_EVAL0(__VA_ARGS__)))
+#    define PYBIND11_EVAL2(...) PYBIND11_EVAL1(PYBIND11_EVAL1(PYBIND11_EVAL1(__VA_ARGS__)))
+#    define PYBIND11_EVAL3(...) PYBIND11_EVAL2(PYBIND11_EVAL2(PYBIND11_EVAL2(__VA_ARGS__)))
+#    define PYBIND11_EVAL4(...) PYBIND11_EVAL3(PYBIND11_EVAL3(PYBIND11_EVAL3(__VA_ARGS__)))
+#    define PYBIND11_EVAL(...) PYBIND11_EVAL4(PYBIND11_EVAL4(PYBIND11_EVAL4(__VA_ARGS__)))
+#    define PYBIND11_MAP_END(...)
+#    define PYBIND11_MAP_OUT
+#    define PYBIND11_MAP_COMMA ,
+#    define PYBIND11_MAP_GET_END() 0, PYBIND11_MAP_END
+#    define PYBIND11_MAP_NEXT0(test, next, ...) next PYBIND11_MAP_OUT
+#    define PYBIND11_MAP_NEXT1(test, next) PYBIND11_MAP_NEXT0(test, next, 0)
+#    define PYBIND11_MAP_NEXT(test, next) PYBIND11_MAP_NEXT1(PYBIND11_MAP_GET_END test, next)
+#    if defined(_MSC_VER)                                                                         \
+        && !defined(__clang__) // MSVC is not as eager to expand macros, hence this workaround
+#        define PYBIND11_MAP_LIST_NEXT1(test, next)                                               \
+            PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))
+#    else
+#        define PYBIND11_MAP_LIST_NEXT1(test, next)                                               \
+            PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)
+#    endif
+#    define PYBIND11_MAP_LIST_NEXT(test, next)                                                    \
+        PYBIND11_MAP_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)
+#    define PYBIND11_MAP_LIST0(f, t, x, peek, ...)                                                \
+        f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST1)(f, t, peek, __VA_ARGS__)
+#    define PYBIND11_MAP_LIST1(f, t, x, peek, ...)                                                \
+        f(t, x) PYBIND11_MAP_LIST_NEXT(peek, PYBIND11_MAP_LIST0)(f, t, peek, __VA_ARGS__)
 // PYBIND11_MAP_LIST(f, t, a1, a2, ...) expands to f(t, a1), f(t, a2), ...
-#define PYBIND11_MAP_LIST(f, t, ...) \
-    PYBIND11_EVAL (PYBIND11_MAP_LIST1 (f, t, __VA_ARGS__, (), 0))
+#    define PYBIND11_MAP_LIST(f, t, ...)                                                          \
+        PYBIND11_EVAL(PYBIND11_MAP_LIST1(f, t, __VA_ARGS__, (), 0))
 
-#define PYBIND11_NUMPY_DTYPE(Type, ...) \
-    ::pybind11::detail::npy_format_descriptor<Type>::register_dtype \
-        (::std::vector<::pybind11::detail::field_descriptor> \
-         {PYBIND11_MAP_LIST (PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})
-
-#if defined(_MSC_VER) && !defined(__clang__)
-#define PYBIND11_MAP2_LIST_NEXT1(test, next) \
-    PYBIND11_EVAL0 (PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0))
-#else
-#define PYBIND11_MAP2_LIST_NEXT1(test, next) \
-    PYBIND11_MAP_NEXT0 (test, PYBIND11_MAP_COMMA next, 0)
-#endif
-#define PYBIND11_MAP2_LIST_NEXT(test, next) \
-    PYBIND11_MAP2_LIST_NEXT1 (PYBIND11_MAP_GET_END test, next)
-#define PYBIND11_MAP2_LIST0(f, t, x1, x2, peek, ...) \
-    f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT (peek, PYBIND11_MAP2_LIST1) (f, t, peek, __VA_ARGS__)
-#define PYBIND11_MAP2_LIST1(f, t, x1, x2, peek, ...) \
-    f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT (peek, PYBIND11_MAP2_LIST0) (f, t, peek, __VA_ARGS__)
+#    define PYBIND11_NUMPY_DTYPE(Type, ...)                                                       \
+        ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(                          \
+            ::std::vector<::pybind11::detail::field_descriptor>{                                  \
+                PYBIND11_MAP_LIST(PYBIND11_FIELD_DESCRIPTOR, Type, __VA_ARGS__)})
+
+#    if defined(_MSC_VER) && !defined(__clang__)
+#        define PYBIND11_MAP2_LIST_NEXT1(test, next)                                              \
+            PYBIND11_EVAL0(PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0))
+#    else
+#        define PYBIND11_MAP2_LIST_NEXT1(test, next)                                              \
+            PYBIND11_MAP_NEXT0(test, PYBIND11_MAP_COMMA next, 0)
+#    endif
+#    define PYBIND11_MAP2_LIST_NEXT(test, next)                                                   \
+        PYBIND11_MAP2_LIST_NEXT1(PYBIND11_MAP_GET_END test, next)
+#    define PYBIND11_MAP2_LIST0(f, t, x1, x2, peek, ...)                                          \
+        f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST1)(f, t, peek, __VA_ARGS__)
+#    define PYBIND11_MAP2_LIST1(f, t, x1, x2, peek, ...)                                          \
+        f(t, x1, x2) PYBIND11_MAP2_LIST_NEXT(peek, PYBIND11_MAP2_LIST0)(f, t, peek, __VA_ARGS__)
 // PYBIND11_MAP2_LIST(f, t, a1, a2, ...) expands to f(t, a1, a2), f(t, a3, a4), ...
-#define PYBIND11_MAP2_LIST(f, t, ...) \
-    PYBIND11_EVAL (PYBIND11_MAP2_LIST1 (f, t, __VA_ARGS__, (), 0))
+#    define PYBIND11_MAP2_LIST(f, t, ...)                                                         \
+        PYBIND11_EVAL(PYBIND11_MAP2_LIST1(f, t, __VA_ARGS__, (), 0))
 
-#define PYBIND11_NUMPY_DTYPE_EX(Type, ...) \
-    ::pybind11::detail::npy_format_descriptor<Type>::register_dtype \
-        (::std::vector<::pybind11::detail::field_descriptor> \
-         {PYBIND11_MAP2_LIST (PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})
+#    define PYBIND11_NUMPY_DTYPE_EX(Type, ...)                                                    \
+        ::pybind11::detail::npy_format_descriptor<Type>::register_dtype(                          \
+            ::std::vector<::pybind11::detail::field_descriptor>{                                  \
+                PYBIND11_MAP2_LIST(PYBIND11_FIELD_DESCRIPTOR_EX, Type, __VA_ARGS__)})
 
 #endif // __CLION_IDE__
 
 class common_iterator {
 public:
     using container_type = std::vector<ssize_t>;
     using value_type = container_type::value_type;
     using size_type = container_type::size_type;
 
-    common_iterator() : p_ptr(0), m_strides() {}
+    common_iterator() : m_strides() {}
 
-    common_iterator(void* ptr, const container_type& strides, const container_type& shape)
-        : p_ptr(reinterpret_cast<char*>(ptr)), m_strides(strides.size()) {
+    common_iterator(void *ptr, const container_type &strides, const container_type &shape)
+        : p_ptr(reinterpret_cast<char *>(ptr)), m_strides(strides.size()) {
         m_strides.back() = static_cast<value_type>(strides.back());
         for (size_type i = m_strides.size() - 1; i != 0; --i) {
             size_type j = i - 1;
             auto s = static_cast<value_type>(shape[i]);
             m_strides[j] = strides[j] + m_strides[i] - strides[i] * s;
         }
     }
 
-    void increment(size_type dim) {
-        p_ptr += m_strides[dim];
-    }
+    void increment(size_type dim) { p_ptr += m_strides[dim]; }
 
-    void* data() const {
-        return p_ptr;
-    }
+    void *data() const { return p_ptr; }
 
 private:
-    char* p_ptr;
+    char *p_ptr{0};
     container_type m_strides;
 };
 
-template <size_t N> class multi_array_iterator {
+template <size_t N>
+class multi_array_iterator {
 public:
     using container_type = std::vector<ssize_t>;
 
-    multi_array_iterator(const std::array<buffer_info, N> &buffers,
-                         const container_type &shape)
-        : m_shape(shape.size()), m_index(shape.size(), 0),
-          m_common_iterator() {
+    multi_array_iterator(const std::array<buffer_info, N> &buffers, const container_type &shape)
+        : m_shape(shape.size()), m_index(shape.size(), 0), m_common_iterator() {
 
         // Manual copy to avoid conversion warning if using std::copy
-        for (size_t i = 0; i < shape.size(); ++i)
+        for (size_t i = 0; i < shape.size(); ++i) {
             m_shape[i] = shape[i];
+        }
 
         container_type strides(shape.size());
-        for (size_t i = 0; i < N; ++i)
+        for (size_t i = 0; i < N; ++i) {
             init_common_iterator(buffers[i], shape, m_common_iterator[i], strides);
+        }
     }
 
-    multi_array_iterator& operator++() {
+    multi_array_iterator &operator++() {
         for (size_t j = m_index.size(); j != 0; --j) {
             size_t i = j - 1;
             if (++m_index[i] != m_shape[i]) {
                 increment_common_iterator(i);
                 break;
-            } else {
-                m_index[i] = 0;
             }
+            m_index[i] = 0;
         }
         return *this;
     }
 
-    template <size_t K, class T = void> T* data() const {
-        return reinterpret_cast<T*>(m_common_iterator[K].data());
+    template <size_t K, class T = void>
+    T *data() const {
+        return reinterpret_cast<T *>(m_common_iterator[K].data());
     }
 
 private:
-
     using common_iter = common_iterator;
 
     void init_common_iterator(const buffer_info &buffer,
                               const container_type &shape,
                               common_iter &iterator,
                               container_type &strides) {
         auto buffer_shape_iter = buffer.shape.rbegin();
         auto buffer_strides_iter = buffer.strides.rbegin();
         auto shape_iter = shape.rbegin();
         auto strides_iter = strides.rbegin();
 
         while (buffer_shape_iter != buffer.shape.rend()) {
-            if (*shape_iter == *buffer_shape_iter)
+            if (*shape_iter == *buffer_shape_iter) {
                 *strides_iter = *buffer_strides_iter;
-            else
+            } else {
                 *strides_iter = 0;
+            }
 
             ++buffer_shape_iter;
             ++buffer_strides_iter;
             ++shape_iter;
             ++strides_iter;
         }
 
         std::fill(strides_iter, strides.rend(), 0);
         iterator = common_iter(buffer.ptr, strides, shape);
     }
 
     void increment_common_iterator(size_t dim) {
-        for (auto &iter : m_common_iterator)
+        for (auto &iter : m_common_iterator) {
             iter.increment(dim);
+        }
     }
 
     container_type m_shape;
     container_type m_index;
     std::array<common_iter, N> m_common_iterator;
 };
 
 enum class broadcast_trivial { non_trivial, c_trivial, f_trivial };
 
-// Populates the shape and number of dimensions for the set of buffers.  Returns a broadcast_trivial
-// enum value indicating whether the broadcast is "trivial"--that is, has each buffer being either a
-// singleton or a full-size, C-contiguous (`c_trivial`) or Fortran-contiguous (`f_trivial`) storage
-// buffer; returns `non_trivial` otherwise.
+// Populates the shape and number of dimensions for the set of buffers.  Returns a
+// broadcast_trivial enum value indicating whether the broadcast is "trivial"--that is, has each
+// buffer being either a singleton or a full-size, C-contiguous (`c_trivial`) or Fortran-contiguous
+// (`f_trivial`) storage buffer; returns `non_trivial` otherwise.
 template <size_t N>
-broadcast_trivial broadcast(const std::array<buffer_info, N> &buffers, ssize_t &ndim, std::vector<ssize_t> &shape) {
-    ndim = std::accumulate(buffers.begin(), buffers.end(), ssize_t(0), [](ssize_t res, const buffer_info &buf) {
-        return std::max(res, buf.ndim);
-    });
+broadcast_trivial
+broadcast(const std::array<buffer_info, N> &buffers, ssize_t &ndim, std::vector<ssize_t> &shape) {
+    ndim = std::accumulate(
+        buffers.begin(), buffers.end(), ssize_t(0), [](ssize_t res, const buffer_info &buf) {
+            return std::max(res, buf.ndim);
+        });
 
     shape.clear();
     shape.resize((size_t) ndim, 1);
 
-    // Figure out the output size, and make sure all input arrays conform (i.e. are either size 1 or
-    // the full size).
+    // Figure out the output size, and make sure all input arrays conform (i.e. are either size 1
+    // or the full size).
     for (size_t i = 0; i < N; ++i) {
         auto res_iter = shape.rbegin();
         auto end = buffers[i].shape.rend();
-        for (auto shape_iter = buffers[i].shape.rbegin(); shape_iter != end; ++shape_iter, ++res_iter) {
+        for (auto shape_iter = buffers[i].shape.rbegin(); shape_iter != end;
+             ++shape_iter, ++res_iter) {
             const auto &dim_size_in = *shape_iter;
             auto &dim_size_out = *res_iter;
 
-            // Each input dimension can either be 1 or `n`, but `n` values must match across buffers
-            if (dim_size_out == 1)
+            // Each input dimension can either be 1 or `n`, but `n` values must match across
+            // buffers
+            if (dim_size_out == 1) {
                 dim_size_out = dim_size_in;
-            else if (dim_size_in != 1 && dim_size_in != dim_size_out)
+            } else if (dim_size_in != 1 && dim_size_in != dim_size_out) {
                 pybind11_fail("pybind11::vectorize: incompatible size/dimension of inputs!");
+            }
         }
     }
 
     bool trivial_broadcast_c = true;
     bool trivial_broadcast_f = true;
     for (size_t i = 0; i < N && (trivial_broadcast_c || trivial_broadcast_f); ++i) {
-        if (buffers[i].size == 1)
+        if (buffers[i].size == 1) {
             continue;
+        }
 
         // Require the same number of dimensions:
-        if (buffers[i].ndim != ndim)
+        if (buffers[i].ndim != ndim) {
             return broadcast_trivial::non_trivial;
+        }
 
         // Require all dimensions be full-size:
-        if (!std::equal(buffers[i].shape.cbegin(), buffers[i].shape.cend(), shape.cbegin()))
+        if (!std::equal(buffers[i].shape.cbegin(), buffers[i].shape.cend(), shape.cbegin())) {
             return broadcast_trivial::non_trivial;
+        }
 
         // Check for C contiguity (but only if previous inputs were also C contiguous)
         if (trivial_broadcast_c) {
             ssize_t expect_stride = buffers[i].itemsize;
             auto end = buffers[i].shape.crend();
-            for (auto shape_iter = buffers[i].shape.crbegin(), stride_iter = buffers[i].strides.crbegin();
-                    trivial_broadcast_c && shape_iter != end; ++shape_iter, ++stride_iter) {
-                if (expect_stride == *stride_iter)
+            for (auto shape_iter = buffers[i].shape.crbegin(),
+                      stride_iter = buffers[i].strides.crbegin();
+                 trivial_broadcast_c && shape_iter != end;
+                 ++shape_iter, ++stride_iter) {
+                if (expect_stride == *stride_iter) {
                     expect_stride *= *shape_iter;
-                else
+                } else {
                     trivial_broadcast_c = false;
+                }
             }
         }
 
         // Check for Fortran contiguity (if previous inputs were also F contiguous)
         if (trivial_broadcast_f) {
             ssize_t expect_stride = buffers[i].itemsize;
             auto end = buffers[i].shape.cend();
-            for (auto shape_iter = buffers[i].shape.cbegin(), stride_iter = buffers[i].strides.cbegin();
-                    trivial_broadcast_f && shape_iter != end; ++shape_iter, ++stride_iter) {
-                if (expect_stride == *stride_iter)
+            for (auto shape_iter = buffers[i].shape.cbegin(),
+                      stride_iter = buffers[i].strides.cbegin();
+                 trivial_broadcast_f && shape_iter != end;
+                 ++shape_iter, ++stride_iter) {
+                if (expect_stride == *stride_iter) {
                     expect_stride *= *shape_iter;
-                else
+                } else {
                     trivial_broadcast_f = false;
+                }
             }
         }
     }
 
-    return
-        trivial_broadcast_c ? broadcast_trivial::c_trivial :
-        trivial_broadcast_f ? broadcast_trivial::f_trivial :
-        broadcast_trivial::non_trivial;
+    return trivial_broadcast_c   ? broadcast_trivial::c_trivial
+           : trivial_broadcast_f ? broadcast_trivial::f_trivial
+                                 : broadcast_trivial::non_trivial;
 }
 
 template <typename T>
 struct vectorize_arg {
-    static_assert(!std::is_rvalue_reference<T>::value, "Functions with rvalue reference arguments cannot be vectorized");
+    static_assert(!std::is_rvalue_reference<T>::value,
+                  "Functions with rvalue reference arguments cannot be vectorized");
     // The wrapped function gets called with this type:
     using call_type = remove_reference_t<T>;
     // Is this a vectorized argument?
-    static constexpr bool vectorize =
-        satisfies_any_of<call_type, std::is_arithmetic, is_complex, is_pod>::value &&
-        satisfies_none_of<call_type, std::is_pointer, std::is_array, is_std_array, std::is_enum>::value &&
-        (!std::is_reference<T>::value ||
-         (std::is_lvalue_reference<T>::value && std::is_const<call_type>::value));
+    static constexpr bool vectorize
+        = satisfies_any_of<call_type, std::is_arithmetic, is_complex, is_pod>::value
+          && satisfies_none_of<call_type,
+                               std::is_pointer,
+                               std::is_array,
+                               is_std_array,
+                               std::is_enum>::value
+          && (!std::is_reference<T>::value
+              || (std::is_lvalue_reference<T>::value && std::is_const<call_type>::value));
     // Accept this type: an array for vectorized types, otherwise the type as-is:
     using type = conditional_t<vectorize, array_t<remove_cv_t<call_type>, array::forcecast>, T>;
 };
 
-
 // py::vectorize when a return type is present
 template <typename Func, typename Return, typename... Args>
 struct vectorize_returned_array {
     using Type = array_t<Return>;
 
     static Type create(broadcast_trivial trivial, const std::vector<ssize_t> &shape) {
-        if (trivial == broadcast_trivial::f_trivial)
+        if (trivial == broadcast_trivial::f_trivial) {
             return array_t<Return, array::f_style>(shape);
-        else
-            return array_t<Return>(shape);
+        }
+        return array_t<Return>(shape);
     }
 
-    static Return *mutable_data(Type &array) {
-        return array.mutable_data();
-    }
+    static Return *mutable_data(Type &array) { return array.mutable_data(); }
 
-    static Return call(Func &f, Args &... args) {
-        return f(args...);
-    }
+    static Return call(Func &f, Args &...args) { return f(args...); }
 
-    static void call(Return *out, size_t i, Func &f, Args &... args) {
-        out[i] = f(args...);
-    }
+    static void call(Return *out, size_t i, Func &f, Args &...args) { out[i] = f(args...); }
 };
 
 // py::vectorize when a return type is not present
 template <typename Func, typename... Args>
 struct vectorize_returned_array<Func, void, Args...> {
     using Type = none;
 
-    static Type create(broadcast_trivial, const std::vector<ssize_t> &) {
-        return none();
-    }
+    static Type create(broadcast_trivial, const std::vector<ssize_t> &) { return none(); }
 
-    static void *mutable_data(Type &) {
-        return nullptr;
-    }
+    static void *mutable_data(Type &) { return nullptr; }
 
-    static detail::void_type call(Func &f, Args &... args) {
+    static detail::void_type call(Func &f, Args &...args) {
         f(args...);
         return {};
     }
 
-    static void call(void *, size_t, Func &f, Args &... args) {
-        f(args...);
-    }
+    static void call(void *, size_t, Func &f, Args &...args) { f(args...); }
 };
 
-
 template <typename Func, typename Return, typename... Args>
 struct vectorize_helper {
 
 // NVCC for some reason breaks if NVectorized is private
 #ifdef __CUDACC__
 public:
 #else
 private:
 #endif
 
     static constexpr size_t N = sizeof...(Args);
     static constexpr size_t NVectorized = constexpr_sum(vectorize_arg<Args>::vectorize...);
-    static_assert(NVectorized >= 1,
-            "pybind11::vectorize(...) requires a function with at least one vectorizable argument");
+    static_assert(
+        NVectorized >= 1,
+        "pybind11::vectorize(...) requires a function with at least one vectorizable argument");
 
 public:
-    template <typename T>
-    explicit vectorize_helper(T &&f) : f(std::forward<T>(f)) { }
+    template <typename T,
+              // SFINAE to prevent shadowing the copy constructor.
+              typename = detail::enable_if_t<
+                  !std::is_same<vectorize_helper, typename std::decay<T>::type>::value>>
+    explicit vectorize_helper(T &&f) : f(std::forward<T>(f)) {}
 
     object operator()(typename vectorize_arg<Args>::type... args) {
         return run(args...,
                    make_index_sequence<N>(),
                    select_indices<vectorize_arg<Args>::vectorize...>(),
                    make_index_sequence<NVectorized>());
     }
 
 private:
     remove_reference_t<Func> f;
 
-    // Internal compiler error in MSVC 19.16.27025.1 (Visual Studio 2017 15.9.4), when compiling with "/permissive-" flag
-    // when arg_call_types is manually inlined.
+    // Internal compiler error in MSVC 19.16.27025.1 (Visual Studio 2017 15.9.4), when compiling
+    // with "/permissive-" flag when arg_call_types is manually inlined.
     using arg_call_types = std::tuple<typename vectorize_arg<Args>::call_type...>;
-    template <size_t Index> using param_n_t = typename std::tuple_element<Index, arg_call_types>::type;
+    template <size_t Index>
+    using param_n_t = typename std::tuple_element<Index, arg_call_types>::type;
 
     using returned_array = vectorize_returned_array<Func, Return, Args...>;
 
     // Runs a vectorized function given arguments tuple and three index sequences:
     //     - Index is the full set of 0 ... (N-1) argument indices;
     //     - VIndex is the subset of argument indices with vectorized parameters, letting us access
     //       vectorized arguments (anything not in this sequence is passed through)
     //     - BIndex is a incremental sequence (beginning at 0) of the same size as VIndex, so that
     //       we can store vectorized buffer_infos in an array (argument VIndex has its buffer at
     //       index BIndex in the array).
-    template <size_t... Index, size_t... VIndex, size_t... BIndex> object run(
-            typename vectorize_arg<Args>::type &...args,
-            index_sequence<Index...> i_seq, index_sequence<VIndex...> vi_seq, index_sequence<BIndex...> bi_seq) {
+    template <size_t... Index, size_t... VIndex, size_t... BIndex>
+    object run(typename vectorize_arg<Args>::type &...args,
+               index_sequence<Index...> i_seq,
+               index_sequence<VIndex...> vi_seq,
+               index_sequence<BIndex...> bi_seq) {
 
         // Pointers to values the function was called with; the vectorized ones set here will start
         // out as array_t<T> pointers, but they will be changed them to T pointers before we make
         // call the wrapped function.  Non-vectorized pointers are left as-is.
-        std::array<void *, N> params{{ &args... }};
+        std::array<void *, N> params{{&args...}};
 
         // The array of `buffer_info`s of vectorized arguments:
-        std::array<buffer_info, NVectorized> buffers{{ reinterpret_cast<array *>(params[VIndex])->request()... }};
+        std::array<buffer_info, NVectorized> buffers{
+            {reinterpret_cast<array *>(params[VIndex])->request()...}};
 
         /* Determine dimensions parameters of output array */
         ssize_t nd = 0;
         std::vector<ssize_t> shape(0);
         auto trivial = broadcast(buffers, nd, shape);
         auto ndim = (size_t) nd;
 
-        size_t size = std::accumulate(shape.begin(), shape.end(), (size_t) 1, std::multiplies<size_t>());
+        size_t size
+            = std::accumulate(shape.begin(), shape.end(), (size_t) 1, std::multiplies<size_t>());
 
         // If all arguments are 0-dimension arrays (i.e. single values) return a plain value (i.e.
         // not wrapped in an array).
         if (size == 1 && ndim == 0) {
             PYBIND11_EXPAND_SIDE_EFFECTS(params[VIndex] = buffers[BIndex].ptr);
-            return cast(returned_array::call(f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...));
+            return cast(
+                returned_array::call(f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...));
         }
 
         auto result = returned_array::create(trivial, shape);
 
-        if (size == 0) return std::move(result);
+        if (size == 0) {
+            return std::move(result);
+        }
 
         /* Call the function */
-        auto mutable_data = returned_array::mutable_data(result);
-        if (trivial == broadcast_trivial::non_trivial)
+        auto *mutable_data = returned_array::mutable_data(result);
+        if (trivial == broadcast_trivial::non_trivial) {
             apply_broadcast(buffers, params, mutable_data, size, shape, i_seq, vi_seq, bi_seq);
-        else
+        } else {
             apply_trivial(buffers, params, mutable_data, size, i_seq, vi_seq, bi_seq);
+        }
 
         return std::move(result);
     }
 
     template <size_t... Index, size_t... VIndex, size_t... BIndex>
     void apply_trivial(std::array<buffer_info, NVectorized> &buffers,
                        std::array<void *, N> &params,
                        Return *out,
                        size_t size,
-                       index_sequence<Index...>, index_sequence<VIndex...>, index_sequence<BIndex...>) {
+                       index_sequence<Index...>,
+                       index_sequence<VIndex...>,
+                       index_sequence<BIndex...>) {
 
         // Initialize an array of mutable byte references and sizes with references set to the
         // appropriate pointer in `params`; as we iterate, we'll increment each pointer by its size
         // (except for singletons, which get an increment of 0).
-        std::array<std::pair<unsigned char *&, const size_t>, NVectorized> vecparams{{
-            std::pair<unsigned char *&, const size_t>(
-                    reinterpret_cast<unsigned char *&>(params[VIndex] = buffers[BIndex].ptr),
-                    buffers[BIndex].size == 1 ? 0 : sizeof(param_n_t<VIndex>)
-            )...
-        }};
+        std::array<std::pair<unsigned char *&, const size_t>, NVectorized> vecparams{
+            {std::pair<unsigned char *&, const size_t>(
+                reinterpret_cast<unsigned char *&>(params[VIndex] = buffers[BIndex].ptr),
+                buffers[BIndex].size == 1 ? 0 : sizeof(param_n_t<VIndex>))...}};
 
         for (size_t i = 0; i < size; ++i) {
-            returned_array::call(out, i, f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...);
-            for (auto &x : vecparams) x.first += x.second;
+            returned_array::call(
+                out, i, f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...);
+            for (auto &x : vecparams) {
+                x.first += x.second;
+            }
         }
     }
 
     template <size_t... Index, size_t... VIndex, size_t... BIndex>
     void apply_broadcast(std::array<buffer_info, NVectorized> &buffers,
                          std::array<void *, N> &params,
                          Return *out,
                          size_t size,
                          const std::vector<ssize_t> &output_shape,
-                         index_sequence<Index...>, index_sequence<VIndex...>, index_sequence<BIndex...>) {
+                         index_sequence<Index...>,
+                         index_sequence<VIndex...>,
+                         index_sequence<BIndex...>) {
 
         multi_array_iterator<NVectorized> input_iter(buffers, output_shape);
 
         for (size_t i = 0; i < size; ++i, ++input_iter) {
-            PYBIND11_EXPAND_SIDE_EFFECTS((
-                params[VIndex] = input_iter.template data<BIndex>()
-            ));
-            returned_array::call(out, i, f, *reinterpret_cast<param_n_t<Index> *>(std::get<Index>(params))...);
+            PYBIND11_EXPAND_SIDE_EFFECTS((params[VIndex] = input_iter.template data<BIndex>()));
+            returned_array::call(
+                out, i, f, *reinterpret_cast<param_n_t<Index> *>(std::get<Index>(params))...);
         }
     }
 };
 
 template <typename Func, typename Return, typename... Args>
-vectorize_helper<Func, Return, Args...>
-vectorize_extractor(const Func &f, Return (*) (Args ...)) {
+vectorize_helper<Func, Return, Args...> vectorize_extractor(const Func &f, Return (*)(Args...)) {
     return detail::vectorize_helper<Func, Return, Args...>(f);
 }
 
-template <typename T, int Flags> struct handle_type_name<array_t<T, Flags>> {
-    static constexpr auto name = _("numpy.ndarray[") + npy_format_descriptor<T>::name + _("]");
+template <typename T, int Flags>
+struct handle_type_name<array_t<T, Flags>> {
+    static constexpr auto name
+        = const_name("numpy.ndarray[") + npy_format_descriptor<T>::name + const_name("]");
 };
 
 PYBIND11_NAMESPACE_END(detail)
 
 // Vanilla pointer vectorizer:
 template <typename Return, typename... Args>
-detail::vectorize_helper<Return (*)(Args...), Return, Args...>
-vectorize(Return (*f) (Args ...)) {
+detail::vectorize_helper<Return (*)(Args...), Return, Args...> vectorize(Return (*f)(Args...)) {
     return detail::vectorize_helper<Return (*)(Args...), Return, Args...>(f);
 }
 
 // lambda vectorizer:
 template <typename Func, detail::enable_if_t<detail::is_lambda<Func>::value, int> = 0>
-auto vectorize(Func &&f) -> decltype(
-        detail::vectorize_extractor(std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr)) {
-    return detail::vectorize_extractor(std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr);
+auto vectorize(Func &&f)
+    -> decltype(detail::vectorize_extractor(std::forward<Func>(f),
+                                            (detail::function_signature_t<Func> *) nullptr)) {
+    return detail::vectorize_extractor(std::forward<Func>(f),
+                                       (detail::function_signature_t<Func> *) nullptr);
 }
 
 // Vectorize a class method (non-const):
-template <typename Return, typename Class, typename... Args,
-          typename Helper = detail::vectorize_helper<decltype(std::mem_fn(std::declval<Return (Class::*)(Args...)>())), Return, Class *, Args...>>
+template <typename Return,
+          typename Class,
+          typename... Args,
+          typename Helper = detail::vectorize_helper<
+              decltype(std::mem_fn(std::declval<Return (Class::*)(Args...)>())),
+              Return,
+              Class *,
+              Args...>>
 Helper vectorize(Return (Class::*f)(Args...)) {
     return Helper(std::mem_fn(f));
 }
 
 // Vectorize a class method (const):
-template <typename Return, typename Class, typename... Args,
-          typename Helper = detail::vectorize_helper<decltype(std::mem_fn(std::declval<Return (Class::*)(Args...) const>())), Return, const Class *, Args...>>
+template <typename Return,
+          typename Class,
+          typename... Args,
+          typename Helper = detail::vectorize_helper<
+              decltype(std::mem_fn(std::declval<Return (Class::*)(Args...) const>())),
+              Return,
+              const Class *,
+              Args...>>
 Helper vectorize(Return (Class::*f)(Args...) const) {
     return Helper(std::mem_fn(f));
 }
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#pragma warning(pop)
-#endif
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/operators.h` & `HepMC3-3.2.6/python/include/pybind11/operators.h`

 * *Files 8% similar despite different names*

```diff
@@ -7,167 +7,214 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
 
-#if defined(__clang__) && !defined(__INTEL_COMPILER)
-#  pragma clang diagnostic ignored "-Wunsequenced" // multiple unsequenced modifications to 'self' (when using def(py::self OP Type()))
-#elif defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 /// Enumeration with all supported operator types
 enum op_id : int {
-    op_add, op_sub, op_mul, op_div, op_mod, op_divmod, op_pow, op_lshift,
-    op_rshift, op_and, op_xor, op_or, op_neg, op_pos, op_abs, op_invert,
-    op_int, op_long, op_float, op_str, op_cmp, op_gt, op_ge, op_lt, op_le,
-    op_eq, op_ne, op_iadd, op_isub, op_imul, op_idiv, op_imod, op_ilshift,
-    op_irshift, op_iand, op_ixor, op_ior, op_complex, op_bool, op_nonzero,
-    op_repr, op_truediv, op_itruediv, op_hash
+    op_add,
+    op_sub,
+    op_mul,
+    op_div,
+    op_mod,
+    op_divmod,
+    op_pow,
+    op_lshift,
+    op_rshift,
+    op_and,
+    op_xor,
+    op_or,
+    op_neg,
+    op_pos,
+    op_abs,
+    op_invert,
+    op_int,
+    op_long,
+    op_float,
+    op_str,
+    op_cmp,
+    op_gt,
+    op_ge,
+    op_lt,
+    op_le,
+    op_eq,
+    op_ne,
+    op_iadd,
+    op_isub,
+    op_imul,
+    op_idiv,
+    op_imod,
+    op_ilshift,
+    op_irshift,
+    op_iand,
+    op_ixor,
+    op_ior,
+    op_complex,
+    op_bool,
+    op_nonzero,
+    op_repr,
+    op_truediv,
+    op_itruediv,
+    op_hash
 };
 
 enum op_type : int {
     op_l, /* base type on left */
     op_r, /* base type on right */
     op_u  /* unary operator */
 };
 
-struct self_t { };
+struct self_t {};
 static const self_t self = self_t();
 
 /// Type for an unused type slot
-struct undefined_t { };
+struct undefined_t {};
 
 /// Don't warn about an unused variable
 inline self_t __self() { return self; }
 
 /// base template of operator implementations
-template <op_id, op_type, typename B, typename L, typename R> struct op_impl { };
+template <op_id, op_type, typename B, typename L, typename R>
+struct op_impl {};
 
 /// Operator implementation generator
-template <op_id id, op_type ot, typename L, typename R> struct op_ {
-    template <typename Class, typename... Extra> void execute(Class &cl, const Extra&... extra) const {
+template <op_id id, op_type ot, typename L, typename R>
+struct op_ {
+    template <typename Class, typename... Extra>
+    void execute(Class &cl, const Extra &...extra) const {
         using Base = typename Class::type;
         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
         using op = op_impl<id, ot, Base, L_type, R_type>;
         cl.def(op::name(), &op::execute, is_operator(), extra...);
-        #if PY_MAJOR_VERSION < 3
-        if (id == op_truediv || id == op_itruediv)
-            cl.def(id == op_itruediv ? "__idiv__" : ot == op_l ? "__div__" : "__rdiv__",
-                    &op::execute, is_operator(), extra...);
-        #endif
+#if PY_MAJOR_VERSION < 3
+        if (PYBIND11_SILENCE_MSVC_C4127(id == op_truediv)
+            || PYBIND11_SILENCE_MSVC_C4127(id == op_itruediv))
+            cl.def(id == op_itruediv ? "__idiv__"
+                   : ot == op_l      ? "__div__"
+                                     : "__rdiv__",
+                   &op::execute,
+                   is_operator(),
+                   extra...);
+#endif
     }
-    template <typename Class, typename... Extra> void execute_cast(Class &cl, const Extra&... extra) const {
+    template <typename Class, typename... Extra>
+    void execute_cast(Class &cl, const Extra &...extra) const {
         using Base = typename Class::type;
         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
         using op = op_impl<id, ot, Base, L_type, R_type>;
         cl.def(op::name(), &op::execute_cast, is_operator(), extra...);
-        #if PY_MAJOR_VERSION < 3
+#if PY_MAJOR_VERSION < 3
         if (id == op_truediv || id == op_itruediv)
-            cl.def(id == op_itruediv ? "__idiv__" : ot == op_l ? "__div__" : "__rdiv__",
-                    &op::execute, is_operator(), extra...);
-        #endif
+            cl.def(id == op_itruediv ? "__idiv__"
+                   : ot == op_l      ? "__div__"
+                                     : "__rdiv__",
+                   &op::execute,
+                   is_operator(),
+                   extra...);
+#endif
     }
 };
 
-#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                    \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }   \
-    static B execute_cast(const L &l, const R &r) { return B(expr); }                  \
-};                                                                                     \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_r, B, L, R> { \
-    static char const* name() { return "__" #rid "__"; }                               \
-    static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }   \
-    static B execute_cast(const R &r, const L &l) { return B(expr); }                  \
-};                                                                                     \
-inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {         \
-    return op_<op_##id, op_l, self_t, self_t>();                                       \
-}                                                                                      \
-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \
-    return op_<op_##id, op_l, self_t, T>();                                            \
-}                                                                                      \
-template <typename T> op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {    \
-    return op_<op_##id, op_r, T, self_t>();                                            \
-}
-
-#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                        \
-template <typename B, typename L, typename R> struct op_impl<op_##id, op_l, B, L, R> { \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }           \
-    static B execute_cast(L &l, const R &r) { return B(expr); }                        \
-};                                                                                     \
-template <typename T> op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {    \
-    return op_<op_##id, op_l, self_t, T>();                                            \
-}
-
-#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                          \
-template <typename B, typename L> struct op_impl<op_##id, op_u, B, L, undefined_t> {   \
-    static char const* name() { return "__" #id "__"; }                                \
-    static auto execute(const L &l) -> decltype(expr) { return expr; }                 \
-    static B execute_cast(const L &l) { return B(expr); }                              \
-};                                                                                     \
-inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                    \
-    return op_<op_##id, op_u, self_t, undefined_t>();                                  \
-}
-
-PYBIND11_BINARY_OPERATOR(sub,       rsub,         operator-,    l - r)
-PYBIND11_BINARY_OPERATOR(add,       radd,         operator+,    l + r)
-PYBIND11_BINARY_OPERATOR(mul,       rmul,         operator*,    l * r)
-PYBIND11_BINARY_OPERATOR(truediv,   rtruediv,     operator/,    l / r)
-PYBIND11_BINARY_OPERATOR(mod,       rmod,         operator%,    l % r)
-PYBIND11_BINARY_OPERATOR(lshift,    rlshift,      operator<<,   l << r)
-PYBIND11_BINARY_OPERATOR(rshift,    rrshift,      operator>>,   l >> r)
-PYBIND11_BINARY_OPERATOR(and,       rand,         operator&,    l & r)
-PYBIND11_BINARY_OPERATOR(xor,       rxor,         operator^,    l ^ r)
-PYBIND11_BINARY_OPERATOR(eq,        eq,           operator==,   l == r)
-PYBIND11_BINARY_OPERATOR(ne,        ne,           operator!=,   l != r)
-PYBIND11_BINARY_OPERATOR(or,        ror,          operator|,    l | r)
-PYBIND11_BINARY_OPERATOR(gt,        lt,           operator>,    l > r)
-PYBIND11_BINARY_OPERATOR(ge,        le,           operator>=,   l >= r)
-PYBIND11_BINARY_OPERATOR(lt,        gt,           operator<,    l < r)
-PYBIND11_BINARY_OPERATOR(le,        ge,           operator<=,   l <= r)
-//PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))
-PYBIND11_INPLACE_OPERATOR(iadd,     operator+=,   l += r)
-PYBIND11_INPLACE_OPERATOR(isub,     operator-=,   l -= r)
-PYBIND11_INPLACE_OPERATOR(imul,     operator*=,   l *= r)
-PYBIND11_INPLACE_OPERATOR(itruediv, operator/=,   l /= r)
-PYBIND11_INPLACE_OPERATOR(imod,     operator%=,   l %= r)
-PYBIND11_INPLACE_OPERATOR(ilshift,  operator<<=,  l <<= r)
-PYBIND11_INPLACE_OPERATOR(irshift,  operator>>=,  l >>= r)
-PYBIND11_INPLACE_OPERATOR(iand,     operator&=,   l &= r)
-PYBIND11_INPLACE_OPERATOR(ixor,     operator^=,   l ^= r)
-PYBIND11_INPLACE_OPERATOR(ior,      operator|=,   l |= r)
-PYBIND11_UNARY_OPERATOR(neg,        operator-,    -l)
-PYBIND11_UNARY_OPERATOR(pos,        operator+,    +l)
+#define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                               \
+    template <typename B, typename L, typename R>                                                 \
+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \
+        static char const *name() { return "__" #id "__"; }                                       \
+        static auto execute(const L &l, const R &r) -> decltype(expr) { return (expr); }          \
+        static B execute_cast(const L &l, const R &r) { return B(expr); }                         \
+    };                                                                                            \
+    template <typename B, typename L, typename R>                                                 \
+    struct op_impl<op_##id, op_r, B, L, R> {                                                      \
+        static char const *name() { return "__" #rid "__"; }                                      \
+        static auto execute(const R &r, const L &l) -> decltype(expr) { return (expr); }          \
+        static B execute_cast(const R &r, const L &l) { return B(expr); }                         \
+    };                                                                                            \
+    inline op_<op_##id, op_l, self_t, self_t> op(const self_t &, const self_t &) {                \
+        return op_<op_##id, op_l, self_t, self_t>();                                              \
+    }                                                                                             \
+    template <typename T>                                                                         \
+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \
+        return op_<op_##id, op_l, self_t, T>();                                                   \
+    }                                                                                             \
+    template <typename T>                                                                         \
+    op_<op_##id, op_r, T, self_t> op(const T &, const self_t &) {                                 \
+        return op_<op_##id, op_r, T, self_t>();                                                   \
+    }
+
+#define PYBIND11_INPLACE_OPERATOR(id, op, expr)                                                   \
+    template <typename B, typename L, typename R>                                                 \
+    struct op_impl<op_##id, op_l, B, L, R> {                                                      \
+        static char const *name() { return "__" #id "__"; }                                       \
+        static auto execute(L &l, const R &r) -> decltype(expr) { return expr; }                  \
+        static B execute_cast(L &l, const R &r) { return B(expr); }                               \
+    };                                                                                            \
+    template <typename T>                                                                         \
+    op_<op_##id, op_l, self_t, T> op(const self_t &, const T &) {                                 \
+        return op_<op_##id, op_l, self_t, T>();                                                   \
+    }
+
+#define PYBIND11_UNARY_OPERATOR(id, op, expr)                                                     \
+    template <typename B, typename L>                                                             \
+    struct op_impl<op_##id, op_u, B, L, undefined_t> {                                            \
+        static char const *name() { return "__" #id "__"; }                                       \
+        static auto execute(const L &l) -> decltype(expr) { return expr; }                        \
+        static B execute_cast(const L &l) { return B(expr); }                                     \
+    };                                                                                            \
+    inline op_<op_##id, op_u, self_t, undefined_t> op(const self_t &) {                           \
+        return op_<op_##id, op_u, self_t, undefined_t>();                                         \
+    }
+
+PYBIND11_BINARY_OPERATOR(sub, rsub, operator-, l - r)
+PYBIND11_BINARY_OPERATOR(add, radd, operator+, l + r)
+PYBIND11_BINARY_OPERATOR(mul, rmul, operator*, l *r)
+PYBIND11_BINARY_OPERATOR(truediv, rtruediv, operator/, l / r)
+PYBIND11_BINARY_OPERATOR(mod, rmod, operator%, l % r)
+PYBIND11_BINARY_OPERATOR(lshift, rlshift, operator<<, l << r)
+PYBIND11_BINARY_OPERATOR(rshift, rrshift, operator>>, l >> r)
+PYBIND11_BINARY_OPERATOR(and, rand, operator&, l &r)
+PYBIND11_BINARY_OPERATOR(xor, rxor, operator^, l ^ r)
+PYBIND11_BINARY_OPERATOR(eq, eq, operator==, l == r)
+PYBIND11_BINARY_OPERATOR(ne, ne, operator!=, l != r)
+PYBIND11_BINARY_OPERATOR(or, ror, operator|, l | r)
+PYBIND11_BINARY_OPERATOR(gt, lt, operator>, l > r)
+PYBIND11_BINARY_OPERATOR(ge, le, operator>=, l >= r)
+PYBIND11_BINARY_OPERATOR(lt, gt, operator<, l < r)
+PYBIND11_BINARY_OPERATOR(le, ge, operator<=, l <= r)
+// PYBIND11_BINARY_OPERATOR(pow,       rpow,         pow,          std::pow(l,  r))
+PYBIND11_INPLACE_OPERATOR(iadd, operator+=, l += r)
+PYBIND11_INPLACE_OPERATOR(isub, operator-=, l -= r)
+PYBIND11_INPLACE_OPERATOR(imul, operator*=, l *= r)
+PYBIND11_INPLACE_OPERATOR(itruediv, operator/=, l /= r)
+PYBIND11_INPLACE_OPERATOR(imod, operator%=, l %= r)
+PYBIND11_INPLACE_OPERATOR(ilshift, operator<<=, l <<= r)
+PYBIND11_INPLACE_OPERATOR(irshift, operator>>=, l >>= r)
+PYBIND11_INPLACE_OPERATOR(iand, operator&=, l &= r)
+PYBIND11_INPLACE_OPERATOR(ixor, operator^=, l ^= r)
+PYBIND11_INPLACE_OPERATOR(ior, operator|=, l |= r)
+PYBIND11_UNARY_OPERATOR(neg, operator-, -l)
+PYBIND11_UNARY_OPERATOR(pos, operator+, +l)
 // WARNING: This usage of `abs` should only be done for existing STL overloads.
 // Adding overloads directly in to the `std::` namespace is advised against:
 // https://en.cppreference.com/w/cpp/language/extending_std
-PYBIND11_UNARY_OPERATOR(abs,        abs,          std::abs(l))
-PYBIND11_UNARY_OPERATOR(hash,       hash,         std::hash<L>()(l))
-PYBIND11_UNARY_OPERATOR(invert,     operator~,    (~l))
-PYBIND11_UNARY_OPERATOR(bool,       operator!,    !!l)
-PYBIND11_UNARY_OPERATOR(int,        int_,         (int) l)
-PYBIND11_UNARY_OPERATOR(float,      float_,       (double) l)
+PYBIND11_UNARY_OPERATOR(abs, abs, std::abs(l))
+PYBIND11_UNARY_OPERATOR(hash, hash, std::hash<L>()(l))
+PYBIND11_UNARY_OPERATOR(invert, operator~, (~l))
+PYBIND11_UNARY_OPERATOR(bool, operator!, !!l)
+PYBIND11_UNARY_OPERATOR(int, int_, (int) l)
+PYBIND11_UNARY_OPERATOR(float, float_, (double) l)
 
 #undef PYBIND11_BINARY_OPERATOR
 #undef PYBIND11_INPLACE_OPERATOR
 #undef PYBIND11_UNARY_OPERATOR
 PYBIND11_NAMESPACE_END(detail)
 
 using detail::self;
 // Add named operators so that they are accessible via `py::`.
 using detail::hash;
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#  pragma warning(pop)
-#endif
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/options.h` & `HepMC3-3.2.6/python/include/pybind11/options.h`

 * *Files 10% similar despite different names*

```diff
@@ -11,51 +11,62 @@
 
 #include "detail/common.h"
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 class options {
 public:
-
     // Default RAII constructor, which leaves settings as they currently are.
     options() : previous_state(global_state()) {}
 
     // Class is non-copyable.
-    options(const options&) = delete;
-    options& operator=(const options&) = delete;
+    options(const options &) = delete;
+    options &operator=(const options &) = delete;
 
     // Destructor, which restores settings that were in effect before.
-    ~options() {
-        global_state() = previous_state;
-    }
+    ~options() { global_state() = previous_state; }
 
     // Setter methods (affect the global state):
 
-    options& disable_user_defined_docstrings() & { global_state().show_user_defined_docstrings = false; return *this; }
+    options &disable_user_defined_docstrings() & {
+        global_state().show_user_defined_docstrings = false;
+        return *this;
+    }
 
-    options& enable_user_defined_docstrings() & { global_state().show_user_defined_docstrings = true; return *this; }
+    options &enable_user_defined_docstrings() & {
+        global_state().show_user_defined_docstrings = true;
+        return *this;
+    }
 
-    options& disable_function_signatures() & { global_state().show_function_signatures = false; return *this; }
+    options &disable_function_signatures() & {
+        global_state().show_function_signatures = false;
+        return *this;
+    }
 
-    options& enable_function_signatures() & { global_state().show_function_signatures = true; return *this; }
+    options &enable_function_signatures() & {
+        global_state().show_function_signatures = true;
+        return *this;
+    }
 
     // Getter methods (return the global state):
 
-    static bool show_user_defined_docstrings() { return global_state().show_user_defined_docstrings; }
+    static bool show_user_defined_docstrings() {
+        return global_state().show_user_defined_docstrings;
+    }
 
     static bool show_function_signatures() { return global_state().show_function_signatures; }
 
     // This type is not meant to be allocated on the heap.
-    void* operator new(size_t) = delete;
+    void *operator new(size_t) = delete;
 
 private:
-
     struct state {
-        bool show_user_defined_docstrings = true;  //< Include user-supplied texts in docstrings.
-        bool show_function_signatures = true;      //< Include auto-generated function signatures in docstrings.
+        bool show_user_defined_docstrings = true; //< Include user-supplied texts in docstrings.
+        bool show_function_signatures = true;     //< Include auto-generated function signatures
+                                                  //  in docstrings.
     };
 
     static state &global_state() {
         static state instance;
         return instance;
     }
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/pybind11.h` & `HepMC3-3.2.6/python/include/pybind11/pybind11.h`

 * *Files 3% similar despite different names*

```diff
@@ -6,404 +6,557 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
-#if defined(__INTEL_COMPILER)
-#  pragma warning push
-#  pragma warning disable 68    // integer conversion resulted in a change of sign
-#  pragma warning disable 186   // pointless comparison of unsigned integer with zero
-#  pragma warning disable 878   // incompatible exception specifications
-#  pragma warning disable 1334  // the "template" keyword used for syntactic disambiguation may only be used within a template
-#  pragma warning disable 1682  // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
-#  pragma warning disable 1786  // function "strdup" was declared deprecated
-#  pragma warning disable 1875  // offsetof applied to non-POD (Plain Old Data) types is nonstandard
-#  pragma warning disable 2196  // warning #2196: routine is both "inline" and "noinline"
-#elif defined(_MSC_VER)
-#  pragma warning(push)
-#  pragma warning(disable: 4100) // warning C4100: Unreferenced formal parameter
-#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#  pragma warning(disable: 4512) // warning C4512: Assignment operator was implicitly defined as deleted
-#  pragma warning(disable: 4800) // warning C4800: 'int': forcing value to bool 'true' or 'false' (performance warning)
-#  pragma warning(disable: 4996) // warning C4996: The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name
-#  pragma warning(disable: 4702) // warning C4702: unreachable code
-#  pragma warning(disable: 4522) // warning C4522: multiple assignment operators specified
-#  pragma warning(disable: 4505) // warning C4505: 'PySlice_GetIndicesEx': unreferenced local function has been removed (PyPy only)
-#elif defined(__GNUG__) && !defined(__clang__)
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wunused-but-set-parameter"
-#  pragma GCC diagnostic ignored "-Wunused-but-set-variable"
-#  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
-#  pragma GCC diagnostic ignored "-Wstrict-aliasing"
-#  pragma GCC diagnostic ignored "-Wattributes"
-#  if __GNUC__ >= 7
-#    pragma GCC diagnostic ignored "-Wnoexcept-type"
-#  endif
-#endif
-
-#include "attr.h"
-#include "options.h"
 #include "detail/class.h"
 #include "detail/init.h"
+#include "attr.h"
+#include "gil.h"
+#include "options.h"
 
+#include <cstdlib>
+#include <cstring>
 #include <memory>
-#include <vector>
+#include <new>
 #include <string>
 #include <utility>
+#include <vector>
 
+#if defined(__cpp_lib_launder) && !(defined(_MSC_VER) && (_MSC_VER < 1914))
+#    define PYBIND11_STD_LAUNDER std::launder
+#    define PYBIND11_HAS_STD_LAUNDER 1
+#else
+#    define PYBIND11_STD_LAUNDER
+#    define PYBIND11_HAS_STD_LAUNDER 0
+#endif
 #if defined(__GNUG__) && !defined(__clang__)
-#  include <cxxabi.h>
+#    include <cxxabi.h>
+#endif
+
+/* https://stackoverflow.com/questions/46798456/handling-gccs-noexcept-type-warning
+   This warning is about ABI compatibility, not code health.
+   It is only actually needed in a couple places, but apparently GCC 7 "generates this warning if
+   and only if the first template instantiation ... involves noexcept" [stackoverflow], therefore
+   it could get triggered from seemingly random places, depending on user code.
+   No other GCC version generates this warning.
+ */
+#if defined(__GNUC__) && __GNUC__ == 7
+#    pragma GCC diagnostic push
+#    pragma GCC diagnostic ignored "-Wnoexcept-type"
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+// Apply all the extensions translators from a list
+// Return true if one of the translators completed without raising an exception
+// itself. Return of false indicates that if there are other translators
+// available, they should be tried.
+inline bool apply_exception_translators(std::forward_list<ExceptionTranslator> &translators) {
+    auto last_exception = std::current_exception();
+
+    for (auto &translator : translators) {
+        try {
+            translator(last_exception);
+            return true;
+        } catch (...) {
+            last_exception = std::current_exception();
+        }
+    }
+    return false;
+}
+
+#if defined(_MSC_VER)
+#    define PYBIND11_COMPAT_STRDUP _strdup
+#else
+#    define PYBIND11_COMPAT_STRDUP strdup
+#endif
+
+PYBIND11_NAMESPACE_END(detail)
+
 /// Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object
 class cpp_function : public function {
 public:
     cpp_function() = default;
-    cpp_function(std::nullptr_t) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(std::nullptr_t) {}
 
     /// Construct a cpp_function from a vanilla function pointer
     template <typename Return, typename... Args, typename... Extra>
-    cpp_function(Return (*f)(Args...), const Extra&... extra) {
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (*f)(Args...), const Extra &...extra) {
         initialize(f, f, extra...);
     }
 
     /// Construct a cpp_function from a lambda function (possibly with internal state)
-    template <typename Func, typename... Extra,
+    template <typename Func,
+              typename... Extra,
               typename = detail::enable_if_t<detail::is_lambda<Func>::value>>
-    cpp_function(Func &&f, const Extra&... extra) {
-        initialize(std::forward<Func>(f),
-                   (detail::function_signature_t<Func> *) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Func &&f, const Extra &...extra) {
+        initialize(
+            std::forward<Func>(f), (detail::function_signature_t<Func> *) nullptr, extra...);
     }
 
     /// Construct a cpp_function from a class method (non-const, no ref-qualifier)
     template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...), const Extra&... extra) {
-        initialize([f](Class *c, Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
-                   (Return (*) (Class *, Arg...)) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...), const Extra &...extra) {
+        initialize(
+            [f](Class *c, Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+            (Return(*)(Class *, Arg...)) nullptr,
+            extra...);
     }
 
     /// Construct a cpp_function from a class method (non-const, lvalue ref-qualifier)
     /// A copy of the overload for non-const functions without explicit ref-qualifier
     /// but with an added `&`.
     template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...)&, const Extra&... extra) {
-        initialize([f](Class *c, Arg... args) -> Return { return (c->*f)(args...); },
-                   (Return (*) (Class *, Arg...)) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...) &, const Extra &...extra) {
+        initialize(
+            [f](Class *c, Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+            (Return(*)(Class *, Arg...)) nullptr,
+            extra...);
     }
 
     /// Construct a cpp_function from a class method (const, no ref-qualifier)
     template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...) const, const Extra&... extra) {
-        initialize([f](const Class *c, Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
-                   (Return (*)(const Class *, Arg ...)) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...) const, const Extra &...extra) {
+        initialize([f](const Class *c,
+                       Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+                   (Return(*)(const Class *, Arg...)) nullptr,
+                   extra...);
     }
 
     /// Construct a cpp_function from a class method (const, lvalue ref-qualifier)
     /// A copy of the overload for const functions without explicit ref-qualifier
     /// but with an added `&`.
     template <typename Return, typename Class, typename... Arg, typename... Extra>
-    cpp_function(Return (Class::*f)(Arg...) const&, const Extra&... extra) {
-        initialize([f](const Class *c, Arg... args) -> Return { return (c->*f)(args...); },
-                   (Return (*)(const Class *, Arg ...)) nullptr, extra...);
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    cpp_function(Return (Class::*f)(Arg...) const &, const Extra &...extra) {
+        initialize([f](const Class *c,
+                       Arg... args) -> Return { return (c->*f)(std::forward<Arg>(args)...); },
+                   (Return(*)(const Class *, Arg...)) nullptr,
+                   extra...);
     }
 
     /// Return the function name
     object name() const { return attr("__name__"); }
 
 protected:
+    struct InitializingFunctionRecordDeleter {
+        // `destruct(function_record, false)`: `initialize_generic` copies strings and
+        // takes care of cleaning up in case of exceptions. So pass `false` to `free_strings`.
+        void operator()(detail::function_record *rec) { destruct(rec, false); }
+    };
+    using unique_function_record
+        = std::unique_ptr<detail::function_record, InitializingFunctionRecordDeleter>;
+
     /// Space optimization: don't inline this frequently instantiated fragment
-    PYBIND11_NOINLINE detail::function_record *make_function_record() {
-        return new detail::function_record();
+    PYBIND11_NOINLINE unique_function_record make_function_record() {
+        return unique_function_record(new detail::function_record());
     }
 
     /// Special internal constructor for functors, lambda functions, etc.
     template <typename Func, typename Return, typename... Args, typename... Extra>
-    void initialize(Func &&f, Return (*)(Args...), const Extra&... extra) {
+    void initialize(Func &&f, Return (*)(Args...), const Extra &...extra) {
         using namespace detail;
-        struct capture { remove_reference_t<Func> f; };
+        struct capture {
+            remove_reference_t<Func> f;
+        };
 
-        /* Store the function including any extra state it might have (e.g. a lambda capture object) */
-        auto rec = make_function_record();
+        /* Store the function including any extra state it might have (e.g. a lambda capture
+         * object) */
+        // The unique_ptr makes sure nothing is leaked in case of an exception.
+        auto unique_rec = make_function_record();
+        auto *rec = unique_rec.get();
 
         /* Store the capture object directly in the function record if there is enough space */
-        if (sizeof(capture) <= sizeof(rec->data)) {
+        if (PYBIND11_SILENCE_MSVC_C4127(sizeof(capture) <= sizeof(rec->data))) {
             /* Without these pragmas, GCC warns that there might not be
                enough space to use the placement new operator. However, the
                'if' statement above ensures that this is the case. */
-#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wplacement-new"
-#endif
-            new ((capture *) &rec->data) capture { std::forward<Func>(f) };
-#if defined(__GNUG__) && !defined(__clang__) && __GNUC__ >= 6
-#  pragma GCC diagnostic pop
+#if defined(__GNUG__) && __GNUC__ >= 6 && !defined(__clang__) && !defined(__INTEL_COMPILER)
+#    pragma GCC diagnostic push
+#    pragma GCC diagnostic ignored "-Wplacement-new"
+#endif
+            new ((capture *) &rec->data) capture{std::forward<Func>(f)};
+#if defined(__GNUG__) && __GNUC__ >= 6 && !defined(__clang__) && !defined(__INTEL_COMPILER)
+#    pragma GCC diagnostic pop
+#endif
+#if defined(__GNUG__) && !PYBIND11_HAS_STD_LAUNDER && !defined(__INTEL_COMPILER)
+#    pragma GCC diagnostic push
+#    pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#endif
+            // UB without std::launder, but without breaking ABI and/or
+            // a significant refactoring it's "impossible" to solve.
+            if (!std::is_trivially_destructible<capture>::value) {
+                rec->free_data = [](function_record *r) {
+                    auto data = PYBIND11_STD_LAUNDER((capture *) &r->data);
+                    (void) data;
+                    data->~capture();
+                };
+            }
+#if defined(__GNUG__) && !PYBIND11_HAS_STD_LAUNDER && !defined(__INTEL_COMPILER)
+#    pragma GCC diagnostic pop
 #endif
-            if (!std::is_trivially_destructible<Func>::value)
-                rec->free_data = [](function_record *r) { ((capture *) &r->data)->~capture(); };
         } else {
-            rec->data[0] = new capture { std::forward<Func>(f) };
+            rec->data[0] = new capture{std::forward<Func>(f)};
             rec->free_data = [](function_record *r) { delete ((capture *) r->data[0]); };
         }
 
         /* Type casters for the function arguments and return value */
         using cast_in = argument_loader<Args...>;
-        using cast_out = make_caster<
-            conditional_t<std::is_void<Return>::value, void_type, Return>
-        >;
+        using cast_out
+            = make_caster<conditional_t<std::is_void<Return>::value, void_type, Return>>;
 
-        static_assert(expected_num_args<Extra...>(sizeof...(Args), cast_in::has_args, cast_in::has_kwargs),
-                      "The number of argument annotations does not match the number of function arguments");
+        static_assert(
+            expected_num_args<Extra...>(
+                sizeof...(Args), cast_in::args_pos >= 0, cast_in::has_kwargs),
+            "The number of argument annotations does not match the number of function arguments");
 
         /* Dispatch code which converts function arguments and performs the actual function call */
         rec->impl = [](function_call &call) -> handle {
             cast_in args_converter;
 
             /* Try to cast the function arguments into the C++ domain */
-            if (!args_converter.load_args(call))
+            if (!args_converter.load_args(call)) {
                 return PYBIND11_TRY_NEXT_OVERLOAD;
+            }
 
             /* Invoke call policy pre-call hook */
             process_attributes<Extra...>::precall(call);
 
             /* Get a pointer to the capture object */
-            auto data = (sizeof(capture) <= sizeof(call.func.data)
-                         ? &call.func.data : call.func.data[0]);
+            const auto *data = (sizeof(capture) <= sizeof(call.func.data) ? &call.func.data
+                                                                          : call.func.data[0]);
             auto *cap = const_cast<capture *>(reinterpret_cast<const capture *>(data));
 
             /* Override policy for rvalues -- usually to enforce rvp::move on an rvalue */
-            return_value_policy policy = return_value_policy_override<Return>::policy(call.func.policy);
+            return_value_policy policy
+                = return_value_policy_override<Return>::policy(call.func.policy);
 
             /* Function scope guard -- defaults to the compile-to-nothing `void_type` */
             using Guard = extract_guard_t<Extra...>;
 
             /* Perform the function call */
-            handle result = cast_out::cast(
-                std::move(args_converter).template call<Return, Guard>(cap->f), policy, call.parent);
+            handle result
+                = cast_out::cast(std::move(args_converter).template call<Return, Guard>(cap->f),
+                                 policy,
+                                 call.parent);
 
             /* Invoke call policy post-call hook */
             process_attributes<Extra...>::postcall(call, result);
 
             return result;
         };
 
+        rec->nargs_pos = cast_in::args_pos >= 0
+                             ? static_cast<std::uint16_t>(cast_in::args_pos)
+                             : sizeof...(Args) - cast_in::has_kwargs; // Will get reduced more if
+                                                                      // we have a kw_only
+        rec->has_args = cast_in::args_pos >= 0;
+        rec->has_kwargs = cast_in::has_kwargs;
+
         /* Process any user-provided function attributes */
         process_attributes<Extra...>::init(extra..., rec);
 
         {
             constexpr bool has_kw_only_args = any_of<std::is_same<kw_only, Extra>...>::value,
                            has_pos_only_args = any_of<std::is_same<pos_only, Extra>...>::value,
-                           has_args = any_of<std::is_same<args, Args>...>::value,
                            has_arg_annotations = any_of<is_keyword<Extra>...>::value;
-            static_assert(has_arg_annotations || !has_kw_only_args, "py::kw_only requires the use of argument annotations");
-            static_assert(has_arg_annotations || !has_pos_only_args, "py::pos_only requires the use of argument annotations (for docstrings and aligning the annotations to the argument)");
-            static_assert(!(has_args && has_kw_only_args), "py::kw_only cannot be combined with a py::args argument");
-        }
-
-        /* Generate a readable signature describing the function's arguments and return value types */
-        static constexpr auto signature = _("(") + cast_in::arg_names + _(") -> ") + cast_out::name;
+            static_assert(has_arg_annotations || !has_kw_only_args,
+                          "py::kw_only requires the use of argument annotations");
+            static_assert(has_arg_annotations || !has_pos_only_args,
+                          "py::pos_only requires the use of argument annotations (for docstrings "
+                          "and aligning the annotations to the argument)");
+
+            static_assert(constexpr_sum(is_kw_only<Extra>::value...) <= 1,
+                          "py::kw_only may be specified only once");
+            static_assert(constexpr_sum(is_pos_only<Extra>::value...) <= 1,
+                          "py::pos_only may be specified only once");
+            constexpr auto kw_only_pos = constexpr_first<is_kw_only, Extra...>();
+            constexpr auto pos_only_pos = constexpr_first<is_pos_only, Extra...>();
+            static_assert(!(has_kw_only_args && has_pos_only_args) || pos_only_pos < kw_only_pos,
+                          "py::pos_only must come before py::kw_only");
+        }
+
+        /* Generate a readable signature describing the function's arguments and return
+           value types */
+        static constexpr auto signature
+            = const_name("(") + cast_in::arg_names + const_name(") -> ") + cast_out::name;
         PYBIND11_DESCR_CONSTEXPR auto types = decltype(signature)::types();
 
         /* Register the function with Python from generic (non-templated) code */
-        initialize_generic(rec, signature.text, types.data(), sizeof...(Args));
-
-        if (cast_in::has_args) rec->has_args = true;
-        if (cast_in::has_kwargs) rec->has_kwargs = true;
+        // Pass on the ownership over the `unique_rec` to `initialize_generic`. `rec` stays valid.
+        initialize_generic(std::move(unique_rec), signature.text, types.data(), sizeof...(Args));
 
         /* Stash some additional information used by an important optimization in 'functional.h' */
         using FunctionType = Return (*)(Args...);
-        constexpr bool is_function_ptr =
-            std::is_convertible<Func, FunctionType>::value &&
-            sizeof(capture) == sizeof(void *);
+        constexpr bool is_function_ptr
+            = std::is_convertible<Func, FunctionType>::value && sizeof(capture) == sizeof(void *);
         if (is_function_ptr) {
             rec->is_stateless = true;
-            rec->data[1] = const_cast<void *>(reinterpret_cast<const void *>(&typeid(FunctionType)));
+            rec->data[1]
+                = const_cast<void *>(reinterpret_cast<const void *>(&typeid(FunctionType)));
         }
     }
 
+    // Utility class that keeps track of all duplicated strings, and cleans them up in its
+    // destructor, unless they are released. Basically a RAII-solution to deal with exceptions
+    // along the way.
+    class strdup_guard {
+    public:
+        ~strdup_guard() {
+            for (auto *s : strings) {
+                std::free(s);
+            }
+        }
+        char *operator()(const char *s) {
+            auto *t = PYBIND11_COMPAT_STRDUP(s);
+            strings.push_back(t);
+            return t;
+        }
+        void release() { strings.clear(); }
+
+    private:
+        std::vector<char *> strings;
+    };
+
     /// Register a function call with Python (generic non-templated code goes here)
-    void initialize_generic(detail::function_record *rec, const char *text,
-                            const std::type_info *const *types, size_t args) {
+    void initialize_generic(unique_function_record &&unique_rec,
+                            const char *text,
+                            const std::type_info *const *types,
+                            size_t args) {
+        // Do NOT receive `unique_rec` by value. If this function fails to move out the unique_ptr,
+        // we do not want this to destruct the pointer. `initialize` (the caller) still relies on
+        // the pointee being alive after this call. Only move out if a `capsule` is going to keep
+        // it alive.
+        auto *rec = unique_rec.get();
+
+        // Keep track of strdup'ed strings, and clean them up as long as the function's capsule
+        // has not taken ownership yet (when `unique_rec.release()` is called).
+        // Note: This cannot easily be fixed by a `unique_ptr` with custom deleter, because the
+        // strings are only referenced before strdup'ing. So only *after* the following block could
+        // `destruct` safely be called, but even then, `repr` could still throw in the middle of
+        // copying all strings.
+        strdup_guard guarded_strdup;
 
         /* Create copies of all referenced C-style strings */
-        rec->name = strdup(rec->name ? rec->name : "");
-        if (rec->doc) rec->doc = strdup(rec->doc);
-        for (auto &a: rec->args) {
-            if (a.name)
-                a.name = strdup(a.name);
-            if (a.descr)
-                a.descr = strdup(a.descr);
-            else if (a.value)
-                a.descr = strdup(repr(a.value).cast<std::string>().c_str());
+        rec->name = guarded_strdup(rec->name ? rec->name : "");
+        if (rec->doc) {
+            rec->doc = guarded_strdup(rec->doc);
+        }
+        for (auto &a : rec->args) {
+            if (a.name) {
+                a.name = guarded_strdup(a.name);
+            }
+            if (a.descr) {
+                a.descr = guarded_strdup(a.descr);
+            } else if (a.value) {
+                a.descr = guarded_strdup(repr(a.value).cast<std::string>().c_str());
+            }
         }
 
-        rec->is_constructor = !strcmp(rec->name, "__init__") || !strcmp(rec->name, "__setstate__");
+        rec->is_constructor = (std::strcmp(rec->name, "__init__") == 0)
+                              || (std::strcmp(rec->name, "__setstate__") == 0);
 
 #if !defined(NDEBUG) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)
         if (rec->is_constructor && !rec->is_new_style_constructor) {
-            const auto class_name = detail::get_fully_qualified_tp_name((PyTypeObject *) rec->scope.ptr());
+            const auto class_name
+                = detail::get_fully_qualified_tp_name((PyTypeObject *) rec->scope.ptr());
             const auto func_name = std::string(rec->name);
-            PyErr_WarnEx(
-                PyExc_FutureWarning,
-                ("pybind11-bound class '" + class_name + "' is using an old-style "
-                 "placement-new '" + func_name + "' which has been deprecated. See "
-                 "the upgrade guide in pybind11's docs. This message is only visible "
-                 "when compiled in debug mode.").c_str(), 0
-            );
+            PyErr_WarnEx(PyExc_FutureWarning,
+                         ("pybind11-bound class '" + class_name
+                          + "' is using an old-style "
+                            "placement-new '"
+                          + func_name
+                          + "' which has been deprecated. See "
+                            "the upgrade guide in pybind11's docs. This message is only visible "
+                            "when compiled in debug mode.")
+                             .c_str(),
+                         0);
         }
 #endif
 
         /* Generate a proper function signature */
         std::string signature;
         size_t type_index = 0, arg_index = 0;
-        for (auto *pc = text; *pc != '\0'; ++pc) {
+        bool is_starred = false;
+        for (const auto *pc = text; *pc != '\0'; ++pc) {
             const auto c = *pc;
 
             if (c == '{') {
                 // Write arg name for everything except *args and **kwargs.
-                if (*(pc + 1) == '*')
+                is_starred = *(pc + 1) == '*';
+                if (is_starred) {
                     continue;
+                }
                 // Separator for keyword-only arguments, placed before the kw
-                // arguments start
-                if (rec->nargs_kw_only > 0 && arg_index + rec->nargs_kw_only == args)
+                // arguments start (unless we are already putting an *args)
+                if (!rec->has_args && arg_index == rec->nargs_pos) {
                     signature += "*, ";
+                }
                 if (arg_index < rec->args.size() && rec->args[arg_index].name) {
                     signature += rec->args[arg_index].name;
                 } else if (arg_index == 0 && rec->is_method) {
                     signature += "self";
                 } else {
                     signature += "arg" + std::to_string(arg_index - (rec->is_method ? 1 : 0));
                 }
                 signature += ": ";
             } else if (c == '}') {
                 // Write default value if available.
-                if (arg_index < rec->args.size() && rec->args[arg_index].descr) {
+                if (!is_starred && arg_index < rec->args.size() && rec->args[arg_index].descr) {
                     signature += " = ";
                     signature += rec->args[arg_index].descr;
                 }
                 // Separator for positional-only arguments (placed after the
                 // argument, rather than before like *
-                if (rec->nargs_pos_only > 0 && (arg_index + 1) == rec->nargs_pos_only)
+                if (rec->nargs_pos_only > 0 && (arg_index + 1) == rec->nargs_pos_only) {
                     signature += ", /";
-                arg_index++;
+                }
+                if (!is_starred) {
+                    arg_index++;
+                }
             } else if (c == '%') {
                 const std::type_info *t = types[type_index++];
-                if (!t)
+                if (!t) {
                     pybind11_fail("Internal error while parsing type signature (1)");
-                if (auto tinfo = detail::get_type_info(*t)) {
+                }
+                if (auto *tinfo = detail::get_type_info(*t)) {
                     handle th((PyObject *) tinfo->type);
-                    signature +=
-                        th.attr("__module__").cast<std::string>() + "." +
-                        th.attr("__qualname__").cast<std::string>(); // Python 3.3+, but we backport it to earlier versions
+                    signature += th.attr("__module__").cast<std::string>() + "." +
+                                 // Python 3.3+, but we backport it to earlier versions
+                                 th.attr("__qualname__").cast<std::string>();
                 } else if (rec->is_new_style_constructor && arg_index == 0) {
                     // A new-style `__init__` takes `self` as `value_and_holder`.
                     // Rewrite it to the proper class type.
-                    signature +=
-                        rec->scope.attr("__module__").cast<std::string>() + "." +
-                        rec->scope.attr("__qualname__").cast<std::string>();
+                    signature += rec->scope.attr("__module__").cast<std::string>() + "."
+                                 + rec->scope.attr("__qualname__").cast<std::string>();
                 } else {
                     std::string tname(t->name());
                     detail::clean_type_id(tname);
                     signature += tname;
                 }
             } else {
                 signature += c;
             }
         }
 
-        if (arg_index != args || types[type_index] != nullptr)
+        if (arg_index != args - rec->has_args - rec->has_kwargs || types[type_index] != nullptr) {
             pybind11_fail("Internal error while parsing type signature (2)");
+        }
 
 #if PY_MAJOR_VERSION < 3
-        if (strcmp(rec->name, "__next__") == 0) {
+        if (std::strcmp(rec->name, "__next__") == 0) {
             std::free(rec->name);
-            rec->name = strdup("next");
-        } else if (strcmp(rec->name, "__bool__") == 0) {
+            rec->name = guarded_strdup("next");
+        } else if (std::strcmp(rec->name, "__bool__") == 0) {
             std::free(rec->name);
-            rec->name = strdup("__nonzero__");
+            rec->name = guarded_strdup("__nonzero__");
         }
 #endif
-        rec->signature = strdup(signature.c_str());
+        rec->signature = guarded_strdup(signature.c_str());
         rec->args.shrink_to_fit();
         rec->nargs = (std::uint16_t) args;
 
-        if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr()))
+        if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr())) {
             rec->sibling = PYBIND11_INSTANCE_METHOD_GET_FUNCTION(rec->sibling.ptr());
+        }
 
         detail::function_record *chain = nullptr, *chain_start = rec;
         if (rec->sibling) {
             if (PyCFunction_Check(rec->sibling.ptr())) {
-                auto rec_capsule = reinterpret_borrow<capsule>(PyCFunction_GET_SELF(rec->sibling.ptr()));
+                auto *self = PyCFunction_GET_SELF(rec->sibling.ptr());
+                capsule rec_capsule = isinstance<capsule>(self) ? reinterpret_borrow<capsule>(self)
+                                                                : capsule(self);
                 chain = (detail::function_record *) rec_capsule;
                 /* Never append a method to an overload chain of a parent class;
                    instead, hide the parent's overloads in this case */
-                if (!chain->scope.is(rec->scope))
+                if (!chain->scope.is(rec->scope)) {
                     chain = nullptr;
+                }
+            }
+            // Don't trigger for things like the default __init__, which are wrapper_descriptors
+            // that we are intentionally replacing
+            else if (!rec->sibling.is_none() && rec->name[0] != '_') {
+                pybind11_fail("Cannot overload existing non-function object \""
+                              + std::string(rec->name) + "\" with a function of the same name");
             }
-            // Don't trigger for things like the default __init__, which are wrapper_descriptors that we are intentionally replacing
-            else if (!rec->sibling.is_none() && rec->name[0] != '_')
-                pybind11_fail("Cannot overload existing non-function object \"" + std::string(rec->name) +
-                        "\" with a function of the same name");
         }
 
         if (!chain) {
             /* No existing overload was found, create a new function object */
             rec->def = new PyMethodDef();
             std::memset(rec->def, 0, sizeof(PyMethodDef));
             rec->def->ml_name = rec->name;
-            rec->def->ml_meth = reinterpret_cast<PyCFunction>(reinterpret_cast<void (*) (void)>(*dispatcher));
+            rec->def->ml_meth
+                = reinterpret_cast<PyCFunction>(reinterpret_cast<void (*)()>(dispatcher));
             rec->def->ml_flags = METH_VARARGS | METH_KEYWORDS;
 
-            capsule rec_capsule(rec, [](void *ptr) {
-                destruct((detail::function_record *) ptr);
-            });
+            capsule rec_capsule(unique_rec.release(),
+                                [](void *ptr) { destruct((detail::function_record *) ptr); });
+            guarded_strdup.release();
 
             object scope_module;
             if (rec->scope) {
                 if (hasattr(rec->scope, "__module__")) {
                     scope_module = rec->scope.attr("__module__");
                 } else if (hasattr(rec->scope, "__name__")) {
                     scope_module = rec->scope.attr("__name__");
                 }
             }
 
             m_ptr = PyCFunction_NewEx(rec->def, rec_capsule.ptr(), scope_module.ptr());
-            if (!m_ptr)
+            if (!m_ptr) {
                 pybind11_fail("cpp_function::cpp_function(): Could not allocate function object");
+            }
         } else {
             /* Append at the beginning or end of the overload chain */
             m_ptr = rec->sibling.ptr();
             inc_ref();
-            if (chain->is_method != rec->is_method)
-                pybind11_fail("overloading a method with both static and instance methods is not supported; "
-                    #if defined(NDEBUG)
-                        "compile in debug mode for more details"
-                    #else
-                        "error while attempting to bind " + std::string(rec->is_method ? "instance" : "static") + " method " +
-                        std::string(pybind11::str(rec->scope.attr("__name__"))) + "." + std::string(rec->name) + signature
-                    #endif
+            if (chain->is_method != rec->is_method) {
+                pybind11_fail(
+                    "overloading a method with both static and instance methods is not supported; "
+#if defined(NDEBUG)
+                    "compile in debug mode for more details"
+#else
+                    "error while attempting to bind "
+                    + std::string(rec->is_method ? "instance" : "static") + " method "
+                    + std::string(pybind11::str(rec->scope.attr("__name__"))) + "."
+                    + std::string(rec->name) + signature
+#endif
                 );
+            }
 
             if (rec->prepend) {
                 // Beginning of chain; we need to replace the capsule's current head-of-the-chain
                 // pointer with this one, then make this one point to the previous head of the
                 // chain.
                 chain_start = rec;
                 rec->next = chain;
-                auto rec_capsule = reinterpret_borrow<capsule>(((PyCFunctionObject *) m_ptr)->m_self);
-                rec_capsule.set_pointer(rec);
+                auto rec_capsule
+                    = reinterpret_borrow<capsule>(((PyCFunctionObject *) m_ptr)->m_self);
+                rec_capsule.set_pointer(unique_rec.release());
+                guarded_strdup.release();
             } else {
                 // Or end of chain (normal behavior)
                 chain_start = chain;
-                while (chain->next)
+                while (chain->next) {
                     chain = chain->next;
-                chain->next = rec;
+                }
+                chain->next = unique_rec.release();
+                guarded_strdup.release();
             }
         }
 
         std::string signatures;
         int index = 0;
         /* Create a nice pydoc rec including all signatures and
            docstrings of the functions in the overload chain */
@@ -411,116 +564,143 @@
             // First a generic signature
             signatures += rec->name;
             signatures += "(*args, **kwargs)\n";
             signatures += "Overloaded function.\n\n";
         }
         // Then specific overload signatures
         bool first_user_def = true;
-        for (auto it = chain_start; it != nullptr; it = it->next) {
+        for (auto *it = chain_start; it != nullptr; it = it->next) {
             if (options::show_function_signatures()) {
-                if (index > 0) signatures += "\n";
-                if (chain)
+                if (index > 0) {
+                    signatures += "\n";
+                }
+                if (chain) {
                     signatures += std::to_string(++index) + ". ";
+                }
                 signatures += rec->name;
                 signatures += it->signature;
                 signatures += "\n";
             }
-            if (it->doc && strlen(it->doc) > 0 && options::show_user_defined_docstrings()) {
-                // If we're appending another docstring, and aren't printing function signatures, we
-                // need to append a newline first:
+            if (it->doc && it->doc[0] != '\0' && options::show_user_defined_docstrings()) {
+                // If we're appending another docstring, and aren't printing function signatures,
+                // we need to append a newline first:
                 if (!options::show_function_signatures()) {
-                    if (first_user_def) first_user_def = false;
-                    else signatures += "\n";
+                    if (first_user_def) {
+                        first_user_def = false;
+                    } else {
+                        signatures += "\n";
+                    }
+                }
+                if (options::show_function_signatures()) {
+                    signatures += "\n";
                 }
-                if (options::show_function_signatures()) signatures += "\n";
                 signatures += it->doc;
-                if (options::show_function_signatures()) signatures += "\n";
+                if (options::show_function_signatures()) {
+                    signatures += "\n";
+                }
             }
         }
 
         /* Install docstring */
         auto *func = (PyCFunctionObject *) m_ptr;
-        if (func->m_ml->ml_doc)
-            std::free(const_cast<char *>(func->m_ml->ml_doc));
-        func->m_ml->ml_doc = strdup(signatures.c_str());
+        std::free(const_cast<char *>(func->m_ml->ml_doc));
+        // Install docstring if it's non-empty (when at least one option is enabled)
+        func->m_ml->ml_doc
+            = signatures.empty() ? nullptr : PYBIND11_COMPAT_STRDUP(signatures.c_str());
 
         if (rec->is_method) {
             m_ptr = PYBIND11_INSTANCE_METHOD_NEW(m_ptr, rec->scope.ptr());
-            if (!m_ptr)
-                pybind11_fail("cpp_function::cpp_function(): Could not allocate instance method object");
+            if (!m_ptr) {
+                pybind11_fail(
+                    "cpp_function::cpp_function(): Could not allocate instance method object");
+            }
             Py_DECREF(func);
         }
     }
 
     /// When a cpp_function is GCed, release any memory allocated by pybind11
-    static void destruct(detail::function_record *rec) {
-        // If on Python 3.9, check the interpreter "MICRO" (patch) version.
-        // If this is running on 3.9.0, we have to work around a bug.
-        #if !defined(PYPY_VERSION) && PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 9
-            static bool is_zero = Py_GetVersion()[4] == '0';
-        #endif
+    static void destruct(detail::function_record *rec, bool free_strings = true) {
+// If on Python 3.9, check the interpreter "MICRO" (patch) version.
+// If this is running on 3.9.0, we have to work around a bug.
+#if !defined(PYPY_VERSION) && PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 9
+        static bool is_zero = Py_GetVersion()[4] == '0';
+#endif
 
         while (rec) {
             detail::function_record *next = rec->next;
-            if (rec->free_data)
+            if (rec->free_data) {
                 rec->free_data(rec);
-            std::free((char *) rec->name);
-            std::free((char *) rec->doc);
-            std::free((char *) rec->signature);
-            for (auto &arg: rec->args) {
-                std::free(const_cast<char *>(arg.name));
-                std::free(const_cast<char *>(arg.descr));
+            }
+            // During initialization, these strings might not have been copied yet,
+            // so they cannot be freed. Once the function has been created, they can.
+            // Check `make_function_record` for more details.
+            if (free_strings) {
+                std::free((char *) rec->name);
+                std::free((char *) rec->doc);
+                std::free((char *) rec->signature);
+                for (auto &arg : rec->args) {
+                    std::free(const_cast<char *>(arg.name));
+                    std::free(const_cast<char *>(arg.descr));
+                }
+            }
+            for (auto &arg : rec->args) {
                 arg.value.dec_ref();
             }
             if (rec->def) {
                 std::free(const_cast<char *>(rec->def->ml_doc));
-                // Python 3.9.0 decref's these in the wrong order; rec->def
-                // If loaded on 3.9.0, let these leak (use Python 3.9.1 at runtime to fix)
-                // See https://github.com/python/cpython/pull/22670
-                #if !defined(PYPY_VERSION) && PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 9
-                    if (!is_zero)
-                        delete rec->def;
-                #else
+// Python 3.9.0 decref's these in the wrong order; rec->def
+// If loaded on 3.9.0, let these leak (use Python 3.9.1 at runtime to fix)
+// See https://github.com/python/cpython/pull/22670
+#if !defined(PYPY_VERSION) && PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION == 9
+                if (!is_zero) {
                     delete rec->def;
-                #endif
+                }
+#else
+                delete rec->def;
+#endif
             }
             delete rec;
             rec = next;
         }
     }
 
     /// Main dispatch logic for calls to functions bound using pybind11
     static PyObject *dispatcher(PyObject *self, PyObject *args_in, PyObject *kwargs_in) {
         using namespace detail;
 
         /* Iterator over the list of potentially admissible overloads */
         const function_record *overloads = (function_record *) PyCapsule_GetPointer(self, nullptr),
                               *it = overloads;
 
-        /* Need to know how many arguments + keyword arguments there are to pick the right overload */
+        /* Need to know how many arguments + keyword arguments there are to pick the right
+           overload */
         const auto n_args_in = (size_t) PyTuple_GET_SIZE(args_in);
 
         handle parent = n_args_in > 0 ? PyTuple_GET_ITEM(args_in, 0) : nullptr,
                result = PYBIND11_TRY_NEXT_OVERLOAD;
 
         auto self_value_and_holder = value_and_holder();
         if (overloads->is_constructor) {
-            const auto tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
-            const auto pi = reinterpret_cast<instance *>(parent.ptr());
-            self_value_and_holder = pi->get_value_and_holder(tinfo, false);
-
-            if (!self_value_and_holder.type || !self_value_and_holder.inst) {
-                PyErr_SetString(PyExc_TypeError, "__init__(self, ...) called with invalid `self` argument");
+            if (!parent
+                || !PyObject_TypeCheck(parent.ptr(), (PyTypeObject *) overloads->scope.ptr())) {
+                PyErr_SetString(
+                    PyExc_TypeError,
+                    "__init__(self, ...) called with invalid or missing `self` argument");
                 return nullptr;
             }
 
+            auto *const tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
+            auto *const pi = reinterpret_cast<instance *>(parent.ptr());
+            self_value_and_holder = pi->get_value_and_holder(tinfo, true);
+
             // If this value is already registered it must mean __init__ is invoked multiple times;
             // we really can't support that in C++, so just ignore the second __init__.
-            if (self_value_and_holder.instance_registered())
+            if (self_value_and_holder.instance_registered()) {
                 return none().release().ptr();
+            }
         }
 
         try {
             // We do this in two passes: in the first pass, we load arguments with `convert=false`;
             // in the second, we allow conversion (except for arguments with an explicit
             // py::arg().noconvert()).  This lets us prefer calls without conversion, with
             // conversion as a fallback.
@@ -531,78 +711,94 @@
 
             for (; it != nullptr; it = it->next) {
 
                 /* For each overload:
                    1. Copy all positional arguments we were given, also checking to make sure that
                       named positional arguments weren't *also* specified via kwarg.
                    2. If we weren't given enough, try to make up the omitted ones by checking
-                      whether they were provided by a kwarg matching the `py::arg("name")` name.  If
-                      so, use it (and remove it from kwargs; if not, see if the function binding
+                      whether they were provided by a kwarg matching the `py::arg("name")` name. If
+                      so, use it (and remove it from kwargs); if not, see if the function binding
                       provided a default that we can use.
-                   3. Ensure that either all keyword arguments were "consumed", or that the function
-                      takes a kwargs argument to accept unconsumed kwargs.
+                   3. Ensure that either all keyword arguments were "consumed", or that the
+                   function takes a kwargs argument to accept unconsumed kwargs.
                    4. Any positional arguments still left get put into a tuple (for args), and any
                       leftover kwargs get put into a dict.
                    5. Pack everything into a vector; if we have py::args or py::kwargs, they are an
                       extra tuple or dict at the end of the positional arguments.
                    6. Call the function call dispatcher (function_record::impl)
 
-                   If one of these fail, move on to the next overload and keep trying until we get a
-                   result other than PYBIND11_TRY_NEXT_OVERLOAD.
+                   If one of these fail, move on to the next overload and keep trying until we get
+                   a result other than PYBIND11_TRY_NEXT_OVERLOAD.
                  */
 
                 const function_record &func = *it;
-                size_t num_args = func.nargs;    // Number of positional arguments that we need
-                if (func.has_args) --num_args;   // (but don't count py::args
-                if (func.has_kwargs) --num_args; //  or py::kwargs)
-                size_t pos_args = num_args - func.nargs_kw_only;
+                size_t num_args = func.nargs; // Number of positional arguments that we need
+                if (func.has_args) {
+                    --num_args; // (but don't count py::args
+                }
+                if (func.has_kwargs) {
+                    --num_args; //  or py::kwargs)
+                }
+                size_t pos_args = func.nargs_pos;
 
-                if (!func.has_args && n_args_in > pos_args)
+                if (!func.has_args && n_args_in > pos_args) {
                     continue; // Too many positional arguments for this overload
+                }
 
-                if (n_args_in < pos_args && func.args.size() < pos_args)
-                    continue; // Not enough positional arguments given, and not enough defaults to fill in the blanks
+                if (n_args_in < pos_args && func.args.size() < pos_args) {
+                    continue; // Not enough positional arguments given, and not enough defaults to
+                              // fill in the blanks
+                }
 
                 function_call call(func, parent);
 
-                size_t args_to_copy = (std::min)(pos_args, n_args_in); // Protect std::min with parentheses
+                // Protect std::min with parentheses
+                size_t args_to_copy = (std::min)(pos_args, n_args_in);
                 size_t args_copied = 0;
 
                 // 0. Inject new-style `self` argument
                 if (func.is_new_style_constructor) {
                     // The `value` may have been preallocated by an old-style `__init__`
                     // if it was a preceding candidate for overload resolution.
-                    if (self_value_and_holder)
+                    if (self_value_and_holder) {
                         self_value_and_holder.type->dealloc(self_value_and_holder);
+                    }
 
                     call.init_self = PyTuple_GET_ITEM(args_in, 0);
                     call.args.emplace_back(reinterpret_cast<PyObject *>(&self_value_and_holder));
                     call.args_convert.push_back(false);
                     ++args_copied;
                 }
 
                 // 1. Copy any position arguments given.
                 bool bad_arg = false;
                 for (; args_copied < args_to_copy; ++args_copied) {
-                    const argument_record *arg_rec = args_copied < func.args.size() ? &func.args[args_copied] : nullptr;
-                    if (kwargs_in && arg_rec && arg_rec->name && PyDict_GetItemString(kwargs_in, arg_rec->name)) {
+                    const argument_record *arg_rec
+                        = args_copied < func.args.size() ? &func.args[args_copied] : nullptr;
+                    if (kwargs_in && arg_rec && arg_rec->name
+                        && dict_getitemstring(kwargs_in, arg_rec->name)) {
                         bad_arg = true;
                         break;
                     }
 
                     handle arg(PyTuple_GET_ITEM(args_in, args_copied));
                     if (arg_rec && !arg_rec->none && arg.is_none()) {
                         bad_arg = true;
                         break;
                     }
                     call.args.push_back(arg);
                     call.args_convert.push_back(arg_rec ? arg_rec->convert : true);
                 }
-                if (bad_arg)
+                if (bad_arg) {
                     continue; // Maybe it was meant for another overload (issue #688)
+                }
+
+                // Keep track of how many position args we copied out in case we need to come back
+                // to copy the rest into a py::args argument.
+                size_t positional_args_copied = args_copied;
 
                 // We'll need to copy this if we steal some kwargs for defaults
                 dict kwargs = reinterpret_borrow<dict>(kwargs_in);
 
                 // 1.5. Fill in any missing pos_only args from defaults if they exist
                 if (args_copied < func.nargs_pos_only) {
                     for (; args_copied < func.nargs_pos_only; ++args_copied) {
@@ -611,100 +807,121 @@
 
                         if (arg_rec.value) {
                             value = arg_rec.value;
                         }
                         if (value) {
                             call.args.push_back(value);
                             call.args_convert.push_back(arg_rec.convert);
-                        } else
+                        } else {
                             break;
+                        }
                     }
 
-                    if (args_copied < func.nargs_pos_only)
+                    if (args_copied < func.nargs_pos_only) {
                         continue; // Not enough defaults to fill the positional arguments
+                    }
                 }
 
                 // 2. Check kwargs and, failing that, defaults that may help complete the list
                 if (args_copied < num_args) {
                     bool copied_kwargs = false;
 
                     for (; args_copied < num_args; ++args_copied) {
                         const auto &arg_rec = func.args[args_copied];
 
                         handle value;
-                        if (kwargs_in && arg_rec.name)
-                            value = PyDict_GetItemString(kwargs.ptr(), arg_rec.name);
+                        if (kwargs_in && arg_rec.name) {
+                            value = dict_getitemstring(kwargs.ptr(), arg_rec.name);
+                        }
 
                         if (value) {
                             // Consume a kwargs value
                             if (!copied_kwargs) {
                                 kwargs = reinterpret_steal<dict>(PyDict_Copy(kwargs.ptr()));
                                 copied_kwargs = true;
                             }
-                            PyDict_DelItemString(kwargs.ptr(), arg_rec.name);
+                            if (PyDict_DelItemString(kwargs.ptr(), arg_rec.name) == -1) {
+                                throw error_already_set();
+                            }
                         } else if (arg_rec.value) {
                             value = arg_rec.value;
                         }
 
                         if (!arg_rec.none && value.is_none()) {
                             break;
                         }
 
                         if (value) {
+                            // If we're at the py::args index then first insert a stub for it to be
+                            // replaced later
+                            if (func.has_args && call.args.size() == func.nargs_pos) {
+                                call.args.push_back(none());
+                            }
+
                             call.args.push_back(value);
                             call.args_convert.push_back(arg_rec.convert);
-                        }
-                        else
+                        } else {
                             break;
+                        }
                     }
 
-                    if (args_copied < num_args)
-                        continue; // Not enough arguments, defaults, or kwargs to fill the positional arguments
+                    if (args_copied < num_args) {
+                        continue; // Not enough arguments, defaults, or kwargs to fill the
+                                  // positional arguments
+                    }
                 }
 
                 // 3. Check everything was consumed (unless we have a kwargs arg)
-                if (kwargs && !kwargs.empty() && !func.has_kwargs)
+                if (kwargs && !kwargs.empty() && !func.has_kwargs) {
                     continue; // Unconsumed kwargs, but no py::kwargs argument to accept them
+                }
 
                 // 4a. If we have a py::args argument, create a new tuple with leftovers
                 if (func.has_args) {
                     tuple extra_args;
                     if (args_to_copy == 0) {
                         // We didn't copy out any position arguments from the args_in tuple, so we
                         // can reuse it directly without copying:
                         extra_args = reinterpret_borrow<tuple>(args_in);
-                    } else if (args_copied >= n_args_in) {
+                    } else if (positional_args_copied >= n_args_in) {
                         extra_args = tuple(0);
                     } else {
-                        size_t args_size = n_args_in - args_copied;
+                        size_t args_size = n_args_in - positional_args_copied;
                         extra_args = tuple(args_size);
                         for (size_t i = 0; i < args_size; ++i) {
-                            extra_args[i] = PyTuple_GET_ITEM(args_in, args_copied + i);
+                            extra_args[i] = PyTuple_GET_ITEM(args_in, positional_args_copied + i);
                         }
                     }
-                    call.args.push_back(extra_args);
+                    if (call.args.size() <= func.nargs_pos) {
+                        call.args.push_back(extra_args);
+                    } else {
+                        call.args[func.nargs_pos] = extra_args;
+                    }
                     call.args_convert.push_back(false);
                     call.args_ref = std::move(extra_args);
                 }
 
                 // 4b. If we have a py::kwargs, pass on any remaining kwargs
                 if (func.has_kwargs) {
-                    if (!kwargs.ptr())
+                    if (!kwargs.ptr()) {
                         kwargs = dict(); // If we didn't get one, send an empty one
+                    }
                     call.args.push_back(kwargs);
                     call.args_convert.push_back(false);
                     call.kwargs_ref = std::move(kwargs);
                 }
 
-                // 5. Put everything in a vector.  Not technically step 5, we've been building it
-                // in `call.args` all along.
-                #if !defined(NDEBUG)
-                if (call.args.size() != func.nargs || call.args_convert.size() != func.nargs)
-                    pybind11_fail("Internal error: function call dispatcher inserted wrong number of arguments!");
-                #endif
+// 5. Put everything in a vector.  Not technically step 5, we've been building it
+// in `call.args` all along.
+#if !defined(NDEBUG)
+                if (call.args.size() != func.nargs || call.args_convert.size() != func.nargs) {
+                    pybind11_fail("Internal error: function call dispatcher inserted wrong number "
+                                  "of arguments!");
+                }
+#endif
 
                 std::vector<bool> second_pass_convert;
                 if (overloaded) {
                     // We're in the first no-convert pass, so swap out the conversion flags for a
                     // set of all-false flags.  If the call fails, we'll swap the flags back in for
                     // the conversion-allowed call below.
                     second_pass_convert.resize(func.nargs, false);
@@ -715,16 +932,17 @@
                 try {
                     loader_life_support guard{};
                     result = func.impl(call);
                 } catch (reference_cast_error &) {
                     result = PYBIND11_TRY_NEXT_OVERLOAD;
                 }
 
-                if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD)
+                if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD) {
                     break;
+                }
 
                 if (overloaded) {
                     // The (overloaded) call failed; if the call has at least one argument that
                     // permits conversion (i.e. it hasn't been explicitly specified `.noconvert()`)
                     // then add this call to the list of second pass overloads to try.
                     for (size_t i = func.is_method ? 1 : 0; i < pos_args; i++) {
                         if (second_pass_convert[i]) {
@@ -735,159 +953,195 @@
                             break;
                         }
                     }
                 }
             }
 
             if (overloaded && !second_pass.empty() && result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {
-                // The no-conversion pass finished without success, try again with conversion allowed
+                // The no-conversion pass finished without success, try again with conversion
+                // allowed
                 for (auto &call : second_pass) {
                     try {
                         loader_life_support guard{};
                         result = call.func.impl(call);
                     } catch (reference_cast_error &) {
                         result = PYBIND11_TRY_NEXT_OVERLOAD;
                     }
 
                     if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD) {
                         // The error reporting logic below expects 'it' to be valid, as it would be
                         // if we'd encountered this failure in the first-pass loop.
-                        if (!result)
+                        if (!result) {
                             it = &call.func;
+                        }
                         break;
                     }
                 }
             }
         } catch (error_already_set &e) {
             e.restore();
             return nullptr;
 #ifdef __GLIBCXX__
-        } catch ( abi::__forced_unwind& ) {
+        } catch (abi::__forced_unwind &) {
             throw;
 #endif
         } catch (...) {
             /* When an exception is caught, give each registered exception
-               translator a chance to translate it to a Python exception
-               in reverse order of registration.
+               translator a chance to translate it to a Python exception. First
+               all module-local translators will be tried in reverse order of
+               registration. If none of the module-locale translators handle
+               the exception (or there are no module-locale translators) then
+               the global translators will be tried, also in reverse order of
+               registration.
 
                A translator may choose to do one of the following:
 
                 - catch the exception and call PyErr_SetString or PyErr_SetObject
                   to set a standard (or custom) Python exception, or
                 - do nothing and let the exception fall through to the next translator, or
-                - delegate translation to the next translator by throwing a new type of exception. */
+                - delegate translation to the next translator by throwing a new type of exception.
+             */
 
-            auto last_exception = std::current_exception();
-            auto &registered_exception_translators = get_internals().registered_exception_translators;
-            for (auto& translator : registered_exception_translators) {
-                try {
-                    translator(last_exception);
-                } catch (...) {
-                    last_exception = std::current_exception();
-                    continue;
-                }
+            auto &local_exception_translators
+                = get_local_internals().registered_exception_translators;
+            if (detail::apply_exception_translators(local_exception_translators)) {
                 return nullptr;
             }
-            PyErr_SetString(PyExc_SystemError, "Exception escaped from default exception translator!");
+            auto &exception_translators = get_internals().registered_exception_translators;
+            if (detail::apply_exception_translators(exception_translators)) {
+                return nullptr;
+            }
+
+            PyErr_SetString(PyExc_SystemError,
+                            "Exception escaped from default exception translator!");
             return nullptr;
         }
 
         auto append_note_if_missing_header_is_suspected = [](std::string &msg) {
             if (msg.find("std::") != std::string::npos) {
                 msg += "\n\n"
                        "Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\n"
                        "<pybind11/functional.h>, <pybind11/chrono.h>, etc. Some automatic\n"
                        "conversions are optional and require extra headers to be included\n"
                        "when compiling your pybind11 module.";
             }
         };
 
         if (result.ptr() == PYBIND11_TRY_NEXT_OVERLOAD) {
-            if (overloads->is_operator)
+            if (overloads->is_operator) {
                 return handle(Py_NotImplemented).inc_ref().ptr();
+            }
 
-            std::string msg = std::string(overloads->name) + "(): incompatible " +
-                std::string(overloads->is_constructor ? "constructor" : "function") +
-                " arguments. The following argument types are supported:\n";
+            std::string msg = std::string(overloads->name) + "(): incompatible "
+                              + std::string(overloads->is_constructor ? "constructor" : "function")
+                              + " arguments. The following argument types are supported:\n";
 
             int ctr = 0;
             for (const function_record *it2 = overloads; it2 != nullptr; it2 = it2->next) {
-                msg += "    "+ std::to_string(++ctr) + ". ";
+                msg += "    " + std::to_string(++ctr) + ". ";
 
                 bool wrote_sig = false;
                 if (overloads->is_constructor) {
-                    // For a constructor, rewrite `(self: Object, arg0, ...) -> NoneType` as `Object(arg0, ...)`
+                    // For a constructor, rewrite `(self: Object, arg0, ...) -> NoneType` as
+                    // `Object(arg0, ...)`
                     std::string sig = it2->signature;
                     size_t start = sig.find('(') + 7; // skip "(self: "
                     if (start < sig.size()) {
                         // End at the , for the next argument
                         size_t end = sig.find(", "), next = end + 2;
                         size_t ret = sig.rfind(" -> ");
                         // Or the ), if there is no comma:
-                        if (end >= sig.size()) next = end = sig.find(')');
+                        if (end >= sig.size()) {
+                            next = end = sig.find(')');
+                        }
                         if (start < end && next < sig.size()) {
                             msg.append(sig, start, end - start);
                             msg += '(';
                             msg.append(sig, next, ret - next);
                             wrote_sig = true;
                         }
                     }
                 }
-                if (!wrote_sig) msg += it2->signature;
+                if (!wrote_sig) {
+                    msg += it2->signature;
+                }
 
                 msg += "\n";
             }
             msg += "\nInvoked with: ";
             auto args_ = reinterpret_borrow<tuple>(args_in);
             bool some_args = false;
             for (size_t ti = overloads->is_constructor ? 1 : 0; ti < args_.size(); ++ti) {
-                if (!some_args) some_args = true;
-                else msg += ", ";
+                if (!some_args) {
+                    some_args = true;
+                } else {
+                    msg += ", ";
+                }
                 try {
                     msg += pybind11::repr(args_[ti]);
-                } catch (const error_already_set&) {
+                } catch (const error_already_set &) {
                     msg += "<repr raised Error>";
                 }
             }
             if (kwargs_in) {
                 auto kwargs = reinterpret_borrow<dict>(kwargs_in);
                 if (!kwargs.empty()) {
-                    if (some_args) msg += "; ";
+                    if (some_args) {
+                        msg += "; ";
+                    }
                     msg += "kwargs: ";
                     bool first = true;
                     for (auto kwarg : kwargs) {
-                        if (first) first = false;
-                        else msg += ", ";
+                        if (first) {
+                            first = false;
+                        } else {
+                            msg += ", ";
+                        }
                         msg += pybind11::str("{}=").format(kwarg.first);
                         try {
                             msg += pybind11::repr(kwarg.second);
-                        } catch (const error_already_set&) {
+                        } catch (const error_already_set &) {
                             msg += "<repr raised Error>";
                         }
                     }
                 }
             }
 
             append_note_if_missing_header_is_suspected(msg);
+#if PY_VERSION_HEX >= 0x03030000
+            // Attach additional error info to the exception if supported
+            if (PyErr_Occurred()) {
+                // #HelpAppreciated: unit test coverage for this branch.
+                raise_from(PyExc_TypeError, msg.c_str());
+                return nullptr;
+            }
+#endif
             PyErr_SetString(PyExc_TypeError, msg.c_str());
             return nullptr;
-        } else if (!result) {
+        }
+        if (!result) {
             std::string msg = "Unable to convert function return value to a "
                               "Python type! The signature was\n\t";
             msg += it->signature;
             append_note_if_missing_header_is_suspected(msg);
+#if PY_VERSION_HEX >= 0x03030000
+            // Attach additional error info to the exception if supported
+            if (PyErr_Occurred()) {
+                raise_from(PyExc_TypeError, msg.c_str());
+                return nullptr;
+            }
+#endif
             PyErr_SetString(PyExc_TypeError, msg.c_str());
             return nullptr;
-        } else {
-            if (overloads->is_constructor && !self_value_and_holder.holder_constructed()) {
-                auto *pi = reinterpret_cast<instance *>(parent.ptr());
-                self_value_and_holder.type->init_instance(pi, nullptr);
-            }
-            return result.ptr();
         }
+        if (overloads->is_constructor && !self_value_and_holder.holder_constructed()) {
+            auto *pi = reinterpret_cast<instance *>(parent.ptr());
+            self_value_and_holder.type->init_instance(pi, nullptr);
+        }
+        return result.ptr();
     }
 };
 
 /// Wrapper for Python extension modules
 class module_ : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(module_, object, PyModule_Check)
@@ -904,19 +1158,23 @@
 
     /** \rst
         Create Python binding for a new function within the module scope. ``Func``
         can be a plain C++ function, a function pointer, or a lambda function. For
         details on the ``Extra&& ... extra`` argument, see section :ref:`extras`.
     \endrst */
     template <typename Func, typename... Extra>
-    module_ &def(const char *name_, Func &&f, const Extra& ... extra) {
-        cpp_function func(std::forward<Func>(f), name(name_), scope(*this),
-                          sibling(getattr(*this, name_, none())), extra...);
+    module_ &def(const char *name_, Func &&f, const Extra &...extra) {
+        cpp_function func(std::forward<Func>(f),
+                          name(name_),
+                          scope(*this),
+                          sibling(getattr(*this, name_, none())),
+                          extra...);
         // NB: allow overwriting here because cpp_function sets up a chain with the intention of
-        // overwriting (and has already checked internally that it isn't overwriting non-functions).
+        // overwriting (and has already checked internally that it isn't overwriting
+        // non-functions).
         add_object(name_, func, true /* overwrite */);
         return *this;
     }
 
     /** \rst
         Create and return a new Python submodule with the given name and docstring.
         This also works recursively, i.e.
@@ -924,92 +1182,100 @@
         .. code-block:: cpp
 
             py::module_ m("example", "pybind11 example plugin");
             py::module_ m2 = m.def_submodule("sub", "A submodule of 'example'");
             py::module_ m3 = m2.def_submodule("subsub", "A submodule of 'example.sub'");
     \endrst */
     module_ def_submodule(const char *name, const char *doc = nullptr) {
-        std::string full_name = std::string(PyModule_GetName(m_ptr))
-            + std::string(".") + std::string(name);
+        std::string full_name
+            = std::string(PyModule_GetName(m_ptr)) + std::string(".") + std::string(name);
         auto result = reinterpret_borrow<module_>(PyImport_AddModule(full_name.c_str()));
-        if (doc && options::show_user_defined_docstrings())
+        if (doc && options::show_user_defined_docstrings()) {
             result.attr("__doc__") = pybind11::str(doc);
+        }
         attr(name) = result;
         return result;
     }
 
     /// Import and return a module or throws `error_already_set`.
     static module_ import(const char *name) {
         PyObject *obj = PyImport_ImportModule(name);
-        if (!obj)
+        if (!obj) {
             throw error_already_set();
+        }
         return reinterpret_steal<module_>(obj);
     }
 
     /// Reload the module or throws `error_already_set`.
     void reload() {
         PyObject *obj = PyImport_ReloadModule(ptr());
-        if (!obj)
+        if (!obj) {
             throw error_already_set();
+        }
         *this = reinterpret_steal<module_>(obj);
     }
 
     /** \rst
         Adds an object to the module using the given name.  Throws if an object with the given name
         already exists.
 
-        ``overwrite`` should almost always be false: attempting to overwrite objects that pybind11 has
-        established will, in most cases, break things.
+        ``overwrite`` should almost always be false: attempting to overwrite objects that pybind11
+        has established will, in most cases, break things.
     \endrst */
     PYBIND11_NOINLINE void add_object(const char *name, handle obj, bool overwrite = false) {
-        if (!overwrite && hasattr(*this, name))
-            pybind11_fail("Error during initialization: multiple incompatible definitions with name \"" +
-                    std::string(name) + "\"");
+        if (!overwrite && hasattr(*this, name)) {
+            pybind11_fail(
+                "Error during initialization: multiple incompatible definitions with name \""
+                + std::string(name) + "\"");
+        }
 
         PyModule_AddObject(ptr(), name, obj.inc_ref().ptr() /* steals a reference */);
     }
 
 #if PY_MAJOR_VERSION >= 3
     using module_def = PyModuleDef;
 #else
     struct module_def {};
 #endif
 
     /** \rst
         Create a new top-level module that can be used as the main module of a C extension.
 
-        For Python 3, ``def`` should point to a staticly allocated module_def.
+        For Python 3, ``def`` should point to a statically allocated module_def.
         For Python 2, ``def`` can be a nullptr and is completely ignored.
     \endrst */
     static module_ create_extension_module(const char *name, const char *doc, module_def *def) {
 #if PY_MAJOR_VERSION >= 3
         // module_def is PyModuleDef
-        def = new (def) PyModuleDef {  // Placement new (not an allocation).
-            /* m_base */     PyModuleDef_HEAD_INIT,
-            /* m_name */     name,
-            /* m_doc */      options::show_user_defined_docstrings() ? doc : nullptr,
-            /* m_size */     -1,
-            /* m_methods */  nullptr,
-            /* m_slots */    nullptr,
-            /* m_traverse */ nullptr,
-            /* m_clear */    nullptr,
-            /* m_free */     nullptr
-        };
-        auto m = PyModule_Create(def);
+        // Placement new (not an allocation).
+        def = new (def)
+            PyModuleDef{/* m_base */ PyModuleDef_HEAD_INIT,
+                        /* m_name */ name,
+                        /* m_doc */ options::show_user_defined_docstrings() ? doc : nullptr,
+                        /* m_size */ -1,
+                        /* m_methods */ nullptr,
+                        /* m_slots */ nullptr,
+                        /* m_traverse */ nullptr,
+                        /* m_clear */ nullptr,
+                        /* m_free */ nullptr};
+        auto *m = PyModule_Create(def);
 #else
         // Ignore module_def *def; only necessary for Python 3
         (void) def;
-        auto m = Py_InitModule3(name, nullptr, options::show_user_defined_docstrings() ? doc : nullptr);
+        auto m = Py_InitModule3(
+            name, nullptr, options::show_user_defined_docstrings() ? doc : nullptr);
 #endif
         if (m == nullptr) {
-            if (PyErr_Occurred())
+            if (PyErr_Occurred()) {
                 throw error_already_set();
+            }
             pybind11_fail("Internal error in module_::create_extension_module()");
         }
-        // TODO: Sould be reinterpret_steal for Python 3, but Python also steals it again when returned from PyInit_...
+        // TODO: Should be reinterpret_steal for Python 3, but Python also steals it again when
+        // returned from PyInit_...
         //       For Python 2, reinterpret_borrow is correct.
         return reinterpret_borrow<module_>(m);
     }
 };
 
 // When inside a namespace (or anywhere as long as it's not the first item on a line),
 // C++20 allows "module" to be used. This is provided for backward compatibility, and for
@@ -1020,28 +1286,41 @@
 /// Return a dictionary representing the global variables in the current execution frame,
 /// or ``__main__.__dict__`` if there is no frame (usually when the interpreter is embedded).
 inline dict globals() {
     PyObject *p = PyEval_GetGlobals();
     return reinterpret_borrow<dict>(p ? p : module_::import("__main__").attr("__dict__").ptr());
 }
 
+#if PY_VERSION_HEX >= 0x03030000
+template <typename... Args, typename = detail::enable_if_t<args_are_all_keyword_or_ds<Args...>()>>
+PYBIND11_DEPRECATED("make_simple_namespace should be replaced with "
+                    "py::module_::import(\"types\").attr(\"SimpleNamespace\") ")
+object make_simple_namespace(Args &&...args_) {
+    return module_::import("types").attr("SimpleNamespace")(std::forward<Args>(args_)...);
+}
+#endif
+
 PYBIND11_NAMESPACE_BEGIN(detail)
 /// Generic support for creating new Python heap types
 class generic_type : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(generic_type, object, PyType_Check)
 protected:
     void initialize(const type_record &rec) {
-        if (rec.scope && hasattr(rec.scope, "__dict__") && rec.scope.attr("__dict__").contains(rec.name))
-            pybind11_fail("generic_type: cannot initialize type \"" + std::string(rec.name) +
-                          "\": an object with that name is already defined");
-
-        if (rec.module_local ? get_local_type_info(*rec.type) : get_global_type_info(*rec.type))
-            pybind11_fail("generic_type: type \"" + std::string(rec.name) +
-                          "\" is already registered!");
+        if (rec.scope && hasattr(rec.scope, "__dict__")
+            && rec.scope.attr("__dict__").contains(rec.name)) {
+            pybind11_fail("generic_type: cannot initialize type \"" + std::string(rec.name)
+                          + "\": an object with that name is already defined");
+        }
+
+        if ((rec.module_local ? get_local_type_info(*rec.type) : get_global_type_info(*rec.type))
+            != nullptr) {
+            pybind11_fail("generic_type: type \"" + std::string(rec.name)
+                          + "\" is already registered!");
+        }
 
         m_ptr = make_new_python_type(rec);
 
         /* Register supplemental type information in C++ dict */
         auto *tinfo = new detail::type_info();
         tinfo->type = (PyTypeObject *) m_ptr;
         tinfo->cpptype = rec.type;
@@ -1055,185 +1334,216 @@
         tinfo->simple_ancestors = true;
         tinfo->default_holder = rec.default_holder;
         tinfo->module_local = rec.module_local;
 
         auto &internals = get_internals();
         auto tindex = std::type_index(*rec.type);
         tinfo->direct_conversions = &internals.direct_conversions[tindex];
-        if (rec.module_local)
-            registered_local_types_cpp()[tindex] = tinfo;
-        else
+        if (rec.module_local) {
+            get_local_internals().registered_types_cpp[tindex] = tinfo;
+        } else {
             internals.registered_types_cpp[tindex] = tinfo;
-        internals.registered_types_py[(PyTypeObject *) m_ptr] = { tinfo };
+        }
+        internals.registered_types_py[(PyTypeObject *) m_ptr] = {tinfo};
 
         if (rec.bases.size() > 1 || rec.multiple_inheritance) {
             mark_parents_nonsimple(tinfo->type);
             tinfo->simple_ancestors = false;
-        }
-        else if (rec.bases.size() == 1) {
-            auto parent_tinfo = get_type_info((PyTypeObject *) rec.bases[0].ptr());
-            tinfo->simple_ancestors = parent_tinfo->simple_ancestors;
+        } else if (rec.bases.size() == 1) {
+            auto *parent_tinfo = get_type_info((PyTypeObject *) rec.bases[0].ptr());
+            assert(parent_tinfo != nullptr);
+            bool parent_simple_ancestors = parent_tinfo->simple_ancestors;
+            tinfo->simple_ancestors = parent_simple_ancestors;
+            // The parent can no longer be a simple type if it has MI and has a child
+            parent_tinfo->simple_type = parent_tinfo->simple_type && parent_simple_ancestors;
         }
 
         if (rec.module_local) {
             // Stash the local typeinfo and loader so that external modules can access it.
             tinfo->module_local_load = &type_caster_generic::local_load;
             setattr(m_ptr, PYBIND11_MODULE_LOCAL_ID, capsule(tinfo));
         }
     }
 
     /// Helper function which tags all parents of a type using mult. inheritance
     void mark_parents_nonsimple(PyTypeObject *value) {
         auto t = reinterpret_borrow<tuple>(value->tp_bases);
         for (handle h : t) {
-            auto tinfo2 = get_type_info((PyTypeObject *) h.ptr());
-            if (tinfo2)
+            auto *tinfo2 = get_type_info((PyTypeObject *) h.ptr());
+            if (tinfo2) {
                 tinfo2->simple_type = false;
+            }
             mark_parents_nonsimple((PyTypeObject *) h.ptr());
         }
     }
 
-    void install_buffer_funcs(
-            buffer_info *(*get_buffer)(PyObject *, void *),
-            void *get_buffer_data) {
-        auto *type = (PyHeapTypeObject*) m_ptr;
-        auto tinfo = detail::get_type_info(&type->ht_type);
-
-        if (!type->ht_type.tp_as_buffer)
-            pybind11_fail(
-                "To be able to register buffer protocol support for the type '" +
-                get_fully_qualified_tp_name(tinfo->type) +
-                "' the associated class<>(..) invocation must "
-                "include the pybind11::buffer_protocol() annotation!");
+    void install_buffer_funcs(buffer_info *(*get_buffer)(PyObject *, void *),
+                              void *get_buffer_data) {
+        auto *type = (PyHeapTypeObject *) m_ptr;
+        auto *tinfo = detail::get_type_info(&type->ht_type);
+
+        if (!type->ht_type.tp_as_buffer) {
+            pybind11_fail("To be able to register buffer protocol support for the type '"
+                          + get_fully_qualified_tp_name(tinfo->type)
+                          + "' the associated class<>(..) invocation must "
+                            "include the pybind11::buffer_protocol() annotation!");
+        }
 
         tinfo->get_buffer = get_buffer;
         tinfo->get_buffer_data = get_buffer_data;
     }
 
     // rec_func must be set for either fget or fset.
     void def_property_static_impl(const char *name,
-                                  handle fget, handle fset,
+                                  handle fget,
+                                  handle fset,
                                   detail::function_record *rec_func) {
-        const auto is_static = rec_func && !(rec_func->is_method && rec_func->scope);
-        const auto has_doc = rec_func && rec_func->doc && pybind11::options::show_user_defined_docstrings();
-        auto property = handle((PyObject *) (is_static ? get_internals().static_property_type
-                                                       : &PyProperty_Type));
+        const auto is_static = (rec_func != nullptr) && !(rec_func->is_method && rec_func->scope);
+        const auto has_doc = (rec_func != nullptr) && (rec_func->doc != nullptr)
+                             && pybind11::options::show_user_defined_docstrings();
+        auto property = handle(
+            (PyObject *) (is_static ? get_internals().static_property_type : &PyProperty_Type));
         attr(name) = property(fget.ptr() ? fget : none(),
                               fset.ptr() ? fset : none(),
-                              /*deleter*/none(),
+                              /*deleter*/ none(),
                               pybind11::str(has_doc ? rec_func->doc : ""));
     }
 };
 
 /// Set the pointer to operator new if it exists. The cast is needed because it can be overloaded.
-template <typename T, typename = void_t<decltype(static_cast<void *(*)(size_t)>(T::operator new))>>
-void set_operator_new(type_record *r) { r->operator_new = &T::operator new; }
-
-template <typename> void set_operator_new(...) { }
-
-template <typename T, typename SFINAE = void> struct has_operator_delete : std::false_type { };
-template <typename T> struct has_operator_delete<T, void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>
-    : std::true_type { };
-template <typename T, typename SFINAE = void> struct has_operator_delete_size : std::false_type { };
-template <typename T> struct has_operator_delete_size<T, void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>>
-    : std::true_type { };
+template <typename T,
+          typename = void_t<decltype(static_cast<void *(*) (size_t)>(T::operator new))>>
+void set_operator_new(type_record *r) {
+    r->operator_new = &T::operator new;
+}
+
+template <typename>
+void set_operator_new(...) {}
+
+template <typename T, typename SFINAE = void>
+struct has_operator_delete : std::false_type {};
+template <typename T>
+struct has_operator_delete<T, void_t<decltype(static_cast<void (*)(void *)>(T::operator delete))>>
+    : std::true_type {};
+template <typename T, typename SFINAE = void>
+struct has_operator_delete_size : std::false_type {};
+template <typename T>
+struct has_operator_delete_size<
+    T,
+    void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>> : std::true_type {
+};
 /// Call class-specific delete if it exists or global otherwise. Can also be an overload set.
 template <typename T, enable_if_t<has_operator_delete<T>::value, int> = 0>
-void call_operator_delete(T *p, size_t, size_t) { T::operator delete(p); }
-template <typename T, enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int> = 0>
-void call_operator_delete(T *p, size_t s, size_t) { T::operator delete(p, s); }
+void call_operator_delete(T *p, size_t, size_t) {
+    T::operator delete(p);
+}
+template <
+    typename T,
+    enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int> = 0>
+void call_operator_delete(T *p, size_t s, size_t) {
+    T::operator delete(p, s);
+}
 
 inline void call_operator_delete(void *p, size_t s, size_t a) {
-    (void)s; (void)a;
-    #if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
-        if (a > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
-            #ifdef __cpp_sized_deallocation
-                ::operator delete(p, s, std::align_val_t(a));
-            #else
-                ::operator delete(p, std::align_val_t(a));
-            #endif
-            return;
-        }
-    #endif
-    #ifdef __cpp_sized_deallocation
-        ::operator delete(p, s);
-    #else
-        ::operator delete(p);
-    #endif
+    (void) s;
+    (void) a;
+#if defined(__cpp_aligned_new) && (!defined(_MSC_VER) || _MSC_VER >= 1912)
+    if (a > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
+#    ifdef __cpp_sized_deallocation
+        ::operator delete(p, s, std::align_val_t(a));
+#    else
+        ::operator delete(p, std::align_val_t(a));
+#    endif
+        return;
+    }
+#endif
+#ifdef __cpp_sized_deallocation
+    ::operator delete(p, s);
+#else
+    ::operator delete(p);
+#endif
 }
 
-inline void add_class_method(object& cls, const char *name_, const cpp_function &cf) {
+inline void add_class_method(object &cls, const char *name_, const cpp_function &cf) {
     cls.attr(cf.name()) = cf;
-    if (strcmp(name_, "__eq__") == 0 && !cls.attr("__dict__").contains("__hash__")) {
-      cls.attr("__hash__") = none();
+    if (std::strcmp(name_, "__eq__") == 0 && !cls.attr("__dict__").contains("__hash__")) {
+        cls.attr("__hash__") = none();
     }
 }
 
 PYBIND11_NAMESPACE_END(detail)
 
 /// Given a pointer to a member function, cast it to its `Derived` version.
 /// Forward everything else unchanged.
 template <typename /*Derived*/, typename F>
-auto method_adaptor(F &&f) -> decltype(std::forward<F>(f)) { return std::forward<F>(f); }
+auto method_adaptor(F &&f) -> decltype(std::forward<F>(f)) {
+    return std::forward<F>(f);
+}
 
 template <typename Derived, typename Return, typename Class, typename... Args>
 auto method_adaptor(Return (Class::*pmf)(Args...)) -> Return (Derived::*)(Args...) {
-    static_assert(detail::is_accessible_base_of<Class, Derived>::value,
+    static_assert(
+        detail::is_accessible_base_of<Class, Derived>::value,
         "Cannot bind an inaccessible base class method; use a lambda definition instead");
     return pmf;
 }
 
 template <typename Derived, typename Return, typename Class, typename... Args>
 auto method_adaptor(Return (Class::*pmf)(Args...) const) -> Return (Derived::*)(Args...) const {
-    static_assert(detail::is_accessible_base_of<Class, Derived>::value,
+    static_assert(
+        detail::is_accessible_base_of<Class, Derived>::value,
         "Cannot bind an inaccessible base class method; use a lambda definition instead");
     return pmf;
 }
 
 template <typename type_, typename... options>
 class class_ : public detail::generic_type {
-    template <typename T> using is_holder = detail::is_holder_type<type_, T>;
-    template <typename T> using is_subtype = detail::is_strict_base_of<type_, T>;
-    template <typename T> using is_base = detail::is_strict_base_of<T, type_>;
+    template <typename T>
+    using is_holder = detail::is_holder_type<type_, T>;
+    template <typename T>
+    using is_subtype = detail::is_strict_base_of<type_, T>;
+    template <typename T>
+    using is_base = detail::is_strict_base_of<T, type_>;
     // struct instead of using here to help MSVC:
-    template <typename T> struct is_valid_class_option :
-        detail::any_of<is_holder<T>, is_subtype<T>, is_base<T>> {};
+    template <typename T>
+    struct is_valid_class_option : detail::any_of<is_holder<T>, is_subtype<T>, is_base<T>> {};
 
 public:
     using type = type_;
     using type_alias = detail::exactly_one_t<is_subtype, void, options...>;
     constexpr static bool has_alias = !std::is_void<type_alias>::value;
     using holder_type = detail::exactly_one_t<is_holder, std::unique_ptr<type>, options...>;
 
     static_assert(detail::all_of<is_valid_class_option<options>...>::value,
-            "Unknown/invalid class_ template parameters provided");
+                  "Unknown/invalid class_ template parameters provided");
 
     static_assert(!has_alias || std::is_polymorphic<type>::value,
-            "Cannot use an alias class with a non-polymorphic type");
+                  "Cannot use an alias class with a non-polymorphic type");
 
     PYBIND11_OBJECT(class_, generic_type, PyType_Check)
 
     template <typename... Extra>
-    class_(handle scope, const char *name, const Extra &... extra) {
+    class_(handle scope, const char *name, const Extra &...extra) {
         using namespace detail;
 
         // MI can only be specified via class_ template options, not constructor parameters
         static_assert(
             none_of<is_pyobject<Extra>...>::value || // no base class arguments, or:
-            (   constexpr_sum(is_pyobject<Extra>::value...) == 1 && // Exactly one base
-                constexpr_sum(is_base<options>::value...)   == 0 && // no template option bases
-                none_of<std::is_same<multiple_inheritance, Extra>...>::value), // no multiple_inheritance attr
+                (constexpr_sum(is_pyobject<Extra>::value...) == 1 && // Exactly one base
+                 constexpr_sum(is_base<options>::value...) == 0 &&   // no template option bases
+                 // no multiple_inheritance attr
+                 none_of<std::is_same<multiple_inheritance, Extra>...>::value),
             "Error: multiple inheritance bases must be specified via class_ template options");
 
         type_record record;
         record.scope = scope;
         record.name = name;
         record.type = &typeid(type);
         record.type_size = sizeof(conditional_t<has_alias, type_alias, type>);
-        record.type_align = alignof(conditional_t<has_alias, type_alias, type>&);
+        record.type_align = alignof(conditional_t<has_alias, type_alias, type> &);
         record.holder_size = sizeof(holder_type);
         record.init_instance = init_instance;
         record.dealloc = dealloc;
         record.default_holder = detail::is_instantiation<std::unique_ptr, holder_type>::value;
 
         set_operator_new<type>(&record);
 
@@ -1242,258 +1552,316 @@
 
         /* Process optional arguments, if any */
         process_attributes<Extra...>::init(extra..., &record);
 
         generic_type::initialize(record);
 
         if (has_alias) {
-            auto &instances = record.module_local ? registered_local_types_cpp() : get_internals().registered_types_cpp;
-            instances[std::type_index(typeid(type_alias))] = instances[std::type_index(typeid(type))];
+            auto &instances = record.module_local ? get_local_internals().registered_types_cpp
+                                                  : get_internals().registered_types_cpp;
+            instances[std::type_index(typeid(type_alias))]
+                = instances[std::type_index(typeid(type))];
         }
     }
 
     template <typename Base, detail::enable_if_t<is_base<Base>::value, int> = 0>
     static void add_base(detail::type_record &rec) {
         rec.add_base(typeid(Base), [](void *src) -> void * {
             return static_cast<Base *>(reinterpret_cast<type *>(src));
         });
     }
 
     template <typename Base, detail::enable_if_t<!is_base<Base>::value, int> = 0>
-    static void add_base(detail::type_record &) { }
+    static void add_base(detail::type_record &) {}
 
     template <typename Func, typename... Extra>
-    class_ &def(const char *name_, Func&& f, const Extra&... extra) {
-        cpp_function cf(method_adaptor<type>(std::forward<Func>(f)), name(name_), is_method(*this),
-                        sibling(getattr(*this, name_, none())), extra...);
+    class_ &def(const char *name_, Func &&f, const Extra &...extra) {
+        cpp_function cf(method_adaptor<type>(std::forward<Func>(f)),
+                        name(name_),
+                        is_method(*this),
+                        sibling(getattr(*this, name_, none())),
+                        extra...);
         add_class_method(*this, name_, cf);
         return *this;
     }
 
-    template <typename Func, typename... Extra> class_ &
-    def_static(const char *name_, Func &&f, const Extra&... extra) {
+    template <typename Func, typename... Extra>
+    class_ &def_static(const char *name_, Func &&f, const Extra &...extra) {
         static_assert(!std::is_member_function_pointer<Func>::value,
-                "def_static(...) called with a non-static member function pointer");
-        cpp_function cf(std::forward<Func>(f), name(name_), scope(*this),
-                        sibling(getattr(*this, name_, none())), extra...);
+                      "def_static(...) called with a non-static member function pointer");
+        cpp_function cf(std::forward<Func>(f),
+                        name(name_),
+                        scope(*this),
+                        sibling(getattr(*this, name_, none())),
+                        extra...);
         attr(cf.name()) = staticmethod(cf);
         return *this;
     }
 
     template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ &def(const detail::op_<id, ot, L, R> &op, const Extra&... extra) {
+    class_ &def(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {
         op.execute(*this, extra...);
         return *this;
     }
 
     template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ & def_cast(const detail::op_<id, ot, L, R> &op, const Extra&... extra) {
+    class_ &def_cast(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {
         op.execute_cast(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(const detail::initimpl::constructor<Args...> &init, const Extra&... extra) {
+    class_ &def(const detail::initimpl::constructor<Args...> &init, const Extra &...extra) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(init);
         init.execute(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(const detail::initimpl::alias_constructor<Args...> &init, const Extra&... extra) {
+    class_ &def(const detail::initimpl::alias_constructor<Args...> &init, const Extra &...extra) {
+        PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(init);
         init.execute(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
-    class_ &def(detail::initimpl::factory<Args...> &&init, const Extra&... extra) {
+    class_ &def(detail::initimpl::factory<Args...> &&init, const Extra &...extra) {
         std::move(init).execute(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
     class_ &def(detail::initimpl::pickle_factory<Args...> &&pf, const Extra &...extra) {
         std::move(pf).execute(*this, extra...);
         return *this;
     }
 
-    template <typename Func> class_& def_buffer(Func &&func) {
-        struct capture { Func func; };
-        auto *ptr = new capture { std::forward<Func>(func) };
-        install_buffer_funcs([](PyObject *obj, void *ptr) -> buffer_info* {
-            detail::make_caster<type> caster;
-            if (!caster.load(obj, false))
-                return nullptr;
-            return new buffer_info(((capture *) ptr)->func(caster));
-        }, ptr);
+    template <typename Func>
+    class_ &def_buffer(Func &&func) {
+        struct capture {
+            Func func;
+        };
+        auto *ptr = new capture{std::forward<Func>(func)};
+        install_buffer_funcs(
+            [](PyObject *obj, void *ptr) -> buffer_info * {
+                detail::make_caster<type> caster;
+                if (!caster.load(obj, false)) {
+                    return nullptr;
+                }
+                return new buffer_info(((capture *) ptr)->func(caster));
+            },
+            ptr);
+        weakref(m_ptr, cpp_function([ptr](handle wr) {
+                    delete ptr;
+                    wr.dec_ref();
+                }))
+            .release();
         return *this;
     }
 
     template <typename Return, typename Class, typename... Args>
     class_ &def_buffer(Return (Class::*func)(Args...)) {
-        return def_buffer([func] (type &obj) { return (obj.*func)(); });
+        return def_buffer([func](type &obj) { return (obj.*func)(); });
     }
 
     template <typename Return, typename Class, typename... Args>
     class_ &def_buffer(Return (Class::*func)(Args...) const) {
-        return def_buffer([func] (const type &obj) { return (obj.*func)(); });
+        return def_buffer([func](const type &obj) { return (obj.*func)(); });
     }
 
     template <typename C, typename D, typename... Extra>
-    class_ &def_readwrite(const char *name, D C::*pm, const Extra&... extra) {
-        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value, "def_readwrite() requires a class member (or base class member)");
-        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this)),
-                     fset([pm](type &c, const D &value) { c.*pm = value; }, is_method(*this));
+    class_ &def_readwrite(const char *name, D C::*pm, const Extra &...extra) {
+        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value,
+                      "def_readwrite() requires a class member (or base class member)");
+        cpp_function fget([pm](const type &c) -> const D & { return c.*pm; }, is_method(*this)),
+            fset([pm](type &c, const D &value) { c.*pm = value; }, is_method(*this));
         def_property(name, fget, fset, return_value_policy::reference_internal, extra...);
         return *this;
     }
 
     template <typename C, typename D, typename... Extra>
-    class_ &def_readonly(const char *name, const D C::*pm, const Extra& ...extra) {
-        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value, "def_readonly() requires a class member (or base class member)");
-        cpp_function fget([pm](const type &c) -> const D &{ return c.*pm; }, is_method(*this));
+    class_ &def_readonly(const char *name, const D C::*pm, const Extra &...extra) {
+        static_assert(std::is_same<C, type>::value || std::is_base_of<C, type>::value,
+                      "def_readonly() requires a class member (or base class member)");
+        cpp_function fget([pm](const type &c) -> const D & { return c.*pm; }, is_method(*this));
         def_property_readonly(name, fget, return_value_policy::reference_internal, extra...);
         return *this;
     }
 
     template <typename D, typename... Extra>
-    class_ &def_readwrite_static(const char *name, D *pm, const Extra& ...extra) {
-        cpp_function fget([pm](object) -> const D &{ return *pm; }, scope(*this)),
-                     fset([pm](object, const D &value) { *pm = value; }, scope(*this));
+    class_ &def_readwrite_static(const char *name, D *pm, const Extra &...extra) {
+        cpp_function fget([pm](const object &) -> const D & { return *pm; }, scope(*this)),
+            fset([pm](const object &, const D &value) { *pm = value; }, scope(*this));
         def_property_static(name, fget, fset, return_value_policy::reference, extra...);
         return *this;
     }
 
     template <typename D, typename... Extra>
-    class_ &def_readonly_static(const char *name, const D *pm, const Extra& ...extra) {
-        cpp_function fget([pm](object) -> const D &{ return *pm; }, scope(*this));
+    class_ &def_readonly_static(const char *name, const D *pm, const Extra &...extra) {
+        cpp_function fget([pm](const object &) -> const D & { return *pm; }, scope(*this));
         def_property_readonly_static(name, fget, return_value_policy::reference, extra...);
         return *this;
     }
 
     /// Uses return_value_policy::reference_internal by default
     template <typename Getter, typename... Extra>
-    class_ &def_property_readonly(const char *name, const Getter &fget, const Extra& ...extra) {
-        return def_property_readonly(name, cpp_function(method_adaptor<type>(fget)),
-                                     return_value_policy::reference_internal, extra...);
+    class_ &def_property_readonly(const char *name, const Getter &fget, const Extra &...extra) {
+        return def_property_readonly(name,
+                                     cpp_function(method_adaptor<type>(fget)),
+                                     return_value_policy::reference_internal,
+                                     extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property_readonly(const char *name, const cpp_function &fget, const Extra& ...extra) {
+    class_ &
+    def_property_readonly(const char *name, const cpp_function &fget, const Extra &...extra) {
         return def_property(name, fget, nullptr, extra...);
     }
 
     /// Uses return_value_policy::reference by default
     template <typename Getter, typename... Extra>
-    class_ &def_property_readonly_static(const char *name, const Getter &fget, const Extra& ...extra) {
-        return def_property_readonly_static(name, cpp_function(fget), return_value_policy::reference, extra...);
+    class_ &
+    def_property_readonly_static(const char *name, const Getter &fget, const Extra &...extra) {
+        return def_property_readonly_static(
+            name, cpp_function(fget), return_value_policy::reference, extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property_readonly_static(const char *name, const cpp_function &fget, const Extra& ...extra) {
+    class_ &def_property_readonly_static(const char *name,
+                                         const cpp_function &fget,
+                                         const Extra &...extra) {
         return def_property_static(name, fget, nullptr, extra...);
     }
 
     /// Uses return_value_policy::reference_internal by default
     template <typename Getter, typename Setter, typename... Extra>
-    class_ &def_property(const char *name, const Getter &fget, const Setter &fset, const Extra& ...extra) {
+    class_ &
+    def_property(const char *name, const Getter &fget, const Setter &fset, const Extra &...extra) {
         return def_property(name, fget, cpp_function(method_adaptor<type>(fset)), extra...);
     }
     template <typename Getter, typename... Extra>
-    class_ &def_property(const char *name, const Getter &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property(name, cpp_function(method_adaptor<type>(fget)), fset,
-                            return_value_policy::reference_internal, extra...);
+    class_ &def_property(const char *name,
+                         const Getter &fget,
+                         const cpp_function &fset,
+                         const Extra &...extra) {
+        return def_property(name,
+                            cpp_function(method_adaptor<type>(fget)),
+                            fset,
+                            return_value_policy::reference_internal,
+                            extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
+    class_ &def_property(const char *name,
+                         const cpp_function &fget,
+                         const cpp_function &fset,
+                         const Extra &...extra) {
         return def_property_static(name, fget, fset, is_method(*this), extra...);
     }
 
     /// Uses return_value_policy::reference by default
     template <typename Getter, typename... Extra>
-    class_ &def_property_static(const char *name, const Getter &fget, const cpp_function &fset, const Extra& ...extra) {
-        return def_property_static(name, cpp_function(fget), fset, return_value_policy::reference, extra...);
+    class_ &def_property_static(const char *name,
+                                const Getter &fget,
+                                const cpp_function &fset,
+                                const Extra &...extra) {
+        return def_property_static(
+            name, cpp_function(fget), fset, return_value_policy::reference, extra...);
     }
 
     /// Uses cpp_function's return_value_policy by default
     template <typename... Extra>
-    class_ &def_property_static(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
-        static_assert( 0 == detail::constexpr_sum(std::is_base_of<arg, Extra>::value...),
+    class_ &def_property_static(const char *name,
+                                const cpp_function &fget,
+                                const cpp_function &fset,
+                                const Extra &...extra) {
+        static_assert(0 == detail::constexpr_sum(std::is_base_of<arg, Extra>::value...),
                       "Argument annotations are not allowed for properties");
         auto rec_fget = get_function_record(fget), rec_fset = get_function_record(fset);
         auto *rec_active = rec_fget;
         if (rec_fget) {
-           char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific documentation string */
-           detail::process_attributes<Extra...>::init(extra..., rec_fget);
-           if (rec_fget->doc && rec_fget->doc != doc_prev) {
-              free(doc_prev);
-              rec_fget->doc = strdup(rec_fget->doc);
-           }
+            char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific
+                                               documentation string */
+            detail::process_attributes<Extra...>::init(extra..., rec_fget);
+            if (rec_fget->doc && rec_fget->doc != doc_prev) {
+                std::free(doc_prev);
+                rec_fget->doc = PYBIND11_COMPAT_STRDUP(rec_fget->doc);
+            }
         }
         if (rec_fset) {
             char *doc_prev = rec_fset->doc;
             detail::process_attributes<Extra...>::init(extra..., rec_fset);
             if (rec_fset->doc && rec_fset->doc != doc_prev) {
-                free(doc_prev);
-                rec_fset->doc = strdup(rec_fset->doc);
+                std::free(doc_prev);
+                rec_fset->doc = PYBIND11_COMPAT_STRDUP(rec_fset->doc);
+            }
+            if (!rec_active) {
+                rec_active = rec_fset;
             }
-            if (! rec_active) rec_active = rec_fset;
         }
         def_property_static_impl(name, fget, fset, rec_active);
         return *this;
     }
 
 private:
     /// Initialize holder object, variant 1: object derives from enable_shared_from_this
     template <typename T>
-    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
-            const holder_type * /* unused */, const std::enable_shared_from_this<T> * /* dummy */) {
-        try {
-            auto sh = std::dynamic_pointer_cast<typename holder_type::element_type>(
-                    v_h.value_ptr<type>()->shared_from_this());
-            if (sh) {
-                new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(sh));
-                v_h.set_holder_constructed();
-            }
-        } catch (const std::bad_weak_ptr &) {}
+    static void init_holder(detail::instance *inst,
+                            detail::value_and_holder &v_h,
+                            const holder_type * /* unused */,
+                            const std::enable_shared_from_this<T> * /* dummy */) {
+
+        auto sh = std::dynamic_pointer_cast<typename holder_type::element_type>(
+            detail::try_get_shared_from_this(v_h.value_ptr<type>()));
+        if (sh) {
+            new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(sh));
+            v_h.set_holder_constructed();
+        }
 
         if (!v_h.holder_constructed() && inst->owned) {
             new (std::addressof(v_h.holder<holder_type>())) holder_type(v_h.value_ptr<type>());
             v_h.set_holder_constructed();
         }
     }
 
     static void init_holder_from_existing(const detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, std::true_type /*is_copy_constructible*/) {
-        new (std::addressof(v_h.holder<holder_type>())) holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));
+                                          const holder_type *holder_ptr,
+                                          std::true_type /*is_copy_constructible*/) {
+        new (std::addressof(v_h.holder<holder_type>()))
+            holder_type(*reinterpret_cast<const holder_type *>(holder_ptr));
     }
 
     static void init_holder_from_existing(const detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, std::false_type /*is_copy_constructible*/) {
-        new (std::addressof(v_h.holder<holder_type>())) holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));
+                                          const holder_type *holder_ptr,
+                                          std::false_type /*is_copy_constructible*/) {
+        new (std::addressof(v_h.holder<holder_type>()))
+            holder_type(std::move(*const_cast<holder_type *>(holder_ptr)));
     }
 
-    /// Initialize holder object, variant 2: try to construct from existing holder object, if possible
-    static void init_holder(detail::instance *inst, detail::value_and_holder &v_h,
-            const holder_type *holder_ptr, const void * /* dummy -- not enable_shared_from_this<T>) */) {
+    /// Initialize holder object, variant 2: try to construct from existing holder object, if
+    /// possible
+    static void init_holder(detail::instance *inst,
+                            detail::value_and_holder &v_h,
+                            const holder_type *holder_ptr,
+                            const void * /* dummy -- not enable_shared_from_this<T>) */) {
         if (holder_ptr) {
             init_holder_from_existing(v_h, holder_ptr, std::is_copy_constructible<holder_type>());
             v_h.set_holder_constructed();
         } else if (inst->owned || detail::always_construct_holder<holder_type>::value) {
             new (std::addressof(v_h.holder<holder_type>())) holder_type(v_h.value_ptr<type>());
             v_h.set_holder_constructed();
         }
     }
 
     /// Performs instance initialization including constructing a holder and registering the known
-    /// instance.  Should be called as soon as the `type` value_ptr is set for an instance.  Takes an
-    /// optional pointer to an existing holder to use; if not specified and the instance is
+    /// instance.  Should be called as soon as the `type` value_ptr is set for an instance.  Takes
+    /// an optional pointer to an existing holder to use; if not specified and the instance is
     /// `.owned`, a new holder will be constructed to manage the value pointer.
     static void init_instance(detail::instance *inst, const void *holder_ptr) {
         auto v_h = inst->get_value_and_holder(detail::get_type_info(typeid(type)));
         if (!v_h.instance_registered()) {
             register_instance(inst, v_h.value_ptr(), v_h.type);
             v_h.set_instance_registered();
         }
@@ -1508,43 +1876,50 @@
         // If we don't, the Python API will exit with an exception, and pybind11 will
         // throw error_already_set from the C++ destructor which is forbidden and triggers
         // std::terminate().
         error_scope scope;
         if (v_h.holder_constructed()) {
             v_h.holder<holder_type>().~holder_type();
             v_h.set_holder_constructed(false);
-        }
-        else {
-            detail::call_operator_delete(v_h.value_ptr<type>(),
-                v_h.type->type_size,
-                v_h.type->type_align
-            );
+        } else {
+            detail::call_operator_delete(
+                v_h.value_ptr<type>(), v_h.type->type_size, v_h.type->type_align);
         }
         v_h.value_ptr() = nullptr;
     }
 
     static detail::function_record *get_function_record(handle h) {
         h = detail::get_function(h);
-        return h ? (detail::function_record *) reinterpret_borrow<capsule>(PyCFunction_GET_SELF(h.ptr()))
+        return h ? (detail::function_record *) reinterpret_borrow<capsule>(
+                   PyCFunction_GET_SELF(h.ptr()))
                  : nullptr;
     }
 };
 
 /// Binds an existing constructor taking arguments Args...
-template <typename... Args> detail::initimpl::constructor<Args...> init() { return {}; }
+template <typename... Args>
+detail::initimpl::constructor<Args...> init() {
+    return {};
+}
 /// Like `init<Args...>()`, but the instance is always constructed through the alias class (even
 /// when not inheriting on the Python side).
-template <typename... Args> detail::initimpl::alias_constructor<Args...> init_alias() { return {}; }
+template <typename... Args>
+detail::initimpl::alias_constructor<Args...> init_alias() {
+    return {};
+}
 
 /// Binds a factory function as a constructor
 template <typename Func, typename Ret = detail::initimpl::factory<Func>>
-Ret init(Func &&f) { return {std::forward<Func>(f)}; }
+Ret init(Func &&f) {
+    return {std::forward<Func>(f)};
+}
 
-/// Dual-argument factory function: the first function is called when no alias is needed, the second
-/// when an alias is needed (i.e. due to python-side inheritance).  Arguments must be identical.
+/// Dual-argument factory function: the first function is called when no alias is needed, the
+/// second when an alias is needed (i.e. due to python-side inheritance).  Arguments must be
+/// identical.
 template <typename CFunc, typename AFunc, typename Ret = detail::initimpl::factory<CFunc, AFunc>>
 Ret init(CFunc &&c, AFunc &&a) {
     return {std::forward<CFunc>(c), std::forward<AFunc>(a)};
 }
 
 /// Binds pickling functions `__getstate__` and `__setstate__` and ensures that the type
 /// returned by `__getstate__` is the same as the argument accepted by `__setstate__`.
@@ -1554,451 +1929,679 @@
 }
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 inline str enum_name(handle arg) {
     dict entries = arg.get_type().attr("__entries");
     for (auto kv : entries) {
-        if (handle(kv.second[int_(0)]).equal(arg))
+        if (handle(kv.second[int_(0)]).equal(arg)) {
             return pybind11::str(kv.first);
+        }
     }
     return "???";
 }
 
 struct enum_base {
-    enum_base(handle base, handle parent) : m_base(base), m_parent(parent) { }
+    enum_base(const handle &base, const handle &parent) : m_base(base), m_parent(parent) {}
 
     PYBIND11_NOINLINE void init(bool is_arithmetic, bool is_convertible) {
         m_base.attr("__entries") = dict();
         auto property = handle((PyObject *) &PyProperty_Type);
         auto static_property = handle((PyObject *) get_internals().static_property_type);
 
         m_base.attr("__repr__") = cpp_function(
-            [](object arg) -> str {
+            [](const object &arg) -> str {
                 handle type = type::handle_of(arg);
                 object type_name = type.attr("__name__");
                 return pybind11::str("<{}.{}: {}>").format(type_name, enum_name(arg), int_(arg));
-            }, name("__repr__"), is_method(m_base)
-        );
+            },
+            name("__repr__"),
+            is_method(m_base));
 
         m_base.attr("name") = property(cpp_function(&enum_name, name("name"), is_method(m_base)));
 
         m_base.attr("__str__") = cpp_function(
             [](handle arg) -> str {
                 object type_name = type::handle_of(arg).attr("__name__");
                 return pybind11::str("{}.{}").format(type_name, enum_name(arg));
-            }, name("name"), is_method(m_base)
-        );
-
-        m_base.attr("__doc__") = static_property(cpp_function(
-            [](handle arg) -> std::string {
-                std::string docstring;
-                dict entries = arg.attr("__entries");
-                if (((PyTypeObject *) arg.ptr())->tp_doc)
-                    docstring += std::string(((PyTypeObject *) arg.ptr())->tp_doc) + "\n\n";
-                docstring += "Members:";
-                for (auto kv : entries) {
-                    auto key = std::string(pybind11::str(kv.first));
-                    auto comment = kv.second[int_(1)];
-                    docstring += "\n\n  " + key;
-                    if (!comment.is_none())
-                        docstring += " : " + (std::string) pybind11::str(comment);
-                }
-                return docstring;
-            }, name("__doc__")
-        ), none(), none(), "");
+            },
+            name("name"),
+            is_method(m_base));
+
+        m_base.attr("__doc__") = static_property(
+            cpp_function(
+                [](handle arg) -> std::string {
+                    std::string docstring;
+                    dict entries = arg.attr("__entries");
+                    if (((PyTypeObject *) arg.ptr())->tp_doc) {
+                        docstring += std::string(((PyTypeObject *) arg.ptr())->tp_doc) + "\n\n";
+                    }
+                    docstring += "Members:";
+                    for (auto kv : entries) {
+                        auto key = std::string(pybind11::str(kv.first));
+                        auto comment = kv.second[int_(1)];
+                        docstring += "\n\n  " + key;
+                        if (!comment.is_none()) {
+                            docstring += " : " + (std::string) pybind11::str(comment);
+                        }
+                    }
+                    return docstring;
+                },
+                name("__doc__")),
+            none(),
+            none(),
+            "");
 
         m_base.attr("__members__") = static_property(cpp_function(
-            [](handle arg) -> dict {
-                dict entries = arg.attr("__entries"), m;
-                for (auto kv : entries)
-                    m[kv.first] = kv.second[int_(0)];
-                return m;
-            }, name("__members__")), none(), none(), ""
-        );
-
-        #define PYBIND11_ENUM_OP_STRICT(op, expr, strict_behavior)                     \
-            m_base.attr(op) = cpp_function(                                            \
-                [](object a, object b) {                                               \
-                    if (!type::handle_of(a).is(type::handle_of(b)))                    \
-                        strict_behavior;                                               \
-                    return expr;                                                       \
-                },                                                                     \
-                name(op), is_method(m_base))
-
-        #define PYBIND11_ENUM_OP_CONV(op, expr)                                        \
-            m_base.attr(op) = cpp_function(                                            \
-                [](object a_, object b_) {                                             \
-                    int_ a(a_), b(b_);                                                 \
-                    return expr;                                                       \
-                },                                                                     \
-                name(op), is_method(m_base))
-
-        #define PYBIND11_ENUM_OP_CONV_LHS(op, expr)                                    \
-            m_base.attr(op) = cpp_function(                                            \
-                [](object a_, object b) {                                              \
-                    int_ a(a_);                                                        \
-                    return expr;                                                       \
-                },                                                                     \
-                name(op), is_method(m_base))
+                                                         [](handle arg) -> dict {
+                                                             dict entries = arg.attr("__entries"),
+                                                                  m;
+                                                             for (auto kv : entries) {
+                                                                 m[kv.first] = kv.second[int_(0)];
+                                                             }
+                                                             return m;
+                                                         },
+                                                         name("__members__")),
+                                                     none(),
+                                                     none(),
+                                                     "");
+
+#define PYBIND11_ENUM_OP_STRICT(op, expr, strict_behavior)                                        \
+    m_base.attr(op) = cpp_function(                                                               \
+        [](const object &a, const object &b) {                                                    \
+            if (!type::handle_of(a).is(type::handle_of(b)))                                       \
+                strict_behavior; /* NOLINT(bugprone-macro-parentheses) */                         \
+            return expr;                                                                          \
+        },                                                                                        \
+        name(op),                                                                                 \
+        is_method(m_base),                                                                        \
+        arg("other"))
+
+#define PYBIND11_ENUM_OP_CONV(op, expr)                                                           \
+    m_base.attr(op) = cpp_function(                                                               \
+        [](const object &a_, const object &b_) {                                                  \
+            int_ a(a_), b(b_);                                                                    \
+            return expr;                                                                          \
+        },                                                                                        \
+        name(op),                                                                                 \
+        is_method(m_base),                                                                        \
+        arg("other"))
+
+#define PYBIND11_ENUM_OP_CONV_LHS(op, expr)                                                       \
+    m_base.attr(op) = cpp_function(                                                               \
+        [](const object &a_, const object &b) {                                                   \
+            int_ a(a_);                                                                           \
+            return expr;                                                                          \
+        },                                                                                        \
+        name(op),                                                                                 \
+        is_method(m_base),                                                                        \
+        arg("other"))
 
         if (is_convertible) {
-            PYBIND11_ENUM_OP_CONV_LHS("__eq__", !b.is_none() &&  a.equal(b));
-            PYBIND11_ENUM_OP_CONV_LHS("__ne__",  b.is_none() || !a.equal(b));
+            PYBIND11_ENUM_OP_CONV_LHS("__eq__", !b.is_none() && a.equal(b));
+            PYBIND11_ENUM_OP_CONV_LHS("__ne__", b.is_none() || !a.equal(b));
 
             if (is_arithmetic) {
-                PYBIND11_ENUM_OP_CONV("__lt__",   a <  b);
-                PYBIND11_ENUM_OP_CONV("__gt__",   a >  b);
-                PYBIND11_ENUM_OP_CONV("__le__",   a <= b);
-                PYBIND11_ENUM_OP_CONV("__ge__",   a >= b);
-                PYBIND11_ENUM_OP_CONV("__and__",  a &  b);
-                PYBIND11_ENUM_OP_CONV("__rand__", a &  b);
-                PYBIND11_ENUM_OP_CONV("__or__",   a |  b);
-                PYBIND11_ENUM_OP_CONV("__ror__",  a |  b);
-                PYBIND11_ENUM_OP_CONV("__xor__",  a ^  b);
-                PYBIND11_ENUM_OP_CONV("__rxor__", a ^  b);
-                m_base.attr("__invert__") = cpp_function(
-                    [](object arg) { return ~(int_(arg)); }, name("__invert__"), is_method(m_base));
+                PYBIND11_ENUM_OP_CONV("__lt__", a < b);
+                PYBIND11_ENUM_OP_CONV("__gt__", a > b);
+                PYBIND11_ENUM_OP_CONV("__le__", a <= b);
+                PYBIND11_ENUM_OP_CONV("__ge__", a >= b);
+                PYBIND11_ENUM_OP_CONV("__and__", a & b);
+                PYBIND11_ENUM_OP_CONV("__rand__", a & b);
+                PYBIND11_ENUM_OP_CONV("__or__", a | b);
+                PYBIND11_ENUM_OP_CONV("__ror__", a | b);
+                PYBIND11_ENUM_OP_CONV("__xor__", a ^ b);
+                PYBIND11_ENUM_OP_CONV("__rxor__", a ^ b);
+                m_base.attr("__invert__")
+                    = cpp_function([](const object &arg) { return ~(int_(arg)); },
+                                   name("__invert__"),
+                                   is_method(m_base));
             }
         } else {
-            PYBIND11_ENUM_OP_STRICT("__eq__",  int_(a).equal(int_(b)), return false);
+            PYBIND11_ENUM_OP_STRICT("__eq__", int_(a).equal(int_(b)), return false);
             PYBIND11_ENUM_OP_STRICT("__ne__", !int_(a).equal(int_(b)), return true);
 
             if (is_arithmetic) {
-                #define PYBIND11_THROW throw type_error("Expected an enumeration of matching type!");
-                PYBIND11_ENUM_OP_STRICT("__lt__", int_(a) <  int_(b), PYBIND11_THROW);
-                PYBIND11_ENUM_OP_STRICT("__gt__", int_(a) >  int_(b), PYBIND11_THROW);
+#define PYBIND11_THROW throw type_error("Expected an enumeration of matching type!");
+                PYBIND11_ENUM_OP_STRICT("__lt__", int_(a) < int_(b), PYBIND11_THROW);
+                PYBIND11_ENUM_OP_STRICT("__gt__", int_(a) > int_(b), PYBIND11_THROW);
                 PYBIND11_ENUM_OP_STRICT("__le__", int_(a) <= int_(b), PYBIND11_THROW);
                 PYBIND11_ENUM_OP_STRICT("__ge__", int_(a) >= int_(b), PYBIND11_THROW);
-                #undef PYBIND11_THROW
+#undef PYBIND11_THROW
             }
         }
 
-        #undef PYBIND11_ENUM_OP_CONV_LHS
-        #undef PYBIND11_ENUM_OP_CONV
-        #undef PYBIND11_ENUM_OP_STRICT
+#undef PYBIND11_ENUM_OP_CONV_LHS
+#undef PYBIND11_ENUM_OP_CONV
+#undef PYBIND11_ENUM_OP_STRICT
 
         m_base.attr("__getstate__") = cpp_function(
-            [](object arg) { return int_(arg); }, name("__getstate__"), is_method(m_base));
+            [](const object &arg) { return int_(arg); }, name("__getstate__"), is_method(m_base));
 
         m_base.attr("__hash__") = cpp_function(
-            [](object arg) { return int_(arg); }, name("__hash__"), is_method(m_base));
+            [](const object &arg) { return int_(arg); }, name("__hash__"), is_method(m_base));
     }
 
-    PYBIND11_NOINLINE void value(char const* name_, object value, const char *doc = nullptr) {
+    PYBIND11_NOINLINE void value(char const *name_, object value, const char *doc = nullptr) {
         dict entries = m_base.attr("__entries");
         str name(name_);
         if (entries.contains(name)) {
             std::string type_name = (std::string) str(m_base.attr("__name__"));
-            throw value_error(type_name + ": element \"" + std::string(name_) + "\" already exists!");
+            throw value_error(type_name + ": element \"" + std::string(name_)
+                              + "\" already exists!");
         }
 
         entries[name] = std::make_pair(value, doc);
         m_base.attr(name) = value;
     }
 
     PYBIND11_NOINLINE void export_values() {
         dict entries = m_base.attr("__entries");
-        for (auto kv : entries)
+        for (auto kv : entries) {
             m_parent.attr(kv.first) = kv.second[int_(0)];
+        }
     }
 
     handle m_base;
     handle m_parent;
 };
 
+template <bool is_signed, size_t length>
+struct equivalent_integer {};
+template <>
+struct equivalent_integer<true, 1> {
+    using type = int8_t;
+};
+template <>
+struct equivalent_integer<false, 1> {
+    using type = uint8_t;
+};
+template <>
+struct equivalent_integer<true, 2> {
+    using type = int16_t;
+};
+template <>
+struct equivalent_integer<false, 2> {
+    using type = uint16_t;
+};
+template <>
+struct equivalent_integer<true, 4> {
+    using type = int32_t;
+};
+template <>
+struct equivalent_integer<false, 4> {
+    using type = uint32_t;
+};
+template <>
+struct equivalent_integer<true, 8> {
+    using type = int64_t;
+};
+template <>
+struct equivalent_integer<false, 8> {
+    using type = uint64_t;
+};
+
+template <typename IntLike>
+using equivalent_integer_t =
+    typename equivalent_integer<std::is_signed<IntLike>::value, sizeof(IntLike)>::type;
+
 PYBIND11_NAMESPACE_END(detail)
 
 /// Binds C++ enumerations and enumeration classes to Python
-template <typename Type> class enum_ : public class_<Type> {
+template <typename Type>
+class enum_ : public class_<Type> {
 public:
     using Base = class_<Type>;
-    using Base::def;
     using Base::attr;
+    using Base::def;
     using Base::def_property_readonly;
     using Base::def_property_readonly_static;
-    using Scalar = typename std::underlying_type<Type>::type;
+    using Underlying = typename std::underlying_type<Type>::type;
+    // Scalar is the integer representation of underlying type
+    using Scalar = detail::conditional_t<detail::any_of<detail::is_std_char_type<Underlying>,
+                                                        std::is_same<Underlying, bool>>::value,
+                                         detail::equivalent_integer_t<Underlying>,
+                                         Underlying>;
 
     template <typename... Extra>
-    enum_(const handle &scope, const char *name, const Extra&... extra)
-      : class_<Type>(scope, name, extra...), m_base(*this, scope) {
+    enum_(const handle &scope, const char *name, const Extra &...extra)
+        : class_<Type>(scope, name, extra...), m_base(*this, scope) {
         constexpr bool is_arithmetic = detail::any_of<std::is_same<arithmetic, Extra>...>::value;
-        constexpr bool is_convertible = std::is_convertible<Type, Scalar>::value;
+        constexpr bool is_convertible = std::is_convertible<Type, Underlying>::value;
         m_base.init(is_arithmetic, is_convertible);
 
-        def(init([](Scalar i) { return static_cast<Type>(i); }));
+        def(init([](Scalar i) { return static_cast<Type>(i); }), arg("value"));
+        def_property_readonly("value", [](Type value) { return (Scalar) value; });
         def("__int__", [](Type value) { return (Scalar) value; });
-        #if PY_MAJOR_VERSION < 3
-            def("__long__", [](Type value) { return (Scalar) value; });
-        #endif
-        #if PY_MAJOR_VERSION > 3 || (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 8)
-            def("__index__", [](Type value) { return (Scalar) value; });
-        #endif
-
+        def("__index__", [](Type value) { return (Scalar) value; });
+#if PY_MAJOR_VERSION < 3
+        def("__long__", [](Type value) { return (Scalar) value; });
+#endif
         attr("__setstate__") = cpp_function(
             [](detail::value_and_holder &v_h, Scalar arg) {
-                detail::initimpl::setstate<Base>(v_h, static_cast<Type>(arg),
-                        Py_TYPE(v_h.inst) != v_h.type->type); },
+                detail::initimpl::setstate<Base>(
+                    v_h, static_cast<Type>(arg), Py_TYPE(v_h.inst) != v_h.type->type);
+            },
             detail::is_new_style_constructor(),
-            pybind11::name("__setstate__"), is_method(*this));
+            pybind11::name("__setstate__"),
+            is_method(*this),
+            arg("state"));
     }
 
     /// Export enumeration entries into the parent scope
-    enum_& export_values() {
+    enum_ &export_values() {
         m_base.export_values();
         return *this;
     }
 
     /// Add an enumeration entry
-    enum_& value(char const* name, Type value, const char *doc = nullptr) {
+    enum_ &value(char const *name, Type value, const char *doc = nullptr) {
         m_base.value(name, pybind11::cast(value, return_value_policy::copy), doc);
         return *this;
     }
 
 private:
     detail::enum_base m_base;
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-
-inline void keep_alive_impl(handle nurse, handle patient) {
-    if (!nurse || !patient)
+PYBIND11_NOINLINE void keep_alive_impl(handle nurse, handle patient) {
+    if (!nurse || !patient) {
         pybind11_fail("Could not activate keep_alive!");
+    }
 
-    if (patient.is_none() || nurse.is_none())
+    if (patient.is_none() || nurse.is_none()) {
         return; /* Nothing to keep alive or nothing to be kept alive by */
+    }
 
     auto tinfo = all_type_info(Py_TYPE(nurse.ptr()));
     if (!tinfo.empty()) {
         /* It's a pybind-registered type, so we can store the patient in the
          * internal list. */
         add_patient(nurse.ptr(), patient.ptr());
-    }
-    else {
+    } else {
         /* Fall back to clever approach based on weak references taken from
          * Boost.Python. This is not used for pybind-registered types because
          * the objects can be destroyed out-of-order in a GC pass. */
-        cpp_function disable_lifesupport(
-            [patient](handle weakref) { patient.dec_ref(); weakref.dec_ref(); });
+        cpp_function disable_lifesupport([patient](handle weakref) {
+            patient.dec_ref();
+            weakref.dec_ref();
+        });
 
         weakref wr(nurse, disable_lifesupport);
 
         patient.inc_ref(); /* reference patient and leak the weak reference */
         (void) wr.release();
     }
 }
 
-PYBIND11_NOINLINE inline void keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret) {
+PYBIND11_NOINLINE void
+keep_alive_impl(size_t Nurse, size_t Patient, function_call &call, handle ret) {
     auto get_arg = [&](size_t n) {
-        if (n == 0)
+        if (n == 0) {
             return ret;
-        else if (n == 1 && call.init_self)
+        }
+        if (n == 1 && call.init_self) {
             return call.init_self;
-        else if (n <= call.args.size())
+        }
+        if (n <= call.args.size()) {
             return call.args[n - 1];
+        }
         return handle();
     };
 
     keep_alive_impl(get_arg(Nurse), get_arg(Patient));
 }
 
-inline std::pair<decltype(internals::registered_types_py)::iterator, bool> all_type_info_get_cache(PyTypeObject *type) {
-    auto res = get_internals().registered_types_py
+inline std::pair<decltype(internals::registered_types_py)::iterator, bool>
+all_type_info_get_cache(PyTypeObject *type) {
+    auto res = get_internals()
+                   .registered_types_py
 #ifdef __cpp_lib_unordered_map_try_emplace
-        .try_emplace(type);
+                   .try_emplace(type);
 #else
-        .emplace(type, std::vector<detail::type_info *>());
+                   .emplace(type, std::vector<detail::type_info *>());
 #endif
     if (res.second) {
         // New cache entry created; set up a weak reference to automatically remove it if the type
         // gets destroyed:
         weakref((PyObject *) type, cpp_function([type](handle wr) {
-            get_internals().registered_types_py.erase(type);
-            wr.dec_ref();
-        })).release();
+                    get_internals().registered_types_py.erase(type);
+
+                    // TODO consolidate the erasure code in pybind11_meta_dealloc() in class.h
+                    auto &cache = get_internals().inactive_override_cache;
+                    for (auto it = cache.begin(), last = cache.end(); it != last;) {
+                        if (it->first == reinterpret_cast<PyObject *>(type)) {
+                            it = cache.erase(it);
+                        } else {
+                            ++it;
+                        }
+                    }
+
+                    wr.dec_ref();
+                }))
+            .release();
     }
 
     return res;
 }
 
-template <typename Iterator, typename Sentinel, bool KeyIterator, return_value_policy Policy>
+/* There are a large number of apparently unused template arguments because
+ * each combination requires a separate py::class_ registration.
+ */
+template <typename Access,
+          return_value_policy Policy,
+          typename Iterator,
+          typename Sentinel,
+          typename ValueType,
+          typename... Extra>
 struct iterator_state {
     Iterator it;
     Sentinel end;
     bool first_or_done;
 };
 
-PYBIND11_NAMESPACE_END(detail)
+// Note: these helpers take the iterator by non-const reference because some
+// iterators in the wild can't be dereferenced when const. The & after Iterator
+// is required for MSVC < 16.9. SFINAE cannot be reused for result_type due to
+// bugs in ICC, NVCC, and PGI compilers. See PR #3293.
+template <typename Iterator, typename SFINAE = decltype(*std::declval<Iterator &>())>
+struct iterator_access {
+    using result_type = decltype(*std::declval<Iterator &>());
+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
+    result_type operator()(Iterator &it) const { return *it; }
+};
 
-/// Makes a python iterator from a first and past-the-end C++ InputIterator.
-template <return_value_policy Policy = return_value_policy::reference_internal,
+template <typename Iterator, typename SFINAE = decltype((*std::declval<Iterator &>()).first)>
+class iterator_key_access {
+private:
+    using pair_type = decltype(*std::declval<Iterator &>());
+
+public:
+    /* If either the pair itself or the element of the pair is a reference, we
+     * want to return a reference, otherwise a value. When the decltype
+     * expression is parenthesized it is based on the value category of the
+     * expression; otherwise it is the declared type of the pair member.
+     * The use of declval<pair_type> in the second branch rather than directly
+     * using *std::declval<Iterator &>() is a workaround for nvcc
+     * (it's not used in the first branch because going via decltype and back
+     * through declval does not perfectly preserve references).
+     */
+    using result_type
+        = conditional_t<std::is_reference<decltype(*std::declval<Iterator &>())>::value,
+                        decltype(((*std::declval<Iterator &>()).first)),
+                        decltype(std::declval<pair_type>().first)>;
+    result_type operator()(Iterator &it) const { return (*it).first; }
+};
+
+template <typename Iterator, typename SFINAE = decltype((*std::declval<Iterator &>()).second)>
+class iterator_value_access {
+private:
+    using pair_type = decltype(*std::declval<Iterator &>());
+
+public:
+    using result_type
+        = conditional_t<std::is_reference<decltype(*std::declval<Iterator &>())>::value,
+                        decltype(((*std::declval<Iterator &>()).second)),
+                        decltype(std::declval<pair_type>().second)>;
+    result_type operator()(Iterator &it) const { return (*it).second; }
+};
+
+template <typename Access,
+          return_value_policy Policy,
           typename Iterator,
           typename Sentinel,
-          typename ValueType = decltype(*std::declval<Iterator>()),
+          typename ValueType,
           typename... Extra>
-iterator make_iterator(Iterator first, Sentinel last, Extra &&... extra) {
-    typedef detail::iterator_state<Iterator, Sentinel, false, Policy> state;
+iterator make_iterator_impl(Iterator first, Sentinel last, Extra &&...extra) {
+    using state = detail::iterator_state<Access, Policy, Iterator, Sentinel, ValueType, Extra...>;
+    // TODO: state captures only the types of Extra, not the values
 
     if (!detail::get_type_info(typeid(state), false)) {
         class_<state>(handle(), "iterator", pybind11::module_local())
-            .def("__iter__", [](state &s) -> state& { return s; })
-            .def("__next__", [](state &s) -> ValueType {
-                if (!s.first_or_done)
-                    ++s.it;
-                else
-                    s.first_or_done = false;
-                if (s.it == s.end) {
-                    s.first_or_done = true;
-                    throw stop_iteration();
-                }
-                return *s.it;
-            }, std::forward<Extra>(extra)..., Policy);
+            .def("__iter__", [](state &s) -> state & { return s; })
+            .def(
+                "__next__",
+                [](state &s) -> ValueType {
+                    if (!s.first_or_done) {
+                        ++s.it;
+                    } else {
+                        s.first_or_done = false;
+                    }
+                    if (s.it == s.end) {
+                        s.first_or_done = true;
+                        throw stop_iteration();
+                    }
+                    return Access()(s.it);
+                    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
+                },
+                std::forward<Extra>(extra)...,
+                Policy);
     }
 
     return cast(state{first, last, true});
 }
 
-/// Makes an python iterator over the keys (`.first`) of a iterator over pairs from a
-/// first and past-the-end InputIterator.
+PYBIND11_NAMESPACE_END(detail)
+
+/// Makes a python iterator from a first and past-the-end C++ InputIterator.
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Iterator,
           typename Sentinel,
-          typename KeyType = decltype((*std::declval<Iterator>()).first),
+          typename ValueType = typename detail::iterator_access<Iterator>::result_type,
           typename... Extra>
-iterator make_key_iterator(Iterator first, Sentinel last, Extra &&... extra) {
-    using state = detail::iterator_state<Iterator, Sentinel, true, Policy>;
+iterator make_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+    return detail::make_iterator_impl<detail::iterator_access<Iterator>,
+                                      Policy,
+                                      Iterator,
+                                      Sentinel,
+                                      ValueType,
+                                      Extra...>(first, last, std::forward<Extra>(extra)...);
+}
 
-    if (!detail::get_type_info(typeid(state), false)) {
-        class_<state>(handle(), "iterator", pybind11::module_local())
-            .def("__iter__", [](state &s) -> state& { return s; })
-            .def("__next__", [](state &s) -> KeyType {
-                if (!s.first_or_done)
-                    ++s.it;
-                else
-                    s.first_or_done = false;
-                if (s.it == s.end) {
-                    s.first_or_done = true;
-                    throw stop_iteration();
-                }
-                return (*s.it).first;
-            }, std::forward<Extra>(extra)..., Policy);
-    }
+/// Makes a python iterator over the keys (`.first`) of a iterator over pairs from a
+/// first and past-the-end InputIterator.
+template <return_value_policy Policy = return_value_policy::reference_internal,
+          typename Iterator,
+          typename Sentinel,
+          typename KeyType = typename detail::iterator_key_access<Iterator>::result_type,
+          typename... Extra>
+iterator make_key_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+    return detail::make_iterator_impl<detail::iterator_key_access<Iterator>,
+                                      Policy,
+                                      Iterator,
+                                      Sentinel,
+                                      KeyType,
+                                      Extra...>(first, last, std::forward<Extra>(extra)...);
+}
 
-    return cast(state{first, last, true});
+/// Makes a python iterator over the values (`.second`) of a iterator over pairs from a
+/// first and past-the-end InputIterator.
+template <return_value_policy Policy = return_value_policy::reference_internal,
+          typename Iterator,
+          typename Sentinel,
+          typename ValueType = typename detail::iterator_value_access<Iterator>::result_type,
+          typename... Extra>
+iterator make_value_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+    return detail::make_iterator_impl<detail::iterator_value_access<Iterator>,
+                                      Policy,
+                                      Iterator,
+                                      Sentinel,
+                                      ValueType,
+                                      Extra...>(first, last, std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over values of an stl container or other container supporting
 /// `std::begin()`/`std::end()`
 template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Type, typename... Extra> iterator make_iterator(Type &value, Extra&&... extra) {
+          typename Type,
+          typename... Extra>
+iterator make_iterator(Type &value, Extra &&...extra) {
     return make_iterator<Policy>(std::begin(value), std::end(value), extra...);
 }
 
 /// Makes an iterator over the keys (`.first`) of a stl map-like container supporting
 /// `std::begin()`/`std::end()`
 template <return_value_policy Policy = return_value_policy::reference_internal,
-          typename Type, typename... Extra> iterator make_key_iterator(Type &value, Extra&&... extra) {
+          typename Type,
+          typename... Extra>
+iterator make_key_iterator(Type &value, Extra &&...extra) {
     return make_key_iterator<Policy>(std::begin(value), std::end(value), extra...);
 }
 
-template <typename InputType, typename OutputType> void implicitly_convertible() {
+/// Makes an iterator over the values (`.second`) of a stl map-like container supporting
+/// `std::begin()`/`std::end()`
+template <return_value_policy Policy = return_value_policy::reference_internal,
+          typename Type,
+          typename... Extra>
+iterator make_value_iterator(Type &value, Extra &&...extra) {
+    return make_value_iterator<Policy>(std::begin(value), std::end(value), extra...);
+}
+
+template <typename InputType, typename OutputType>
+void implicitly_convertible() {
     struct set_flag {
         bool &flag;
-        set_flag(bool &flag) : flag(flag) { flag = true; }
+        explicit set_flag(bool &flag_) : flag(flag_) { flag_ = true; }
         ~set_flag() { flag = false; }
     };
     auto implicit_caster = [](PyObject *obj, PyTypeObject *type) -> PyObject * {
         static bool currently_used = false;
-        if (currently_used) // implicit conversions are non-reentrant
+        if (currently_used) { // implicit conversions are non-reentrant
             return nullptr;
+        }
         set_flag flag_helper(currently_used);
-        if (!detail::make_caster<InputType>().load(obj, false))
+        if (!detail::make_caster<InputType>().load(obj, false)) {
             return nullptr;
+        }
         tuple args(1);
         args[0] = obj;
         PyObject *result = PyObject_Call((PyObject *) type, args.ptr(), nullptr);
-        if (result == nullptr)
+        if (result == nullptr) {
             PyErr_Clear();
+        }
         return result;
     };
 
-    if (auto tinfo = detail::get_type_info(typeid(OutputType)))
+    if (auto *tinfo = detail::get_type_info(typeid(OutputType))) {
         tinfo->implicit_conversions.push_back(implicit_caster);
-    else
+    } else {
         pybind11_fail("implicitly_convertible: Unable to find type " + type_id<OutputType>());
+    }
 }
 
-template <typename ExceptionTranslator>
-void register_exception_translator(ExceptionTranslator&& translator) {
+inline void register_exception_translator(ExceptionTranslator &&translator) {
     detail::get_internals().registered_exception_translators.push_front(
         std::forward<ExceptionTranslator>(translator));
 }
 
 /**
+ * Add a new module-local exception translator. Locally registered functions
+ * will be tried before any globally registered exception translators, which
+ * will only be invoked if the module-local handlers do not deal with
+ * the exception.
+ */
+inline void register_local_exception_translator(ExceptionTranslator &&translator) {
+    detail::get_local_internals().registered_exception_translators.push_front(
+        std::forward<ExceptionTranslator>(translator));
+}
+
+/**
  * Wrapper to generate a new Python exception type.
  *
  * This should only be used with PyErr_SetString for now.
  * It is not (yet) possible to use as a py::base.
  * Template type argument is reserved for future use.
  */
 template <typename type>
 class exception : public object {
 public:
     exception() = default;
     exception(handle scope, const char *name, handle base = PyExc_Exception) {
-        std::string full_name = scope.attr("__name__").cast<std::string>() +
-                                std::string(".") + name;
+        std::string full_name
+            = scope.attr("__name__").cast<std::string>() + std::string(".") + name;
         m_ptr = PyErr_NewException(const_cast<char *>(full_name.c_str()), base.ptr(), NULL);
-        if (hasattr(scope, "__dict__") && scope.attr("__dict__").contains(name))
+        if (hasattr(scope, "__dict__") && scope.attr("__dict__").contains(name)) {
             pybind11_fail("Error during initialization: multiple incompatible "
-                          "definitions with name \"" + std::string(name) + "\"");
+                          "definitions with name \""
+                          + std::string(name) + "\"");
+        }
         scope.attr(name) = *this;
     }
 
     // Sets the current python exception to this exception object with the given message
-    void operator()(const char *message) {
-        PyErr_SetString(m_ptr, message);
-    }
+    void operator()(const char *message) { PyErr_SetString(m_ptr, message); }
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 // Returns a reference to a function-local static exception object used in the simple
 // register_exception approach below.  (It would be simpler to have the static local variable
 // directly in register_exception, but that makes clang <3.5 segfault - issue #1349).
 template <typename CppException>
-exception<CppException> &get_exception_object() { static exception<CppException> ex; return ex; }
-PYBIND11_NAMESPACE_END(detail)
+exception<CppException> &get_exception_object() {
+    static exception<CppException> ex;
+    return ex;
+}
 
-/**
- * Registers a Python exception in `m` of the given `name` and installs an exception translator to
- * translate the C++ exception to the created Python exception using the exceptions what() method.
- * This is intended for simple exception translations; for more complex translation, register the
- * exception object and translator directly.
- */
+// Helper function for register_exception and register_local_exception
 template <typename CppException>
-exception<CppException> &register_exception(handle scope,
-                                            const char *name,
-                                            handle base = PyExc_Exception) {
+exception<CppException> &
+register_exception_impl(handle scope, const char *name, handle base, bool isLocal) {
     auto &ex = detail::get_exception_object<CppException>();
-    if (!ex) ex = exception<CppException>(scope, name, base);
+    if (!ex) {
+        ex = exception<CppException>(scope, name, base);
+    }
 
-    register_exception_translator([](std::exception_ptr p) {
-        if (!p) return;
+    auto register_func
+        = isLocal ? &register_local_exception_translator : &register_exception_translator;
+
+    register_func([](std::exception_ptr p) {
+        if (!p) {
+            return;
+        }
         try {
             std::rethrow_exception(p);
         } catch (const CppException &e) {
             detail::get_exception_object<CppException>()(e.what());
         }
     });
     return ex;
 }
 
+PYBIND11_NAMESPACE_END(detail)
+
+/**
+ * Registers a Python exception in `m` of the given `name` and installs a translator to
+ * translate the C++ exception to the created Python exception using the what() method.
+ * This is intended for simple exception translations; for more complex translation, register the
+ * exception object and translator directly.
+ */
+template <typename CppException>
+exception<CppException> &
+register_exception(handle scope, const char *name, handle base = PyExc_Exception) {
+    return detail::register_exception_impl<CppException>(scope, name, base, false /* isLocal */);
+}
+
+/**
+ * Registers a Python exception in `m` of the given `name` and installs a translator to
+ * translate the C++ exception to the created Python exception using the what() method.
+ * This translator will only be used for exceptions that are thrown in this module and will be
+ * tried before global exception translators, including those registered with register_exception.
+ * This is intended for simple exception translations; for more complex translation, register the
+ * exception object and translator directly.
+ */
+template <typename CppException>
+exception<CppException> &
+register_local_exception(handle scope, const char *name, handle base = PyExc_Exception) {
+    return detail::register_exception_impl<CppException>(scope, name, base, true /* isLocal */);
+}
+
 PYBIND11_NAMESPACE_BEGIN(detail)
-PYBIND11_NOINLINE inline void print(tuple args, dict kwargs) {
+PYBIND11_NOINLINE void print(const tuple &args, const dict &kwargs) {
     auto strings = tuple(args.size());
     for (size_t i = 0; i < args.size(); ++i) {
         strings[i] = str(args[i]);
     }
     auto sep = kwargs.contains("sep") ? kwargs["sep"] : cast(" ");
     auto line = sep.attr("join")(strings);
 
@@ -2017,303 +2620,198 @@
         }
     }
 
     auto write = file.attr("write");
     write(line);
     write(kwargs.contains("end") ? kwargs["end"] : cast("\n"));
 
-    if (kwargs.contains("flush") && kwargs["flush"].cast<bool>())
+    if (kwargs.contains("flush") && kwargs["flush"].cast<bool>()) {
         file.attr("flush")();
+    }
 }
 PYBIND11_NAMESPACE_END(detail)
 
 template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
 void print(Args &&...args) {
     auto c = detail::collect_arguments<policy>(std::forward<Args>(args)...);
     detail::print(c.args(), c.kwargs());
 }
 
-#if defined(WITH_THREAD) && !defined(PYPY_VERSION)
-
-/* The functions below essentially reproduce the PyGILState_* API using a RAII
- * pattern, but there are a few important differences:
- *
- * 1. When acquiring the GIL from an non-main thread during the finalization
- *    phase, the GILState API blindly terminates the calling thread, which
- *    is often not what is wanted. This API does not do this.
- *
- * 2. The gil_scoped_release function can optionally cut the relationship
- *    of a PyThreadState and its associated thread, which allows moving it to
- *    another thread (this is a fairly rare/advanced use case).
- *
- * 3. The reference count of an acquired thread state can be controlled. This
- *    can be handy to prevent cases where callbacks issued from an external
- *    thread would otherwise constantly construct and destroy thread state data
- *    structures.
- *
- * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an
- * example which uses features 2 and 3 to migrate the Python thread of
- * execution to another thread (to run the event loop on the original thread,
- * in this case).
- */
-
-class gil_scoped_acquire {
-public:
-    PYBIND11_NOINLINE gil_scoped_acquire() {
-        auto const &internals = detail::get_internals();
-        tstate = (PyThreadState *) PYBIND11_TLS_GET_VALUE(internals.tstate);
-
-        if (!tstate) {
-            /* Check if the GIL was acquired using the PyGILState_* API instead (e.g. if
-               calling from a Python thread). Since we use a different key, this ensures
-               we don't create a new thread state and deadlock in PyEval_AcquireThread
-               below. Note we don't save this state with internals.tstate, since we don't
-               create it we would fail to clear it (its reference count should be > 0). */
-            tstate = PyGILState_GetThisThreadState();
-        }
-
-        if (!tstate) {
-            tstate = PyThreadState_New(internals.istate);
-            #if !defined(NDEBUG)
-                if (!tstate)
-                    pybind11_fail("scoped_acquire: could not create thread state!");
-            #endif
-            tstate->gilstate_counter = 0;
-            PYBIND11_TLS_REPLACE_VALUE(internals.tstate, tstate);
-        } else {
-            release = detail::get_thread_state_unchecked() != tstate;
-        }
-
-        if (release) {
-            /* Work around an annoying assertion in PyThreadState_Swap */
-            #if defined(Py_DEBUG)
-                PyInterpreterState *interp = tstate->interp;
-                tstate->interp = nullptr;
-            #endif
-            PyEval_AcquireThread(tstate);
-            #if defined(Py_DEBUG)
-                tstate->interp = interp;
-            #endif
-        }
-
-        inc_ref();
-    }
-
-    void inc_ref() {
-        ++tstate->gilstate_counter;
-    }
-
-    PYBIND11_NOINLINE void dec_ref() {
-        --tstate->gilstate_counter;
-        #if !defined(NDEBUG)
-            if (detail::get_thread_state_unchecked() != tstate)
-                pybind11_fail("scoped_acquire::dec_ref(): thread state must be current!");
-            if (tstate->gilstate_counter < 0)
-                pybind11_fail("scoped_acquire::dec_ref(): reference count underflow!");
-        #endif
-        if (tstate->gilstate_counter == 0) {
-            #if !defined(NDEBUG)
-                if (!release)
-                    pybind11_fail("scoped_acquire::dec_ref(): internal error!");
-            #endif
-            PyThreadState_Clear(tstate);
-            PyThreadState_DeleteCurrent();
-            PYBIND11_TLS_DELETE_VALUE(detail::get_internals().tstate);
-            release = false;
-        }
-    }
-
-    PYBIND11_NOINLINE ~gil_scoped_acquire() {
-        dec_ref();
-        if (release)
-           PyEval_SaveThread();
-    }
-private:
-    PyThreadState *tstate = nullptr;
-    bool release = true;
-};
-
-class gil_scoped_release {
-public:
-    explicit gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {
-        // `get_internals()` must be called here unconditionally in order to initialize
-        // `internals.tstate` for subsequent `gil_scoped_acquire` calls. Otherwise, an
-        // initialization race could occur as multiple threads try `gil_scoped_acquire`.
-        const auto &internals = detail::get_internals();
-        tstate = PyEval_SaveThread();
-        if (disassoc) {
-            auto key = internals.tstate;
-            PYBIND11_TLS_DELETE_VALUE(key);
-        }
-    }
-    ~gil_scoped_release() {
-        if (!tstate)
-            return;
-        PyEval_RestoreThread(tstate);
-        if (disassoc) {
-            auto key = detail::get_internals().tstate;
-            PYBIND11_TLS_REPLACE_VALUE(key, tstate);
-        }
-    }
-private:
-    PyThreadState *tstate;
-    bool disassoc;
-};
-#elif defined(PYPY_VERSION)
-class gil_scoped_acquire {
-    PyGILState_STATE state;
-public:
-    gil_scoped_acquire() { state = PyGILState_Ensure(); }
-    ~gil_scoped_acquire() { PyGILState_Release(state); }
-};
-
-class gil_scoped_release {
-    PyThreadState *state;
-public:
-    gil_scoped_release() { state = PyEval_SaveThread(); }
-    ~gil_scoped_release() { PyEval_RestoreThread(state); }
-};
-#else
-class gil_scoped_acquire { };
-class gil_scoped_release { };
-#endif
-
 error_already_set::~error_already_set() {
     if (m_type) {
         gil_scoped_acquire gil;
         error_scope scope;
         m_type.release().dec_ref();
         m_value.release().dec_ref();
         m_trace.release().dec_ref();
     }
 }
 
 PYBIND11_NAMESPACE_BEGIN(detail)
-inline function get_type_override(const void *this_ptr, const type_info *this_type, const char *name)  {
+inline function
+get_type_override(const void *this_ptr, const type_info *this_type, const char *name) {
     handle self = get_object_handle(this_ptr, this_type);
-    if (!self)
+    if (!self) {
         return function();
+    }
     handle type = type::handle_of(self);
     auto key = std::make_pair(type.ptr(), name);
 
     /* Cache functions that aren't overridden in Python to avoid
        many costly Python dictionary lookups below */
     auto &cache = get_internals().inactive_override_cache;
-    if (cache.find(key) != cache.end())
+    if (cache.find(key) != cache.end()) {
         return function();
+    }
 
     function override = getattr(self, name, function());
     if (override.is_cpp_function()) {
         cache.insert(key);
         return function();
     }
 
     /* Don't call dispatch code if invoked from overridden function.
        Unfortunately this doesn't work on PyPy. */
 #if !defined(PYPY_VERSION)
+#    if PY_VERSION_HEX >= 0x03090000
+    PyFrameObject *frame = PyThreadState_GetFrame(PyThreadState_Get());
+    if (frame != nullptr) {
+        PyCodeObject *f_code = PyFrame_GetCode(frame);
+        // f_code is guaranteed to not be NULL
+        if ((std::string) str(f_code->co_name) == name && f_code->co_argcount > 0) {
+            PyObject *locals = PyEval_GetLocals();
+            if (locals != nullptr) {
+                PyObject *co_varnames = PyObject_GetAttrString((PyObject *) f_code, "co_varnames");
+                PyObject *self_arg = PyTuple_GET_ITEM(co_varnames, 0);
+                Py_DECREF(co_varnames);
+                PyObject *self_caller = dict_getitem(locals, self_arg);
+                if (self_caller == self.ptr()) {
+                    Py_DECREF(f_code);
+                    Py_DECREF(frame);
+                    return function();
+                }
+            }
+        }
+        Py_DECREF(f_code);
+        Py_DECREF(frame);
+    }
+#    else
     PyFrameObject *frame = PyThreadState_Get()->frame;
-    if (frame && (std::string) str(frame->f_code->co_name) == name &&
-        frame->f_code->co_argcount > 0) {
+    if (frame != nullptr && (std::string) str(frame->f_code->co_name) == name
+        && frame->f_code->co_argcount > 0) {
         PyFrame_FastToLocals(frame);
-        PyObject *self_caller = PyDict_GetItem(
-            frame->f_locals, PyTuple_GET_ITEM(frame->f_code->co_varnames, 0));
-        if (self_caller == self.ptr())
+        PyObject *self_caller
+            = dict_getitem(frame->f_locals, PyTuple_GET_ITEM(frame->f_code->co_varnames, 0));
+        if (self_caller == self.ptr()) {
             return function();
+        }
     }
+#    endif
+
 #else
     /* PyPy currently doesn't provide a detailed cpyext emulation of
        frame objects, so we have to emulate this using Python. This
        is going to be slow..*/
-    dict d; d["self"] = self; d["name"] = pybind11::str(name);
-    PyObject *result = PyRun_String(
-        "import inspect\n"
-        "frame = inspect.currentframe()\n"
-        "if frame is not None:\n"
-        "    frame = frame.f_back\n"
-        "    if frame is not None and str(frame.f_code.co_name) == name and "
-        "frame.f_code.co_argcount > 0:\n"
-        "        self_caller = frame.f_locals[frame.f_code.co_varnames[0]]\n"
-        "        if self_caller == self:\n"
-        "            self = None\n",
-        Py_file_input, d.ptr(), d.ptr());
+    dict d;
+    d["self"] = self;
+    d["name"] = pybind11::str(name);
+    PyObject *result
+        = PyRun_String("import inspect\n"
+                       "frame = inspect.currentframe()\n"
+                       "if frame is not None:\n"
+                       "    frame = frame.f_back\n"
+                       "    if frame is not None and str(frame.f_code.co_name) == name and "
+                       "frame.f_code.co_argcount > 0:\n"
+                       "        self_caller = frame.f_locals[frame.f_code.co_varnames[0]]\n"
+                       "        if self_caller == self:\n"
+                       "            self = None\n",
+                       Py_file_input,
+                       d.ptr(),
+                       d.ptr());
     if (result == nullptr)
         throw error_already_set();
+    Py_DECREF(result);
     if (d["self"].is_none())
         return function();
-    Py_DECREF(result);
 #endif
 
     return override;
 }
 PYBIND11_NAMESPACE_END(detail)
 
 /** \rst
-  Try to retrieve a python method by the provided name from the instance pointed to by the this_ptr.
+  Try to retrieve a python method by the provided name from the instance pointed to by the
+  this_ptr.
 
-  :this_ptr: The pointer to the object the overriden method should be retrieved for. This should be
-             the first non-trampoline class encountered in the inheritance chain.
+  :this_ptr: The pointer to the object the overridden method should be retrieved for. This should
+             be the first non-trampoline class encountered in the inheritance chain.
   :name: The name of the overridden Python method to retrieve.
   :return: The Python method by this name from the object or an empty function wrapper.
  \endrst */
-template <class T> function get_override(const T *this_ptr, const char *name) {
-    auto tinfo = detail::get_type_info(typeid(T));
+template <class T>
+function get_override(const T *this_ptr, const char *name) {
+    auto *tinfo = detail::get_type_info(typeid(T));
     return tinfo ? detail::get_type_override(this_ptr, tinfo, name) : function();
 }
 
-#define PYBIND11_OVERRIDE_IMPL(ret_type, cname, name, ...) \
-    do { \
-        pybind11::gil_scoped_acquire gil; \
-        pybind11::function override = pybind11::get_override(static_cast<const cname *>(this), name); \
-        if (override) { \
-            auto o = override(__VA_ARGS__); \
-            if (pybind11::detail::cast_is_temporary_value_reference<ret_type>::value) { \
-                static pybind11::detail::override_caster_t<ret_type> caster; \
-                return pybind11::detail::cast_ref<ret_type>(std::move(o), caster); \
-            } \
-            else return pybind11::detail::cast_safe<ret_type>(std::move(o)); \
-        } \
+#define PYBIND11_OVERRIDE_IMPL(ret_type, cname, name, ...)                                        \
+    do {                                                                                          \
+        pybind11::gil_scoped_acquire gil;                                                         \
+        pybind11::function override                                                               \
+            = pybind11::get_override(static_cast<const cname *>(this), name);                     \
+        if (override) {                                                                           \
+            auto o = override(__VA_ARGS__);                                                       \
+            if (pybind11::detail::cast_is_temporary_value_reference<ret_type>::value) {           \
+                static pybind11::detail::override_caster_t<ret_type> caster;                      \
+                return pybind11::detail::cast_ref<ret_type>(std::move(o), caster);                \
+            }                                                                                     \
+            return pybind11::detail::cast_safe<ret_type>(std::move(o));                           \
+        }                                                                                         \
     } while (false)
 
 /** \rst
-    Macro to populate the virtual method in the trampoline class. This macro tries to look up a method named 'fn'
-    from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
-    the appropriate type. See :ref:`overriding_virtuals` for more information. This macro should be used when the method
+    Macro to populate the virtual method in the trampoline class. This macro tries to look up a
+    method named 'fn' from the Python side, deals with the :ref:`gil` and necessary argument
+    conversions to call this method and return the appropriate type.
+    See :ref:`overriding_virtuals` for more information. This macro should be used when the method
     name in C is not the same as the method name in Python. For example with `__str__`.
 
     .. code-block:: cpp
 
       std::string toString() override {
         PYBIND11_OVERRIDE_NAME(
             std::string, // Return type (ret_type)
             Animal,      // Parent class (cname)
             "__str__",   // Name of method in Python (name)
             toString,    // Name of function in C++ (fn)
         );
       }
 \endrst */
-#define PYBIND11_OVERRIDE_NAME(ret_type, cname, name, fn, ...) \
-    do { \
+#define PYBIND11_OVERRIDE_NAME(ret_type, cname, name, fn, ...)                                    \
+    do {                                                                                          \
         PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__); \
-        return cname::fn(__VA_ARGS__); \
+        return cname::fn(__VA_ARGS__);                                                            \
     } while (false)
 
 /** \rst
-    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERRIDE_NAME`, except that it
-    throws if no override can be found.
+    Macro for pure virtual functions, this function is identical to
+    :c:macro:`PYBIND11_OVERRIDE_NAME`, except that it throws if no override can be found.
 \endrst */
-#define PYBIND11_OVERRIDE_PURE_NAME(ret_type, cname, name, fn, ...) \
-    do { \
+#define PYBIND11_OVERRIDE_PURE_NAME(ret_type, cname, name, fn, ...)                               \
+    do {                                                                                          \
         PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__); \
-        pybind11::pybind11_fail("Tried to call pure virtual function \"" PYBIND11_STRINGIFY(cname) "::" name "\""); \
+        pybind11::pybind11_fail(                                                                  \
+            "Tried to call pure virtual function \"" PYBIND11_STRINGIFY(cname) "::" name "\"");   \
     } while (false)
 
 /** \rst
-    Macro to populate the virtual method in the trampoline class. This macro tries to look up the method
-    from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
-    the appropriate type. This macro should be used if the method name in C and in Python are identical.
+    Macro to populate the virtual method in the trampoline class. This macro tries to look up the
+    method from the Python side, deals with the :ref:`gil` and necessary argument conversions to
+    call this method and return the appropriate type. This macro should be used if the method name
+    in C and in Python are identical.
     See :ref:`overriding_virtuals` for more information.
 
     .. code-block:: cpp
 
       class PyAnimal : public Animal {
       public:
           // Inherit the constructors
@@ -2326,48 +2824,48 @@
                   Animal,      // Parent class (cname)
                   go,          // Name of function in C++ (must match Python name) (fn)
                   n_times      // Argument(s) (...)
               );
           }
       };
 \endrst */
-#define PYBIND11_OVERRIDE(ret_type, cname, fn, ...) \
+#define PYBIND11_OVERRIDE(ret_type, cname, fn, ...)                                               \
     PYBIND11_OVERRIDE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
 
 /** \rst
-    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERRIDE`, except that it throws
-    if no override can be found.
+    Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERRIDE`,
+    except that it throws if no override can be found.
 \endrst */
-#define PYBIND11_OVERRIDE_PURE(ret_type, cname, fn, ...) \
-    PYBIND11_OVERRIDE_PURE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
-
+#define PYBIND11_OVERRIDE_PURE(ret_type, cname, fn, ...)                                          \
+    PYBIND11_OVERRIDE_PURE_NAME(                                                                  \
+        PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), #fn, fn, __VA_ARGS__)
 
 // Deprecated versions
 
 PYBIND11_DEPRECATED("get_type_overload has been deprecated")
-inline function get_type_overload(const void *this_ptr, const detail::type_info *this_type, const char *name) {
+inline function
+get_type_overload(const void *this_ptr, const detail::type_info *this_type, const char *name) {
     return detail::get_type_override(this_ptr, this_type, name);
 }
 
 template <class T>
 inline function get_overload(const T *this_ptr, const char *name) {
     return get_override(this_ptr, name);
 }
 
-#define PYBIND11_OVERLOAD_INT(ret_type, cname, name, ...) \
+#define PYBIND11_OVERLOAD_INT(ret_type, cname, name, ...)                                         \
     PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, __VA_ARGS__)
-#define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...) \
+#define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...)                                    \
     PYBIND11_OVERRIDE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, fn, __VA_ARGS__)
-#define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...) \
-    PYBIND11_OVERRIDE_PURE_NAME(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, fn, __VA_ARGS__);
-#define PYBIND11_OVERLOAD(ret_type, cname, fn, ...) \
+#define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...)                               \
+    PYBIND11_OVERRIDE_PURE_NAME(                                                                  \
+        PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, fn, __VA_ARGS__);
+#define PYBIND11_OVERLOAD(ret_type, cname, fn, ...)                                               \
     PYBIND11_OVERRIDE(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), fn, __VA_ARGS__)
-#define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...) \
+#define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...)                                          \
     PYBIND11_OVERRIDE_PURE(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), fn, __VA_ARGS__);
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
 
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#  pragma warning(pop)
-#elif defined(__GNUG__) && !defined(__clang__)
-#  pragma GCC diagnostic pop
+#if defined(__GNUC__) && __GNUC__ == 7
+#    pragma GCC diagnostic pop // -Wnoexcept-type
 #endif
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/pytypes.h` & `HepMC3-3.2.6/python/include/pybind11/pytypes.h`

 * *Files 19% similar despite different names*

```diff
@@ -7,49 +7,63 @@
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "detail/common.h"
 #include "buffer_info.h"
-#include <utility>
+
 #include <type_traits>
+#include <utility>
+
+#if defined(PYBIND11_HAS_OPTIONAL)
+#    include <optional>
+#endif
+
+#ifdef PYBIND11_HAS_STRING_VIEW
+#    include <string_view>
+#endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /* A few forward declarations */
-class handle; class object;
-class str; class iterator;
+class handle;
+class object;
+class str;
+class iterator;
 class type;
-struct arg; struct arg_v;
+struct arg;
+struct arg_v;
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 class args_proxy;
-inline bool isinstance_generic(handle obj, const std::type_info &tp);
+bool isinstance_generic(handle obj, const std::type_info &tp);
 
 // Accessor forward declarations
-template <typename Policy> class accessor;
+template <typename Policy>
+class accessor;
 namespace accessor_policies {
-    struct obj_attr;
-    struct str_attr;
-    struct generic_item;
-    struct sequence_item;
-    struct list_item;
-    struct tuple_item;
+struct obj_attr;
+struct str_attr;
+struct generic_item;
+struct sequence_item;
+struct list_item;
+struct tuple_item;
 } // namespace accessor_policies
 using obj_attr_accessor = accessor<accessor_policies::obj_attr>;
 using str_attr_accessor = accessor<accessor_policies::str_attr>;
 using item_accessor = accessor<accessor_policies::generic_item>;
 using sequence_accessor = accessor<accessor_policies::sequence_item>;
 using list_accessor = accessor<accessor_policies::list_item>;
 using tuple_accessor = accessor<accessor_policies::tuple_item>;
 
 /// Tag and check to identify a class which implements the Python object API
-class pyobject_tag { };
-template <typename T> using is_pyobject = std::is_base_of<pyobject_tag, remove_reference_t<T>>;
+class pyobject_tag {};
+template <typename T>
+using is_pyobject = std::is_base_of<pyobject_tag, remove_reference_t<T>>;
 
 /** \rst
     A mixin class which adds common functions to `handle`, `object` and various accessors.
     The only requirement for `Derived` is to implement ``PyObject *Derived::ptr() const``.
 \endrst */
 template <typename Derived>
 class object_api : public pyobject_tag {
@@ -89,42 +103,45 @@
         or ``list`` for a function call. Applying another * to the result yields
         ** unpacking, e.g. to unpack a dict as function keyword arguments.
         See :ref:`calling_python_functions`.
     \endrst */
     args_proxy operator*() const;
 
     /// Check if the given item is contained within this object, i.e. ``item in obj``.
-    template <typename T> bool contains(T &&item) const;
+    template <typename T>
+    bool contains(T &&item) const;
 
     /** \rst
         Assuming the Python object is a function or implements the ``__call__``
         protocol, ``operator()`` invokes the underlying function, passing an
         arbitrary set of parameters. The result is returned as a `object` and
         may need to be converted back into a Python object using `handle::cast()`.
 
         When some of the arguments cannot be converted to Python objects, the
         function will throw a `cast_error` exception. When the Python function
         call fails, a `error_already_set` exception is thrown.
     \endrst */
-    template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
+    template <return_value_policy policy = return_value_policy::automatic_reference,
+              typename... Args>
     object operator()(Args &&...args) const;
-    template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
+    template <return_value_policy policy = return_value_policy::automatic_reference,
+              typename... Args>
     PYBIND11_DEPRECATED("call(...) was deprecated in favor of operator()(...)")
-        object call(Args&&... args) const;
+    object call(Args &&...args) const;
 
     /// Equivalent to ``obj is other`` in Python.
-    bool is(object_api const& other) const { return derived().ptr() == other.derived().ptr(); }
+    bool is(object_api const &other) const { return derived().ptr() == other.derived().ptr(); }
     /// Equivalent to ``obj is None`` in Python.
     bool is_none() const { return derived().ptr() == Py_None; }
     /// Equivalent to obj == other in Python
-    bool equal(object_api const &other) const      { return rich_compare(other, Py_EQ); }
-    bool not_equal(object_api const &other) const  { return rich_compare(other, Py_NE); }
-    bool operator<(object_api const &other) const  { return rich_compare(other, Py_LT); }
+    bool equal(object_api const &other) const { return rich_compare(other, Py_EQ); }
+    bool not_equal(object_api const &other) const { return rich_compare(other, Py_NE); }
+    bool operator<(object_api const &other) const { return rich_compare(other, Py_LT); }
     bool operator<=(object_api const &other) const { return rich_compare(other, Py_LE); }
-    bool operator>(object_api const &other) const  { return rich_compare(other, Py_GT); }
+    bool operator>(object_api const &other) const { return rich_compare(other, Py_GT); }
     bool operator>=(object_api const &other) const { return rich_compare(other, Py_GE); }
 
     object operator-() const;
     object operator~() const;
     object operator+(object_api const &other) const;
     object operator+=(object_api const &other) const;
     object operator-(object_api const &other) const;
@@ -149,15 +166,16 @@
 
     /// Get or set the object's docstring, i.e. ``obj.__doc__``.
     str_attr_accessor doc() const;
 
     /// Return the object's current reference count
     int ref_count() const { return static_cast<int>(Py_REFCNT(derived().ptr())); }
 
-    // TODO PYBIND11_DEPRECATED("Call py::type::handle_of(h) or py::type::of(h) instead of h.get_type()")
+    // TODO PYBIND11_DEPRECATED(
+    //     "Call py::type::handle_of(h) or py::type::of(h) instead of h.get_type()")
     handle get_type() const;
 
 private:
     bool rich_compare(object_api const &other, int value) const;
 };
 
 PYBIND11_NAMESPACE_END(detail)
@@ -174,51 +192,60 @@
         counting features.
 \endrst */
 class handle : public detail::object_api<handle> {
 public:
     /// The default constructor creates a handle with a ``nullptr``-valued pointer
     handle() = default;
     /// Creates a ``handle`` from the given raw Python object pointer
-    handle(PyObject *ptr) : m_ptr(ptr) { } // Allow implicit conversion from PyObject*
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    handle(PyObject *ptr) : m_ptr(ptr) {} // Allow implicit conversion from PyObject*
 
     /// Return the underlying ``PyObject *`` pointer
     PyObject *ptr() const { return m_ptr; }
     PyObject *&ptr() { return m_ptr; }
 
     /** \rst
         Manually increase the reference count of the Python object. Usually, it is
         preferable to use the `object` class which derives from `handle` and calls
         this function automatically. Returns a reference to itself.
     \endrst */
-    const handle& inc_ref() const & { Py_XINCREF(m_ptr); return *this; }
+    const handle &inc_ref() const & {
+        Py_XINCREF(m_ptr);
+        return *this;
+    }
 
     /** \rst
         Manually decrease the reference count of the Python object. Usually, it is
         preferable to use the `object` class which derives from `handle` and calls
         this function automatically. Returns a reference to itself.
     \endrst */
-    const handle& dec_ref() const & { Py_XDECREF(m_ptr); return *this; }
+    const handle &dec_ref() const & {
+        Py_XDECREF(m_ptr);
+        return *this;
+    }
 
     /** \rst
         Attempt to cast the Python object into the given C++ type. A `cast_error`
         will be throw upon failure.
     \endrst */
-    template <typename T> T cast() const;
+    template <typename T>
+    T cast() const;
     /// Return ``true`` when the `handle` wraps a valid Python object
     explicit operator bool() const { return m_ptr != nullptr; }
     /** \rst
         Deprecated: Check that the underlying pointers are the same.
         Equivalent to ``obj1 is obj2`` in Python.
     \endrst */
     PYBIND11_DEPRECATED("Use obj1.is(obj2) instead")
     bool operator==(const handle &h) const { return m_ptr == h.m_ptr; }
     PYBIND11_DEPRECATED("Use !obj1.is(obj2) instead")
     bool operator!=(const handle &h) const { return m_ptr != h.m_ptr; }
     PYBIND11_DEPRECATED("Use handle::operator bool() instead")
     bool check() const { return m_ptr != nullptr; }
+
 protected:
     PyObject *m_ptr = nullptr;
 };
 
 /** \rst
     Holds a reference to a Python object (with reference counting)
 
@@ -229,67 +256,83 @@
     scope and is destructed. When using `object` instances consistently, it is much
     easier to get reference counting right at the first attempt.
 \endrst */
 class object : public handle {
 public:
     object() = default;
     PYBIND11_DEPRECATED("Use reinterpret_borrow<object>() or reinterpret_steal<object>()")
-    object(handle h, bool is_borrowed) : handle(h) { if (is_borrowed) inc_ref(); }
+    object(handle h, bool is_borrowed) : handle(h) {
+        if (is_borrowed) {
+            inc_ref();
+        }
+    }
     /// Copy constructor; always increases the reference count
     object(const object &o) : handle(o) { inc_ref(); }
     /// Move constructor; steals the object from ``other`` and preserves its reference count
-    object(object &&other) noexcept { m_ptr = other.m_ptr; other.m_ptr = nullptr; }
+    object(object &&other) noexcept {
+        m_ptr = other.m_ptr;
+        other.m_ptr = nullptr;
+    }
     /// Destructor; automatically calls `handle::dec_ref()`
     ~object() { dec_ref(); }
 
     /** \rst
         Resets the internal pointer to ``nullptr`` without decreasing the
         object's reference count. The function returns a raw handle to the original
         Python object.
     \endrst */
     handle release() {
-      PyObject *tmp = m_ptr;
-      m_ptr = nullptr;
-      return handle(tmp);
+        PyObject *tmp = m_ptr;
+        m_ptr = nullptr;
+        return handle(tmp);
     }
 
-    object& operator=(const object &other) {
+    object &operator=(const object &other) {
         other.inc_ref();
-        dec_ref();
+        // Use temporary variable to ensure `*this` remains valid while
+        // `Py_XDECREF` executes, in case `*this` is accessible from Python.
+        handle temp(m_ptr);
         m_ptr = other.m_ptr;
+        temp.dec_ref();
         return *this;
     }
 
-    object& operator=(object &&other) noexcept {
+    object &operator=(object &&other) noexcept {
         if (this != &other) {
             handle temp(m_ptr);
             m_ptr = other.m_ptr;
             other.m_ptr = nullptr;
             temp.dec_ref();
         }
         return *this;
     }
 
     // Calling cast() on an object lvalue just copies (via handle::cast)
-    template <typename T> T cast() const &;
+    template <typename T>
+    T cast() const &;
     // Calling on an object rvalue does a move, if needed and/or possible
-    template <typename T> T cast() &&;
+    template <typename T>
+    T cast() &&;
 
 protected:
     // Tags for choosing constructors from raw PyObject *
-    struct borrowed_t { };
-    struct stolen_t { };
+    struct borrowed_t {};
+    struct stolen_t {};
 
-    template <typename T> friend T reinterpret_borrow(handle);
-    template <typename T> friend T reinterpret_steal(handle);
+    /// @cond BROKEN
+    template <typename T>
+    friend T reinterpret_borrow(handle);
+    template <typename T>
+    friend T reinterpret_steal(handle);
+    /// @endcond
 
 public:
     // Only accessible from derived classes and the reinterpret_* functions
     object(handle h, borrowed_t) : handle(h) { inc_ref(); }
-    object(handle h, stolen_t) : handle(h) { }
+    object(handle h, stolen_t) : handle(h) {}
 };
 
 /** \rst
     Declare that a `handle` or ``PyObject *`` is a certain type and borrow the reference.
     The target type ``T`` must be `object` or one of its derived classes. The function
     doesn't do any conversions or checks. It's up to the user to make sure that the
     target type is correct.
@@ -297,35 +340,47 @@
     .. code-block:: cpp
 
         PyObject *p = PyList_GetItem(obj, index);
         py::object o = reinterpret_borrow<py::object>(p);
         // or
         py::tuple t = reinterpret_borrow<py::tuple>(p); // <-- `p` must be already be a `tuple`
 \endrst */
-template <typename T> T reinterpret_borrow(handle h) { return {h, object::borrowed_t{}}; }
+template <typename T>
+T reinterpret_borrow(handle h) {
+    return {h, object::borrowed_t{}};
+}
 
 /** \rst
     Like `reinterpret_borrow`, but steals the reference.
 
      .. code-block:: cpp
 
         PyObject *p = PyObject_Str(obj);
         py::str s = reinterpret_steal<py::str>(p); // <-- `p` must be already be a `str`
 \endrst */
-template <typename T> T reinterpret_steal(handle h) { return {h, object::stolen_t{}}; }
+template <typename T>
+T reinterpret_steal(handle h) {
+    return {h, object::stolen_t{}};
+}
 
 PYBIND11_NAMESPACE_BEGIN(detail)
-inline std::string error_string();
+std::string error_string();
 PYBIND11_NAMESPACE_END(detail)
 
+#if defined(_MSC_VER)
+#    pragma warning(push)
+#    pragma warning(disable : 4275 4251)
+//     warning C4275: An exported class was derived from a class that wasn't exported.
+//     Can be ignored when derived from a STL class.
+#endif
 /// Fetch and hold an error which was already set in Python.  An instance of this is typically
 /// thrown to propagate python-side errors back through C++ which can either be caught manually or
 /// else falls back to the function dispatcher (which then raises the captured error back to
 /// python).
-class error_already_set : public std::runtime_error {
+class PYBIND11_EXPORT_EXCEPTION error_already_set : public std::runtime_error {
 public:
     /// Constructs a new exception from the current Python error indicator, if any.  The current
     /// Python error indicator will be cleared.
     error_already_set() : std::runtime_error(detail::error_string()) {
         PyErr_Fetch(&m_type.ptr(), &m_value.ptr(), &m_trace.ptr());
     }
 
@@ -333,212 +388,340 @@
     error_already_set(error_already_set &&) = default;
 
     inline ~error_already_set() override;
 
     /// Give the currently-held error back to Python, if any.  If there is currently a Python error
     /// already set it is cleared first.  After this call, the current object no longer stores the
     /// error variables (but the `.what()` string is still available).
-    void restore() { PyErr_Restore(m_type.release().ptr(), m_value.release().ptr(), m_trace.release().ptr()); }
+    void restore() {
+        PyErr_Restore(m_type.release().ptr(), m_value.release().ptr(), m_trace.release().ptr());
+    }
 
-    /// If it is impossible to raise the currently-held error, such as in destructor, we can write
-    /// it out using Python's unraisable hook (sys.unraisablehook). The error context should be
-    /// some object whose repr() helps identify the location of the error. Python already knows the
-    /// type and value of the error, so there is no need to repeat that. For example, __func__ could
-    /// be helpful. After this call, the current object no longer stores the error variables,
-    /// and neither does Python.
+    /// If it is impossible to raise the currently-held error, such as in a destructor, we can
+    /// write it out using Python's unraisable hook (`sys.unraisablehook`). The error context
+    /// should be some object whose `repr()` helps identify the location of the error. Python
+    /// already knows the type and value of the error, so there is no need to repeat that. After
+    /// this call, the current object no longer stores the error variables, and neither does
+    /// Python.
     void discard_as_unraisable(object err_context) {
         restore();
         PyErr_WriteUnraisable(err_context.ptr());
     }
+    /// An alternate version of `discard_as_unraisable()`, where a string provides information on
+    /// the location of the error. For example, `__func__` could be helpful.
     void discard_as_unraisable(const char *err_context) {
         discard_as_unraisable(reinterpret_steal<object>(PYBIND11_FROM_STRING(err_context)));
     }
 
     // Does nothing; provided for backwards compatibility.
     PYBIND11_DEPRECATED("Use of error_already_set.clear() is deprecated")
     void clear() {}
 
     /// Check if the currently trapped error type matches the given Python exception class (or a
     /// subclass thereof).  May also be passed a tuple to search for any exception class matches in
     /// the given tuple.
-    bool matches(handle exc) const { return PyErr_GivenExceptionMatches(m_type.ptr(), exc.ptr()); }
+    bool matches(handle exc) const {
+        return (PyErr_GivenExceptionMatches(m_type.ptr(), exc.ptr()) != 0);
+    }
 
-    const object& type() const { return m_type; }
-    const object& value() const { return m_value; }
-    const object& trace() const { return m_trace; }
+    const object &type() const { return m_type; }
+    const object &value() const { return m_value; }
+    const object &trace() const { return m_trace; }
 
 private:
     object m_type, m_value, m_trace;
 };
+#if defined(_MSC_VER)
+#    pragma warning(pop)
+#endif
+
+#if PY_VERSION_HEX >= 0x03030000
+
+/// Replaces the current Python error indicator with the chosen error, performing a
+/// 'raise from' to indicate that the chosen error was caused by the original error.
+inline void raise_from(PyObject *type, const char *message) {
+    // Based on _PyErr_FormatVFromCause:
+    // https://github.com/python/cpython/blob/467ab194fc6189d9f7310c89937c51abeac56839/Python/errors.c#L405
+    // See https://github.com/pybind/pybind11/pull/2112 for details.
+    PyObject *exc = nullptr, *val = nullptr, *val2 = nullptr, *tb = nullptr;
+
+    assert(PyErr_Occurred());
+    PyErr_Fetch(&exc, &val, &tb);
+    PyErr_NormalizeException(&exc, &val, &tb);
+    if (tb != nullptr) {
+        PyException_SetTraceback(val, tb);
+        Py_DECREF(tb);
+    }
+    Py_DECREF(exc);
+    assert(!PyErr_Occurred());
+
+    PyErr_SetString(type, message);
+
+    PyErr_Fetch(&exc, &val2, &tb);
+    PyErr_NormalizeException(&exc, &val2, &tb);
+    Py_INCREF(val);
+    PyException_SetCause(val2, val);
+    PyException_SetContext(val2, val);
+    PyErr_Restore(exc, val2, tb);
+}
+
+/// Sets the current Python error indicator with the chosen error, performing a 'raise from'
+/// from the error contained in error_already_set to indicate that the chosen error was
+/// caused by the original error. After this function is called error_already_set will
+/// no longer contain an error.
+inline void raise_from(error_already_set &err, PyObject *type, const char *message) {
+    err.restore();
+    raise_from(type, message);
+}
+
+#endif
 
-/** \defgroup python_builtins _
+/** \defgroup python_builtins const_name
     Unless stated otherwise, the following C++ functions behave the same
     as their Python counterparts.
  */
 
 /** \ingroup python_builtins
     \rst
     Return true if ``obj`` is an instance of ``T``. Type ``T`` must be a subclass of
     `object` or a class which was exposed to Python as ``py::class_<T>``.
 \endrst */
 template <typename T, detail::enable_if_t<std::is_base_of<object, T>::value, int> = 0>
-bool isinstance(handle obj) { return T::check_(obj); }
+bool isinstance(handle obj) {
+    return T::check_(obj);
+}
 
 template <typename T, detail::enable_if_t<!std::is_base_of<object, T>::value, int> = 0>
-bool isinstance(handle obj) { return detail::isinstance_generic(obj, typeid(T)); }
+bool isinstance(handle obj) {
+    return detail::isinstance_generic(obj, typeid(T));
+}
 
-template <> inline bool isinstance<handle>(handle) = delete;
-template <> inline bool isinstance<object>(handle obj) { return obj.ptr() != nullptr; }
+template <>
+inline bool isinstance<handle>(handle) = delete;
+template <>
+inline bool isinstance<object>(handle obj) {
+    return obj.ptr() != nullptr;
+}
 
 /// \ingroup python_builtins
 /// Return true if ``obj`` is an instance of the ``type``.
 inline bool isinstance(handle obj, handle type) {
     const auto result = PyObject_IsInstance(obj.ptr(), type.ptr());
-    if (result == -1)
+    if (result == -1) {
         throw error_already_set();
+    }
     return result != 0;
 }
 
 /// \addtogroup python_builtins
 /// @{
 inline bool hasattr(handle obj, handle name) {
     return PyObject_HasAttr(obj.ptr(), name.ptr()) == 1;
 }
 
 inline bool hasattr(handle obj, const char *name) {
     return PyObject_HasAttrString(obj.ptr(), name) == 1;
 }
 
 inline void delattr(handle obj, handle name) {
-    if (PyObject_DelAttr(obj.ptr(), name.ptr()) != 0) { throw error_already_set(); }
+    if (PyObject_DelAttr(obj.ptr(), name.ptr()) != 0) {
+        throw error_already_set();
+    }
 }
 
 inline void delattr(handle obj, const char *name) {
-    if (PyObject_DelAttrString(obj.ptr(), name) != 0) { throw error_already_set(); }
+    if (PyObject_DelAttrString(obj.ptr(), name) != 0) {
+        throw error_already_set();
+    }
 }
 
 inline object getattr(handle obj, handle name) {
     PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr());
-    if (!result) { throw error_already_set(); }
+    if (!result) {
+        throw error_already_set();
+    }
     return reinterpret_steal<object>(result);
 }
 
 inline object getattr(handle obj, const char *name) {
     PyObject *result = PyObject_GetAttrString(obj.ptr(), name);
-    if (!result) { throw error_already_set(); }
+    if (!result) {
+        throw error_already_set();
+    }
     return reinterpret_steal<object>(result);
 }
 
 inline object getattr(handle obj, handle name, handle default_) {
     if (PyObject *result = PyObject_GetAttr(obj.ptr(), name.ptr())) {
         return reinterpret_steal<object>(result);
-    } else {
-        PyErr_Clear();
-        return reinterpret_borrow<object>(default_);
     }
+    PyErr_Clear();
+    return reinterpret_borrow<object>(default_);
 }
 
 inline object getattr(handle obj, const char *name, handle default_) {
     if (PyObject *result = PyObject_GetAttrString(obj.ptr(), name)) {
         return reinterpret_steal<object>(result);
-    } else {
-        PyErr_Clear();
-        return reinterpret_borrow<object>(default_);
     }
+    PyErr_Clear();
+    return reinterpret_borrow<object>(default_);
 }
 
 inline void setattr(handle obj, handle name, handle value) {
-    if (PyObject_SetAttr(obj.ptr(), name.ptr(), value.ptr()) != 0) { throw error_already_set(); }
+    if (PyObject_SetAttr(obj.ptr(), name.ptr(), value.ptr()) != 0) {
+        throw error_already_set();
+    }
 }
 
 inline void setattr(handle obj, const char *name, handle value) {
-    if (PyObject_SetAttrString(obj.ptr(), name, value.ptr()) != 0) { throw error_already_set(); }
+    if (PyObject_SetAttrString(obj.ptr(), name, value.ptr()) != 0) {
+        throw error_already_set();
+    }
 }
 
 inline ssize_t hash(handle obj) {
     auto h = PyObject_Hash(obj.ptr());
-    if (h == -1) { throw error_already_set(); }
+    if (h == -1) {
+        throw error_already_set();
+    }
     return h;
 }
 
 /// @} python_builtins
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 inline handle get_function(handle value) {
     if (value) {
 #if PY_MAJOR_VERSION >= 3
-        if (PyInstanceMethod_Check(value.ptr()))
+        if (PyInstanceMethod_Check(value.ptr())) {
             value = PyInstanceMethod_GET_FUNCTION(value.ptr());
-        else
+        } else
 #endif
-        if (PyMethod_Check(value.ptr()))
+            if (PyMethod_Check(value.ptr())) {
             value = PyMethod_GET_FUNCTION(value.ptr());
+        }
     }
     return value;
 }
 
-// Helper aliases/functions to support implicit casting of values given to python accessors/methods.
-// When given a pyobject, this simply returns the pyobject as-is; for other C++ type, the value goes
-// through pybind11::cast(obj) to convert it to an `object`.
+// Reimplementation of python's dict helper functions to ensure that exceptions
+// aren't swallowed (see #2862)
+
+// copied from cpython _PyDict_GetItemStringWithError
+inline PyObject *dict_getitemstring(PyObject *v, const char *key) {
+#if PY_MAJOR_VERSION >= 3
+    PyObject *kv = nullptr, *rv = nullptr;
+    kv = PyUnicode_FromString(key);
+    if (kv == NULL) {
+        throw error_already_set();
+    }
+
+    rv = PyDict_GetItemWithError(v, kv);
+    Py_DECREF(kv);
+    if (rv == NULL && PyErr_Occurred()) {
+        throw error_already_set();
+    }
+    return rv;
+#else
+    return PyDict_GetItemString(v, key);
+#endif
+}
+
+inline PyObject *dict_getitem(PyObject *v, PyObject *key) {
+#if PY_MAJOR_VERSION >= 3
+    PyObject *rv = PyDict_GetItemWithError(v, key);
+    if (rv == NULL && PyErr_Occurred()) {
+        throw error_already_set();
+    }
+    return rv;
+#else
+    return PyDict_GetItem(v, key);
+#endif
+}
+
+// Helper aliases/functions to support implicit casting of values given to python
+// accessors/methods. When given a pyobject, this simply returns the pyobject as-is; for other C++
+// type, the value goes through pybind11::cast(obj) to convert it to an `object`.
 template <typename T, enable_if_t<is_pyobject<T>::value, int> = 0>
-auto object_or_cast(T &&o) -> decltype(std::forward<T>(o)) { return std::forward<T>(o); }
+auto object_or_cast(T &&o) -> decltype(std::forward<T>(o)) {
+    return std::forward<T>(o);
+}
 // The following casting version is implemented in cast.h:
 template <typename T, enable_if_t<!is_pyobject<T>::value, int> = 0>
 object object_or_cast(T &&o);
 // Match a PyObject*, which we want to convert directly to handle via its converting constructor
 inline handle object_or_cast(PyObject *ptr) { return ptr; }
 
+#if defined(_MSC_VER) && _MSC_VER < 1920
+#    pragma warning(push)
+#    pragma warning(disable : 4522) // warning C4522: multiple assignment operators specified
+#endif
 template <typename Policy>
 class accessor : public object_api<accessor<Policy>> {
     using key_type = typename Policy::key_type;
 
 public:
-    accessor(handle obj, key_type key) : obj(obj), key(std::move(key)) { }
+    accessor(handle obj, key_type key) : obj(obj), key(std::move(key)) {}
     accessor(const accessor &) = default;
-    accessor(accessor &&) = default;
+    accessor(accessor &&) noexcept = default;
 
-    // accessor overload required to override default assignment operator (templates are not allowed
-    // to replace default compiler-generated assignments).
+    // accessor overload required to override default assignment operator (templates are not
+    // allowed to replace default compiler-generated assignments).
     void operator=(const accessor &a) && { std::move(*this).operator=(handle(a)); }
     void operator=(const accessor &a) & { operator=(handle(a)); }
 
-    template <typename T> void operator=(T &&value) && {
+    template <typename T>
+    void operator=(T &&value) && {
         Policy::set(obj, key, object_or_cast(std::forward<T>(value)));
     }
-    template <typename T> void operator=(T &&value) & {
+    template <typename T>
+    void operator=(T &&value) & {
         get_cache() = reinterpret_borrow<object>(object_or_cast(std::forward<T>(value)));
     }
 
     template <typename T = Policy>
-    PYBIND11_DEPRECATED("Use of obj.attr(...) as bool is deprecated in favor of pybind11::hasattr(obj, ...)")
-    explicit operator enable_if_t<std::is_same<T, accessor_policies::str_attr>::value ||
-            std::is_same<T, accessor_policies::obj_attr>::value, bool>() const {
+    PYBIND11_DEPRECATED(
+        "Use of obj.attr(...) as bool is deprecated in favor of pybind11::hasattr(obj, ...)")
+    explicit
+    operator enable_if_t<std::is_same<T, accessor_policies::str_attr>::value
+                             || std::is_same<T, accessor_policies::obj_attr>::value,
+                         bool>() const {
         return hasattr(obj, key);
     }
     template <typename T = Policy>
     PYBIND11_DEPRECATED("Use of obj[key] as bool is deprecated in favor of obj.contains(key)")
-    explicit operator enable_if_t<std::is_same<T, accessor_policies::generic_item>::value, bool>() const {
+    explicit
+    operator enable_if_t<std::is_same<T, accessor_policies::generic_item>::value, bool>() const {
         return obj.contains(key);
     }
 
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator object() const { return get_cache(); }
     PyObject *ptr() const { return get_cache().ptr(); }
-    template <typename T> T cast() const { return get_cache().template cast<T>(); }
+    template <typename T>
+    T cast() const {
+        return get_cache().template cast<T>();
+    }
 
 private:
     object &get_cache() const {
-        if (!cache) { cache = Policy::get(obj, key); }
+        if (!cache) {
+            cache = Policy::get(obj, key);
+        }
         return cache;
     }
 
 private:
     handle obj;
     key_type key;
     mutable object cache;
 };
+#if defined(_MSC_VER) && _MSC_VER < 1920
+#    pragma warning(pop)
+#endif
 
 PYBIND11_NAMESPACE_BEGIN(accessor_policies)
 struct obj_attr {
     using key_type = object;
     static object get(handle obj, handle key) { return getattr(obj, key); }
     static void set(handle obj, handle key, handle val) { setattr(obj, key, val); }
 };
@@ -550,69 +733,85 @@
 };
 
 struct generic_item {
     using key_type = object;
 
     static object get(handle obj, handle key) {
         PyObject *result = PyObject_GetItem(obj.ptr(), key.ptr());
-        if (!result) { throw error_already_set(); }
+        if (!result) {
+            throw error_already_set();
+        }
         return reinterpret_steal<object>(result);
     }
 
     static void set(handle obj, handle key, handle val) {
-        if (PyObject_SetItem(obj.ptr(), key.ptr(), val.ptr()) != 0) { throw error_already_set(); }
+        if (PyObject_SetItem(obj.ptr(), key.ptr(), val.ptr()) != 0) {
+            throw error_already_set();
+        }
     }
 };
 
 struct sequence_item {
     using key_type = size_t;
 
-    static object get(handle obj, size_t index) {
-        PyObject *result = PySequence_GetItem(obj.ptr(), static_cast<ssize_t>(index));
-        if (!result) { throw error_already_set(); }
+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
+    static object get(handle obj, const IdxType &index) {
+        PyObject *result = PySequence_GetItem(obj.ptr(), ssize_t_cast(index));
+        if (!result) {
+            throw error_already_set();
+        }
         return reinterpret_steal<object>(result);
     }
 
-    static void set(handle obj, size_t index, handle val) {
+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
+    static void set(handle obj, const IdxType &index, handle val) {
         // PySequence_SetItem does not steal a reference to 'val'
-        if (PySequence_SetItem(obj.ptr(), static_cast<ssize_t>(index), val.ptr()) != 0) {
+        if (PySequence_SetItem(obj.ptr(), ssize_t_cast(index), val.ptr()) != 0) {
             throw error_already_set();
         }
     }
 };
 
 struct list_item {
     using key_type = size_t;
 
-    static object get(handle obj, size_t index) {
-        PyObject *result = PyList_GetItem(obj.ptr(), static_cast<ssize_t>(index));
-        if (!result) { throw error_already_set(); }
+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
+    static object get(handle obj, const IdxType &index) {
+        PyObject *result = PyList_GetItem(obj.ptr(), ssize_t_cast(index));
+        if (!result) {
+            throw error_already_set();
+        }
         return reinterpret_borrow<object>(result);
     }
 
-    static void set(handle obj, size_t index, handle val) {
+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
+    static void set(handle obj, const IdxType &index, handle val) {
         // PyList_SetItem steals a reference to 'val'
-        if (PyList_SetItem(obj.ptr(), static_cast<ssize_t>(index), val.inc_ref().ptr()) != 0) {
+        if (PyList_SetItem(obj.ptr(), ssize_t_cast(index), val.inc_ref().ptr()) != 0) {
             throw error_already_set();
         }
     }
 };
 
 struct tuple_item {
     using key_type = size_t;
 
-    static object get(handle obj, size_t index) {
-        PyObject *result = PyTuple_GetItem(obj.ptr(), static_cast<ssize_t>(index));
-        if (!result) { throw error_already_set(); }
+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
+    static object get(handle obj, const IdxType &index) {
+        PyObject *result = PyTuple_GetItem(obj.ptr(), ssize_t_cast(index));
+        if (!result) {
+            throw error_already_set();
+        }
         return reinterpret_borrow<object>(result);
     }
 
-    static void set(handle obj, size_t index, handle val) {
+    template <typename IdxType, detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
+    static void set(handle obj, const IdxType &index, handle val) {
         // PyTuple_SetItem steals a reference to 'val'
-        if (PyTuple_SetItem(obj.ptr(), static_cast<ssize_t>(index), val.inc_ref().ptr()) != 0) {
+        if (PyTuple_SetItem(obj.ptr(), ssize_t_cast(index), val.inc_ref().ptr()) != 0) {
             throw error_already_set();
         }
     }
 };
 PYBIND11_NAMESPACE_END(accessor_policies)
 
 /// STL iterator template used for tuple, list, sequence and dict
@@ -624,60 +823,90 @@
     using difference_type = ssize_t;
     using iterator_category = typename Policy::iterator_category;
     using value_type = typename Policy::value_type;
     using reference = typename Policy::reference;
     using pointer = typename Policy::pointer;
 
     generic_iterator() = default;
-    generic_iterator(handle seq, ssize_t index) : Policy(seq, index) { }
+    generic_iterator(handle seq, ssize_t index) : Policy(seq, index) {}
 
+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
     reference operator*() const { return Policy::dereference(); }
+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
     reference operator[](difference_type n) const { return *(*this + n); }
     pointer operator->() const { return **this; }
 
-    It &operator++() { Policy::increment(); return *this; }
-    It operator++(int) { auto copy = *this; Policy::increment(); return copy; }
-    It &operator--() { Policy::decrement(); return *this; }
-    It operator--(int) { auto copy = *this; Policy::decrement(); return copy; }
-    It &operator+=(difference_type n) { Policy::advance(n); return *this; }
-    It &operator-=(difference_type n) { Policy::advance(-n); return *this; }
+    It &operator++() {
+        Policy::increment();
+        return *this;
+    }
+    It operator++(int) {
+        auto copy = *this;
+        Policy::increment();
+        return copy;
+    }
+    It &operator--() {
+        Policy::decrement();
+        return *this;
+    }
+    It operator--(int) {
+        auto copy = *this;
+        Policy::decrement();
+        return copy;
+    }
+    It &operator+=(difference_type n) {
+        Policy::advance(n);
+        return *this;
+    }
+    It &operator-=(difference_type n) {
+        Policy::advance(-n);
+        return *this;
+    }
 
-    friend It operator+(const It &a, difference_type n) { auto copy = a; return copy += n; }
+    friend It operator+(const It &a, difference_type n) {
+        auto copy = a;
+        return copy += n;
+    }
     friend It operator+(difference_type n, const It &b) { return b + n; }
-    friend It operator-(const It &a, difference_type n) { auto copy = a; return copy -= n; }
+    friend It operator-(const It &a, difference_type n) {
+        auto copy = a;
+        return copy -= n;
+    }
     friend difference_type operator-(const It &a, const It &b) { return a.distance_to(b); }
 
     friend bool operator==(const It &a, const It &b) { return a.equal(b); }
     friend bool operator!=(const It &a, const It &b) { return !(a == b); }
-    friend bool operator< (const It &a, const It &b) { return b - a > 0; }
-    friend bool operator> (const It &a, const It &b) { return b < a; }
+    friend bool operator<(const It &a, const It &b) { return b - a > 0; }
+    friend bool operator>(const It &a, const It &b) { return b < a; }
     friend bool operator>=(const It &a, const It &b) { return !(a < b); }
     friend bool operator<=(const It &a, const It &b) { return !(a > b); }
 };
 
 PYBIND11_NAMESPACE_BEGIN(iterator_policies)
 /// Quick proxy class needed to implement ``operator->`` for iterators which can't return pointers
 template <typename T>
 struct arrow_proxy {
     T value;
 
-    arrow_proxy(T &&value) : value(std::move(value)) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    arrow_proxy(T &&value) noexcept : value(std::move(value)) {}
     T *operator->() const { return &value; }
 };
 
 /// Lightweight iterator policy using just a simple pointer: see ``PySequence_Fast_ITEMS``
 class sequence_fast_readonly {
 protected:
     using iterator_category = std::random_access_iterator_tag;
     using value_type = handle;
-    using reference = const handle;
+    using reference = const handle; // PR #3263
     using pointer = arrow_proxy<const handle>;
 
-    sequence_fast_readonly(handle obj, ssize_t n) : ptr(PySequence_Fast_ITEMS(obj.ptr()) + n) { }
+    sequence_fast_readonly(handle obj, ssize_t n) : ptr(PySequence_Fast_ITEMS(obj.ptr()) + n) {}
 
+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
     reference dereference() const { return *ptr; }
     void increment() { ++ptr; }
     void decrement() { --ptr; }
     void advance(ssize_t n) { ptr += n; }
     bool equal(const sequence_fast_readonly &b) const { return ptr == b.ptr; }
     ssize_t distance_to(const sequence_fast_readonly &b) const { return ptr - b.ptr; }
 
@@ -689,15 +918,15 @@
 class sequence_slow_readwrite {
 protected:
     using iterator_category = std::random_access_iterator_tag;
     using value_type = object;
     using reference = sequence_accessor;
     using pointer = arrow_proxy<const sequence_accessor>;
 
-    sequence_slow_readwrite(handle obj, ssize_t index) : obj(obj), index(index) { }
+    sequence_slow_readwrite(handle obj, ssize_t index) : obj(obj), index(index) {}
 
     reference dereference() const { return {obj, static_cast<size_t>(index)}; }
     void increment() { ++index; }
     void decrement() { --index; }
     void advance(ssize_t n) { index += n; }
     bool equal(const sequence_slow_readwrite &b) const { return index == b.index; }
     ssize_t distance_to(const sequence_slow_readwrite &b) const { return index - b.index; }
@@ -708,22 +937,27 @@
 };
 
 /// Python's dictionary protocol permits this to be a forward iterator
 class dict_readonly {
 protected:
     using iterator_category = std::forward_iterator_tag;
     using value_type = std::pair<handle, handle>;
-    using reference = const value_type;
+    using reference = const value_type; // PR #3263
     using pointer = arrow_proxy<const value_type>;
 
     dict_readonly() = default;
     dict_readonly(handle obj, ssize_t pos) : obj(obj), pos(pos) { increment(); }
 
+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
     reference dereference() const { return {key, value}; }
-    void increment() { if (!PyDict_Next(obj.ptr(), &pos, &key, &value)) { pos = -1; } }
+    void increment() {
+        if (PyDict_Next(obj.ptr(), &pos, &key, &value) == 0) {
+            pos = -1;
+        }
+    }
     bool equal(const dict_readonly &b) const { return pos == b.pos; }
 
 private:
     handle obj;
     PyObject *key = nullptr, *value = nullptr;
     ssize_t pos = -1;
 };
@@ -741,97 +975,122 @@
 using dict_iterator = generic_iterator<iterator_policies::dict_readonly>;
 
 inline bool PyIterable_Check(PyObject *obj) {
     PyObject *iter = PyObject_GetIter(obj);
     if (iter) {
         Py_DECREF(iter);
         return true;
-    } else {
-        PyErr_Clear();
-        return false;
     }
+    PyErr_Clear();
+    return false;
 }
 
 inline bool PyNone_Check(PyObject *o) { return o == Py_None; }
 inline bool PyEllipsis_Check(PyObject *o) { return o == Py_Ellipsis; }
 
-inline bool PyUnicode_Check_Permissive(PyObject *o) { return PyUnicode_Check(o) || PYBIND11_BYTES_CHECK(o); }
+#ifdef PYBIND11_STR_LEGACY_PERMISSIVE
+inline bool PyUnicode_Check_Permissive(PyObject *o) {
+    return PyUnicode_Check(o) || PYBIND11_BYTES_CHECK(o);
+}
+#    define PYBIND11_STR_CHECK_FUN detail::PyUnicode_Check_Permissive
+#else
+#    define PYBIND11_STR_CHECK_FUN PyUnicode_Check
+#endif
 
 inline bool PyStaticMethod_Check(PyObject *o) { return o->ob_type == &PyStaticMethod_Type; }
 
 class kwargs_proxy : public handle {
 public:
-    explicit kwargs_proxy(handle h) : handle(h) { }
+    explicit kwargs_proxy(handle h) : handle(h) {}
 };
 
 class args_proxy : public handle {
 public:
-    explicit args_proxy(handle h) : handle(h) { }
+    explicit args_proxy(handle h) : handle(h) {}
     kwargs_proxy operator*() const { return kwargs_proxy(*this); }
 };
 
 /// Python argument categories (using PEP 448 terms)
-template <typename T> using is_keyword = std::is_base_of<arg, T>;
-template <typename T> using is_s_unpacking = std::is_same<args_proxy, T>; // * unpacking
-template <typename T> using is_ds_unpacking = std::is_same<kwargs_proxy, T>; // ** unpacking
-template <typename T> using is_positional = satisfies_none_of<T,
-    is_keyword, is_s_unpacking, is_ds_unpacking
->;
-template <typename T> using is_keyword_or_ds = satisfies_any_of<T, is_keyword, is_ds_unpacking>;
+template <typename T>
+using is_keyword = std::is_base_of<arg, T>;
+template <typename T>
+using is_s_unpacking = std::is_same<args_proxy, T>; // * unpacking
+template <typename T>
+using is_ds_unpacking = std::is_same<kwargs_proxy, T>; // ** unpacking
+template <typename T>
+using is_positional = satisfies_none_of<T, is_keyword, is_s_unpacking, is_ds_unpacking>;
+template <typename T>
+using is_keyword_or_ds = satisfies_any_of<T, is_keyword, is_ds_unpacking>;
 
 // Call argument collector forward declarations
 template <return_value_policy policy = return_value_policy::automatic_reference>
 class simple_collector;
 template <return_value_policy policy = return_value_policy::automatic_reference>
 class unpacking_collector;
 
 PYBIND11_NAMESPACE_END(detail)
 
 // TODO: After the deprecated constructors are removed, this macro can be simplified by
 //       inheriting ctors: `using Parent::Parent`. It's not an option right now because
 //       the `using` statement triggers the parent deprecation warning even if the ctor
 //       isn't even used.
-#define PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
-    public: \
-        PYBIND11_DEPRECATED("Use reinterpret_borrow<"#Name">() or reinterpret_steal<"#Name">()") \
-        Name(handle h, bool is_borrowed) : Parent(is_borrowed ? Parent(h, borrowed_t{}) : Parent(h, stolen_t{})) { } \
-        Name(handle h, borrowed_t) : Parent(h, borrowed_t{}) { } \
-        Name(handle h, stolen_t) : Parent(h, stolen_t{}) { } \
-        PYBIND11_DEPRECATED("Use py::isinstance<py::python_type>(obj) instead") \
-        bool check() const { return m_ptr != nullptr && (bool) CheckFun(m_ptr); } \
-        static bool check_(handle h) { return h.ptr() != nullptr && CheckFun(h.ptr()); } \
-        template <typename Policy_> \
-        Name(const ::pybind11::detail::accessor<Policy_> &a) : Name(object(a)) { }
-
-#define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun) \
-    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
-    /* This is deliberately not 'explicit' to allow implicit conversion from object: */ \
-    Name(const object &o) \
-    : Parent(check_(o) ? o.inc_ref().ptr() : ConvertFun(o.ptr()), stolen_t{}) \
-    { if (!m_ptr) throw error_already_set(); } \
-    Name(object &&o) \
-    : Parent(check_(o) ? o.release().ptr() : ConvertFun(o.ptr()), stolen_t{}) \
-    { if (!m_ptr) throw error_already_set(); }
-
-#define PYBIND11_OBJECT_CHECK_FAILED(Name, o) \
-    ::pybind11::type_error("Object of type '" + \
-                           ::pybind11::detail::get_fully_qualified_tp_name(Py_TYPE(o.ptr())) + \
-                           "' is not an instance of '" #Name "'")
-
-#define PYBIND11_OBJECT(Name, Parent, CheckFun) \
-    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun) \
-    /* This is deliberately not 'explicit' to allow implicit conversion from object: */ \
-    Name(const object &o) : Parent(o) \
-    { if (o && !check_(o)) throw PYBIND11_OBJECT_CHECK_FAILED(Name, o); } \
-    Name(object &&o) : Parent(std::move(o)) \
-    { if (o && !check_(o)) throw PYBIND11_OBJECT_CHECK_FAILED(Name, o); }
-
-#define PYBIND11_OBJECT_DEFAULT(Name, Parent, CheckFun) \
-    PYBIND11_OBJECT(Name, Parent, CheckFun) \
-    Name() : Parent() { }
+#define PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                                            \
+public:                                                                                           \
+    PYBIND11_DEPRECATED("Use reinterpret_borrow<" #Name ">() or reinterpret_steal<" #Name ">()")  \
+    Name(handle h, bool is_borrowed)                                                              \
+        : Parent(is_borrowed ? Parent(h, borrowed_t{}) : Parent(h, stolen_t{})) {}                \
+    Name(handle h, borrowed_t) : Parent(h, borrowed_t{}) {}                                       \
+    Name(handle h, stolen_t) : Parent(h, stolen_t{}) {}                                           \
+    PYBIND11_DEPRECATED("Use py::isinstance<py::python_type>(obj) instead")                       \
+    bool check() const { return m_ptr != nullptr && (CheckFun(m_ptr) != 0); }                     \
+    static bool check_(handle h) { return h.ptr() != nullptr && CheckFun(h.ptr()); }              \
+    template <typename Policy_> /* NOLINTNEXTLINE(google-explicit-constructor) */                 \
+    Name(const ::pybind11::detail::accessor<Policy_> &a) : Name(object(a)) {}
+
+#define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun)                                   \
+    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                                                \
+    /* This is deliberately not 'explicit' to allow implicit conversion from object: */           \
+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \
+    Name(const object &o)                                                                         \
+        : Parent(check_(o) ? o.inc_ref().ptr() : ConvertFun(o.ptr()), stolen_t{}) {               \
+        if (!m_ptr)                                                                               \
+            throw error_already_set();                                                            \
+    }                                                                                             \
+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \
+    Name(object &&o) : Parent(check_(o) ? o.release().ptr() : ConvertFun(o.ptr()), stolen_t{}) {  \
+        if (!m_ptr)                                                                               \
+            throw error_already_set();                                                            \
+    }
+
+#define PYBIND11_OBJECT_CVT_DEFAULT(Name, Parent, CheckFun, ConvertFun)                           \
+    PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun)                                       \
+    Name() : Parent() {}
+
+#define PYBIND11_OBJECT_CHECK_FAILED(Name, o_ptr)                                                 \
+    ::pybind11::type_error("Object of type '"                                                     \
+                           + ::pybind11::detail::get_fully_qualified_tp_name(Py_TYPE(o_ptr))      \
+                           + "' is not an instance of '" #Name "'")
+
+#define PYBIND11_OBJECT(Name, Parent, CheckFun)                                                   \
+    PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                                                \
+    /* This is deliberately not 'explicit' to allow implicit conversion from object: */           \
+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \
+    Name(const object &o) : Parent(o) {                                                           \
+        if (m_ptr && !check_(m_ptr))                                                              \
+            throw PYBIND11_OBJECT_CHECK_FAILED(Name, m_ptr);                                      \
+    }                                                                                             \
+    /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \
+    Name(object &&o) : Parent(std::move(o)) {                                                     \
+        if (m_ptr && !check_(m_ptr))                                                              \
+            throw PYBIND11_OBJECT_CHECK_FAILED(Name, m_ptr);                                      \
+    }
+
+#define PYBIND11_OBJECT_DEFAULT(Name, Parent, CheckFun)                                           \
+    PYBIND11_OBJECT(Name, Parent, CheckFun)                                                       \
+    Name() : Parent() {}
 
 /// \addtogroup pytypes
 /// @{
 
 /** \rst
     Wraps a Python iterator so that it can also be used as a C++ input iterator
 
@@ -841,39 +1100,43 @@
     value using ``operator*()``.
 \endrst */
 class iterator : public object {
 public:
     using iterator_category = std::input_iterator_tag;
     using difference_type = ssize_t;
     using value_type = handle;
-    using reference = const handle;
+    using reference = const handle; // PR #3263
     using pointer = const handle *;
 
     PYBIND11_OBJECT_DEFAULT(iterator, object, PyIter_Check)
 
-    iterator& operator++() {
+    iterator &operator++() {
         advance();
         return *this;
     }
 
     iterator operator++(int) {
         auto rv = *this;
         advance();
         return rv;
     }
 
+    // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
     reference operator*() const {
         if (m_ptr && !value.ptr()) {
-            auto& self = const_cast<iterator &>(*this);
+            auto &self = const_cast<iterator &>(*this);
             self.advance();
         }
         return value;
     }
 
-    pointer operator->() const { operator*(); return &value; }
+    pointer operator->() const {
+        operator*();
+        return &value;
+    }
 
     /** \rst
          The value which marks the end of the iteration. ``it == iterator::sentinel()``
          is equivalent to catching ``StopIteration`` in Python.
 
          .. code-block:: cpp
 
@@ -888,106 +1151,138 @@
 
     friend bool operator==(const iterator &a, const iterator &b) { return a->ptr() == b->ptr(); }
     friend bool operator!=(const iterator &a, const iterator &b) { return a->ptr() != b->ptr(); }
 
 private:
     void advance() {
         value = reinterpret_steal<object>(PyIter_Next(m_ptr));
-        if (PyErr_Occurred()) { throw error_already_set(); }
+        if (PyErr_Occurred()) {
+            throw error_already_set();
+        }
     }
 
 private:
     object value = {};
 };
 
-
-
 class type : public object {
 public:
     PYBIND11_OBJECT(type, object, PyType_Check)
 
     /// Return a type handle from a handle or an object
-    static handle handle_of(handle h) { return handle((PyObject*) Py_TYPE(h.ptr())); }
+    static handle handle_of(handle h) { return handle((PyObject *) Py_TYPE(h.ptr())); }
 
     /// Return a type object from a handle or an object
     static type of(handle h) { return type(type::handle_of(h), borrowed_t{}); }
 
     // Defined in pybind11/cast.h
     /// Convert C++ type to handle if previously registered. Does not convert
     /// standard types, like int, float. etc. yet.
     /// See https://github.com/pybind/pybind11/issues/2486
-    template<typename T>
+    template <typename T>
     static handle handle_of();
 
     /// Convert C++ type to type if previously registered. Does not convert
     /// standard types, like int, float. etc. yet.
     /// See https://github.com/pybind/pybind11/issues/2486
-    template<typename T>
-    static type of() {return type(type::handle_of<T>(), borrowed_t{}); }
+    template <typename T>
+    static type of() {
+        return type(type::handle_of<T>(), borrowed_t{});
+    }
 };
 
 class iterable : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(iterable, object, detail::PyIterable_Check)
 };
 
 class bytes;
 
 class str : public object {
 public:
-    PYBIND11_OBJECT_CVT(str, object, detail::PyUnicode_Check_Permissive, raw_str)
+    PYBIND11_OBJECT_CVT(str, object, PYBIND11_STR_CHECK_FUN, raw_str)
 
-    str(const char *c, size_t n)
-        : object(PyUnicode_FromStringAndSize(c, (ssize_t) n), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate string object!");
+    template <typename SzType, detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>
+    str(const char *c, const SzType &n)
+        : object(PyUnicode_FromStringAndSize(c, ssize_t_cast(n)), stolen_t{}) {
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate string object!");
+        }
     }
 
-    // 'explicit' is explicitly omitted from the following constructors to allow implicit conversion to py::str from C++ string-like objects
-    str(const char *c = "")
-        : object(PyUnicode_FromString(c), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate string object!");
+    // 'explicit' is explicitly omitted from the following constructors to allow implicit
+    // conversion to py::str from C++ string-like objects
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    str(const char *c = "") : object(PyUnicode_FromString(c), stolen_t{}) {
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate string object!");
+        }
     }
 
-    str(const std::string &s) : str(s.data(), s.size()) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    str(const std::string &s) : str(s.data(), s.size()) {}
+
+#ifdef PYBIND11_HAS_STRING_VIEW
+    // enable_if is needed to avoid "ambiguous conversion" errors (see PR #3521).
+    template <typename T, detail::enable_if_t<std::is_same<T, std::string_view>::value, int> = 0>
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    str(T s) : str(s.data(), s.size()) {}
+
+#    ifdef PYBIND11_HAS_U8STRING
+    // reinterpret_cast here is safe (C++20 guarantees char8_t has the same size/alignment as char)
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    str(std::u8string_view s) : str(reinterpret_cast<const char *>(s.data()), s.size()) {}
+#    endif
+
+#endif
 
     explicit str(const bytes &b);
 
     /** \rst
         Return a string representation of the object. This is analogous to
         the ``str()`` function in Python.
     \endrst */
-    explicit str(handle h) : object(raw_str(h.ptr()), stolen_t{}) { if (!m_ptr) throw error_already_set(); }
+    explicit str(handle h) : object(raw_str(h.ptr()), stolen_t{}) {
+        if (!m_ptr) {
+            throw error_already_set();
+        }
+    }
 
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator std::string() const {
         object temp = *this;
         if (PyUnicode_Check(m_ptr)) {
             temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(m_ptr));
-            if (!temp)
-                pybind11_fail("Unable to extract string contents! (encoding issue)");
+            if (!temp) {
+                throw error_already_set();
+            }
         }
-        char *buffer;
-        ssize_t length;
-        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length))
+        char *buffer = nullptr;
+        ssize_t length = 0;
+        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length)) {
             pybind11_fail("Unable to extract string contents! (invalid type)");
+        }
         return std::string(buffer, (size_t) length);
     }
 
     template <typename... Args>
     str format(Args &&...args) const {
         return attr("format")(std::forward<Args>(args)...);
     }
 
 private:
     /// Return string representation -- always returns a new reference, even if already a str
     static PyObject *raw_str(PyObject *op) {
         PyObject *str_value = PyObject_Str(op);
 #if PY_MAJOR_VERSION < 3
-        if (!str_value) throw error_already_set();
+        if (!str_value)
+            throw error_already_set();
         PyObject *unicode = PyUnicode_FromEncodedObject(str_value, "utf-8", nullptr);
-        Py_XDECREF(str_value); str_value = unicode;
+        Py_XDECREF(str_value);
+        str_value = unicode;
 #endif
         return str_value;
     }
 };
 /// @} pytypes
 
 inline namespace literals {
@@ -1000,375 +1295,524 @@
 /// \addtogroup pytypes
 /// @{
 class bytes : public object {
 public:
     PYBIND11_OBJECT(bytes, object, PYBIND11_BYTES_CHECK)
 
     // Allow implicit conversion:
-    bytes(const char *c = "")
-        : object(PYBIND11_BYTES_FROM_STRING(c), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate bytes object!");
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    bytes(const char *c = "") : object(PYBIND11_BYTES_FROM_STRING(c), stolen_t{}) {
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate bytes object!");
+        }
     }
 
-    bytes(const char *c, size_t n)
-        : object(PYBIND11_BYTES_FROM_STRING_AND_SIZE(c, (ssize_t) n), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate bytes object!");
+    template <typename SzType, detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>
+    bytes(const char *c, const SzType &n)
+        : object(PYBIND11_BYTES_FROM_STRING_AND_SIZE(c, ssize_t_cast(n)), stolen_t{}) {
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate bytes object!");
+        }
     }
 
     // Allow implicit conversion:
-    bytes(const std::string &s) : bytes(s.data(), s.size()) { }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    bytes(const std::string &s) : bytes(s.data(), s.size()) {}
 
     explicit bytes(const pybind11::str &s);
 
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator std::string() const {
-        char *buffer;
-        ssize_t length;
-        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length))
+        char *buffer = nullptr;
+        ssize_t length = 0;
+        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length)) {
             pybind11_fail("Unable to extract bytes contents!");
+        }
         return std::string(buffer, (size_t) length);
     }
+
+#ifdef PYBIND11_HAS_STRING_VIEW
+    // enable_if is needed to avoid "ambiguous conversion" errors (see PR #3521).
+    template <typename T, detail::enable_if_t<std::is_same<T, std::string_view>::value, int> = 0>
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    bytes(T s) : bytes(s.data(), s.size()) {}
+
+    // Obtain a string view that views the current `bytes` buffer value.  Note that this is only
+    // valid so long as the `bytes` instance remains alive and so generally should not outlive the
+    // lifetime of the `bytes` instance.
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator std::string_view() const {
+        char *buffer = nullptr;
+        ssize_t length = 0;
+        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length)) {
+            pybind11_fail("Unable to extract bytes contents!");
+        }
+        return {buffer, static_cast<size_t>(length)};
+    }
+#endif
 };
 // Note: breathe >= 4.17.0 will fail to build docs if the below two constructors
 // are included in the doxygen group; close here and reopen after as a workaround
 /// @} pytypes
 
 inline bytes::bytes(const pybind11::str &s) {
     object temp = s;
     if (PyUnicode_Check(s.ptr())) {
         temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(s.ptr()));
-        if (!temp)
+        if (!temp) {
             pybind11_fail("Unable to extract string contents! (encoding issue)");
+        }
     }
-    char *buffer;
-    ssize_t length;
-    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length))
+    char *buffer = nullptr;
+    ssize_t length = 0;
+    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length)) {
         pybind11_fail("Unable to extract string contents! (invalid type)");
+    }
     auto obj = reinterpret_steal<object>(PYBIND11_BYTES_FROM_STRING_AND_SIZE(buffer, length));
-    if (!obj)
+    if (!obj) {
         pybind11_fail("Could not allocate bytes object!");
+    }
     m_ptr = obj.release().ptr();
 }
 
-inline str::str(const bytes& b) {
-    char *buffer;
-    ssize_t length;
-    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(b.ptr(), &buffer, &length))
+inline str::str(const bytes &b) {
+    char *buffer = nullptr;
+    ssize_t length = 0;
+    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(b.ptr(), &buffer, &length)) {
         pybind11_fail("Unable to extract bytes contents!");
-    auto obj = reinterpret_steal<object>(PyUnicode_FromStringAndSize(buffer, (ssize_t) length));
-    if (!obj)
+    }
+    auto obj = reinterpret_steal<object>(PyUnicode_FromStringAndSize(buffer, length));
+    if (!obj) {
         pybind11_fail("Could not allocate string object!");
+    }
     m_ptr = obj.release().ptr();
 }
 
 /// \addtogroup pytypes
 /// @{
+class bytearray : public object {
+public:
+    PYBIND11_OBJECT_CVT(bytearray, object, PyByteArray_Check, PyByteArray_FromObject)
+
+    template <typename SzType, detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>
+    bytearray(const char *c, const SzType &n)
+        : object(PyByteArray_FromStringAndSize(c, ssize_t_cast(n)), stolen_t{}) {
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate bytearray object!");
+        }
+    }
+
+    bytearray() : bytearray("", 0) {}
+
+    explicit bytearray(const std::string &s) : bytearray(s.data(), s.size()) {}
+
+    size_t size() const { return static_cast<size_t>(PyByteArray_Size(m_ptr)); }
+
+    explicit operator std::string() const {
+        char *buffer = PyByteArray_AS_STRING(m_ptr);
+        ssize_t size = PyByteArray_GET_SIZE(m_ptr);
+        return std::string(buffer, static_cast<size_t>(size));
+    }
+};
+// Note: breathe >= 4.17.0 will fail to build docs if the below two constructors
+// are included in the doxygen group; close here and reopen after as a workaround
+/// @} pytypes
+
+/// \addtogroup pytypes
+/// @{
 class none : public object {
 public:
     PYBIND11_OBJECT(none, object, detail::PyNone_Check)
-    none() : object(Py_None, borrowed_t{}) { }
+    none() : object(Py_None, borrowed_t{}) {}
 };
 
 class ellipsis : public object {
 public:
     PYBIND11_OBJECT(ellipsis, object, detail::PyEllipsis_Check)
-    ellipsis() : object(Py_Ellipsis, borrowed_t{}) { }
+    ellipsis() : object(Py_Ellipsis, borrowed_t{}) {}
 };
 
 class bool_ : public object {
 public:
     PYBIND11_OBJECT_CVT(bool_, object, PyBool_Check, raw_bool)
-    bool_() : object(Py_False, borrowed_t{}) { }
+    bool_() : object(Py_False, borrowed_t{}) {}
     // Allow implicit conversion from and to `bool`:
-    bool_(bool value) : object(value ? Py_True : Py_False, borrowed_t{}) { }
-    operator bool() const { return m_ptr && PyLong_AsLong(m_ptr) != 0; }
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    bool_(bool value) : object(value ? Py_True : Py_False, borrowed_t{}) {}
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    operator bool() const { return (m_ptr != nullptr) && PyLong_AsLong(m_ptr) != 0; }
 
 private:
     /// Return the truth value of an object -- always returns a new reference
     static PyObject *raw_bool(PyObject *op) {
         const auto value = PyObject_IsTrue(op);
-        if (value == -1) return nullptr;
-        return handle(value ? Py_True : Py_False).inc_ref().ptr();
+        if (value == -1) {
+            return nullptr;
+        }
+        return handle(value != 0 ? Py_True : Py_False).inc_ref().ptr();
     }
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 // Converts a value to the given unsigned type.  If an error occurs, you get back (Unsigned) -1;
 // otherwise you get back the unsigned long or unsigned long long value cast to (Unsigned).
 // (The distinction is critically important when casting a returned -1 error value to some other
 // unsigned type: (A)-1 != (B)-1 when A and B are unsigned types of different sizes).
 template <typename Unsigned>
 Unsigned as_unsigned(PyObject *o) {
-    if (sizeof(Unsigned) <= sizeof(unsigned long)
+    if (PYBIND11_SILENCE_MSVC_C4127(sizeof(Unsigned) <= sizeof(unsigned long))
 #if PY_VERSION_HEX < 0x03000000
-            || PyInt_Check(o)
+        || PyInt_Check(o)
 #endif
     ) {
         unsigned long v = PyLong_AsUnsignedLong(o);
         return v == (unsigned long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
     }
-    else {
-        unsigned long long v = PyLong_AsUnsignedLongLong(o);
-        return v == (unsigned long long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
-    }
+    unsigned long long v = PyLong_AsUnsignedLongLong(o);
+    return v == (unsigned long long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
 }
 PYBIND11_NAMESPACE_END(detail)
 
 class int_ : public object {
 public:
     PYBIND11_OBJECT_CVT(int_, object, PYBIND11_LONG_CHECK, PyNumber_Long)
-    int_() : object(PyLong_FromLong(0), stolen_t{}) { }
+    int_() : object(PyLong_FromLong(0), stolen_t{}) {}
     // Allow implicit conversion from C++ integral types:
-    template <typename T,
-              detail::enable_if_t<std::is_integral<T>::value, int> = 0>
+    template <typename T, detail::enable_if_t<std::is_integral<T>::value, int> = 0>
+    // NOLINTNEXTLINE(google-explicit-constructor)
     int_(T value) {
-        if (sizeof(T) <= sizeof(long)) {
-            if (std::is_signed<T>::value)
+        if (PYBIND11_SILENCE_MSVC_C4127(sizeof(T) <= sizeof(long))) {
+            if (std::is_signed<T>::value) {
                 m_ptr = PyLong_FromLong((long) value);
-            else
+            } else {
                 m_ptr = PyLong_FromUnsignedLong((unsigned long) value);
+            }
         } else {
-            if (std::is_signed<T>::value)
+            if (std::is_signed<T>::value) {
                 m_ptr = PyLong_FromLongLong((long long) value);
-            else
+            } else {
                 m_ptr = PyLong_FromUnsignedLongLong((unsigned long long) value);
+            }
+        }
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate int object!");
         }
-        if (!m_ptr) pybind11_fail("Could not allocate int object!");
     }
 
-    template <typename T,
-              detail::enable_if_t<std::is_integral<T>::value, int> = 0>
+    template <typename T, detail::enable_if_t<std::is_integral<T>::value, int> = 0>
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator T() const {
-        return std::is_unsigned<T>::value
-            ? detail::as_unsigned<T>(m_ptr)
-            : sizeof(T) <= sizeof(long)
-              ? (T) PyLong_AsLong(m_ptr)
-              : (T) PYBIND11_LONG_AS_LONGLONG(m_ptr);
+        return std::is_unsigned<T>::value  ? detail::as_unsigned<T>(m_ptr)
+               : sizeof(T) <= sizeof(long) ? (T) PyLong_AsLong(m_ptr)
+                                           : (T) PYBIND11_LONG_AS_LONGLONG(m_ptr);
     }
 };
 
 class float_ : public object {
 public:
     PYBIND11_OBJECT_CVT(float_, object, PyFloat_Check, PyNumber_Float)
     // Allow implicit conversion from float/double:
+    // NOLINTNEXTLINE(google-explicit-constructor)
     float_(float value) : object(PyFloat_FromDouble((double) value), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate float object!");
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate float object!");
+        }
     }
+    // NOLINTNEXTLINE(google-explicit-constructor)
     float_(double value = .0) : object(PyFloat_FromDouble((double) value), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate float object!");
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate float object!");
+        }
     }
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator float() const { return (float) PyFloat_AsDouble(m_ptr); }
+    // NOLINTNEXTLINE(google-explicit-constructor)
     operator double() const { return (double) PyFloat_AsDouble(m_ptr); }
 };
 
 class weakref : public object {
 public:
-    PYBIND11_OBJECT_DEFAULT(weakref, object, PyWeakref_Check)
+    PYBIND11_OBJECT_CVT_DEFAULT(weakref, object, PyWeakref_Check, raw_weakref)
     explicit weakref(handle obj, handle callback = {})
         : object(PyWeakref_NewRef(obj.ptr(), callback.ptr()), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate weak reference!");
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate weak reference!");
+        }
     }
+
+private:
+    static PyObject *raw_weakref(PyObject *o) { return PyWeakref_NewRef(o, nullptr); }
 };
 
 class slice : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(slice, object, PySlice_Check)
-    slice(ssize_t start_, ssize_t stop_, ssize_t step_) {
-        int_ start(start_), stop(stop_), step(step_);
+    slice(handle start, handle stop, handle step) {
         m_ptr = PySlice_New(start.ptr(), stop.ptr(), step.ptr());
-        if (!m_ptr) pybind11_fail("Could not allocate slice object!");
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate slice object!");
+        }
     }
-    bool compute(size_t length, size_t *start, size_t *stop, size_t *step,
-                 size_t *slicelength) const {
+
+#ifdef PYBIND11_HAS_OPTIONAL
+    slice(std::optional<ssize_t> start, std::optional<ssize_t> stop, std::optional<ssize_t> step)
+        : slice(index_to_object(start), index_to_object(stop), index_to_object(step)) {}
+#else
+    slice(ssize_t start_, ssize_t stop_, ssize_t step_)
+        : slice(int_(start_), int_(stop_), int_(step_)) {}
+#endif
+
+    bool
+    compute(size_t length, size_t *start, size_t *stop, size_t *step, size_t *slicelength) const {
         return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *) m_ptr,
-                                    (ssize_t) length, (ssize_t *) start,
-                                    (ssize_t *) stop, (ssize_t *) step,
-                                    (ssize_t *) slicelength) == 0;
-    }
-    bool compute(ssize_t length, ssize_t *start, ssize_t *stop, ssize_t *step,
-      ssize_t *slicelength) const {
-      return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *) m_ptr,
-          length, start,
-          stop, step,
-          slicelength) == 0;
+                                    (ssize_t) length,
+                                    (ssize_t *) start,
+                                    (ssize_t *) stop,
+                                    (ssize_t *) step,
+                                    (ssize_t *) slicelength)
+               == 0;
+    }
+    bool compute(
+        ssize_t length, ssize_t *start, ssize_t *stop, ssize_t *step, ssize_t *slicelength) const {
+        return PySlice_GetIndicesEx(
+                   (PYBIND11_SLICE_OBJECT *) m_ptr, length, start, stop, step, slicelength)
+               == 0;
+    }
+
+private:
+    template <typename T>
+    static object index_to_object(T index) {
+        return index ? object(int_(*index)) : object(none());
     }
 };
 
 class capsule : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(capsule, object, PyCapsule_CheckExact)
     PYBIND11_DEPRECATED("Use reinterpret_borrow<capsule>() or reinterpret_steal<capsule>()")
-    capsule(PyObject *ptr, bool is_borrowed) : object(is_borrowed ? object(ptr, borrowed_t{}) : object(ptr, stolen_t{})) { }
+    capsule(PyObject *ptr, bool is_borrowed)
+        : object(is_borrowed ? object(ptr, borrowed_t{}) : object(ptr, stolen_t{})) {}
 
-    explicit capsule(const void *value, const char *name = nullptr, void (*destructor)(PyObject *) = nullptr)
+    explicit capsule(const void *value,
+                     const char *name = nullptr,
+                     void (*destructor)(PyObject *) = nullptr)
         : object(PyCapsule_New(const_cast<void *>(value), name, destructor), stolen_t{}) {
-        if (!m_ptr)
+        if (!m_ptr) {
             pybind11_fail("Could not allocate capsule object!");
+        }
     }
 
     PYBIND11_DEPRECATED("Please pass a destructor that takes a void pointer as input")
     capsule(const void *value, void (*destruct)(PyObject *))
-        : object(PyCapsule_New(const_cast<void*>(value), nullptr, destruct), stolen_t{}) {
-        if (!m_ptr)
+        : object(PyCapsule_New(const_cast<void *>(value), nullptr, destruct), stolen_t{}) {
+        if (!m_ptr) {
             pybind11_fail("Could not allocate capsule object!");
+        }
     }
 
     capsule(const void *value, void (*destructor)(void *)) {
         m_ptr = PyCapsule_New(const_cast<void *>(value), nullptr, [](PyObject *o) {
             auto destructor = reinterpret_cast<void (*)(void *)>(PyCapsule_GetContext(o));
             void *ptr = PyCapsule_GetPointer(o, nullptr);
             destructor(ptr);
         });
 
-        if (!m_ptr)
+        if (!m_ptr) {
             pybind11_fail("Could not allocate capsule object!");
+        }
 
-        if (PyCapsule_SetContext(m_ptr, (void *) destructor) != 0)
+        if (PyCapsule_SetContext(m_ptr, (void *) destructor) != 0) {
             pybind11_fail("Could not set capsule context!");
+        }
     }
 
-    capsule(void (*destructor)()) {
+    explicit capsule(void (*destructor)()) {
         m_ptr = PyCapsule_New(reinterpret_cast<void *>(destructor), nullptr, [](PyObject *o) {
             auto destructor = reinterpret_cast<void (*)()>(PyCapsule_GetPointer(o, nullptr));
             destructor();
         });
 
-        if (!m_ptr)
+        if (!m_ptr) {
             pybind11_fail("Could not allocate capsule object!");
+        }
     }
 
-    template <typename T> operator T *() const {
+    template <typename T>
+    operator T *() const { // NOLINT(google-explicit-constructor)
         return get_pointer<T>();
     }
 
     /// Get the pointer the capsule holds.
-    template<typename T = void>
-    T* get_pointer() const {
-        auto name = this->name();
+    template <typename T = void>
+    T *get_pointer() const {
+        const auto *name = this->name();
         T *result = static_cast<T *>(PyCapsule_GetPointer(m_ptr, name));
-        if (!result) pybind11_fail("Unable to extract capsule contents!");
+        if (!result) {
+            PyErr_Clear();
+            pybind11_fail("Unable to extract capsule contents!");
+        }
         return result;
     }
 
     /// Replaces a capsule's pointer *without* calling the destructor on the existing one.
     void set_pointer(const void *value) {
-        if (PyCapsule_SetPointer(m_ptr, const_cast<void *>(value)) != 0)
+        if (PyCapsule_SetPointer(m_ptr, const_cast<void *>(value)) != 0) {
+            PyErr_Clear();
             pybind11_fail("Could not set capsule pointer");
+        }
     }
 
     const char *name() const { return PyCapsule_GetName(m_ptr); }
 };
 
 class tuple : public object {
 public:
     PYBIND11_OBJECT_CVT(tuple, object, PyTuple_Check, PySequence_Tuple)
-    explicit tuple(size_t size = 0) : object(PyTuple_New((ssize_t) size), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate tuple object!");
+    template <typename SzType = ssize_t,
+              detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>
+    // Some compilers generate link errors when using `const SzType &` here:
+    explicit tuple(SzType size = 0) : object(PyTuple_New(ssize_t_cast(size)), stolen_t{}) {
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate tuple object!");
+        }
     }
     size_t size() const { return (size_t) PyTuple_Size(m_ptr); }
     bool empty() const { return size() == 0; }
     detail::tuple_accessor operator[](size_t index) const { return {*this, index}; }
     detail::item_accessor operator[](handle h) const { return object::operator[](h); }
     detail::tuple_iterator begin() const { return {*this, 0}; }
     detail::tuple_iterator end() const { return {*this, PyTuple_GET_SIZE(m_ptr)}; }
 };
 
+// We need to put this into a separate function because the Intel compiler
+// fails to compile enable_if_t<all_of<is_keyword_or_ds<Args>...>::value> part below
+// (tested with ICC 2021.1 Beta 20200827).
+template <typename... Args>
+constexpr bool args_are_all_keyword_or_ds() {
+    return detail::all_of<detail::is_keyword_or_ds<Args>...>::value;
+}
+
 class dict : public object {
 public:
     PYBIND11_OBJECT_CVT(dict, object, PyDict_Check, raw_dict)
     dict() : object(PyDict_New(), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate dict object!");
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate dict object!");
+        }
     }
     template <typename... Args,
-              typename = detail::enable_if_t<detail::all_of<detail::is_keyword_or_ds<Args>...>::value>,
-              // MSVC workaround: it can't compile an out-of-line definition, so defer the collector
+              typename = detail::enable_if_t<args_are_all_keyword_or_ds<Args...>()>,
+              // MSVC workaround: it can't compile an out-of-line definition, so defer the
+              // collector
               typename collector = detail::deferred_t<detail::unpacking_collector<>, Args...>>
-    explicit dict(Args &&...args) : dict(collector(std::forward<Args>(args)...).kwargs()) { }
+    explicit dict(Args &&...args) : dict(collector(std::forward<Args>(args)...).kwargs()) {}
 
     size_t size() const { return (size_t) PyDict_Size(m_ptr); }
     bool empty() const { return size() == 0; }
     detail::dict_iterator begin() const { return {*this, 0}; }
     detail::dict_iterator end() const { return {}; }
-    void clear() const { PyDict_Clear(ptr()); }
-    template <typename T> bool contains(T &&key) const {
+    void clear() /* py-non-const */ { PyDict_Clear(ptr()); }
+    template <typename T>
+    bool contains(T &&key) const {
         return PyDict_Contains(m_ptr, detail::object_or_cast(std::forward<T>(key)).ptr()) == 1;
     }
 
 private:
     /// Call the `dict` Python type -- always returns a new reference
     static PyObject *raw_dict(PyObject *op) {
-        if (PyDict_Check(op))
+        if (PyDict_Check(op)) {
             return handle(op).inc_ref().ptr();
+        }
         return PyObject_CallFunctionObjArgs((PyObject *) &PyDict_Type, op, nullptr);
     }
 };
 
 class sequence : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(sequence, object, PySequence_Check)
     size_t size() const {
         ssize_t result = PySequence_Size(m_ptr);
-        if (result == -1)
+        if (result == -1) {
             throw error_already_set();
+        }
         return (size_t) result;
     }
     bool empty() const { return size() == 0; }
     detail::sequence_accessor operator[](size_t index) const { return {*this, index}; }
     detail::item_accessor operator[](handle h) const { return object::operator[](h); }
     detail::sequence_iterator begin() const { return {*this, 0}; }
     detail::sequence_iterator end() const { return {*this, PySequence_Size(m_ptr)}; }
 };
 
 class list : public object {
 public:
     PYBIND11_OBJECT_CVT(list, object, PyList_Check, PySequence_List)
-    explicit list(size_t size = 0) : object(PyList_New((ssize_t) size), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate list object!");
+    template <typename SzType = ssize_t,
+              detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>
+    // Some compilers generate link errors when using `const SzType &` here:
+    explicit list(SzType size = 0) : object(PyList_New(ssize_t_cast(size)), stolen_t{}) {
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate list object!");
+        }
     }
     size_t size() const { return (size_t) PyList_Size(m_ptr); }
     bool empty() const { return size() == 0; }
     detail::list_accessor operator[](size_t index) const { return {*this, index}; }
     detail::item_accessor operator[](handle h) const { return object::operator[](h); }
     detail::list_iterator begin() const { return {*this, 0}; }
     detail::list_iterator end() const { return {*this, PyList_GET_SIZE(m_ptr)}; }
-    template <typename T> void append(T &&val) const {
+    template <typename T>
+    void append(T &&val) /* py-non-const */ {
         PyList_Append(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr());
     }
-    template <typename T> void insert(size_t index, T &&val) const {
-        PyList_Insert(m_ptr, static_cast<ssize_t>(index),
-            detail::object_or_cast(std::forward<T>(val)).ptr());
+    template <typename IdxType,
+              typename ValType,
+              detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
+    void insert(const IdxType &index, ValType &&val) /* py-non-const */ {
+        PyList_Insert(
+            m_ptr, ssize_t_cast(index), detail::object_or_cast(std::forward<ValType>(val)).ptr());
     }
 };
 
-class args : public tuple { PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check) };
-class kwargs : public dict { PYBIND11_OBJECT_DEFAULT(kwargs, dict, PyDict_Check)  };
+class args : public tuple {
+    PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check)
+};
+class kwargs : public dict {
+    PYBIND11_OBJECT_DEFAULT(kwargs, dict, PyDict_Check)
+};
 
 class set : public object {
 public:
     PYBIND11_OBJECT_CVT(set, object, PySet_Check, PySet_New)
     set() : object(PySet_New(nullptr), stolen_t{}) {
-        if (!m_ptr) pybind11_fail("Could not allocate set object!");
+        if (!m_ptr) {
+            pybind11_fail("Could not allocate set object!");
+        }
     }
     size_t size() const { return (size_t) PySet_Size(m_ptr); }
     bool empty() const { return size() == 0; }
-    template <typename T> bool add(T &&val) const {
+    template <typename T>
+    bool add(T &&val) /* py-non-const */ {
         return PySet_Add(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 0;
     }
-    void clear() const { PySet_Clear(m_ptr); }
-    template <typename T> bool contains(T &&val) const {
+    void clear() /* py-non-const */ { PySet_Clear(m_ptr); }
+    template <typename T>
+    bool contains(T &&val) const {
         return PySet_Contains(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 1;
     }
 };
 
 class function : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(function, object, PyCallable_Check)
     handle cpp_function() const {
         handle fun = detail::get_function(m_ptr);
-        if (fun && PyCFunction_Check(fun.ptr()))
+        if (fun && PyCFunction_Check(fun.ptr())) {
             return fun;
+        }
         return handle();
     }
     bool is_cpp_function() const { return (bool) cpp_function(); }
 };
 
 class staticmethod : public object {
 public:
@@ -1377,15 +1821,17 @@
 
 class buffer : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(buffer, object, PyObject_CheckBuffer)
 
     buffer_info request(bool writable = false) const {
         int flags = PyBUF_STRIDES | PyBUF_FORMAT;
-        if (writable) flags |= PyBUF_WRITABLE;
+        if (writable) {
+            flags |= PyBUF_WRITABLE;
+        }
         auto *view = new Py_buffer();
         if (PyObject_GetBuffer(m_ptr, view, flags) != 0) {
             delete view;
             throw error_already_set();
         }
         return buffer_info(view);
     }
@@ -1400,146 +1846,168 @@
 
         ``buffer_info`` must be created from ``buffer::request()``. Otherwise
         throws an exception.
 
         For creating a ``memoryview`` from objects that support buffer protocol,
         use ``memoryview(const object& obj)`` instead of this constructor.
      \endrst */
-    explicit memoryview(const buffer_info& info) {
-        if (!info.view())
+    explicit memoryview(const buffer_info &info) {
+        if (!info.view()) {
             pybind11_fail("Prohibited to create memoryview without Py_buffer");
+        }
         // Note: PyMemoryView_FromBuffer never increments obj reference.
-        m_ptr = (info.view()->obj) ?
-            PyMemoryView_FromObject(info.view()->obj) :
-            PyMemoryView_FromBuffer(info.view());
-        if (!m_ptr)
+        m_ptr = (info.view()->obj) ? PyMemoryView_FromObject(info.view()->obj)
+                                   : PyMemoryView_FromBuffer(info.view());
+        if (!m_ptr) {
             pybind11_fail("Unable to create memoryview from buffer descriptor");
+        }
     }
 
     /** \rst
         Creates ``memoryview`` from static buffer.
 
         This method is meant for providing a ``memoryview`` for C/C++ buffer not
         managed by Python. The caller is responsible for managing the lifetime
         of ``ptr`` and ``format``, which MUST outlive the memoryview constructed
         here.
 
         See also: Python C API documentation for `PyMemoryView_FromBuffer`_.
 
-        .. _PyMemoryView_FromBuffer: https://docs.python.org/c-api/memoryview.html#c.PyMemoryView_FromBuffer
+        .. _PyMemoryView_FromBuffer:
+           https://docs.python.org/c-api/memoryview.html#c.PyMemoryView_FromBuffer
 
         :param ptr: Pointer to the buffer.
         :param itemsize: Byte size of an element.
         :param format: Pointer to the null-terminated format string. For
             homogeneous Buffers, this should be set to
             ``format_descriptor<T>::value``.
         :param shape: Shape of the tensor (1 entry per dimension).
         :param strides: Number of bytes between adjacent entries (for each
             per dimension).
         :param readonly: Flag to indicate if the underlying storage may be
             written to.
      \endrst */
-    static memoryview from_buffer(
-        void *ptr, ssize_t itemsize, const char *format,
-        detail::any_container<ssize_t> shape,
-        detail::any_container<ssize_t> strides, bool readonly = false);
-
-    static memoryview from_buffer(
-        const void *ptr, ssize_t itemsize, const char *format,
-        detail::any_container<ssize_t> shape,
-        detail::any_container<ssize_t> strides) {
+    static memoryview from_buffer(void *ptr,
+                                  ssize_t itemsize,
+                                  const char *format,
+                                  detail::any_container<ssize_t> shape,
+                                  detail::any_container<ssize_t> strides,
+                                  bool readonly = false);
+
+    static memoryview from_buffer(const void *ptr,
+                                  ssize_t itemsize,
+                                  const char *format,
+                                  detail::any_container<ssize_t> shape,
+                                  detail::any_container<ssize_t> strides) {
         return memoryview::from_buffer(
-            const_cast<void*>(ptr), itemsize, format, shape, strides, true);
+            const_cast<void *>(ptr), itemsize, format, std::move(shape), std::move(strides), true);
     }
 
-    template<typename T>
-    static memoryview from_buffer(
-        T *ptr, detail::any_container<ssize_t> shape,
-        detail::any_container<ssize_t> strides, bool readonly = false) {
-        return memoryview::from_buffer(
-            reinterpret_cast<void*>(ptr), sizeof(T),
-            format_descriptor<T>::value, shape, strides, readonly);
-    }
-
-    template<typename T>
-    static memoryview from_buffer(
-        const T *ptr, detail::any_container<ssize_t> shape,
-        detail::any_container<ssize_t> strides) {
-        return memoryview::from_buffer(
-            const_cast<T*>(ptr), shape, strides, true);
+    template <typename T>
+    static memoryview from_buffer(T *ptr,
+                                  detail::any_container<ssize_t> shape,
+                                  detail::any_container<ssize_t> strides,
+                                  bool readonly = false) {
+        return memoryview::from_buffer(reinterpret_cast<void *>(ptr),
+                                       sizeof(T),
+                                       format_descriptor<T>::value,
+                                       shape,
+                                       strides,
+                                       readonly);
+    }
+
+    template <typename T>
+    static memoryview from_buffer(const T *ptr,
+                                  detail::any_container<ssize_t> shape,
+                                  detail::any_container<ssize_t> strides) {
+        return memoryview::from_buffer(const_cast<T *>(ptr), shape, strides, true);
     }
 
 #if PY_MAJOR_VERSION >= 3
     /** \rst
         Creates ``memoryview`` from static memory.
 
         This method is meant for providing a ``memoryview`` for C/C++ buffer not
         managed by Python. The caller is responsible for managing the lifetime
         of ``mem``, which MUST outlive the memoryview constructed here.
 
         This method is not available in Python 2.
 
         See also: Python C API documentation for `PyMemoryView_FromBuffer`_.
 
-        .. _PyMemoryView_FromMemory: https://docs.python.org/c-api/memoryview.html#c.PyMemoryView_FromMemory
+        .. _PyMemoryView_FromMemory:
+           https://docs.python.org/c-api/memoryview.html#c.PyMemoryView_FromMemory
      \endrst */
     static memoryview from_memory(void *mem, ssize_t size, bool readonly = false) {
-        PyObject* ptr = PyMemoryView_FromMemory(
-            reinterpret_cast<char*>(mem), size,
-            (readonly) ? PyBUF_READ : PyBUF_WRITE);
-        if (!ptr)
+        PyObject *ptr = PyMemoryView_FromMemory(
+            reinterpret_cast<char *>(mem), size, (readonly) ? PyBUF_READ : PyBUF_WRITE);
+        if (!ptr) {
             pybind11_fail("Could not allocate memoryview object!");
+        }
         return memoryview(object(ptr, stolen_t{}));
     }
 
     static memoryview from_memory(const void *mem, ssize_t size) {
-        return memoryview::from_memory(const_cast<void*>(mem), size, true);
+        return memoryview::from_memory(const_cast<void *>(mem), size, true);
     }
+
+#    ifdef PYBIND11_HAS_STRING_VIEW
+    static memoryview from_memory(std::string_view mem) {
+        return from_memory(const_cast<char *>(mem.data()), static_cast<ssize_t>(mem.size()), true);
+    }
+#    endif
+
 #endif
 };
 
-#ifndef DOXYGEN_SHOULD_SKIP_THIS
-inline memoryview memoryview::from_buffer(
-    void *ptr, ssize_t itemsize, const char* format,
-    detail::any_container<ssize_t> shape,
-    detail::any_container<ssize_t> strides, bool readonly) {
+/// @cond DUPLICATE
+inline memoryview memoryview::from_buffer(void *ptr,
+                                          ssize_t itemsize,
+                                          const char *format,
+                                          detail::any_container<ssize_t> shape,
+                                          detail::any_container<ssize_t> strides,
+                                          bool readonly) {
     size_t ndim = shape->size();
-    if (ndim != strides->size())
+    if (ndim != strides->size()) {
         pybind11_fail("memoryview: shape length doesn't match strides length");
-    ssize_t size = ndim ? 1 : 0;
-    for (size_t i = 0; i < ndim; ++i)
+    }
+    ssize_t size = ndim != 0u ? 1 : 0;
+    for (size_t i = 0; i < ndim; ++i) {
         size *= (*shape)[i];
+    }
     Py_buffer view;
     view.buf = ptr;
     view.obj = nullptr;
     view.len = size * itemsize;
     view.readonly = static_cast<int>(readonly);
     view.itemsize = itemsize;
-    view.format = const_cast<char*>(format);
+    view.format = const_cast<char *>(format);
     view.ndim = static_cast<int>(ndim);
     view.shape = shape->data();
     view.strides = strides->data();
     view.suboffsets = nullptr;
     view.internal = nullptr;
-    PyObject* obj = PyMemoryView_FromBuffer(&view);
-    if (!obj)
+    PyObject *obj = PyMemoryView_FromBuffer(&view);
+    if (!obj) {
         throw error_already_set();
+    }
     return memoryview(object(obj, stolen_t{}));
 }
-#endif  // DOXYGEN_SHOULD_SKIP_THIS
+/// @endcond
 /// @} pytypes
 
 /// \addtogroup python_builtins
 /// @{
 
 /// Get the length of a Python object.
 inline size_t len(handle h) {
     ssize_t result = PyObject_Length(h.ptr());
-    if (result < 0)
+    if (result < 0) {
         throw error_already_set();
+    }
     return (size_t) result;
 }
 
 /// Get the length hint of a Python object.
 /// Returns 0 when this cannot be determined.
 inline size_t len_hint(handle h) {
 #if PY_VERSION_HEX >= 0x03040000
@@ -1554,106 +2022,132 @@
         return 0;
     }
     return (size_t) result;
 }
 
 inline str repr(handle h) {
     PyObject *str_value = PyObject_Repr(h.ptr());
-    if (!str_value) throw error_already_set();
+    if (!str_value) {
+        throw error_already_set();
+    }
 #if PY_MAJOR_VERSION < 3
     PyObject *unicode = PyUnicode_FromEncodedObject(str_value, "utf-8", nullptr);
-    Py_XDECREF(str_value); str_value = unicode;
-    if (!str_value) throw error_already_set();
+    Py_XDECREF(str_value);
+    str_value = unicode;
+    if (!str_value)
+        throw error_already_set();
 #endif
     return reinterpret_steal<str>(str_value);
 }
 
 inline iterator iter(handle obj) {
     PyObject *result = PyObject_GetIter(obj.ptr());
-    if (!result) { throw error_already_set(); }
+    if (!result) {
+        throw error_already_set();
+    }
     return reinterpret_steal<iterator>(result);
 }
 /// @} python_builtins
 
 PYBIND11_NAMESPACE_BEGIN(detail)
-template <typename D> iterator object_api<D>::begin() const { return iter(derived()); }
-template <typename D> iterator object_api<D>::end() const { return iterator::sentinel(); }
-template <typename D> item_accessor object_api<D>::operator[](handle key) const {
+template <typename D>
+iterator object_api<D>::begin() const {
+    return iter(derived());
+}
+template <typename D>
+iterator object_api<D>::end() const {
+    return iterator::sentinel();
+}
+template <typename D>
+item_accessor object_api<D>::operator[](handle key) const {
     return {derived(), reinterpret_borrow<object>(key)};
 }
-template <typename D> item_accessor object_api<D>::operator[](const char *key) const {
+template <typename D>
+item_accessor object_api<D>::operator[](const char *key) const {
     return {derived(), pybind11::str(key)};
 }
-template <typename D> obj_attr_accessor object_api<D>::attr(handle key) const {
+template <typename D>
+obj_attr_accessor object_api<D>::attr(handle key) const {
     return {derived(), reinterpret_borrow<object>(key)};
 }
-template <typename D> str_attr_accessor object_api<D>::attr(const char *key) const {
+template <typename D>
+str_attr_accessor object_api<D>::attr(const char *key) const {
     return {derived(), key};
 }
-template <typename D> args_proxy object_api<D>::operator*() const {
+template <typename D>
+args_proxy object_api<D>::operator*() const {
     return args_proxy(derived().ptr());
 }
-template <typename D> template <typename T> bool object_api<D>::contains(T &&item) const {
+template <typename D>
+template <typename T>
+bool object_api<D>::contains(T &&item) const {
     return attr("__contains__")(std::forward<T>(item)).template cast<bool>();
 }
 
 template <typename D>
-pybind11::str object_api<D>::str() const { return pybind11::str(derived()); }
+pybind11::str object_api<D>::str() const {
+    return pybind11::str(derived());
+}
 
 template <typename D>
-str_attr_accessor object_api<D>::doc() const { return attr("__doc__"); }
+str_attr_accessor object_api<D>::doc() const {
+    return attr("__doc__");
+}
 
 template <typename D>
-handle object_api<D>::get_type() const { return type::handle_of(derived()); }
+handle object_api<D>::get_type() const {
+    return type::handle_of(derived());
+}
 
 template <typename D>
 bool object_api<D>::rich_compare(object_api const &other, int value) const {
     int rv = PyObject_RichCompareBool(derived().ptr(), other.derived().ptr(), value);
-    if (rv == -1)
+    if (rv == -1) {
         throw error_already_set();
+    }
     return rv == 1;
 }
 
-#define PYBIND11_MATH_OPERATOR_UNARY(op, fn)                                   \
-    template <typename D> object object_api<D>::op() const {                   \
-        object result = reinterpret_steal<object>(fn(derived().ptr()));        \
-        if (!result.ptr())                                                     \
-            throw error_already_set();                                         \
-        return result;                                                         \
-    }
-
-#define PYBIND11_MATH_OPERATOR_BINARY(op, fn)                                  \
-    template <typename D>                                                      \
-    object object_api<D>::op(object_api const &other) const {                  \
-        object result = reinterpret_steal<object>(                             \
-            fn(derived().ptr(), other.derived().ptr()));                       \
-        if (!result.ptr())                                                     \
-            throw error_already_set();                                         \
-        return result;                                                         \
-    }
-
-PYBIND11_MATH_OPERATOR_UNARY (operator~,   PyNumber_Invert)
-PYBIND11_MATH_OPERATOR_UNARY (operator-,   PyNumber_Negative)
-PYBIND11_MATH_OPERATOR_BINARY(operator+,   PyNumber_Add)
-PYBIND11_MATH_OPERATOR_BINARY(operator+=,  PyNumber_InPlaceAdd)
-PYBIND11_MATH_OPERATOR_BINARY(operator-,   PyNumber_Subtract)
-PYBIND11_MATH_OPERATOR_BINARY(operator-=,  PyNumber_InPlaceSubtract)
-PYBIND11_MATH_OPERATOR_BINARY(operator*,   PyNumber_Multiply)
-PYBIND11_MATH_OPERATOR_BINARY(operator*=,  PyNumber_InPlaceMultiply)
-PYBIND11_MATH_OPERATOR_BINARY(operator/,   PyNumber_TrueDivide)
-PYBIND11_MATH_OPERATOR_BINARY(operator/=,  PyNumber_InPlaceTrueDivide)
-PYBIND11_MATH_OPERATOR_BINARY(operator|,   PyNumber_Or)
-PYBIND11_MATH_OPERATOR_BINARY(operator|=,  PyNumber_InPlaceOr)
-PYBIND11_MATH_OPERATOR_BINARY(operator&,   PyNumber_And)
-PYBIND11_MATH_OPERATOR_BINARY(operator&=,  PyNumber_InPlaceAnd)
-PYBIND11_MATH_OPERATOR_BINARY(operator^,   PyNumber_Xor)
-PYBIND11_MATH_OPERATOR_BINARY(operator^=,  PyNumber_InPlaceXor)
-PYBIND11_MATH_OPERATOR_BINARY(operator<<,  PyNumber_Lshift)
+#define PYBIND11_MATH_OPERATOR_UNARY(op, fn)                                                      \
+    template <typename D>                                                                         \
+    object object_api<D>::op() const {                                                            \
+        object result = reinterpret_steal<object>(fn(derived().ptr()));                           \
+        if (!result.ptr())                                                                        \
+            throw error_already_set();                                                            \
+        return result;                                                                            \
+    }
+
+#define PYBIND11_MATH_OPERATOR_BINARY(op, fn)                                                     \
+    template <typename D>                                                                         \
+    object object_api<D>::op(object_api const &other) const {                                     \
+        object result = reinterpret_steal<object>(fn(derived().ptr(), other.derived().ptr()));    \
+        if (!result.ptr())                                                                        \
+            throw error_already_set();                                                            \
+        return result;                                                                            \
+    }
+
+PYBIND11_MATH_OPERATOR_UNARY(operator~, PyNumber_Invert)
+PYBIND11_MATH_OPERATOR_UNARY(operator-, PyNumber_Negative)
+PYBIND11_MATH_OPERATOR_BINARY(operator+, PyNumber_Add)
+PYBIND11_MATH_OPERATOR_BINARY(operator+=, PyNumber_InPlaceAdd)
+PYBIND11_MATH_OPERATOR_BINARY(operator-, PyNumber_Subtract)
+PYBIND11_MATH_OPERATOR_BINARY(operator-=, PyNumber_InPlaceSubtract)
+PYBIND11_MATH_OPERATOR_BINARY(operator*, PyNumber_Multiply)
+PYBIND11_MATH_OPERATOR_BINARY(operator*=, PyNumber_InPlaceMultiply)
+PYBIND11_MATH_OPERATOR_BINARY(operator/, PyNumber_TrueDivide)
+PYBIND11_MATH_OPERATOR_BINARY(operator/=, PyNumber_InPlaceTrueDivide)
+PYBIND11_MATH_OPERATOR_BINARY(operator|, PyNumber_Or)
+PYBIND11_MATH_OPERATOR_BINARY(operator|=, PyNumber_InPlaceOr)
+PYBIND11_MATH_OPERATOR_BINARY(operator&, PyNumber_And)
+PYBIND11_MATH_OPERATOR_BINARY(operator&=, PyNumber_InPlaceAnd)
+PYBIND11_MATH_OPERATOR_BINARY(operator^, PyNumber_Xor)
+PYBIND11_MATH_OPERATOR_BINARY(operator^=, PyNumber_InPlaceXor)
+PYBIND11_MATH_OPERATOR_BINARY(operator<<, PyNumber_Lshift)
 PYBIND11_MATH_OPERATOR_BINARY(operator<<=, PyNumber_InPlaceLshift)
-PYBIND11_MATH_OPERATOR_BINARY(operator>>,  PyNumber_Rshift)
+PYBIND11_MATH_OPERATOR_BINARY(operator>>, PyNumber_Rshift)
 PYBIND11_MATH_OPERATOR_BINARY(operator>>=, PyNumber_InPlaceRshift)
 
 #undef PYBIND11_MATH_OPERATOR_UNARY
 #undef PYBIND11_MATH_OPERATOR_BINARY
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/stl.h` & `HepMC3-3.2.6/python/include/pybind11/stl.h`

 * *Files 7% similar despite different names*

```diff
@@ -6,117 +6,110 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
-#include <set>
-#include <unordered_set>
-#include <map>
-#include <unordered_map>
+#include "detail/common.h"
+
+#include <deque>
 #include <iostream>
 #include <list>
-#include <deque>
+#include <map>
+#include <set>
+#include <unordered_map>
+#include <unordered_set>
 #include <valarray>
 
-#if defined(_MSC_VER)
-#pragma warning(push)
-#pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
-#endif
-
-#ifdef __has_include
-// std::optional (but including it in c++14 mode isn't allowed)
-#  if defined(PYBIND11_CPP17) && __has_include(<optional>)
+// See `detail/common.h` for implementation of these guards.
+#if defined(PYBIND11_HAS_OPTIONAL)
 #    include <optional>
-#    define PYBIND11_HAS_OPTIONAL 1
-#  endif
-// std::experimental::optional (but not allowed in c++11 mode)
-#  if defined(PYBIND11_CPP14) && (__has_include(<experimental/optional>) && \
-                                 !__has_include(<optional>))
+#elif defined(PYBIND11_HAS_EXP_OPTIONAL)
 #    include <experimental/optional>
-#    define PYBIND11_HAS_EXP_OPTIONAL 1
-#  endif
-// std::variant
-#  if defined(PYBIND11_CPP17) && __has_include(<variant>)
+#endif
+
+#if defined(PYBIND11_HAS_VARIANT)
 #    include <variant>
-#    define PYBIND11_HAS_VARIANT 1
-#  endif
-#elif defined(_MSC_VER) && defined(PYBIND11_CPP17)
-#  include <optional>
-#  include <variant>
-#  define PYBIND11_HAS_OPTIONAL 1
-#  define PYBIND11_HAS_VARIANT 1
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 /// Extracts an const lvalue reference or rvalue reference for U based on the type of T (e.g. for
 /// forwarding a container element).  Typically used indirect via forwarded_type(), below.
 template <typename T, typename U>
-using forwarded_type = conditional_t<
-    std::is_lvalue_reference<T>::value, remove_reference_t<U> &, remove_reference_t<U> &&>;
+using forwarded_type = conditional_t<std::is_lvalue_reference<T>::value,
+                                     remove_reference_t<U> &,
+                                     remove_reference_t<U> &&>;
 
 /// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically
 /// used for forwarding a container's elements.
 template <typename T, typename U>
 forwarded_type<T, U> forward_like(U &&u) {
     return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));
 }
 
-template <typename Type, typename Key> struct set_caster {
+template <typename Type, typename Key>
+struct set_caster {
     using type = Type;
     using key_conv = make_caster<Key>;
 
     bool load(handle src, bool convert) {
-        if (!isinstance<pybind11::set>(src))
+        if (!isinstance<pybind11::set>(src)) {
             return false;
+        }
         auto s = reinterpret_borrow<pybind11::set>(src);
         value.clear();
         for (auto entry : s) {
             key_conv conv;
-            if (!conv.load(entry, convert))
+            if (!conv.load(entry, convert)) {
                 return false;
+            }
             value.insert(cast_op<Key &&>(std::move(conv)));
         }
         return true;
     }
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
-        if (!std::is_lvalue_reference<T>::value)
+        if (!std::is_lvalue_reference<T>::value) {
             policy = return_value_policy_override<Key>::policy(policy);
+        }
         pybind11::set s;
         for (auto &&value : src) {
-            auto value_ = reinterpret_steal<object>(key_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_ || !s.add(value_))
+            auto value_ = reinterpret_steal<object>(
+                key_conv::cast(forward_like<T>(value), policy, parent));
+            if (!value_ || !s.add(value_)) {
                 return handle();
+            }
         }
         return s.release();
     }
 
-    PYBIND11_TYPE_CASTER(type, _("Set[") + key_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(type, const_name("Set[") + key_conv::name + const_name("]"));
 };
 
-template <typename Type, typename Key, typename Value> struct map_caster {
-    using key_conv   = make_caster<Key>;
+template <typename Type, typename Key, typename Value>
+struct map_caster {
+    using key_conv = make_caster<Key>;
     using value_conv = make_caster<Value>;
 
     bool load(handle src, bool convert) {
-        if (!isinstance<dict>(src))
+        if (!isinstance<dict>(src)) {
             return false;
+        }
         auto d = reinterpret_borrow<dict>(src);
         value.clear();
         for (auto it : d) {
             key_conv kconv;
             value_conv vconv;
-            if (!kconv.load(it.first.ptr(), convert) ||
-                !vconv.load(it.second.ptr(), convert))
+            if (!kconv.load(it.first.ptr(), convert) || !vconv.load(it.second.ptr(), convert)) {
                 return false;
+            }
             value.emplace(cast_op<Key &&>(std::move(kconv)), cast_op<Value &&>(std::move(vconv)));
         }
         return true;
     }
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
@@ -124,188 +117,225 @@
         return_value_policy policy_key = policy;
         return_value_policy policy_value = policy;
         if (!std::is_lvalue_reference<T>::value) {
             policy_key = return_value_policy_override<Key>::policy(policy_key);
             policy_value = return_value_policy_override<Value>::policy(policy_value);
         }
         for (auto &&kv : src) {
-            auto key = reinterpret_steal<object>(key_conv::cast(forward_like<T>(kv.first), policy_key, parent));
-            auto value = reinterpret_steal<object>(value_conv::cast(forward_like<T>(kv.second), policy_value, parent));
-            if (!key || !value)
+            auto key = reinterpret_steal<object>(
+                key_conv::cast(forward_like<T>(kv.first), policy_key, parent));
+            auto value = reinterpret_steal<object>(
+                value_conv::cast(forward_like<T>(kv.second), policy_value, parent));
+            if (!key || !value) {
                 return handle();
+            }
             d[key] = value;
         }
         return d.release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _("Dict[") + key_conv::name + _(", ") + value_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type,
+                         const_name("Dict[") + key_conv::name + const_name(", ") + value_conv::name
+                             + const_name("]"));
 };
 
-template <typename Type, typename Value> struct list_caster {
+template <typename Type, typename Value>
+struct list_caster {
     using value_conv = make_caster<Value>;
 
     bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src) || isinstance<str>(src))
+        if (!isinstance<sequence>(src) || isinstance<bytes>(src) || isinstance<str>(src)) {
             return false;
+        }
         auto s = reinterpret_borrow<sequence>(src);
         value.clear();
         reserve_maybe(s, &value);
         for (auto it : s) {
             value_conv conv;
-            if (!conv.load(it, convert))
+            if (!conv.load(it, convert)) {
                 return false;
+            }
             value.push_back(cast_op<Value &&>(std::move(conv)));
         }
         return true;
     }
 
 private:
-    template <typename T = Type,
-              enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>
-    void reserve_maybe(sequence s, Type *) { value.reserve(s.size()); }
-    void reserve_maybe(sequence, void *) { }
+    template <
+        typename T = Type,
+        enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>
+    void reserve_maybe(const sequence &s, Type *) {
+        value.reserve(s.size());
+    }
+    void reserve_maybe(const sequence &, void *) {}
 
 public:
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
-        if (!std::is_lvalue_reference<T>::value)
+        if (!std::is_lvalue_reference<T>::value) {
             policy = return_value_policy_override<Value>::policy(policy);
+        }
         list l(src.size());
-        size_t index = 0;
+        ssize_t index = 0;
         for (auto &&value : src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_)
+            auto value_ = reinterpret_steal<object>(
+                value_conv::cast(forward_like<T>(value), policy, parent));
+            if (!value_) {
                 return handle();
-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
+            }
+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference
         }
         return l.release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, _("List[") + value_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type, const_name("List[") + value_conv::name + const_name("]"));
 };
 
-template <typename Type, typename Alloc> struct type_caster<std::vector<Type, Alloc>>
- : list_caster<std::vector<Type, Alloc>, Type> { };
+template <typename Type, typename Alloc>
+struct type_caster<std::vector<Type, Alloc>> : list_caster<std::vector<Type, Alloc>, Type> {};
 
-template <typename Type, typename Alloc> struct type_caster<std::deque<Type, Alloc>>
- : list_caster<std::deque<Type, Alloc>, Type> { };
+template <typename Type, typename Alloc>
+struct type_caster<std::deque<Type, Alloc>> : list_caster<std::deque<Type, Alloc>, Type> {};
 
-template <typename Type, typename Alloc> struct type_caster<std::list<Type, Alloc>>
- : list_caster<std::list<Type, Alloc>, Type> { };
+template <typename Type, typename Alloc>
+struct type_caster<std::list<Type, Alloc>> : list_caster<std::list<Type, Alloc>, Type> {};
 
-template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0> struct array_caster {
+template <typename ArrayType, typename Value, bool Resizable, size_t Size = 0>
+struct array_caster {
     using value_conv = make_caster<Value>;
 
 private:
     template <bool R = Resizable>
     bool require_size(enable_if_t<R, size_t> size) {
-        if (value.size() != size)
+        if (value.size() != size) {
             value.resize(size);
+        }
         return true;
     }
     template <bool R = Resizable>
     bool require_size(enable_if_t<!R, size_t> size) {
         return size == Size;
     }
 
 public:
     bool load(handle src, bool convert) {
-        if (!isinstance<sequence>(src))
+        if (!isinstance<sequence>(src)) {
             return false;
+        }
         auto l = reinterpret_borrow<sequence>(src);
-        if (!require_size(l.size()))
+        if (!require_size(l.size())) {
             return false;
+        }
         size_t ctr = 0;
         for (auto it : l) {
             value_conv conv;
-            if (!conv.load(it, convert))
+            if (!conv.load(it, convert)) {
                 return false;
+            }
             value[ctr++] = cast_op<Value &&>(std::move(conv));
         }
         return true;
     }
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
         list l(src.size());
-        size_t index = 0;
+        ssize_t index = 0;
         for (auto &&value : src) {
-            auto value_ = reinterpret_steal<object>(value_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_)
+            auto value_ = reinterpret_steal<object>(
+                value_conv::cast(forward_like<T>(value), policy, parent));
+            if (!value_) {
                 return handle();
-            PyList_SET_ITEM(l.ptr(), (ssize_t) index++, value_.release().ptr()); // steals a reference
+            }
+            PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference
         }
         return l.release();
     }
 
-    PYBIND11_TYPE_CASTER(ArrayType, _("List[") + value_conv::name + _<Resizable>(_(""), _("[") + _<Size>() + _("]")) + _("]"));
+    PYBIND11_TYPE_CASTER(ArrayType,
+                         const_name("List[") + value_conv::name
+                             + const_name<Resizable>(const_name(""),
+                                                     const_name("[") + const_name<Size>()
+                                                         + const_name("]"))
+                             + const_name("]"));
 };
 
-template <typename Type, size_t Size> struct type_caster<std::array<Type, Size>>
- : array_caster<std::array<Type, Size>, Type, false, Size> { };
-
-template <typename Type> struct type_caster<std::valarray<Type>>
- : array_caster<std::valarray<Type>, Type, true> { };
-
-template <typename Key, typename Compare, typename Alloc> struct type_caster<std::set<Key, Compare, Alloc>>
-  : set_caster<std::set<Key, Compare, Alloc>, Key> { };
-
-template <typename Key, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>
-  : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> { };
-
-template <typename Key, typename Value, typename Compare, typename Alloc> struct type_caster<std::map<Key, Value, Compare, Alloc>>
-  : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> { };
-
-template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc> struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>
-  : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> { };
+template <typename Type, size_t Size>
+struct type_caster<std::array<Type, Size>>
+    : array_caster<std::array<Type, Size>, Type, false, Size> {};
+
+template <typename Type>
+struct type_caster<std::valarray<Type>> : array_caster<std::valarray<Type>, Type, true> {};
+
+template <typename Key, typename Compare, typename Alloc>
+struct type_caster<std::set<Key, Compare, Alloc>>
+    : set_caster<std::set<Key, Compare, Alloc>, Key> {};
+
+template <typename Key, typename Hash, typename Equal, typename Alloc>
+struct type_caster<std::unordered_set<Key, Hash, Equal, Alloc>>
+    : set_caster<std::unordered_set<Key, Hash, Equal, Alloc>, Key> {};
+
+template <typename Key, typename Value, typename Compare, typename Alloc>
+struct type_caster<std::map<Key, Value, Compare, Alloc>>
+    : map_caster<std::map<Key, Value, Compare, Alloc>, Key, Value> {};
+
+template <typename Key, typename Value, typename Hash, typename Equal, typename Alloc>
+struct type_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>>
+    : map_caster<std::unordered_map<Key, Value, Hash, Equal, Alloc>, Key, Value> {};
 
 // This type caster is intended to be used for std::optional and std::experimental::optional
-template<typename T> struct optional_caster {
-    using value_conv = make_caster<typename T::value_type>;
+template <typename Type, typename Value = typename Type::value_type>
+struct optional_caster {
+    using value_conv = make_caster<Value>;
 
-    template <typename T_>
-    static handle cast(T_ &&src, return_value_policy policy, handle parent) {
-        if (!src)
+    template <typename T>
+    static handle cast(T &&src, return_value_policy policy, handle parent) {
+        if (!src) {
             return none().inc_ref();
+        }
         if (!std::is_lvalue_reference<T>::value) {
-            policy = return_value_policy_override<T>::policy(policy);
+            policy = return_value_policy_override<Value>::policy(policy);
         }
-        return value_conv::cast(*std::forward<T_>(src), policy, parent);
+        return value_conv::cast(*std::forward<T>(src), policy, parent);
     }
 
     bool load(handle src, bool convert) {
         if (!src) {
             return false;
-        } else if (src.is_none()) {
-            return true;  // default-constructed value is already empty
+        }
+        if (src.is_none()) {
+            return true; // default-constructed value is already empty
         }
         value_conv inner_caster;
-        if (!inner_caster.load(src, convert))
+        if (!inner_caster.load(src, convert)) {
             return false;
+        }
 
-        value.emplace(cast_op<typename T::value_type &&>(std::move(inner_caster)));
+        value.emplace(cast_op<Value &&>(std::move(inner_caster)));
         return true;
     }
 
-    PYBIND11_TYPE_CASTER(T, _("Optional[") + value_conv::name + _("]"));
+    PYBIND11_TYPE_CASTER(Type, const_name("Optional[") + value_conv::name + const_name("]"));
 };
 
 #if defined(PYBIND11_HAS_OPTIONAL)
-template<typename T> struct type_caster<std::optional<T>>
-    : public optional_caster<std::optional<T>> {};
+template <typename T>
+struct type_caster<std::optional<T>> : public optional_caster<std::optional<T>> {};
 
-template<> struct type_caster<std::nullopt_t>
-    : public void_caster<std::nullopt_t> {};
+template <>
+struct type_caster<std::nullopt_t> : public void_caster<std::nullopt_t> {};
 #endif
 
 #if defined(PYBIND11_HAS_EXP_OPTIONAL)
-template<typename T> struct type_caster<std::experimental::optional<T>>
+template <typename T>
+struct type_caster<std::experimental::optional<T>>
     : public optional_caster<std::experimental::optional<T>> {};
 
-template<> struct type_caster<std::experimental::nullopt_t>
+template <>
+struct type_caster<std::experimental::nullopt_t>
     : public void_caster<std::experimental::nullopt_t> {};
 #endif
 
 /// Visit a variant and cast any found type to Python
 struct variant_caster_visitor {
     return_value_policy policy;
     handle parent;
@@ -318,26 +348,27 @@
     }
 };
 
 /// Helper class which abstracts away variant's `visit` function. `std::variant` and similar
 /// `namespace::variant` types which provide a `namespace::visit()` function are handled here
 /// automatically using argument-dependent lookup. Users can provide specializations for other
 /// variant-like classes, e.g. `boost::variant` and `boost::apply_visitor`.
-template <template<typename...> class Variant>
+template <template <typename...> class Variant>
 struct visit_helper {
     template <typename... Args>
     static auto call(Args &&...args) -> decltype(visit(std::forward<Args>(args)...)) {
         return visit(std::forward<Args>(args)...);
     }
 };
 
 /// Generic variant caster
-template <typename Variant> struct variant_caster;
+template <typename Variant>
+struct variant_caster;
 
-template <template<typename...> class V, typename... Ts>
+template <template <typename...> class V, typename... Ts>
 struct variant_caster<V<Ts...>> {
     static_assert(sizeof...(Ts) > 0, "Variant must consist of at least one alternative.");
 
     template <typename U, typename... Us>
     bool load_alternative(handle src, bool convert, type_list<U, Us...>) {
         auto caster = make_caster<U>();
         if (caster.load(src, convert)) {
@@ -350,39 +381,42 @@
     bool load_alternative(handle, bool, type_list<>) { return false; }
 
     bool load(handle src, bool convert) {
         // Do a first pass without conversions to improve constructor resolution.
         // E.g. `py::int_(1).cast<variant<double, int>>()` needs to fill the `int`
         // slot of the variant. Without two-pass loading `double` would be filled
         // because it appears first and a conversion is possible.
-        if (convert && load_alternative(src, false, type_list<Ts...>{}))
+        if (convert && load_alternative(src, false, type_list<Ts...>{})) {
             return true;
+        }
         return load_alternative(src, convert, type_list<Ts...>{});
     }
 
     template <typename Variant>
     static handle cast(Variant &&src, return_value_policy policy, handle parent) {
         return visit_helper<V>::call(variant_caster_visitor{policy, parent},
                                      std::forward<Variant>(src));
     }
 
     using Type = V<Ts...>;
-    PYBIND11_TYPE_CASTER(Type, _("Union[") + detail::concat(make_caster<Ts>::name...) + _("]"));
+    PYBIND11_TYPE_CASTER(Type,
+                         const_name("Union[") + detail::concat(make_caster<Ts>::name...)
+                             + const_name("]"));
 };
 
 #if defined(PYBIND11_HAS_VARIANT)
 template <typename... Ts>
-struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> { };
+struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> {};
 #endif
 
 PYBIND11_NAMESPACE_END(detail)
 
 inline std::ostream &operator<<(std::ostream &os, const handle &obj) {
+#ifdef PYBIND11_HAS_STRING_VIEW
+    os << str(obj).cast<std::string_view>();
+#else
     os << (std::string) str(obj);
+#endif
     return os;
 }
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(_MSC_VER)
-#pragma warning(pop)
-#endif
```

### Comparing `HepMC3-3.2.5/python/include/pybind11/stl_bind.h` & `HepMC3-3.2.6/python/include/pybind11/stl_bind.h`

 * *Files 10% similar despite different names*

```diff
@@ -15,426 +15,482 @@
 #include <algorithm>
 #include <sstream>
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 /* SFINAE helper class used by 'is_comparable */
-template <typename T>  struct container_traits {
-    template <typename T2> static std::true_type test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>())*);
-    template <typename T2> static std::false_type test_comparable(...);
-    template <typename T2> static std::true_type test_value(typename T2::value_type *);
-    template <typename T2> static std::false_type test_value(...);
-    template <typename T2> static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);
-    template <typename T2> static std::false_type test_pair(...);
-
-    static constexpr const bool is_comparable = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;
-    static constexpr const bool is_pair = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;
-    static constexpr const bool is_vector = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;
+template <typename T>
+struct container_traits {
+    template <typename T2>
+    static std::true_type
+    test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>()) *);
+    template <typename T2>
+    static std::false_type test_comparable(...);
+    template <typename T2>
+    static std::true_type test_value(typename T2::value_type *);
+    template <typename T2>
+    static std::false_type test_value(...);
+    template <typename T2>
+    static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);
+    template <typename T2>
+    static std::false_type test_pair(...);
+
+    static constexpr const bool is_comparable
+        = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;
+    static constexpr const bool is_pair
+        = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;
+    static constexpr const bool is_vector
+        = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;
     static constexpr const bool is_element = !is_pair && !is_vector;
 };
 
 /* Default: is_comparable -> std::false_type */
 template <typename T, typename SFINAE = void>
-struct is_comparable : std::false_type { };
+struct is_comparable : std::false_type {};
 
 /* For non-map data structures, check whether operator== can be instantiated */
 template <typename T>
 struct is_comparable<
-    T, enable_if_t<container_traits<T>::is_element &&
-                   container_traits<T>::is_comparable>>
-    : std::true_type { };
+    T,
+    enable_if_t<container_traits<T>::is_element && container_traits<T>::is_comparable>>
+    : std::true_type {};
 
-/* For a vector/map data structure, recursively check the value type (which is std::pair for maps) */
+/* For a vector/map data structure, recursively check the value type
+   (which is std::pair for maps) */
 template <typename T>
 struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>> {
-    static constexpr const bool value =
-        is_comparable<typename T::value_type>::value;
+    static constexpr const bool value = is_comparable<typename T::value_type>::value;
 };
 
 /* For pairs, recursively check the two data types */
 template <typename T>
 struct is_comparable<T, enable_if_t<container_traits<T>::is_pair>> {
-    static constexpr const bool value =
-        is_comparable<typename T::first_type>::value &&
-        is_comparable<typename T::second_type>::value;
+    static constexpr const bool value = is_comparable<typename T::first_type>::value
+                                        && is_comparable<typename T::second_type>::value;
 };
 
 /* Fallback functions */
-template <typename, typename, typename... Args> void vector_if_copy_constructible(const Args &...) { }
-template <typename, typename, typename... Args> void vector_if_equal_operator(const Args &...) { }
-template <typename, typename, typename... Args> void vector_if_insertion_operator(const Args &...) { }
-template <typename, typename, typename... Args> void vector_modifiers(const Args &...) { }
+template <typename, typename, typename... Args>
+void vector_if_copy_constructible(const Args &...) {}
+template <typename, typename, typename... Args>
+void vector_if_equal_operator(const Args &...) {}
+template <typename, typename, typename... Args>
+void vector_if_insertion_operator(const Args &...) {}
+template <typename, typename, typename... Args>
+void vector_modifiers(const Args &...) {}
 
-template<typename Vector, typename Class_>
+template <typename Vector, typename Class_>
 void vector_if_copy_constructible(enable_if_t<is_copy_constructible<Vector>::value, Class_> &cl) {
     cl.def(init<const Vector &>(), "Copy constructor");
 }
 
-template<typename Vector, typename Class_>
+template <typename Vector, typename Class_>
 void vector_if_equal_operator(enable_if_t<is_comparable<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
 
     cl.def(self == self);
     cl.def(self != self);
 
-    cl.def("count",
-        [](const Vector &v, const T &x) {
-            return std::count(v.begin(), v.end(), x);
-        },
+    cl.def(
+        "count",
+        [](const Vector &v, const T &x) { return std::count(v.begin(), v.end(), x); },
         arg("x"),
-        "Return the number of times ``x`` appears in the list"
-    );
+        "Return the number of times ``x`` appears in the list");
 
-    cl.def("remove", [](Vector &v, const T &x) {
+    cl.def(
+        "remove",
+        [](Vector &v, const T &x) {
             auto p = std::find(v.begin(), v.end(), x);
-            if (p != v.end())
+            if (p != v.end()) {
                 v.erase(p);
-            else
+            } else {
                 throw value_error();
+            }
         },
         arg("x"),
         "Remove the first item from the list whose value is x. "
-        "It is an error if there is no such item."
-    );
+        "It is an error if there is no such item.");
 
-    cl.def("__contains__",
-        [](const Vector &v, const T &x) {
-            return std::find(v.begin(), v.end(), x) != v.end();
-        },
+    cl.def(
+        "__contains__",
+        [](const Vector &v, const T &x) { return std::find(v.begin(), v.end(), x) != v.end(); },
         arg("x"),
-        "Return true the container contains ``x``"
-    );
+        "Return true the container contains ``x``");
 }
 
 // Vector modifiers -- requires a copyable vector_type:
-// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it seems
-// silly to allow deletion but not insertion, so include them here too.)
+// (Technically, some of these (pop and __delitem__) don't actually require copyability, but it
+// seems silly to allow deletion but not insertion, so include them here too.)
 template <typename Vector, typename Class_>
-void vector_modifiers(enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
+void vector_modifiers(
+    enable_if_t<is_copy_constructible<typename Vector::value_type>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
 
     auto wrap_i = [](DiffType i, SizeType n) {
-        if (i < 0)
+        if (i < 0) {
             i += n;
-        if (i < 0 || (SizeType)i >= n)
+        }
+        if (i < 0 || (SizeType) i >= n) {
             throw index_error();
+        }
         return i;
     };
 
-    cl.def("append",
-           [](Vector &v, const T &value) { v.push_back(value); },
-           arg("x"),
-           "Add an item to the end of the list");
+    cl.def(
+        "append",
+        [](Vector &v, const T &value) { v.push_back(value); },
+        arg("x"),
+        "Add an item to the end of the list");
 
-    cl.def(init([](iterable it) {
+    cl.def(init([](const iterable &it) {
         auto v = std::unique_ptr<Vector>(new Vector());
         v->reserve(len_hint(it));
-        for (handle h : it)
-           v->push_back(h.cast<T>());
+        for (handle h : it) {
+            v->push_back(h.cast<T>());
+        }
         return v.release();
     }));
 
-    cl.def("clear",
-        [](Vector &v) {
-            v.clear();
-        },
-        "Clear the contents"
-    );
+    cl.def(
+        "clear", [](Vector &v) { v.clear(); }, "Clear the contents");
 
-    cl.def("extend",
-       [](Vector &v, const Vector &src) {
-           v.insert(v.end(), src.begin(), src.end());
-       },
-       arg("L"),
-       "Extend the list by appending all the items in the given list"
-    );
-
-    cl.def("extend",
-       [](Vector &v, iterable it) {
-           const size_t old_size = v.size();
-           v.reserve(old_size + len_hint(it));
-           try {
-               for (handle h : it) {
-                   v.push_back(h.cast<T>());
-               }
-           } catch (const cast_error &) {
-               v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size), v.end());
-               try {
-                   v.shrink_to_fit();
-               } catch (const std::exception &) {
-                   // Do nothing
-               }
-               throw;
-           }
-       },
-       arg("L"),
-       "Extend the list by appending all the items in the given list"
-    );
+    cl.def(
+        "extend",
+        [](Vector &v, const Vector &src) { v.insert(v.end(), src.begin(), src.end()); },
+        arg("L"),
+        "Extend the list by appending all the items in the given list");
+
+    cl.def(
+        "extend",
+        [](Vector &v, const iterable &it) {
+            const size_t old_size = v.size();
+            v.reserve(old_size + len_hint(it));
+            try {
+                for (handle h : it) {
+                    v.push_back(h.cast<T>());
+                }
+            } catch (const cast_error &) {
+                v.erase(v.begin() + static_cast<typename Vector::difference_type>(old_size),
+                        v.end());
+                try {
+                    v.shrink_to_fit();
+                } catch (const std::exception &) {
+                    // Do nothing
+                }
+                throw;
+            }
+        },
+        arg("L"),
+        "Extend the list by appending all the items in the given list");
 
-    cl.def("insert",
+    cl.def(
+        "insert",
         [](Vector &v, DiffType i, const T &x) {
             // Can't use wrap_i; i == v.size() is OK
-            if (i < 0)
+            if (i < 0) {
                 i += v.size();
-            if (i < 0 || (SizeType)i > v.size())
+            }
+            if (i < 0 || (SizeType) i > v.size()) {
                 throw index_error();
+            }
             v.insert(v.begin() + i, x);
         },
-        arg("i") , arg("x"),
-        "Insert an item at a given position."
-    );
+        arg("i"),
+        arg("x"),
+        "Insert an item at a given position.");
 
-    cl.def("pop",
+    cl.def(
+        "pop",
         [](Vector &v) {
-            if (v.empty())
+            if (v.empty()) {
                 throw index_error();
-            T t = v.back();
+            }
+            T t = std::move(v.back());
             v.pop_back();
             return t;
         },
-        "Remove and return the last item"
-    );
+        "Remove and return the last item");
 
-    cl.def("pop",
+    cl.def(
+        "pop",
         [wrap_i](Vector &v, DiffType i) {
             i = wrap_i(i, v.size());
-            T t = v[(SizeType) i];
-            v.erase(v.begin() + i);
+            T t = std::move(v[(SizeType) i]);
+            v.erase(std::next(v.begin(), i));
             return t;
         },
         arg("i"),
-        "Remove and return the item at index ``i``"
-    );
+        "Remove and return the item at index ``i``");
 
-    cl.def("__setitem__",
-        [wrap_i](Vector &v, DiffType i, const T &t) {
-            i = wrap_i(i, v.size());
-            v[(SizeType)i] = t;
-        }
-    );
+    cl.def("__setitem__", [wrap_i](Vector &v, DiffType i, const T &t) {
+        i = wrap_i(i, v.size());
+        v[(SizeType) i] = t;
+    });
 
     /// Slicing protocol
-    cl.def("__getitem__",
+    cl.def(
+        "__getitem__",
         [](const Vector &v, slice slice) -> Vector * {
-            size_t start, stop, step, slicelength;
+            size_t start = 0, stop = 0, step = 0, slicelength = 0;
 
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
+            }
 
             auto *seq = new Vector();
             seq->reserve((size_t) slicelength);
 
-            for (size_t i=0; i<slicelength; ++i) {
+            for (size_t i = 0; i < slicelength; ++i) {
                 seq->push_back(v[start]);
                 start += step;
             }
             return seq;
         },
         arg("s"),
-        "Retrieve list elements using a slice object"
-    );
+        "Retrieve list elements using a slice object");
 
-    cl.def("__setitem__",
-        [](Vector &v, slice slice,  const Vector &value) {
-            size_t start, stop, step, slicelength;
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+    cl.def(
+        "__setitem__",
+        [](Vector &v, slice slice, const Vector &value) {
+            size_t start = 0, stop = 0, step = 0, slicelength = 0;
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
+            }
 
-            if (slicelength != value.size())
-                throw std::runtime_error("Left and right hand size of slice assignment have different sizes!");
+            if (slicelength != value.size()) {
+                throw std::runtime_error(
+                    "Left and right hand size of slice assignment have different sizes!");
+            }
 
-            for (size_t i=0; i<slicelength; ++i) {
+            for (size_t i = 0; i < slicelength; ++i) {
                 v[start] = value[i];
                 start += step;
             }
         },
-        "Assign list elements using a slice object"
-    );
+        "Assign list elements using a slice object");
 
-    cl.def("__delitem__",
+    cl.def(
+        "__delitem__",
         [wrap_i](Vector &v, DiffType i) {
             i = wrap_i(i, v.size());
             v.erase(v.begin() + i);
         },
-        "Delete the list elements at index ``i``"
-    );
+        "Delete the list elements at index ``i``");
 
-    cl.def("__delitem__",
+    cl.def(
+        "__delitem__",
         [](Vector &v, slice slice) {
-            size_t start, stop, step, slicelength;
+            size_t start = 0, stop = 0, step = 0, slicelength = 0;
 
-            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
+            }
 
             if (step == 1 && false) {
                 v.erase(v.begin() + (DiffType) start, v.begin() + DiffType(start + slicelength));
             } else {
                 for (size_t i = 0; i < slicelength; ++i) {
                     v.erase(v.begin() + DiffType(start));
                     start += step - 1;
                 }
             }
         },
-        "Delete list elements using a slice object"
-    );
-
+        "Delete list elements using a slice object");
 }
 
 // If the type has an operator[] that doesn't return a reference (most notably std::vector<bool>),
 // we have to access by copying; otherwise we return by reference.
-template <typename Vector> using vector_needs_copy = negation<
-    std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]), typename Vector::value_type &>>;
+template <typename Vector>
+using vector_needs_copy
+    = negation<std::is_same<decltype(std::declval<Vector>()[typename Vector::size_type()]),
+                            typename Vector::value_type &>>;
 
 // The usual case: access and iterate by reference
 template <typename Vector, typename Class_>
 void vector_accessor(enable_if_t<!vector_needs_copy<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
-    using ItType   = typename Vector::iterator;
+    using ItType = typename Vector::iterator;
 
     auto wrap_i = [](DiffType i, SizeType n) {
-        if (i < 0)
+        if (i < 0) {
             i += n;
-        if (i < 0 || (SizeType)i >= n)
+        }
+        if (i < 0 || (SizeType) i >= n) {
             throw index_error();
+        }
         return i;
     };
 
-    cl.def("__getitem__",
+    cl.def(
+        "__getitem__",
         [wrap_i](Vector &v, DiffType i) -> T & {
             i = wrap_i(i, v.size());
-            return v[(SizeType)i];
+            return v[(SizeType) i];
         },
         return_value_policy::reference_internal // ref + keepalive
     );
 
-    cl.def("__iter__",
-           [](Vector &v) {
-               return make_iterator<
-                   return_value_policy::reference_internal, ItType, ItType, T&>(
-                   v.begin(), v.end());
-           },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "__iter__",
+        [](Vector &v) {
+            return make_iterator<return_value_policy::reference_internal, ItType, ItType, T &>(
+                v.begin(), v.end());
+        },
+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
     );
 }
 
 // The case for special objects, like std::vector<bool>, that have to be returned-by-copy:
 template <typename Vector, typename Class_>
 void vector_accessor(enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
-    using ItType   = typename Vector::iterator;
-    cl.def("__getitem__",
-        [](const Vector &v, DiffType i) -> T {
-            if (i < 0 && (i += v.size()) < 0)
-                throw index_error();
-            if ((SizeType)i >= v.size())
-                throw index_error();
-            return v[(SizeType)i];
+    using ItType = typename Vector::iterator;
+    cl.def("__getitem__", [](const Vector &v, DiffType i) -> T {
+        if (i < 0 && (i += v.size()) < 0) {
+            throw index_error();
         }
-    );
+        if ((SizeType) i >= v.size()) {
+            throw index_error();
+        }
+        return v[(SizeType) i];
+    });
 
-    cl.def("__iter__",
-           [](Vector &v) {
-               return make_iterator<
-                   return_value_policy::copy, ItType, ItType, T>(
-                   v.begin(), v.end());
-           },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "__iter__",
+        [](Vector &v) {
+            return make_iterator<return_value_policy::copy, ItType, ItType, T>(v.begin(), v.end());
+        },
+        keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
     );
 }
 
-template <typename Vector, typename Class_> auto vector_if_insertion_operator(Class_ &cl, std::string const &name)
-    -> decltype(std::declval<std::ostream&>() << std::declval<typename Vector::value_type>(), void()) {
+template <typename Vector, typename Class_>
+auto vector_if_insertion_operator(Class_ &cl, std::string const &name)
+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Vector::value_type>(),
+                void()) {
     using size_type = typename Vector::size_type;
 
-    cl.def("__repr__",
-           [name](Vector &v) {
+    cl.def(
+        "__repr__",
+        [name](Vector &v) {
             std::ostringstream s;
             s << name << '[';
-            for (size_type i=0; i < v.size(); ++i) {
+            for (size_type i = 0; i < v.size(); ++i) {
                 s << v[i];
-                if (i != v.size() - 1)
+                if (i != v.size() - 1) {
                     s << ", ";
+                }
             }
             s << ']';
             return s.str();
         },
-        "Return the canonical string representation of this list."
-    );
+        "Return the canonical string representation of this list.");
 }
 
 // Provide the buffer interface for vectors if we have data() and we have a format for it
-// GCC seems to have "void std::vector<bool>::data()" - doing SFINAE on the existence of data() is insufficient, we need to check it returns an appropriate pointer
+// GCC seems to have "void std::vector<bool>::data()" - doing SFINAE on the existence of data()
+// is insufficient, we need to check it returns an appropriate pointer
 template <typename Vector, typename = void>
 struct vector_has_data_and_format : std::false_type {};
 template <typename Vector>
-struct vector_has_data_and_format<Vector, enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(), std::declval<Vector>().data()), typename Vector::value_type*>::value>> : std::true_type {};
+struct vector_has_data_and_format<
+    Vector,
+    enable_if_t<std::is_same<decltype(format_descriptor<typename Vector::value_type>::format(),
+                                      std::declval<Vector>().data()),
+                             typename Vector::value_type *>::value>> : std::true_type {};
+
+// [workaround(intel)] Separate function required here
+// Workaround as the Intel compiler does not compile the enable_if_t part below
+// (tested with icc (ICC) 2021.1 Beta 20200827)
+template <typename... Args>
+constexpr bool args_any_are_buffer() {
+    return detail::any_of<std::is_same<Args, buffer_protocol>...>::value;
+}
+
+// [workaround(intel)] Separate function required here
+// [workaround(msvc)] Can't use constexpr bool in return type
 
 // Add the buffer interface to a vector
 template <typename Vector, typename Class_, typename... Args>
-enable_if_t<detail::any_of<std::is_same<Args, buffer_protocol>...>::value>
-vector_buffer(Class_& cl) {
+void vector_buffer_impl(Class_ &cl, std::true_type) {
     using T = typename Vector::value_type;
 
-    static_assert(vector_has_data_and_format<Vector>::value, "There is not an appropriate format descriptor for this vector");
+    static_assert(vector_has_data_and_format<Vector>::value,
+                  "There is not an appropriate format descriptor for this vector");
 
-    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here
+    // numpy.h declares this for arbitrary types, but it may raise an exception and crash hard
+    // at runtime if PYBIND11_NUMPY_DTYPE hasn't been called, so check here
     format_descriptor<T>::format();
 
-    cl.def_buffer([](Vector& v) -> buffer_info {
-        return buffer_info(v.data(), static_cast<ssize_t>(sizeof(T)), format_descriptor<T>::format(), 1, {v.size()}, {sizeof(T)});
+    cl.def_buffer([](Vector &v) -> buffer_info {
+        return buffer_info(v.data(),
+                           static_cast<ssize_t>(sizeof(T)),
+                           format_descriptor<T>::format(),
+                           1,
+                           {v.size()},
+                           {sizeof(T)});
     });
 
-    cl.def(init([](buffer buf) {
+    cl.def(init([](const buffer &buf) {
         auto info = buf.request();
-        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T)))
+        if (info.ndim != 1 || info.strides[0] % static_cast<ssize_t>(sizeof(T))) {
             throw type_error("Only valid 1D buffers can be copied to a vector");
-        if (!detail::compare_buffer_info<T>::compare(info) || (ssize_t) sizeof(T) != info.itemsize)
-            throw type_error("Format mismatch (Python: " + info.format + " C++: " + format_descriptor<T>::format() + ")");
+        }
+        if (!detail::compare_buffer_info<T>::compare(info)
+            || (ssize_t) sizeof(T) != info.itemsize) {
+            throw type_error("Format mismatch (Python: " + info.format
+                             + " C++: " + format_descriptor<T>::format() + ")");
+        }
 
-        T *p = static_cast<T*>(info.ptr);
+        T *p = static_cast<T *>(info.ptr);
         ssize_t step = info.strides[0] / static_cast<ssize_t>(sizeof(T));
         T *end = p + info.shape[0] * step;
         if (step == 1) {
             return Vector(p, end);
         }
-        else {
-            Vector vec;
-            vec.reserve((size_t) info.shape[0]);
-            for (; p != end; p += step)
-                vec.push_back(*p);
-            return vec;
+        Vector vec;
+        vec.reserve((size_t) info.shape[0]);
+        for (; p != end; p += step) {
+            vec.push_back(*p);
         }
+        return vec;
     }));
 
     return;
 }
 
 template <typename Vector, typename Class_, typename... Args>
-enable_if_t<!detail::any_of<std::is_same<Args, buffer_protocol>...>::value> vector_buffer(Class_&) {}
+void vector_buffer_impl(Class_ &, std::false_type) {}
+
+template <typename Vector, typename Class_, typename... Args>
+void vector_buffer(Class_ &cl) {
+    vector_buffer_impl<Vector, Class_, Args...>(
+        cl, detail::any_of<std::is_same<Args, buffer_protocol>...>{});
+}
 
 PYBIND11_NAMESPACE_END(detail)
 
 //
 // std::vector
 //
 template <typename Vector, typename holder_type = std::unique_ptr<Vector>, typename... Args>
-class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args&&... args) {
+class_<Vector, holder_type> bind_vector(handle scope, std::string const &name, Args &&...args) {
     using Class_ = class_<Vector, holder_type>;
 
     // If the value_type is unregistered (e.g. a converting type) or is itself registered
     // module-local then make the vector binding module-local as well:
     using vtype = typename Vector::value_type;
-    auto vtype_info = detail::get_type_info(typeid(vtype));
+    auto *vtype_info = detail::get_type_info(typeid(vtype));
     bool local = !vtype_info || vtype_info->module_local;
 
     Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
 
     // Declare the buffer interface if a buffer_protocol() is passed in
     detail::vector_buffer<Vector, Class_, Args...>(cl);
 
@@ -451,26 +507,21 @@
 
     // Modifiers require copyable vector value type
     detail::vector_modifiers<Vector, Class_>(cl);
 
     // Accessor and iterator; return by value if copyable, otherwise we return by ref + keep-alive
     detail::vector_accessor<Vector, Class_>(cl);
 
-    cl.def("__bool__",
-        [](const Vector &v) -> bool {
-            return !v.empty();
-        },
-        "Check whether the list is nonempty"
-    );
+    cl.def(
+        "__bool__",
+        [](const Vector &v) -> bool { return !v.empty(); },
+        "Check whether the list is nonempty");
 
     cl.def("__len__", &Vector::size);
 
-
-
-
 #if 0
     // C++ style functions deprecated, leaving it here as an example
     cl.def(init<size_type>());
 
     cl.def("resize",
          (void (Vector::*) (size_type count)) & Vector::resize,
          "changes the number of elements stored");
@@ -506,156 +557,229 @@
     }, "access the last element ");
 
 #endif
 
     return cl;
 }
 
-
-
 //
 // std::map, std::unordered_map
 //
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 /* Fallback functions */
-template <typename, typename, typename... Args> void map_if_insertion_operator(const Args &...) { }
-template <typename, typename, typename... Args> void map_assignment(const Args &...) { }
+template <typename, typename, typename... Args>
+void map_if_insertion_operator(const Args &...) {}
+template <typename, typename, typename... Args>
+void map_assignment(const Args &...) {}
 
 // Map assignment when copy-assignable: just copy the value
 template <typename Map, typename Class_>
-void map_assignment(enable_if_t<is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {
+void map_assignment(
+    enable_if_t<is_copy_assignable<typename Map::mapped_type>::value, Class_> &cl) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
 
-    cl.def("__setitem__",
-           [](Map &m, const KeyType &k, const MappedType &v) {
-               auto it = m.find(k);
-               if (it != m.end()) it->second = v;
-               else m.emplace(k, v);
-           }
-    );
+    cl.def("__setitem__", [](Map &m, const KeyType &k, const MappedType &v) {
+        auto it = m.find(k);
+        if (it != m.end()) {
+            it->second = v;
+        } else {
+            m.emplace(k, v);
+        }
+    });
 }
 
-// Not copy-assignable, but still copy-constructible: we can update the value by erasing and reinserting
-template<typename Map, typename Class_>
-void map_assignment(enable_if_t<
-        !is_copy_assignable<typename Map::mapped_type>::value &&
-        is_copy_constructible<typename Map::mapped_type>::value,
-        Class_> &cl) {
+// Not copy-assignable, but still copy-constructible: we can update the value by erasing and
+// reinserting
+template <typename Map, typename Class_>
+void map_assignment(enable_if_t<!is_copy_assignable<typename Map::mapped_type>::value
+                                    && is_copy_constructible<typename Map::mapped_type>::value,
+                                Class_> &cl) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
 
-    cl.def("__setitem__",
-           [](Map &m, const KeyType &k, const MappedType &v) {
-               // We can't use m[k] = v; because value type might not be default constructable
-               auto r = m.emplace(k, v);
-               if (!r.second) {
-                   // value type is not copy assignable so the only way to insert it is to erase it first...
-                   m.erase(r.first);
-                   m.emplace(k, v);
-               }
-           }
-    );
+    cl.def("__setitem__", [](Map &m, const KeyType &k, const MappedType &v) {
+        // We can't use m[k] = v; because value type might not be default constructable
+        auto r = m.emplace(k, v);
+        if (!r.second) {
+            // value type is not copy assignable so the only way to insert it is to erase it
+            // first...
+            m.erase(r.first);
+            m.emplace(k, v);
+        }
+    });
 }
 
-
-template <typename Map, typename Class_> auto map_if_insertion_operator(Class_ &cl, std::string const &name)
--> decltype(std::declval<std::ostream&>() << std::declval<typename Map::key_type>() << std::declval<typename Map::mapped_type>(), void()) {
-
-    cl.def("__repr__",
-           [name](Map &m) {
+template <typename Map, typename Class_>
+auto map_if_insertion_operator(Class_ &cl, std::string const &name)
+    -> decltype(std::declval<std::ostream &>() << std::declval<typename Map::key_type>()
+                                               << std::declval<typename Map::mapped_type>(),
+                void()) {
+
+    cl.def(
+        "__repr__",
+        [name](Map &m) {
             std::ostringstream s;
             s << name << '{';
             bool f = false;
             for (auto const &kv : m) {
-                if (f)
+                if (f) {
                     s << ", ";
+                }
                 s << kv.first << ": " << kv.second;
                 f = true;
             }
             s << '}';
             return s.str();
         },
-        "Return the canonical string representation of this map."
-    );
+        "Return the canonical string representation of this map.");
 }
 
+template <typename Map>
+struct keys_view {
+    Map &map;
+};
+
+template <typename Map>
+struct values_view {
+    Map &map;
+};
+
+template <typename Map>
+struct items_view {
+    Map &map;
+};
 
 PYBIND11_NAMESPACE_END(detail)
 
 template <typename Map, typename holder_type = std::unique_ptr<Map>, typename... Args>
-class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args&&... args) {
+class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args &&...args) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
+    using KeysView = detail::keys_view<Map>;
+    using ValuesView = detail::values_view<Map>;
+    using ItemsView = detail::items_view<Map>;
     using Class_ = class_<Map, holder_type>;
 
     // If either type is a non-module-local bound type then make the map binding non-local as well;
     // otherwise (e.g. both types are either module-local or converting) the map will be
     // module-local.
-    auto tinfo = detail::get_type_info(typeid(MappedType));
+    auto *tinfo = detail::get_type_info(typeid(MappedType));
     bool local = !tinfo || tinfo->module_local;
     if (local) {
         tinfo = detail::get_type_info(typeid(KeyType));
         local = !tinfo || tinfo->module_local;
     }
 
     Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
+    class_<KeysView> keys_view(
+        scope, ("KeysView[" + name + "]").c_str(), pybind11::module_local(local));
+    class_<ValuesView> values_view(
+        scope, ("ValuesView[" + name + "]").c_str(), pybind11::module_local(local));
+    class_<ItemsView> items_view(
+        scope, ("ItemsView[" + name + "]").c_str(), pybind11::module_local(local));
 
     cl.def(init<>());
 
     // Register stream insertion operator (if possible)
     detail::map_if_insertion_operator<Map, Class_>(cl, name);
 
-    cl.def("__bool__",
+    cl.def(
+        "__bool__",
         [](const Map &m) -> bool { return !m.empty(); },
-        "Check whether the map is nonempty"
+        "Check whether the map is nonempty");
+
+    cl.def(
+        "__iter__",
+        [](Map &m) { return make_key_iterator(m.begin(), m.end()); },
+        keep_alive<0, 1>() /* Essential: keep map alive while iterator exists */
     );
 
-    cl.def("__iter__",
-           [](Map &m) { return make_key_iterator(m.begin(), m.end()); },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "keys",
+        [](Map &m) { return KeysView{m}; },
+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
-    cl.def("items",
-           [](Map &m) { return make_iterator(m.begin(), m.end()); },
-           keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    cl.def(
+        "values",
+        [](Map &m) { return ValuesView{m}; },
+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
-    cl.def("__getitem__",
+    cl.def(
+        "items",
+        [](Map &m) { return ItemsView{m}; },
+        keep_alive<0, 1>() /* Essential: keep map alive while view exists */
+    );
+
+    cl.def(
+        "__getitem__",
         [](Map &m, const KeyType &k) -> MappedType & {
             auto it = m.find(k);
-            if (it == m.end())
-              throw key_error();
-           return it->second;
+            if (it == m.end()) {
+                throw key_error();
+            }
+            return it->second;
         },
         return_value_policy::reference_internal // ref + keepalive
     );
 
-    cl.def("__contains__",
-        [](Map &m, const KeyType &k) -> bool {
-            auto it = m.find(k);
-            if (it == m.end())
-              return false;
-           return true;
+    cl.def("__contains__", [](Map &m, const KeyType &k) -> bool {
+        auto it = m.find(k);
+        if (it == m.end()) {
+            return false;
         }
-    );
+        return true;
+    });
+    // Fallback for when the object is not of the key type
+    cl.def("__contains__", [](Map &, const object &) -> bool { return false; });
 
     // Assignment provided only if the type is copyable
     detail::map_assignment<Map, Class_>(cl);
 
-    cl.def("__delitem__",
-           [](Map &m, const KeyType &k) {
-               auto it = m.find(k);
-               if (it == m.end())
-                   throw key_error();
-               m.erase(it);
-           }
-    );
+    cl.def("__delitem__", [](Map &m, const KeyType &k) {
+        auto it = m.find(k);
+        if (it == m.end()) {
+            throw key_error();
+        }
+        m.erase(it);
+    });
 
     cl.def("__len__", &Map::size);
 
+    keys_view.def("__len__", [](KeysView &view) { return view.map.size(); });
+    keys_view.def(
+        "__iter__",
+        [](KeysView &view) { return make_key_iterator(view.map.begin(), view.map.end()); },
+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+    );
+    keys_view.def("__contains__", [](KeysView &view, const KeyType &k) -> bool {
+        auto it = view.map.find(k);
+        if (it == view.map.end()) {
+            return false;
+        }
+        return true;
+    });
+    // Fallback for when the object is not of the key type
+    keys_view.def("__contains__", [](KeysView &, const object &) -> bool { return false; });
+
+    values_view.def("__len__", [](ValuesView &view) { return view.map.size(); });
+    values_view.def(
+        "__iter__",
+        [](ValuesView &view) { return make_value_iterator(view.map.begin(), view.map.end()); },
+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+    );
+
+    items_view.def("__len__", [](ItemsView &view) { return view.map.size(); });
+    items_view.def(
+        "__iter__",
+        [](ItemsView &view) { return make_iterator(view.map.begin(), view.map.end()); },
+        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+    );
+
     return cl;
 }
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `HepMC3-3.2.5/python/pyHepMC3.egg-info.in` & `HepMC3-3.2.6/python/pyHepMC3.egg-info.in`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 Metadata-Version: 1.1
 Name: pyHepMC3
 Version: @THIS_PROJECT_NAME_VERSION@
 Summary: Python bindings for HepMC3
 Home-page: https://gitlab.cern.ch/hepmc/HepMC3
 Author: HepMC3 Developers
 Author-email: hepmc-dev@cern.ch
-License: GPLv3
+License: LGPLv3+
 Description: pyHepMC3
               Official python bindings for the HepMC3 library
 Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Physicists
-Classifier: License :: OSI Approved :: GPLv3
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)
 Classifier: License :: OSI Approved :: Python Software Foundation License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3.1
 Classifier: Programming Language :: Python :: 3.2
 Classifier: Programming Language :: Python :: 3.3
@@ -24,8 +24,10 @@
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
+Classifier: Programming Language :: Python :: 3.13
+Classifier: Programming Language :: Python :: 3.14
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
```

### Comparing `HepMC3-3.2.5/python/pyHepMC3.rootIO.egg-info.in` & `HepMC3-3.2.6/python/pyHepMC3.rootIO.egg-info.in`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 Metadata-Version: 1.1
 Name: pyHepMC3.rootIO
 Version: @THIS_PROJECT_NAME_VERSION@
 Summary: Python bindings for HepMC3 rootIO module
 Home-page: https://gitlab.cern.ch/hepmc/HepMC3
 Author: HepMC3 Developers
 Author-email: hepmc-dev@cern.ch
-License: GPLv3
+License: LGPLv3+
 Description: pyHepMC3.rootIO
               Official python bindings for the rootIO module of the HepMC3 library
 Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Physicists
-Classifier: License :: OSI Approved :: GPLv3
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)
 Classifier: License :: OSI Approved :: Python Software Foundation License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3.1
 Classifier: Programming Language :: Python :: 3.2
 Classifier: Programming Language :: Python :: 3.3
@@ -24,8 +24,10 @@
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
+Classifier: Programming Language :: Python :: 3.13
+Classifier: Programming Language :: Python :: 3.14
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
```

### Comparing `HepMC3-3.2.5/python/pyHepMC3.search.egg-info.in` & `HepMC3-3.2.6/python/pyHepMC3.search.egg-info.in`

 * *Files 10% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 Metadata-Version: 1.1
 Name: pyHepMC3.search
 Version: @THIS_PROJECT_NAME_VERSION@
 Summary: Python bindings for HepMC3 search module
 Home-page: https://gitlab.cern.ch/hepmc/HepMC3
 Author: HepMC3 Developers
 Author-email: hepmc-dev@cern.ch
-License: GPLv3
+License: LGPLv3+
 Description: pyHepMC3.search
               Official python bindings for the search module of the HepMC3 library
 Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Physicists
-Classifier: License :: OSI Approved :: GPLv3
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)
 Classifier: License :: OSI Approved :: Python Software Foundation License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3.1
 Classifier: Programming Language :: Python :: 3.2
 Classifier: Programming Language :: Python :: 3.3
@@ -24,8 +24,10 @@
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
+Classifier: Programming Language :: Python :: 3.13
+Classifier: Programming Language :: Python :: 3.14
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
```

### Comparing `HepMC3-3.2.5/python/src/binders.cpp` & `HepMC3-3.2.6/python/src/binders.cpp`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/src/binders.h` & `HepMC3-3.2.6/python/src/binders.h`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3.binder` & `HepMC3-3.2.6/python/src/pyHepMC3.binder`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3.cpp`

 * *Files 24% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 #include <map>
+#include <algorithm>
+#include <functional>
 #include <memory>
 #include <stdexcept>
-#include <functional>
 #include <string>
 
 #include <pybind11/pybind11.h>
 
 typedef std::function< pybind11::module & (std::string const &) > ModuleGetter;
 
 void bind_pyHepMC3_0(std::function< pybind11::module &(std::string const &namespace_) > &M);
@@ -37,20 +38,29 @@
 		auto it = modules.find(namespace_);
 		if( it == modules.end() ) throw std::runtime_error("Attempt to access pybind11::module for namespace " + namespace_ + " before it was created!!!");
 		return it->second;
 	};
 
 	modules[""] = root_module;
 
+	static std::vector<std::string> const reserved_python_words {"nonlocal", "global", };
+
+	auto mangle_namespace_name(
+		[](std::string const &ns) -> std::string {
+			if ( std::find(reserved_python_words.begin(), reserved_python_words.end(), ns) == reserved_python_words.end() ) return ns;
+			else return ns+'_';
+		}
+	);
+
 	std::vector< std::pair<std::string, std::string> > sub_modules {
 		{"", "HepMC3"},
 		{"", "LHEF"},
 		{"", "std"},
 	};
-	for(auto &p : sub_modules ) modules[p.first.size() ? p.first+"::"+p.second : p.second] = modules[p.first].def_submodule(p.second.c_str(), ("Bindings for " + p.first + "::" + p.second + " namespace").c_str() );
+	for(auto &p : sub_modules ) modules[p.first.size() ? p.first+"::"+p.second : p.second] = modules[p.first].def_submodule( mangle_namespace_name(p.second).c_str(), ("Bindings for " + p.first + "::" + p.second + " namespace").c_str() );
 
 	//pybind11::class_<std::shared_ptr<void>>(M(""), "_encapsulated_data_");
 
 	bind_pyHepMC3_0(M);
 	bind_pyHepMC3_1(M);
 	bind_pyHepMC3_2(M);
 	bind_pyHepMC3_3(M);
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_0.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_0.cpp`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 #include <HepMC3/Setup.h>
 #include <sstream> // __str__
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_1.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_1.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 #include <HepMC3/FourVector.h>
 #include <sstream> // __str__
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -82,19 +82,19 @@
 		cl.def("delta_r2_rap", (double (HepMC3::FourVector::*)(const class HepMC3::FourVector &) const) &HepMC3::FourVector::delta_r2_rap, "R_rap^2-distance separation dR^2 = dphi^2 + drap^2\n\nC++: HepMC3::FourVector::delta_r2_rap(const class HepMC3::FourVector &) const --> double", pybind11::arg("v"));
 		cl.def("delta_r_rap", (double (HepMC3::FourVector::*)(const class HepMC3::FourVector &) const) &HepMC3::FourVector::delta_r_rap, "R-rap-distance separation dR = sqrt(dphi^2 + drap^2)\n\nC++: HepMC3::FourVector::delta_r_rap(const class HepMC3::FourVector &) const --> double", pybind11::arg("v"));
 		cl.def("__eq__", (bool (HepMC3::FourVector::*)(const class HepMC3::FourVector &) const) &HepMC3::FourVector::operator==, "Equality\n\nC++: HepMC3::FourVector::operator==(const class HepMC3::FourVector &) const --> bool", pybind11::arg("rhs"));
 		cl.def("__ne__", (bool (HepMC3::FourVector::*)(const class HepMC3::FourVector &) const) &HepMC3::FourVector::operator!=, "Inequality\n\nC++: HepMC3::FourVector::operator!=(const class HepMC3::FourVector &) const --> bool", pybind11::arg("rhs"));
 		cl.def("__add__", (class HepMC3::FourVector (HepMC3::FourVector::*)(const class HepMC3::FourVector &) const) &HepMC3::FourVector::operator+, "Arithmetic operator +\n\nC++: HepMC3::FourVector::operator+(const class HepMC3::FourVector &) const --> class HepMC3::FourVector", pybind11::arg("rhs"));
 		cl.def("__sub__", (class HepMC3::FourVector (HepMC3::FourVector::*)(const class HepMC3::FourVector &) const) &HepMC3::FourVector::operator-, "Arithmetic operator -\n\nC++: HepMC3::FourVector::operator-(const class HepMC3::FourVector &) const --> class HepMC3::FourVector", pybind11::arg("rhs"));
 		cl.def("__mul__", (class HepMC3::FourVector (HepMC3::FourVector::*)(const double) const) &HepMC3::FourVector::operator*, "Arithmetic operator * by scalar\n\nC++: HepMC3::FourVector::operator*(const double) const --> class HepMC3::FourVector", pybind11::arg("rhs"));
-		cl.def("__div__", (class HepMC3::FourVector (HepMC3::FourVector::*)(const double) const) &HepMC3::FourVector::operator/, "Arithmetic operator / by scalar\n\nC++: HepMC3::FourVector::operator/(const double) const --> class HepMC3::FourVector", pybind11::arg("rhs"));
+		cl.def("__truediv__", (class HepMC3::FourVector (HepMC3::FourVector::*)(const double) const) &HepMC3::FourVector::operator/, "Arithmetic operator / by scalar\n\nC++: HepMC3::FourVector::operator/(const double) const --> class HepMC3::FourVector", pybind11::arg("rhs"));
 		cl.def("__iadd__", (void (HepMC3::FourVector::*)(const class HepMC3::FourVector &)) &HepMC3::FourVector::operator+=, "Arithmetic operator +=\n\nC++: HepMC3::FourVector::operator+=(const class HepMC3::FourVector &) --> void", pybind11::arg("rhs"));
 		cl.def("__isub__", (void (HepMC3::FourVector::*)(const class HepMC3::FourVector &)) &HepMC3::FourVector::operator-=, "Arithmetic operator -=\n\nC++: HepMC3::FourVector::operator-=(const class HepMC3::FourVector &) --> void", pybind11::arg("rhs"));
 		cl.def("__imul__", (void (HepMC3::FourVector::*)(const double)) &HepMC3::FourVector::operator*=, "Arithmetic operator *= by scalar\n\nC++: HepMC3::FourVector::operator*=(const double) --> void", pybind11::arg("rhs"));
-		cl.def("__idiv__", (void (HepMC3::FourVector::*)(const double)) &HepMC3::FourVector::operator/=, "Arithmetic operator /= by scalar\n\nC++: HepMC3::FourVector::operator/=(const double) --> void", pybind11::arg("rhs"));
+		cl.def("__itruediv__", (void (HepMC3::FourVector::*)(const double)) &HepMC3::FourVector::operator/=, "Arithmetic operator /= by scalar\n\nC++: HepMC3::FourVector::operator/=(const double) --> void", pybind11::arg("rhs"));
 		cl.def_static("ZERO_VECTOR", (const class HepMC3::FourVector & (*)()) &HepMC3::FourVector::ZERO_VECTOR, "Static null FourVector = (0,0,0,0)\n\nC++: HepMC3::FourVector::ZERO_VECTOR() --> const class HepMC3::FourVector &", pybind11::return_value_policy::automatic);
 		cl.def("assign", (class HepMC3::FourVector & (HepMC3::FourVector::*)(const class HepMC3::FourVector &)) &HepMC3::FourVector::operator=, "C++: HepMC3::FourVector::operator=(const class HepMC3::FourVector &) --> class HepMC3::FourVector &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 
 		 binder::custom_FourVector_binder(cl);
 	}
 	// HepMC3::delta_phi(const class HepMC3::FourVector &, const class HepMC3::FourVector &) file:HepMC3/FourVector.h line:313
 	M("HepMC3").def("delta_phi", (double (*)(const class HepMC3::FourVector &, const class HepMC3::FourVector &)) &HepMC3::delta_phi, "Signed azimuthal angle separation in [-pi, pi] between vecs  and \n\nC++: HepMC3::delta_phi(const class HepMC3::FourVector &, const class HepMC3::FourVector &) --> double", pybind11::arg("a"), pybind11::arg("b"));
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_11.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_11.cpp`

 * *Files 27% similar despite different names*

```diff
@@ -1,32 +1,34 @@
 #include <HepMC3/Attribute.h>
 #include <HepMC3/Data/GenEventData.h>
 #include <HepMC3/Data/GenParticleData.h>
+#include <HepMC3/Data/GenRunInfoData.h>
 #include <HepMC3/FourVector.h>
 #include <HepMC3/GenCrossSection.h>
 #include <HepMC3/GenEvent.h>
 #include <HepMC3/GenHeavyIon.h>
 #include <HepMC3/GenParticle.h>
 #include <HepMC3/GenRunInfo.h>
 #include <HepMC3/GenVertex.h>
+#include <HepMC3/Writer.h>
 #include <HepMC3/WriterAscii.h>
 #include <functional>
 #include <ios>
 #include <iterator>
 #include <map>
 #include <memory>
 #include <ostream>
 #include <sstream> // __str__
 #include <streambuf>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -78,14 +80,67 @@
 				static pybind11::detail::override_caster_t<void> caster;
 				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
 		return WriterAscii::close();
 	}
+	void set_run_info(class std::shared_ptr<class HepMC3::GenRunInfo> a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAscii *>(this), "set_run_info");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
+		}
+		return Writer::set_run_info(a0);
+	}
+	class std::shared_ptr<class HepMC3::GenRunInfo> run_info() const override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAscii *>(this), "run_info");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<class std::shared_ptr<class HepMC3::GenRunInfo>>::value) {
+				static pybind11::detail::override_caster_t<class std::shared_ptr<class HepMC3::GenRunInfo>> caster;
+				return pybind11::detail::cast_ref<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o));
+		}
+		return Writer::run_info();
+	}
+	void set_options(const class std::map<std::string, std::string > & a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAscii *>(this), "set_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
+		}
+		return Writer::set_options(a0);
+	}
+	using _binder_ret_0 = std::map<std::string, std::string >;
+	_binder_ret_0 get_options() const override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAscii *>(this), "get_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
+				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
+				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
+		}
+		return Writer::get_options();
+	}
 };
 
 void bind_pyHepMC3_11(std::function< pybind11::module &(std::string const &namespace_) > &M)
 {
 	{ // HepMC3::WriterAscii file:HepMC3/WriterAscii.h line:25
 		pybind11::class_<HepMC3::WriterAscii, std::shared_ptr<HepMC3::WriterAscii>, PyCallBack_HepMC3_WriterAscii, HepMC3::Writer> cl(M("HepMC3"), "WriterAscii", "");
 		cl.def( pybind11::init( [](const std::string & a0){ return new HepMC3::WriterAscii(a0); }, [](const std::string & a0){ return new PyCallBack_HepMC3_WriterAscii(a0); } ), "doc");
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_13.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_12.cpp`

 * *Files 23% similar despite different names*

```diff
@@ -1,35 +1,38 @@
 #include <HepMC3/Attribute.h>
 #include <HepMC3/Data/GenEventData.h>
 #include <HepMC3/Data/GenParticleData.h>
+#include <HepMC3/Data/GenRunInfoData.h>
 #include <HepMC3/FourVector.h>
 #include <HepMC3/GenCrossSection.h>
 #include <HepMC3/GenEvent.h>
 #include <HepMC3/GenHeavyIon.h>
 #include <HepMC3/GenParticle.h>
 #include <HepMC3/GenRunInfo.h>
 #include <HepMC3/GenVertex.h>
-#include <HepMC3/HEPEVT_Wrapper_Runtime.h>
-#include <HepMC3/ReaderHEPEVT.h>
-#include <HepMC3/WriterHEPEVT.h>
+#include <HepMC3/Reader.h>
+#include <HepMC3/ReaderAscii.h>
+#include <HepMC3/ReaderAsciiHepMC2.h>
+#include <HepMC3/Writer.h>
+#include <HepMC3/WriterAsciiHepMC2.h>
 #include <functional>
 #include <ios>
 #include <istream>
 #include <iterator>
 #include <map>
 #include <memory>
 #include <ostream>
 #include <sstream> // __str__
 #include <streambuf>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -38,211 +41,360 @@
 #ifndef BINDER_PYBIND11_TYPE_CASTER
 	#define BINDER_PYBIND11_TYPE_CASTER
 	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
 	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
 	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
 #endif
 
-// HepMC3::WriterHEPEVT file:HepMC3/WriterHEPEVT.h line:27
-struct PyCallBack_HepMC3_WriterHEPEVT : public HepMC3::WriterHEPEVT {
-	using HepMC3::WriterHEPEVT::WriterHEPEVT;
+// HepMC3::ReaderAscii file:HepMC3/ReaderAscii.h line:29
+struct PyCallBack_HepMC3_ReaderAscii : public HepMC3::ReaderAscii {
+	using HepMC3::ReaderAscii::ReaderAscii;
 
-	void write_hepevt_particle(int a0, bool a1) override {
+	bool skip(const int a0) override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterHEPEVT *>(this), "write_hepevt_particle");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "skip");
 		if (overload) {
-			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0, a1);
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
+				static pybind11::detail::override_caster_t<bool> caster;
+				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<bool>(std::move(o));
+		}
+		return ReaderAscii::skip(a0);
+	}
+	bool read_event(class HepMC3::GenEvent & a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "read_event");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
+				static pybind11::detail::override_caster_t<bool> caster;
+				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<bool>(std::move(o));
+		}
+		return ReaderAscii::read_event(a0);
+	}
+	bool failed() override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "failed");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
+				static pybind11::detail::override_caster_t<bool> caster;
+				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<bool>(std::move(o));
+		}
+		return ReaderAscii::failed();
+	}
+	void close() override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "close");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
 			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
 				static pybind11::detail::override_caster_t<void> caster;
 				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
-		return WriterHEPEVT::write_hepevt_particle(a0, a1);
+		return ReaderAscii::close();
 	}
-	void write_hepevt_event_header() override {
+	class std::shared_ptr<class HepMC3::GenRunInfo> run_info() const override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterHEPEVT *>(this), "write_hepevt_event_header");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "run_info");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<class std::shared_ptr<class HepMC3::GenRunInfo>>::value) {
+				static pybind11::detail::override_caster_t<class std::shared_ptr<class HepMC3::GenRunInfo>> caster;
+				return pybind11::detail::cast_ref<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o));
+		}
+		return Reader::run_info();
+	}
+	void set_options(const class std::map<std::string, std::string > & a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "set_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
 			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
 				static pybind11::detail::override_caster_t<void> caster;
 				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
-		return WriterHEPEVT::write_hepevt_event_header();
+		return Reader::set_options(a0);
 	}
-	void write_event(const class HepMC3::GenEvent & a0) override {
+	using _binder_ret_0 = std::map<std::string, std::string >;
+	_binder_ret_0 get_options() const override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterHEPEVT *>(this), "write_event");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "get_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
+				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
+				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
+		}
+		return Reader::get_options();
+	}
+	void set_run_info(class std::shared_ptr<class HepMC3::GenRunInfo> a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAscii *>(this), "set_run_info");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
 			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
 				static pybind11::detail::override_caster_t<void> caster;
 				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
-		return WriterHEPEVT::write_event(a0);
+		return Reader::set_run_info(a0);
 	}
-	void close() override {
+};
+
+// HepMC3::WriterAsciiHepMC2 file:HepMC3/WriterAsciiHepMC2.h line:26
+struct PyCallBack_HepMC3_WriterAsciiHepMC2 : public HepMC3::WriterAsciiHepMC2 {
+	using HepMC3::WriterAsciiHepMC2::WriterAsciiHepMC2;
+
+	void write_event(const class HepMC3::GenEvent & a0) override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterHEPEVT *>(this), "close");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAsciiHepMC2 *>(this), "write_event");
 		if (overload) {
-			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
 			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
 				static pybind11::detail::override_caster_t<void> caster;
 				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
-		return WriterHEPEVT::close();
+		return WriterAsciiHepMC2::write_event(a0);
 	}
 	bool failed() override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterHEPEVT *>(this), "failed");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAsciiHepMC2 *>(this), "failed");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>();
 			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
 				static pybind11::detail::override_caster_t<bool> caster;
 				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
-		return WriterHEPEVT::failed();
+		return WriterAsciiHepMC2::failed();
 	}
-};
-
-// HepMC3::ReaderHEPEVT file:HepMC3/ReaderHEPEVT.h line:32
-struct PyCallBack_HepMC3_ReaderHEPEVT : public HepMC3::ReaderHEPEVT {
-	using HepMC3::ReaderHEPEVT::ReaderHEPEVT;
-
-	bool read_hepevt_event_header() override {
+	void close() override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderHEPEVT *>(this), "read_hepevt_event_header");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAsciiHepMC2 *>(this), "close");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>();
-			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
-				static pybind11::detail::override_caster_t<bool> caster;
-				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
-			else return pybind11::detail::cast_safe<bool>(std::move(o));
+			else return pybind11::detail::cast_safe<void>(std::move(o));
+		}
+		return WriterAsciiHepMC2::close();
+	}
+	void set_run_info(class std::shared_ptr<class HepMC3::GenRunInfo> a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAsciiHepMC2 *>(this), "set_run_info");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
-		return ReaderHEPEVT::read_hepevt_event_header();
+		return Writer::set_run_info(a0);
 	}
-	bool read_hepevt_particle(int a0) override {
+	class std::shared_ptr<class HepMC3::GenRunInfo> run_info() const override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderHEPEVT *>(this), "read_hepevt_particle");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAsciiHepMC2 *>(this), "run_info");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<class std::shared_ptr<class HepMC3::GenRunInfo>>::value) {
+				static pybind11::detail::override_caster_t<class std::shared_ptr<class HepMC3::GenRunInfo>> caster;
+				return pybind11::detail::cast_ref<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o));
+		}
+		return Writer::run_info();
+	}
+	void set_options(const class std::map<std::string, std::string > & a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAsciiHepMC2 *>(this), "set_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
+		}
+		return Writer::set_options(a0);
+	}
+	using _binder_ret_0 = std::map<std::string, std::string >;
+	_binder_ret_0 get_options() const override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::WriterAsciiHepMC2 *>(this), "get_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
+				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
+				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
+		}
+		return Writer::get_options();
+	}
+};
+
+// HepMC3::ReaderAsciiHepMC2 file:HepMC3/ReaderAsciiHepMC2.h line:30
+struct PyCallBack_HepMC3_ReaderAsciiHepMC2 : public HepMC3::ReaderAsciiHepMC2 {
+	using HepMC3::ReaderAsciiHepMC2::ReaderAsciiHepMC2;
+
+	bool skip(const int a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "skip");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
 			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
 				static pybind11::detail::override_caster_t<bool> caster;
 				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
-		return ReaderHEPEVT::read_hepevt_particle(a0);
+		return ReaderAsciiHepMC2::skip(a0);
 	}
-	bool skip(const int a0) override {
+	bool read_event(class HepMC3::GenEvent & a0) override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderHEPEVT *>(this), "skip");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "read_event");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
 			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
 				static pybind11::detail::override_caster_t<bool> caster;
 				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
-		return ReaderHEPEVT::skip(a0);
+		return ReaderAsciiHepMC2::read_event(a0);
 	}
-	bool read_event(class HepMC3::GenEvent & a0) override {
+	bool failed() override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderHEPEVT *>(this), "read_event");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "failed");
 		if (overload) {
-			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
 			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
 				static pybind11::detail::override_caster_t<bool> caster;
 				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
-		return ReaderHEPEVT::read_event(a0);
+		return ReaderAsciiHepMC2::failed();
 	}
 	void close() override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderHEPEVT *>(this), "close");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "close");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>();
 			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
 				static pybind11::detail::override_caster_t<void> caster;
 				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
-		return ReaderHEPEVT::close();
+		return ReaderAsciiHepMC2::close();
 	}
-	bool failed() override {
+	class std::shared_ptr<class HepMC3::GenRunInfo> run_info() const override {
 		pybind11::gil_scoped_acquire gil;
-		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderHEPEVT *>(this), "failed");
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "run_info");
 		if (overload) {
 			auto o = overload.operator()<pybind11::return_value_policy::reference>();
-			if (pybind11::detail::cast_is_temporary_value_reference<bool>::value) {
-				static pybind11::detail::override_caster_t<bool> caster;
-				return pybind11::detail::cast_ref<bool>(std::move(o), caster);
+			if (pybind11::detail::cast_is_temporary_value_reference<class std::shared_ptr<class HepMC3::GenRunInfo>>::value) {
+				static pybind11::detail::override_caster_t<class std::shared_ptr<class HepMC3::GenRunInfo>> caster;
+				return pybind11::detail::cast_ref<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o), caster);
 			}
-			else return pybind11::detail::cast_safe<bool>(std::move(o));
+			else return pybind11::detail::cast_safe<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o));
+		}
+		return Reader::run_info();
+	}
+	void set_options(const class std::map<std::string, std::string > & a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "set_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
-		return ReaderHEPEVT::failed();
+		return Reader::set_options(a0);
+	}
+	using _binder_ret_0 = std::map<std::string, std::string >;
+	_binder_ret_0 get_options() const override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "get_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
+				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
+				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
+		}
+		return Reader::get_options();
+	}
+	void set_run_info(class std::shared_ptr<class HepMC3::GenRunInfo> a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::ReaderAsciiHepMC2 *>(this), "set_run_info");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
+		}
+		return Reader::set_run_info(a0);
 	}
 };
 
-void bind_pyHepMC3_13(std::function< pybind11::module &(std::string const &namespace_) > &M)
+void bind_pyHepMC3_12(std::function< pybind11::module &(std::string const &namespace_) > &M)
 {
-	{ // HepMC3::GenParticlePtr_greater file: line:63
-		pybind11::class_<HepMC3::GenParticlePtr_greater, std::shared_ptr<HepMC3::GenParticlePtr_greater>> cl(M("HepMC3"), "GenParticlePtr_greater", "comparison of two particles ");
-		cl.def( pybind11::init( [](){ return new HepMC3::GenParticlePtr_greater(); } ) );
-		cl.def( pybind11::init( [](HepMC3::GenParticlePtr_greater const &o){ return new HepMC3::GenParticlePtr_greater(o); } ) );
-		cl.def("__call__", (bool (HepMC3::GenParticlePtr_greater::*)(class std::shared_ptr<const class HepMC3::GenParticle>, class std::shared_ptr<const class HepMC3::GenParticle>) const) &HepMC3::GenParticlePtr_greater::operator(), "comparison of two particles \n\nC++: HepMC3::GenParticlePtr_greater::operator()(class std::shared_ptr<const class HepMC3::GenParticle>, class std::shared_ptr<const class HepMC3::GenParticle>) const --> bool", pybind11::arg("lx"), pybind11::arg("rx"));
-	}
-	{ // HepMC3::pair_GenVertexPtr_int_greater file: line:69
-		pybind11::class_<HepMC3::pair_GenVertexPtr_int_greater, std::shared_ptr<HepMC3::pair_GenVertexPtr_int_greater>> cl(M("HepMC3"), "pair_GenVertexPtr_int_greater", "Order vertices with equal paths. ");
-		cl.def( pybind11::init( [](){ return new HepMC3::pair_GenVertexPtr_int_greater(); } ) );
-		cl.def( pybind11::init( [](HepMC3::pair_GenVertexPtr_int_greater const &o){ return new HepMC3::pair_GenVertexPtr_int_greater(o); } ) );
-		cl.def("__call__", (bool (HepMC3::pair_GenVertexPtr_int_greater::*)(const struct std::pair<class std::shared_ptr<const class HepMC3::GenVertex>, int> &, const struct std::pair<class std::shared_ptr<const class HepMC3::GenVertex>, int> &) const) &HepMC3::pair_GenVertexPtr_int_greater::operator(), "Order vertices with equal paths. If the paths are equal, order in other quantities.\n We cannot use id, as it can be assigned in different way\n\nC++: HepMC3::pair_GenVertexPtr_int_greater::operator()(const struct std::pair<class std::shared_ptr<const class HepMC3::GenVertex>, int> &, const struct std::pair<class std::shared_ptr<const class HepMC3::GenVertex>, int> &) const --> bool", pybind11::arg("lx"), pybind11::arg("rx"));
-	}
-	// HepMC3::calculate_longest_path_to_top(class std::shared_ptr<const class HepMC3::GenVertex>, class std::map<class std::shared_ptr<const class HepMC3::GenVertex>, int> &) file: line:76
-	M("HepMC3").def("calculate_longest_path_to_top", (void (*)(class std::shared_ptr<const class HepMC3::GenVertex>, class std::map<class std::shared_ptr<const class HepMC3::GenVertex>, int> &)) &HepMC3::calculate_longest_path_to_top, "Calculates the path to the top (beam) particles \n\nC++: HepMC3::calculate_longest_path_to_top(class std::shared_ptr<const class HepMC3::GenVertex>, class std::map<class std::shared_ptr<const class HepMC3::GenVertex>, int> &) --> void", pybind11::arg("v"), pybind11::arg("pathl"));
-
-	// HepMC3::HEPEVT_to_GenEvent_nonstatic(class HepMC3::GenEvent *, const class HepMC3::HEPEVT_Wrapper_Runtime *) file: line:81
-	M("HepMC3").def("HEPEVT_to_GenEvent_nonstatic", (bool (*)(class HepMC3::GenEvent *, const class HepMC3::HEPEVT_Wrapper_Runtime *)) &HepMC3::HEPEVT_to_GenEvent_nonstatic<const HepMC3::HEPEVT_Wrapper_Runtime>, "C++: HepMC3::HEPEVT_to_GenEvent_nonstatic(class HepMC3::GenEvent *, const class HepMC3::HEPEVT_Wrapper_Runtime *) --> bool", pybind11::arg("evt"), pybind11::arg("A"));
-
-	// HepMC3::GenEvent_to_HEPEVT_nonstatic(const class HepMC3::GenEvent *, class HepMC3::HEPEVT_Wrapper_Runtime *) file: line:152
-	M("HepMC3").def("GenEvent_to_HEPEVT_nonstatic", (bool (*)(const class HepMC3::GenEvent *, class HepMC3::HEPEVT_Wrapper_Runtime *)) &HepMC3::GenEvent_to_HEPEVT_nonstatic<HepMC3::HEPEVT_Wrapper_Runtime>, "C++: HepMC3::GenEvent_to_HEPEVT_nonstatic(const class HepMC3::GenEvent *, class HepMC3::HEPEVT_Wrapper_Runtime *) --> bool", pybind11::arg("evt"), pybind11::arg("A"));
-
-	{ // HepMC3::WriterHEPEVT file:HepMC3/WriterHEPEVT.h line:27
-		pybind11::class_<HepMC3::WriterHEPEVT, std::shared_ptr<HepMC3::WriterHEPEVT>, PyCallBack_HepMC3_WriterHEPEVT, HepMC3::Writer> cl(M("HepMC3"), "WriterHEPEVT", "");
-		cl.def( pybind11::init( [](const std::string & a0){ return new HepMC3::WriterHEPEVT(a0); }, [](const std::string & a0){ return new PyCallBack_HepMC3_WriterHEPEVT(a0); } ), "doc");
+	{ // HepMC3::ReaderAscii file:HepMC3/ReaderAscii.h line:29
+		pybind11::class_<HepMC3::ReaderAscii, std::shared_ptr<HepMC3::ReaderAscii>, PyCallBack_HepMC3_ReaderAscii, HepMC3::Reader> cl(M("HepMC3"), "ReaderAscii", "");
+		cl.def( pybind11::init<const std::string &>(), pybind11::arg("filename") );
+
+		cl.def("skip", (bool (HepMC3::ReaderAscii::*)(const int)) &HepMC3::ReaderAscii::skip, "skip events\n\nC++: HepMC3::ReaderAscii::skip(const int) --> bool", pybind11::arg(""));
+		cl.def("read_event", (bool (HepMC3::ReaderAscii::*)(class HepMC3::GenEvent &)) &HepMC3::ReaderAscii::read_event, "Load event from file\n\n \n Event to be filled\n\nC++: HepMC3::ReaderAscii::read_event(class HepMC3::GenEvent &) --> bool", pybind11::arg("evt"));
+		cl.def("failed", (bool (HepMC3::ReaderAscii::*)()) &HepMC3::ReaderAscii::failed, "Return status of the stream\n\nC++: HepMC3::ReaderAscii::failed() --> bool");
+		cl.def("close", (void (HepMC3::ReaderAscii::*)()) &HepMC3::ReaderAscii::close, "Close file stream\n\nC++: HepMC3::ReaderAscii::close() --> void");
+	}
+	{ // HepMC3::WriterAsciiHepMC2 file:HepMC3/WriterAsciiHepMC2.h line:26
+		pybind11::class_<HepMC3::WriterAsciiHepMC2, std::shared_ptr<HepMC3::WriterAsciiHepMC2>, PyCallBack_HepMC3_WriterAsciiHepMC2, HepMC3::Writer> cl(M("HepMC3"), "WriterAsciiHepMC2", "");
+		cl.def( pybind11::init( [](const std::string & a0){ return new HepMC3::WriterAsciiHepMC2(a0); }, [](const std::string & a0){ return new PyCallBack_HepMC3_WriterAsciiHepMC2(a0); } ), "doc");
 		cl.def( pybind11::init<const std::string &, class std::shared_ptr<class HepMC3::GenRunInfo>>(), pybind11::arg("filename"), pybind11::arg("run") );
 
-		cl.def("write_hepevt_particle", [](HepMC3::WriterHEPEVT &o, int const & a0) -> void { return o.write_hepevt_particle(a0); }, "", pybind11::arg("index"));
-		cl.def("write_hepevt_particle", (void (HepMC3::WriterHEPEVT::*)(int, bool)) &HepMC3::WriterHEPEVT::write_hepevt_particle, "Write particle to file\n\n  \n Particle to be serialized\n  \n\n Format of record\n\nC++: HepMC3::WriterHEPEVT::write_hepevt_particle(int, bool) --> void", pybind11::arg("index"), pybind11::arg("iflong"));
-		cl.def("write_hepevt_event_header", (void (HepMC3::WriterHEPEVT::*)()) &HepMC3::WriterHEPEVT::write_hepevt_event_header, "Write event header to file\n\n     \n\nC++: HepMC3::WriterHEPEVT::write_hepevt_event_header() --> void");
-		cl.def("write_event", (void (HepMC3::WriterHEPEVT::*)(const class HepMC3::GenEvent &)) &HepMC3::WriterHEPEVT::write_event, "Write event to file\n\n  \n Event to be serialized\n\nC++: HepMC3::WriterHEPEVT::write_event(const class HepMC3::GenEvent &) --> void", pybind11::arg("evt"));
-		cl.def("close", (void (HepMC3::WriterHEPEVT::*)()) &HepMC3::WriterHEPEVT::close, "Close file stream \n\nC++: HepMC3::WriterHEPEVT::close() --> void");
-		cl.def("failed", (bool (HepMC3::WriterHEPEVT::*)()) &HepMC3::WriterHEPEVT::failed, "Get stream error state flag \n\nC++: HepMC3::WriterHEPEVT::failed() --> bool");
-		cl.def("set_vertices_positions_present", (void (HepMC3::WriterHEPEVT::*)(bool)) &HepMC3::WriterHEPEVT::set_vertices_positions_present, "set flag if vertex positions are available.\n  Effectively this adds or removes key \"vertices_positions_are_absent\"\n  to/from the m_options.\n\nC++: HepMC3::WriterHEPEVT::set_vertices_positions_present(bool) --> void", pybind11::arg("iflong"));
-		cl.def("get_vertices_positions_present", (bool (HepMC3::WriterHEPEVT::*)() const) &HepMC3::WriterHEPEVT::get_vertices_positions_present, "get flag if vertex positions are available.\n The flag is deduced from m_options. If the m_options have the key\n \"vertices_positions_are_absent\" the result if false. True otherwise. \n\nC++: HepMC3::WriterHEPEVT::get_vertices_positions_present() const --> bool");
+		cl.def("write_event", (void (HepMC3::WriterAsciiHepMC2::*)(const class HepMC3::GenEvent &)) &HepMC3::WriterAsciiHepMC2::write_event, "Write event to file\n\n \n Event to be serialized\n\nC++: HepMC3::WriterAsciiHepMC2::write_event(const class HepMC3::GenEvent &) --> void", pybind11::arg("evt"));
+		cl.def("write_run_info", (void (HepMC3::WriterAsciiHepMC2::*)()) &HepMC3::WriterAsciiHepMC2::write_run_info, "Write the GenRunInfo object to file.\n\nC++: HepMC3::WriterAsciiHepMC2::write_run_info() --> void");
+		cl.def("failed", (bool (HepMC3::WriterAsciiHepMC2::*)()) &HepMC3::WriterAsciiHepMC2::failed, "Return status of the stream\n\nC++: HepMC3::WriterAsciiHepMC2::failed() --> bool");
+		cl.def("close", (void (HepMC3::WriterAsciiHepMC2::*)()) &HepMC3::WriterAsciiHepMC2::close, "Close file stream\n\nC++: HepMC3::WriterAsciiHepMC2::close() --> void");
+		cl.def("set_precision", (void (HepMC3::WriterAsciiHepMC2::*)(const int &)) &HepMC3::WriterAsciiHepMC2::set_precision, "Set output precision\n\n Available range is [2,24]. Default is 16.\n\nC++: HepMC3::WriterAsciiHepMC2::set_precision(const int &) --> void", pybind11::arg("prec"));
+		cl.def("precision", (int (HepMC3::WriterAsciiHepMC2::*)() const) &HepMC3::WriterAsciiHepMC2::precision, "Return output precision\n\nC++: HepMC3::WriterAsciiHepMC2::precision() const --> int");
 	}
-	{ // HepMC3::ReaderHEPEVT file:HepMC3/ReaderHEPEVT.h line:32
-		pybind11::class_<HepMC3::ReaderHEPEVT, std::shared_ptr<HepMC3::ReaderHEPEVT>, PyCallBack_HepMC3_ReaderHEPEVT, HepMC3::Reader> cl(M("HepMC3"), "ReaderHEPEVT", "");
+	{ // HepMC3::ReaderAsciiHepMC2 file:HepMC3/ReaderAsciiHepMC2.h line:30
+		pybind11::class_<HepMC3::ReaderAsciiHepMC2, std::shared_ptr<HepMC3::ReaderAsciiHepMC2>, PyCallBack_HepMC3_ReaderAsciiHepMC2, HepMC3::Reader> cl(M("HepMC3"), "ReaderAsciiHepMC2", "");
 		cl.def( pybind11::init<const std::string &>(), pybind11::arg("filename") );
 
-		cl.def("read_hepevt_event_header", (bool (HepMC3::ReaderHEPEVT::*)()) &HepMC3::ReaderHEPEVT::read_hepevt_event_header, "Find and read event header line  from file\n\n    \n\nC++: HepMC3::ReaderHEPEVT::read_hepevt_event_header() --> bool");
-		cl.def("read_hepevt_particle", (bool (HepMC3::ReaderHEPEVT::*)(int)) &HepMC3::ReaderHEPEVT::read_hepevt_particle, "read particle from file\n\n \n Particle id\n\nC++: HepMC3::ReaderHEPEVT::read_hepevt_particle(int) --> bool", pybind11::arg("i"));
-		cl.def("skip", (bool (HepMC3::ReaderHEPEVT::*)(const int)) &HepMC3::ReaderHEPEVT::skip, "skip events\n\nC++: HepMC3::ReaderHEPEVT::skip(const int) --> bool", pybind11::arg(""));
-		cl.def("read_event", (bool (HepMC3::ReaderHEPEVT::*)(class HepMC3::GenEvent &)) &HepMC3::ReaderHEPEVT::read_event, "Read event from file\n\nC++: HepMC3::ReaderHEPEVT::read_event(class HepMC3::GenEvent &) --> bool", pybind11::arg("evt"));
-		cl.def("close", (void (HepMC3::ReaderHEPEVT::*)()) &HepMC3::ReaderHEPEVT::close, "Close file stream \n\nC++: HepMC3::ReaderHEPEVT::close() --> void");
-		cl.def("failed", (bool (HepMC3::ReaderHEPEVT::*)()) &HepMC3::ReaderHEPEVT::failed, "Get stream error state \n\nC++: HepMC3::ReaderHEPEVT::failed() --> bool");
+		cl.def("skip", (bool (HepMC3::ReaderAsciiHepMC2::*)(const int)) &HepMC3::ReaderAsciiHepMC2::skip, "skip events\n\nC++: HepMC3::ReaderAsciiHepMC2::skip(const int) --> bool", pybind11::arg(""));
+		cl.def("read_event", (bool (HepMC3::ReaderAsciiHepMC2::*)(class HepMC3::GenEvent &)) &HepMC3::ReaderAsciiHepMC2::read_event, "Implementation of Reader::read_event \n\nC++: HepMC3::ReaderAsciiHepMC2::read_event(class HepMC3::GenEvent &) --> bool", pybind11::arg("evt"));
+		cl.def("failed", (bool (HepMC3::ReaderAsciiHepMC2::*)()) &HepMC3::ReaderAsciiHepMC2::failed, "Return status of the stream\n\nC++: HepMC3::ReaderAsciiHepMC2::failed() --> bool");
+		cl.def("close", (void (HepMC3::ReaderAsciiHepMC2::*)()) &HepMC3::ReaderAsciiHepMC2::close, "Close file stream\n\nC++: HepMC3::ReaderAsciiHepMC2::close() --> void");
 	}
 }
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_14.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_14.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -9,16 +9,16 @@
 #include <set>
 #include <sstream> // __str__
 #include <streambuf>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -38,48 +38,48 @@
 		cl.def( pybind11::init<std::string, const std::string &>(), pybind11::arg("n"), pybind11::arg("v") );
 
 		cl.def( pybind11::init( [](LHEF::OAttr<std::string> const &o){ return new LHEF::OAttr<std::string>(o); } ) );
 		cl.def_readwrite("name", &LHEF::OAttr<std::string>::name);
 		cl.def_readwrite("val", &LHEF::OAttr<std::string>::val);
 		cl.def("assign", (struct LHEF::OAttr<std::string > & (LHEF::OAttr<std::string>::*)(const struct LHEF::OAttr<std::string > &)) &LHEF::OAttr<std::string>::operator=, "C++: LHEF::OAttr<std::string>::operator=(const struct LHEF::OAttr<std::string > &) --> struct LHEF::OAttr<std::string > &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 
-		cl.def("__str__", [](LHEF::OAttr<std::string> const &o) -> std::string { std::ostringstream s; s << o; return s.str(); } );
+		cl.def("__str__", [](LHEF::OAttr<std::string> const &o) -> std::string { std::ostringstream s; LHEF::operator<<(s, o); return s.str(); } );
 	}
 	{ // LHEF::OAttr file:HepMC3/LHEF.h line:45
 		pybind11::class_<LHEF::OAttr<long>, std::shared_ptr<LHEF::OAttr<long>>> cl(M("LHEF"), "OAttr_long_t", "");
 		cl.def( pybind11::init<std::string, const long &>(), pybind11::arg("n"), pybind11::arg("v") );
 
 		cl.def( pybind11::init( [](LHEF::OAttr<long> const &o){ return new LHEF::OAttr<long>(o); } ) );
 		cl.def_readwrite("name", &LHEF::OAttr<long>::name);
 		cl.def_readwrite("val", &LHEF::OAttr<long>::val);
 		cl.def("assign", (struct LHEF::OAttr<long> & (LHEF::OAttr<long>::*)(const struct LHEF::OAttr<long> &)) &LHEF::OAttr<long>::operator=, "C++: LHEF::OAttr<long>::operator=(const struct LHEF::OAttr<long> &) --> struct LHEF::OAttr<long> &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 
-		cl.def("__str__", [](LHEF::OAttr<long> const &o) -> std::string { std::ostringstream s; s << o; return s.str(); } );
+		cl.def("__str__", [](LHEF::OAttr<long> const &o) -> std::string { std::ostringstream s; LHEF::operator<<(s, o); return s.str(); } );
 	}
 	{ // LHEF::OAttr file:HepMC3/LHEF.h line:45
 		pybind11::class_<LHEF::OAttr<double>, std::shared_ptr<LHEF::OAttr<double>>> cl(M("LHEF"), "OAttr_double_t", "");
 		cl.def( pybind11::init<std::string, const double &>(), pybind11::arg("n"), pybind11::arg("v") );
 
 		cl.def( pybind11::init( [](LHEF::OAttr<double> const &o){ return new LHEF::OAttr<double>(o); } ) );
 		cl.def_readwrite("name", &LHEF::OAttr<double>::name);
 		cl.def_readwrite("val", &LHEF::OAttr<double>::val);
 		cl.def("assign", (struct LHEF::OAttr<double> & (LHEF::OAttr<double>::*)(const struct LHEF::OAttr<double> &)) &LHEF::OAttr<double>::operator=, "C++: LHEF::OAttr<double>::operator=(const struct LHEF::OAttr<double> &) --> struct LHEF::OAttr<double> &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 
-		cl.def("__str__", [](LHEF::OAttr<double> const &o) -> std::string { std::ostringstream s; s << o; return s.str(); } );
+		cl.def("__str__", [](LHEF::OAttr<double> const &o) -> std::string { std::ostringstream s; LHEF::operator<<(s, o); return s.str(); } );
 	}
 	{ // LHEF::OAttr file:HepMC3/LHEF.h line:45
 		pybind11::class_<LHEF::OAttr<int>, std::shared_ptr<LHEF::OAttr<int>>> cl(M("LHEF"), "OAttr_int_t", "");
 		cl.def( pybind11::init<std::string, const int &>(), pybind11::arg("n"), pybind11::arg("v") );
 
 		cl.def( pybind11::init( [](LHEF::OAttr<int> const &o){ return new LHEF::OAttr<int>(o); } ) );
 		cl.def_readwrite("name", &LHEF::OAttr<int>::name);
 		cl.def_readwrite("val", &LHEF::OAttr<int>::val);
 		cl.def("assign", (struct LHEF::OAttr<int> & (LHEF::OAttr<int>::*)(const struct LHEF::OAttr<int> &)) &LHEF::OAttr<int>::operator=, "C++: LHEF::OAttr<int>::operator=(const struct LHEF::OAttr<int> &) --> struct LHEF::OAttr<int> &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 
-		cl.def("__str__", [](LHEF::OAttr<int> const &o) -> std::string { std::ostringstream s; s << o; return s.str(); } );
+		cl.def("__str__", [](LHEF::OAttr<int> const &o) -> std::string { std::ostringstream s; LHEF::operator<<(s, o); return s.str(); } );
 	}
 	// LHEF::oattr(std::string, const std::string &) file:HepMC3/LHEF.h line:68
 	M("LHEF").def("oattr", (struct LHEF::OAttr<std::string > (*)(std::string, const std::string &)) &LHEF::oattr<std::string>, "C++: LHEF::oattr(std::string, const std::string &) --> struct LHEF::OAttr<std::string >", pybind11::arg("name"), pybind11::arg("value"));
 
 	// LHEF::oattr(std::string, const long &) file:HepMC3/LHEF.h line:68
 	M("LHEF").def("oattr", (struct LHEF::OAttr<long> (*)(std::string, const long &)) &LHEF::oattr<long>, "C++: LHEF::oattr(std::string, const long &) --> struct LHEF::OAttr<long>", pybind11::arg("name"), pybind11::arg("value"));
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_15.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_15.cpp`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 #include <memory>
 #include <ostream>
 #include <sstream> // __str__
 #include <streambuf>
 #include <string>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_16.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_16.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 #include <iterator>
 #include <memory>
 #include <ostream>
 #include <sstream> // __str__
 #include <streambuf>
 #include <string>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -41,16 +41,21 @@
 		cl.def_readwrite("eventComments", &LHEF::Reader::eventComments);
 		cl.def_readwrite("currevent", &LHEF::Reader::currevent);
 		cl.def_readwrite("curreventfile", &LHEF::Reader::curreventfile);
 		cl.def_readwrite("currfileevent", &LHEF::Reader::currfileevent);
 		cl.def_readwrite("dirpath", &LHEF::Reader::dirpath);
 		cl.def("readEvent", (bool (LHEF::Reader::*)()) &LHEF::Reader::readEvent, "Read an event from the file and store it in the hepeup\n object. Optional comment lines are stored i the eventComments\n member variable.\n \n\n true if the read sas successful.\n\nC++: LHEF::Reader::readEvent() --> bool");
 		cl.def("openeventfile", (void (LHEF::Reader::*)(int)) &LHEF::Reader::openeventfile, "Open the efentfile with index ifile. If another eventfile is\n being read, its remaining contents is discarded. This is a noop\n if current read session is not a multi-file run.\n\nC++: LHEF::Reader::openeventfile(int) --> void", pybind11::arg("ifile"));
+/*Because of an issue in binder one should comment those lines manually.*/
+/*
+		cl.def("initfile_rdstate", (enum std::_Ios_Iostate (LHEF::Reader::*)() const) &LHEF::Reader::initfile_rdstate, "initfile rdstate \n\nC++: LHEF::Reader::initfile_rdstate() const --> enum std::_Ios_Iostate");
+		cl.def("file_rdstate", (enum std::_Ios_Iostate (LHEF::Reader::*)() const) &LHEF::Reader::file_rdstate, "file rdstate \n\nC++: LHEF::Reader::file_rdstate() const --> enum std::_Ios_Iostate");
+*/
 	}
-	{ // LHEF::Writer file:HepMC3/LHEF.h line:3090
+	{ // LHEF::Writer file:HepMC3/LHEF.h line:3099
 		pybind11::class_<LHEF::Writer, std::shared_ptr<LHEF::Writer>> cl(M("LHEF"), "Writer", "The Writer class is initialized with a stream to which to write a\n version 1.0 Les Houches Accord event file. In the constructor of\n the Writer object the main XML tag is written out, with the\n corresponding end tag is written in the destructor. After a Writer\n object has been created, it is possible to assign standard init\n information in the heprup member variable. In addition any XML\n formatted information can be added to the headerBlock member\n variable (directly or via the addHeader() function). Further\n comment line (beginning with a # character) can be\n added to the initComments variable (directly or with the\n addInitComment() function). After this information is set, it\n should be written out to the file with the init() function.\n\n Before each event is written out with the writeEvent() function,\n the standard event information can then be assigned to the hepeup\n variable and optional comment lines (beginning with a\n # character) may be given to the eventComments\n variable (directly or with the addEventComment() function).\n\n ");
 		cl.def( pybind11::init<std::string>(), pybind11::arg("filename") );
 
 		cl.def_readwrite("heprup", &LHEF::Writer::heprup);
 		cl.def_readwrite("hepeup", &LHEF::Writer::hepeup);
 		cl.def("headerBlock", (void (LHEF::Writer::*)(const std::string &)) &LHEF::Writer::headerBlock, "Add header lines consisting of XML code with this stream.\n\nC++: LHEF::Writer::headerBlock(const std::string &) --> void", pybind11::arg("a"));
 		cl.def("initComments", (void (LHEF::Writer::*)(const std::string &)) &LHEF::Writer::initComments, "Add comment lines to the init block with this stream.\n\nC++: LHEF::Writer::initComments(const std::string &) --> void", pybind11::arg("a"));
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_17.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_17.cpp`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -10,16 +10,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_2.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_2.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,32 +1,22 @@
 #include <HepMC3/Attribute.h>
-#include <HepMC3/Data/GenParticleData.h>
-#include <HepMC3/FourVector.h>
 #include <HepMC3/GenCrossSection.h>
-#include <HepMC3/GenEvent.h>
 #include <HepMC3/GenHeavyIon.h>
-#include <HepMC3/GenParticle.h>
 #include <HepMC3/GenVertex.h>
-#include <HepMC3/LHEF.h>
-//#include <bits/stl_uninitialized.h>
 #include <functional>
-#include <ios>
 #include <iterator>
 #include <map>
 #include <memory>
-#include <ostream>
 #include <set>
 #include <sstream> // __str__
-#include <streambuf>
 #include <string>
 #include <utility>
-#include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_3.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_3.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,19 @@
-#include <HepMC3/Data/GenParticleData.h>
 #include <HepMC3/GenParticle.h>
-#include <HepMC3/GenRunInfo.h>
 #include <HepMC3/GenVertex.h>
 #include <HepMC3/LHEF.h>
-#include <functional>
 #include <iterator>
-#include <map>
 #include <memory>
 #include <ostream>
-#include <set>
 #include <sstream> // __str__
 #include <string>
-#include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -30,59 +24,62 @@
 	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
 	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
 	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
 #endif
 
 void bind_pyHepMC3_3(std::function< pybind11::module &(std::string const &namespace_) > &M)
 {
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<std::shared_ptr<HepMC3::GenParticle>,std::allocator<std::shared_ptr<HepMC3::GenParticle> >>(M("std"), "std_shared_ptr_HepMC3_GenParticle_t", "std_allocator_std_shared_ptr_HepMC3_GenParticle_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
+	binder::vector_binder<std::shared_ptr<const HepMC3::GenParticle>,std::allocator<std::shared_ptr<const HepMC3::GenParticle> >>(M("std"), "std_shared_ptr_const_HepMC3_GenParticle_t", "std_allocator_std_shared_ptr_const_HepMC3_GenParticle_t");
+
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<char,std::allocator<char>>(M("std"), "char", "std_allocator_char_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<float,std::allocator<float>>(M("std"), "float", "std_allocator_float_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<long double,std::allocator<long double>>(M("std"), "long_double", "std_allocator_long_double_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<long long,std::allocator<long long>>(M("std"), "long_long", "std_allocator_long_long_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<unsigned int,std::allocator<unsigned int>>(M("std"), "unsigned_int", "std_allocator_unsigned_int_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<unsigned long,std::allocator<unsigned long>>(M("std"), "unsigned_long", "std_allocator_unsigned_long_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<unsigned long long,std::allocator<unsigned long long>>(M("std"), "unsigned_long_long", "std_allocator_unsigned_long_long_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<int,std::allocator<int>>(M("std"), "int", "std_allocator_int_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<long,std::allocator<long>>(M("std"), "long", "std_allocator_long_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<double,std::allocator<double>>(M("std"), "double", "std_allocator_double_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<std::string,std::allocator<std::string >>(M("std"), "std_string", "std_allocator_std_string_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<std::shared_ptr<HepMC3::GenVertex>,std::allocator<std::shared_ptr<HepMC3::GenVertex> >>(M("std"), "std_shared_ptr_HepMC3_GenVertex_t", "std_allocator_std_shared_ptr_HepMC3_GenVertex_t");
 
-	// std::vector file:bits/stl_vector.h line:339
-	binder::vector_binder<LHEF::XMLTag *,std::allocator<LHEF::XMLTag *>>(M("std"), "LHEF_XMLTag_*", "std_allocator_LHEF_XMLTag_*_t");
+	// std::vector file:bits/stl_vector.h line:423
+	binder::vector_binder<LHEF::XMLTag *,std::allocator<LHEF::XMLTag *>>(M("std"), "LHEF_XMLTag_*", "std_allocator_LHEF_XMLTag__star__t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<std::vector<double>,std::allocator<std::vector<double> >>(M("std"), "std_vector_double_t", "std_allocator_std_vector_double_t");
 
-	// std::vector file:bits/stl_vector.h line:339
+	// std::vector file:bits/stl_vector.h line:423
 	binder::vector_binder<LHEF::WeightInfo,std::allocator<LHEF::WeightInfo>>(M("std"), "LHEF_WeightInfo", "std_allocator_LHEF_WeightInfo_t");
 
-	// std::vector file:bits/stl_vector.h line:339
-	binder::vector_binder<LHEF::HEPEUP *,std::allocator<LHEF::HEPEUP *>>(M("std"), "LHEF_HEPEUP_*", "std_allocator_LHEF_HEPEUP_*_t");
+	// std::vector file:bits/stl_vector.h line:423
+	binder::vector_binder<LHEF::HEPEUP *,std::allocator<LHEF::HEPEUP *>>(M("std"), "LHEF_HEPEUP_*", "std_allocator_LHEF_HEPEUP__star__t");
 
 }
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_4.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_4.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -13,16 +13,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -642,15 +642,15 @@
 		cl.def("from_string", (bool (HepMC3::IntAttribute::*)(const std::string &)) &HepMC3::IntAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::IntAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::IntAttribute::*)(std::string &) const) &HepMC3::IntAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::IntAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (int (HepMC3::IntAttribute::*)() const) &HepMC3::IntAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::IntAttribute::value() const --> int");
 		cl.def("set_value", (void (HepMC3::IntAttribute::*)(const int &)) &HepMC3::IntAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::IntAttribute::set_value(const int &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::IntAttribute & (HepMC3::IntAttribute::*)(const class HepMC3::IntAttribute &)) &HepMC3::IntAttribute::operator=, "C++: HepMC3::IntAttribute::operator=(const class HepMC3::IntAttribute &) --> class HepMC3::IntAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 	{ // HepMC3::LongAttribute file:HepMC3/Attribute.h line:198
-		pybind11::class_<HepMC3::LongAttribute, std::shared_ptr<HepMC3::LongAttribute>, PyCallBack_HepMC3_LongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "LongAttribute", "Attribute that holds an Integer implemented as an int\n\n  \n\n ");
+		pybind11::class_<HepMC3::LongAttribute, std::shared_ptr<HepMC3::LongAttribute>, PyCallBack_HepMC3_LongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "LongAttribute", "Attribute that holds an Integer implemented as a long int\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::LongAttribute(); }, [](){ return new PyCallBack_HepMC3_LongAttribute(); } ) );
 		cl.def( pybind11::init<long>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_LongAttribute const &o){ return new PyCallBack_HepMC3_LongAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::LongAttribute const &o){ return new HepMC3::LongAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::LongAttribute::*)(const std::string &)) &HepMC3::LongAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::LongAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::LongAttribute::*)(std::string &) const) &HepMC3::LongAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::LongAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
@@ -694,41 +694,41 @@
 		cl.def("from_string", (bool (HepMC3::StringAttribute::*)(const std::string &)) &HepMC3::StringAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::StringAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::StringAttribute::*)(std::string &) const) &HepMC3::StringAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::StringAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (std::string (HepMC3::StringAttribute::*)() const) &HepMC3::StringAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::StringAttribute::value() const --> std::string");
 		cl.def("set_value", (void (HepMC3::StringAttribute::*)(const std::string &)) &HepMC3::StringAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::StringAttribute::set_value(const std::string &) --> void", pybind11::arg("s"));
 		cl.def("assign", (class HepMC3::StringAttribute & (HepMC3::StringAttribute::*)(const class HepMC3::StringAttribute &)) &HepMC3::StringAttribute::operator=, "C++: HepMC3::StringAttribute::operator=(const class HepMC3::StringAttribute &) --> class HepMC3::StringAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 	{ // HepMC3::CharAttribute file:HepMC3/Attribute.h line:379
-		pybind11::class_<HepMC3::CharAttribute, std::shared_ptr<HepMC3::CharAttribute>, PyCallBack_HepMC3_CharAttribute, HepMC3::Attribute> cl(M("HepMC3"), "CharAttribute", "Attribute that holds an Chareger implemented as an int\n\n  \n\n ");
+		pybind11::class_<HepMC3::CharAttribute, std::shared_ptr<HepMC3::CharAttribute>, PyCallBack_HepMC3_CharAttribute, HepMC3::Attribute> cl(M("HepMC3"), "CharAttribute", "Attribute that holds an Character implemented as an int\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::CharAttribute(); }, [](){ return new PyCallBack_HepMC3_CharAttribute(); } ) );
 		cl.def( pybind11::init<char>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_CharAttribute const &o){ return new PyCallBack_HepMC3_CharAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::CharAttribute const &o){ return new HepMC3::CharAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::CharAttribute::*)(const std::string &)) &HepMC3::CharAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::CharAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::CharAttribute::*)(std::string &) const) &HepMC3::CharAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::CharAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (char (HepMC3::CharAttribute::*)() const) &HepMC3::CharAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::CharAttribute::value() const --> char");
 		cl.def("set_value", (void (HepMC3::CharAttribute::*)(const char &)) &HepMC3::CharAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::CharAttribute::set_value(const char &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::CharAttribute & (HepMC3::CharAttribute::*)(const class HepMC3::CharAttribute &)) &HepMC3::CharAttribute::operator=, "C++: HepMC3::CharAttribute::operator=(const class HepMC3::CharAttribute &) --> class HepMC3::CharAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 	{ // HepMC3::LongLongAttribute file:HepMC3/Attribute.h line:424
-		pybind11::class_<HepMC3::LongLongAttribute, std::shared_ptr<HepMC3::LongLongAttribute>, PyCallBack_HepMC3_LongLongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "LongLongAttribute", "Attribute that holds an Integer implemented as an int\n\n  \n\n ");
+		pybind11::class_<HepMC3::LongLongAttribute, std::shared_ptr<HepMC3::LongLongAttribute>, PyCallBack_HepMC3_LongLongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "LongLongAttribute", "Attribute that holds an Integer implemented as a long long int\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::LongLongAttribute(); }, [](){ return new PyCallBack_HepMC3_LongLongAttribute(); } ) );
 		cl.def( pybind11::init<long long>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_LongLongAttribute const &o){ return new PyCallBack_HepMC3_LongLongAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::LongLongAttribute const &o){ return new HepMC3::LongLongAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::LongLongAttribute::*)(const std::string &)) &HepMC3::LongLongAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::LongLongAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::LongLongAttribute::*)(std::string &) const) &HepMC3::LongLongAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::LongLongAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (long long (HepMC3::LongLongAttribute::*)() const) &HepMC3::LongLongAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::LongLongAttribute::value() const --> long long");
 		cl.def("set_value", (void (HepMC3::LongLongAttribute::*)(const long long &)) &HepMC3::LongLongAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::LongLongAttribute::set_value(const long long &) --> void", pybind11::arg("l"));
 		cl.def("assign", (class HepMC3::LongLongAttribute & (HepMC3::LongLongAttribute::*)(const class HepMC3::LongLongAttribute &)) &HepMC3::LongLongAttribute::operator=, "C++: HepMC3::LongLongAttribute::operator=(const class HepMC3::LongLongAttribute &) --> class HepMC3::LongLongAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 	{ // HepMC3::LongDoubleAttribute file:HepMC3/Attribute.h line:467
-		pybind11::class_<HepMC3::LongDoubleAttribute, std::shared_ptr<HepMC3::LongDoubleAttribute>, PyCallBack_HepMC3_LongDoubleAttribute, HepMC3::Attribute> cl(M("HepMC3"), "LongDoubleAttribute", "Attribute that holds a real number as a double.\n\n  \n\n ");
+		pybind11::class_<HepMC3::LongDoubleAttribute, std::shared_ptr<HepMC3::LongDoubleAttribute>, PyCallBack_HepMC3_LongDoubleAttribute, HepMC3::Attribute> cl(M("HepMC3"), "LongDoubleAttribute", "Attribute that holds a real number as a long double.\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::LongDoubleAttribute(); }, [](){ return new PyCallBack_HepMC3_LongDoubleAttribute(); } ) );
 		cl.def( pybind11::init<long double>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_LongDoubleAttribute const &o){ return new PyCallBack_HepMC3_LongDoubleAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::LongDoubleAttribute const &o){ return new HepMC3::LongDoubleAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::LongDoubleAttribute::*)(const std::string &)) &HepMC3::LongDoubleAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::LongDoubleAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::LongDoubleAttribute::*)(std::string &) const) &HepMC3::LongDoubleAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::LongDoubleAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_5.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_5.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -142,15 +142,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::BoolAttribute file:HepMC3/Attribute.h line:639
+// HepMC3::BoolAttribute file:HepMC3/Attribute.h line:640
 struct PyCallBack_HepMC3_BoolAttribute : public HepMC3::BoolAttribute {
 	using HepMC3::BoolAttribute::BoolAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::BoolAttribute *>(this), "from_string");
 		if (overload) {
@@ -200,15 +200,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorCharAttribute file:HepMC3/Attribute.h line:682
+// HepMC3::VectorCharAttribute file:HepMC3/Attribute.h line:683
 struct PyCallBack_HepMC3_VectorCharAttribute : public HepMC3::VectorCharAttribute {
 	using HepMC3::VectorCharAttribute::VectorCharAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorCharAttribute *>(this), "from_string");
 		if (overload) {
@@ -258,15 +258,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorFloatAttribute file:HepMC3/Attribute.h line:727
+// HepMC3::VectorFloatAttribute file:HepMC3/Attribute.h line:728
 struct PyCallBack_HepMC3_VectorFloatAttribute : public HepMC3::VectorFloatAttribute {
 	using HepMC3::VectorFloatAttribute::VectorFloatAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorFloatAttribute *>(this), "from_string");
 		if (overload) {
@@ -316,15 +316,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorLongDoubleAttribute file:HepMC3/Attribute.h line:773
+// HepMC3::VectorLongDoubleAttribute file:HepMC3/Attribute.h line:774
 struct PyCallBack_HepMC3_VectorLongDoubleAttribute : public HepMC3::VectorLongDoubleAttribute {
 	using HepMC3::VectorLongDoubleAttribute::VectorLongDoubleAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorLongDoubleAttribute *>(this), "from_string");
 		if (overload) {
@@ -374,15 +374,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorLongLongAttribute file:HepMC3/Attribute.h line:820
+// HepMC3::VectorLongLongAttribute file:HepMC3/Attribute.h line:821
 struct PyCallBack_HepMC3_VectorLongLongAttribute : public HepMC3::VectorLongLongAttribute {
 	using HepMC3::VectorLongLongAttribute::VectorLongLongAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorLongLongAttribute *>(this), "from_string");
 		if (overload) {
@@ -432,15 +432,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorUIntAttribute file:HepMC3/Attribute.h line:865
+// HepMC3::VectorUIntAttribute file:HepMC3/Attribute.h line:866
 struct PyCallBack_HepMC3_VectorUIntAttribute : public HepMC3::VectorUIntAttribute {
 	using HepMC3::VectorUIntAttribute::VectorUIntAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorUIntAttribute *>(this), "from_string");
 		if (overload) {
@@ -490,15 +490,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorULongAttribute file:HepMC3/Attribute.h line:910
+// HepMC3::VectorULongAttribute file:HepMC3/Attribute.h line:911
 struct PyCallBack_HepMC3_VectorULongAttribute : public HepMC3::VectorULongAttribute {
 	using HepMC3::VectorULongAttribute::VectorULongAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorULongAttribute *>(this), "from_string");
 		if (overload) {
@@ -576,94 +576,94 @@
 		cl.def( pybind11::init( [](HepMC3::ULongLongAttribute const &o){ return new HepMC3::ULongLongAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::ULongLongAttribute::*)(const std::string &)) &HepMC3::ULongLongAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::ULongLongAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::ULongLongAttribute::*)(std::string &) const) &HepMC3::ULongLongAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::ULongLongAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (unsigned long long (HepMC3::ULongLongAttribute::*)() const) &HepMC3::ULongLongAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::ULongLongAttribute::value() const --> unsigned long long");
 		cl.def("set_value", (void (HepMC3::ULongLongAttribute::*)(const unsigned long long &)) &HepMC3::ULongLongAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::ULongLongAttribute::set_value(const unsigned long long &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::ULongLongAttribute & (HepMC3::ULongLongAttribute::*)(const class HepMC3::ULongLongAttribute &)) &HepMC3::ULongLongAttribute::operator=, "C++: HepMC3::ULongLongAttribute::operator=(const class HepMC3::ULongLongAttribute &) --> class HepMC3::ULongLongAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::BoolAttribute file:HepMC3/Attribute.h line:639
+	{ // HepMC3::BoolAttribute file:HepMC3/Attribute.h line:640
 		pybind11::class_<HepMC3::BoolAttribute, std::shared_ptr<HepMC3::BoolAttribute>, PyCallBack_HepMC3_BoolAttribute, HepMC3::Attribute> cl(M("HepMC3"), "BoolAttribute", "Attribute that holds an Booleger implemented as an int\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::BoolAttribute(); }, [](){ return new PyCallBack_HepMC3_BoolAttribute(); } ) );
 		cl.def( pybind11::init<bool>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_BoolAttribute const &o){ return new PyCallBack_HepMC3_BoolAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::BoolAttribute const &o){ return new HepMC3::BoolAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::BoolAttribute::*)(const std::string &)) &HepMC3::BoolAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::BoolAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::BoolAttribute::*)(std::string &) const) &HepMC3::BoolAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::BoolAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (bool (HepMC3::BoolAttribute::*)() const) &HepMC3::BoolAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::BoolAttribute::value() const --> bool");
 		cl.def("set_value", (void (HepMC3::BoolAttribute::*)(const bool &)) &HepMC3::BoolAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::BoolAttribute::set_value(const bool &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::BoolAttribute & (HepMC3::BoolAttribute::*)(const class HepMC3::BoolAttribute &)) &HepMC3::BoolAttribute::operator=, "C++: HepMC3::BoolAttribute::operator=(const class HepMC3::BoolAttribute &) --> class HepMC3::BoolAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorCharAttribute file:HepMC3/Attribute.h line:682
-		pybind11::class_<HepMC3::VectorCharAttribute, std::shared_ptr<HepMC3::VectorCharAttribute>, PyCallBack_HepMC3_VectorCharAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorCharAttribute", "Attribute that holds a vector of charegers of type  char\n\n  \n\n ");
+	{ // HepMC3::VectorCharAttribute file:HepMC3/Attribute.h line:683
+		pybind11::class_<HepMC3::VectorCharAttribute, std::shared_ptr<HepMC3::VectorCharAttribute>, PyCallBack_HepMC3_VectorCharAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorCharAttribute", "Attribute that holds a vector of characters of type  char\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorCharAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorCharAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<char>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorCharAttribute const &o){ return new PyCallBack_HepMC3_VectorCharAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorCharAttribute const &o){ return new HepMC3::VectorCharAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorCharAttribute::*)(const std::string &)) &HepMC3::VectorCharAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorCharAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorCharAttribute::*)(std::string &) const) &HepMC3::VectorCharAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorCharAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<char> (HepMC3::VectorCharAttribute::*)() const) &HepMC3::VectorCharAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorCharAttribute::value() const --> class std::vector<char>");
 		cl.def("set_value", (void (HepMC3::VectorCharAttribute::*)(const class std::vector<char> &)) &HepMC3::VectorCharAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorCharAttribute::set_value(const class std::vector<char> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorCharAttribute & (HepMC3::VectorCharAttribute::*)(const class HepMC3::VectorCharAttribute &)) &HepMC3::VectorCharAttribute::operator=, "C++: HepMC3::VectorCharAttribute::operator=(const class HepMC3::VectorCharAttribute &) --> class HepMC3::VectorCharAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorFloatAttribute file:HepMC3/Attribute.h line:727
-		pybind11::class_<HepMC3::VectorFloatAttribute, std::shared_ptr<HepMC3::VectorFloatAttribute>, PyCallBack_HepMC3_VectorFloatAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorFloatAttribute", "Attribute that holds a vector of floategers of type  float\n\n  \n\n ");
+	{ // HepMC3::VectorFloatAttribute file:HepMC3/Attribute.h line:728
+		pybind11::class_<HepMC3::VectorFloatAttribute, std::shared_ptr<HepMC3::VectorFloatAttribute>, PyCallBack_HepMC3_VectorFloatAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorFloatAttribute", "Attribute that holds a vector of real numbers of type float\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorFloatAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorFloatAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<float>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorFloatAttribute const &o){ return new PyCallBack_HepMC3_VectorFloatAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorFloatAttribute const &o){ return new HepMC3::VectorFloatAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorFloatAttribute::*)(const std::string &)) &HepMC3::VectorFloatAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorFloatAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorFloatAttribute::*)(std::string &) const) &HepMC3::VectorFloatAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorFloatAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<float> (HepMC3::VectorFloatAttribute::*)() const) &HepMC3::VectorFloatAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorFloatAttribute::value() const --> class std::vector<float>");
 		cl.def("set_value", (void (HepMC3::VectorFloatAttribute::*)(const class std::vector<float> &)) &HepMC3::VectorFloatAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorFloatAttribute::set_value(const class std::vector<float> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorFloatAttribute & (HepMC3::VectorFloatAttribute::*)(const class HepMC3::VectorFloatAttribute &)) &HepMC3::VectorFloatAttribute::operator=, "C++: HepMC3::VectorFloatAttribute::operator=(const class HepMC3::VectorFloatAttribute &) --> class HepMC3::VectorFloatAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorLongDoubleAttribute file:HepMC3/Attribute.h line:773
-		pybind11::class_<HepMC3::VectorLongDoubleAttribute, std::shared_ptr<HepMC3::VectorLongDoubleAttribute>, PyCallBack_HepMC3_VectorLongDoubleAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorLongDoubleAttribute", "Attribute that holds a vector of long doubleegers of type  long double\n\n  \n\n ");
+	{ // HepMC3::VectorLongDoubleAttribute file:HepMC3/Attribute.h line:774
+		pybind11::class_<HepMC3::VectorLongDoubleAttribute, std::shared_ptr<HepMC3::VectorLongDoubleAttribute>, PyCallBack_HepMC3_VectorLongDoubleAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorLongDoubleAttribute", "Attribute that holds a vector of real numbers of type long double\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorLongDoubleAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorLongDoubleAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<long double>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorLongDoubleAttribute const &o){ return new PyCallBack_HepMC3_VectorLongDoubleAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorLongDoubleAttribute const &o){ return new HepMC3::VectorLongDoubleAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorLongDoubleAttribute::*)(const std::string &)) &HepMC3::VectorLongDoubleAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorLongDoubleAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorLongDoubleAttribute::*)(std::string &) const) &HepMC3::VectorLongDoubleAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorLongDoubleAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<long double> (HepMC3::VectorLongDoubleAttribute::*)() const) &HepMC3::VectorLongDoubleAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorLongDoubleAttribute::value() const --> class std::vector<long double>");
 		cl.def("set_value", (void (HepMC3::VectorLongDoubleAttribute::*)(const class std::vector<long double> &)) &HepMC3::VectorLongDoubleAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorLongDoubleAttribute::set_value(const class std::vector<long double> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorLongDoubleAttribute & (HepMC3::VectorLongDoubleAttribute::*)(const class HepMC3::VectorLongDoubleAttribute &)) &HepMC3::VectorLongDoubleAttribute::operator=, "C++: HepMC3::VectorLongDoubleAttribute::operator=(const class HepMC3::VectorLongDoubleAttribute &) --> class HepMC3::VectorLongDoubleAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorLongLongAttribute file:HepMC3/Attribute.h line:820
-		pybind11::class_<HepMC3::VectorLongLongAttribute, std::shared_ptr<HepMC3::VectorLongLongAttribute>, PyCallBack_HepMC3_VectorLongLongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorLongLongAttribute", "Attribute that holds a vector of long longegers of type  long long\n\n  \n\n ");
+	{ // HepMC3::VectorLongLongAttribute file:HepMC3/Attribute.h line:821
+		pybind11::class_<HepMC3::VectorLongLongAttribute, std::shared_ptr<HepMC3::VectorLongLongAttribute>, PyCallBack_HepMC3_VectorLongLongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorLongLongAttribute", "Attribute that holds a vector of integers of type  long long\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorLongLongAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorLongLongAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<long long>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorLongLongAttribute const &o){ return new PyCallBack_HepMC3_VectorLongLongAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorLongLongAttribute const &o){ return new HepMC3::VectorLongLongAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorLongLongAttribute::*)(const std::string &)) &HepMC3::VectorLongLongAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorLongLongAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorLongLongAttribute::*)(std::string &) const) &HepMC3::VectorLongLongAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorLongLongAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<long long> (HepMC3::VectorLongLongAttribute::*)() const) &HepMC3::VectorLongLongAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorLongLongAttribute::value() const --> class std::vector<long long>");
 		cl.def("set_value", (void (HepMC3::VectorLongLongAttribute::*)(const class std::vector<long long> &)) &HepMC3::VectorLongLongAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorLongLongAttribute::set_value(const class std::vector<long long> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorLongLongAttribute & (HepMC3::VectorLongLongAttribute::*)(const class HepMC3::VectorLongLongAttribute &)) &HepMC3::VectorLongLongAttribute::operator=, "C++: HepMC3::VectorLongLongAttribute::operator=(const class HepMC3::VectorLongLongAttribute &) --> class HepMC3::VectorLongLongAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorUIntAttribute file:HepMC3/Attribute.h line:865
+	{ // HepMC3::VectorUIntAttribute file:HepMC3/Attribute.h line:866
 		pybind11::class_<HepMC3::VectorUIntAttribute, std::shared_ptr<HepMC3::VectorUIntAttribute>, PyCallBack_HepMC3_VectorUIntAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorUIntAttribute", "Attribute that holds a vector of unsigned integers of type  unsigned int\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorUIntAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorUIntAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<unsigned int>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorUIntAttribute const &o){ return new PyCallBack_HepMC3_VectorUIntAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorUIntAttribute const &o){ return new HepMC3::VectorUIntAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorUIntAttribute::*)(const std::string &)) &HepMC3::VectorUIntAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorUIntAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorUIntAttribute::*)(std::string &) const) &HepMC3::VectorUIntAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorUIntAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<unsigned int> (HepMC3::VectorUIntAttribute::*)() const) &HepMC3::VectorUIntAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorUIntAttribute::value() const --> class std::vector<unsigned int>");
 		cl.def("set_value", (void (HepMC3::VectorUIntAttribute::*)(const class std::vector<unsigned int> &)) &HepMC3::VectorUIntAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorUIntAttribute::set_value(const class std::vector<unsigned int> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorUIntAttribute & (HepMC3::VectorUIntAttribute::*)(const class HepMC3::VectorUIntAttribute &)) &HepMC3::VectorUIntAttribute::operator=, "C++: HepMC3::VectorUIntAttribute::operator=(const class HepMC3::VectorUIntAttribute &) --> class HepMC3::VectorUIntAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorULongAttribute file:HepMC3/Attribute.h line:910
-		pybind11::class_<HepMC3::VectorULongAttribute, std::shared_ptr<HepMC3::VectorULongAttribute>, PyCallBack_HepMC3_VectorULongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorULongAttribute", "Attribute that holds a vector of unsigned longegers of type  unsigned long\n\n  \n\n ");
+	{ // HepMC3::VectorULongAttribute file:HepMC3/Attribute.h line:911
+		pybind11::class_<HepMC3::VectorULongAttribute, std::shared_ptr<HepMC3::VectorULongAttribute>, PyCallBack_HepMC3_VectorULongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorULongAttribute", "Attribute that holds a vector of unsigned integers of type  unsigned long\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorULongAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorULongAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<unsigned long>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorULongAttribute const &o){ return new PyCallBack_HepMC3_VectorULongAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorULongAttribute const &o){ return new HepMC3::VectorULongAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorULongAttribute::*)(const std::string &)) &HepMC3::VectorULongAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorULongAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorULongAttribute::*)(std::string &) const) &HepMC3::VectorULongAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorULongAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_6.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_6.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -26,15 +26,15 @@
 #ifndef BINDER_PYBIND11_TYPE_CASTER
 	#define BINDER_PYBIND11_TYPE_CASTER
 	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
 	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
 	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
 #endif
 
-// HepMC3::VectorULongLongAttribute file:HepMC3/Attribute.h line:956
+// HepMC3::VectorULongLongAttribute file:HepMC3/Attribute.h line:957
 struct PyCallBack_HepMC3_VectorULongLongAttribute : public HepMC3::VectorULongLongAttribute {
 	using HepMC3::VectorULongLongAttribute::VectorULongLongAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorULongLongAttribute *>(this), "from_string");
 		if (overload) {
@@ -84,15 +84,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorIntAttribute file:HepMC3/Attribute.h line:1001
+// HepMC3::VectorIntAttribute file:HepMC3/Attribute.h line:1002
 struct PyCallBack_HepMC3_VectorIntAttribute : public HepMC3::VectorIntAttribute {
 	using HepMC3::VectorIntAttribute::VectorIntAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorIntAttribute *>(this), "from_string");
 		if (overload) {
@@ -142,15 +142,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorLongIntAttribute file:HepMC3/Attribute.h line:1046
+// HepMC3::VectorLongIntAttribute file:HepMC3/Attribute.h line:1047
 struct PyCallBack_HepMC3_VectorLongIntAttribute : public HepMC3::VectorLongIntAttribute {
 	using HepMC3::VectorLongIntAttribute::VectorLongIntAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorLongIntAttribute *>(this), "from_string");
 		if (overload) {
@@ -200,15 +200,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorDoubleAttribute file:HepMC3/Attribute.h line:1091
+// HepMC3::VectorDoubleAttribute file:HepMC3/Attribute.h line:1092
 struct PyCallBack_HepMC3_VectorDoubleAttribute : public HepMC3::VectorDoubleAttribute {
 	using HepMC3::VectorDoubleAttribute::VectorDoubleAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorDoubleAttribute *>(this), "from_string");
 		if (overload) {
@@ -258,15 +258,15 @@
 			}
 			else return pybind11::detail::cast_safe<bool>(std::move(o));
 		}
 		return Attribute::init(a0);
 	}
 };
 
-// HepMC3::VectorStringAttribute file:HepMC3/Attribute.h line:1137
+// HepMC3::VectorStringAttribute file:HepMC3/Attribute.h line:1138
 struct PyCallBack_HepMC3_VectorStringAttribute : public HepMC3::VectorStringAttribute {
 	using HepMC3::VectorStringAttribute::VectorStringAttribute;
 
 	bool from_string(const std::string & a0) override {
 		pybind11::gil_scoped_acquire gil;
 		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::VectorStringAttribute *>(this), "from_string");
 		if (overload) {
@@ -376,68 +376,68 @@
 		}
 		return Attribute::init(a0);
 	}
 };
 
 void bind_pyHepMC3_6(std::function< pybind11::module &(std::string const &namespace_) > &M)
 {
-	{ // HepMC3::VectorULongLongAttribute file:HepMC3/Attribute.h line:956
-		pybind11::class_<HepMC3::VectorULongLongAttribute, std::shared_ptr<HepMC3::VectorULongLongAttribute>, PyCallBack_HepMC3_VectorULongLongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorULongLongAttribute", "Attribute that holds a vector of unsigned long longegers of type  unsigned long long\n\n  \n\n ");
+	{ // HepMC3::VectorULongLongAttribute file:HepMC3/Attribute.h line:957
+		pybind11::class_<HepMC3::VectorULongLongAttribute, std::shared_ptr<HepMC3::VectorULongLongAttribute>, PyCallBack_HepMC3_VectorULongLongAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorULongLongAttribute", "Attribute that holds a vector of integers of type  unsigned long long\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorULongLongAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorULongLongAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<unsigned long long>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorULongLongAttribute const &o){ return new PyCallBack_HepMC3_VectorULongLongAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorULongLongAttribute const &o){ return new HepMC3::VectorULongLongAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorULongLongAttribute::*)(const std::string &)) &HepMC3::VectorULongLongAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorULongLongAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorULongLongAttribute::*)(std::string &) const) &HepMC3::VectorULongLongAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorULongLongAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<unsigned long long> (HepMC3::VectorULongLongAttribute::*)() const) &HepMC3::VectorULongLongAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorULongLongAttribute::value() const --> class std::vector<unsigned long long>");
 		cl.def("set_value", (void (HepMC3::VectorULongLongAttribute::*)(const class std::vector<unsigned long long> &)) &HepMC3::VectorULongLongAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorULongLongAttribute::set_value(const class std::vector<unsigned long long> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorULongLongAttribute & (HepMC3::VectorULongLongAttribute::*)(const class HepMC3::VectorULongLongAttribute &)) &HepMC3::VectorULongLongAttribute::operator=, "C++: HepMC3::VectorULongLongAttribute::operator=(const class HepMC3::VectorULongLongAttribute &) --> class HepMC3::VectorULongLongAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorIntAttribute file:HepMC3/Attribute.h line:1001
+	{ // HepMC3::VectorIntAttribute file:HepMC3/Attribute.h line:1002
 		pybind11::class_<HepMC3::VectorIntAttribute, std::shared_ptr<HepMC3::VectorIntAttribute>, PyCallBack_HepMC3_VectorIntAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorIntAttribute", "Attribute that holds a vector of integers of type  int\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorIntAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorIntAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<int>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorIntAttribute const &o){ return new PyCallBack_HepMC3_VectorIntAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorIntAttribute const &o){ return new HepMC3::VectorIntAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorIntAttribute::*)(const std::string &)) &HepMC3::VectorIntAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorIntAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorIntAttribute::*)(std::string &) const) &HepMC3::VectorIntAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorIntAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<int> (HepMC3::VectorIntAttribute::*)() const) &HepMC3::VectorIntAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorIntAttribute::value() const --> class std::vector<int>");
 		cl.def("set_value", (void (HepMC3::VectorIntAttribute::*)(const class std::vector<int> &)) &HepMC3::VectorIntAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorIntAttribute::set_value(const class std::vector<int> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorIntAttribute & (HepMC3::VectorIntAttribute::*)(const class HepMC3::VectorIntAttribute &)) &HepMC3::VectorIntAttribute::operator=, "C++: HepMC3::VectorIntAttribute::operator=(const class HepMC3::VectorIntAttribute &) --> class HepMC3::VectorIntAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorLongIntAttribute file:HepMC3/Attribute.h line:1046
-		pybind11::class_<HepMC3::VectorLongIntAttribute, std::shared_ptr<HepMC3::VectorLongIntAttribute>, PyCallBack_HepMC3_VectorLongIntAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorLongIntAttribute", "Attribute that holds a vector of integers of type  int\n\n  \n\n ");
+	{ // HepMC3::VectorLongIntAttribute file:HepMC3/Attribute.h line:1047
+		pybind11::class_<HepMC3::VectorLongIntAttribute, std::shared_ptr<HepMC3::VectorLongIntAttribute>, PyCallBack_HepMC3_VectorLongIntAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorLongIntAttribute", "Attribute that holds a vector of integers of type long int\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorLongIntAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorLongIntAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<long>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorLongIntAttribute const &o){ return new PyCallBack_HepMC3_VectorLongIntAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorLongIntAttribute const &o){ return new HepMC3::VectorLongIntAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorLongIntAttribute::*)(const std::string &)) &HepMC3::VectorLongIntAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorLongIntAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorLongIntAttribute::*)(std::string &) const) &HepMC3::VectorLongIntAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorLongIntAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<long> (HepMC3::VectorLongIntAttribute::*)() const) &HepMC3::VectorLongIntAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorLongIntAttribute::value() const --> class std::vector<long>");
 		cl.def("set_value", (void (HepMC3::VectorLongIntAttribute::*)(const class std::vector<long> &)) &HepMC3::VectorLongIntAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorLongIntAttribute::set_value(const class std::vector<long> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorLongIntAttribute & (HepMC3::VectorLongIntAttribute::*)(const class HepMC3::VectorLongIntAttribute &)) &HepMC3::VectorLongIntAttribute::operator=, "C++: HepMC3::VectorLongIntAttribute::operator=(const class HepMC3::VectorLongIntAttribute &) --> class HepMC3::VectorLongIntAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorDoubleAttribute file:HepMC3/Attribute.h line:1091
-		pybind11::class_<HepMC3::VectorDoubleAttribute, std::shared_ptr<HepMC3::VectorDoubleAttribute>, PyCallBack_HepMC3_VectorDoubleAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorDoubleAttribute", "Attribute that holds a vector of FPs of type  double\n\n  \n\n ");
+	{ // HepMC3::VectorDoubleAttribute file:HepMC3/Attribute.h line:1092
+		pybind11::class_<HepMC3::VectorDoubleAttribute, std::shared_ptr<HepMC3::VectorDoubleAttribute>, PyCallBack_HepMC3_VectorDoubleAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorDoubleAttribute", "Attribute that holds a vector of real numbers of type  double\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorDoubleAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorDoubleAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<double>>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorDoubleAttribute const &o){ return new PyCallBack_HepMC3_VectorDoubleAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorDoubleAttribute const &o){ return new HepMC3::VectorDoubleAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorDoubleAttribute::*)(const std::string &)) &HepMC3::VectorDoubleAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorDoubleAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorDoubleAttribute::*)(std::string &) const) &HepMC3::VectorDoubleAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorDoubleAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("value", (class std::vector<double> (HepMC3::VectorDoubleAttribute::*)() const) &HepMC3::VectorDoubleAttribute::value, "get the value associated to this Attribute. \n\nC++: HepMC3::VectorDoubleAttribute::value() const --> class std::vector<double>");
 		cl.def("set_value", (void (HepMC3::VectorDoubleAttribute::*)(const class std::vector<double> &)) &HepMC3::VectorDoubleAttribute::set_value, "set the value associated to this Attribute. \n\nC++: HepMC3::VectorDoubleAttribute::set_value(const class std::vector<double> &) --> void", pybind11::arg("i"));
 		cl.def("assign", (class HepMC3::VectorDoubleAttribute & (HepMC3::VectorDoubleAttribute::*)(const class HepMC3::VectorDoubleAttribute &)) &HepMC3::VectorDoubleAttribute::operator=, "C++: HepMC3::VectorDoubleAttribute::operator=(const class HepMC3::VectorDoubleAttribute &) --> class HepMC3::VectorDoubleAttribute &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::VectorStringAttribute file:HepMC3/Attribute.h line:1137
-		pybind11::class_<HepMC3::VectorStringAttribute, std::shared_ptr<HepMC3::VectorStringAttribute>, PyCallBack_HepMC3_VectorStringAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorStringAttribute", "Attribute that holds a vector of FPs of type  string\n\n  \n\n ");
+	{ // HepMC3::VectorStringAttribute file:HepMC3/Attribute.h line:1138
+		pybind11::class_<HepMC3::VectorStringAttribute, std::shared_ptr<HepMC3::VectorStringAttribute>, PyCallBack_HepMC3_VectorStringAttribute, HepMC3::Attribute> cl(M("HepMC3"), "VectorStringAttribute", "Attribute that holds a vector of type  string\n\n  \n\n ");
 		cl.def( pybind11::init( [](){ return new HepMC3::VectorStringAttribute(); }, [](){ return new PyCallBack_HepMC3_VectorStringAttribute(); } ) );
 		cl.def( pybind11::init<class std::vector<std::string >>(), pybind11::arg("val") );
 
 		cl.def( pybind11::init( [](PyCallBack_HepMC3_VectorStringAttribute const &o){ return new PyCallBack_HepMC3_VectorStringAttribute(o); } ) );
 		cl.def( pybind11::init( [](HepMC3::VectorStringAttribute const &o){ return new HepMC3::VectorStringAttribute(o); } ) );
 		cl.def("from_string", (bool (HepMC3::VectorStringAttribute::*)(const std::string &)) &HepMC3::VectorStringAttribute::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::VectorStringAttribute::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::VectorStringAttribute::*)(std::string &) const) &HepMC3::VectorStringAttribute::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::VectorStringAttribute::to_string(std::string &) const --> bool", pybind11::arg("att"));
@@ -481,12 +481,12 @@
 		cl.def("set", [](HepMC3::GenHeavyIon &o, const int & a0, const int & a1, const int & a2, const int & a3, const int & a4, const int & a5, const int & a6, const int & a7) -> void { return o.set(a0, a1, a2, a3, a4, a5, a6, a7); }, "", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"));
 		cl.def("set", [](HepMC3::GenHeavyIon &o, const int & a0, const int & a1, const int & a2, const int & a3, const int & a4, const int & a5, const int & a6, const int & a7, const int & a8) -> void { return o.set(a0, a1, a2, a3, a4, a5, a6, a7, a8); }, "", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"));
 		cl.def("set", [](HepMC3::GenHeavyIon &o, const int & a0, const int & a1, const int & a2, const int & a3, const int & a4, const int & a5, const int & a6, const int & a7, const int & a8, const double & a9) -> void { return o.set(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }, "", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"), pybind11::arg("im"));
 		cl.def("set", [](HepMC3::GenHeavyIon &o, const int & a0, const int & a1, const int & a2, const int & a3, const int & a4, const int & a5, const int & a6, const int & a7, const int & a8, const double & a9, const double & a10) -> void { return o.set(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); }, "", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"), pybind11::arg("im"), pybind11::arg("pl"));
 		cl.def("set", [](HepMC3::GenHeavyIon &o, const int & a0, const int & a1, const int & a2, const int & a3, const int & a4, const int & a5, const int & a6, const int & a7, const int & a8, const double & a9, const double & a10, const double & a11) -> void { return o.set(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); }, "", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"), pybind11::arg("im"), pybind11::arg("pl"), pybind11::arg("ec"));
 		cl.def("set", [](HepMC3::GenHeavyIon &o, const int & a0, const int & a1, const int & a2, const int & a3, const int & a4, const int & a5, const int & a6, const int & a7, const int & a8, const double & a9, const double & a10, const double & a11, const double & a12) -> void { return o.set(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); }, "", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"), pybind11::arg("im"), pybind11::arg("pl"), pybind11::arg("ec"), pybind11::arg("s"));
 		cl.def("set", [](HepMC3::GenHeavyIon &o, const int & a0, const int & a1, const int & a2, const int & a3, const int & a4, const int & a5, const int & a6, const int & a7, const int & a8, const double & a9, const double & a10, const double & a11, const double & a12, const double & a13) -> void { return o.set(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); }, "", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"), pybind11::arg("im"), pybind11::arg("pl"), pybind11::arg("ec"), pybind11::arg("s"), pybind11::arg("cent"));
-		cl.def("set", (void (HepMC3::GenHeavyIon::*)(const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const double &, const double &, const double &, const double &, const double &, const double &)) &HepMC3::GenHeavyIon::set, "Set all fields.\n\n HEPMC3_DEPRECATED(\"Set individual fields directly instead.\")\n \n\n Set all fields \n\nC++: HepMC3::GenHeavyIon::set(const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const double &, const double &, const double &, const double &, const double &, const double &) --> void", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"), pybind11::arg("im"), pybind11::arg("pl"), pybind11::arg("ec"), pybind11::arg("s"), pybind11::arg("cent"), pybind11::arg("ucent"));
+		cl.def("set", (void (HepMC3::GenHeavyIon::*)(const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const double &, const double &, const double &, const double &, const double &, const double &)) &HepMC3::GenHeavyIon::set, "Set all fields.\n\n HEPMC3_DEPRECATED(\"Set individual fields directly instead.\")\n \n\n Set all fields \n\nC++: HepMC3::GenHeavyIon::set(const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const int &, const double &, const double &, const double &, const double &, const double &, const double &) --> void", pybind11::arg("nh"), pybind11::arg("np"), pybind11::arg("nt"), pybind11::arg("nc"), pybind11::arg("ns"), pybind11::arg("nsp"), pybind11::arg("nnw"), pybind11::arg("nwn"), pybind11::arg("nwnw"), pybind11::arg("im"), pybind11::arg("pl"), pybind11::arg("ec"), pybind11::arg("s"), pybind11::arg("cent"), pybind11::arg("usrcent"));
 		cl.def("is_valid", (bool (HepMC3::GenHeavyIon::*)() const) &HepMC3::GenHeavyIon::is_valid, "Verify that the instance contains non-zero information.\n\n HEPMC3_DEPRECATED(\"Each filed now have default values meaning\n that they have not been set\")\n\nC++: HepMC3::GenHeavyIon::is_valid() const --> bool");
 		cl.def("assign", (class HepMC3::GenHeavyIon & (HepMC3::GenHeavyIon::*)(const class HepMC3::GenHeavyIon &)) &HepMC3::GenHeavyIon::operator=, "C++: HepMC3::GenHeavyIon::operator=(const class HepMC3::GenHeavyIon &) --> class HepMC3::GenHeavyIon &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 }
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_7.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_7.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -96,28 +96,33 @@
 		cl.def( pybind11::init( [](HepMC3::GenCrossSection const &o){ return new HepMC3::GenCrossSection(o); } ) );
 		cl.def( pybind11::init( [](){ return new HepMC3::GenCrossSection(); }, [](){ return new PyCallBack_HepMC3_GenCrossSection(); } ) );
 		cl.def("from_string", (bool (HepMC3::GenCrossSection::*)(const std::string &)) &HepMC3::GenCrossSection::from_string, "Implementation of Attribute::from_string \n\nC++: HepMC3::GenCrossSection::from_string(const std::string &) --> bool", pybind11::arg("att"));
 		cl.def("to_string", (bool (HepMC3::GenCrossSection::*)(std::string &) const) &HepMC3::GenCrossSection::to_string, "Implementation of Attribute::to_string \n\nC++: HepMC3::GenCrossSection::to_string(std::string &) const --> bool", pybind11::arg("att"));
 		cl.def("set_cross_section", [](HepMC3::GenCrossSection &o, const double & a0, const double & a1) -> void { return o.set_cross_section(a0, a1); }, "", pybind11::arg("xs"), pybind11::arg("xs_err"));
 		cl.def("set_cross_section", [](HepMC3::GenCrossSection &o, const double & a0, const double & a1, const long & a2) -> void { return o.set_cross_section(a0, a1, a2); }, "", pybind11::arg("xs"), pybind11::arg("xs_err"), pybind11::arg("n_acc"));
 		cl.def("set_cross_section", (void (HepMC3::GenCrossSection::*)(const double &, const double &, const long &, const long &)) &HepMC3::GenCrossSection::set_cross_section, "Set all fields \n\nC++: HepMC3::GenCrossSection::set_cross_section(const double &, const double &, const long &, const long &) --> void", pybind11::arg("xs"), pybind11::arg("xs_err"), pybind11::arg("n_acc"), pybind11::arg("n_att"));
+		cl.def("set_cross_section", [](HepMC3::GenCrossSection &o, const class std::vector<double> & a0, const class std::vector<double> & a1) -> void { return o.set_cross_section(a0, a1); }, "", pybind11::arg("xs"), pybind11::arg("xs_err"));
+		cl.def("set_cross_section", [](HepMC3::GenCrossSection &o, const class std::vector<double> & a0, const class std::vector<double> & a1, const long & a2) -> void { return o.set_cross_section(a0, a1, a2); }, "", pybind11::arg("xs"), pybind11::arg("xs_err"), pybind11::arg("n_acc"));
+		cl.def("set_cross_section", (void (HepMC3::GenCrossSection::*)(const class std::vector<double> &, const class std::vector<double> &, const long &, const long &)) &HepMC3::GenCrossSection::set_cross_section, "Set all fields \n\nC++: HepMC3::GenCrossSection::set_cross_section(const class std::vector<double> &, const class std::vector<double> &, const long &, const long &) --> void", pybind11::arg("xs"), pybind11::arg("xs_err"), pybind11::arg("n_acc"), pybind11::arg("n_att"));
+		cl.def("xsecs", (const class std::vector<double> & (HepMC3::GenCrossSection::*)() const) &HepMC3::GenCrossSection::xsecs, "Get the cross-sections\n\nC++: HepMC3::GenCrossSection::xsecs() const --> const class std::vector<double> &", pybind11::return_value_policy::automatic);
+		cl.def("xsec_errs", (const class std::vector<double> & (HepMC3::GenCrossSection::*)() const) &HepMC3::GenCrossSection::xsec_errs, "Get the cross-section errors\n\nC++: HepMC3::GenCrossSection::xsec_errs() const --> const class std::vector<double> &", pybind11::return_value_policy::automatic);
 		cl.def("set_accepted_events", (void (HepMC3::GenCrossSection::*)(const long &)) &HepMC3::GenCrossSection::set_accepted_events, "Set the number of accepted events\n\nC++: HepMC3::GenCrossSection::set_accepted_events(const long &) --> void", pybind11::arg("n_acc"));
 		cl.def("set_attempted_events", (void (HepMC3::GenCrossSection::*)(const long &)) &HepMC3::GenCrossSection::set_attempted_events, "Set the number of attempted events\n\nC++: HepMC3::GenCrossSection::set_attempted_events(const long &) --> void", pybind11::arg("n_att"));
 		cl.def("get_accepted_events", (long (HepMC3::GenCrossSection::*)() const) &HepMC3::GenCrossSection::get_accepted_events, "Get the number of accepted events\n\nC++: HepMC3::GenCrossSection::get_accepted_events() const --> long");
 		cl.def("get_attempted_events", (long (HepMC3::GenCrossSection::*)() const) &HepMC3::GenCrossSection::get_attempted_events, "Get the number of attempted events\n\nC++: HepMC3::GenCrossSection::get_attempted_events() const --> long");
 		cl.def("set_xsec", (void (HepMC3::GenCrossSection::*)(const std::string &, const double &)) &HepMC3::GenCrossSection::set_xsec, "Set the cross section  corresponding to the weight\n        named \n     \n\nC++: HepMC3::GenCrossSection::set_xsec(const std::string &, const double &) --> void", pybind11::arg("wName"), pybind11::arg("xs"));
-		cl.def("set_xsec", (void (HepMC3::GenCrossSection::*)(const int &, const double &)) &HepMC3::GenCrossSection::set_xsec, "Set the cross section corresponding to the weight with\n        index \n     \n\nC++: HepMC3::GenCrossSection::set_xsec(const int &, const double &) --> void", pybind11::arg("indx"), pybind11::arg("xs"));
+		cl.def("set_xsec", (void (HepMC3::GenCrossSection::*)(const unsigned long &, const double &)) &HepMC3::GenCrossSection::set_xsec, "Set the cross section corresponding to the weight with\n        index \n     \n\nC++: HepMC3::GenCrossSection::set_xsec(const unsigned long &, const double &) --> void", pybind11::arg("index"), pybind11::arg("xs"));
 		cl.def("set_xsec_err", (void (HepMC3::GenCrossSection::*)(const std::string &, const double &)) &HepMC3::GenCrossSection::set_xsec_err, "Set the cross section error corresponding to the weight\n        named \n     \n\nC++: HepMC3::GenCrossSection::set_xsec_err(const std::string &, const double &) --> void", pybind11::arg("wName"), pybind11::arg("xs_err"));
-		cl.def("set_xsec_err", (void (HepMC3::GenCrossSection::*)(const int &, const double &)) &HepMC3::GenCrossSection::set_xsec_err, "Set the cross section error corresponding to the weight\n        with index \n     \n\nC++: HepMC3::GenCrossSection::set_xsec_err(const int &, const double &) --> void", pybind11::arg("indx"), pybind11::arg("xs_err"));
+		cl.def("set_xsec_err", (void (HepMC3::GenCrossSection::*)(const unsigned long &, const double &)) &HepMC3::GenCrossSection::set_xsec_err, "Set the cross section error corresponding to the weight\n        with index \n     \n\nC++: HepMC3::GenCrossSection::set_xsec_err(const unsigned long &, const double &) --> void", pybind11::arg("index"), pybind11::arg("xs_err"));
 		cl.def("xsec", (double (HepMC3::GenCrossSection::*)(const std::string &) const) &HepMC3::GenCrossSection::xsec, "Get the cross section corresponding to the weight named\n        \n     \n\nC++: HepMC3::GenCrossSection::xsec(const std::string &) const --> double", pybind11::arg("wName"));
 		cl.def("xsec", [](HepMC3::GenCrossSection const &o) -> double { return o.xsec(); }, "");
-		cl.def("xsec", (double (HepMC3::GenCrossSection::*)(const int &) const) &HepMC3::GenCrossSection::xsec, "Get the cross section corresponding to the weight with index\n        \n     \n\nC++: HepMC3::GenCrossSection::xsec(const int &) const --> double", pybind11::arg("indx"));
+		cl.def("xsec", (double (HepMC3::GenCrossSection::*)(const unsigned long &) const) &HepMC3::GenCrossSection::xsec, "Get the cross section corresponding to the weight with index\n        \n     \n\nC++: HepMC3::GenCrossSection::xsec(const unsigned long &) const --> double", pybind11::arg("index"));
 		cl.def("xsec_err", (double (HepMC3::GenCrossSection::*)(const std::string &) const) &HepMC3::GenCrossSection::xsec_err, "Get the cross section error corresponding to the weight\n        named \n     \n\nC++: HepMC3::GenCrossSection::xsec_err(const std::string &) const --> double", pybind11::arg("wName"));
 		cl.def("xsec_err", [](HepMC3::GenCrossSection const &o) -> double { return o.xsec_err(); }, "");
-		cl.def("xsec_err", (double (HepMC3::GenCrossSection::*)(const int &) const) &HepMC3::GenCrossSection::xsec_err, "Get the cross section error corresponding to the weight\n        with index \n     \n\nC++: HepMC3::GenCrossSection::xsec_err(const int &) const --> double", pybind11::arg("indx"));
+		cl.def("xsec_err", (double (HepMC3::GenCrossSection::*)(const unsigned long &) const) &HepMC3::GenCrossSection::xsec_err, "Get the cross section error corresponding to the weight\n        with index \n     \n\nC++: HepMC3::GenCrossSection::xsec_err(const unsigned long &) const --> double", pybind11::arg("index"));
 		cl.def("__eq__", (bool (HepMC3::GenCrossSection::*)(const class HepMC3::GenCrossSection &) const) &HepMC3::GenCrossSection::operator==, "C++: HepMC3::GenCrossSection::operator==(const class HepMC3::GenCrossSection &) const --> bool", pybind11::arg(""));
 		cl.def("__ne__", (bool (HepMC3::GenCrossSection::*)(const class HepMC3::GenCrossSection &) const) &HepMC3::GenCrossSection::operator!=, "C++: HepMC3::GenCrossSection::operator!=(const class HepMC3::GenCrossSection &) const --> bool", pybind11::arg(""));
 		cl.def("is_valid", (bool (HepMC3::GenCrossSection::*)() const) &HepMC3::GenCrossSection::is_valid, "C++: HepMC3::GenCrossSection::is_valid() const --> bool");
 		cl.def("assign", (class HepMC3::GenCrossSection & (HepMC3::GenCrossSection::*)(const class HepMC3::GenCrossSection &)) &HepMC3::GenCrossSection::operator=, "C++: HepMC3::GenCrossSection::operator=(const class HepMC3::GenCrossSection &) --> class HepMC3::GenCrossSection &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 	{ // HepMC3::Units file: line:26
 		pybind11::class_<HepMC3::Units, std::shared_ptr<HepMC3::Units>> cl(M("HepMC3"), "Units", "");
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_8.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_8.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -14,16 +14,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -157,29 +157,29 @@
 		cl.def("__ne__", (bool (HepMC3::GenPdfInfo::*)(const class HepMC3::GenPdfInfo &) const) &HepMC3::GenPdfInfo::operator!=, "C++: HepMC3::GenPdfInfo::operator!=(const class HepMC3::GenPdfInfo &) const --> bool", pybind11::arg(""));
 		cl.def("is_valid", (bool (HepMC3::GenPdfInfo::*)() const) &HepMC3::GenPdfInfo::is_valid, "C++: HepMC3::GenPdfInfo::is_valid() const --> bool");
 		cl.def("assign", (class HepMC3::GenPdfInfo & (HepMC3::GenPdfInfo::*)(const class HepMC3::GenPdfInfo &)) &HepMC3::GenPdfInfo::operator=, "C++: HepMC3::GenPdfInfo::operator=(const class HepMC3::GenPdfInfo &) --> class HepMC3::GenPdfInfo &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 	{ // HepMC3::GenEvent file:HepMC3/GenEvent.h line:41
 		pybind11::class_<HepMC3::GenEvent, std::shared_ptr<HepMC3::GenEvent>> cl(M("HepMC3"), "GenEvent", "Stores event-related information\n\n Manages event-related information.\n Contains lists of GenParticle and GenVertex objects");
 		cl.def( pybind11::init( [](){ return new HepMC3::GenEvent(); } ), "doc" );
-		cl.def( pybind11::init( [](enum HepMC3::Units::MomentumUnit const & a0){ return new HepMC3::GenEvent(a0); } ), "doc" , pybind11::arg("momentum_unit"));
-		cl.def( pybind11::init<enum HepMC3::Units::MomentumUnit, enum HepMC3::Units::LengthUnit>(), pybind11::arg("momentum_unit"), pybind11::arg("length_unit") );
+		cl.def( pybind11::init( [](enum HepMC3::Units::MomentumUnit const & a0){ return new HepMC3::GenEvent(a0); } ), "doc" , pybind11::arg("mu"));
+		cl.def( pybind11::init<enum HepMC3::Units::MomentumUnit, enum HepMC3::Units::LengthUnit>(), pybind11::arg("mu"), pybind11::arg("lu") );
 
 		cl.def( pybind11::init( [](class std::shared_ptr<class HepMC3::GenRunInfo> const & a0){ return new HepMC3::GenEvent(a0); } ), "doc" , pybind11::arg("run"));
-		cl.def( pybind11::init( [](class std::shared_ptr<class HepMC3::GenRunInfo> const & a0, enum HepMC3::Units::MomentumUnit const & a1){ return new HepMC3::GenEvent(a0, a1); } ), "doc" , pybind11::arg("run"), pybind11::arg("momentum_unit"));
-		cl.def( pybind11::init<class std::shared_ptr<class HepMC3::GenRunInfo>, enum HepMC3::Units::MomentumUnit, enum HepMC3::Units::LengthUnit>(), pybind11::arg("run"), pybind11::arg("momentum_unit"), pybind11::arg("length_unit") );
+		cl.def( pybind11::init( [](class std::shared_ptr<class HepMC3::GenRunInfo> const & a0, enum HepMC3::Units::MomentumUnit const & a1){ return new HepMC3::GenEvent(a0, a1); } ), "doc" , pybind11::arg("run"), pybind11::arg("mu"));
+		cl.def( pybind11::init<class std::shared_ptr<class HepMC3::GenRunInfo>, enum HepMC3::Units::MomentumUnit, enum HepMC3::Units::LengthUnit>(), pybind11::arg("run"), pybind11::arg("mu"), pybind11::arg("lu") );
 
 		cl.def( pybind11::init( [](HepMC3::GenEvent const &o){ return new HepMC3::GenEvent(o); } ) );
 		cl.def("assign", (class HepMC3::GenEvent & (HepMC3::GenEvent::*)(const class HepMC3::GenEvent &)) &HepMC3::GenEvent::operator=, "Assignment operator\n\nC++: HepMC3::GenEvent::operator=(const class HepMC3::GenEvent &) --> class HepMC3::GenEvent &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 		cl.def("particles", (const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > & (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::particles, "Get/set list of particles (non-const)\n\nC++: HepMC3::GenEvent::particles() --> const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > &", pybind11::return_value_policy::automatic);
 		cl.def("vertices", (const class std::vector<class std::shared_ptr<class HepMC3::GenVertex> > & (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::vertices, "Get/set list of vertices (non-const)\n\nC++: HepMC3::GenEvent::vertices() --> const class std::vector<class std::shared_ptr<class HepMC3::GenVertex> > &", pybind11::return_value_policy::automatic);
-		cl.def("particles_size", (int (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::particles_size, "Particles size, HepMC2 compatiility\n\nC++: HepMC3::GenEvent::particles_size() const --> int");
-		cl.def("particles_empty", (bool (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::particles_empty, "Particles empty, HepMC2 compatiility\n\nC++: HepMC3::GenEvent::particles_empty() const --> bool");
-		cl.def("vertices_size", (int (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::vertices_size, "Vertices size, HepMC2 compatiility\n\nC++: HepMC3::GenEvent::vertices_size() const --> int");
-		cl.def("vertices_empty", (bool (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::vertices_empty, "Vertices empty, HepMC2 compatiility\n\nC++: HepMC3::GenEvent::vertices_empty() const --> bool");
+		cl.def("particles_size", (int (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::particles_size, "@{\n Particles size, HepMC2 compatibility\n\nC++: HepMC3::GenEvent::particles_size() const --> int");
+		cl.def("particles_empty", (bool (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::particles_empty, "Particles empty, HepMC2 compatibility\n\nC++: HepMC3::GenEvent::particles_empty() const --> bool");
+		cl.def("vertices_size", (int (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::vertices_size, "Vertices size, HepMC2 compatibility\n\nC++: HepMC3::GenEvent::vertices_size() const --> int");
+		cl.def("vertices_empty", (bool (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::vertices_empty, "Vertices empty, HepMC2 compatibility\n\nC++: HepMC3::GenEvent::vertices_empty() const --> bool");
 		cl.def("weights", (class std::vector<double> & (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::weights, "Get event weights as a vector (non-const)\n\nC++: HepMC3::GenEvent::weights() --> class std::vector<double> &", pybind11::return_value_policy::automatic);
 		cl.def("weight", [](HepMC3::GenEvent const &o) -> double { return o.weight(); }, "");
 		cl.def("weight", (double (HepMC3::GenEvent::*)(const unsigned long &) const) &HepMC3::GenEvent::weight, "Get event weight accessed by index (or the canonical/first one if there is no argument)\n \n\n It's the user's responsibility to ensure that the given index exists!\n\nC++: HepMC3::GenEvent::weight(const unsigned long &) const --> double", pybind11::arg("index"));
 		cl.def("weight", (double & (HepMC3::GenEvent::*)(const std::string &)) &HepMC3::GenEvent::weight, "Get event weight accessed by weight name\n \n\n Requires there to be an attached GenRunInfo, otherwise will throw an exception\n \n\n It's the user's responsibility to ensure that the given name exists!\n\nC++: HepMC3::GenEvent::weight(const std::string &) --> double &", pybind11::return_value_policy::automatic, pybind11::arg("name"));
 		cl.def("weight_names", (const class std::vector<std::string > & (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::weight_names, "Get event weight names, if there are some\n \n\n Requires there to be an attached GenRunInfo with registered weight names, otherwise will throw an exception\n\nC++: HepMC3::GenEvent::weight_names() const --> const class std::vector<std::string > &", pybind11::return_value_policy::automatic);
 		cl.def("run_info", (class std::shared_ptr<class HepMC3::GenRunInfo> (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::run_info, "Get a pointer to the the GenRunInfo object.\n\nC++: HepMC3::GenEvent::run_info() const --> class std::shared_ptr<class HepMC3::GenRunInfo>");
 		cl.def("set_run_info", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenRunInfo>)) &HepMC3::GenEvent::set_run_info, "Set the GenRunInfo object by smart pointer.\n\nC++: HepMC3::GenEvent::set_run_info(class std::shared_ptr<class HepMC3::GenRunInfo>) --> void", pybind11::arg("run"));
@@ -191,40 +191,42 @@
 		cl.def("heavy_ion", (class std::shared_ptr<class HepMC3::GenHeavyIon> (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::heavy_ion, "Get heavy ion generator additional information\n\nC++: HepMC3::GenEvent::heavy_ion() --> class std::shared_ptr<class HepMC3::GenHeavyIon>");
 		cl.def("set_heavy_ion", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenHeavyIon>)) &HepMC3::GenEvent::set_heavy_ion, "Set heavy ion generator additional information\n\nC++: HepMC3::GenEvent::set_heavy_ion(class std::shared_ptr<class HepMC3::GenHeavyIon>) --> void", pybind11::arg("hi"));
 		cl.def("pdf_info", (class std::shared_ptr<class HepMC3::GenPdfInfo> (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::pdf_info, "Get PDF information\n\nC++: HepMC3::GenEvent::pdf_info() --> class std::shared_ptr<class HepMC3::GenPdfInfo>");
 		cl.def("set_pdf_info", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenPdfInfo>)) &HepMC3::GenEvent::set_pdf_info, "Set PDF information\n\nC++: HepMC3::GenEvent::set_pdf_info(class std::shared_ptr<class HepMC3::GenPdfInfo>) --> void", pybind11::arg("pi"));
 		cl.def("cross_section", (class std::shared_ptr<class HepMC3::GenCrossSection> (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::cross_section, "Get cross-section information\n\nC++: HepMC3::GenEvent::cross_section() --> class std::shared_ptr<class HepMC3::GenCrossSection>");
 		cl.def("set_cross_section", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenCrossSection>)) &HepMC3::GenEvent::set_cross_section, "Set cross-section information\n\nC++: HepMC3::GenEvent::set_cross_section(class std::shared_ptr<class HepMC3::GenCrossSection>) --> void", pybind11::arg("cs"));
 		cl.def("event_pos", (const class HepMC3::FourVector & (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::event_pos, "Vertex representing the overall event position\n\nC++: HepMC3::GenEvent::event_pos() const --> const class HepMC3::FourVector &", pybind11::return_value_policy::automatic);
+		cl.def("beams", [](HepMC3::GenEvent const &o) -> std::vector<class std::shared_ptr<const class HepMC3::GenParticle> > { return o.beams(); }, "");
+		cl.def("beams", (class std::vector<class std::shared_ptr<const class HepMC3::GenParticle> > (HepMC3::GenEvent::*)(const int) const) &HepMC3::GenEvent::beams, "Vector of beam particles\n\nC++: HepMC3::GenEvent::beams(const int) const --> class std::vector<class std::shared_ptr<const class HepMC3::GenParticle> >", pybind11::arg("status"));
 		cl.def("beams", (const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > & (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::beams, "Vector of beam particles\n\nC++: HepMC3::GenEvent::beams() --> const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > &", pybind11::return_value_policy::automatic);
 		cl.def("shift_position_by", (void (HepMC3::GenEvent::*)(const class HepMC3::FourVector &)) &HepMC3::GenEvent::shift_position_by, "Shift position of all vertices in the event by \n\nC++: HepMC3::GenEvent::shift_position_by(const class HepMC3::FourVector &) --> void", pybind11::arg("delta"));
 		cl.def("shift_position_to", (void (HepMC3::GenEvent::*)(const class HepMC3::FourVector &)) &HepMC3::GenEvent::shift_position_to, "Shift position of all vertices in the event to \n\nC++: HepMC3::GenEvent::shift_position_to(const class HepMC3::FourVector &) --> void", pybind11::arg("newpos"));
-		cl.def("boost", (bool (HepMC3::GenEvent::*)(const class HepMC3::FourVector &)) &HepMC3::GenEvent::boost, "Boost event using x,y,z components of  as velocities\n\nC++: HepMC3::GenEvent::boost(const class HepMC3::FourVector &) --> bool", pybind11::arg("v"));
-		cl.def("rotate", (bool (HepMC3::GenEvent::*)(const class HepMC3::FourVector &)) &HepMC3::GenEvent::rotate, "Rotate event using x,y,z components of  as rotation angles\n\nC++: HepMC3::GenEvent::rotate(const class HepMC3::FourVector &) --> bool", pybind11::arg("v"));
+		cl.def("boost", (bool (HepMC3::GenEvent::*)(const class HepMC3::FourVector &)) &HepMC3::GenEvent::boost, "Boost event using x,y,z components of  as velocities\n\nC++: HepMC3::GenEvent::boost(const class HepMC3::FourVector &) --> bool", pybind11::arg("delta"));
+		cl.def("rotate", (bool (HepMC3::GenEvent::*)(const class HepMC3::FourVector &)) &HepMC3::GenEvent::rotate, "Rotate event using x,y,z components of  as rotation angles\n\nC++: HepMC3::GenEvent::rotate(const class HepMC3::FourVector &) --> bool", pybind11::arg("delta"));
 		cl.def("reflect", (bool (HepMC3::GenEvent::*)(const int)) &HepMC3::GenEvent::reflect, "Change sign of \n\nC++: HepMC3::GenEvent::reflect(const int) --> bool", pybind11::arg("axis"));
 		cl.def("add_attribute", [](HepMC3::GenEvent &o, const std::string & a0, const class std::shared_ptr<class HepMC3::Attribute> & a1) -> void { return o.add_attribute(a0, a1); }, "", pybind11::arg("name"), pybind11::arg("att"));
 		cl.def("add_attribute", (void (HepMC3::GenEvent::*)(const std::string &, const class std::shared_ptr<class HepMC3::Attribute> &, const int &)) &HepMC3::GenEvent::add_attribute, "@{\n \n\n Add event attribute to event\n\n This will overwrite existing attribute if an attribute\n with the same name is present\n\nC++: HepMC3::GenEvent::add_attribute(const std::string &, const class std::shared_ptr<class HepMC3::Attribute> &, const int &) --> void", pybind11::arg("name"), pybind11::arg("att"), pybind11::arg("id"));
 		cl.def("remove_attribute", [](HepMC3::GenEvent &o, const std::string & a0) -> void { return o.remove_attribute(a0); }, "", pybind11::arg("name"));
 		cl.def("remove_attribute", (void (HepMC3::GenEvent::*)(const std::string &, const int &)) &HepMC3::GenEvent::remove_attribute, "Remove attribute\n\nC++: HepMC3::GenEvent::remove_attribute(const std::string &, const int &) --> void", pybind11::arg("name"), pybind11::arg("id"));
 		cl.def("attribute_as_string", [](HepMC3::GenEvent const &o, const std::string & a0) -> std::string { return o.attribute_as_string(a0); }, "", pybind11::arg("name"));
 		cl.def("attribute_as_string", (std::string (HepMC3::GenEvent::*)(const std::string &, const int &) const) &HepMC3::GenEvent::attribute_as_string, "Get attribute of any type as string\n\nC++: HepMC3::GenEvent::attribute_as_string(const std::string &, const int &) const --> std::string", pybind11::arg("name"), pybind11::arg("id"));
 		cl.def("attribute_names", [](HepMC3::GenEvent const &o) -> std::vector<std::string > { return o.attribute_names(); }, "");
 		cl.def("attribute_names", (class std::vector<std::string > (HepMC3::GenEvent::*)(const int &) const) &HepMC3::GenEvent::attribute_names, "Get list of attribute names\n\nC++: HepMC3::GenEvent::attribute_names(const int &) const --> class std::vector<std::string >", pybind11::arg("id"));
 		cl.def("attributes", (class std::map<std::string, class std::map<int, class std::shared_ptr<class HepMC3::Attribute> > > (HepMC3::GenEvent::*)() const) &HepMC3::GenEvent::attributes, "Get a copy of the list of attributes\n \n\n To avoid thread issues, this is returns a copy. Better solution may be needed.\n\nC++: HepMC3::GenEvent::attributes() const --> class std::map<std::string, class std::map<int, class std::shared_ptr<class HepMC3::Attribute> > >");
 		cl.def("add_particle", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenParticle>)) &HepMC3::GenEvent::add_particle, "Add particle\n\nC++: HepMC3::GenEvent::add_particle(class std::shared_ptr<class HepMC3::GenParticle>) --> void", pybind11::arg("p"));
 		cl.def("add_vertex", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenVertex>)) &HepMC3::GenEvent::add_vertex, "Add vertex\n\nC++: HepMC3::GenEvent::add_vertex(class std::shared_ptr<class HepMC3::GenVertex>) --> void", pybind11::arg("v"));
-		cl.def("remove_particle", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenParticle>)) &HepMC3::GenEvent::remove_particle, "Remove particle from the event\n\n This function  will remove whole sub-tree starting from this particle\n if it is the only incoming particle of this vertex.\n It will also production vertex of this particle if this vertex\n has no more outgoing particles\n\nC++: HepMC3::GenEvent::remove_particle(class std::shared_ptr<class HepMC3::GenParticle>) --> void", pybind11::arg("v"));
+		cl.def("remove_particle", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenParticle>)) &HepMC3::GenEvent::remove_particle, "Remove particle from the event\n\n This function  will remove whole sub-tree starting from this particle\n if it is the only incoming particle of this vertex.\n It will also production vertex of this particle if this vertex\n has no more outgoing particles\n\nC++: HepMC3::GenEvent::remove_particle(class std::shared_ptr<class HepMC3::GenParticle>) --> void", pybind11::arg("p"));
 		cl.def("remove_particles", (void (HepMC3::GenEvent::*)(class std::vector<class std::shared_ptr<class HepMC3::GenParticle> >)) &HepMC3::GenEvent::remove_particles, "Remove a set of particles\n\n This function follows rules of GenEvent::remove_particle to remove\n a list of particles from the event.\n\nC++: HepMC3::GenEvent::remove_particles(class std::vector<class std::shared_ptr<class HepMC3::GenParticle> >) --> void", pybind11::arg("v"));
 		cl.def("remove_vertex", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenVertex>)) &HepMC3::GenEvent::remove_vertex, "Remove vertex from the event\n\n This will remove all sub-trees of all outgoing particles of this vertex\n\nC++: HepMC3::GenEvent::remove_vertex(class std::shared_ptr<class HepMC3::GenVertex>) --> void", pybind11::arg("v"));
-		cl.def("add_tree", (void (HepMC3::GenEvent::*)(const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > &)) &HepMC3::GenEvent::add_tree, "Add whole tree in topological order\n\n This function will find the beam particles (particles\n that have no production vertices or their production vertices\n have no particles) and will add the whole decay tree starting from\n these particles.\n\n \n Any particles on this list that do not belong to the tree\n       will be ignored.\n\nC++: HepMC3::GenEvent::add_tree(const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > &) --> void", pybind11::arg("particles"));
-		cl.def("reserve", [](HepMC3::GenEvent &o, const unsigned long & a0) -> void { return o.reserve(a0); }, "", pybind11::arg("particles"));
-		cl.def("reserve", (void (HepMC3::GenEvent::*)(const unsigned long &, const unsigned long &)) &HepMC3::GenEvent::reserve, "Reserve memory for particles and vertices\n\n Helps optimize event creation when size of the event is known beforehand\n\nC++: HepMC3::GenEvent::reserve(const unsigned long &, const unsigned long &) --> void", pybind11::arg("particles"), pybind11::arg("vertices"));
+		cl.def("add_tree", (void (HepMC3::GenEvent::*)(const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > &)) &HepMC3::GenEvent::add_tree, "Add whole tree in topological order\n\n This function will find the beam particles (particles\n that have no production vertices or their production vertices\n have no particles) and will add the whole decay tree starting from\n these particles.\n\n \n Any particles on this list that do not belong to the tree\n       will be ignored.\n\nC++: HepMC3::GenEvent::add_tree(const class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > &) --> void", pybind11::arg("parts"));
+		cl.def("reserve", [](HepMC3::GenEvent &o, const unsigned long & a0) -> void { return o.reserve(a0); }, "", pybind11::arg("parts"));
+		cl.def("reserve", (void (HepMC3::GenEvent::*)(const unsigned long &, const unsigned long &)) &HepMC3::GenEvent::reserve, "Reserve memory for particles and vertices\n\n Helps optimize event creation when size of the event is known beforehand\n\nC++: HepMC3::GenEvent::reserve(const unsigned long &, const unsigned long &) --> void", pybind11::arg("parts"), pybind11::arg("verts"));
 		cl.def("clear", (void (HepMC3::GenEvent::*)()) &HepMC3::GenEvent::clear, "Remove contents of this event\n\nC++: HepMC3::GenEvent::clear() --> void");
-		cl.def("add_particle", (void (HepMC3::GenEvent::*)(class HepMC3::GenParticle *)) &HepMC3::GenEvent::add_particle, "Add particle by raw pointer\n \n\n Use GenEvent::add_particle( const GenParticlePtr& ) instead\n\nC++: HepMC3::GenEvent::add_particle(class HepMC3::GenParticle *) --> void", pybind11::arg("p"));
-		cl.def("add_vertex", (void (HepMC3::GenEvent::*)(class HepMC3::GenVertex *)) &HepMC3::GenEvent::add_vertex, "Add vertex by raw pointer\n \n\n Use GenEvent::add_vertex( const GenVertexPtr& ) instead\n\nC++: HepMC3::GenEvent::add_vertex(class HepMC3::GenVertex *) --> void", pybind11::arg("v"));
+		cl.def("add_particle", (void (HepMC3::GenEvent::*)(class HepMC3::GenParticle *)) &HepMC3::GenEvent::add_particle, "Add particle by raw pointer\n\n \n Use GenEvent::add_particle( const GenParticlePtr& ) instead\n\nC++: HepMC3::GenEvent::add_particle(class HepMC3::GenParticle *) --> void", pybind11::arg("p"));
+		cl.def("add_vertex", (void (HepMC3::GenEvent::*)(class HepMC3::GenVertex *)) &HepMC3::GenEvent::add_vertex, "Add vertex by raw pointer\n\n \n Use GenEvent::add_vertex( const GenVertexPtr& ) instead\n\nC++: HepMC3::GenEvent::add_vertex(class HepMC3::GenVertex *) --> void", pybind11::arg("v"));
 		cl.def("set_beam_particles", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenParticle>, class std::shared_ptr<class HepMC3::GenParticle>)) &HepMC3::GenEvent::set_beam_particles, "Set incoming beam particles\n \n\n Backward compatibility\n\nC++: HepMC3::GenEvent::set_beam_particles(class std::shared_ptr<class HepMC3::GenParticle>, class std::shared_ptr<class HepMC3::GenParticle>) --> void", pybind11::arg("p1"), pybind11::arg("p2"));
 		cl.def("add_beam_particle", (void (HepMC3::GenEvent::*)(class std::shared_ptr<class HepMC3::GenParticle>)) &HepMC3::GenEvent::add_beam_particle, "Add  particle to root vertex\n\nC++: HepMC3::GenEvent::add_beam_particle(class std::shared_ptr<class HepMC3::GenParticle>) --> void", pybind11::arg("p1"));
 		cl.def("write_data", (void (HepMC3::GenEvent::*)(struct HepMC3::GenEventData &) const) &HepMC3::GenEvent::write_data, "Fill GenEventData object\n\nC++: HepMC3::GenEvent::write_data(struct HepMC3::GenEventData &) const --> void", pybind11::arg("data"));
 		cl.def("read_data", (void (HepMC3::GenEvent::*)(const struct HepMC3::GenEventData &)) &HepMC3::GenEvent::read_data, "Fill GenEvent based on GenEventData\n\nC++: HepMC3::GenEvent::read_data(const struct HepMC3::GenEventData &) --> void", pybind11::arg("data"));
 
 		 binder::custom_GenEvent_binder(cl);
 	}
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3_9.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3_9.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -18,16 +18,16 @@
 #include <ostream>
 #include <sstream> // __str__
 #include <streambuf>
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <src/stl_binders.hpp>
 #include <src/binders.h>
@@ -79,31 +79,84 @@
 				static pybind11::detail::override_caster_t<void> caster;
 				return pybind11::detail::cast_ref<void>(std::move(o), caster);
 			}
 			else return pybind11::detail::cast_safe<void>(std::move(o));
 		}
 		pybind11::pybind11_fail("Tried to call pure virtual function \"Writer::close\"");
 	}
+	void set_run_info(class std::shared_ptr<class HepMC3::GenRunInfo> a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::Writer *>(this), "set_run_info");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
+		}
+		return Writer::set_run_info(a0);
+	}
+	class std::shared_ptr<class HepMC3::GenRunInfo> run_info() const override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::Writer *>(this), "run_info");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<class std::shared_ptr<class HepMC3::GenRunInfo>>::value) {
+				static pybind11::detail::override_caster_t<class std::shared_ptr<class HepMC3::GenRunInfo>> caster;
+				return pybind11::detail::cast_ref<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<class std::shared_ptr<class HepMC3::GenRunInfo>>(std::move(o));
+		}
+		return Writer::run_info();
+	}
+	void set_options(const class std::map<std::string, std::string > & a0) override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::Writer *>(this), "set_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>(a0);
+			if (pybind11::detail::cast_is_temporary_value_reference<void>::value) {
+				static pybind11::detail::override_caster_t<void> caster;
+				return pybind11::detail::cast_ref<void>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<void>(std::move(o));
+		}
+		return Writer::set_options(a0);
+	}
+	using _binder_ret_0 = std::map<std::string, std::string >;
+	_binder_ret_0 get_options() const override {
+		pybind11::gil_scoped_acquire gil;
+		pybind11::function overload = pybind11::get_overload(static_cast<const HepMC3::Writer *>(this), "get_options");
+		if (overload) {
+			auto o = overload.operator()<pybind11::return_value_policy::reference>();
+			if (pybind11::detail::cast_is_temporary_value_reference<_binder_ret_0>::value) {
+				static pybind11::detail::override_caster_t<_binder_ret_0> caster;
+				return pybind11::detail::cast_ref<_binder_ret_0>(std::move(o), caster);
+			}
+			else return pybind11::detail::cast_safe<_binder_ret_0>(std::move(o));
+		}
+		return Writer::get_options();
+	}
 };
 
 void bind_pyHepMC3_9(std::function< pybind11::module &(std::string const &namespace_) > &M)
 {
 	{ // HepMC3::GenParticle file:HepMC3/GenParticle.h line:31
 		pybind11::class_<HepMC3::GenParticle, std::shared_ptr<HepMC3::GenParticle>> cl(M("HepMC3"), "GenParticle", "");
 		cl.def( pybind11::init( [](){ return new HepMC3::GenParticle(); } ), "doc" );
 		cl.def( pybind11::init( [](const class HepMC3::FourVector & a0){ return new HepMC3::GenParticle(a0); } ), "doc" , pybind11::arg("momentum"));
 		cl.def( pybind11::init( [](const class HepMC3::FourVector & a0, int const & a1){ return new HepMC3::GenParticle(a0, a1); } ), "doc" , pybind11::arg("momentum"), pybind11::arg("pid"));
 		cl.def( pybind11::init<const class HepMC3::FourVector &, int, int>(), pybind11::arg("momentum"), pybind11::arg("pid"), pybind11::arg("status") );
 
 		cl.def( pybind11::init<const struct HepMC3::GenParticleData &>(), pybind11::arg("data") );
 
 		cl.def( pybind11::init( [](HepMC3::GenParticle const &o){ return new HepMC3::GenParticle(o); } ) );
-		cl.def("in_event", (bool (HepMC3::GenParticle::*)() const) &HepMC3::GenParticle::in_event, "Check if this particle belongs to an event \n\nC++: HepMC3::GenParticle::in_event() const --> bool");
-		cl.def("parent_event", (class HepMC3::GenEvent * (HepMC3::GenParticle::*)()) &HepMC3::GenParticle::parent_event, "C++: HepMC3::GenParticle::parent_event() --> class HepMC3::GenEvent *", pybind11::return_value_policy::automatic);
-		cl.def("id", (int (HepMC3::GenParticle::*)() const) &HepMC3::GenParticle::id, "C++: HepMC3::GenParticle::id() const --> int");
+		cl.def("in_event", (bool (HepMC3::GenParticle::*)() const) &HepMC3::GenParticle::in_event, "Check if this particle belongs to an event\n\nC++: HepMC3::GenParticle::in_event() const --> bool");
+		cl.def("parent_event", (class HepMC3::GenEvent * (HepMC3::GenParticle::*)()) &HepMC3::GenParticle::parent_event, "Get the parent event\n\nC++: HepMC3::GenParticle::parent_event() --> class HepMC3::GenEvent *", pybind11::return_value_policy::automatic);
+		cl.def("id", (int (HepMC3::GenParticle::*)() const) &HepMC3::GenParticle::id, "Get the particle ID number (*not* PDG ID)\n\nC++: HepMC3::GenParticle::id() const --> int");
 		cl.def("data", (const struct HepMC3::GenParticleData & (HepMC3::GenParticle::*)() const) &HepMC3::GenParticle::data, "C++: HepMC3::GenParticle::data() const --> const struct HepMC3::GenParticleData &", pybind11::return_value_policy::automatic);
 		cl.def("production_vertex", (class std::shared_ptr<class HepMC3::GenVertex> (HepMC3::GenParticle::*)()) &HepMC3::GenParticle::production_vertex, "C++: HepMC3::GenParticle::production_vertex() --> class std::shared_ptr<class HepMC3::GenVertex>");
 		cl.def("end_vertex", (class std::shared_ptr<class HepMC3::GenVertex> (HepMC3::GenParticle::*)()) &HepMC3::GenParticle::end_vertex, "C++: HepMC3::GenParticle::end_vertex() --> class std::shared_ptr<class HepMC3::GenVertex>");
 		cl.def("parents", (class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > (HepMC3::GenParticle::*)()) &HepMC3::GenParticle::parents, "Convenience access to immediate incoming particles via production vertex\n \n\n Less efficient than via the vertex since return must be by value (in case there is no vertex)\n\nC++: HepMC3::GenParticle::parents() --> class std::vector<class std::shared_ptr<class HepMC3::GenParticle> >");
 		cl.def("children", (class std::vector<class std::shared_ptr<class HepMC3::GenParticle> > (HepMC3::GenParticle::*)()) &HepMC3::GenParticle::children, "Convenience access to immediate outgoing particles via end vertex\n \n\n Less efficient than via the vertex since return must be by value (in case there is no vertex)\n\nC++: HepMC3::GenParticle::children() --> class std::vector<class std::shared_ptr<class HepMC3::GenParticle> >");
 		cl.def("pid", (int (HepMC3::GenParticle::*)() const) &HepMC3::GenParticle::pid, "C++: HepMC3::GenParticle::pid() const --> int");
 		cl.def("abs_pid", (int (HepMC3::GenParticle::*)() const) &HepMC3::GenParticle::abs_pid, "C++: HepMC3::GenParticle::abs_pid() const --> int");
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3rootIO.binder` & `HepMC3-3.2.6/python/src/pyHepMC3rootIO.binder`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3rootIO.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3protobufIO.cpp`

 * *Files 17% similar despite different names*

```diff
@@ -4,21 +4,19 @@
 #include <functional>
 #include <string>
 
 #include <pybind11/pybind11.h>
 
 typedef std::function< pybind11::module & (std::string const &) > ModuleGetter;
 
-void bind_pyHepMC3rootIO_0(std::function< pybind11::module &(std::string const &namespace_) > &M);
-void bind_pyHepMC3rootIO_1(std::function< pybind11::module &(std::string const &namespace_) > &M);
-void bind_pyHepMC3rootIO_2(std::function< pybind11::module &(std::string const &namespace_) > &M);
+void bind_pyHepMC3protobufIO_0(std::function< pybind11::module &(std::string const &namespace_) > &M);
 
 
-PYBIND11_MODULE(pyHepMC3rootIO, root_module) {
-	root_module.doc() = "pyHepMC3rootIO module";
+PYBIND11_MODULE(pyHepMC3protobufIO, root_module) {
+	root_module.doc() = "pyHepMC3protobufIO module";
 
 	std::map <std::string, pybind11::module> modules;
 	ModuleGetter M = [&](std::string const &namespace_) -> pybind11::module & {
 		auto it = modules.find(namespace_);
 		if( it == modules.end() ) throw std::runtime_error("Attempt to access pybind11::module for namespace " + namespace_ + " before it was created!!!");
 		return it->second;
 	};
@@ -28,12 +26,10 @@
 	std::vector< std::pair<std::string, std::string> > sub_modules {
 		{"", "HepMC3"},
 	};
 	for(auto &p : sub_modules ) modules[p.first.size() ? p.first+"::"+p.second : p.second] = modules[p.first].def_submodule(p.second.c_str(), ("Bindings for " + p.first + "::" + p.second + " namespace").c_str() );
 
 	//pybind11::class_<std::shared_ptr<void>>(M(""), "_encapsulated_data_");
 
-	bind_pyHepMC3rootIO_0(M);
-	bind_pyHepMC3rootIO_1(M);
-	bind_pyHepMC3rootIO_2(M);
+	bind_pyHepMC3protobufIO_0(M);
 
 }
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3rootIO_0.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3rootIO_0.cpp`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <HepMC3/GenRunInfo.h>
 #include <HepMC3/WriterRoot.h>
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3rootIO_1.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3rootIO_1.cpp`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -5,16 +5,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <HepMC3/GenRunInfo.h>
 #include <HepMC3/WriterRoot.h>
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3rootIO_2.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3rootIO_2.cpp`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 #include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 #include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Reader.h>
 #include <HepMC3/Writer.h>
 #include <HepMC3/Print.h>
 #include <HepMC3/GenRunInfo.h>
 #include <HepMC3/WriterRoot.h>
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3search.binder` & `HepMC3-3.2.6/python/src/pyHepMC3search.binder`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3search.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3rootIO.cpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,37 +1,49 @@
 #include <map>
+#include <algorithm>
+#include <functional>
 #include <memory>
 #include <stdexcept>
-#include <functional>
 #include <string>
 
 #include <pybind11/pybind11.h>
 
 typedef std::function< pybind11::module & (std::string const &) > ModuleGetter;
 
-void bind_pyHepMC3search_0(std::function< pybind11::module &(std::string const &namespace_) > &M);
-void bind_pyHepMC3search_1(std::function< pybind11::module &(std::string const &namespace_) > &M);
+void bind_pyHepMC3rootIO_0(std::function< pybind11::module &(std::string const &namespace_) > &M);
+void bind_pyHepMC3rootIO_1(std::function< pybind11::module &(std::string const &namespace_) > &M);
+void bind_pyHepMC3rootIO_2(std::function< pybind11::module &(std::string const &namespace_) > &M);
 
 
-PYBIND11_MODULE(pyHepMC3search, root_module) {
-	root_module.doc() = "pyHepMC3search module";
+PYBIND11_MODULE(pyHepMC3rootIO, root_module) {
+	root_module.doc() = "pyHepMC3rootIO module";
 
 	std::map <std::string, pybind11::module> modules;
 	ModuleGetter M = [&](std::string const &namespace_) -> pybind11::module & {
 		auto it = modules.find(namespace_);
 		if( it == modules.end() ) throw std::runtime_error("Attempt to access pybind11::module for namespace " + namespace_ + " before it was created!!!");
 		return it->second;
 	};
 
 	modules[""] = root_module;
 
+	static std::vector<std::string> const reserved_python_words {"nonlocal", "global", };
+
+	auto mangle_namespace_name(
+		[](std::string const &ns) -> std::string {
+			if ( std::find(reserved_python_words.begin(), reserved_python_words.end(), ns) == reserved_python_words.end() ) return ns;
+			else return ns+'_';
+		}
+	);
+
 	std::vector< std::pair<std::string, std::string> > sub_modules {
 		{"", "HepMC3"},
 	};
-	for(auto &p : sub_modules ) modules[p.first.size() ? p.first+"::"+p.second : p.second] = modules[p.first].def_submodule(p.second.c_str(), ("Bindings for " + p.first + "::" + p.second + " namespace").c_str() );
+	for(auto &p : sub_modules ) modules[p.first.size() ? p.first+"::"+p.second : p.second] = modules[p.first].def_submodule( mangle_namespace_name(p.second).c_str(), ("Bindings for " + p.first + "::" + p.second + " namespace").c_str() );
 
 	//pybind11::class_<std::shared_ptr<void>>(M(""), "_encapsulated_data_");
 
-	bind_pyHepMC3search_0(M);
-	bind_pyHepMC3search_1(M);
+	bind_pyHepMC3rootIO_0(M);
+	bind_pyHepMC3rootIO_1(M);
+	bind_pyHepMC3rootIO_2(M);
 
 }
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3search_0.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3search_0.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,19 @@
 #include <HepMC3/AttributeFeature.h>
 #include <HepMC3/Relatives.h>
 #include <HepMC3/Selector.h>
 #include <functional>
 #include <iterator>
-#include <map>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
-#include <utility>
 #include <vector>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Relatives.h>
 #include <HepMC3/Selector.h>
 #include <src/search_binders.h>
 
 
@@ -35,26 +33,26 @@
 		cl.def( pybind11::init<const std::string &>(), pybind11::arg("name") );
 
 		cl.def( pybind11::init( [](HepMC3::AttributeFeature const &o){ return new HepMC3::AttributeFeature(o); } ) );
 		cl.def("exists", (class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> (HepMC3::AttributeFeature::*)() const) &HepMC3::AttributeFeature::exists, "existence\n\nC++: HepMC3::AttributeFeature::exists() const --> class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)>");
 		cl.def("__eq__", (class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> (HepMC3::AttributeFeature::*)(std::string) const) &HepMC3::AttributeFeature::operator==, "equality operator\n\nC++: HepMC3::AttributeFeature::operator==(std::string) const --> class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)>", pybind11::arg("rhs"));
 		cl.def("assign", (class HepMC3::AttributeFeature & (HepMC3::AttributeFeature::*)(const class HepMC3::AttributeFeature &)) &HepMC3::AttributeFeature::operator=, "C++: HepMC3::AttributeFeature::operator=(const class HepMC3::AttributeFeature &) --> class HepMC3::AttributeFeature &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
-	{ // HepMC3::Relatives file:HepMC3/Relatives.h line:53
-		pybind11::class_<HepMC3::Relatives, std::shared_ptr<HepMC3::Relatives>> cl(M("HepMC3"), "Relatives", "Define a common interface that all Relatives objects will satisfy\n         Relatives provides an operator to get the relatives of a range of different\n         GenObject types.  The following are examples\n\n         Relatives::ANCESTORS(GenParticlePtr);// returns ancestors of the particle\n         Descendants descendants;\n         descendants(GenVertexPtr);// descendants of the vertex\n         vector<Relatives*> relations = {&Relatives::CHILDREN, &Relatives::DESCENDANTS, &Relatives::PARENTS, new Ancestors()}; // make a vector of Relatives\n\n         You can also define your own relation and wrap it in the Relatives interface using\n         Relatives * relo = new RelativesInterface<MyRelationClass>();");
-		cl.def("assign", (class HepMC3::Relatives & (HepMC3::Relatives::*)(const class HepMC3::Relatives &)) &HepMC3::Relatives::operator=, "C++: HepMC3::Relatives::operator=(const class HepMC3::Relatives &) --> class HepMC3::Relatives &", pybind11::return_value_policy::automatic, pybind11::arg(""));
-	}
-	{ // HepMC3::_parents file:HepMC3/Relatives.h line:195
+	{ // HepMC3::_parents file:HepMC3/Relatives.h line:76
 		pybind11::class_<HepMC3::_parents, std::shared_ptr<HepMC3::_parents>> cl(M("HepMC3"), "_parents", "Provides operator to find the parent particles of a Vertex or Particle\n\n Note you would usually not instantiate this directly, but wrap it in a RelativesInterface");
 		cl.def( pybind11::init( [](){ return new HepMC3::_parents(); } ) );
 	}
-	{ // HepMC3::_children file:HepMC3/Relatives.h line:218
+	{ // HepMC3::_children file:HepMC3/Relatives.h line:99
 		pybind11::class_<HepMC3::_children, std::shared_ptr<HepMC3::_children>> cl(M("HepMC3"), "_children", "Provides operator to find the child particles of a Vertex or Particle\n\n Note you would usually not instantiate this directly, but wrap it in a RelativesInterface");
 		cl.def( pybind11::init( [](){ return new HepMC3::_children(); } ) );
 	}
+	{ // HepMC3::Relatives file:HepMC3/Relatives.h line:182
+		pybind11::class_<HepMC3::Relatives, std::shared_ptr<HepMC3::Relatives>> cl(M("HepMC3"), "Relatives", "Define a common interface that all Relatives objects will satisfy\n         Relatives provides an operator to get the relatives of a range of different\n         GenObject types.  The following are examples\n\n         Relatives::ANCESTORS(GenParticlePtr);// returns ancestors of the particle\n         Descendants descendants;\n         descendants(GenVertexPtr);// descendants of the vertex\n         vector<Relatives*> relations = {&Relatives::CHILDREN, &Relatives::DESCENDANTS, &Relatives::PARENTS, new Ancestors()}; // make a vector of Relatives\n\n         You can also define your own relation and wrap it in the Relatives interface using\n         Relatives * relo = new RelativesInterface<MyRelationClass>();");
+		cl.def("assign", (class HepMC3::Relatives & (HepMC3::Relatives::*)(const class HepMC3::Relatives &)) &HepMC3::Relatives::operator=, "C++: HepMC3::Relatives::operator=(const class HepMC3::Relatives &) --> class HepMC3::Relatives &", pybind11::return_value_policy::automatic, pybind11::arg(""));
+	}
 	{ // HepMC3::Selector file:HepMC3/Selector.h line:57
 		pybind11::class_<HepMC3::Selector, std::shared_ptr<HepMC3::Selector>> cl(M("HepMC3"), "Selector", "Selector is an interface to \"standard\" Features that are valid\n  for both integral and floating point comparisons\n\n  You would use this in preference to the more general\n  Feature<> templated type.  A Selector is constructed from a\n  function to extract features from particles, e.g.\n\n  ConstSelectorPtr status = std::make_shared<SelectorWrapper<int> >([](ConstParticlePtr p)->int{return p->status();});\n  ConstSelectorPtr pt = std::make_shared<SelectorWrapper<double> >([](ConstParticlePtr p)->double{return p->momentum().pt();});\n\n  You can then use the Selector to construct Filter functions that\n  evaluate on particles, e.g.\n  Filter is_stable = (*status) == 1;\n  bool stable = is_stable(p);\n  bool beam = (*status == 4)(p);\n\n  StandardSelector contains a few standard Selectors already defined, e.g.\n\n  ConstGenParticlePtr p;\n  (StandardSelector::STATUS == 1)(p);\n  (StandardSelector::PT > 15.)(p);\n  (abs(StandardSelector::RAPIDITY) < 2.5)(p);\n\n  you can also combined them e.g.\n\n  Filter myCuts = (StandardSelector::PT > 15.) && (*abs(StandardSelector::RAPIDITY) < 2.5) || (StandardSelector::PT > 100.);\n  bool passCuts = myCuts(p);");
 		cl.def("__eq__", (class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> (HepMC3::Selector::*)(int) const) &HepMC3::Selector::operator==, "C++: HepMC3::Selector::operator==(int) const --> class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)>", pybind11::arg("value"));
 		cl.def("__eq__", (class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> (HepMC3::Selector::*)(double) const) &HepMC3::Selector::operator==, "C++: HepMC3::Selector::operator==(double) const --> class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)>", pybind11::arg("value"));
 		cl.def("__ne__", (class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> (HepMC3::Selector::*)(int) const) &HepMC3::Selector::operator!=, "C++: HepMC3::Selector::operator!=(int) const --> class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)>", pybind11::arg("value"));
 		cl.def("__ne__", (class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> (HepMC3::Selector::*)(double) const) &HepMC3::Selector::operator!=, "C++: HepMC3::Selector::operator!=(double) const --> class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)>", pybind11::arg("value"));
 		cl.def("abs", (class std::shared_ptr<const class HepMC3::Selector> (HepMC3::Selector::*)() const) &HepMC3::Selector::abs, "C++: HepMC3::Selector::abs() const --> class std::shared_ptr<const class HepMC3::Selector>");
```

### Comparing `HepMC3-3.2.5/python/src/pyHepMC3search_1.cpp` & `HepMC3-3.2.6/python/src/pyHepMC3search_1.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 #include <HepMC3/Selector.h>
 #include <functional>
 #include <iterator>
 #include <memory>
 #include <sstream> // __str__
 #include <string>
 
-#include <pybind11/pybind11.h>
 #include <functional>
+#include <pybind11/pybind11.h>
 #include <string>
 #include <HepMC3/Version.h>
 #include <HepMC3/Relatives.h>
 #include <HepMC3/Selector.h>
 #include <src/search_binders.h>
 
 
@@ -23,12 +23,12 @@
 #endif
 
 void bind_pyHepMC3search_1(std::function< pybind11::module &(std::string const &namespace_) > &M)
 {
 	// HepMC3::abs(const class HepMC3::Selector &) file:HepMC3/Selector.h line:161
 	M("HepMC3").def("abs", (class std::shared_ptr<const class HepMC3::Selector> (*)(const class HepMC3::Selector &)) &HepMC3::abs, "ConstSelectorPtr abs\n\nC++: HepMC3::abs(const class HepMC3::Selector &) --> class std::shared_ptr<const class HepMC3::Selector>", pybind11::arg("input"));
 
-	{ // HepMC3::StandardSelector file:HepMC3/Selector.h line:176
+	{ // HepMC3::StandardSelector file:HepMC3/Selector.h line:174
 		pybind11::class_<HepMC3::StandardSelector, std::shared_ptr<HepMC3::StandardSelector>, HepMC3::Selector> cl(M("HepMC3"), "StandardSelector", "StandardSelector ");
 		cl.def("assign", (class HepMC3::StandardSelector & (HepMC3::StandardSelector::*)(const class HepMC3::StandardSelector &)) &HepMC3::StandardSelector::operator=, "C++: HepMC3::StandardSelector::operator=(const class HepMC3::StandardSelector &) --> class HepMC3::StandardSelector &", pybind11::return_value_policy::automatic, pybind11::arg(""));
 	}
 }
```

### Comparing `HepMC3-3.2.5/python/src/root_binders.cpp` & `HepMC3-3.2.6/python/src/root_binders.cpp`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/src/search_binders.cpp` & `HepMC3-3.2.6/python/src/search_binders.cpp`

 * *Files 24% similar despite different names*

```diff
@@ -20,51 +20,51 @@
 	// HepMC3::applyFilter(const class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> &, const class std::vector<class std::shared_ptr<const class HepMC3::GenParticle>, class std::allocator<class std::shared_ptr<const class HepMC3::GenParticle> > > &) file: line:31
 	M.def("applyFilter", (class std::vector<class std::shared_ptr<const class HepMC3::GenParticle>, class std::allocator<class std::shared_ptr<const class HepMC3::GenParticle> > > (*)(const class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> &, const class std::vector<class std::shared_ptr<const class HepMC3::GenParticle>, class std::allocator<class std::shared_ptr<const class HepMC3::GenParticle> > > &)) &HepMC3::applyFilter, "Apply a Filter to a list of ConstGenParticles\n Returns a vector of ConstGenParticles that satisfy the Filter\n\nC++: HepMC3::applyFilter(const class std::function<bool (class std::shared_ptr<const class HepMC3::GenParticle>)> &, const class std::vector<class std::shared_ptr<const class HepMC3::GenParticle>, class std::allocator<class std::shared_ptr<const class HepMC3::GenParticle> > > &) --> class std::vector<class std::shared_ptr<const class HepMC3::GenParticle>, class std::allocator<class std::shared_ptr<const class HepMC3::GenParticle> > >", pybind11::arg("filter"), pybind11::arg("particles"));
 
 	// HepMC3::ACCEPT_ALL(class std::shared_ptr<const class HepMC3::GenParticle>) file: line:41
 	M.def("ACCEPT_ALL", (bool (*)(class std::shared_ptr<const class HepMC3::GenParticle>)) &HepMC3::ACCEPT_ALL, "A Filter that will accept all particles\n This might be needed if a signature requires a default Filter\n\nC++: HepMC3::ACCEPT_ALL(class std::shared_ptr<const class HepMC3::GenParticle>) --> bool", pybind11::arg("dummy"));
 
 
-  M.def("children_particles",   (std::vector<HepMC3::GenParticlePtr>(*)(HepMC3::GenVertexPtr)      ) &HepMC3::children_particles,  "See documentation");
-  M.def("children_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(HepMC3::ConstGenVertexPtr) ) &HepMC3::children_particles,  "See documentation");
-  M.def("children_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)(HepMC3::GenParticlePtr)        ) &HepMC3::children_vertices,  "See documentation");
-  M.def("children_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)(HepMC3::ConstGenParticlePtr)   ) &HepMC3::children_vertices,  "See documentation");
-
-  M.def("grandchildren_particles",   (std::vector<HepMC3::GenParticlePtr>(*)(HepMC3::GenParticlePtr)       ) &HepMC3::grandchildren_particles,  "See documentation");
-  M.def("grandchildren_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*) (HepMC3::ConstGenParticlePtr)) &HepMC3::grandchildren_particles,  "See documentation");
-  M.def("grandchildren_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)(HepMC3::GenVertexPtr)          ) &HepMC3::grandchildren_vertices,  "See documentation");
-  M.def("grandchildren_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)(HepMC3::ConstGenVertexPtr)    ) &HepMC3::grandchildren_vertices,  "See documentation");
-
-  M.def("parent_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (HepMC3::GenVertexPtr)       ) &HepMC3::parent_particles,  "See documentation");
-  M.def("parent_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(HepMC3::ConstGenVertexPtr)  ) &HepMC3::parent_particles,  "See documentation");
-  M.def("parent_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)        (HepMC3::GenParticlePtr)         ) &HepMC3::parent_vertices,  "See documentation");
-  M.def("parent_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)   (HepMC3::ConstGenParticlePtr)    ) &HepMC3::parent_vertices,  "See documentation");
-
-  M.def("grandparent_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (HepMC3::GenParticlePtr)       ) &HepMC3::grandparent_particles,  "See documentation");
-  M.def("grandparent_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(HepMC3::ConstGenParticlePtr)  ) &HepMC3::grandparent_particles,  "See documentation");
-  M.def("grandparent_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)        (HepMC3::GenVertexPtr)         ) &HepMC3::grandparent_vertices,  "See documentation");
-  M.def("grandparent_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)   (HepMC3::ConstGenVertexPtr)    ) &HepMC3::grandparent_vertices,  "See documentation");
-
-  M.def("descendant_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(HepMC3::ConstGenVertexPtr) ) &HepMC3::descendant_particles,  "See documentation");
-  M.def("descendant_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (HepMC3::GenVertexPtr)     ) &HepMC3::descendant_particles,  "See documentation");
-  M.def("descendant_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(HepMC3::ConstGenParticlePtr) ) &HepMC3::descendant_particles,  "See documentation");
-  M.def("descendant_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (HepMC3::GenParticlePtr)      ) &HepMC3::descendant_particles,  "See documentation");
-
-  M.def("descendant_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (HepMC3::ConstGenParticlePtr)   ) &HepMC3::descendant_vertices,  "See documentation");
-  M.def("descendant_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (HepMC3::GenParticlePtr)        ) &HepMC3::descendant_vertices,  "See documentation");
-  M.def("descendant_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (HepMC3::ConstGenVertexPtr)  ) &HepMC3::descendant_vertices,  "See documentation");
-  M.def("descendant_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (HepMC3::GenVertexPtr)         ) &HepMC3::descendant_vertices,  "See documentation");
-
-  M.def("ancestor_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(HepMC3::ConstGenVertexPtr) ) &HepMC3::ancestor_particles,  "See documentation");
-  M.def("ancestor_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (HepMC3::GenVertexPtr)      ) &HepMC3::ancestor_particles,  "See documentation");
-  M.def("ancestor_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(HepMC3::ConstGenParticlePtr) ) &HepMC3::ancestor_particles,  "See documentation");
-  M.def("ancestor_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (HepMC3::GenParticlePtr)      ) &HepMC3::ancestor_particles,  "See documentation");
-
-
-  M.def("ancestor_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (HepMC3::ConstGenParticlePtr)   ) &HepMC3::ancestor_vertices,  "See documentation");
-  M.def("ancestor_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (HepMC3::GenParticlePtr)           ) &HepMC3::ancestor_vertices,  "See documentation");
-  M.def("ancestor_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (HepMC3::ConstGenVertexPtr)  ) &HepMC3::ancestor_vertices,  "See documentation");
-  M.def("ancestor_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (HepMC3::GenVertexPtr)            ) &HepMC3::ancestor_vertices,  "See documentation");
+  M.def("children_particles",   (std::vector<HepMC3::GenParticlePtr>(*)(const HepMC3::GenVertexPtr&)     ) &HepMC3::children_particles,  "See documentation");
+  M.def("children_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(const HepMC3::ConstGenVertexPtr&)) &HepMC3::children_particles,  "See documentation");
+  M.def("children_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)(const HepMC3::GenParticlePtr&)       ) &HepMC3::children_vertices,  "See documentation");
+  M.def("children_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)(const HepMC3::ConstGenParticlePtr&)  ) &HepMC3::children_vertices,  "See documentation");
+
+  M.def("grandchildren_particles",   (std::vector<HepMC3::GenParticlePtr>(*)(const HepMC3::GenParticlePtr&)      ) &HepMC3::grandchildren_particles,  "See documentation");
+  M.def("grandchildren_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*) (const HepMC3::ConstGenParticlePtr&)) &HepMC3::grandchildren_particles,  "See documentation");
+  M.def("grandchildren_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)(const HepMC3::GenVertexPtr&)         ) &HepMC3::grandchildren_vertices,  "See documentation");
+  M.def("grandchildren_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)(const HepMC3::ConstGenVertexPtr&)   ) &HepMC3::grandchildren_vertices,  "See documentation");
+
+  M.def("parent_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (const HepMC3::GenVertexPtr&)      ) &HepMC3::parent_particles,  "See documentation");
+  M.def("parent_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(const HepMC3::ConstGenVertexPtr&) ) &HepMC3::parent_particles,  "See documentation");
+  M.def("parent_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)        (const HepMC3::GenParticlePtr&)        ) &HepMC3::parent_vertices,  "See documentation");
+  M.def("parent_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)   (const HepMC3::ConstGenParticlePtr&)   ) &HepMC3::parent_vertices,  "See documentation");
+
+  M.def("grandparent_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (const HepMC3::GenParticlePtr&)      ) &HepMC3::grandparent_particles,  "See documentation");
+  M.def("grandparent_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(const HepMC3::ConstGenParticlePtr&) ) &HepMC3::grandparent_particles,  "See documentation");
+  M.def("grandparent_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)        (const HepMC3::GenVertexPtr&)        ) &HepMC3::grandparent_vertices,  "See documentation");
+  M.def("grandparent_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*)   (const HepMC3::ConstGenVertexPtr&)   ) &HepMC3::grandparent_vertices,  "See documentation");
+
+  M.def("descendant_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(const HepMC3::ConstGenVertexPtr&)) &HepMC3::descendant_particles,  "See documentation");
+  M.def("descendant_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (const HepMC3::GenVertexPtr&)    ) &HepMC3::descendant_particles,  "See documentation");
+  M.def("descendant_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(const HepMC3::ConstGenParticlePtr&)) &HepMC3::descendant_particles,  "See documentation");
+  M.def("descendant_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (const HepMC3::GenParticlePtr&)     ) &HepMC3::descendant_particles,  "See documentation");
+
+  M.def("descendant_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (const HepMC3::ConstGenParticlePtr&)  ) &HepMC3::descendant_vertices,  "See documentation");
+  M.def("descendant_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (const HepMC3::GenParticlePtr&)       ) &HepMC3::descendant_vertices,  "See documentation");
+  M.def("descendant_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (const HepMC3::ConstGenVertexPtr&) ) &HepMC3::descendant_vertices,  "See documentation");
+  M.def("descendant_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (const HepMC3::GenVertexPtr&)        ) &HepMC3::descendant_vertices,  "See documentation");
+
+  M.def("ancestor_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(const HepMC3::ConstGenVertexPtr&)) &HepMC3::ancestor_particles,  "See documentation");
+  M.def("ancestor_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (const HepMC3::GenVertexPtr&)     ) &HepMC3::ancestor_particles,  "See documentation");
+  M.def("ancestor_particles",   (std::vector<HepMC3::ConstGenParticlePtr>(*)(const HepMC3::ConstGenParticlePtr&)) &HepMC3::ancestor_particles,  "See documentation");
+  M.def("ancestor_particles",   (std::vector<HepMC3::GenParticlePtr>(*)     (const HepMC3::GenParticlePtr&)     ) &HepMC3::ancestor_particles,  "See documentation");
+
+
+  M.def("ancestor_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (const HepMC3::ConstGenParticlePtr&)  ) &HepMC3::ancestor_vertices,  "See documentation");
+  M.def("ancestor_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (const HepMC3::GenParticlePtr&)          ) &HepMC3::ancestor_vertices,  "See documentation");
+  M.def("ancestor_vertices",   (std::vector<HepMC3::ConstGenVertexPtr>(*) (const HepMC3::ConstGenVertexPtr&) ) &HepMC3::ancestor_vertices,  "See documentation");
+  M.def("ancestor_vertices",   (std::vector<HepMC3::GenVertexPtr>(*)      (const HepMC3::GenVertexPtr&)           ) &HepMC3::ancestor_vertices,  "See documentation");
 
        }
 
 } // namespace binder
```

### Comparing `HepMC3-3.2.5/python/src/stl_binders.hpp` & `HepMC3-3.2.6/python/src/stl_binders.hpp`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/Pythia8ToHepMC3.py` & `HepMC3-3.2.6/python/test/Pythia8ToHepMC3.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputDelete.hepmc` & `HepMC3-3.2.6/python/test/inputDelete.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputDelete2.hepmc` & `HepMC3-3.2.6/python/test/inputDelete2.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputIO1.hepmc` & `HepMC3-3.2.6/python/test/inputIO1.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputIO2.hepmc` & `HepMC3-3.2.6/python/test/inputIO2.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputIO3.hepevt` & `HepMC3-3.2.6/python/test/inputIO3.hepevt`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputIO4.root` & `HepMC3-3.2.6/python/test/inputIO4.root`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputIO5.hepmc` & `HepMC3-3.2.6/python/test/inputIO5.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputIO6.hepmc` & `HepMC3-3.2.6/python/test/inputIO6.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputMass.hepmc` & `HepMC3-3.2.6/python/test/inputMass.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputMultipleCopies1.hepmc` & `HepMC3-3.2.6/python/test/inputMultipleCopies1.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputMultipleCopies2.hepmc` & `HepMC3-3.2.6/python/test/inputMultipleCopies2.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputPythonization_Search.hepmc` & `HepMC3-3.2.6/python/test/inputPythonization_Search.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputReaderFactory1.hepmc` & `HepMC3-3.2.6/python/test/inputReaderFactory1.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputReaderFactory2.hepmc` & `HepMC3-3.2.6/python/test/inputReaderFactory2.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/inputThreads1.hepmc` & `HepMC3-3.2.6/python/test/inputThreads1.hepmc`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/pyHepMC3TestUtils.py` & `HepMC3-3.2.6/python/test/pyHepMC3TestUtils.py`

 * *Files 27% similar despite different names*

```diff
@@ -16,14 +16,20 @@
     return a
 
 
 def update_path():
     try:
      os.add_dll_directory(os.path.abspath(os.path.join(os.pardir, python_label())))
      os.add_dll_directory(os.getcwd())
+     for val in str(os.getenv("PATH")).split(',:;'):
+       os.add_dll_directory(os.path.abspath(val))
+     for val in str(os.getenv("LD_LIBRARY_PATH")).split(',:;'):
+       os.add_dll_directory(os.path.abspath(val))
+     for val in str(os.getenv("DYLD_LIBRARY_PATH")).split(',:;'):
+       os.add_dll_directory(os.path.abspath(val))
     except:
      pass
     return [os.path.abspath(os.path.join(os.pardir, python_label()))] + [os.getcwd()] + sys.path
 
 
 def COMPARE_ASCII_FILES(f1, f2):
     file1 = open(f1)
@@ -44,14 +50,13 @@
                 file1.close()
                 file2.close()
                 return 1
     file1.close()
     file2.close()
     return 0
 
-
 def fuse_equal(a, b, rtol=0.00001, atol=0.000001):
     if abs(1.0 * a - 1.0 * b) < atol:
         return True
     if abs(1.0 * a - 1.0 * b) < rtol * (abs(1.0 * a + 1.0 * b)):
         return True
     return False
```

### Comparing `HepMC3-3.2.5/python/test/test_Attribute.py` & `HepMC3-3.2.6/python/test/test_Attribute.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Boost.py` & `HepMC3-3.2.6/python/test/test_Boost.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_HEPEVT.py` & `HepMC3-3.2.6/python/test/test_HEPEVT.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_IO1.py` & `HepMC3-3.2.6/python/test/test_IO1.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_IO2.py` & `HepMC3-3.2.6/python/test/test_IO2.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Polarization.py` & `HepMC3-3.2.6/python/test/test_Polarization.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Print.py` & `HepMC3-3.2.6/python/test/test_Print.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Pythia8.py` & `HepMC3-3.2.6/python/test/test_Pythia8.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Pythonization_FourVector.py` & `HepMC3-3.2.6/python/test/test_Pythonization_FourVector.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Pythonization_GenRunInfo.py` & `HepMC3-3.2.6/python/test/test_Pythonization_GenRunInfo.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Pythonization_Search.py` & `HepMC3-3.2.6/python/test/test_Pythonization_Search.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/python/test/test_Units.py` & `HepMC3-3.2.6/python/test/test_Units.py`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/rootIO/CMakeLists.txt` & `HepMC3-3.2.6/rootIO/CMakeLists.txt`

 * *Files 12% similar despite different names*

```diff
@@ -13,16 +13,36 @@
 endif()
 ROOT_GENERATE_DICTIONARY(G__HepMC3rootIO include/rootIO_Classes.hh LINKDEF include/LinkDef.hh NOINSTALL OPTIONS -inlineInputHeader)
 
 add_library(HepMC3rootIO SHARED ${PROJECT_SOURCE_DIR}/rootIO/src/WriterRoot.cc ${PROJECT_SOURCE_DIR}/rootIO/src/ReaderRoot.cc ${PROJECT_SOURCE_DIR}/rootIO/src/WriterRootTree.cc ${PROJECT_SOURCE_DIR}/rootIO/src/ReaderRootTree.cc ${PROJECT_SOURCE_DIR}/rootIO/src/Streamers.cc G__HepMC3rootIO.cxx)
 set_property(TARGET HepMC3rootIO PROPERTY POSITION_INDEPENDENT_CODE 1)
 
 target_link_libraries(HepMC3rootIO ${ROOT_Tree_LIBRARY} ${ROOT_RIO_LIBRARY} ${ROOT_Core_LIBRARY} HepMC3)
-set_target_properties(HepMC3rootIO PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>)
+
+target_include_directories(HepMC3rootIO PUBLIC
+  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+  $<INSTALL_INTERFACE:include>
+  ${ROOT_INCLUDE_DIRS})
+
+set_target_properties(HepMC3rootIO PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+  EXPORT_NAME HepMC3::rootIO)
 if (MSVC)
   set_target_properties(HepMC3rootIO PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>)
 endif()
 set_target_properties(HepMC3rootIO PROPERTIES SOVERSION 3)
 # installs
-install(TARGETS HepMC3rootIO DESTINATION ${HEPMC3_ROOTIO_INSTALL_LIBDIR} COMPONENT rootIOlibs)
+install(TARGETS HepMC3rootIO
+  EXPORT HepMC3rootIOTargets
+  DESTINATION ${HEPMC3_ROOTIO_INSTALL_LIBDIR}
+  COMPONENT rootIOlibs)
 install(DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/ DESTINATION  ${HEPMC3_ROOTIO_INSTALL_LIBDIR}  COMPONENT rootIOlibs  FILES_MATCHING  PATTERN "*.pcm"  PATTERN "*.rootmap"  PATTERN "CMakeFiles" EXCLUDE   PATTERN "src" EXCLUDE  PATTERN "include" EXCLUDE)
 install(DIRECTORY include/HepMC3 DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT rootIOdevel)
+
+# Alias for packages that include this as a sub-project but
+# want to use the namespaced target names
+add_library(HepMC3::rootIO ALIAS HepMC3rootIO)
+
+set(CONFIG_INSTALL_DIR ${CMAKE_INSTALL_DATADIR}/HepMC3/cmake)
+install(EXPORT HepMC3rootIOTargets
+  DESTINATION ${CONFIG_INSTALL_DIR}
+  COMPONENT rootIOdevel)
```

### Comparing `HepMC3-3.2.5/rootIO/include/HepMC3/ReaderRoot.h` & `HepMC3-3.2.6/rootIO/include/HepMC3/ReaderRoot.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERROOT_H
 #define HEPMC3_READERROOT_H
 /**
  *  @file  ReaderRoot.h
  *  @brief Definition of \b class ReaderRoot
  *
```

### Comparing `HepMC3-3.2.5/rootIO/include/HepMC3/ReaderRootTree.h` & `HepMC3-3.2.6/rootIO/include/HepMC3/ReaderRootTree.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_READERROOTTREE_H
 #define HEPMC3_READERROOTTREE_H
 /**
  *  @file  ReaderRootTree.h
  *  @brief Definition of \b class ReaderRootTree
  *
```

### Comparing `HepMC3-3.2.5/rootIO/include/HepMC3/WriterRoot.h` & `HepMC3-3.2.6/examples/ConvertExample/include/WriterDOT.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,76 +1,61 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
-#ifndef HEPMC3_WRITERROOT_H
-#define HEPMC3_WRITERROOT_H
-/**
- *  @file  WriterRoot.h
- *  @brief Definition of \b class WriterRoot
- *
- *  @class HepMC3::WriterRoot
- *  @brief GenEvent I/O serialization for root files
- *
- *  If HepMC was compiled with path to ROOT available, this class can be used
- *  for root writing in the same manner as with HepMC::WriterAscii class.
- *
- *  @ingroup IO
- *
- */
+#ifndef HEPMC3_WRITERDOT_H
+#define HEPMC3_WRITERDOT_H
+///
+/// @file  WriterDOT.h
+/// @brief Definition of class \b WriterDOT
+///
+/// @class HepMC3::WriterDOT
+/// @brief GenEvent I/O output to dot files that should be processed by graphviz or other software
+///
+/// @ingroup Examples
+///
 #include <string>
-#include <memory>
+#include <fstream>
 #include "HepMC3/Writer.h"
 #include "HepMC3/GenEvent.h"
+#include "HepMC3/GenParticle.h"
+#include "HepMC3/GenVertex.h"
 #include "HepMC3/Data/GenEventData.h"
-#include "HepMC3/Data/GenRunInfoData.h"
-
-// ROOT header files
-#ifdef __CINT__
-#include "TFile.h"
-#else
-class TFile;
-#endif
-
-namespace HepMC3 {
-
-class WriterRoot : public Writer {
-//
-// Constructors
-//
-public:
-    /** @brief Default constructor
-     *  @warning If file exists, it will be overwritten
-     */
-    WriterRoot(const std::string& filename,
-               std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>());
-
-//
-// Functions
-//
+namespace HepMC3
+{
+class WriterDOT : public Writer
+{
 public:
-    /** @brief Write event to file
-     *
-     *  @param[in] evt Event to be serialized
-     */
+    /// @brief Constructor
+    /// @warning If file already exists, it will be cleared before writing
+    WriterDOT(const std::string &filename,std::shared_ptr<GenRunInfo> run = std::shared_ptr<GenRunInfo>());
+    /// @brief Constructor from ostream
+    WriterDOT(std::ostream& stream,std::shared_ptr<GenRunInfo> run =std:: shared_ptr<GenRunInfo>());
+    /// @brief Write event to file
+    ///
+    /// @param[in] evt Event to be serialized
     void write_event(const GenEvent &evt) override;
-
-    /** @brief Write the GenRunInfo object to file. */
-    void write_run_info();
-
-    /** @brief Close file stream */
+    /// @brief Return status of the stream
+    bool failed() override {
+        return (bool)m_file.rdstate();
+    }
+    /// @brief Close file stream
     void close() override;
+    /// @brief Close file stream
+    void set_style(const int& istyle) {
+        m_style=istyle;
+    };
 
-    /** @brief Get stream error state flag */
-    bool failed() override;
-//
-// Fields
-//
 private:
-    TFile* m_file;         //!< File handler
-    int    m_events_count; //!< Events count. Needed to generate unique object name
+    void allocate_buffer(); //!< allocates buffer for output
+    void flush(); //!< flushes output buffer
+    void forced_flush(); //!< flushes output buffer
+    std::ofstream m_file; //!< Output file
+    std::ostream* m_stream; //!< Output stream
+    int m_style; //!< style of dot file
+    char* m_buffer;  //!< Stream buffer
+    char* m_cursor;  //!< Cursor inside stream buffer
+    unsigned long m_buffer_size; //!< Buffer size
 };
-
-} // namespace HepMC3
-
+}
 #endif
```

### Comparing `HepMC3-3.2.5/rootIO/include/HepMC3/WriterRootTree.h` & `HepMC3-3.2.6/rootIO/include/HepMC3/WriterRootTree.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_WRITERROOTTREE_H
 #define HEPMC3_WRITERROOTTREE_H
 /**
  *  @file  WriterRootTree.h
  *  @brief Definition of \b class WriterRootTree
  *
```

### Comparing `HepMC3-3.2.5/rootIO/include/LinkDef.hh` & `HepMC3-3.2.6/rootIO/include/LinkDef.hh`

 * *Files identical despite different names*

### Comparing `HepMC3-3.2.5/rootIO/src/ReaderRoot.cc` & `HepMC3-3.2.6/rootIO/src/ReaderRoot.cc`

 * *Files 13% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file ReaderRoot.cc
  *  @brief Implementation of \b class ReaderRoot
  *
  */
 #include "HepMC3/ReaderRoot.h"
@@ -21,15 +21,15 @@
     if ( !m_file->IsOpen() ) {
         HEPMC3_ERROR("ReaderRoot: problem opening file: " << filename)
         return;
     }
 
     std::shared_ptr<GenRunInfo> ri = std::make_shared<GenRunInfo>();
 
-    GenRunInfoData *run = reinterpret_cast<GenRunInfoData*>(m_file->Get("GenRunInfoData"));
+    auto *run = reinterpret_cast<GenRunInfoData*>(m_file->Get("GenRunInfoData"));
 
     if (run) {
         ri->read_data(*run);
         delete run;
     }
 
     set_run_info(ri);
@@ -60,16 +60,16 @@
 
         const char *cl = key->GetClassName();
 
         if ( !cl ) continue;
         size_t geneventdata30 = strncmp(cl, "HepMC::GenEventData", 19);
         size_t geneventdata31 = strncmp(cl, "HepMC3::GenEventData", 20);
         if ( geneventdata31 == 0 || geneventdata30 == 0 ) {
-            if (geneventdata30 == 0) HEPMC3_WARNING("ReaderRoot::read_event: The object was written with HepMC3 version 3.0")
-                data = reinterpret_cast<GenEventData*>(key->ReadObj());
+            if (geneventdata30 == 0) {HEPMC3_WARNING("ReaderRoot::read_event: The object was written with HepMC3 version 3.0")}
+            data = reinterpret_cast<GenEventData*>(key->ReadObj());
             break;
         }
     }
 
     if ( !data ) {
         HEPMC3_ERROR("ReaderRoot: could not read event from root file")
         m_file->Close();
@@ -84,13 +84,11 @@
 }
 
 void ReaderRoot::close() {
     m_file->Close();
 }
 
 bool ReaderRoot::failed() {
-    if ( !m_file->IsOpen() ) return true;
-
-    return false;
+    return !m_file->IsOpen();
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/rootIO/src/ReaderRootTree.cc` & `HepMC3-3.2.6/rootIO/src/ReaderRootTree.cc`

 * *Files 8% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file ReaderRootTree.cc
  *  @brief Implementation of \b class ReaderRootTree
  *
  */
 #include "HepMC3/ReaderRootTree.h"
 #include "HepMC3/Units.h"
 #include "HepMC3/Version.h"
 namespace HepMC3
 {
 HEPMC3_DECLARE_READER_FILE(ReaderRootTree)
 
 ReaderRootTree::ReaderRootTree(const std::string &filename):
-    m_tree(0), m_events_count(0), m_tree_name("hepmc3_tree"), m_branch_name("hepmc3_event")
+    m_tree(nullptr), m_events_count(0), m_tree_name("hepmc3_tree"), m_branch_name("hepmc3_event")
 {
     m_file = TFile::Open(filename.c_str());
     if (!init()) return;
 }
 
 
 ReaderRootTree::ReaderRootTree(const std::string &filename, const std::string &treename, const std::string &branchname):
-    m_tree(0), m_events_count(0), m_tree_name(treename.c_str()), m_branch_name(branchname.c_str())
+    m_tree(nullptr), m_events_count(0), m_tree_name(treename), m_branch_name(branchname)
 {
     m_file = TFile::Open(filename.c_str());
     if (!init()) return;
 }
 
 bool ReaderRootTree::init()
 {
@@ -54,15 +54,15 @@
     }
     m_run_info_data = new GenRunInfoData();
     result = m_tree->SetBranchAddress("GenRunInfo", &m_run_info_data);
     if (result < 0)
     {
         HEPMC3_WARNING("ReaderRootTree: problem reading branch tree: GenRunInfo. Will attempt to read GenRunInfoData object.")
         std::shared_ptr<GenRunInfo> ri = std::make_shared<GenRunInfo>();
-        GenRunInfoData *run = reinterpret_cast<GenRunInfoData*>(m_file->Get("GenRunInfoData"));
+        auto *run = reinterpret_cast<GenRunInfoData*>(m_file->Get("GenRunInfoData"));
         if (run) {
             ri->read_data(*run);
             delete run;
             set_run_info(ri);
             HEPMC3_WARNING("ReaderRootTree::init The object was written with HepMC3 version 3.0")
         } else {
             HEPMC3_ERROR("ReaderRootTree: problem reading object GenRunInfoData")
@@ -72,16 +72,15 @@
     set_run_info(std::make_shared<GenRunInfo>());
     return true;
 }
 
 bool ReaderRootTree::skip(const int n)
 {
     m_events_count+=n;
-    if (m_events_count > m_tree->GetEntries()) return false;
-    return true;
+    return m_events_count <= m_tree->GetEntries();
 }
 
 
 
 bool ReaderRootTree::read_event(GenEvent& evt)
 {
     if (m_events_count > m_tree->GetEntries()) return false;
```

### Comparing `HepMC3-3.2.5/rootIO/src/Streamers.cc` & `HepMC3-3.2.6/rootIO/src/Streamers.cc`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file Streamers.cc
  *  @brief Implementation of \b methods GenEvent::Streamer and GenRunInfo::Streamer
  *
  */
```

### Comparing `HepMC3-3.2.5/rootIO/src/WriterRoot.cc` & `HepMC3-3.2.6/rootIO/src/WriterRoot.cc`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file WriterRoot.cc
  *  @brief Implementation of \b class WriterRoot
  *
  */
+#include <array>
 #include <cstdio>  // sprintf
 #include "HepMC3/WriterRoot.h"
 #include "HepMC3/Version.h"
 // ROOT header files
 #include "TFile.h"
 #include "TTree.h"
 
@@ -34,27 +35,28 @@
 void WriterRoot::write_event(const GenEvent &evt) {
     if ( !m_file->IsOpen() ) return;
 
     if ( !run_info() ) {
         set_run_info(evt.run_info());
         write_run_info();
     } else {
-        if ( evt.run_info() && run_info() != evt.run_info() )
+        if ( evt.run_info() && run_info() != evt.run_info() ) {
             HEPMC3_WARNING("WriterRoot::write_event: GenEvents contain "
                            "different GenRunInfo objects from - only the "
                            "first such object will be serialized.")
         }
+    }
 
     GenEventData data;
     evt.write_data(data);
 
-    char buf[16] = "";
-    sprintf(buf, "%15i", ++m_events_count);
+    std::array<char,16> buf;
+    snprintf(buf.data(), buf.size(), "%15i", ++m_events_count);
 
-    int nbytes = m_file->WriteObject(&data, buf);
+    int nbytes = m_file->WriteObject(&data, buf.data());
 
     if ( nbytes == 0 ) {
         HEPMC3_ERROR("WriterRoot: error writing event")
         m_file->Close();
     }
 }
 
@@ -73,13 +75,11 @@
 }
 
 void WriterRoot::close() {
     m_file->Close();
 }
 
 bool WriterRoot::failed() {
-    if ( !m_file->IsOpen() ) return true;
-
-    return false;
+    return !m_file->IsOpen();
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/rootIO/src/WriterRootTree.cc` & `HepMC3-3.2.6/rootIO/src/WriterRootTree.cc`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2019 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file WriterRootTree.cc
  *  @brief Implementation of \b class WriterRootTree
  *
  */
 #include <cstdio>  // sprintf
@@ -16,28 +16,28 @@
 #include "TTree.h"
 
 namespace HepMC3
 {
 HEPMC3_DECLARE_WRITER_FILE(WriterRootTree)
 
 WriterRootTree::WriterRootTree(const std::string &filename, std::shared_ptr<GenRunInfo> run):
-    m_tree(0),
+    m_tree(nullptr),
     m_events_count(0),
     m_tree_name("hepmc3_tree"),
     m_branch_name("hepmc3_event")
 {
     m_file = TFile::Open(filename.c_str(), "RECREATE");
     if (!init(run)) return;
 }
 
 WriterRootTree::WriterRootTree(const std::string &filename, const std::string &treename, const std::string &branchname, std::shared_ptr<GenRunInfo> run):
-    m_tree(0),
+    m_tree(nullptr),
     m_events_count(0),
-    m_tree_name(treename.c_str()),
-    m_branch_name(branchname.c_str())
+    m_tree_name(treename),
+    m_branch_name(branchname)
 {
     m_file = TFile::Open(filename.c_str(), "RECREATE");
     if (!init(run)) return;
 }
 
 bool WriterRootTree::init(std::shared_ptr<GenRunInfo> run )
 {
@@ -96,13 +96,11 @@
     m_file->Close();
     delete m_event_data;
     delete m_run_info_data;
 }
 
 bool WriterRootTree::failed()
 {
-    if ( !m_file->IsOpen() ) return true;
-
-    return false;
+    return !m_file->IsOpen();
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/search/CMakeLists.txt` & `HepMC3-3.2.6/search/CMakeLists.txt`

 * *Files 14% similar despite different names*

```diff
@@ -1,32 +1,63 @@
 #--------
 #-search
 #--------
-include_directories(${PROJECT_SOURCE_DIR}/include ${CMAKE_CURRENT_SOURCE_DIR}/include ${CMAKE_CURRENT_SOURCE_DIR} )
+
 set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
 set( hepmc3search_sources
 ${PROJECT_SOURCE_DIR}/search/src/Relatives.cc
 ${PROJECT_SOURCE_DIR}/search/src/Selector.cc)
 
 add_library(HepMC3search SHARED ${hepmc3search_sources})
-target_link_libraries(HepMC3search  HepMC3)
-target_include_directories(HepMC3search PUBLIC ${PROJECT_SOURCE_DIR}/include)
-target_link_libraries(HepMC3search  HepMC3)
-  set_target_properties(HepMC3search PROPERTIES OUTPUT_NAME HepMC3search   SOVERSION 4
-                                               ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>)
+target_link_libraries(HepMC3search HepMC3)
+set_target_properties(HepMC3search PROPERTIES OUTPUT_NAME HepMC3search   SOVERSION 5
+  ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+  LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+  RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+  EXPORT_NAME HepMC3::search)
+
+target_include_directories(HepMC3search PUBLIC
+  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+  $<INSTALL_INTERFACE:include>)
+
 # installs
-install(TARGETS HepMC3search DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT searchlibs)
+install(TARGETS HepMC3search
+  EXPORT HepMC3searchTargets
+  DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  COMPONENT searchlibs)
+
+# Alias for packages that include this as a sub-project but
+# want to use the namespaced target names
+add_library(HepMC3::search ALIAS HepMC3search)
+
 if (HEPMC3_BUILD_STATIC_LIBS)
-  add_library(HepMC3search_static STATIC  ${hepmc3search_sources})
-  target_include_directories(HepMC3search_static PUBLIC ${PROJECT_SOURCE_DIR}/include)
+  add_library(HepMC3search_static STATIC ${hepmc3search_sources})
+
+  target_include_directories(HepMC3search_static PUBLIC
+    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:include>)
+
   target_compile_definitions(HepMC3search_static PRIVATE HEPMC3search_NO_StandardSelector_EXPORTS HEPMC3search_NO_Relatives_EXPORTS)
-    set_target_properties(HepMC3search_static PROPERTIES OUTPUT_NAME HepMC3search-static
-                                               ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
-                                               RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>)
-  install(TARGETS HepMC3search_static DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT searchlibs)
+  set_target_properties(HepMC3search_static PROPERTIES OUTPUT_NAME HepMC3search-static
+    ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+    LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+    RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/outputs/${CMAKE_INSTALL_LIBDIR}/$<0:>
+    EXPORT_NAME HepMC3::search_static)
+  install(TARGETS HepMC3search_static
+    EXPORT HepMC3searchTargets
+    DESTINATION ${CMAKE_INSTALL_LIBDIR}
+    COMPONENT searchlibs)
+
+  # Alias for packages that include this as a sub-project but
+  # want to use the namespaced target names
+  add_library(HepMC3::search_static ALIAS HepMC3search_static)
 endif()
 
 install(DIRECTORY ${PROJECT_BINARY_DIR}/search/ DESTINATION  ${CMAKE_INSTALL_LIBDIR}  COMPONENT searchlibs  FILES_MATCHING PATTERN "CMakeFiles"  EXCLUDE  PATTERN "src"  EXCLUDE PATTERN "include"  EXCLUDE)
 install(DIRECTORY include/HepMC3 DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT searchdevel)
+
+set(CONFIG_INSTALL_DIR ${CMAKE_INSTALL_DATADIR}/HepMC3/cmake)
+install(EXPORT HepMC3searchTargets
+  DESTINATION ${CONFIG_INSTALL_DIR}
+  COMPONENT searchdevel)
```

### Comparing `HepMC3-3.2.5/search/include/HepMC3/AttributeFeature.h` & `HepMC3-3.2.6/search/include/HepMC3/AttributeFeature.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file AttributeFeature.h
 /// @brief Defines AttributeFeature for obtaining Filters to search by Attribute.
 /// @class HepMC3::AttributeFeature
 /// @brief AttributeFeature
```

### Comparing `HepMC3-3.2.5/search/include/HepMC3/Feature.h` & `HepMC3-3.2.6/search/include/HepMC3/Feature.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file Feature.h
 /// @brief Defines Feature interface for selecting Particles according to extracted Features.
 ///
 
 #ifndef HEPMC3_FEATURE_H
@@ -112,14 +112,22 @@
 protected:
     /// Hide the constructor so no one can use GenericFeature directly
     GenericFeature(Evaluator_type functor):m_internal(std::make_shared<Evaluator_type>(functor)) {}
 
     /// Hide the copy constructor
     GenericFeature(const GenericFeature &copy) : m_internal(copy.m_internal) {}
 
+    /** @brief Move constructor */
+    GenericFeature(GenericFeature && ) = default;
+    /** @brief = */
+    GenericFeature& operator=(const GenericFeature&) = default;
+    /** @brief = */
+    GenericFeature& operator=(GenericFeature&&) = default;
+
+
     /// @brief internal copy of func for evaluation
     /// on the heap so will persist in resulting Filters even if
     /// parent Feature object was destroyed
     EvaluatorPtr m_internal;
 };
 
 //////////////////////////////////////////////////////////////////////
```

### Comparing `HepMC3-3.2.5/search/include/HepMC3/Filter.h` & `HepMC3-3.2.6/search/include/HepMC3/Filter.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file Filter.h
 /// @brief Defines Filter operations for combingin Filters
 ///
 #ifndef HEPMC3_FILTER_H
 #define HEPMC3_FILTER_H
```

### Comparing `HepMC3-3.2.5/search/include/HepMC3/FilterAttribute.h` & `HepMC3-3.2.6/search/include/HepMC3/FilterAttribute.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 #ifndef HEPMC3_SEARCH_FILTEATTRIBUTE_H
 #define HEPMC3_SEARCH_FILTEATTRIBUTE_H
 ///
 /// @file FilterAttribute.h
 /// @brief Definition of \b class ATTRIBUTE
 ///
```

### Comparing `HepMC3-3.2.5/search/include/HepMC3/Relatives.h` & `HepMC3-3.2.6/search/include/HepMC3/Relatives.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file Relatives.h
 /// @brief Defines helper classes to extract relatives of an input GenParticle or GenVertex
 ///
 #ifndef HEPMC3_RELATIVES_H
 #define HEPMC3_RELATIVES_H
@@ -20,46 +20,46 @@
 #endif
 
 
 #include <vector>
 #include "HepMC3/GenParticle.h"
 #include "HepMC3/GenVertex.h"
 namespace HepMC3 {
-std::vector<HepMC3::GenParticlePtr>      children_particles(HepMC3::GenVertexPtr O);   ///< Return children particles
-std::vector<HepMC3::ConstGenParticlePtr> children_particles(HepMC3::ConstGenVertexPtr O); ///< Return children particles
-std::vector<HepMC3::GenVertexPtr>        children_vertices(HepMC3::GenParticlePtr O); ///< Return children vertices
-std::vector<HepMC3::ConstGenVertexPtr>   children_vertices(HepMC3::ConstGenParticlePtr O); ///< Return children vertices
-std::vector<HepMC3::GenParticlePtr>      grandchildren_particles(HepMC3::GenParticlePtr O);  ///< Return grandchildren particles
-std::vector<HepMC3::ConstGenParticlePtr> grandchildren_particles(HepMC3::ConstGenParticlePtr O);  ///< Return grandchildren particles
-std::vector<HepMC3::GenVertexPtr>        grandchildren_vertices(HepMC3::GenVertexPtr O);   ///< Return grandchildren vertices
-std::vector<HepMC3::ConstGenVertexPtr>   grandchildren_vertices(HepMC3::ConstGenVertexPtr O); ///< Return grandchildren vertices
-std::vector<HepMC3::GenParticlePtr>      parent_particles(HepMC3::GenVertexPtr O);  ///< Return parent particles
-std::vector<HepMC3::ConstGenParticlePtr> parent_particles(HepMC3::ConstGenVertexPtr O);   ///< Return parent particles
-std::vector<HepMC3::GenVertexPtr>        parent_vertices(HepMC3::GenParticlePtr O);   ///< Return parent vertices
-std::vector<HepMC3::ConstGenVertexPtr>   parent_vertices(HepMC3::ConstGenParticlePtr O);    ///< Return parent vertices
-std::vector<HepMC3::GenParticlePtr>      grandparent_particles(HepMC3::GenParticlePtr O);    ///< Return grandparent particles
-std::vector<HepMC3::ConstGenParticlePtr> grandparent_particles(HepMC3::ConstGenParticlePtr O);     ///< Return grandparent particles
-std::vector<HepMC3::GenVertexPtr>        grandparent_vertices(HepMC3::GenVertexPtr O);      ///< Return grandparent vertices
-std::vector<HepMC3::ConstGenVertexPtr>   grandparent_vertices(HepMC3::ConstGenVertexPtr O);       ///< Return grandparent vertices
-std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(HepMC3::ConstGenVertexPtr obj);       ///< Return descendant particles
-std::vector<HepMC3::GenParticlePtr>      descendant_particles(HepMC3::GenVertexPtr obj);       ///< Return descendant particles
-std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(HepMC3::ConstGenParticlePtr obj);       ///< Return descendant particles
-std::vector<HepMC3::GenParticlePtr>      descendant_particles(HepMC3::GenParticlePtr obj);       ///< Return descendant particles
-std::vector<HepMC3::ConstGenVertexPtr>   descendant_vertices(HepMC3::ConstGenParticlePtr obj);       ///< Return descendant vertices
-std::vector<HepMC3::GenVertexPtr>        descendant_vertices(HepMC3::GenParticlePtr obj);       ///< Return descendant vertices
-std::vector<HepMC3::ConstGenVertexPtr>   descendant_vertices(HepMC3::ConstGenVertexPtr obj);       ///< Return descendant vertices
-std::vector<HepMC3::GenVertexPtr>        descendant_vertices(HepMC3::GenVertexPtr obj);       ///< Return descendant vertices
-std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(HepMC3::ConstGenVertexPtr obj);       ///< Return ancestor particles
-std::vector<HepMC3::GenParticlePtr>      ancestor_particles(HepMC3::GenVertexPtr obj);      ///< Return ancestor particles
-std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(HepMC3::ConstGenParticlePtr obj);      ///< Return ancestor particles
-std::vector<HepMC3::GenParticlePtr>      ancestor_particles(HepMC3::GenParticlePtr obj);      ///< Return ancestor particles
-std::vector<HepMC3::ConstGenVertexPtr>   ancestor_vertices(HepMC3::ConstGenParticlePtr obj);      ///< Return ancestor vertices
-std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(HepMC3::GenParticlePtr obj);      ///< Return ancestor vertices
-std::vector<HepMC3::ConstGenVertexPtr>   ancestor_vertices(HepMC3::ConstGenVertexPtr obj);      ///< Return ancestor vertices
-std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(HepMC3::GenVertexPtr obj);      ///< Return ancestor vertices
+std::vector<HepMC3::GenParticlePtr>      children_particles(const HepMC3::GenVertexPtr& O);   ///< Return children particles
+std::vector<HepMC3::ConstGenParticlePtr> children_particles(const HepMC3::ConstGenVertexPtr& O); ///< Return children particles
+std::vector<HepMC3::GenVertexPtr>        children_vertices(const HepMC3::GenParticlePtr& O); ///< Return children vertices
+std::vector<HepMC3::ConstGenVertexPtr>   children_vertices(const HepMC3::ConstGenParticlePtr& O); ///< Return children vertices
+std::vector<HepMC3::GenParticlePtr>      grandchildren_particles(const HepMC3::GenParticlePtr& O);  ///< Return grandchildren particles
+std::vector<HepMC3::ConstGenParticlePtr> grandchildren_particles(const HepMC3::ConstGenParticlePtr& O);  ///< Return grandchildren particles
+std::vector<HepMC3::GenVertexPtr>        grandchildren_vertices(const HepMC3::GenVertexPtr& O);   ///< Return grandchildren vertices
+std::vector<HepMC3::ConstGenVertexPtr>   grandchildren_vertices(const HepMC3::ConstGenVertexPtr& O); ///< Return grandchildren vertices
+std::vector<HepMC3::GenParticlePtr>      parent_particles(const HepMC3::GenVertexPtr& O);  ///< Return parent particles
+std::vector<HepMC3::ConstGenParticlePtr> parent_particles(const HepMC3::ConstGenVertexPtr& O);   ///< Return parent particles
+std::vector<HepMC3::GenVertexPtr>        parent_vertices(const HepMC3::GenParticlePtr& O);   ///< Return parent vertices
+std::vector<HepMC3::ConstGenVertexPtr>   parent_vertices(const HepMC3::ConstGenParticlePtr& O);    ///< Return parent vertices
+std::vector<HepMC3::GenParticlePtr>      grandparent_particles(const HepMC3::GenParticlePtr& O);    ///< Return grandparent particles
+std::vector<HepMC3::ConstGenParticlePtr> grandparent_particles(const HepMC3::ConstGenParticlePtr& O);     ///< Return grandparent particles
+std::vector<HepMC3::GenVertexPtr>        grandparent_vertices(const HepMC3::GenVertexPtr& O);      ///< Return grandparent vertices
+std::vector<HepMC3::ConstGenVertexPtr>   grandparent_vertices(const HepMC3::ConstGenVertexPtr& O);       ///< Return grandparent vertices
+std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(const HepMC3::ConstGenVertexPtr& obj);       ///< Return descendant particles
+std::vector<HepMC3::GenParticlePtr>      descendant_particles(const HepMC3::GenVertexPtr& obj);       ///< Return descendant particles
+std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(const HepMC3::ConstGenParticlePtr& obj);       ///< Return descendant particles
+std::vector<HepMC3::GenParticlePtr>      descendant_particles(const HepMC3::GenParticlePtr& obj);       ///< Return descendant particles
+std::vector<HepMC3::ConstGenVertexPtr>   descendant_vertices(const HepMC3::ConstGenParticlePtr& obj);       ///< Return descendant vertices
+std::vector<HepMC3::GenVertexPtr>        descendant_vertices(const HepMC3::GenParticlePtr& obj);       ///< Return descendant vertices
+std::vector<HepMC3::ConstGenVertexPtr>   descendant_vertices(const HepMC3::ConstGenVertexPtr& obj);       ///< Return descendant vertices
+std::vector<HepMC3::GenVertexPtr>        descendant_vertices(const HepMC3::GenVertexPtr& obj);       ///< Return descendant vertices
+std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(const HepMC3::ConstGenVertexPtr& obj);       ///< Return ancestor particles
+std::vector<HepMC3::GenParticlePtr>      ancestor_particles(const HepMC3::GenVertexPtr& obj);      ///< Return ancestor particles
+std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(const HepMC3::ConstGenParticlePtr& obj);      ///< Return ancestor particles
+std::vector<HepMC3::GenParticlePtr>      ancestor_particles(const HepMC3::GenParticlePtr& obj);      ///< Return ancestor particles
+std::vector<HepMC3::ConstGenVertexPtr>   ancestor_vertices(const HepMC3::ConstGenParticlePtr& obj);      ///< Return ancestor vertices
+std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(const HepMC3::GenParticlePtr& obj);      ///< Return ancestor vertices
+std::vector<HepMC3::ConstGenVertexPtr>   ancestor_vertices(const HepMC3::ConstGenVertexPtr& obj);      ///< Return ancestor vertices
+std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(const HepMC3::GenVertexPtr& obj);      ///< Return ancestor vertices
 }
 
 
 
 namespace HepMC3 {
 
 /// forward declare the Relatives interface in which _parents and _children are wrapped
@@ -144,17 +144,17 @@
 public:
  std::vector<ConstGenParticlePtr> operator()(ConstGenVertexPtr input)const  { return descendant_particles(input);}
  std::vector<GenParticlePtr> operator()(GenVertexPtr input)const  { return descendant_particles(input);}
  std::vector<ConstGenParticlePtr> operator()(ConstGenParticlePtr input)const  { return descendant_particles(input);}
  std::vector<GenParticlePtr> operator()(GenParticlePtr input) const { return descendant_particles(input);}
 };
 
-/// alias 
+/// alias
 using Parents  = SearchParents;
-/// alias 
+/// alias
 using Children = SearchChildren;
 /// Ancestors
 using Ancestors = SearchAncestors;
 /// Descendants
 using Descendants = SearchDescendants;
 
 #else
```

### Comparing `HepMC3-3.2.5/search/include/HepMC3/Selector.h` & `HepMC3-3.2.6/search/include/HepMC3/Selector.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file Selector.h
 /// @brief definition of /b Selector class
 ///
 #ifndef HEPMC3_SELECTOR_H
 #define HEPMC3_SELECTOR_H
```

### Comparing `HepMC3-3.2.5/search/src/Relatives.cc` & `HepMC3-3.2.6/search/src/Relatives.cc`

 * *Files 10% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file Relatives.cc
 /// @brief Implementation of \b Relatives class
 ///
 #include "HepMC3/Relatives.h"
 
@@ -15,215 +15,217 @@
 #ifdef _MSC_VER
 const Ancestors   Relatives::ANCESTORS;
 const Descendants Relatives::DESCENDANTS;
 #else
 thread_local const Ancestors   Relatives::ANCESTORS;
 thread_local const Descendants Relatives::DESCENDANTS;
 #endif
-}
+} // namespace HepMC3
 
 namespace HepMC3 {
 /// @brief Returns children of vertex, i.e. outgoing particles.
-std::vector<HepMC3::GenParticlePtr>      children(HepMC3::GenVertexPtr O) {
+std::vector<HepMC3::GenParticlePtr>      children(const HepMC3::GenVertexPtr& O) {
     if (O) return O->particles_out();
-    return  std::vector<HepMC3::GenParticlePtr>();
+    return  {};
 }
 /// @brief Returns children of const vertex, i.e. outgoing particles.
-std::vector<HepMC3::ConstGenParticlePtr> children(HepMC3::ConstGenVertexPtr O) {
+std::vector<HepMC3::ConstGenParticlePtr> children(const HepMC3::ConstGenVertexPtr& O) {
     if (O) return O->particles_out();
-    return  std::vector<HepMC3::ConstGenParticlePtr>();
+    return  {};
 }
 /// @brief Returns children of particle, i.e. the end vertex.
-std::vector<HepMC3::GenVertexPtr>        children(HepMC3::GenParticlePtr O) {
+std::vector<HepMC3::GenVertexPtr>        children(const HepMC3::GenParticlePtr& O) {
     std::vector<HepMC3::GenVertexPtr> result;
-    if (O->end_vertex()) result.push_back(O->end_vertex());
+    if (O->end_vertex()) result.emplace_back(O->end_vertex());
     return result;
 }
 /// @brief Returns children of const particle, i.e. the end vertex.
-std::vector<HepMC3::ConstGenVertexPtr>   children(HepMC3::ConstGenParticlePtr O) {
+std::vector<HepMC3::ConstGenVertexPtr>   children(const HepMC3::ConstGenParticlePtr& O) {
     std::vector<HepMC3::ConstGenVertexPtr> result;
-    if (O->end_vertex()) result.push_back(O->end_vertex());
+    if (O->end_vertex()) result.emplace_back(O->end_vertex());
     return result;
 }
 /// @brief Returns grandchildren of particle, i.e. the outgoing particles of the end vertex.
-std::vector<HepMC3::GenParticlePtr>      grandchildren(HepMC3::GenParticlePtr O) {
+std::vector<HepMC3::GenParticlePtr>      grandchildren(const HepMC3::GenParticlePtr& O) {
     if (O) if (O->end_vertex()) return O->end_vertex()->particles_out();
-    return std::vector<HepMC3::GenParticlePtr> ();
+    return {};
 }
 /// @brief Returns grandchildren of const particle, i.e. the outgoing particles of the end vertex.
-std::vector<HepMC3::ConstGenParticlePtr> grandchildren(HepMC3::ConstGenParticlePtr O) {
+std::vector<HepMC3::ConstGenParticlePtr> grandchildren(const HepMC3::ConstGenParticlePtr& O) {
     if (O) if (O->end_vertex()) return O->end_vertex()->particles_out();
-    return std::vector<HepMC3::ConstGenParticlePtr> ();
+    return {};
 }
 /// @brief Returns grandchildren of vertex, i.e. the end vertices of the outgoing particles.
-std::vector<HepMC3::GenVertexPtr>        grandchildren(HepMC3::GenVertexPtr O) {
+std::vector<HepMC3::GenVertexPtr>        grandchildren(const HepMC3::GenVertexPtr& O) {
     std::vector<HepMC3::GenVertexPtr> result;
-    if (O) for (auto o: O->particles_out()) if (o->end_vertex()) result.push_back(o->end_vertex());
+    if (O) for (const auto&o: O->particles_out()) if (o->end_vertex()) result.emplace_back(o->end_vertex());
     return result;
 }
 /// @brief Returns grandchildren of const vertex, i.e. the end vertices of the outgoing particles.
-std::vector<HepMC3::ConstGenVertexPtr>   grandchildren(HepMC3::ConstGenVertexPtr O) {
+std::vector<HepMC3::ConstGenVertexPtr>   grandchildren(const HepMC3::ConstGenVertexPtr& O) {
     std::vector<HepMC3::ConstGenVertexPtr> result;
-    if (O)  for (auto o:O->particles_out()) if (o->end_vertex()) result.push_back(o->end_vertex());
+    if (O)  for (const auto& o:O->particles_out()) if (o->end_vertex()) result.emplace_back(o->end_vertex());
     return result;
 }
 /// @brief Returns parents of vertex, i.e. incoming particles.
-std::vector<HepMC3::GenParticlePtr>      parents(HepMC3::GenVertexPtr O) {
+std::vector<HepMC3::GenParticlePtr>      parents(const HepMC3::GenVertexPtr& O) {
     if (O) return O->particles_in();
-    return  std::vector<GenParticlePtr>();
+    return  {};
 }
 /// @brief Returns parents of const vertex, i.e. incoming particles.
-std::vector<HepMC3::ConstGenParticlePtr> parents(HepMC3::ConstGenVertexPtr O) {
+std::vector<HepMC3::ConstGenParticlePtr> parents(const HepMC3::ConstGenVertexPtr& O) {
     if (O) return O->particles_in();
-    return  std::vector<HepMC3::ConstGenParticlePtr>();
+    return  {};
 }
 /// @brief Returns parents of particle, i.e. production vertex.
-std::vector<HepMC3::GenVertexPtr>        parents(HepMC3::GenParticlePtr O) {
+std::vector<HepMC3::GenVertexPtr>        parents(const HepMC3::GenParticlePtr& O) {
     std::vector<HepMC3::GenVertexPtr> result;
-    if (O->production_vertex()) result.push_back(O->production_vertex());
+    if (O->production_vertex()) result.emplace_back(O->production_vertex());
     return result;
 }
 /// @brief Returns parents of const particle, i.e. production vertex.
-std::vector<HepMC3::ConstGenVertexPtr>   parents(HepMC3::ConstGenParticlePtr O) {
+std::vector<HepMC3::ConstGenVertexPtr>   parents(const HepMC3::ConstGenParticlePtr& O) {
     std::vector<HepMC3::ConstGenVertexPtr> result;
-    if (O->production_vertex()) result.push_back(O->production_vertex());
+    if (O->production_vertex()) result.emplace_back(O->production_vertex());
     return result;
 }
 /// @brief Returns grandparents of particle, i.e. incoming particles of production vertex.
-std::vector<HepMC3::GenParticlePtr>      grandparents(HepMC3::GenParticlePtr O) {
+std::vector<HepMC3::GenParticlePtr>      grandparents(const HepMC3::GenParticlePtr& O) {
     if (O) if (O->production_vertex()) return O->production_vertex()->particles_in();
-    return std::vector<HepMC3::GenParticlePtr> ();
+    return {};
 }
 /// @brief Returns grandparents of const particle, i.e. incoming particles of production vertex.
-std::vector<HepMC3::ConstGenParticlePtr> grandparents(HepMC3::ConstGenParticlePtr O) {
+std::vector<HepMC3::ConstGenParticlePtr> grandparents(const HepMC3::ConstGenParticlePtr& O) {
     if (O) if (O->production_vertex()) return O->production_vertex()->particles_in();
-    return std::vector<HepMC3::ConstGenParticlePtr> ();
+    return {};
 }
 /// @brief Returns grandparents of vertex, i.e. production vertices of incoming particles.
-std::vector<HepMC3::GenVertexPtr>        grandparents(HepMC3::GenVertexPtr O) {
+std::vector<HepMC3::GenVertexPtr>        grandparents(const HepMC3::GenVertexPtr& O) {
     std::vector<HepMC3::GenVertexPtr> result;
-    if (O) for (auto o: O->particles_in()) if (o->production_vertex()) result.push_back(o->production_vertex());
+    if (O) for (const auto& o: O->particles_in()) if (o->production_vertex()) result.emplace_back(o->production_vertex());
     return result;
 }
 /// @brief Returns grandparents of const vertex, i.e. production vertices of incoming particles.
-std::vector<HepMC3::ConstGenVertexPtr>   grandparents(HepMC3::ConstGenVertexPtr O) {
+std::vector<HepMC3::ConstGenVertexPtr>   grandparents(const HepMC3::ConstGenVertexPtr& O) {
     std::vector<HepMC3::ConstGenVertexPtr> result;
-    if (O)  for (auto o:O->particles_in()) if (o->end_vertex()) result.push_back(o->production_vertex());
+    if (O)  for (const auto& o: O->particles_in()) if (o->end_vertex()) result.emplace_back(o->production_vertex());
     return result;
 }
 /// @brief Returns descendands of the same type, i.e. vertices for vertex and particles for particle
-template <class O>  std::vector<O> descendants_of_same_type(O obj)
+template <class O>  std::vector<O> descendants_of_same_type(const O& obj)
 {
     std::vector<O>  result = grandchildren(obj);
     size_t gc = 0;
+    std::vector<O>  temp;
     for (;;)
     {
-        std::vector<O>  temp;
+        temp.clear();
         for (; gc < result.size(); gc++)
         {
             auto  temp0 = grandchildren(result[gc]);
-            temp.insert(temp.end(), temp0.begin(), temp0.end());
+            std::move(temp0.begin(), temp0.end(), std::back_inserter(temp));
         }
-        for (auto p2: temp) if (std::find(result.begin(), result.end(), p2) == result.end()) result.push_back(p2);
+        for (const auto& p2: temp) if (std::find(result.begin(), result.end(), p2) == result.end()) result.emplace_back(p2);
         if (gc >= result.size()) break;
     }
     return result;
 }
 /// @brief Returns descendands of the other type, i.e. vertices for  particle and particles for vertex
-template <class O, class R>  std::vector<R> descendants_of_other_type(O obj)
+template <class O, class R>  std::vector<R> descendants_of_other_type(const O& obj)
 {
     std::vector<R> localchildren = children(obj);
     std::vector<R>  result = localchildren;
-    for (auto c: localchildren)
+    for (const auto& c: localchildren)
     {
         std::vector<R> desc = descendants_of_same_type(c);
-        for (auto d: desc) if (std::find(result.begin(), result.end(), d) == result.end()) result.push_back(d);
+        for (const auto& d: desc) if (std::find(result.begin(), result.end(), d) == result.end()) result.emplace_back(d);
     }
     return result;
 }
 /// @brief Returns ancestors of the same type, i.e. vertices for vertex and particles for particle
-template <class O>  std::vector<O> ancestors_of_same_type(O obj)
+template <class O>  std::vector<O> ancestors_of_same_type(const O& obj)
 {
     std::vector<O>  result = grandparents(obj);
     size_t gc = 0;
+    std::vector<O>  temp;
     for (;;)
     {
-        std::vector<O>  temp;
+        temp.clear();
         for (; gc < result.size(); gc++)
         {
             auto  temp0 = grandparents(result[gc]);
-            temp.insert(temp.end(), temp0.begin(), temp0.end());
+            std::move(temp0.begin(), temp0.end(), std::back_inserter(temp));
         }
-        for (auto p2: temp) if (std::find(result.begin(), result.end(), p2) == result.end()) result.push_back(p2);
+        for (const auto& p2: temp) if (std::find(result.begin(), result.end(), p2) == result.end()) result.emplace_back(p2);
         if (gc >= result.size()) break;
     }
     return result;
 }
 /// @brief Returns ancestors of the other type, i.e. vertices for  particle and particles for vertex
-template <class O, class R>  std::vector<R> ancestors_of_other_type(O obj)
+template <class O, class R>  std::vector<R> ancestors_of_other_type(const O& obj)
 {
     std::vector<R> localparents = parents(obj);
     std::vector<R>  result = localparents;
-    for (auto c: localparents)
+    for (const auto& c: localparents)
     {
         std::vector<R> desc = ancestors_of_same_type(c);
-        for (auto d: desc) if (std::find(result.begin(), result.end(), d) == result.end()) result.push_back(d);
+        for (const auto& d: desc) if (std::find(result.begin(), result.end(), d) == result.end()) result.emplace_back(d);
     }
     return result;
 }
 
-std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(HepMC3::ConstGenVertexPtr obj) {
+std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(const HepMC3::ConstGenVertexPtr& obj) {
     return  descendants_of_other_type<HepMC3::ConstGenVertexPtr, HepMC3::ConstGenParticlePtr>(obj);
 }
-std::vector<HepMC3::GenParticlePtr> descendant_particles(HepMC3::GenVertexPtr obj) {
+std::vector<HepMC3::GenParticlePtr> descendant_particles(const HepMC3::GenVertexPtr& obj) {
     return descendants_of_other_type<HepMC3::GenVertexPtr, HepMC3::GenParticlePtr>(obj);
 }
 
-std::vector<ConstGenVertexPtr> descendant_vertices(HepMC3::ConstGenParticlePtr obj) {
+std::vector<ConstGenVertexPtr> descendant_vertices(const HepMC3::ConstGenParticlePtr& obj) {
     return descendants_of_other_type<HepMC3::ConstGenParticlePtr, HepMC3::ConstGenVertexPtr>(obj);
 }
-std::vector<HepMC3::GenVertexPtr> descendant_vertices(HepMC3::GenParticlePtr obj) {
+std::vector<HepMC3::GenVertexPtr> descendant_vertices(const HepMC3::GenParticlePtr& obj) {
     return descendants_of_other_type<HepMC3::GenParticlePtr, HepMC3::GenVertexPtr>(obj);
 }
 
-std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(HepMC3::ConstGenVertexPtr obj) {
+std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(const HepMC3::ConstGenVertexPtr& obj) {
     return  ancestors_of_other_type<HepMC3::ConstGenVertexPtr, HepMC3::ConstGenParticlePtr>(obj);
 }
-std::vector<HepMC3::GenParticlePtr> ancestor_particles(HepMC3::GenVertexPtr obj) {
+std::vector<HepMC3::GenParticlePtr> ancestor_particles(const HepMC3::GenVertexPtr& obj) {
     return ancestors_of_other_type<HepMC3::GenVertexPtr, HepMC3::GenParticlePtr>(obj);
 }
 
-std::vector<HepMC3::ConstGenVertexPtr> ancestor_vertices(HepMC3::ConstGenParticlePtr obj) {
+std::vector<HepMC3::ConstGenVertexPtr> ancestor_vertices(const HepMC3::ConstGenParticlePtr& obj) {
     return ancestors_of_other_type<HepMC3::ConstGenParticlePtr, HepMC3::ConstGenVertexPtr>(obj);
 }
-std::vector<HepMC3::GenVertexPtr> ancestor_vertices(HepMC3::GenParticlePtr obj) {
+std::vector<HepMC3::GenVertexPtr> ancestor_vertices(const HepMC3::GenParticlePtr& obj) {
     return ancestors_of_other_type<HepMC3::GenParticlePtr, HepMC3::GenVertexPtr>(obj);
 }
 
 
-std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(HepMC3::ConstGenParticlePtr obj)  { return descendants_of_same_type(obj); }
-std::vector<HepMC3::GenParticlePtr>      descendant_particles(HepMC3::GenParticlePtr obj)       { return descendants_of_same_type(obj); }
-std::vector<HepMC3::ConstGenVertexPtr>   descendant_vertices(HepMC3::ConstGenVertexPtr obj)     { return descendants_of_same_type(obj); }
-std::vector<HepMC3::GenVertexPtr>        descendant_vertices(HepMC3::GenVertexPtr obj)          { return descendants_of_same_type(obj); }
-std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(HepMC3::ConstGenParticlePtr obj)    { return ancestors_of_same_type(obj); }
-std::vector<HepMC3::GenParticlePtr>      ancestor_particles(HepMC3::GenParticlePtr obj)         { return ancestors_of_same_type(obj); }
-std::vector<HepMC3::ConstGenVertexPtr>   ancestor_vertices(HepMC3::ConstGenVertexPtr obj)       { return ancestors_of_same_type(obj); }
-std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(HepMC3::GenVertexPtr obj)            { return ancestors_of_same_type(obj); }
-std::vector<HepMC3::GenParticlePtr>      children_particles(HepMC3::GenVertexPtr O)             { return children(O); }
-std::vector<HepMC3::ConstGenParticlePtr> children_particles(HepMC3::ConstGenVertexPtr O)        { return children(O); }
-std::vector<HepMC3::GenVertexPtr>        children_vertices(HepMC3::GenParticlePtr O)            { return children(O); }
-std::vector<HepMC3::ConstGenVertexPtr>   children_vertices(HepMC3::ConstGenParticlePtr O)       { return children(O); }
-std::vector<HepMC3::GenParticlePtr>      grandchildren_particles(HepMC3::GenParticlePtr O)      { return grandchildren(O); }
-std::vector<HepMC3::ConstGenParticlePtr> grandchildren_particles(HepMC3::ConstGenParticlePtr O) { return grandchildren(O); }
-std::vector<HepMC3::GenVertexPtr>        grandchildren_vertices(HepMC3::GenVertexPtr O)         { return grandchildren(O); }
-std::vector<HepMC3::ConstGenVertexPtr>   grandchildren_vertices(HepMC3::ConstGenVertexPtr O)    { return grandchildren(O); }
-std::vector<HepMC3::GenParticlePtr>      parent_particles(HepMC3::GenVertexPtr O)               { return parents(O); }
-std::vector<HepMC3::ConstGenParticlePtr> parent_particles(HepMC3::ConstGenVertexPtr O)          { return parents(O); }
-std::vector<HepMC3::GenVertexPtr>        parent_vertices(HepMC3::GenParticlePtr O)              { return parents(O); }
-std::vector<HepMC3::ConstGenVertexPtr>   parent_vertices(HepMC3::ConstGenParticlePtr O)         { return parents(O); }
-std::vector<HepMC3::GenParticlePtr>      grandparent_particles(HepMC3::GenParticlePtr O)        { return grandparents(O); }
-std::vector<HepMC3::ConstGenParticlePtr> grandparent_particles(HepMC3::ConstGenParticlePtr O)   { return grandparents(O); }
-std::vector<HepMC3::GenVertexPtr>        grandparent_vertices(HepMC3::GenVertexPtr O)           { return grandparents(O); }
-std::vector<HepMC3::ConstGenVertexPtr>   grandparent_vertices(HepMC3::ConstGenVertexPtr O)      { return grandparents(O); }
+std::vector<HepMC3::ConstGenParticlePtr> descendant_particles(const HepMC3::ConstGenParticlePtr& obj)  { return descendants_of_same_type(obj); }
+std::vector<HepMC3::GenParticlePtr>      descendant_particles(const HepMC3::GenParticlePtr& obj)       { return descendants_of_same_type(obj); }
+std::vector<HepMC3::ConstGenVertexPtr>   descendant_vertices(const HepMC3::ConstGenVertexPtr& obj)     { return descendants_of_same_type(obj); }
+std::vector<HepMC3::GenVertexPtr>        descendant_vertices(const HepMC3::GenVertexPtr& obj)          { return descendants_of_same_type(obj); }
+std::vector<HepMC3::ConstGenParticlePtr> ancestor_particles(const HepMC3::ConstGenParticlePtr& obj)    { return ancestors_of_same_type(obj); }
+std::vector<HepMC3::GenParticlePtr>      ancestor_particles(const HepMC3::GenParticlePtr& obj)         { return ancestors_of_same_type(obj); }
+std::vector<HepMC3::ConstGenVertexPtr>   ancestor_vertices(const HepMC3::ConstGenVertexPtr& obj)       { return ancestors_of_same_type(obj); }
+std::vector<HepMC3::GenVertexPtr>        ancestor_vertices(const HepMC3::GenVertexPtr& obj)            { return ancestors_of_same_type(obj); }
+std::vector<HepMC3::GenParticlePtr>      children_particles(const HepMC3::GenVertexPtr& O)             { return children(O); }
+std::vector<HepMC3::ConstGenParticlePtr> children_particles(const HepMC3::ConstGenVertexPtr& O)        { return children(O); }
+std::vector<HepMC3::GenVertexPtr>        children_vertices(const HepMC3::GenParticlePtr& O)            { return children(O); }
+std::vector<HepMC3::ConstGenVertexPtr>   children_vertices(const HepMC3::ConstGenParticlePtr& O)       { return children(O); }
+std::vector<HepMC3::GenParticlePtr>      grandchildren_particles(const HepMC3::GenParticlePtr& O)      { return grandchildren(O); }
+std::vector<HepMC3::ConstGenParticlePtr> grandchildren_particles(const HepMC3::ConstGenParticlePtr& O) { return grandchildren(O); }
+std::vector<HepMC3::GenVertexPtr>        grandchildren_vertices(const HepMC3::GenVertexPtr& O)         { return grandchildren(O); }
+std::vector<HepMC3::ConstGenVertexPtr>   grandchildren_vertices(const HepMC3::ConstGenVertexPtr& O)    { return grandchildren(O); }
+std::vector<HepMC3::GenParticlePtr>      parent_particles(const HepMC3::GenVertexPtr& O)               { return parents(O); }
+std::vector<HepMC3::ConstGenParticlePtr> parent_particles(const HepMC3::ConstGenVertexPtr& O)          { return parents(O); }
+std::vector<HepMC3::GenVertexPtr>        parent_vertices(const HepMC3::GenParticlePtr& O)              { return parents(O); }
+std::vector<HepMC3::ConstGenVertexPtr>   parent_vertices(const HepMC3::ConstGenParticlePtr& O)         { return parents(O); }
+std::vector<HepMC3::GenParticlePtr>      grandparent_particles(const HepMC3::GenParticlePtr& O)        { return grandparents(O); }
+std::vector<HepMC3::ConstGenParticlePtr> grandparent_particles(const HepMC3::ConstGenParticlePtr& O)   { return grandparents(O); }
+std::vector<HepMC3::GenVertexPtr>        grandparent_vertices(const HepMC3::GenVertexPtr& O)           { return grandparents(O); }
+std::vector<HepMC3::ConstGenVertexPtr>   grandparent_vertices(const HepMC3::ConstGenVertexPtr& O)      { return grandparents(O); }
 
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/search/src/Selector.cc` & `HepMC3-3.2.6/search/src/Selector.cc`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file Selector.cc
 /// @brief Implementation  of Selector wrappers
 ///
 #include "HepMC3/Selector.h"
 
@@ -21,10 +21,10 @@
 const SelectorWrapper<double> StandardSelector::MASS     = SelectorWrapper<double>([](ConstGenParticlePtr p)->double{return p->momentum().m();});
 
 ConstSelectorPtr abs(const Selector &input)
 {
     return input.abs();
 }
 
-AttributeFeature Selector::ATTRIBUTE(const std::string &name) {return AttributeFeature(name);}
+AttributeFeature Selector::ATTRIBUTE(const std::string &name) {return {name};}
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/setup.py` & `HepMC3-3.2.6/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -158,15 +158,15 @@
                    os.path.normpath( "outputs/" + lib + "/libHepMC3search.dylib"),
                    os.path.normpath( "outputs/" + lib + "/libHepMC3-static.a"),
                    os.path.normpath( "outputs/" + lib + "/libHepMC3search-static.a"),
                 ],
             )
         ]
     if ps == "Windows" :
-        if  (len(os.environ.get('MSYSTEM')) == 0):
+        if  (os.environ.get('MSYSTEM') is None):
           return [
             (
                 lib,
                 [
                     os.path.normpath("outputs/" + lib + "/HepMC3.dll"),
                     os.path.normpath("outputs/" + lib + "/HepMC3search.dll"),
                     os.path.normpath( "outputs/" + lib + "/HepMC3search-static.lib"),
@@ -290,15 +290,15 @@
             cmake_args.append("-DPython_INCLUDE_DIR=" + sysconfig.get_path("include"))
             cmake_args.append("-DPython_ARTIFACTS_INTERACTIVE:BOOL=TRUE")
 
         if ps == "Linux":
             if bits == "64bit":
                 cmake_args.append("-DLIB_SUFFIX=64")
                 cmake_args.append("-DCMAKE_INSTALL_LIBDIR=lib64")
-        if ps == "Windows" and (len(os.environ.get('MSYSTEM')) == 0):
+        if ps == "Windows" and (os.environ.get('MSYSTEM') is None):
             # FIXME: detect arch
             cmake_args.append("-Thost=x64")
             cmake_args.append("-A")
             cmake_args.append("x64")
         cmake_args.append("-DPython"+str(sys.version_info[0])+"_ROOT_DIR="+ os.path.dirname(sysconfig.get_path("scripts")))
         self.spawn([cmake_exe, str(cwd)] + cmake_args)
 
@@ -307,16 +307,15 @@
             self.spawn([cmake_exe, "--build", "."] + build_args)
             ctest_args = []
             v = sys.version_info
             if ps == "Windows":
                 ctest_args.append("-C")
                 ctest_args.append("Debug")
                 ctest_args.append("-j1")
-            # Travis+Windows bug?
-            if ps != "Darwin" and not (ps == "Windows" and v[0] == 3 and v[1] == 8):
+            if ps != "Darwin" and (os.environ.get('MSYSTEM') is  None):
                 self.spawn([ctest_exe, ".", "--output-on-failure"] + ctest_args)
         os.chdir(str(cwd))
 
 
 def local_find_packages():
     os.mkdir("pyHepMC3")
     return ["pyHepMC3"]
```

### Comparing `HepMC3-3.2.5/src/GenCrossSection.cc` & `HepMC3-3.2.6/src/GenCrossSection.cc`

 * *Files 16% similar despite different names*

```diff
@@ -1,113 +1,124 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file GenCrossSection.cc
  *  @brief Implementation of \b class GenCrossSection
  *
  */
-#include <cstring> // memcmp
 #include <cstdlib> // atoi
-#include <sstream>
+#include <cstring> // memcmp
 #include <iomanip>
+#include <sstream>
+
 #include "HepMC3/GenCrossSection.h"
 #include "HepMC3/GenEvent.h"
 
 
 namespace HepMC3 {
 
 
-int GenCrossSection::windx(std::string wName) const {
-    if ( !event() || !event()->run_info() ) return 0;
+int GenCrossSection::windx(const std::string& wName) const {
+    if ( !event() || !event()->run_info() ) {return 0;}
     return event()->run_info()->weight_index(wName);
 }
 
 void GenCrossSection::set_cross_section(const double& xs, const double& xs_err, const long& n_acc, const long& n_att) {
     double cross_section       = xs;
     double cross_section_error = xs_err;
     accepted_events     = n_acc;
     attempted_events    = n_att;
-    size_t N = 1;
-    if ( event() ) N = std::max(event()->weights().size(), N);
+    size_t N = std::max( event() ? event()->weights().size() : 0, size_t{1});
     cross_sections = std::vector<double>(N, cross_section);
     cross_section_errors = std::vector<double>(N, cross_section_error);
 }
 
 
+void GenCrossSection::set_cross_section(const std::vector<double>& xs, const std::vector<double>& xs_err, const long& n_acc, const long& n_att) {
+    cross_sections       = xs;
+    cross_section_errors = xs_err;
+    accepted_events     = n_acc;
+    attempted_events    = n_att;
+}
+
+
 bool GenCrossSection::from_string(const std::string &att) {
     const char *cursor = att.data();
     cross_sections.clear();
     cross_section_errors.clear();
 
 
     double cross_section = atof(cursor);
-    cross_sections.push_back(cross_section);
+    cross_sections.emplace_back(cross_section);
 
-    if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
+    if ( !(cursor = strchr(cursor+1, ' ')) ) {return false;}
     double cross_section_error = atof(cursor);
-    cross_section_errors.push_back(cross_section_error);
+    cross_section_errors.emplace_back(cross_section_error);
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) {accepted_events = -1; attempted_events = -1;}
     else
     {
         accepted_events = atoi(cursor);
-        if ( !(cursor = strchr(cursor+1, ' ')) ) attempted_events = -1;
-        else attempted_events = atoi(cursor);
+        if ( !(cursor = strchr(cursor+1, ' ')) ) { attempted_events = -1; }
+        else { attempted_events = atoi(cursor); }
     }
-    size_t N = 1;
-    if ( event() ) N = std::max(event()->weights().size(), N);
+    size_t N = event() ? std::max(event()->weights().size(), size_t{1}) : size_t{1};
     const size_t max_n_cross_sections = 1000;
     while (cross_sections.size() < max_n_cross_sections) {
         if ( !(cursor = strchr(cursor+1, ' ')) ) break;
-        cross_sections.push_back(atof(cursor));
+        cross_sections.emplace_back(atof(cursor));
         if ( !(cursor = strchr(cursor+1, ' ')) ) break;
-        cross_section_errors.push_back(atof(cursor));
+        cross_section_errors.emplace_back(atof(cursor));
     }
     if (cross_sections.size() >= max_n_cross_sections) {
         HEPMC3_WARNING("GenCrossSection::from_string: too many optional cross-sections  N=" << cross_sections.size() << " or ill-formed input:" << att)
     }
     // Use the default values to fill the vector to the size of N.
     size_t oldsize = cross_sections.size();
-    for (size_t i = oldsize; i < N; i++) {cross_sections.push_back(cross_section); cross_section_errors.push_back(cross_section_error);}
-
+    if (oldsize != N) {
+        HEPMC3_WARNING("GenCrossSection::from_string: the number of cross-sections cross_sections.size()=" << cross_sections.size() << " does not match the number of weights" << event()->weights().size())
+    }
+    for (size_t i = oldsize; i < N; i++) {cross_sections.emplace_back(cross_section); cross_section_errors.emplace_back(cross_section_error);}
     return true;
 }
 
 bool GenCrossSection::to_string(std::string &att) const {
     std::ostringstream os;
 
     os << std::setprecision(8) << std::scientific
-       << (cross_sections.size()>0?cross_sections.at(0):0.0) << " "
-       << (cross_section_errors.size()>0?cross_section_errors.at(0):0.0) << " "
+       << (cross_sections.empty()?0.0:cross_sections.at(0)) << " "
+       << (cross_section_errors.empty()?0.0:cross_section_errors.at(0)) << " "
        << accepted_events << " "
        << attempted_events;
-
-    for (size_t i = 1; i < cross_sections.size(); ++i )
+    if ( event() && event()->weights().size() != cross_sections.size() ) {
+        HEPMC3_WARNING("GenCrossSection::to_string: the number of cross-sections cross_sections.size()=" << cross_sections.size() << " does not match the number of weights" << event()->weights().size())
+    }
+    for (size_t i = 1; i < cross_sections.size(); ++i ) {
         os << " " << cross_sections.at(i)
            << " " << (cross_section_errors.size()>i?cross_section_errors.at(i):0.0);
-
+    }
     att = os.str();
 
     return true;
 }
 
 bool GenCrossSection::operator==(const GenCrossSection& a) const {
     return ( memcmp( (void*)this, (void*) &a, sizeof(class GenCrossSection) ) == 0 );
 }
 
 bool GenCrossSection::operator!=(const GenCrossSection& a) const {
     return !( a == *this );
 }
 
 bool GenCrossSection::is_valid() const {
-    if ( cross_sections.size()       == 0 ) return false;
-    if ( cross_section_errors.size() == 0 ) return false;
-    if ( cross_section_errors.size() != cross_sections.size() ) return false;
-    if ( cross_sections.at(0)       != 0 ) return true;
-    if ( cross_section_errors.at(0) != 0 ) return true;
+    if ( cross_sections.empty() ) { return false; }
+    if ( cross_section_errors.empty() ) { return false; }
+    if ( cross_section_errors.size() != cross_sections.size() ) { return false; }
+    if ( cross_sections.at(0)       != 0 ) { return true; }
+    if ( cross_section_errors.at(0) != 0 ) { return true; }
     return false;
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/GenEvent.cc` & `HepMC3-3.2.6/src/GenEvent.cc`

 * *Files 8% similar despite different names*

```diff
@@ -1,65 +1,66 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file GenEvent.cc
  *  @brief Implementation of \b class GenEvent
  *
  */
-#include <deque>
 #include <algorithm> // sort
+#include <deque>
 
+#include "HepMC3/Data/GenEventData.h"
 #include "HepMC3/GenEvent.h"
 #include "HepMC3/GenParticle.h"
 #include "HepMC3/GenVertex.h"
-#include "HepMC3/Data/GenEventData.h"
+
 
 namespace HepMC3 {
 
 GenEvent::GenEvent(Units::MomentumUnit mu,
                    Units::LengthUnit lu)
-    : m_event_number(0), m_weights(std::vector<double>()), //m_weights(std::vector<double>(1, 1.0)),//Prevent from  different number of weights and names
-      m_momentum_unit(mu), m_length_unit(lu),
+    : m_momentum_unit(mu), m_length_unit(lu), //m_weights(std::vector<double>(1, 1.0)),//Prevent from  different number of weights and names
       m_rootvertex(std::make_shared<GenVertex>()) {}
 
 
 GenEvent::GenEvent(std::shared_ptr<GenRunInfo> run,
                    Units::MomentumUnit mu,
                    Units::LengthUnit lu)
-    : m_event_number(0), m_weights(std::vector<double>()), //m_weights(std::vector<double>(1, 1.0)),//Prevent from  different number of weights and names
-      m_momentum_unit(mu), m_length_unit(lu),
+    : m_momentum_unit(mu), m_length_unit(lu),  //m_weights(std::vector<double>(1, 1.0)),//Prevent from  different number of weights and names
       m_rootvertex(std::make_shared<GenVertex>()),
       m_run_info(run) {
-    if ( run && !run->weight_names().empty() )
+    if ( run && !run->weight_names().empty() ) {
         m_weights = std::vector<double>(run->weight_names().size(), 1.0);
+    }
 }
 
 const std::vector<ConstGenParticlePtr>& GenEvent::particles() const {
     return *(reinterpret_cast<const std::vector<ConstGenParticlePtr>*>(&m_particles));
 }
 
 const std::vector<ConstGenVertexPtr>& GenEvent::vertices() const {
     return *(reinterpret_cast<const std::vector<ConstGenVertexPtr>*>(&m_vertices));
 }
 
 
 void GenEvent::add_particle(GenParticlePtr p) {
     if ( !p || p->in_event() ) return;
 
-    m_particles.push_back(p);
+    m_particles.emplace_back(p);
 
     p->m_event = this;
     p->m_id = particles().size();
 
     // Particles without production vertex are added to the root vertex
-    if ( !p->production_vertex() )
+    if ( !p->production_vertex() ) {
         m_rootvertex->add_particle_out(p);
+    }
 }
 
 
 GenEvent::GenEvent(const GenEvent&e) {
     if (this != &e)
     {
         std::lock(m_lock_attributes, e.m_lock_attributes);
@@ -68,19 +69,19 @@
         GenEventData tdata;
         e.write_data(tdata);
         read_data(tdata);
     }
 }
 
 GenEvent::~GenEvent() {
-    for ( std::map< std::string, std::map<int, std::shared_ptr<Attribute> > >::iterator attm = m_attributes.begin(); attm != m_attributes.end(); ++attm)
-        for ( std::map<int, std::shared_ptr<Attribute> >::iterator att = attm->second.begin(); att != attm->second.end(); ++att) if (att->second) att->second->m_event = nullptr;
-
-    for  ( std::vector<GenVertexPtr>::iterator v = m_vertices.begin(); v != m_vertices.end(); ++v ) if (*v)  if ((*v)->m_event == this) (*v)->m_event = nullptr;
-    for  ( std::vector<GenParticlePtr>::iterator p = m_particles.begin(); p != m_particles.end(); ++p ) if (*p)  if ((*p)->m_event == this)  (*p)->m_event = nullptr;
+    for ( auto attm = m_attributes.begin(); attm != m_attributes.end(); ++attm) {
+        for ( auto att = attm->second.begin(); att != attm->second.end(); ++att) { if (att->second) att->second->m_event = nullptr;}
+    }
+    for  ( auto v = m_vertices.begin(); v != m_vertices.end(); ++v ) if (*v)  if ((*v)->m_event == this) (*v)->m_event = nullptr;
+    for  ( auto p = m_particles.begin(); p != m_particles.end(); ++p ) if (*p)  if ((*p)->m_event == this)  (*p)->m_event = nullptr;
 }
 
 GenEvent& GenEvent::operator=(const GenEvent& e) {
     if (this != &e)
     {
         std::lock(m_lock_attributes, e.m_lock_attributes);
         std::lock_guard<std::recursive_mutex> lhs_lk(m_lock_attributes, std::adopt_lock);
@@ -91,26 +92,26 @@
     }
     return *this;
 }
 
 
 void GenEvent::add_vertex(GenVertexPtr v) {
     if ( !v|| v->in_event() ) return;
-    m_vertices.push_back(v);
+    m_vertices.emplace_back(v);
 
     v->m_event = this;
     v->m_id = -(int)vertices().size();
 
     // Add all incoming and outgoing particles and restore their production/end vertices
-    for (auto p: v->particles_in()) {
+    for (const auto& p: v->particles_in()) {
         if (!p->in_event()) add_particle(p);
         p->m_end_vertex = v->shared_from_this();
     }
 
-    for (auto p: v->particles_out()) {
+    for (const auto& p: v->particles_out()) {
         if (!p->in_event()) add_particle(p);
         p->m_production_vertex = v;
     }
 }
 
 
 void GenEvent::remove_particle(GenParticlePtr p) {
@@ -118,126 +119,121 @@
 
     HEPMC3_DEBUG(30, "GenEvent::remove_particle - called with particle: " << p->id());
     GenVertexPtr end_vtx = p->end_vertex();
     if ( end_vtx ) {
         end_vtx->remove_particle_in(p);
 
         // If that was the only incoming particle, remove vertex from the event
-        if ( end_vtx->particles_in().size() == 0 )  remove_vertex(end_vtx);
+        if ( end_vtx->particles_in().empty() )  remove_vertex(end_vtx);
     }
 
     GenVertexPtr prod_vtx = p->production_vertex();
     if ( prod_vtx ) {
         prod_vtx->remove_particle_out(p);
 
         // If that was the only outgoing particle, remove vertex from the event
-        if ( prod_vtx->particles_out().size() == 0 ) remove_vertex(prod_vtx);
+        if ( prod_vtx->particles_out().empty() ) remove_vertex(prod_vtx);
     }
 
     HEPMC3_DEBUG(30, "GenEvent::remove_particle - erasing particle: " << p->id())
 
     int idx = p->id();
-    std::vector<GenParticlePtr>::iterator it = m_particles.erase(m_particles.begin() + idx-1);
+    auto it = m_particles.erase(m_particles.begin() + idx-1);
 
     // Remove attributes of this particle
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    std::vector<std::string> atts = p->attribute_names();
-    for (const std::string &s: atts) {
-        p->remove_attribute(s);
+    for (att_key_t& vt1: m_attributes) {
+        auto vt2 = vt1.second.find(idx);
+        if (vt2 == vt1.second.end()) continue;
+        vt1.second.erase(vt2);
     }
 
     //
     // Reassign id of attributes with id above this one
     //
     std::vector< std::pair< int, std::shared_ptr<Attribute> > > changed_attributes;
 
     for (att_key_t& vt1: m_attributes) {
         changed_attributes.clear();
 
-        for (std::map<int, std::shared_ptr<Attribute> >::iterator vt2 = vt1.second.begin(); vt2 != vt1.second.end(); ++vt2) {
+        for (auto vt2 = vt1.second.begin(); vt2 != vt1.second.end(); ++vt2) {
             if ( (*vt2).first > p->id() ) {
-                changed_attributes.push_back(*vt2);
+                changed_attributes.emplace_back(*vt2);
             }
         }
 
-        for ( att_val_t val: changed_attributes ) {
+        for ( const auto& val: changed_attributes ) {
             vt1.second.erase(val.first);
             vt1.second[val.first-1] = val.second;
         }
     }
     // Reassign id of particles with id above this one
     for (; it != m_particles.end(); ++it) {
         --((*it)->m_id);
     }
 
     // Finally - set parent event and id of this particle to 0
     p->m_event = nullptr;
     p->m_id    = 0;
 }
-/** @brief Comparison of two particle by id */
-struct sort_by_id_asc {
-    /** @brief Comparison of two particle by id */
-    inline bool operator()(const GenParticlePtr& p1, const GenParticlePtr& p2) {
-        return (p1->id() > p2->id());
-    }
-};
 
 void GenEvent::remove_particles(std::vector<GenParticlePtr> v) {
-    std::sort(v.begin(), v.end(), sort_by_id_asc());
+    std::sort(v.begin(), v.end(), [](const GenParticlePtr& p1, const GenParticlePtr& p2) { return p1->id() > p2->id();});
 
-    for (std::vector<GenParticlePtr>::iterator p = v.begin(); p != v.end(); ++p) {
+    for (auto p = v.begin(); p != v.end(); ++p) {
         remove_particle(*p);
     }
 }
 
 void GenEvent::remove_vertex(GenVertexPtr v) {
     if ( !v || v->parent_event() != this ) return;
 
     HEPMC3_DEBUG(30, "GenEvent::remove_vertex   - called with vertex:  " << v->id());
     std::shared_ptr<GenVertex> null_vtx;
 
-    for (auto p: v->particles_in()) {
+    for (const auto& p: v->particles_in()) {
         p->m_end_vertex = std::weak_ptr<GenVertex>();
     }
 
-    for (auto p: v->particles_out()) {
+    for (const auto& p: v->particles_out()) {
         p->m_production_vertex = std::weak_ptr<GenVertex>();
 
         // recursive delete rest of the tree
         remove_particle(p);
     }
 
     // Erase this vertex from vertices list
     HEPMC3_DEBUG(30, "GenEvent::remove_vertex   - erasing vertex: " << v->id())
 
     int idx = -v->id();
-    std::vector<GenVertexPtr>::iterator it = m_vertices.erase(m_vertices.begin() + idx-1);
+    auto it = m_vertices.erase(m_vertices.begin() + idx-1);
     // Remove attributes of this vertex
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    std::vector<std::string> atts = v->attribute_names();
-    for (std::string s: atts) {
-        v->remove_attribute(s);
+    for (att_key_t& vt1: m_attributes) {
+        auto vt2 = vt1.second.find(-idx);
+        if (vt2 == vt1.second.end()) continue;
+        vt1.second.erase(vt2);
     }
 
     //
     // Reassign id of attributes with id below this one
     //
 
     std::vector< std::pair< int, std::shared_ptr<Attribute> > > changed_attributes;
 
     for ( att_key_t& vt1: m_attributes ) {
         changed_attributes.clear();
 
-        for (std::map<int, std::shared_ptr<Attribute> >::iterator vt2 = vt1.second.begin(); vt2 != vt1.second.end(); ++vt2) {
+        for (auto vt2 = vt1.second.begin(); vt2 != vt1.second.end(); ++vt2) {
             if ( (*vt2).first < v->id() ) {
-                changed_attributes.push_back(*vt2);
+                changed_attributes.emplace_back(*vt2);
             }
         }
 
-        for ( att_val_t val: changed_attributes ) {
+        for ( const auto& val: changed_attributes ) {
             vt1.second.erase(val.first);
             vt1.second[val.first+1] = val.second;
         }
     }
 
     // Reassign id of particles with id above this one
     for (; it != m_vertices.end(); ++it) {
@@ -246,43 +242,46 @@
 
     // Finally - set parent event and id of this vertex to 0
     v->m_event = nullptr;
     v->m_id    = 0;
 }
 /// @todo This looks dangerously similar to the recusive event traversel that we forbade in the
 ///       Core library due to wories about generator dependence
-static bool visit_children(std::map<ConstGenVertexPtr, int>  &a, ConstGenVertexPtr v)
+static bool visit_children(std::map<ConstGenVertexPtr, int>  &a, const ConstGenVertexPtr& v)
 {
-    for ( ConstGenParticlePtr p: v->particles_out())
+    for (const ConstGenParticlePtr& p: v->particles_out()) {
         if (p->end_vertex())
         {
-            if (a[p->end_vertex()] != 0) return true;
-            else a[p->end_vertex()]++;
+            if (a[p->end_vertex()] != 0) { return true; }
+            a[p->end_vertex()]++;
             if (visit_children(a, p->end_vertex())) return true;
         }
+    }
     return false;
 }
 
 void GenEvent::add_tree(const std::vector<GenParticlePtr> &parts) {
+    m_particles.reserve(m_particles.size() + parts.size());
+    m_vertices.reserve(m_vertices.size() + parts.size());
     std::shared_ptr<IntAttribute> existing_hc = attribute<IntAttribute>("cycles");
     bool has_cycles = false;
     std::map<GenVertexPtr, int>  sortingv;
     std::vector<GenVertexPtr> noinv;
     if (existing_hc)     if (existing_hc->value() != 0) has_cycles = true;
     if (!existing_hc)
     {
-        for (GenParticlePtr p: parts) {
+        for (const GenParticlePtr& p: parts) {
             GenVertexPtr v = p->production_vertex();
             if (v) sortingv[v]=0;
-            if ( !v || v->particles_in().size() == 0 ) {
+            if ( !v || v->particles_in().empty()) {
                 GenVertexPtr v2 = p->end_vertex();
-                if (v2) {noinv.push_back(v2); sortingv[v2] = 0;}
+                if (v2) {noinv.emplace_back(v2); sortingv[v2] = 0;}
             }
         }
-        for (GenVertexPtr v: noinv) {
+        for (const GenVertexPtr& v: noinv) {
             std::map<ConstGenVertexPtr, int>  sorting_temp(sortingv.begin(), sortingv.end());
             has_cycles = (has_cycles || visit_children(sorting_temp, v));
         }
     }
     if (has_cycles) {
         add_attribute("cycles", std::make_shared<IntAttribute>(1));
         /* Commented out  as improvemnts allow us to do sorting in other way.
@@ -290,19 +289,19 @@
          return;
          */
     }
 
     std::deque<GenVertexPtr> sorting;
 
     // Find all starting vertices (end vertex of particles that have no production vertex)
-    for (auto p: parts) {
+    for (const auto& p: parts) {
         const GenVertexPtr &v = p->production_vertex();
-        if ( !v || v->particles_in().size() == 0 ) {
+        if ( !v || v->particles_in().empty() ) {
             const GenVertexPtr &v2 = p->end_vertex();
-            if (v2) sorting.push_back(v2);
+            if (v2) sorting.emplace_back(v2);
         }
     }
 
     HEPMC3_DEBUG_CODE_BLOCK(
         unsigned int sorting_loop_count = 0;
         unsigned int max_deque_size     = 0;
     )
@@ -315,15 +314,15 @@
         )
 
             GenVertexPtr &v = sorting.front();
 
         bool added = false;
 
         // Add all mothers to the front of the list
-        for ( auto p: v->particles_in() ) {
+        for (const auto& p: v->particles_in() ) {
             GenVertexPtr v2 = p->production_vertex();
             if ( v2 && !v2->in_event() && find(sorting.begin(), sorting.end(), v2) == sorting.end() ) {
                 sorting.push_front(v2);
                 added = true;
             }
         }
 
@@ -332,18 +331,18 @@
         if ( added ) continue;
 
         // If vertex not yet added
         if ( !v->in_event() ) {
             add_vertex(v);
 
             // Add all end vertices to the end of the list
-            for (auto p: v->particles_out()) {
+            for (const auto& p: v->particles_out()) {
                 GenVertexPtr v2 = p->end_vertex();
                 if ( v2 && !v2->in_event()&& find(sorting.begin(), sorting.end(), v2) == sorting.end() ) {
-                    sorting.push_back(v2);
+                    sorting.emplace_back(v2);
                 }
             }
         }
 
         sorting.pop_front();
     }
 
@@ -352,18 +351,20 @@
         const int vx = -1 - m_rootvertex->id();
         const int rootid = m_rootvertex->id();
         if ( vx >= 0 && vx < (int) m_vertices.size() && m_vertices[vx] == m_rootvertex ) {
             auto next = m_vertices.erase(m_vertices.begin() + vx);
             std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
             for (auto & vt1: m_attributes) {
                 std::vector< std::pair< int, std::shared_ptr<Attribute> > > changed_attributes;
-                for ( auto vt2 : vt1.second )
-                    if ( vt2.first <= rootid )
-                        changed_attributes.push_back(vt2);
-                for ( auto val : changed_attributes ) {
+                for ( const auto& vt2 : vt1.second ) {
+                    if ( vt2.first <= rootid ) {
+                        changed_attributes.emplace_back(vt2);
+                    }
+                }
+                for ( const auto& val : changed_attributes ) {
                     vt1.second.erase(val.first);
                     vt1.second[val.first == rootid? 0: val.first + 1] = val.second;
                 }
             }
             m_rootvertex->set_id(0);
             while ( next != m_vertices.end() ) {
                 ++((*next++)->m_id);
@@ -374,94 +375,97 @@
     }
 
     HEPMC3_DEBUG_CODE_BLOCK(
         HEPMC3_DEBUG(6, "GenEvent - particles sorted: "
                      << this->particles().size() << ", max deque size: "
                      << max_deque_size << ", iterations: " << sorting_loop_count)
     )
-    return;
 }
 
 
 void GenEvent::reserve(const size_t& parts, const size_t& verts) {
     m_particles.reserve(parts);
     m_vertices.reserve(verts);
 }
 
 
 void GenEvent::set_units(Units::MomentumUnit new_momentum_unit, Units::LengthUnit new_length_unit) {
     if ( new_momentum_unit != m_momentum_unit ) {
-        for ( GenParticlePtr p: m_particles ) {
+        for ( GenParticlePtr& p: m_particles ) {
             Units::convert(p->m_data.momentum, m_momentum_unit, new_momentum_unit);
             Units::convert(p->m_data.mass, m_momentum_unit, new_momentum_unit);
         }
 
         m_momentum_unit = new_momentum_unit;
     }
 
     if ( new_length_unit != m_length_unit ) {
-        for (GenVertexPtr &v: m_vertices) {
+        for (GenVertexPtr& v: m_vertices) {
             FourVector &fv = v->m_data.position;
             if ( !fv.is_zero() ) Units::convert( fv, m_length_unit, new_length_unit );
         }
 
         m_length_unit = new_length_unit;
     }
 }
 
 
 const FourVector& GenEvent::event_pos() const {
     return m_rootvertex->data().position;
 }
 
+std::vector<ConstGenParticlePtr> GenEvent::beams(const int status) const {
+    if (!status) return std::const_pointer_cast<const GenVertex>(m_rootvertex)->particles_out();
+    std::vector<ConstGenParticlePtr> ret;
+    for (auto p: m_rootvertex->particles_out()) if (p->status() == status) ret.emplace_back(p);
+    return ret;
+}
+
 std::vector<ConstGenParticlePtr> GenEvent::beams() const {
     return std::const_pointer_cast<const GenVertex>(m_rootvertex)->particles_out();
 }
 
+
 const std::vector<GenParticlePtr> & GenEvent::beams() {
     return m_rootvertex->particles_out();
 }
 
 void GenEvent::shift_position_by(const FourVector & delta) {
     m_rootvertex->set_position(event_pos() + delta);
 
     // Offset all vertices
-    for ( GenVertexPtr v: m_vertices ) {
-        if ( v->has_set_position() )
+    for ( GenVertexPtr& v: m_vertices ) {
+        if ( v->has_set_position() ) {
             v->set_position(v->position() + delta);
+        }
     }
 }
 
 bool GenEvent::rotate(const FourVector&  delta)
 {
-    for ( auto p: m_particles)
+    for ( auto& p: m_particles)
     {
-        FourVector mom = p->momentum();
+        const FourVector& mom = p->momentum();
         long double tempX = mom.x();
         long double tempY = mom.y();
         long double tempZ = mom.z();
 
-        long double tempX_;
-        long double tempY_;
-        long double tempZ_;
-
-
         long double cosa = std::cos(delta.x());
         long double sina = std::sin(delta.x());
 
-        tempY_ = cosa*tempY+sina*tempZ;
-        tempZ_ = -sina*tempY+cosa*tempZ;
+        long double tempY_ = cosa*tempY+sina*tempZ;
+        long double tempZ_ = -sina*tempY+cosa*tempZ;
         tempY = tempY_;
         tempZ = tempZ_;
 
 
         long double cosb = std::cos(delta.y());
         long double sinb = std::sin(delta.y());
 
-        tempX_ = cosb*tempX-sinb*tempZ;
+        long double tempX_ = cosb*tempX-sinb*tempZ;
         tempZ_ = sinb*tempX+cosb*tempZ;
         tempX = tempX_;
         tempZ = tempZ_;
 
         long double cosg = std::cos(delta.z());
         long double sing = std::sin(delta.z());
 
@@ -469,39 +473,34 @@
         tempY_ = -sing*tempX+cosg*tempY;
         tempX = tempX_;
         tempY = tempY_;
 
         FourVector temp(tempX, tempY, tempZ, mom.e());
         p->set_momentum(temp);
     }
-    for (auto v: m_vertices)
+    for (auto& v: m_vertices)
     {
-        FourVector pos = v->position();
+        const FourVector& pos = v->position();
         long double tempX = pos.x();
         long double tempY = pos.y();
         long double tempZ = pos.z();
 
-        long double tempX_;
-        long double tempY_;
-        long double tempZ_;
-
-
         long double cosa = std::cos(delta.x());
         long double sina = std::sin(delta.x());
 
-        tempY_ = cosa*tempY+sina*tempZ;
-        tempZ_ = -sina*tempY+cosa*tempZ;
+        long double tempY_ = cosa*tempY+sina*tempZ;
+        long double tempZ_ = -sina*tempY+cosa*tempZ;
         tempY = tempY_;
         tempZ = tempZ_;
 
 
         long double cosb = std::cos(delta.y());
         long double sinb = std::sin(delta.y());
 
-        tempX_ = cosb*tempX-sinb*tempZ;
+        long double tempX_ = cosb*tempX-sinb*tempZ;
         tempZ_ = sinb*tempX+cosb*tempZ;
         tempX = tempX_;
         tempZ = tempZ_;
 
         long double cosg = std::cos(delta.z());
         long double sing = std::sin(delta.z());
 
@@ -524,28 +523,28 @@
     {
         HEPMC3_WARNING("GenEvent::reflect: wrong axis")
         return false;
     }
     switch (axis)
     {
     case 0:
-        for ( auto p: m_particles) { FourVector temp = p->momentum(); temp.setX(-p->momentum().x()); p->set_momentum(temp);}
-        for ( auto v: m_vertices)  { FourVector temp = v->position(); temp.setX(-v->position().x()); v->set_position(temp);}
+        for ( auto& p: m_particles) { FourVector temp = p->momentum(); temp.setX(-p->momentum().x()); p->set_momentum(temp);}
+        for ( auto& v: m_vertices)  { FourVector temp = v->position(); temp.setX(-v->position().x()); v->set_position(temp);}
         break;
     case 1:
-        for ( auto p: m_particles) { FourVector temp = p->momentum(); temp.setY(-p->momentum().y()); p->set_momentum(temp);}
-        for ( auto v: m_vertices)  { FourVector temp = v->position(); temp.setY(-v->position().y()); v->set_position(temp);}
+        for ( auto& p: m_particles) { FourVector temp = p->momentum(); temp.setY(-p->momentum().y()); p->set_momentum(temp);}
+        for ( auto& v: m_vertices)  { FourVector temp = v->position(); temp.setY(-v->position().y()); v->set_position(temp);}
         break;
     case 2:
-        for ( auto p: m_particles) { FourVector temp = p->momentum(); temp.setZ(-p->momentum().z()); p->set_momentum(temp);}
-        for ( auto v: m_vertices)  { FourVector temp = v->position(); temp.setZ(-v->position().z()); v->set_position(temp);}
+        for ( auto& p: m_particles) { FourVector temp = p->momentum(); temp.setZ(-p->momentum().z()); p->set_momentum(temp);}
+        for ( auto& v: m_vertices)  { FourVector temp = v->position(); temp.setZ(-v->position().z()); v->set_position(temp);}
         break;
     case 3:
-        for ( auto p: m_particles) { FourVector temp = p->momentum(); temp.setT(-p->momentum().e()); p->set_momentum(temp);}
-        for ( auto v: m_vertices)  { FourVector temp = v->position(); temp.setT(-v->position().t()); v->set_position(temp);}
+        for ( auto& p: m_particles) { FourVector temp = p->momentum(); temp.setT(-p->momentum().e()); p->set_momentum(temp);}
+        for ( auto& v: m_vertices)  { FourVector temp = v->position(); temp.setT(-v->position().t()); v->set_position(temp);}
         break;
     default:
         return false;
     }
 
     return true;
 }
@@ -571,17 +570,17 @@
     long double deltaX = delta.x();
     long double deltaY = delta.y();
     long double deltaZ = delta.z();
     long double deltalength2 = deltaX*deltaX+deltaY*deltaY+deltaZ*deltaZ;
     long double deltalength = std::sqrt(deltalength2);
     long double gamma = 1.0/std::sqrt(1.0-deltalength2);
 
-    for ( auto p: m_particles)
+    for ( auto& p: m_particles)
     {
-        FourVector mom = p->momentum();
+        const FourVector& mom = p->momentum();
 
         long double tempX = mom.x();
         long double tempY = mom.y();
         long double tempZ = mom.z();
         long double tempE = mom.e();
         long double nr = (deltaX*tempX+deltaY*tempY+deltaZ*tempZ)/deltalength;
 
@@ -604,30 +603,29 @@
     m_attributes.clear();
     m_particles.clear();
     m_vertices.clear();
 }
 
 void GenEvent::remove_attribute(const std::string &name,  const int& id) {
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    std:: map< std::string, std::map<int, std::shared_ptr<Attribute> > >::iterator i1 =
-        m_attributes.find(name);
+    auto i1 = m_attributes.find(name);
     if ( i1 == m_attributes.end() ) return;
 
-    std::map<int, std::shared_ptr<Attribute> >::iterator i2 = i1->second.find(id);
+    auto i2 = i1->second.find(id);
     if ( i2 == i1->second.end() ) return;
 
     i1->second.erase(i2);
 }
 
 std::vector<std::string> GenEvent::attribute_names(const int& id) const {
     std::vector<std::string> results;
 
     for (const att_key_t& vt1: m_attributes) {
         if ( vt1.second.count(id) == 1 ) {
-            results.push_back(vt1.first);
+            results.emplace_back(vt1.first);
         }
     }
 
     return results;
 }
 
 void GenEvent::write_data(GenEventData& data) const {
@@ -645,46 +643,46 @@
     data.momentum_unit = this->momentum_unit();
     data.length_unit   = this->length_unit();
     data.event_pos     = this->event_pos();
 
     // Fill containers
     data.weights = this->weights();
 
-    for (ConstGenParticlePtr p: this->particles()) {
-        data.particles.push_back(p->data());
+    for (const ConstGenParticlePtr& p: this->particles()) {
+        data.particles.emplace_back(p->data());
     }
 
-    for (ConstGenVertexPtr v: this->vertices()) {
-        data.vertices.push_back(v->data());
+    for (const ConstGenVertexPtr& v: this->vertices()) {
+        data.vertices.emplace_back(v->data());
         int v_id = v->id();
 
-        for (ConstGenParticlePtr p: v->particles_in()) {
-            data.links1.push_back(p->id());
-            data.links2.push_back(v_id);
+        for (const ConstGenParticlePtr& p: v->particles_in()) {
+            data.links1.emplace_back(p->id());
+            data.links2.emplace_back(v_id);
         }
 
-        for (ConstGenParticlePtr p: v->particles_out()) {
-            data.links1.push_back(v_id);
-            data.links2.push_back(p->id());
+        for (const ConstGenParticlePtr& p: v->particles_out()) {
+            data.links1.emplace_back(v_id);
+            data.links2.emplace_back(p->id());
         }
     }
 
     for (const att_key_t& vt1: this->attributes()) {
         for (const att_val_t& vt2: vt1.second) {
             std::string st;
 
             bool status = vt2.second->to_string(st);
 
             if ( !status ) {
                 HEPMC3_WARNING("GenEvent::write_data: problem serializing attribute: " << vt1.first)
             }
             else {
-                data.attribute_id.push_back(vt2.first);
-                data.attribute_name.push_back(vt1.first);
-                data.attribute_string.push_back(st);
+                data.attribute_id.emplace_back(vt2.first);
+                data.attribute_name.emplace_back(vt1.first);
+                data.attribute_string.emplace_back(st);
             }
         }
     }
 }
 
 
 void GenEvent::read_data(const GenEventData &data) {
@@ -693,56 +691,64 @@
     //Note: set_units checks the current unit of event, i.e. applicable only for fully constructed event.
     m_momentum_unit = data.momentum_unit;
     m_length_unit = data.length_unit;
     this->shift_position_to(data.event_pos);
 
     // Fill weights
     this->weights() = data.weights;
+    m_particles.reserve(data.particles.size());
+    m_vertices.reserve(data.vertices.size());
 
     // Fill particle information
     for ( const GenParticleData &pd: data.particles ) {
-        GenParticlePtr p = std::make_shared<GenParticle>(pd);
-
-        m_particles.push_back(p);
-
-        p->m_event = this;
-        p->m_id    = m_particles.size();
+        m_particles.emplace_back(std::make_shared<GenParticle>(pd));
+        m_particles.back()->m_event = this;
+        m_particles.back()->m_id    = m_particles.size();
     }
 
     // Fill vertex information
     for ( const GenVertexData &vd: data.vertices ) {
-        GenVertexPtr v = std::make_shared<GenVertex>(vd);
-
-        m_vertices.push_back(v);
-
-        v->m_event = this;
-        v->m_id    = -(int)m_vertices.size();
+        m_vertices.emplace_back(std::make_shared<GenVertex>(vd));
+        m_vertices.back()->m_event = this;
+        m_vertices.back()->m_id    = -(int)m_vertices.size();
     }
 
     // Restore links
     for (unsigned int i = 0; i < data.links1.size(); ++i) {
-        int id1 = data.links1[i];
-        int id2 = data.links2[i];
+        const int id1 = data.links1[i];
+        const int id2 = data.links2[i];
         /* @note:
         The  meaningfull combinations for (id1,id2) are:
         (+-)  --  particle has end vertex
         (-+)  --  particle  has production vertex
         */
         if ((id1 < 0 && id2 <0) || (id1 > 0 && id2 > 0))   { HEPMC3_WARNING("GenEvent::read_data: wrong link: " << id1 << " " << id2); continue;}
 
         if ( id1 > 0 ) { m_vertices[ (-id2)-1 ]->add_particle_in ( m_particles[ id1-1 ] ); continue; }
         if ( id1 < 0 ) { m_vertices[ (-id1)-1 ]->add_particle_out( m_particles[ id2-1 ] );   continue; }
     }
-    for (auto p:  m_particles) if (!p->production_vertex()) m_rootvertex->add_particle_out(p);
+    for (auto& p:  m_particles) if (!p->production_vertex()) m_rootvertex->add_particle_out(p);
 
     // Read attributes
+    std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
     for (unsigned int i = 0; i < data.attribute_id.size(); ++i) {
-        add_attribute(data.attribute_name[i],
-                      std::make_shared<StringAttribute>(data.attribute_string[i]),
-                      data.attribute_id[i]);
+        ///Disallow empty strings
+        const std::string name = data.attribute_name[i];
+        if (name.length() == 0) continue;
+        const int id = data.attribute_id[i];
+        if (m_attributes.count(name) == 0) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
+        auto att = std::make_shared<StringAttribute>(data.attribute_string[i]);
+        att->m_event = this;
+        if ( id > 0 && id <= int(m_particles.size()) ) {
+            att->m_particle = m_particles[id - 1];
+        }
+        if ( id < 0 && -id <= int(m_vertices.size()) ) {
+            att->m_vertex = m_vertices[-id - 1];
+        }
+        m_attributes[name][id] = att;
     }
 }
 
 
 //
 // Deprecated functions
 //
@@ -764,135 +770,138 @@
 
 void GenEvent::add_beam_particle(GenParticlePtr p1) {
     if (!p1)
     {
         HEPMC3_WARNING("Attempting to add an empty particle as beam particle. Ignored.")
         return;
     }
-    if (p1->in_event()) if (p1->parent_event() != this)
-        {
-            HEPMC3_WARNING("Attempting to add particle from another event. Ignored.")
-            return;
-        }
+    if (p1->in_event() && p1->parent_event() != this)
+    {
+        HEPMC3_WARNING("Attempting to add particle from another event. Ignored.")
+        return;
+    }
     if (p1->production_vertex())  p1->production_vertex()->remove_particle_out(p1);
     //Particle w/o production vertex is added to root vertex.
     add_particle(p1);
     p1->set_status(4);
-    return;
 }
 
 
 std::string GenEvent::attribute_as_string(const std::string &name, const int& id) const {
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    std::map< std::string, std::map<int, std::shared_ptr<Attribute> > >::iterator i1 =
-        m_attributes.find(name);
+    auto i1 = m_attributes.find(name);
     if ( i1 == m_attributes.end() ) {
         if ( id == 0 && run_info() ) {
             return run_info()->attribute_as_string(name);
         }
-        return std::string();
+        return {};
     }
 
-    std::map<int, std::shared_ptr<Attribute> >::iterator i2 = i1->second.find(id);
-    if (i2 == i1->second.end() ) return std::string();
+    auto i2 = i1->second.find(id);
+    if (i2 == i1->second.end() ) return {};
 
-    if ( !i2->second ) return std::string();
+    if ( !i2->second ) return {};
 
     std::string ret;
     i2->second->to_string(ret);
 
     return ret;
 }
 
 void GenEvent::add_attribute(const std::string &name, const std::shared_ptr<Attribute> &att, const int& id ) {
     ///Disallow empty strings
     if (name.length() == 0) return;
     if (!att)  return;
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    if (m_attributes.find(name) == m_attributes.end()) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
+    if (m_attributes.count(name) == 0) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
     m_attributes[name][id] = att;
     att->m_event = this;
-    if ( id > 0 && id <= int(particles().size()) )
+    if ( id > 0 && id <= int(particles().size()) ) {
         att->m_particle = particles()[id - 1];
-    if ( id < 0 && -id <= int(vertices().size()) )
+    }
+    if ( id < 0 && -id <= int(vertices().size()) ) {
         att->m_vertex = vertices()[-id - 1];
+    }
 }
 
 
 void GenEvent::add_attributes(const std::vector<std::string> &names, const std::vector<std::shared_ptr<Attribute> > &atts, const std::vector<int>& ids) {
     size_t N = names.size();
     if ( N == 0 ) return;
     if (N != atts.size()) return;
     if (N != ids.size()) return;
 
     std::vector<std::string> unames = names;
     vector<std::string>::iterator ip;
     ip = std::unique(unames.begin(), unames.end());
     unames.resize(std::distance(unames.begin(), ip));
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    for (auto name: unames)
+    for (const auto& name: unames) {
         if (m_attributes.count(name) == 0) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
-
+    }
     const int particles_size = int(m_particles.size());
     const int vertices_size = int(m_vertices.size());
     for (size_t i = 0; i < N; i++) {
         ///Disallow empty strings
         if (names.at(i).length() == 0) continue;
         if (!atts[i])  continue;
         m_attributes[names.at(i)][ids.at(i)] = atts[i];
         atts[i]->m_event = this;
         if ( ids.at(i) > 0 && ids.at(i) <= particles_size )
         { atts[i]->m_particle = m_particles[ids.at(i) - 1]; }
         else {
-            if ( ids.at(i) < 0 && -ids.at(i) <= vertices_size )
+            if ( ids.at(i) < 0 && -ids.at(i) <= vertices_size ) {
                 atts[i]->m_vertex = m_vertices[-ids.at(i) - 1];
+            }
         }
     }
 }
 
 void GenEvent::add_attributes(const std::string& name, const std::vector<std::shared_ptr<Attribute> > &atts, const std::vector<int>& ids) {
     if (name.length() == 0) return;
     size_t N = ids.size();
     if(!N) return;
     if ( N != atts.size()) return;
 
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    if (m_attributes.find(name) == m_attributes.end()) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
+    if (m_attributes.count(name) == 0) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
     auto& tmap = m_attributes[name];
     const int particles_size = int(m_particles.size());
     const int vertices_size = int(m_vertices.size());
     for (size_t i = 0; i < N; i++) {
         ///Disallow empty strings
         if (!atts[i])  continue;
         tmap[ids.at(i)] = atts[i];
         atts[i]->m_event = this;
         if ( ids.at(i) > 0 && ids.at(i) <= particles_size )
         { atts[i]->m_particle = m_particles[ids.at(i) - 1]; }
         else {
-            if ( ids.at(i) < 0 && -ids.at(i) <= vertices_size )
+            if ( ids.at(i) < 0 && -ids.at(i) <= vertices_size ) {
                 atts[i]->m_vertex = m_vertices[-ids.at(i) - 1];
+            }
         }
     }
 }
 void GenEvent::add_attributes(const std::string& name, const std::vector<std::pair<int, std::shared_ptr<Attribute> > > &atts) {
     if (name.length() == 0) return;
-    if (!atts.size()) return;
+    if (atts.empty()) return;
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    if (m_attributes.find(name) == m_attributes.end()) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
+    if (m_attributes.count(name) == 0) m_attributes[name] = std::map<int, std::shared_ptr<Attribute> >();
     auto& tmap = m_attributes[name];
     const int particles_size = int(m_particles.size());
     const int vertices_size = int(m_vertices.size());
-    for (auto att: atts) {
+    for (const auto& att: atts) {
         ///Disallow empty strings
         if (!att.second)  continue;
         tmap.insert(att);
         att.second->m_event = this;
         if ( att.first > 0 && att.first <= particles_size )
         { att.second->m_particle = m_particles[att.first - 1]; }
         else {
-            if ( att.first < 0 && -att.first <= vertices_size )
+            if ( att.first < 0 && -att.first <= vertices_size ) {
                 att.second->m_vertex = m_vertices[-att.first - 1];
+            }
         }
     }
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/GenHeavyIon.cc` & `HepMC3-3.2.6/src/GenHeavyIon.cc`

 * *Files 6% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file GenHeavyIon.cc
  *  @brief Implementation of \b class GenHeavyIon
  *
  */
-#include <cstring> // memcmp
-#include <cstdlib> // atoi
 #include <cstdio> // sprintf
+#include <cstdlib> // atoi
+#include <cstring> // memcmp
 #include <sstream> // sprintf
 
 #include "HepMC3/GenHeavyIon.h"
 
 namespace HepMC3 {
 
 bool GenHeavyIon::from_string(const std::string &att) {
+/// If HEPMC3_NO_DEPRECATED is not defined, those are member variables.
 #ifdef HEPMC3_NO_DEPRECATED
     double spectator_neutrons, spectator_protons, eccentricity;
 #endif
 
     std::istringstream is(att);
     std::string version;
 
@@ -29,30 +30,31 @@
         is >> Ncoll_hard >> Npart_proj >> Npart_targ >> Ncoll
            >> spectator_neutrons >> spectator_protons
            >> N_Nwounded_collisions >> Nwounded_N_collisions
            >> Nwounded_Nwounded_collisions >> impact_parameter
            >> event_plane_angle >> eccentricity >> sigma_inel_NN
            >> centrality;
         return !is.fail();
-    } else
-        is >> version;
+    }
+    is >> version;
 
 
 
     is >> Ncoll_hard >> Npart_proj >> Npart_targ >> Ncoll;
     if ( version == "v0" ) is >> spectator_neutrons >> spectator_protons;
     is >> N_Nwounded_collisions >> Nwounded_N_collisions
        >> Nwounded_Nwounded_collisions >> impact_parameter
        >> event_plane_angle;
     if ( version == "v0" ) is >> eccentricity;
     is >> sigma_inel_NN >> centrality;
     if ( version != "v0" ) is >> user_cent_estimate;
     is >> Nspec_proj_n >> Nspec_targ_n >> Nspec_proj_p >> Nspec_targ_p;
 
-    int N, ord;
+    int N=0;
+    int ord=0;
     is >> N;
     for ( int i = 0; i < N; ++i ) {
         is >> ord;
         is >> participant_plane_angles[ord];
     }
     is >> N;
     for ( int i = 0; i < N; ++i ) {
@@ -85,23 +87,21 @@
        << eccentricity << " "
 #endif
        << sigma_inel_NN << " " << centrality << " " << user_cent_estimate << " "
        << Nspec_proj_n << " " << Nspec_targ_n << " "
        << Nspec_proj_p << " " << Nspec_targ_p << " ";
 
     os << participant_plane_angles.size();
-    for ( std::map<int, double>::const_iterator it = participant_plane_angles.begin();
-            it != participant_plane_angles.end(); ++it )
-        os << " " << it->first << " " << it->second;
-
+    for (const auto& it: participant_plane_angles) {
+        os << " " << it.first << " " << it.second;
+    }
     os << " " << eccentricities.size();
-    for ( std::map<int, double>::const_iterator it = eccentricities.begin();
-            it != eccentricities.end(); ++it )
-        os << " " << it->first << " " << it->second;
-
+    for (const auto& it: eccentricities) {
+        os << " " << it.first << " " << it.second;
+    }
     att = os.str();
 
     return true;
 }
 
 
 #ifndef HEPMC3_NO_DEPRECATED
@@ -131,27 +131,27 @@
     eccentricity                 = ec;
     sigma_inel_NN                = s;
     centrality                   = cent;
     user_cent_estimate           = usrcent;
 }
 
 bool GenHeavyIon::is_valid() const {
-    if ( Ncoll_hard                   != 0 ) return true;
-    if ( Npart_proj                   != 0 ) return true;
-    if ( Npart_targ                   != 0 ) return true;
-    if ( Ncoll                        != 0 ) return true;
-    if ( spectator_neutrons           != 0 ) return true;
-    if ( spectator_protons            != 0 ) return true;
-    if ( N_Nwounded_collisions        != 0 ) return true;
-    if ( Nwounded_N_collisions        != 0 ) return true;
-    if ( Nwounded_Nwounded_collisions != 0 ) return true;
-    if ( impact_parameter             != 0 ) return true;
-    if ( event_plane_angle            != 0 ) return true;
-    if ( eccentricity                 != 0 ) return true;
-    if ( sigma_inel_NN                != 0 ) return true;
-    if ( centrality                   != 0 ) return true;
+    if ( Ncoll_hard                   != 0 ) { return true; }
+    if ( Npart_proj                   != 0 ) { return true; }
+    if ( Npart_targ                   != 0 ) { return true; }
+    if ( Ncoll                        != 0 ) { return true; }
+    if ( spectator_neutrons           != 0 ) { return true; }
+    if ( spectator_protons            != 0 ) { return true; }
+    if ( N_Nwounded_collisions        != 0 ) { return true; }
+    if ( Nwounded_N_collisions        != 0 ) { return true; }
+    if ( Nwounded_Nwounded_collisions != 0 ) { return true; }
+    if ( impact_parameter             != 0 ) { return true; }
+    if ( event_plane_angle            != 0 ) { return true; }
+    if ( eccentricity                 != 0 ) { return true; }
+    if ( sigma_inel_NN                != 0 ) { return true; }
+    if ( centrality                   != 0 ) { return true; }
     return false;
 }
 
 #endif
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/GenParticle.cc` & `HepMC3-3.2.6/src/GenParticle.cc`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file GenParticle.cc
  *  @brief Implementation of \b class GenParticle
  *
  */
+#include "HepMC3/Attribute.h"
+#include "HepMC3/GenEvent.h"
 #include "HepMC3/GenParticle.h"
 #include "HepMC3/GenVertex.h"
-#include "HepMC3/GenEvent.h"
 #include "HepMC3/Setup.h"
-#include "HepMC3/Attribute.h"
+
 
 namespace HepMC3 {
 
 GenParticle::GenParticle(const FourVector &mom, int pidin, int stat):
     m_event(nullptr),
     m_id(0) {
     m_data.pid               = pidin;
@@ -29,16 +30,15 @@
 GenParticle::GenParticle(const GenParticleData &dat):
     m_event(nullptr),
     m_id(0),
     m_data(dat) {
 }
 
 double GenParticle::generated_mass() const {
-    if (m_data.is_mass_set) return m_data.mass;
-    else                   return m_data.momentum.m();
+    return m_data.is_mass_set ? m_data.mass : m_data.momentum.m();
 }
 
 void GenParticle::set_pid(int pidin) {
     m_data.pid = pidin;
 }
 
 void GenParticle::set_status(int stat) {
@@ -95,16 +95,15 @@
     if ( !parent_event() ) return false;
     parent_event()->add_attribute(name, att, id());
     return true;
 }
 
 std::vector<std::string> GenParticle::attribute_names() const {
     if ( parent_event() ) return parent_event()->attribute_names(id());
-
-    return std::vector<std::string>();
+    return {};
 }
 
 void GenParticle::remove_attribute(const std::string& name) {
     if ( parent_event() ) parent_event()->remove_attribute(name, id());
 }
 
 std::string GenParticle::attribute_as_string(const std::string& name) const {
```

### Comparing `HepMC3-3.2.5/src/GenPdfInfo.cc` & `HepMC3-3.2.6/src/GenPdfInfo.cc`

 * *Files 21% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file GenPdfInfo.cc
  *  @brief Implementation of \b class GenPdfInfo
  *
  */
-#include <cstring> // memcmp
-#include <cstdlib> // atoi
+#include <array>
 #include <cstdio> // sprintf
+#include <cstdlib> // atoi
+#include <cstring> // memcmp
 
 #include "HepMC3/GenPdfInfo.h"
 
 namespace HepMC3 {
 
 bool GenPdfInfo::from_string(const std::string &att) {
     const char *cursor = att.data();
@@ -45,28 +46,28 @@
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     pdf_id[1] = atoi(cursor);
 
     return true;
 }
 
 bool GenPdfInfo::to_string(std::string &att) const {
-    char buf[255];//Note: the format is fixed, so no reason for complicatied tratment
+    std::array<char, 255> buf;//Note: the format is fixed, so no reason for complicatied tratment
 
-    snprintf(buf, 255, "%i %i %.8e %.8e %.8e %.8e %.8e %i %i",
+    snprintf(buf.data(), buf.size(), "%i %i %.8e %.8e %.8e %.8e %.8e %i %i",
              parton_id[0],
              parton_id[1],
              x[0],
              x[1],
              scale,
              xf[0],
              xf[1],
              pdf_id[0],
              pdf_id[1]);
 
-    att = buf;
+    att = buf.data();
 
     return true;
 }
 
 void GenPdfInfo::set(const int& parton_id1, const int& parton_id2, const double& x1, const double& x2,
                      const double& scale_in, const double& xf1, const double& xf2,
                      const int& pdf_id1, const int& pdf_id2) {
@@ -87,21 +88,21 @@
 
 bool GenPdfInfo::operator!=(const GenPdfInfo& a) const {
     return !( a == *this );
 }
 
 bool GenPdfInfo::is_valid() const
 {
-    if ( parton_id[0] != 0 ) return true;
-    if ( parton_id[1] != 0 ) return true;
-    if ( x[0]         != 0 ) return true;
-    if ( x[1]         != 0 ) return true;
-    if ( scale        != 0 ) return true;
-    if ( xf[0]        != 0 ) return true;
-    if ( xf[1]        != 0 ) return true;
-    if ( pdf_id[0]    != 0 ) return true;
-    if ( pdf_id[1]    != 0 ) return true;
+    if ( parton_id[0] != 0 ) { return true; }
+    if ( parton_id[1] != 0 ) { return true; }
+    if ( x[0]         != 0 ) { return true; }
+    if ( x[1]         != 0 ) { return true; }
+    if ( scale        != 0 ) { return true; }
+    if ( xf[0]        != 0 ) { return true; }
+    if ( xf[1]        != 0 ) { return true; }
+    if ( pdf_id[0]    != 0 ) { return true; }
+    if ( pdf_id[1]    != 0 ) { return true; }
 
     return false;
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/GenRunInfo.cc` & `HepMC3-3.2.6/src/GenRunInfo.cc`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file GenRunInfo.cc
  *  @brief Implementation of \b class GenRunInfo
  *
  */
 #include <sstream>
 
-#include "HepMC3/GenRunInfo.h"
 #include "HepMC3/Data/GenRunInfoData.h"
+#include "HepMC3/GenRunInfo.h"
+
 
 namespace HepMC3 {
 
 
 void GenRunInfo::set_weight_names(const std::vector<std::string> & names) {
     m_weight_indices.clear();
     m_weight_names = names;
@@ -23,63 +24,64 @@
         std::string name = names[i];
         if ( name.empty() ) {
             std::ostringstream oss;
             oss << i;
             name = oss.str();
             m_weight_names[i] = name;
         }
-        if ( has_weight(name) )
+        if ( has_weight(name) ) {
             throw std::logic_error("GenRunInfo::set_weight_names: "
                                    "Duplicate weight name '" + name +
                                    "' found.");
+        }
         m_weight_indices[name] = i;
     }
 }
 
 std::string GenRunInfo::attribute_as_string(const std::string &name) const {
     std::lock_guard<std::recursive_mutex> lock(m_lock_attributes);
-    std::map< std::string, std::shared_ptr<Attribute> >::iterator i = m_attributes.find(name);
-    if ( i == m_attributes.end() ) return std::string();
+    auto i = m_attributes.find(name);
+    if ( i == m_attributes.end() ) return {};
 
-    if ( !i->second ) return std::string();
+    if ( !i->second ) return {};
 
     std::string ret;
     i->second->to_string(ret);
 
     return ret;
 }
 
 void GenRunInfo::write_data(GenRunInfoData& data) const {
     // Weight names
     data.weight_names = this->weight_names();
 
     // Attributes
-    typedef std::map<std::string, std::shared_ptr<Attribute> >::value_type att_val_t;
+    using att_val_t = std::map<std::string, std::shared_ptr<Attribute>>::value_type;
 
     for (const att_val_t& vt: m_attributes) {
         std::string att;
         vt.second->to_string(att);
 
-        data.attribute_name.  push_back(vt.first);
-        data.attribute_string.push_back(att);
+        data.attribute_name.  emplace_back(vt.first);
+        data.attribute_string.emplace_back(att);
     }
 
     // Tools
     for ( const ToolInfo &tool: this->tools() ) {
-        data.tool_name.       push_back(tool.name);
-        data.tool_version.    push_back(tool.version);
-        data.tool_description.push_back(tool.description);
+        data.tool_name.       emplace_back(tool.name);
+        data.tool_version.    emplace_back(tool.version);
+        data.tool_description.emplace_back(tool.description);
     }
 }
 
 
 std::vector<std::string> GenRunInfo::attribute_names() const {
     std::vector<std::string> results;
-    for (auto vt1: m_attributes) {
-        results.push_back(vt1.first);
+    for (const auto& vt1: m_attributes) {
+        results.emplace_back(vt1.first);
     }
     return results;
 }
 
 void GenRunInfo::read_data(const GenRunInfoData& data) {
     // Weight names
     set_weight_names(data.weight_names);
@@ -93,15 +95,15 @@
     // Tools
     for (unsigned int i = 0; i < data.tool_name.size(); ++i) {
         ToolInfo ti;
         ti.name        = data.tool_name[i];
         ti.version     = data.tool_version[i];
         ti.description = data.tool_description[i];
 
-        this->tools().push_back(ti);
+        this->tools().emplace_back(ti);
     }
 }
 
 GenRunInfo::GenRunInfo(const GenRunInfo& r)
 {
     if (this != &r)
     {
```

### Comparing `HepMC3-3.2.5/src/GenVertex.cc` & `HepMC3-3.2.6/src/GenVertex.cc`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file GenVertex.cc
  *  @brief Implementation of \b class GenVertex
  *
  */
 #include <algorithm> // std::remove
 
-#include "HepMC3/GenVertex.h"
-#include "HepMC3/GenParticle.h"
+#include "HepMC3/Attribute.h"
 #include "HepMC3/GenEvent.h"
+#include "HepMC3/GenParticle.h"
+#include "HepMC3/GenVertex.h"
 #include "HepMC3/Setup.h"
-#include "HepMC3/Attribute.h"
 
 namespace HepMC3 {
 
 
 GenVertex::GenVertex(const FourVector& pos):
     m_event(nullptr),
     m_id(0) {
@@ -35,15 +35,15 @@
 
 void GenVertex::add_particle_in(GenParticlePtr p) {
     if (!p) return;
 
     // Avoid duplicates
     if (std::find(particles_in().begin(), particles_in().end(), p) != particles_in().end()) return;
 
-    m_particles_in.push_back(p);
+    m_particles_in.emplace_back(p);
 
     if ( p->end_vertex() ) p->end_vertex()->remove_particle_in(p);
 
     p->m_end_vertex = shared_from_this();
 
     if (m_event) m_event->add_particle(p);
 }
@@ -51,15 +51,15 @@
 
 void GenVertex::add_particle_out(GenParticlePtr p) {
     if (!p) return;
 
     // Avoid duplicates
     if (std::find(particles_out().begin(), particles_out().end(), p) != particles_out().end()) return;
 
-    m_particles_out.push_back(p);
+    m_particles_out.emplace_back(p);
 
     if ( p->production_vertex() ) p->production_vertex()->remove_particle_out(p);
 
     p->m_production_vertex = shared_from_this();
 
     if (m_event) m_event->add_particle(p);
 }
@@ -77,15 +77,14 @@
     if (std::find(m_particles_out.begin(), m_particles_out.end(), p) == m_particles_out.end()) return;
     p->m_production_vertex.reset();
     m_particles_out.erase(std::remove(m_particles_out.begin(), m_particles_out.end(), p), m_particles_out.end());
 }
 
 void GenVertex::set_id(int id) {
     m_id = id;
-    return;
 }
 
 
 const std::vector<ConstGenParticlePtr>& GenVertex::particles_in()const {
     return *(reinterpret_cast<const std::vector<ConstGenParticlePtr>*>(&m_particles_in));
 }
 
@@ -99,15 +98,15 @@
     // No position information - look at event and/or search ancestors
     if ( parent_event() )
     {
         std::shared_ptr<IntAttribute> cycles = parent_event()->attribute<IntAttribute>("cycles");
         //This could be a recussive call.  Try to prevent it.
         if (!cycles || cycles->value() == 0)
         {
-            for (ConstGenParticlePtr p: m_particles_in) {
+            for (const auto& p: m_particles_in) {
                 ConstGenVertexPtr v = p->production_vertex();
                 if (v) return v->position();
             }
         }
         return parent_event()->event_pos();
     }
     return FourVector::ZERO_VECTOR();
@@ -130,11 +129,11 @@
 std::string GenVertex::attribute_as_string(const std::string& name) const {
     return parent_event() ? parent_event()->attribute_as_string(name, id()) : std::string();
 }
 
 std::vector<std::string> GenVertex::attribute_names() const {
     if ( parent_event() ) return parent_event()->attribute_names(id());
 
-    return std::vector<std::string>();
+    return {};
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/HEPEVT_Wrapper.cc` & `HepMC3-3.2.6/src/HEPEVT_Wrapper.cc`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file HEPEVT_Wrapper.cc
  *  @brief Implementation of helper functions used to manipulate with HEPEVT block
  */
 #include <algorithm>
+#include <array>
 #include <set>
 #include <vector>
 
 #include "HepMC3/HEPEVT_Helpers.h"
 #include "HepMC3/HEPEVT_Wrapper.h"
 #include "HepMC3/HEPEVT_Wrapper_Runtime.h"
 #include "HepMC3/HEPEVT_Wrapper_Runtime_Static.h"
@@ -34,68 +35,73 @@
 bool pair_GenVertexPtr_int_greater::operator()(const std::pair<ConstGenVertexPtr, int>& lx, const std::pair<ConstGenVertexPtr, int>& rx) const
 {
     if (lx.second != rx.second) return (lx.second < rx.second);
     if (lx.first->particles_in().size() != rx.first->particles_in().size()) return (lx.first->particles_in().size() < rx.first->particles_in().size());
     if (lx.first->particles_out().size() != rx.first->particles_out().size()) return (lx.first->particles_out().size() < rx.first->particles_out().size());
     /* The code below is usefull mainly for debug. Assures strong ordering.*/
     std::vector<int> lx_id_in;
+    lx_id_in.reserve(lx.first->particles_in().size());
     std::vector<int> rx_id_in;
-    for (ConstGenParticlePtr pp: lx.first->particles_in()) lx_id_in.push_back(pp->pid());
-    for (ConstGenParticlePtr pp: rx.first->particles_in()) rx_id_in.push_back(pp->pid());
+    rx_id_in.reserve(rx.first->particles_in().size());
+    for (const ConstGenParticlePtr& pp: lx.first->particles_in()) lx_id_in.emplace_back(pp->pid());
+    for (const ConstGenParticlePtr& pp: rx.first->particles_in()) rx_id_in.emplace_back(pp->pid());
     std::sort(lx_id_in.begin(), lx_id_in.end());
     std::sort(rx_id_in.begin(), rx_id_in.end());
     for (unsigned int i = 0; i < lx_id_in.size(); i++) if (lx_id_in[i] != rx_id_in[i]) return  (lx_id_in[i] < rx_id_in[i]);
 
     std::vector<int> lx_id_out;
+    lx_id_out.reserve(lx.first->particles_out().size());
     std::vector<int> rx_id_out;
-    for (ConstGenParticlePtr pp: lx.first->particles_in()) lx_id_out.push_back(pp->pid());
-    for (ConstGenParticlePtr pp: rx.first->particles_in()) rx_id_out.push_back(pp->pid());
+    rx_id_out.reserve(rx.first->particles_out().size());
+    for (const ConstGenParticlePtr& pp: lx.first->particles_in()) lx_id_out.emplace_back(pp->pid());
+    for (const ConstGenParticlePtr& pp: rx.first->particles_in()) rx_id_out.emplace_back(pp->pid());
     std::sort(lx_id_out.begin(), lx_id_out.end());
     std::sort(rx_id_out.begin(), rx_id_out.end());
     for (unsigned int i = 0; i < lx_id_out.size(); i++) if (lx_id_out[i] != rx_id_out[i]) return  (lx_id_out[i] < rx_id_out[i]);
 
     std::vector<double> lx_mom_in;
     std::vector<double> rx_mom_in;
-    for (ConstGenParticlePtr pp: lx.first->particles_in()) lx_mom_in.push_back(pp->momentum().e());
-    for (ConstGenParticlePtr pp: rx.first->particles_in()) rx_mom_in.push_back(pp->momentum().e());
+    for (const ConstGenParticlePtr& pp: lx.first->particles_in()) lx_mom_in.emplace_back(pp->momentum().e());
+    for (const ConstGenParticlePtr& pp: rx.first->particles_in()) rx_mom_in.emplace_back(pp->momentum().e());
     std::sort(lx_mom_in.begin(), lx_mom_in.end());
     std::sort(rx_mom_in.begin(), rx_mom_in.end());
     for (unsigned int i = 0; i < lx_mom_in.size(); i++) if (lx_mom_in[i] != rx_mom_in[i]) return  (lx_mom_in[i] < rx_mom_in[i]);
 
     std::vector<double> lx_mom_out;
     std::vector<double> rx_mom_out;
-    for (ConstGenParticlePtr pp: lx.first->particles_in()) lx_mom_out.push_back(pp->momentum().e());
-    for (ConstGenParticlePtr pp: rx.first->particles_in()) rx_mom_out.push_back(pp->momentum().e());
+    for (const ConstGenParticlePtr& pp: lx.first->particles_in()) lx_mom_out.emplace_back(pp->momentum().e());
+    for (const ConstGenParticlePtr& pp: rx.first->particles_in()) rx_mom_out.emplace_back(pp->momentum().e());
     std::sort(lx_mom_out.begin(), lx_mom_out.end());
     std::sort(rx_mom_out.begin(), rx_mom_out.end());
     for (unsigned int i = 0; i < lx_mom_out.size(); i++) if (lx_mom_out[i] != rx_mom_out[i]) return  (lx_mom_out[i] < rx_mom_out[i]);
     /* The code above is usefull mainly for debug*/
 
-    return (lx.first < lx.first); /*This  is random. This should never happen*/
+    //return (lx.first < lx.first); /*This  is random. This should never happen*/
+    return false;
 }
 /** @brief Calculates the path to the top (beam) particles */
 void calculate_longest_path_to_top(ConstGenVertexPtr v, std::map<ConstGenVertexPtr, int>& pathl)
 {
     int p = 0;
-    for (ConstGenParticlePtr pp: v->particles_in()) {
+    for (const ConstGenParticlePtr& pp: v->particles_in()) {
         ConstGenVertexPtr v2 = pp->production_vertex();
         if (v2 == v) continue; //LOOP! THIS SHOULD NEVER HAPPEN FOR A PROPER EVENT!
-        if (!v2) p = std::max(p, 1);
+        if (!v2) { p = std::max(p, 1); }
         else
-        {if (pathl.find(v2) == pathl.end())  calculate_longest_path_to_top(v2, pathl); p = std::max(p, pathl[v2]+1);}
+        {if (pathl.count(v2) == 0)  calculate_longest_path_to_top(v2, pathl); p = std::max(p, pathl[v2]+1);}
     }
     pathl[v] = p;
-    return;
 }
 
+/** @brief pointer to the common block */
 HEPMC3_EXPORT_API struct HEPEVT*  hepevtptr = nullptr;
 HEPMC3_EXPORT_API std::shared_ptr<struct HEPEVT_Pointers<double> >  HEPEVT_Wrapper_Runtime_Static::m_hepevtptr = nullptr;
 HEPMC3_EXPORT_API int HEPEVT_Wrapper_Runtime_Static::m_max_particles = 0;
 
-
+/** @brief Set the address */
 void HEPEVT_Wrapper_Runtime::set_hepevt_address(char *c) {
     m_hepevtptr = std::make_shared<struct HEPEVT_Pointers<double> >();
     char* x = c;
     m_hepevtptr->nevhep = (int*)x;
     x += sizeof(int);
     m_hepevtptr->nhep = (int*)(x);
     x += sizeof(int);
@@ -122,24 +128,22 @@
         print_hepevt_particle( i, ostr );
     }
 }
 
 
 void HEPEVT_Wrapper_Runtime::print_hepevt_particle( int index, std::ostream& ostr ) const
 {
-    char buf[255];//Note: the format is fixed, so no reason for complicated treatment
+    std::array<char, 255> buf;//Note: the format is fixed, so no reason for complicated treatment
 
-    sprintf(buf, "%5i %6i", index, m_hepevtptr->idhep[index-1]);
-    ostr << buf;
-    sprintf(buf, "%4i - %4i  ", m_hepevtptr->jmohep[2*(index-1)], m_hepevtptr->jmohep[2*(index-1)+1]);
-    ostr << buf;
-    sprintf(buf, "%4i - %4i ", m_hepevtptr->jdahep[2*(index-1)], m_hepevtptr->jdahep[2*(index-1)+1]);
-    ostr << buf;
-    sprintf(buf, "%8.2f %8.2f %8.2f %8.2f %8.2f", m_hepevtptr->phep[5*(index-1)], m_hepevtptr->phep[5*(index-1)+1], m_hepevtptr->phep[5*(index-1)+2], m_hepevtptr->phep[5*(index-1)+3], m_hepevtptr->phep[5*(index-1)+4]);
-    ostr << buf << std::endl;
+    snprintf(buf.data(), buf.size(), "%5i %6i%4i - %4i  %4i - %4i %8.2f %8.2f %8.2f %8.2f %8.2f",
+             index, m_hepevtptr->idhep[index-1],
+             m_hepevtptr->jmohep[2*(index-1)], m_hepevtptr->jmohep[2*(index-1)+1],
+             m_hepevtptr->jdahep[2*(index-1)], m_hepevtptr->jdahep[2*(index-1)+1],
+             m_hepevtptr->phep[5*(index-1)], m_hepevtptr->phep[5*(index-1)+1], m_hepevtptr->phep[5*(index-1)+2], m_hepevtptr->phep[5*(index-1)+3], m_hepevtptr->phep[5*(index-1)+4]);
+    ostr << buf.data() << std::endl;
 }
 
 
 void HEPEVT_Wrapper_Runtime::zero_everything()
 {
     *(m_hepevtptr->nevhep) = 0;
     *(m_hepevtptr->nhep) = 0;
@@ -163,17 +167,18 @@
 {
     return (m_hepevtptr->jdahep[2*(index-1)]) ? (m_hepevtptr->jdahep[2*(index-1)+1]) ? m_hepevtptr->jdahep[2*(index-1)+1]-m_hepevtptr->jdahep[2*(index-1)] : 1 : 0;
 }
 
 int HEPEVT_Wrapper_Runtime::number_children_exact( const int index )  const
 {
     int nc = 0;
-    for ( int i = 1; i <= *(m_hepevtptr->nhep); ++i )
+    for ( int i = 1; i <= *(m_hepevtptr->nhep); ++i ) {
         if (((m_hepevtptr->jmohep[2*(i-1)] <= index && m_hepevtptr->jmohep[2*(i-1)+1] >= index)) || (m_hepevtptr->jmohep[2*(i-1)] == index) ||
                 (m_hepevtptr->jmohep[2*(index-1)+1]==index)) nc++;
+    }
     return nc;
 }
 
 void HEPEVT_Wrapper_Runtime::set_parents( const int index,  const int firstparent, const int lastparent )
 {
     m_hepevtptr->jmohep[2*(index-1)] = firstparent;
     m_hepevtptr->jmohep[2*(index-1)+1] = lastparent;
@@ -213,21 +218,27 @@
 bool HEPEVT_Wrapper_Runtime::fix_daughters()
 {
     /*AV The function should be called  for a record that has correct particle ordering and mother ids.
     As a result it produces a record with ranges where the daughters can be found.
     Not every particle in the range will be a daughter. It is true only for proper events.
     The return tells if the record was fixed succesfully.
     */
-    for ( int i = 1; i <= number_entries(); i++ )
-        for ( int k=1; k <= number_entries(); k++ ) if (i != k)
-                if ((first_parent(k) <= i) && (i <= last_parent(k)))
+    for ( int i = 1; i <= number_entries(); i++ ) {
+        for ( int k=1; k <= number_entries(); k++ ) {
+            if (i != k) {
+                if ((first_parent(k) <= i) && (i <= last_parent(k))) {
                     set_children(i, (first_child(i) == 0 ? k : std::min(first_child(i), k)), (last_child(i) == 0 ? k : std::max(last_child(i), k)));
+                }
+            }
+        }
+    }
     bool is_fixed = true;
-    for ( int i = 1; i <= number_entries(); i++ )
+    for ( int i = 1; i <= number_entries(); i++ ) {
         is_fixed = (is_fixed && (number_children_exact(i) == number_children(i)));
+    }
     return is_fixed;
 }
 
 
 void HEPEVT_Wrapper_Runtime::allocate_internal_storage()
 {
     m_internal_storage.reserve(2*sizeof(int)+m_max_particles*(6*sizeof(int)+9*sizeof(double)));
@@ -256,8 +267,8 @@
     dest += 2*m_max_particles*sizeof(int);
     memcpy(dest, src, 5*N*sizeof(double));
     src  += 5*N*sizeof(double);
     dest += 5*m_max_particles*sizeof(double);
     memcpy(dest, src, 4*N*sizeof(double));
 }
 
-}
+} // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/LHEFAttributes.cc` & `HepMC3-3.2.6/src/LHEFAttributes.cc`

 * *Files 10% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file LHEFAttributes.cc
  *  @brief Implementation of \b class HEPRUPAttribute and HEPEUPAttribute
  */
 
 #include "HepMC3/LHEFAttributes.h"
@@ -19,64 +19,71 @@
     heprup.clear();
 }
 
 bool HEPRUPAttribute::from_string(const std::string &att) {
     bool found = false;
     clear();
     tags = LHEF::XMLTag::findXMLTags(att);
-    for ( int i = 0, N = tags.size(); i < N; ++i )
+    for ( int i = 0, N = tags.size(); i < N; ++i ) {
         if ( tags[i]->name == "init" ) {
             heprup = LHEF::HEPRUP(*tags[i], 3);
             found = true;
         }
+    }
     return found;
 }
 
 bool HEPRUPAttribute::to_string(std::string &att) const {
     std::ostringstream os;
     if ( heprup.NPRUP ) heprup.print(os);
-    for ( int i = 0, N = tags.size(); i < N; ++i )
+    for ( int i = 0, N = tags.size(); i < N; ++i ) {
         if ( heprup.NPRUP == 0 || tags[i]->name != "init" ) tags[i]->print(os);
+    }
     att = os.str();
     return true;
 }
 
 void HEPEUPAttribute::clear() {
     for ( int i = 0, N = tags.size(); i < N; ++i ) delete tags[i];
     tags.clear();
     hepeup.clear();
 }
 
 bool HEPEUPAttribute::from_string(const std::string &att) {
     clear();
     tags = LHEF::XMLTag::findXMLTags(att);
-    for ( int i = 0, N = tags.size(); i < N; ++i )
-        if ( tags[i]->name == "event" || tags[i]->name == "eventgroup")
+    for ( int i = 0, N = tags.size(); i < N; ++i ) {
+        if ( tags[i]->name == "event" || tags[i]->name == "eventgroup") {
             return true;
+        }
+    }
     return false;
 }
 
 bool HEPEUPAttribute::to_string(std::string &att) const {
     std::ostringstream os;
     if ( hepeup.heprup ) hepeup.print(os);
-    for ( int i = 0, N = tags.size(); i < N; ++i )
+    for ( int i = 0, N = tags.size(); i < N; ++i ) {
         if ( !hepeup.heprup ||
-                (tags[i]->name != "event" && tags[i]->name != "eventgroup") )
+                (tags[i]->name != "event" && tags[i]->name != "eventgroup") ) {
             tags[i]->print(os);
+        }
+    }
     att = os.str();
     return true;
 }
 
 bool HEPEUPAttribute::init() {
     std::shared_ptr<HEPRUPAttribute> hepr =
         event()->attribute<HEPRUPAttribute>("HEPRUP");
     bool found = false;
-    for ( int i = 0, N = tags.size(); i < N; ++i )
+    for ( int i = 0, N = tags.size(); i < N; ++i ) {
         if ( tags[i]->name == "event" || tags[i]->name == "eventgroup" ) {
             hepeup = LHEF::HEPEUP(*tags[i], hepr->heprup);
             found = true;
         }
+    }
     return found;
 }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/Print.cc` & `HepMC3-3.2.6/src/Print.cc`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file Print.cc
 /// @brief Implementation of static \b class Print
 ///
 ///
 #include "HepMC3/Print.h"
@@ -17,35 +17,37 @@
 void Print::content(std::ostream& os, const GenEvent &event) {
     os << "--------------------------------" << std::endl;
     os << "--------- EVENT CONTENT --------" << std::endl;
     os << "--------------------------------" << std::endl;
     os << std::endl;
 
     os << "Weights (" << event.weights().size() << "): " << std::endl;
-    for (std::vector<double>::const_iterator w = event.weights().begin(); w != event.weights().end(); ++w )
-        os << " " << *w;
-
+    for (const auto& w: event.weights()) {
+        os << " " << w;
+    }
 
     os << "Attributes:" << std::endl;
 
-    for (auto vt1: event.attributes()) {
-        for (auto vt2: vt1.second) {
+    for (const auto& vt1: event.attributes()) {
+        for (const auto& vt2: vt1.second) {
             os << vt2.first << ": " << vt1.first << std::endl;
         }
     }
 
     os << "GenParticlePtr (" << event.particles().size() << ")" << std::endl;
 
-    for (ConstGenParticlePtr p: event.particles()) {
-        Print::line(p, true);
+    for (const ConstGenParticlePtr& p: event.particles()) {
+        Print::line(os, p, true);
+        os << std::endl;
     }
 
     os << "GenVertexPtr (" << event.vertices().size() << ")" << std::endl;
-    for ( ConstGenVertexPtr v: event.vertices() ) {
-        Print::line(v, true);
+    for ( const ConstGenVertexPtr& v: event.vertices() ) {
+        Print::line(os, v, true);
+        os << std::endl;
     }
 
     os << "-----------------------------" << std::endl;
 }
 
 void Print::listing(std::ostream& os, const GenEvent &event, unsigned short precision) {
     // Find the current stream state
@@ -70,15 +72,15 @@
     os << "                                    GenParticle Legend" << std::endl;
     os << "         ID    PDG ID   "
        << "( px,       py,       pz,     E )"
        << "   Stat ProdVtx" << std::endl;
     os << "________________________________________________________________________" << std::endl;
 
     // Print all vertices
-    for (ConstGenVertexPtr v: event.vertices()) {
+    for (const ConstGenVertexPtr& v: event.vertices()) {
         Print::listing(os, v);
     }
 
     // Restore the stream state
     os.flags(orig);
     os.precision(prec);
     os << "________________________________________________________________________" << std::endl;
@@ -93,29 +95,29 @@
     os.precision(precision);
 
     os << "________________________________________________________________________" << std::endl;
     os << "GenRunInfo:" << std::endl;
 
     std::vector<std::string> names = ri.weight_names();
     os << " Names: ( ";
-    for (auto n: names) os << n;
+    for (const auto& n: names) os << n;
     os << " )" << std::endl;
 
     os << " Tools: " << std::endl;
 
-    for (auto t: ri.tools()) {
+    for (const auto& t: ri.tools()) {
         Print::line(os, t);
     }
     os << "Attributes:" << std::endl;
-    for (auto att: ri.attributes()) {
+    for (const auto& att: ri.attributes()) {
         std::string st;
         if ( !att.second->to_string(st) ) {
             HEPMC3_WARNING("Print::listing: problem serializing attribute: " << att.first)
         }
-        else { os << att.first << " " << att.second->to_string(st);}
+        else { os << att.first << " " << st;}
         os << std::endl;
     }
 
     // Restore the stream state
     os.flags(orig);
     os.precision(prec);
     os << "________________________________________________________________________" << std::endl;
@@ -136,28 +138,28 @@
     else os << " (X,cT): 0";
 
     os << std::endl;
 
     bool printed_header = false;
 
     // Print out all the incoming particles
-    for (ConstGenParticlePtr p: v->particles_in()) {
+    for (const ConstGenParticlePtr& p: v->particles_in()) {
         if ( !printed_header ) {
             os << " I: ";
             printed_header = true;
         }
         else os << "    ";
 
         Print::listing(os, p);
     }
 
     printed_header = false;
 
     // Print out all the outgoing particles
-    for (ConstGenParticlePtr p: v->particles_out()) {
+    for (const ConstGenParticlePtr& p: v->particles_out()) {
         if ( !printed_header ) {
             os << " O: ";
             printed_header = true;
         }
         else os << "    ";
 
         Print::listing(os, p);
@@ -197,22 +199,29 @@
         os << prod->id();
     }
 
     os << std::endl;
 }
 void Print::line(std::ostream& os, const GenEvent &event, bool attributes) {
     os << "GenEvent: #" << event.event_number();
-    if (attributes) for (std::string s: event.attribute_names())
+    if (attributes) {
+        for (const std::string& s: event.attribute_names()) {
             os << " " << s << "=" <<event.attribute_as_string(s);
+        }
+    }
 }
 
 void Print::line(std::ostream& os, const GenRunInfo &RunInfo, bool attributes) {
     os <<"GenRunInfo: Number of tools:" << RunInfo.tools().size();
-    if (attributes) for (std::string s: RunInfo.attribute_names())
+
+    if (attributes) {
+        for (const std::string& s: RunInfo.attribute_names()) {
             os << " " << s << "=" << RunInfo.attribute_as_string(s);
+        }
+    }
 }
 
 void Print::line(std::ostream& os, const GenRunInfo::ToolInfo& t) {
     os << "GenRunInfo::ToolInfo " << t.name<< " " << t.version << " " << t.description;
 }
 
 void Print::line(std::ostream& os, ConstGenVertexPtr v, bool attributes) {
@@ -222,23 +231,24 @@
     os << v->status();
     os << " in: "  << v->particles_in().size();
     os.width(3);
     os << " out: " << v->particles_out().size();
 
     const FourVector &pos = v->position();
     os << " has_set_position: ";
-    if ( v->has_set_position() ) os << "true";
-    else                        os << "false";
+    if ( v->has_set_position() ) { os << "true"; }
+    else  { os << "false"; }
 
     os << " (X,cT): " << pos.x() << ", " <<pos.y() << ", " << pos.z() << ", " << pos.t();
     if (attributes)
     {
         std::vector<std::string> names     = v->attribute_names();
-        for (auto ss: names)
+        for (const auto& ss: names) {
             os << " " << ss << "=" << (*v).attribute_as_string(ss);
+        }
     }
 }
 
 void Print::line(std::ostream& os, const FourVector& p) {
     os << "FourVector: ";
     // Find the current stream state
     std::ios_base::fmtflags orig = os.flags();
@@ -282,29 +292,30 @@
        << "," << momentum.pz()
        << "," << momentum.e();
 
     // Restore the stream state
     os.flags(orig);
     os.precision(prec);
 
-    ConstGenVertexPtr prod = p->production_vertex();
-    ConstGenVertexPtr end  = p->end_vertex();
+    const ConstGenVertexPtr prod = p->production_vertex();
+    const ConstGenVertexPtr end  = p->end_vertex();
     int prod_vtx_id   = (prod) ? prod->id() : 0;
     int end_vtx_id    = (end)  ? end->id()  : 0;
 
     os << " Stat: " << p->status()
        << " PV: " << prod_vtx_id
        << " EV: " << end_vtx_id
        << " Attr: " << (*p).attribute_names().size();
 
     if (attributes)
     {
         std::vector<std::string> names     = p->attribute_names();
-        for (auto ss: names)
+        for (const auto& ss: names) {
             os << " " << ss << "=" << (*p).attribute_as_string(ss);
+        }
     }
 }
 
 void Print::line(std::ostream& os, std::shared_ptr<GenCrossSection> &cs) {
     if (!cs) {os << " GenCrossSection: Empty"; return;}
     os << " GenCrossSection: " << cs->xsec(0)
        << " " << cs->xsec_err(0)
```

### Comparing `HepMC3-3.2.5/src/ReaderAscii.cc` & `HepMC3-3.2.6/src/ReaderAscii.cc`

 * *Files 3% similar despite different names*

```diff
@@ -1,31 +1,32 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file ReaderAscii.cc
 /// @brief Implementation of \b class ReaderAscii
 ///
+#include <array>
 #include <cstring>
 #include <sstream>
 
 #include "HepMC3/ReaderAscii.h"
 
 #include "HepMC3/GenEvent.h"
 #include "HepMC3/GenParticle.h"
 #include "HepMC3/GenVertex.h"
 #include "HepMC3/Units.h"
 
 namespace HepMC3 {
 
 
 ReaderAscii::ReaderAscii(const std::string &filename)
-    : m_file(filename), m_stream(0), m_isstream(false)
+    : m_file(filename), m_stream(nullptr), m_isstream(false)
 {
     if ( !m_file.is_open() ) {
         HEPMC3_ERROR("ReaderAscii: could not open input file: " << filename)
     }
     set_run_info(std::make_shared<GenRunInfo>());
 }
 
@@ -48,55 +49,53 @@
     set_run_info(std::make_shared<GenRunInfo>());
 }
 
 ReaderAscii::~ReaderAscii() { if (!m_isstream) close(); }
 
 bool ReaderAscii::skip(const int n)
 {
-    const size_t       max_buffer_size = 512*512;
-    char               buf[max_buffer_size];
+    std::array<char, 262144> buf;
     bool               event_context    = false;
     bool               run_info_context    = false;
     int nn = n;
     while (!failed()) {
-        char  peek;
+        char  peek(0);
         if ( (!m_file.is_open()) && (!m_isstream) ) return false;
         m_isstream ? peek = m_stream->peek() : peek = m_file.peek();
         if ( peek == 'E' ) { event_context = true; nn--; }
         //We have to read each run info.
         if ( !event_context && ( peek == 'W' || peek == 'A' || peek == 'T' ) ) {
-            m_isstream ? m_stream->getline(buf, max_buffer_size) : m_file.getline(buf, max_buffer_size);
+            m_isstream ? m_stream->getline(buf.data(), buf.size()) : m_file.getline(buf.data(), buf.size());
             if (!run_info_context) {
                 set_run_info(std::make_shared<GenRunInfo>());
                 run_info_context = true;
             }
             if ( peek == 'W' ) {
-                parse_weight_names(buf);
+                parse_weight_names(buf.data());
             }
             if ( peek == 'T' ) {
-                parse_tool(buf);
+                parse_tool(buf.data());
             }
             if ( peek == 'A' ) {
-                parse_run_attribute(buf);
+                parse_run_attribute(buf.data());
             }
         }
         if ( event_context && ( peek == 'V' || peek == 'P' ) ) event_context=false;
         if (nn < 0) return true;
-        m_isstream ? m_stream->getline(buf, max_buffer_size) : m_file.getline(buf, max_buffer_size);
+        m_isstream ? m_stream->getline(buf.data(), buf.size()) : m_file.getline(buf.data(), buf.size());
     }
     return true;
 }
 
 
 bool ReaderAscii::read_event(GenEvent &evt) {
     if ( (!m_file.is_open()) && (!m_isstream) ) return false;
 
-    char               peek;
-    const size_t       max_buffer_size = 512*512;
-    char               buf[max_buffer_size];
+    char               peek(0);
+    std::array<char, 262144> buf;
     bool               event_context    = false;
     bool               parsed_weights    = false;
     bool               parsed_particles_or_vertices    = false;
     bool               run_info_context    = false;
     bool               is_parsing_successful  = true;
     std::pair<int, int> vertices_and_particles(0, 0);
 
@@ -104,92 +103,92 @@
     evt.set_run_info(run_info());
     m_forward_daughters.clear();
     m_forward_mothers.clear();
     //
     // Parse event, vertex and particle information
     //
     while (!failed()) {
-        m_isstream ? m_stream->getline(buf, max_buffer_size) : m_file.getline(buf, max_buffer_size);
+        m_isstream ? m_stream->getline(buf.data(), buf.size()) : m_file.getline(buf.data(), buf.size());
 
-        if ( strlen(buf) == 0 ) continue;
+        if ( strlen(buf.data()) == 0 ) continue;
 
         // Check for ReaderAscii header/footer
-        if ( strncmp(buf, "HepMC", 5) == 0 ) {
-            if ( strncmp(buf, "HepMC::Version", 14) != 0 && strncmp(buf, "HepMC::Asciiv3", 14) != 0 )
+        if ( strncmp(buf.data(), "HepMC", 5) == 0 ) {
+            if ( strncmp(buf.data(), "HepMC::Version", 14) != 0 && strncmp(buf.data(), "HepMC::Asciiv3", 14) != 0 )
             {
                 HEPMC3_WARNING("ReaderAscii: found unsupported expression in header. Will close the input.")
-                std::cout << buf << std::endl;
+                std::cout << buf.data() << std::endl;
                 m_isstream ? m_stream->clear(std::ios::eofbit) : m_file.clear(std::ios::eofbit);
             }
             if (event_context) {
                 is_parsing_successful = true;
                 break;
             }
             continue;
         }
 
         switch (buf[0]) {
         case 'E':
-            vertices_and_particles = parse_event_information(evt, buf);
+            vertices_and_particles = parse_event_information(evt, buf.data());
             if (vertices_and_particles.second < 0) {
                 is_parsing_successful = false;
             } else {
                 is_parsing_successful = true;
                 event_context   = true;
                 parsed_weights = false;
                 parsed_particles_or_vertices = false;
             }
             run_info_context   = false;
             break;
         case 'V':
-            is_parsing_successful = parse_vertex_information(evt, buf);
+            is_parsing_successful = parse_vertex_information(evt, buf.data());
             parsed_particles_or_vertices =  true;
             break;
         case 'P':
-            is_parsing_successful = parse_particle_information(evt, buf);
+            is_parsing_successful = parse_particle_information(evt, buf.data());
             parsed_particles_or_vertices =  true;
             break;
         case 'W':
             if ( event_context ) {
-                is_parsing_successful = parse_weight_values(evt, buf);
+                is_parsing_successful = parse_weight_values(evt, buf.data());
                 parsed_weights=true;
             } else {
                 if ( !run_info_context ) {
                     set_run_info(std::make_shared<GenRunInfo>());
                     evt.set_run_info(run_info());
                 }
                 run_info_context = true;
-                is_parsing_successful = parse_weight_names(buf);
+                is_parsing_successful = parse_weight_names(buf.data());
             }
             break;
         case 'U':
-            is_parsing_successful = parse_units(evt, buf);
+            is_parsing_successful = parse_units(evt, buf.data());
             break;
         case 'T':
             if ( event_context ) {
                 //We ignore T in the event context
             } else {
                 if ( !run_info_context ) {
                     set_run_info(std::make_shared<GenRunInfo>());
                     evt.set_run_info(run_info());
                 }
                 run_info_context = true;
-                is_parsing_successful = parse_tool(buf);
+                is_parsing_successful = parse_tool(buf.data());
             }
             break;
         case 'A':
             if ( event_context ) {
-                is_parsing_successful = parse_attribute(evt, buf);
+                is_parsing_successful = parse_attribute(evt, buf.data());
             } else {
                 if ( !run_info_context ) {
                     set_run_info(std::make_shared<GenRunInfo>());
                     evt.set_run_info(run_info());
                 }
                 run_info_context = true;
-                is_parsing_successful = parse_run_attribute(buf);
+                is_parsing_successful = parse_run_attribute(buf.data());
             }
             break;
         default:
             HEPMC3_WARNING("ReaderAscii: skipping unrecognised prefix: " << buf[0])
             is_parsing_successful = true;
             break;
         }
@@ -236,40 +235,47 @@
         HEPMC3_ERROR("ReaderAscii: too few vertices were parsed")
         printf("%zu  vs  %i expected\n", evt.vertices().size(), vertices_and_particles.first);
         is_parsing_successful =  false;
     }
     // Check if there were HEPMC3_ERRORs during parsing
     if ( !is_parsing_successful ) {
         HEPMC3_ERROR("ReaderAscii: event parsing failed. Returning empty event")
-        HEPMC3_DEBUG(1, "Parsing failed at line:" << std::endl << buf)
+        HEPMC3_DEBUG(1, "Parsing failed at line:" << std::endl << buf.data())
 
         evt.clear();
         m_isstream ? m_stream->clear(std::ios::badbit) : m_file.clear(std::ios::badbit);
 
         return false;
     }
-    for ( auto p : m_forward_daughters )
-        for (auto v: evt.vertices())
-            if (p.second == v->id())
+    for (const auto& p : m_forward_daughters )
+    {
+        for (const auto& v: evt.vertices()) {
+            if (p.second == v->id()) {
                 v->add_particle_out(p.first);
-    for ( auto v : m_forward_mothers )  for ( auto idpm : v.second )  v.first->add_particle_in(evt.particles()[idpm-1]);
+            }
+        }
+    }
+    for ( const auto& v : m_forward_mothers )  for (const auto& idpm : v.second )  v.first->add_particle_in(evt.particles()[idpm-1]);
 
     /* restore ids of vertices using a bank of available ids*/
     std::vector<int> all_ids;
+    all_ids.reserve(evt.vertices().size());
     std::vector<int> filled_ids;
+    filled_ids.reserve(evt.vertices().size());
     std::vector<int> diff;
-    for (auto v: evt.vertices()) if (v->id() != 0) filled_ids.push_back(v->id());
-    for (int i = -((long)evt.vertices().size()); i < 0; i++) all_ids.push_back(i);
+    diff.reserve(evt.vertices().size());
+    for (const auto& v: evt.vertices()) if (v->id() != 0) filled_ids.emplace_back(v->id());
+    for (int i = -((long)evt.vertices().size()); i < 0; i++) all_ids.emplace_back(i);
     std::sort(all_ids.begin(), all_ids.end());
     std::sort(filled_ids.begin(), filled_ids.end());
     //The bank of available ids is created as a difference between all range of ids and the set of used ids
     std::set_difference(all_ids.begin(), all_ids.end(), filled_ids.begin(), filled_ids.end(), std::inserter(diff, diff.begin()));
     auto it = diff.rbegin();
     //Set available ids to vertices sequentially.
-    for (auto v: evt.vertices()) if (v->id() == 0) { v->set_id(*it); it++;}
+    for (const auto& v: evt.vertices()) if (v->id() == 0) { v->set_id(*it); it++;}
 
     return true;
 }
 
 
 std::pair<int, int> ReaderAscii::parse_event_information(GenEvent &evt, const char *buf) {
     static const std::pair<int, int>  err(-1, -1);
@@ -316,21 +322,22 @@
     return ret;
 }
 
 
 bool ReaderAscii::parse_weight_values(GenEvent &evt, const char *buf) {
     std::istringstream iss(buf + 1);
     std::vector<double> wts;
-    double w;
-    while (iss >> w) wts.push_back(w);
-    if ( run_info() && run_info()->weight_names().size()
-            && run_info()->weight_names().size() != wts.size() )
+    double w = 0.0;
+    while (iss >> w) wts.emplace_back(w);
+    if ( run_info() && !run_info()->weight_names().empty()
+            && run_info()->weight_names().size() != wts.size() ) {
         throw std::logic_error("ReaderAscii::parse_weight_values: "
                                "The number of weights ("+std::to_string((long long int)(wts.size()))+") does not match "
                                "the  number weight names("+std::to_string((long long int)(run_info()->weight_names().size()))+") in the GenRunInfo object");
+    }
     evt.weights() = wts;
 
     return true;
 }
 
 
 bool ReaderAscii::parse_units(GenEvent &evt, const char *buf) {
@@ -458,28 +465,29 @@
 
         vertex->add_particle_out(data);
         evt.add_vertex(vertex);
         //ID of this vertex is not explicitely set in the input. We set it to zero to prevent overlap with other ids. It will be restored later.
         vertex->set_id(0);
     }
     // Parent object is vertex
-    else if ( mother_id < 0 )
-    {
-        //Vertices are not always ordered, e.g. when one reads HepMC2 event, so we check their ids.
-        bool found = false;
-        for (auto v: evt.vertices()) if (v->id() == mother_id) {v->add_particle_out(data); found = true; break; }
-        if (!found)
+    else {
+        if ( mother_id < 0 )
         {
-            //This should happen  in case of unordered event.
-            //      WARNING("ReaderAscii: Unordered event, id of mother vertex  is out of range of known ids:   " <<mother_id<<" evt.vertices().size()="<<evt.vertices().size() )
-            //Save the mother id to reconnect later.
-            m_forward_daughters[data] = mother_id;
+            //Vertices are not always ordered, e.g. when one reads HepMC2 event, so we check their ids.
+            bool found = false;
+            for (auto v: evt.vertices()) if (v->id() == mother_id) {v->add_particle_out(data); found = true; break; }
+            if (!found)
+            {
+                //This should happen  in case of unordered event.
+                //      WARNING("ReaderAscii: Unordered event, id of mother vertex  is out of range of known ids:   " <<mother_id<<" evt.vertices().size()="<<evt.vertices().size() )
+                //Save the mother id to reconnect later.
+                m_forward_daughters[data] = mother_id;
+            }
         }
     }
-
     // pdg id
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     data->set_pid(atoi(cursor));
 
     // px
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     momentum.setPx(atof(cursor));
@@ -512,105 +520,107 @@
     return true;
 }
 
 
 bool ReaderAscii::parse_attribute(GenEvent &evt, const char *buf) {
     const char     *cursor  = buf;
     const char     *cursor2 = buf;
-    char            name[512];
+    std::array<char, 512> name;
     int             id = 0;
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     id = atoi(cursor);
 
     if ( !(cursor  = strchr(cursor+1, ' ')) ) return false;
     ++cursor;
 
     if ( !(cursor2 = strchr(cursor, ' ')) ) return false;
-    snprintf(name, 512, "%.*s", (int)(cursor2-cursor), cursor);
+    snprintf(name.data(), name.size(), "%.*s", (int)(cursor2-cursor), cursor);
 
     cursor = cursor2+1;
 
     std::shared_ptr<Attribute> att =
         std::make_shared<StringAttribute>(StringAttribute(unescape(cursor)));
 
-    evt.add_attribute(std::string(name), att, id);
+    evt.add_attribute(std::string(name.data()), att, id);
 
     return true;
 }
 
 bool ReaderAscii::parse_run_attribute(const char *buf) {
     const char     *cursor  = buf;
     const char     *cursor2 = buf;
-    char            name[512];
+    std::array<char, 512> name;
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     ++cursor;
 
     if ( !(cursor2 = strchr(cursor, ' ')) ) return false;
-    snprintf(name, 512, "%.*s", (int)(cursor2-cursor), cursor);
+    snprintf(name.data(), name.size(), "%.*s", (int)(cursor2-cursor), cursor);
 
     cursor = cursor2+1;
 
     std::shared_ptr<StringAttribute> att =
         std::make_shared<StringAttribute>(StringAttribute(unescape(cursor)));
 
-    run_info()->add_attribute(std::string(name), att);
+    run_info()->add_attribute(std::string(name.data()), att);
 
     return true;
 }
 
 
 bool ReaderAscii::parse_weight_names(const char *buf) {
     const char     *cursor  = buf;
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     ++cursor;
 
     std::istringstream iss(unescape(cursor));
     std::vector<std::string> names;
     std::string name;
-    while (iss >> name) names.push_back(name);
+    while (iss >> name) names.emplace_back(name);
 
     run_info()->set_weight_names(names);
 
     return true;
 }
 
 bool ReaderAscii::parse_tool(const char *buf) {
     const char     *cursor  = buf;
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     ++cursor;
     std::string line = unescape(cursor);
     GenRunInfo::ToolInfo tool;
-    std::string::size_type pos = line.find("\n");
+    std::string::size_type pos = line.find('\n');
     tool.name = line.substr(0, pos);
     line = line.substr(pos + 1);
-    pos = line.find("\n");
+    pos = line.find('\n');
     tool.version = line.substr(0, pos);
     tool.description = line.substr(pos + 1);
-    run_info()->tools().push_back(tool);
+    run_info()->tools().emplace_back(tool);
 
     return true;
 }
 
 
 std::string ReaderAscii::unescape(const std::string& s) {
     std::string ret;
     ret.reserve(s.length());
     for ( std::string::const_iterator it = s.begin(); it != s.end(); ++it ) {
         if ( *it == '\\' ) {
             ++it;
-            if ( *it == '|' )
+            if ( *it == '|' ) {
                 ret += '\n';
-            else
+            }
+            else {
                 ret += *it;
+            }
         } else
-            ret += *it;
+        {ret += *it;}
     }
 
     return ret;
 }
 
 bool ReaderAscii::failed() { return m_isstream ? (bool)m_stream->rdstate() :(bool)m_file.rdstate(); }
```

### Comparing `HepMC3-3.2.5/src/ReaderAsciiHepMC2.cc` & `HepMC3-3.2.6/src/ReaderAsciiHepMC2.cc`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file ReaderAsciiHepMC2.cc
  *  @brief Implementation of \b class ReaderAsciiHepMC2
  *
  */
-#include <cstring>
+#include <array>
 #include <cstdlib>
-
-#include "HepMC3/ReaderAsciiHepMC2.h"
+#include <cstring>
 
 #include "HepMC3/GenEvent.h"
-#include "HepMC3/GenVertex.h"
-#include "HepMC3/GenParticle.h"
 #include "HepMC3/GenHeavyIon.h"
+#include "HepMC3/GenParticle.h"
 #include "HepMC3/GenPdfInfo.h"
+#include "HepMC3/GenVertex.h"
+#include "HepMC3/ReaderAsciiHepMC2.h"
 #include "HepMC3/Setup.h"
 
 namespace HepMC3 {
 
 ReaderAsciiHepMC2::ReaderAsciiHepMC2(const std::string& filename):
     m_file(filename), m_stream(nullptr), m_isstream(false) {
     if ( !m_file.is_open() ) {
@@ -51,34 +51,32 @@
 }
 
 
 ReaderAsciiHepMC2::~ReaderAsciiHepMC2() { if (m_event_ghost) { m_event_ghost->clear(); delete m_event_ghost; m_event_ghost=nullptr; } if (!m_isstream) close(); }
 
 bool ReaderAsciiHepMC2::skip(const int n)
 {
-    const size_t       max_buffer_size = 512*512;
-    char               buf[max_buffer_size];
+    std::array<char, 262144> buf;
     int nn = n;
     while (!failed()) {
-        char peek;
+        char peek(0);
         if ( (!m_file.is_open()) && (!m_isstream) ) return false;
         m_isstream ? peek = m_stream->peek() : peek = m_file.peek();
         if ( peek =='E' ) nn--;
-        if (nn < 0) return true;
-        m_isstream ? m_stream->getline(buf, max_buffer_size) : m_file.getline(buf, max_buffer_size);
+        if (nn < 0) { return true; }
+        m_isstream ? m_stream->getline(buf.data(), buf.size()) : m_file.getline(buf.data(), buf.size());
     }
     return true;
 }
 
 bool ReaderAsciiHepMC2::read_event(GenEvent &evt) {
     if ( (!m_file.is_open()) && (!m_isstream) ) return false;
 
-    char               peek;
-    const size_t  max_buffer_size = 512*512;
-    char          buf[max_buffer_size];
+    char               peek = 0;
+    std::array<char, 262144> buf;
     bool          parsed_event_header            = false;
     bool          is_parsing_successful          = true;
     int           parsing_result                 = 0;
     unsigned int  vertices_count                 = 0;
     unsigned int  current_vertex_particles_count = 0;
     unsigned int  current_vertex_particles_parsed = 0;
 
@@ -93,33 +91,33 @@
     m_end_vertex_barcodes.clear();
     m_particle_cache_ghost.clear();
     m_vertex_cache_ghost.clear();
     //
     // Parse event, vertex and particle information
     //
     while (!failed()) {
-        m_isstream ? m_stream->getline(buf, max_buffer_size) : m_file.getline(buf, max_buffer_size);
-        if ( strlen(buf) == 0 ) continue;
+        m_isstream ? m_stream->getline(buf.data(), buf.size()) : m_file.getline(buf.data(), buf.size());
+        if ( strlen(buf.data()) == 0 ) continue;
         // Check for IO_GenEvent header/footer
-        if ( strncmp(buf, "HepMC", 5) == 0 ) {
-            if ( strncmp(buf, "HepMC::Version", 14) != 0 && strncmp(buf, "HepMC::IO_GenEvent", 18) != 0 )
+        if ( strncmp(buf.data(), "HepMC", 5) == 0 ) {
+            if ( strncmp(buf.data(), "HepMC::Version", 14) != 0 && strncmp(buf.data(), "HepMC::IO_GenEvent", 18) != 0 )
             {
                 HEPMC3_WARNING("ReaderAsciiHepMC2: found unsupported expression in header. Will close the input.")
-                std::cout <<buf << std::endl;
+                std::cout <<buf.data() << std::endl;
                 m_isstream ? m_stream->clear(std::ios::eofbit) : m_file.clear(std::ios::eofbit);
             }
             if (parsed_event_header) {
                 is_parsing_successful = true;
                 break;
             }
             continue;
         }
         switch (buf[0]) {
         case 'E':
-            parsing_result = parse_event_information(evt, buf);
+            parsing_result = parse_event_information(evt, buf.data());
             if (parsing_result < 0) {
                 is_parsing_successful = false;
                 HEPMC3_ERROR("ReaderAsciiHepMC2: HEPMC3_ERROR parsing event information")
             }
             else {
                 vertices_count = parsing_result;
                 m_vertex_cache.reserve(vertices_count);
@@ -141,52 +139,52 @@
                      information about number of particles in vertex. Hence '<' sign */
             if (current_vertex_particles_parsed < current_vertex_particles_count) {
                 is_parsing_successful = false;
                 break;
             }
             current_vertex_particles_parsed = 0;
 
-            parsing_result = parse_vertex_information(buf);
+            parsing_result = parse_vertex_information(buf.data());
 
             if (parsing_result < 0) {
                 is_parsing_successful = false;
                 HEPMC3_ERROR("ReaderAsciiHepMC2: HEPMC3_ERROR parsing vertex information")
             }
             else {
                 current_vertex_particles_count = parsing_result;
                 is_parsing_successful = true;
             }
             break;
         case 'P':
 
-            parsing_result   = parse_particle_information(buf);
+            parsing_result   = parse_particle_information(buf.data());
 
             if (parsing_result < 0) {
                 is_parsing_successful = false;
                 HEPMC3_ERROR("ReaderAsciiHepMC2: HEPMC3_ERROR parsing particle information")
             }
             else {
                 ++current_vertex_particles_parsed;
                 is_parsing_successful = true;
             }
             break;
         case 'U':
-            is_parsing_successful = parse_units(evt, buf);
+            is_parsing_successful = parse_units(evt, buf.data());
             break;
         case 'F':
-            is_parsing_successful = parse_pdf_info(evt, buf);
+            is_parsing_successful = parse_pdf_info(evt, buf.data());
             break;
         case 'H':
-            is_parsing_successful = parse_heavy_ion(evt, buf);
+            is_parsing_successful = parse_heavy_ion(evt, buf.data());
             break;
         case 'N':
-            is_parsing_successful = parse_weight_names(buf);
+            is_parsing_successful = parse_weight_names(buf.data());
             break;
         case 'C':
-            is_parsing_successful = parse_xs_info(evt, buf);
+            is_parsing_successful = parse_xs_info(evt, buf.data());
             break;
         default:
             HEPMC3_WARNING("ReaderAsciiHepMC2: skipping unrecognised prefix: " << buf[0])
             is_parsing_successful = true;
             break;
         }
 
@@ -208,18 +206,25 @@
     else if (is_parsing_successful && m_vertex_cache.size() != vertices_count) {
         HEPMC3_ERROR("ReaderAsciiHepMC2: not all vertices parsed")
         is_parsing_successful = false;
     }
 
     if ( !is_parsing_successful ) {
         HEPMC3_ERROR("ReaderAsciiHepMC2: event parsing failed. Returning empty event")
-        HEPMC3_DEBUG(1, "Parsing failed at line:" << std::endl << buf)
+        HEPMC3_DEBUG(1, "Parsing failed at line:" << std::endl << buf.data())
         evt.clear();
         m_isstream ? m_stream->clear(std::ios::badbit) : m_file.clear(std::ios::badbit);
-        return 0;
+        return false;
+    }
+    if (run_info() && run_info()->weight_names().empty() ) {
+        run_info()->set_weight_names(std::vector<std::string> {"Default"});
+    }
+    if (evt.weights().empty()) {
+        HEPMC3_WARNING("ReaderAsciiHepMC2: weights are empty, an event weight 1.0 will be added.")
+        evt.weights().push_back(1.0);
     }
 
     // Restore production vertex pointers
     for (unsigned int i = 0; i < m_particle_cache.size(); ++i) {
         if ( !m_end_vertex_barcodes[i] ) continue;
 
         for (unsigned int j = 0; j < m_vertex_cache.size(); ++j) {
@@ -228,90 +233,96 @@
                 break;
             }
         }
     }
 
     // Remove vertices with no incoming particles or no outgoing particles
     for (unsigned int i = 0; i < m_vertex_cache.size(); ++i) {
-        if ( m_vertex_cache[i]->particles_in().size() == 0 ) {
+        if ( m_vertex_cache[i]->particles_in().empty() ) {
             HEPMC3_DEBUG(30, "ReaderAsciiHepMC2::read_event - found a vertex without incoming particles: " << m_vertex_cache[i]->id() );
             //Sometimes the root vertex has no incoming particles.  Here we try to save the event.
             std::vector<GenParticlePtr> beams;
-            for (auto p: m_vertex_cache[i]->particles_out()) if (p->status() == 4 && !(p->end_vertex())) beams.push_back(p);
-            for (auto p: beams)
+            beams.reserve(2);
+            for (const auto& p: m_vertex_cache[i]->particles_out()) if (p->status() == 4 && !(p->end_vertex())) beams.emplace_back(p);
+            for (auto& p: beams)
             {
                 m_vertex_cache[i]->add_particle_in(p);
                 m_vertex_cache[i]->remove_particle_out(p);
                 HEPMC3_DEBUG(30, "ReaderAsciiHepMC2::read_event - moved particle with status=4 from the outgoing to the incoming particles of vertex: " << m_vertex_cache[i]->id());
             }
-            if (beams.size() == 0) {
+            if (beams.empty()) {
                 HEPMC3_DEBUG(30, "ReaderAsciiHepMC2::read_event - removed vertex without incoming particles: " << m_vertex_cache[i]->id() );
                 m_vertex_cache[i] = nullptr;
             }
         }
-        else if ( m_vertex_cache[i]->particles_out().size() == 0 ) {
+        else if ( m_vertex_cache[i]->particles_out().empty() ) {
             m_vertex_cache[i] = nullptr;
             HEPMC3_DEBUG(30, "ReaderAsciiHepMC2::read_event - removed vertex without outgoing particles: " << m_vertex_cache[i]->id());
         }
     }
 
     // Reserve memory for the event
     evt.reserve(m_particle_cache.size(), m_vertex_cache.size());
 
     // Add whole event tree in topological order
     evt.add_tree(m_particle_cache);
 
-    if (m_options.find("event_random_states_are_separated") != m_options.end())
+    if (m_options.count("event_random_states_are_separated") != 0)
     {
         std::shared_ptr<VectorLongIntAttribute> random_states_a = evt.attribute<VectorLongIntAttribute>("random_states");
         if (random_states_a) {
             std::vector<long int> random_states_v = random_states_a->value();
-            for (size_t i = 0; i < random_states_v.size(); ++i )
+            for (size_t i = 0; i < random_states_v.size(); ++i ) {
                 evt.add_attribute("random_states" + std::to_string((long long unsigned int)i), std::make_shared<IntAttribute>(random_states_v[i]));
+            }
             evt.remove_attribute("random_states");
         }
 
     }
 
     std::map< std::string, std::map<int, std::shared_ptr<Attribute> > > cached_attributes = m_event_ghost->attributes();
-    if (cached_attributes.find("flows") != cached_attributes.end()) {
-        std::map<int, std::shared_ptr<Attribute> > flows = cached_attributes.at("flows");
-        if (m_options.find("particle_flows_are_separated") == m_options.end()) {
-            for (auto f: flows) if (f.first > 0 && f.first <= (int)m_particle_cache.size())  m_particle_cache[f.first-1]->add_attribute("flows", f.second);
+    if (cached_attributes.count("flows") != 0) {
+        const std::map<int, std::shared_ptr<Attribute> >& flows = cached_attributes.at("flows");
+        if (m_options.count("particle_flows_are_separated") == 0) {
+            for (const auto& f: flows) if (f.first > 0 && f.first <= (int)m_particle_cache.size()) {  m_particle_cache[f.first-1]->add_attribute("flows", f.second);}
         } else  {
-            for (auto f: flows) if (f.first > 0 && f.first <= (int)m_particle_cache.size()) {
+            for (const auto& f: flows) {
+                if (f.first > 0 && f.first <= (int)m_particle_cache.size()) {
                     std::shared_ptr<VectorIntAttribute>  casted = std::dynamic_pointer_cast<VectorIntAttribute>(f.second);
                     if (!casted) continue;//Should not happen
                     std::vector<int> this_p_flow = casted->value();
                     for (size_t i = 0; i<this_p_flow.size(); i++) m_particle_cache[f.first-1]->add_attribute("flow" + std::to_string(i + 1), std::make_shared<IntAttribute>(this_p_flow[i]));
                 }
+            }
         }
     }
 
-    if (cached_attributes.find("phi") != cached_attributes.end()) {
-        std::map<int, std::shared_ptr<Attribute> > phi = cached_attributes.at("phi");
-        for (auto f: phi) if (f.first > 0 &&f.first <= (int)m_particle_cache.size())  m_particle_cache[f.first-1]->add_attribute("phi", f.second);
+    if (cached_attributes.count("phi") != 0) {
+        const std::map<int, std::shared_ptr<Attribute> >& phi = cached_attributes.at("phi");
+        for (const auto& f: phi) if (f.first > 0 &&f.first <= (int)m_particle_cache.size())  m_particle_cache[f.first-1]->add_attribute("phi", f.second);
     }
 
-    if (cached_attributes.find("theta") != cached_attributes.end()) {
-        std::map<int, std::shared_ptr<Attribute> > theta = cached_attributes.at("theta");
-        for (auto f: theta) if (f.first > 0 && f.first <= (int)m_particle_cache.size())  m_particle_cache[f.first-1]->add_attribute("theta", f.second);
+    if (cached_attributes.count("theta") != 0) {
+        const std::map<int, std::shared_ptr<Attribute> >& theta = cached_attributes.at("theta");
+        for (const auto& f: theta) if (f.first > 0 && f.first <= (int)m_particle_cache.size())  m_particle_cache[f.first-1]->add_attribute("theta", f.second);
     }
 
-    if (cached_attributes.find("weights") != cached_attributes.end()) {
-        std::map<int, std::shared_ptr<Attribute> > weights = cached_attributes.at("weights");
-        if (m_options.find("vertex_weights_are_separated") == m_options.end()) {
-            for (auto f: weights) if (f.first < 0 && f.first >= -(int)m_vertex_cache.size())  m_vertex_cache[-f.first-1]->add_attribute("weights", f.second);
+    if (cached_attributes.count("weights") != 0) {
+        const std::map<int, std::shared_ptr<Attribute> >& weights = cached_attributes.at("weights");
+        if (m_options.count("vertex_weights_are_separated") == 0) {
+            for (const auto& f: weights) { if (f.first < 0 && f.first >= -(int)m_vertex_cache.size())  m_vertex_cache[-f.first-1]->add_attribute("weights", f.second);}
         } else {
-            for (auto f: weights) if (f.first < 0 && f.first >= -(int)m_vertex_cache.size()) {
+            for (const auto& f: weights) {
+                if (f.first < 0 && f.first >= -(int)m_vertex_cache.size()) {
                     std::shared_ptr<VectorDoubleAttribute>  casted = std::dynamic_pointer_cast<VectorDoubleAttribute>(f.second);
                     if (!casted) continue;//Should not happen
                     std::vector<double> this_v_weight = casted->value();
                     for (size_t i = 0; i < this_v_weight.size(); i++) m_particle_cache[-f.first-1]->add_attribute("weight"+std::to_string(i), std::make_shared<DoubleAttribute>(this_v_weight[i]));
                 }
+            }
         }
     }
 
     std::shared_ptr<IntAttribute> signal_process_vertex_barcode = evt.attribute<IntAttribute>("signal_process_vertex");
     if (signal_process_vertex_barcode) {
         int signal_process_vertex_barcode_value = signal_process_vertex_barcode->value();
         for (unsigned int i = 0; i < m_vertex_cache.size(); ++i)
@@ -322,20 +333,20 @@
             evt.add_attribute("signal_process_vertex", signal_process_vertex);
             break;
         }
     }
     m_particle_cache_ghost.clear();
     m_vertex_cache_ghost.clear();
     m_event_ghost->clear();
-    return 1;
+    return true;
 }
 
 int ReaderAsciiHepMC2::parse_event_information(GenEvent &evt, const char *buf) {
     const char          *cursor             = buf;
-    int                  vertices_count     = 0;
+    size_t               vertices_count     = 0;
     int                  random_states_size = 0;
     int                  weights_size       = 0;
     std::vector<long>    random_states(0);
     std::vector<double>  weights(0);
 
     // event number
     if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
@@ -374,28 +385,34 @@
 
     // SKIPPED: beam 2
     if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
 
     //random states
     if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
     random_states_size = atoi(cursor);
-    random_states.resize(random_states_size);
-
+    if (random_states_size >= 0 ) {
+        random_states.resize(random_states_size);
+    } else {
+        HEPMC3_DEBUG(0, "ReaderAsciiHepMC2: E: " << evt.event_number() << " (" << vertices_count << "V, "  << random_states_size << "RS)")
+    }
     for ( int i = 0; i < random_states_size; ++i ) {
         if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
         random_states[i] = atoi(cursor);
     }
 
-    if (random_states.size()) evt.add_attribute("random_states", std::make_shared<VectorLongIntAttribute>(random_states));
+    if (!random_states.empty()) evt.add_attribute("random_states", std::make_shared<VectorLongIntAttribute>(random_states));
 
     // weights
     if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
     weights_size = atoi(cursor);
-    weights.resize(weights_size);
-
+    if (weights_size >= 0 ) {
+        weights.resize(weights_size);
+    } else {
+        HEPMC3_DEBUG(0, "ReaderAsciiHepMC2: E: " << evt.event_number() << " (" << vertices_count << "V, " << weights_size << "WS)")
+    }
     for ( int i = 0; i < weights_size; ++i ) {
         if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
         weights[i] = atof(cursor);
     }
 
     evt.weights() = weights;
 
@@ -473,22 +490,22 @@
         if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
         weights[i] = atof(cursor);
     }
 
 
 
     // Add original vertex barcode to the cache
-    m_vertex_cache.push_back(data);
-    m_vertex_barcodes.push_back(barcode);
+    m_vertex_cache.emplace_back(data);
+    m_vertex_barcodes.emplace_back(barcode);
 
     m_event_ghost->add_vertex(data_ghost);
 
-    if (weights.size()) data_ghost->add_attribute("weights", std::make_shared<VectorDoubleAttribute>(weights));
+    if (!weights.empty()) data_ghost->add_attribute("weights", std::make_shared<VectorDoubleAttribute>(weights));
 
-    m_vertex_cache_ghost.push_back(data_ghost);
+    m_vertex_cache_ghost.emplace_back(data_ghost);
 
     HEPMC3_DEBUG(10, "ReaderAsciiHepMC2: V: " << -(int)m_vertex_cache.size() << " (old barcode " << barcode << ") " << num_particles_out << " particles)")
 
     return num_particles_out;
 }
 
 int ReaderAsciiHepMC2::parse_particle_information(const char *buf) {
@@ -556,48 +573,52 @@
         if ( !(cursor = strchr(cursor+1, ' ')) ) return -1;
         int flowvalue = atoi(cursor);
         flows[flowindex] = flowvalue;
     }
     if (flowsize)
     {
         std::vector<int> vectorflows;
-        for (auto f: flows) vectorflows.push_back(f.second);
+        vectorflows.reserve(flows.size());
+        for (const auto& f: flows) { vectorflows.emplace_back(f.second); }
         data_ghost->add_attribute("flows", std::make_shared<VectorIntAttribute>(vectorflows));
     }
     // Set prod_vtx link
     if ( end_vtx == m_vertex_barcodes.back() ) {
         m_vertex_cache.back()->add_particle_in(data);
         end_vtx = 0;
     }
     else {
         m_vertex_cache.back()->add_particle_out(data);
     }
 
-    m_particle_cache.push_back(data);
-    m_particle_cache_ghost.push_back(data_ghost);
-    m_end_vertex_barcodes.push_back(end_vtx);
+    m_particle_cache.emplace_back(data);
+    m_particle_cache_ghost.emplace_back(data_ghost);
+    m_end_vertex_barcodes.emplace_back(end_vtx);
 
     HEPMC3_DEBUG(10, "ReaderAsciiHepMC2: P: " << m_particle_cache.size() << " ( pid: " << data->pid() << ") end vertex: " << end_vtx)
 
     return 0;
 }
 
 bool ReaderAsciiHepMC2::parse_xs_info(GenEvent &evt, const char *buf) {
     const char *cursor  = buf;
     std::shared_ptr<GenCrossSection>  xs     = std::make_shared<GenCrossSection>();
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
-    double xs_val  = atof(cursor);
+    const double xs_val  = atof(cursor);
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
-    double xs_err = atof(cursor);
-
-    xs->set_cross_section(xs_val, xs_err);
+    const double xs_err = atof(cursor);
+    const size_t all = m_options.count("disable_pad_cross_sections") ? size_t{1} : std::max(evt.weights().size(),size_t{1});
+    const double xs_val_dummy = m_options.count("pad_cross_section_value") ? std::strtod(m_options.at("pad_cross_section_value").c_str(),nullptr) : 0.0;
+    const double xs_err_dummy = m_options.count("pad_cross_section_error") ? std::strtod(m_options.at("pad_cross_section_error").c_str(),nullptr) : 0.0;
+    xs->set_cross_section(std::vector<double>(all,xs_val_dummy), std::vector<double>(all,xs_err_dummy));
+    xs->set_xsec(0,xs_val);
+    xs->set_xsec_err(0,xs_err);
     evt.add_attribute("GenCrossSection", xs);
-
     return true;
 }
 
 bool ReaderAsciiHepMC2::parse_weight_names(const char *buf) {
     const char     *cursor  = buf;
     const char     *cursor2 = buf;
     int             w_count = 0;
@@ -706,20 +727,20 @@
 
     if ( !(cursor = strchr(cursor+1, ' ')) ) return false;
     pi->xf[1] = atof(cursor);
 
     //For compatibility with original HepMC2
     bool pdfids = true;
     if ( !(cursor = strchr(cursor+1, ' ')) ) pdfids = false;
-    if (pdfids) pi->pdf_id[0] = atoi(cursor);
-    else  pi->pdf_id[0] = 0;
+    if (pdfids) {pi->pdf_id[0] = atoi(cursor);}
+    else  {pi->pdf_id[0] = 0;}
 
     if (pdfids) if ( !(cursor = strchr(cursor+1, ' ')) )  pdfids = false;
-    if (pdfids) pi->pdf_id[1] = atoi(cursor);
-    else  pi->pdf_id[1] = 0;
+    if (pdfids) { pi->pdf_id[1] = atoi(cursor);}
+    else  {pi->pdf_id[1] = 0;}
 
     evt.add_attribute("GenPdfInfo", pi);
 
     return true;
 }
 bool ReaderAsciiHepMC2::failed() { return m_isstream ? (bool)m_stream->rdstate() :(bool)m_file.rdstate(); }
```

### Comparing `HepMC3-3.2.5/src/ReaderHEPEVT.cc` & `HepMC3-3.2.6/src/ReaderHEPEVT.cc`

 * *Files 10% similar despite different names*

```diff
@@ -1,25 +1,26 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file ReaderHEPEVT.cc
  *  @brief Implementation of \b class ReaderHEPEVT
  *
  */
+#include <array>
 #include <sstream>
 #include "HepMC3/ReaderHEPEVT.h"
 
 namespace HepMC3
 {
 
 ReaderHEPEVT::ReaderHEPEVT(const std::string &filename)
-    : m_file(filename), m_stream(0), m_isstream(false)
+    : m_file(filename), m_stream(nullptr), m_isstream(false)
 {
     if ( !m_file.is_open() ) {
         HEPMC3_ERROR("ReaderHEPEVT: could not open input file: " << filename)
     }
     else
     {
         set_run_info(std::make_shared<GenRunInfo>());
@@ -53,79 +54,76 @@
         m_hepevt_interface.allocate_internal_storage();
     }
 }
 
 
 bool ReaderHEPEVT::skip(const int n)
 {
-    const size_t       max_buffer_size = 512*512;
-    char               buf[max_buffer_size];
+    std::array<char, 262144> buf;
     int nn = n;
     while (!failed()) {
-        char peek;
-        if ( (!m_file.is_open()) && (!m_isstream) ) return false;
+        char peek(0);
+        if ( (!m_file.is_open()) && (!m_isstream) ) { return false; }
         m_isstream ? peek = m_stream->peek() : peek = m_file.peek();
         if ( peek == 'E' ) nn--;
-        if ( nn < 0 ) return true;
-        m_isstream ? m_stream->getline(buf, max_buffer_size) : m_file.getline(buf, max_buffer_size);
+        if ( nn < 0 ) { return true; }
+        m_isstream ? m_stream->getline(buf.data(), buf.size()) : m_file.getline(buf.data(), buf.size());
     }
     return true;
 }
 
 
 
 bool ReaderHEPEVT::read_hepevt_event_header()
 {
-    const size_t       max_e_buffer_size = 512;
-    char buf_e[max_e_buffer_size];
+    std::array<char, 512> buf_e;
     bool eventline = false;
-    int m_i = 0, m_p = 0;
+    int m_i = 0;
+    int m_p = 0;
     while (!eventline)
     {
-        m_isstream ? m_stream->getline(buf_e, max_e_buffer_size) : m_file.getline(buf_e, max_e_buffer_size);
-        if ( strlen(buf_e) == 0 ) return false;
-        std::stringstream st_e(buf_e);
+        m_isstream ? m_stream->getline(buf_e.data(), buf_e.size()) : m_file.getline(buf_e.data(), buf_e.size());
+        if ( strlen(buf_e.data()) == 0 ) return false;
+        std::stringstream st_e(buf_e.data());
         char attr = ' ';
         eventline = false;
         while (!eventline)
         {
             if (!(st_e >> attr)) break;
-            if (attr == ' ') continue;
-            else eventline = false;
+            if (attr == ' ') { continue; }
+            eventline = false;
             if (attr == 'E')
             {
                 eventline = static_cast<bool>(st_e >> m_i >> m_p);
             }
         }
     }
     m_hepevt_interface.set_event_number(m_i);
     m_hepevt_interface.set_number_entries(m_p);
     return eventline;
 }
 
 
 bool ReaderHEPEVT::read_hepevt_particle(int i)
 {
-    const size_t       max_p_buffer_size = 512;
-    const size_t       max_v_buffer_size = 512;
-    char buf_p[max_p_buffer_size];
-    char buf_v[max_v_buffer_size];
-    int   intcodes[6];
-    double fltcodes1[5];
-    double fltcodes2[4];
-    m_isstream ? m_stream->getline(buf_p, max_p_buffer_size) : m_file.getline(buf_p, max_p_buffer_size);
-    if ( strlen(buf_p) == 0 ) return false;
-    if (m_options.find("vertices_positions_are_absent") == m_options.end())
-    {
-        m_isstream ? m_stream->getline(buf_v, max_v_buffer_size) : m_file.getline(buf_v, max_v_buffer_size);
-        if ( strlen(buf_v) == 0 ) return false;
-    }
-    std::stringstream st_p(buf_p);
-    std::stringstream st_v(buf_v);
-    if (m_options.find("vertices_positions_are_absent") == m_options.end())
+    std::array<char, 512> buf_p;
+    std::array<char, 512> buf_v;
+    std::array<int, 6>   intcodes;
+    std::array<double, 5> fltcodes1;
+    std::array<double, 5> fltcodes2;
+    m_isstream ? m_stream->getline(buf_p.data(),buf_p.size()) : m_file.getline(buf_p.data(),buf_p.size());
+    if ( strlen(buf_p.data()) == 0 ) return false;
+    if (m_options.count("vertices_positions_are_absent") == 0)
+    {
+        m_isstream ? m_stream->getline(buf_v.data(),buf_v.size()) : m_file.getline(buf_v.data(),buf_v.size());
+        if ( strlen(buf_v.data()) == 0 ) return false;
+    }
+    std::stringstream st_p(buf_p.data());
+    std::stringstream st_v(buf_v.data());
+    if (m_options.count("vertices_positions_are_absent") == 0)
     {
         if (!static_cast<bool>(st_p >> intcodes[0] >> intcodes[1] >> intcodes[2] >> intcodes[3] >> intcodes[4] >> intcodes[5] >> fltcodes1[0] >> fltcodes1[1] >> fltcodes1[2] >> fltcodes1[3] >> fltcodes1[4])) { HEPMC3_ERROR("ReaderHEPEVT: HEPMC3_ERROR reading particle momenta");     return false;}
         if (!static_cast<bool>(st_v >> fltcodes2[0] >> fltcodes2[1] >> fltcodes2[2] >> fltcodes2[3])) { HEPMC3_ERROR("ReaderHEPEVT: HEPMC3_ERROR reading particle vertex");  return false;}
     }
     else
     {
         if (!static_cast<bool>(st_p>> intcodes[0]>> intcodes[1] >> intcodes[4] >> intcodes[5] >> fltcodes1[0] >> fltcodes1[1] >> fltcodes1[2] >> fltcodes1[4])) {HEPMC3_ERROR("ReaderHEPEVT: HEPMC3_ERROR reading particle momenta");     return false;}
@@ -148,25 +146,24 @@
 }
 
 bool ReaderHEPEVT::read_event(GenEvent& evt)
 {
     evt.clear();
     m_hepevt_interface.zero_everything();
     bool fileok = read_hepevt_event_header();
-    for (int i = 1; (i <= m_hepevt_interface.number_entries()) && fileok; i++)
+    for (int i = 1; (i <= m_hepevt_interface.number_entries()) && fileok; i++) {
         fileok = read_hepevt_particle(i);
+    }
     bool result = false;
     if (fileok)
     {
         result = m_hepevt_interface.HEPEVT_to_GenEvent(&evt);
         std::shared_ptr<GenRunInfo> g = std::make_shared<GenRunInfo>();
-        std::vector<std::string> weightnames;
-        weightnames.push_back("0");
-        std::vector<double> wts;
-        wts.push_back(1.0);
+        std::vector<std::string> weightnames(1,"0");
+        std::vector<double> wts(1,1.0);
         g->set_weight_names(weightnames);
         evt.set_run_info(g);
         evt.weights() = wts;
     }
     else
     {
         m_isstream ? m_stream->clear(std::ios::badbit) : m_file.clear(std::ios::badbit);
```

### Comparing `HepMC3-3.2.5/src/ReaderPlugin.cc` & `HepMC3-3.2.6/src/ReaderPlugin.cc`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file ReaderPlugin.cc
 /// @brief Implementation of \b class ReaderPlugin
 ///
 #ifdef WIN32
 #define WIN32_LEAN_AND_MEAN
@@ -14,60 +14,56 @@
 #undef UNICODE
 #include <intrin.h>
 #include <windows.h>
 #endif
 #if defined(__linux__) || defined(__darwin__) || defined(__APPLE__) || defined(BSD) || defined(__sun)
 #include <dlfcn.h>
 #endif
-#include <cstring>
 #include <sstream>
-#include "HepMC3/ReaderPlugin.h"
+#include <cstring>
 #include "HepMC3/GenEvent.h"
+#include "HepMC3/ReaderPlugin.h"
 
 namespace HepMC3 {
 
 ReaderPlugin::ReaderPlugin(std::istream & stream, const std::string &libname, const std::string &newreader) {
 #ifdef WIN32
-    dll_handle = nullptr;
     dll_handle = LoadLibrary(libname.c_str());
     if (!dll_handle) { printf("Error  while loading library %s. Error code %i\n", libname.c_str(), GetLastError()); m_reader = nullptr; return;  }
     typedef Reader* (__stdcall *f_funci)(std::istream & stream);
     f_funci newReader = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newreader.c_str());
     if (!newReader) { printf("Error  while loading function %s from  library %s. Error code %i\n", newreader.c_str(), libname.c_str(), GetLastError()); m_reader = nullptr; return;  }
     m_reader = (Reader*)(newReader(stream));
 #endif
 
 #if defined(__linux__) || defined(__darwin__) || defined(__APPLE__) || defined(BSD) || defined(__sun)
-    dll_handle = nullptr;
     dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);
     if (!dll_handle) { printf("Error  while loading library %s: %s\n", libname.c_str(), dlerror()); m_reader = nullptr; return;  }
-    Reader* (*newReader)(std::istream & stream);
-    newReader = (Reader* (*)(std::istream & stream))dlsym(dll_handle, newreader.c_str());
+    using f_funci = Reader *(*)(std::istream &);
+    auto newReader = (f_funci)dlsym(dll_handle, newreader.c_str());
     if (!newReader) { printf("Error  while loading function %s from  library %s: %s\n", newreader.c_str(), libname.c_str(), dlerror()); m_reader = nullptr; return;   }
     m_reader = (Reader*)(newReader(stream));
 #endif
 }
 /** @brief Constructor */
 ReaderPlugin::ReaderPlugin(const std::string& filename, const std::string &libname, const std::string &newreader) {
 #ifdef WIN32
-    dll_handle = nullptr;
     dll_handle = LoadLibrary(libname.c_str());
     if (!dll_handle) { printf("Error  while loading library %s. Error code %i\n", libname.c_str(), GetLastError()); m_reader = nullptr; return;  }
     typedef Reader* (__stdcall *f_funci)(const std::string&);
     f_funci newReader = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newreader.c_str());
     if (!newReader) { printf("Error  while loading function %s from  library %s. Error code %i\n", newreader.c_str(), libname.c_str(), GetLastError()); m_reader = nullptr; return;  }
     m_reader = (Reader*)(newReader(filename));
 #endif
 
 #if defined(__linux__) || defined(__darwin__) || defined(__APPLE__) || defined(BSD) || defined(__sun)
-    dll_handle = nullptr;
     dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);
     if (!dll_handle) { printf("Error  while loading library %s: %s\n", libname.c_str(), dlerror()); m_reader = nullptr; return;  }
-    Reader* (*newReader)(const std::string&);
-    newReader = (Reader* (*)(const std::string&))dlsym(dll_handle, newreader.c_str());
+    using f_funci = Reader *(*)(const std::string&);
+    auto newReader = (f_funci)dlsym(dll_handle, newreader.c_str());
     if (!newReader) { printf("Error  while loading function %s from  library %s: %s\n", newreader.c_str(), libname.c_str(), dlerror()); m_reader = nullptr; return;   }
     m_reader = (Reader*)(newReader(filename));
 #endif
 }
 ReaderPlugin::~ReaderPlugin() {
     if (m_reader) m_reader->close();
     if (m_reader) delete m_reader;
```

### Comparing `HepMC3-3.2.5/src/Setup.cc` & `HepMC3-3.2.6/src/Setup.cc`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file Setup.cc
  *  @brief Implementation of Setup class
  *
  */
 #include "HepMC3/Setup.h"
```

### Comparing `HepMC3-3.2.5/src/WriterAscii.cc` & `HepMC3-3.2.6/src/WriterAscii.cc`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file WriterAscii.cc
 /// @brief Implementation of \b class WriterAscii
 ///
-#include <cstring>
+
 #include <algorithm>//min max for VS2017
+#include <cstring>
 
-#include "HepMC3/WriterAscii.h"
 
-#include "HepMC3/Version.h"
 #include "HepMC3/GenEvent.h"
 #include "HepMC3/GenParticle.h"
 #include "HepMC3/GenVertex.h"
 #include "HepMC3/Units.h"
+#include "HepMC3/Version.h"
+#include "HepMC3/WriterAscii.h"
 
 namespace HepMC3 {
 
 
 WriterAscii::WriterAscii(const std::string &filename, std::shared_ptr<GenRunInfo> run)
     : m_file(filename),
       m_stream(&m_file),
       m_precision(16),
       m_buffer(nullptr),
       m_cursor(nullptr),
-      m_buffer_size(256*1024)
+      m_buffer_size(262144)
 {
     set_run_info(run);
     if ( !m_file.is_open() ) {
         HEPMC3_ERROR("WriterAscii: could not open output file: " << filename)
     } else {
         const std::string header = "HepMC::Version " + version() + "\nHepMC::Asciiv3-START_EVENT_LISTING\n";
         m_file.write(header.data(), header.length());
@@ -46,20 +47,19 @@
                                   + m_float_printf_specifier + " %i\n";
     m_vertex_short_printf_specifier = "V %i %i [%s]\n";
     m_vertex_long_printf_specifier = "V %i %i [%s] @"+ m_float_printf_specifier + m_float_printf_specifier + m_float_printf_specifier + m_float_printf_specifier + "\n";
 }
 
 
 WriterAscii::WriterAscii(std::ostream &stream, std::shared_ptr<GenRunInfo> run)
-    : m_file(),
-      m_stream(&stream),
+    : m_stream(&stream),
       m_precision(16),
       m_buffer(nullptr),
       m_cursor(nullptr),
-      m_buffer_size(256*1024)
+      m_buffer_size(262144)
 {
     set_run_info(run);
     const std::string header = "HepMC::Version " + version() + "\nHepMC::Asciiv3-START_EVENT_LISTING\n";
     m_stream->write(header.data(), header.length());
     if ( run_info() ) write_run_info();
     m_float_printf_specifier = " %." + std::to_string(m_precision) + "e";
     m_particle_printf_specifier = "P %i %i %i"
@@ -69,21 +69,20 @@
                                   + m_float_printf_specifier
                                   + m_float_printf_specifier + " %i\n";
     m_vertex_short_printf_specifier = "V %i %i [%s]\n";
     m_vertex_long_printf_specifier = "V %i %i [%s] @"+ m_float_printf_specifier + m_float_printf_specifier + m_float_printf_specifier + m_float_printf_specifier + "\n";
 }
 
 WriterAscii::WriterAscii(std::shared_ptr<std::ostream> s_stream, std::shared_ptr<GenRunInfo> run)
-    : m_file(),
-      m_shared_stream(s_stream),
+    : m_shared_stream(s_stream),
       m_stream(s_stream.get()),
       m_precision(16),
       m_buffer(nullptr),
       m_cursor(nullptr),
-      m_buffer_size(256*1024)
+      m_buffer_size(262144)
 {
     set_run_info(run);
     const std::string header = "HepMC::Version " + version() + "\nHepMC::Asciiv3-START_EVENT_LISTING\n";
     m_stream->write(header.data(), header.length());
     if ( run_info() ) write_run_info();
     m_float_printf_specifier = " %." + std::to_string(m_precision) + "e";
     m_particle_printf_specifier = "P %i %i %i"
@@ -150,28 +149,28 @@
     flush();
 
     // Write units
     m_cursor += sprintf(m_cursor, "U %s %s\n", Units::name(evt.momentum_unit()).c_str(), Units::name(evt.length_unit()).c_str());
     flush();
 
     // Write weight values if present
-    if ( evt.weights().size() ) {
+    if ( !evt.weights().empty() ) {
         m_cursor += sprintf(m_cursor, "W");
-        for (auto w: evt.weights())
+        for (const auto& w: evt.weights())
         {
             m_cursor += sprintf(m_cursor, " %.*e", std::min(3*m_precision, 22), w);
             flush();
         }
         m_cursor += sprintf(m_cursor, "\n");
         flush();
     }
 
     // Write attributes
-    for ( auto vt1: evt.attributes() ) {
-        for ( auto vt2: vt1.second ) {
+    for ( const auto& vt1: evt.attributes() ) {
+        for ( const auto& vt2: vt1.second ) {
             std::string st;
             bool status = vt2.second->to_string(st);
 
             if ( !status ) {
                 HEPMC3_WARNING("WriterAscii::write_event: problem serializing attribute: " << vt1.first)
             }
             else {
@@ -185,27 +184,29 @@
             }
         }
     }
 
 
     // Print particles
     std::map<int, bool> alreadywritten;
-    for (ConstGenParticlePtr p: evt.particles()) {
+    for (const ConstGenParticlePtr& p: evt.particles()) {
         // Check to see if we need to write a vertex first
         ConstGenVertexPtr v = p->production_vertex();
         int parent_object = 0;
 
         if (v) {
             // Check if we need this vertex at all
             // Yes, use vertex as parent object
-            if ( v->particles_in().size() > 1 || !v->data().is_zero() ) parent_object = v->id();
+            if ( v->particles_in().size() > 1 || !v->data().is_zero() ) { parent_object = v->id(); }
             // No, use particle as parent object
             // Add check for attributes of this vertex
-            else if ( v->particles_in().size() == 1 )                   parent_object = v->particles_in().front()->id();
-            else if ( v->particles_in().size() == 0 ) HEPMC3_DEBUG(30, "WriterAscii::write_event - found a vertex without incoming particles: " << v->id());
+            else {
+                if ( v->particles_in().size() == 1 )                  { parent_object = v->particles_in().front()->id();}
+                else {if ( v->particles_in().empty() ) {HEPMC3_DEBUG(30, "WriterAscii::write_event - found a vertex without incoming particles: " << v->id());}}
+            }
             // Usage of map instead of simple counter helps to deal with events with random ids of vertices.
             if (alreadywritten.count(v->id()) == 0 && parent_object < 0)
             { write_vertex(v); alreadywritten[v->id()] = true; }
         }
 
         write_particle(p, parent_object);
     }
@@ -250,24 +251,24 @@
         default:
             ret += *it;
         }
     }
     return ret;
 }
 
-void WriterAscii::write_vertex(ConstGenVertexPtr v) {
+void WriterAscii::write_vertex(const ConstGenVertexPtr& v) {
     flush();
     std::string vlist;
     std::vector<int> pids;
     pids.reserve(v->particles_in().size());
-    for (ConstGenParticlePtr p: v->particles_in()) pids.push_back(p->id());
+    for (const ConstGenParticlePtr& p: v->particles_in()) pids.emplace_back(p->id());
     //We order pids to be able to compare ascii files
     std::sort(pids.begin(), pids.end());
-    for (auto p: pids) vlist.append( std::to_string(p).append(",") );
-    if ( pids.size() ) vlist.pop_back();
+    for (const auto& p: pids) vlist.append( std::to_string(p).append(",") );
+    if ( !pids.empty() ) vlist.pop_back();
     const FourVector &pos = v->position();
     if ( !pos.is_zero() ) {
         m_cursor += sprintf(m_cursor, m_vertex_long_printf_specifier.c_str(),  v->id(), v->status(), vlist.c_str(), pos.x(), pos.y(), pos.z(), pos.t() );
     } else {
         m_cursor += sprintf(m_cursor, m_vertex_short_printf_specifier.c_str(), v->id(), v->status(), vlist.c_str());
     }
     flush();
@@ -299,32 +300,31 @@
     // If no run info object set, create a dummy one.
     if ( !run_info() ) set_run_info(std::make_shared<GenRunInfo>());
 
     const std::vector<std::string> names = run_info()->weight_names();
 
     if ( !names.empty() ) {
         std::string out = names[0];
-        for ( int i = 1, N = names.size(); i < N; ++i )
+        for ( int i = 1, N = names.size(); i < N; ++i ) {
             out += "\n" + names[i];
+        }
         m_cursor += sprintf(m_cursor, "W ");
         flush();
         write_string(escape(out));
         m_cursor += sprintf(m_cursor, "\n");
     }
 
-    for (int i = 0, N = run_info()->tools().size(); i < N; ++i) {
-        std::string out = "T " + run_info()->tools()[i].name + "\n"
-                          + run_info()->tools()[i].version + "\n"
-                          + run_info()->tools()[i].description;
+    for (const auto& tool: run_info()->tools()) {
+        std::string out = "T " + tool.name + "\n" + tool.version + "\n" + tool.description;
         write_string(escape(out));
         m_cursor += sprintf(m_cursor, "\n");
     }
 
 
-    for ( auto att: run_info()->attributes() ) {
+    for ( const auto& att: run_info()->attributes() ) {
         std::string st;
         if ( !att.second->to_string(st) ) {
             HEPMC3_WARNING("WriterAscii::write_run_info: problem serializing attribute: " << att.first)
         }
         else {
             m_cursor += sprintf(m_cursor, "A ");
             write_string(att.first);
@@ -333,15 +333,15 @@
             write_string(escape(st));
             m_cursor += sprintf(m_cursor, "\n");
             flush();
         }
     }
 }
 
-void WriterAscii::write_particle(ConstGenParticlePtr p, int second_field) {
+void WriterAscii::write_particle(const ConstGenParticlePtr& p, int second_field) {
     flush();
     m_cursor += sprintf(m_cursor, m_particle_printf_specifier.c_str(), p->id(), second_field, p->pid(), p->momentum().px(), p->momentum().py(), p->momentum().pz(), p->momentum().e(), p->generated_mass(), p->status());
     flush();
 }
 
 
 inline void WriterAscii::write_string(const std::string &str) {
@@ -356,15 +356,15 @@
         forced_flush();
         m_stream->write(str.data(), str.length());
     }
 }
 
 
 void WriterAscii::close() {
-    std::ofstream* ofs = dynamic_cast<std::ofstream*>(m_stream);
+    auto* ofs = dynamic_cast<std::ofstream*>(m_stream);
     if (ofs && !ofs->is_open()) return;
     forced_flush();
     const std::string footer("HepMC::Asciiv3-END_EVENT_LISTING\n\n");
     if (m_stream) m_stream->write(footer.data(),footer.length());
     if (ofs) ofs->close();
 }
 bool WriterAscii::failed() { return (bool)m_file.rdstate(); }
```

### Comparing `HepMC3-3.2.5/src/WriterAsciiHepMC2.cc` & `HepMC3-3.2.6/src/WriterAsciiHepMC2.cc`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file WriterAsciiHepMC2.cc
 /// @brief Implementation of \b class WriterAsciiHepMC2
 ///
 #include <cstring>
 
-#include "HepMC3/WriterAsciiHepMC2.h"
 
-#include "HepMC3/Version.h"
 #include "HepMC3/GenEvent.h"
 #include "HepMC3/GenParticle.h"
 #include "HepMC3/GenVertex.h"
 #include "HepMC3/Units.h"
+#include "HepMC3/Version.h"
+#include "HepMC3/WriterAsciiHepMC2.h"
 
 namespace HepMC3
 {
 
 
 WriterAsciiHepMC2::WriterAsciiHepMC2(const std::string &filename, std::shared_ptr<GenRunInfo> run)
     : m_file(filename),
       m_stream(&m_file),
       m_precision(16),
       m_buffer(nullptr),
       m_cursor(nullptr),
-      m_buffer_size(256*1024),
+      m_buffer_size(262144),
       m_particle_counter(0)
 {
     HEPMC3_WARNING("WriterAsciiHepMC2::WriterAsciiHepMC2: HepMC2 IO_GenEvent format is outdated. Please use HepMC3 Asciiv3 format instead.")
     set_run_info(run);
     if ( !run_info() ) set_run_info(std::make_shared<GenRunInfo>());
     if ( !m_file.is_open() )
     {
@@ -42,38 +42,36 @@
         const std::string header = "HepMC::Version " + version() + "\nHepMC::IO_GenEvent-START_EVENT_LISTING\n";
         m_file.write(header.data(), header.length());
     }
     m_float_printf_specifier = " %." + std::to_string(m_precision) + "e";
 }
 
 WriterAsciiHepMC2::WriterAsciiHepMC2(std::ostream &stream, std::shared_ptr<GenRunInfo> run)
-    : m_file(),
-      m_stream(&stream),
+    : m_stream(&stream),
       m_precision(16),
       m_buffer(nullptr),
       m_cursor(nullptr),
-      m_buffer_size(256*1024),
+      m_buffer_size(262144),
       m_particle_counter(0)
 {
     HEPMC3_WARNING("WriterAsciiHepMC2::WriterAsciiHepMC2: HepMC2 IO_GenEvent format is outdated. Please use HepMC3 Asciiv3 format instead.")
     set_run_info(run);
     if ( !run_info() ) set_run_info(std::make_shared<GenRunInfo>());
     const std::string header = "HepMC::Version " + version() + "\nHepMC::IO_GenEvent-START_EVENT_LISTING\n";
     m_stream->write(header.data(), header.length());
     m_float_printf_specifier = " %." + std::to_string(m_precision) + "e";
 }
 
 WriterAsciiHepMC2::WriterAsciiHepMC2(std::shared_ptr<std::ostream> s_stream, std::shared_ptr<GenRunInfo> run)
-    : m_file(),
-      m_shared_stream(s_stream),
+    : m_shared_stream(s_stream),
       m_stream(s_stream.get()),
       m_precision(16),
       m_buffer(nullptr),
       m_cursor(nullptr),
-      m_buffer_size(256*1024),
+      m_buffer_size(262144),
       m_particle_counter(0)
 {
     HEPMC3_WARNING("WriterAsciiHepMC2::WriterAsciiHepMC2: HepMC2 IO_GenEvent format is outdated. Please use HepMC3 Asciiv3 format instead.")
     set_run_info(run);
     if ( !run_info() ) set_run_info(std::make_shared<GenRunInfo>());
     const std::string header = "HepMC::Version " + version() + "\nHepMC::IO_GenEvent-START_EVENT_LISTING\n";
     m_stream->write(header.data(), header.length());
@@ -123,35 +121,35 @@
         m_random_states = random_states_a->value();
     } else {
         m_random_states.reserve(100);
         for (int i = 0; i < 100; i++)
         {
             std::shared_ptr<LongAttribute> rs = evt.attribute<LongAttribute>("random_states"+std::to_string((long long unsigned int)i));
             if (!rs) break;
-            m_random_states.push_back(rs->value());
+            m_random_states.emplace_back(rs->value());
         }
     }
     // Write event info
     //Find beam particles
     std::vector<int> beams;
     beams.reserve(2);
     int idbeam = 0;
-    for (ConstGenVertexPtr v: evt.vertices())
+    for (const ConstGenVertexPtr& v: evt.vertices())
     {
-        for (ConstGenParticlePtr p: v->particles_in())
+        for (const ConstGenParticlePtr& p: v->particles_in())
         {
-            if (!p->production_vertex())                { if (p->status() == 4) beams.push_back(idbeam); idbeam++; }
-            else if (p->production_vertex()->id() == 0) { if (p->status() == 4) beams.push_back(idbeam); idbeam++; }
+            if (!p->production_vertex())                { if (p->status() == 4) beams.emplace_back(idbeam); idbeam++; }
+            else {if (p->production_vertex()->id() == 0) { if (p->status() == 4) beams.emplace_back(idbeam); idbeam++; }}
         }
-        for (ConstGenParticlePtr p: v->particles_out()) { if (p->status() == 4) beams.push_back(idbeam); idbeam++; }
+        for (const ConstGenParticlePtr& p: v->particles_out()) { if (p->status() == 4) beams.push_back(idbeam); idbeam++; }
     }
     //
     int idbeam1 = 10000;
     int idbeam2 = 10000;
-    if (beams.size() > 0) idbeam1 += beams[0] + 1;
+    if (!beams.empty()) idbeam1 += beams[0] + 1;
     if (beams.size() > 1) idbeam2 += beams[1] + 1;
     m_cursor += sprintf(m_cursor, "E %d %d %e %e %e %d %d %zu %i %i",
                         evt.event_number(),
                         mpi,
                         event_scale,
                         alphaQCD,
                         alphaQED,
@@ -166,30 +164,31 @@
     for (size_t q = 0; q < m_random_states.size(); q++)
     {
         m_cursor += sprintf(m_cursor, " %i", (int)q);
         flush();
     }
     flush();
     m_cursor += sprintf(m_cursor, " %zu", evt.weights().size());
-    if ( evt.weights().size() )
+    if ( !evt.weights().empty() )
     {
-        for (double w: evt.weights()) {
+        for (const double& w: evt.weights()) {
             m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), w);
             flush();
         }
         m_cursor += sprintf(m_cursor, "\n");
         flush();
         m_cursor += sprintf(m_cursor, "N %zu", evt.weights().size());
         const std::vector<std::string> names = run_info()->weight_names();
         for (size_t q = 0; q < evt.weights().size(); q++)
         {
-            if (q < names.size())
+            if (q < names.size()) {
                 write_string(" \""+names[q]+"\"");
-            else
+            } else {
                 write_string(" \""+std::to_string(q)+"\"");
+            }
             flush();
         }
     }
     m_cursor += sprintf(m_cursor, "\n");
     flush();
     // Write units
     m_cursor += sprintf(m_cursor, "U %s %s\n", Units::name(evt.momentum_unit()).c_str(), Units::name(evt.length_unit()).c_str());
@@ -234,29 +233,30 @@
             m_cursor += sprintf(m_cursor, "\n");
             flush();
         }
     }
 
 
     m_particle_counter = 0;
-    for (ConstGenVertexPtr v: evt.vertices() )
+    for (const ConstGenVertexPtr& v: evt.vertices() )
     {
         int production_vertex = 0;
         production_vertex = v->id();
         write_vertex(v);
-        for (ConstGenParticlePtr p: v->particles_in())
+        for (const ConstGenParticlePtr& p: v->particles_in())
         {
-            if (!p->production_vertex()) write_particle( p, production_vertex );
+            if (!p->production_vertex()) { write_particle( p, production_vertex ); }
             else
             {
                 if (p->production_vertex()->id() == 0) write_particle( p, production_vertex );
             }
         }
-        for (ConstGenParticlePtr p: v->particles_out())
+        for (const ConstGenParticlePtr& p: v->particles_out()) {
             write_particle(p, production_vertex);
+        }
     }
 
     // Flush rest of the buffer to file
     forced_flush();
 }
 
 
@@ -300,35 +300,35 @@
         default:
             ret += *it;
         }
     }
     return ret;
 }
 
-void WriterAsciiHepMC2::write_vertex(ConstGenVertexPtr v)
+void WriterAsciiHepMC2::write_vertex(const ConstGenVertexPtr& v)
 {
     std::vector<double> weights;
     std::shared_ptr<VectorDoubleAttribute> weights_a = v->attribute<VectorDoubleAttribute>("weights");
     if (weights_a) {
         weights = weights_a->value();
     } else {
         weights.reserve(100);
         for (int i = 0; i < 100; i++)
         {
             std::shared_ptr<DoubleAttribute> rs = v->attribute<DoubleAttribute>("weight"+std::to_string((long long unsigned int)i));
             if (!rs) break;
-            weights.push_back(rs->value());
+            weights.emplace_back(rs->value());
         }
     }
     flush();
     m_cursor += sprintf(m_cursor, "V %i %i", v->id(), v->status());
     int orph = 0;
-    for (ConstGenParticlePtr p: v->particles_in())
+    for (const ConstGenParticlePtr& p: v->particles_in())
     {
-        if (!p->production_vertex()) orph++;
+        if (!p->production_vertex()) { orph++;}
         else
         {
             if (p->production_vertex()->id() == 0) orph++;
         }
     }
     const FourVector &pos = v->position();
     if (pos.is_zero())
@@ -369,38 +369,38 @@
     m_stream->write(m_buffer, length);
     m_cursor = m_buffer;
 }
 
 
 void WriterAsciiHepMC2::write_run_info() {}
 
-void WriterAsciiHepMC2::write_particle(ConstGenParticlePtr p, int /*second_field*/)
+void WriterAsciiHepMC2::write_particle(const ConstGenParticlePtr& p, int /*second_field*/)
 {
     flush();
     m_cursor += sprintf(m_cursor, "P %i", int(10001+m_particle_counter));
     m_particle_counter++;
     m_cursor += sprintf(m_cursor, " %i", p->pid() );
     m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), p->momentum().px() );
     m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), p->momentum().py());
     m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), p->momentum().pz() );
     m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), p->momentum().e() );
     m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), p->generated_mass() );
     m_cursor += sprintf(m_cursor, " %i", p->status() );
     flush();
     int ev = 0;
-    if (p->end_vertex())
+    if (p->end_vertex()) {
         if (p->end_vertex()->id() != 0)
-            ev = p->end_vertex()->id();
-
+        { ev = p->end_vertex()->id(); }
+    }
     std::shared_ptr<DoubleAttribute> A_theta = p->attribute<DoubleAttribute>("theta");
     std:: shared_ptr<DoubleAttribute> A_phi = p->attribute<DoubleAttribute>("phi");
-    if (A_theta) m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), A_theta->value());
-    else m_cursor += sprintf(m_cursor, " 0");
-    if (A_phi) m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), A_phi->value());
-    else m_cursor += sprintf(m_cursor, " 0");
+    if (A_theta) { m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), A_theta->value()); }
+    else { m_cursor += sprintf(m_cursor, " 0");}
+    if (A_phi) { m_cursor += sprintf(m_cursor, m_float_printf_specifier.c_str(), A_phi->value()); }
+    else { m_cursor += sprintf(m_cursor, " 0");}
     m_cursor += sprintf(m_cursor, " %i", ev);
     flush();
     std::shared_ptr<VectorIntAttribute> A_flows = p->attribute<VectorIntAttribute>("flows");
     if (A_flows)
     {
         std::vector<int> flowsv = A_flows->value();
         std::string flowss = " " + std::to_string(flowsv.size());
@@ -442,15 +442,15 @@
         m_stream->write(str.data(), str.length());
     }
 }
 
 
 void WriterAsciiHepMC2::close()
 {
-    std::ofstream* ofs = dynamic_cast<std::ofstream*>(m_stream);
+    auto* ofs = dynamic_cast<std::ofstream*>(m_stream);
     if (ofs && !ofs->is_open()) return;
     forced_flush();
     const std::string footer("HepMC::IO_GenEvent-END_EVENT_LISTING\n\n");
     if (m_stream) m_stream->write(footer.data(),footer.length());
     if (ofs) ofs->close();
 }
 bool WriterAsciiHepMC2::failed() { return (bool)m_file.rdstate(); }
```

### Comparing `HepMC3-3.2.5/src/WriterHEPEVT.cc` & `HepMC3-3.2.6/src/WriterHEPEVT.cc`

 * *Files 15% similar despite different names*

```diff
@@ -1,95 +1,97 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 /**
  *  @file WriterHEPEVT.cc
  *  @brief Implementation of \b class WriterHEPEVT
  *
  */
-#include <sstream>
+#include <array>
 #include <cstdio>  // sprintf
-#include "HepMC3/WriterHEPEVT.h"
+#include <sstream>
+
 #include "HepMC3/Print.h"
+#include "HepMC3/WriterHEPEVT.h"
 namespace HepMC3
 {
 
 
 WriterHEPEVT::WriterHEPEVT(const std::string &filename,
-                           std::shared_ptr<GenRunInfo> run): m_file(filename), m_stream(&m_file), m_events_count(0)
+                           std::shared_ptr<GenRunInfo> /*run*/): m_file(filename), m_stream(&m_file)
 {
     HEPMC3_WARNING("WriterHEPEVT::WriterHEPEVT: HEPEVT format is outdated. Please use HepMC3 format instead.")
     m_hepevt_interface.allocate_internal_storage();
 }
 
 WriterHEPEVT::WriterHEPEVT(std::ostream& stream,
-                           std::shared_ptr<GenRunInfo> run): m_file(), m_stream(&stream), m_events_count(0)
+                           std::shared_ptr<GenRunInfo> /*run*/): m_stream(&stream)
 {
     HEPMC3_WARNING("WriterHEPEVT::WriterHEPEVT: HEPEVT format is outdated. Please use HepMC3 format instead.")
     m_hepevt_interface.allocate_internal_storage();
 }
 
 WriterHEPEVT::WriterHEPEVT(std::shared_ptr<std::ostream> s_stream,
-                           std::shared_ptr<GenRunInfo> run): m_file(), m_shared_stream(s_stream), m_stream(s_stream.get()), m_events_count(0)
+                           std::shared_ptr<GenRunInfo> /*run*/): m_shared_stream(s_stream), m_stream(s_stream.get())
 {
     HEPMC3_WARNING("WriterHEPEVT::WriterHEPEVT: HEPEVT format is outdated. Please use HepMC3 format instead.")
     m_hepevt_interface.allocate_internal_storage();
 }
 
 void WriterHEPEVT::write_hepevt_particle(int index, bool iflong)
 {
-    char buf[512];//Note: the format is fixed, so no reason for complicatied tratment
-    char* cursor = &(buf[0]);
+    std::array<char, 512> buf;//Note: the format is fixed, so no reason for complicatied tratment
+    char* cursor = buf.data();
     cursor += sprintf(cursor, "% 8i% 8i", m_hepevt_interface.status(index), m_hepevt_interface.id(index));
     if (iflong)
     {
         cursor += sprintf(cursor, "% 8i% 8i", m_hepevt_interface.first_parent(index), m_hepevt_interface.last_parent(index));
         cursor += sprintf(cursor, "% 8i% 8i", m_hepevt_interface.first_child(index), m_hepevt_interface.last_child(index));
         cursor += sprintf(cursor, "% 19.8E% 19.8E% 19.8E% 19.8E% 19.8E\n", m_hepevt_interface.px(index), m_hepevt_interface.py(index), m_hepevt_interface.pz(index), m_hepevt_interface.e(index), m_hepevt_interface.m(index));
         cursor += sprintf(cursor, "%-48s% 19.8E% 19.8E% 19.8E% 19.8E\n", " ", m_hepevt_interface.x(index), m_hepevt_interface.y(index), m_hepevt_interface.z(index), m_hepevt_interface.t(index));
     }
     else
     {
         cursor += sprintf(cursor, "% 8i% 8i", m_hepevt_interface.first_child(index), m_hepevt_interface.last_child(index));
         cursor += sprintf(cursor, "% 19.8E% 19.8E% 19.8E% 19.8E\n", m_hepevt_interface.px(index), m_hepevt_interface.py(index), m_hepevt_interface.pz(index), m_hepevt_interface.m(index));
     }
-    unsigned long length = cursor - &(buf[0]);
-    m_stream->write(buf, length);
+    unsigned long length = cursor - buf.data();
+    m_stream->write(buf.data(), length);
 }
 
 void WriterHEPEVT::write_hepevt_event_header()
 {
-    char buf[512];//Note: the format is fixed, so no reason for complicatied tratment
-    char* cursor = buf;
+    std::array<char, 512> buf;//Note: the format is fixed, so no reason for complicatied tratment
+    char* cursor = buf.data();
     cursor += sprintf(cursor, "E% 8i %8i\n", m_hepevt_interface.event_number(), m_hepevt_interface.number_entries());
-    unsigned long length = cursor - &(buf[0]);
-    m_stream->write(buf, length);
+    unsigned long length = cursor - buf.data();
+    m_stream->write(buf.data(), length);
 }
 
 void WriterHEPEVT::write_event(const GenEvent &evt)
 {
     m_hepevt_interface.GenEvent_to_HEPEVT(&evt);
     m_hepevt_interface.fix_daughters();
     write_hepevt_event_header();
     for ( int i = 1; i <= m_hepevt_interface.number_entries(); ++i )  write_hepevt_particle(i, get_vertices_positions_present());
     m_events_count++;
 }
 
 void WriterHEPEVT::close()
 {
-    std::ofstream* ofs = dynamic_cast<std::ofstream*>(m_stream);
+    auto* ofs = dynamic_cast<std::ofstream*>(m_stream);
     if (ofs && !ofs->is_open()) return;
     if (ofs) ofs->close();
 }
 
 bool WriterHEPEVT::failed()
 {
     return (bool)m_file.rdstate();
 }
 
 void WriterHEPEVT::set_vertices_positions_present(bool iflong) { if (iflong) m_options["vertices_positions_are_absent"] = ""; else m_options.erase("vertices_positions_are_absent"); }
 
-bool WriterHEPEVT::get_vertices_positions_present() const { return  (m_options.find("vertices_positions_are_absent") == m_options.end()); }
+bool WriterHEPEVT::get_vertices_positions_present() const { return  (m_options.count("vertices_positions_are_absent") == 0); }
 
 } // namespace HepMC3
```

### Comparing `HepMC3-3.2.5/src/WriterPlugin.cc` & `HepMC3-3.2.6/src/WriterPlugin.cc`

 * *Files 8% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // -*- C++ -*-
 //
 // This file is part of HepMC
-// Copyright (C) 2014-2021 The HepMC collaboration (see AUTHORS for details)
+// Copyright (C) 2014-2023 The HepMC collaboration (see AUTHORS for details)
 //
 ///
 /// @file WriterPlugin.cc
 /// @brief Implementation of \b class WriterPlugin
 ///
 #ifdef WIN32
 #define WIN32_LEAN_AND_MEAN
@@ -14,61 +14,58 @@
 #undef UNICODE
 #include <intrin.h>
 #include <windows.h>
 #endif
 #if defined(__linux__) || defined(__darwin__) || defined(__APPLE__) || defined(BSD) || defined(__sun)
 #include <dlfcn.h>
 #endif
-#include <cstring>
 #include <sstream>
-#include "HepMC3/WriterPlugin.h"
+#include <cstring>
 #include "HepMC3/GenEvent.h"
+#include "HepMC3/WriterPlugin.h"
+
 
 
 namespace HepMC3 {
 
 WriterPlugin::WriterPlugin(std::ostream & stream, const std::string &libname, const std::string &newwriter, std::shared_ptr<GenRunInfo> run) {
 #ifdef WIN32
-    dll_handle = nullptr;
     dll_handle = LoadLibrary(libname.c_str());
     if (!dll_handle) { printf("Error  while loading library %s. Error code %i\n", libname.c_str(), GetLastError()); m_writer = nullptr; return;  }
-    typedef Writer* (__stdcall *f_funci)(std::ostream & stream, shared_ptr<GenRunInfo>);
+    typedef Writer* (__stdcall *f_funci)(std::ostream & stream, std::shared_ptr<GenRunInfo>);
     f_funci newWriter = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newwriter.c_str());
     if (!newWriter) { printf("Error  while loading function %s from  library %s. Error code %i\n", newwriter.c_str(), libname.c_str(), GetLastError()); m_writer = nullptr; return;  }
     m_writer = (Writer*)(newWriter(stream, run));
 #endif
 
 #if defined(__linux__) || defined(__darwin__) || defined(__APPLE__) || defined(BSD) || defined(__sun)
-    dll_handle = nullptr;
     dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);
     if (!dll_handle) { printf("Error  while loading library %s: %s\n", libname.c_str(), dlerror()); m_writer=nullptr; return;  }
-    Writer* (*newWriter)(std::ostream & stream, std::shared_ptr<GenRunInfo>);
-    newWriter = (Writer* (*)(std::ostream & stream, std::shared_ptr<GenRunInfo>))dlsym(dll_handle, newwriter.c_str());
+    using f_funci =  Writer* (*)(std::ostream & stream, std::shared_ptr<GenRunInfo>);
+    auto newWriter = (f_funci)dlsym(dll_handle, newwriter.c_str());
     if (!newWriter) { printf("Error  while loading function %s from  library %s: %s\n", newwriter.c_str(), libname.c_str(), dlerror()); m_writer = nullptr; return;   }
     m_writer = (Writer*)(newWriter(stream, run));
 #endif
 }
 
 WriterPlugin::WriterPlugin(const std::string& filename, const std::string &libname, const std::string &newwriter, std::shared_ptr<GenRunInfo> run) {
 #ifdef WIN32
-    dll_handle = nullptr;
     dll_handle = LoadLibrary(libname.c_str());
     if (!dll_handle) { printf("Error  while loading library %s. Error code %i\n", libname.c_str(), GetLastError()); m_writer = nullptr; return;  }
-    typedef Writer* (__stdcall *f_funci)(const std::string&, shared_ptr<GenRunInfo>);
+    typedef Writer* (__stdcall *f_funci)(const std::string&, std::shared_ptr<GenRunInfo>);
     f_funci newWriter = (f_funci)GetProcAddress((HINSTANCE)(dll_handle), newwriter.c_str());
     if (!newWriter) { printf("Error  while loading function %s from  library %s. Error code %i\n", newwriter.c_str(), libname.c_str(), GetLastError()); m_writer = nullptr; return;  }
     m_writer = (Writer*)(newWriter(filename, run));
 #endif
 
 #if defined(__linux__) || defined(__darwin__) || defined(__APPLE__) || defined(BSD) || defined(__sun)
-    dll_handle = nullptr;
     dll_handle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);
     if (!dll_handle) { printf("Error  while loading library %s: %s\n", libname.c_str(), dlerror()); m_writer = nullptr; return;  }
-    Writer* (*newWriter)(const std::string&, std::shared_ptr<GenRunInfo>);
-    newWriter = (Writer* (*)(const std::string&, std::shared_ptr<GenRunInfo>))dlsym(dll_handle, newwriter.c_str());
+    using  f_funci =  Writer* (*)(const std::string&, std::shared_ptr<GenRunInfo>);
+    auto newWriter = (f_funci)dlsym(dll_handle, newwriter.c_str());
     if (!newWriter) { printf("Error  while loading function %s from  library %s: %s\n", newwriter.c_str(), libname.c_str(), dlerror()); m_writer = nullptr; return;   }
     m_writer = (Writer*)(newWriter(filename, run));
 #endif
 }
 
 WriterPlugin::~WriterPlugin() {
     if (m_writer) m_writer->close();
```

